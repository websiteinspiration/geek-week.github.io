<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‘ ğŸ¬ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ Daftar Lini Multithreaded: Masalah Keberadaan Elemen, Peningkatan Kinerja, dan Hubungan STL ğŸ•ï¸ ğŸ˜ ğŸ¤¶ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, para pengunjung Habr! 
 
 Artikel ini akan fokus pada daftar tertaut, multithreading, dan C ++. Saya segera mencatat bahwa ada setiap kesempatan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Daftar Lini Multithreaded: Masalah Keberadaan Elemen, Peningkatan Kinerja, dan Hubungan STL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, para pengunjung Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini akan fokus pada daftar tertaut, multithreading, dan C ++. Saya segera mencatat bahwa ada setiap kesempatan untuk meletakkan karya ini di rak dan menggunakannya di sejumlah kecil proyek pribadi. Alih-alih, saya masih memutuskan untuk meletakkannya di pengadilan publik - tiba-tiba itu tampak bagi seseorang yang berguna atau menarik. Selain itu, jika ternyata seseorang telah berhasil melakukan sesuatu seperti ini, tolong tunjukkan materi ini kepada saya. Namun, tidak peduli bagaimana saya mencoba google pada topik ini, semua upaya tidak berhasil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya juga mencatat bahwa ini bukan tentang daftar tertaut klasik, tetapi tentang pemikiran ulang kreatif saya tentang penggunaan struktur data ini dalam lingkungan multi-utas. Saya sedang mempertimbangkan skenario akses daftar multi-threaded intensif unordered. Ini berarti bahwa utas kapan saja, apa pun yang lainnya, dapat mengakses daftar dan melakukan operasi yang diperlukan. Jika dia hanya menambah atau mengubah elemen, ini tidak terlalu buruk. Jika ia juga menghilangkan elemen, berbagai fitur menarik mungkin muncul.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek ini, yang saya kerjakan sebagai hobi dan pengembangan diri, karena sejumlah alasan bertahan lama. </font><font style="vertical-align: inherit;">Selain itu, ketika saya mengerjakannya, saya secara intensif belajar: proyek dimulai tanpa sepengetahuan dan pemahaman STL dan dirancang sesuai itu, hanya menggunakan sarana internal bahasa C ++ itu sendiri. </font><font style="vertical-align: inherit;">Namun, kemudian saya sangat serius memodifikasinya dengan mempertimbangkan STL dan bahkan di bawah STL. </font><font style="vertical-align: inherit;">Apa yang saya dapatkan dari ini, menilai Anda, para pembaca yang budiman.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pemahaman paling lengkap tentang materi yang dijelaskan di sini, Anda perlu membaca buku-buku berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - "Desain Modern di C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - â€œWindows via C / C ++, Pemrograman Visual C ++â€.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - â€œPerpustakaan Standar C ++. </font><font style="vertical-align: inherit;">Panduan referensi. </font><font style="vertical-align: inherit;">Edisi Kedua â€atau buku serupa di STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar baris</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar linear adalah struktur data terkenal yang telah digunakan sejak zaman bahasa C dan sebelumnya. Elemennya adalah objek tertentu dalam memori yang memiliki koneksi dengan satu atau dua elemen serupa yang berdekatan - berikut adalah contoh untuk daftar yang ditautkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;â€¦   â€¦&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, daftar itu sendiri adalah program (sub) tertentu yang melakukan manipulasi dengan elemen-elemen ini. </font><font style="vertical-align: inherit;">Sebagai aturan, sebuah penunjuk ke awal dan, secara opsional, hingga akhir daftar diketahui: ini sudah cukup, mulai dari elemen pertama, melalui semua elemennya hingga akhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, saya menggambarkan informasi yang sudah dipelajari dan terkenal: itu adalah program pendidikan bagi mereka yang sama sekali tidak sadar. </font><font style="vertical-align: inherit;">Untuk perincian, misalnya, Anda dapat menghubungi di sini: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Linear (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Perpustakaan STL memiliki wadah luar biasa std :: daftar (daftar tertaut ganda), serta kembarannya - std :: forward_list (daftar tertaut tunggal). </font><font style="vertical-align: inherit;">Artinya, jika Anda tidak tertarik pada bagaimana daftar disusun dan berfungsi di dalamnya, dan Anda hanya ingin menggunakannya untuk tugas-tugas Anda, wadah yang diusulkan adalah pilihan Anda.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi ada satu hal tapi ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ulangi bahwa ketika saya mulai menganalisis topik ini, saya akan melakukan segalanya, hanya mengandalkan alat internal C ++ tanpa dukungan STL. </font><font style="vertical-align: inherit;">Nilai dari apa yang akan terjadi akan lebih rendah jika saya masih memutuskan untuk membicarakannya di sini. </font><font style="vertical-align: inherit;">Tetapi di sisi lain, saya benar-benar bebas dari konsep atau keterbatasan perpustakaan, dan karenanya tidak terikat oleh apa pun dan mencari pendekatan dengan pikiran terbuka dan kemandirian.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelumnya, di masa lalu yang jauh, sebagian besar komputer adalah single-core dan single-processor. Daftar linear adalah struktur data yang relatif sederhana dan transparan, dan bekerja dengannya tidak menyebabkan kesulitan tertentu. Sekarang bahkan smartphone telah menjadi multi-core. Dalam kondisi multithreading, bahkan struktur sederhana seperti daftar tertaut sangat rumit. Memastikan operasi yang benar dalam mode multi-threaded umumnya menyulitkan program apa pun, ini adalah fakta yang diketahui.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambil skenario abstrak pekerjaan intensif dengan daftar utas berbeda: masing-masing dapat menambah, menghapus, mengubah elemen, dll. Pada titik waktu yang sepenuhnya arbitrer. Di satu sisi, pekerjaan dengan daftar dalam kasus ini terutama harus aman: jika ada pelanggaran data dan perilaku program yang tidak terdefinisi, ini akan menjadi solusi yang sepenuhnya tidak tepat. Di sisi lain, saya sangat ingin bekerja dengannya secepat mungkin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah pertama, daftar ini jelas harus diblokir, juga menyinkronkan akses ke sana. Masalah kedua - kinerja - ditangguhkan untuk saat ini.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini hanya mempertimbangkan memblokir seluruh daftar oleh aliran untuk akses eksklusif dari aliran ke sana. Pilihan lain tampak meragukan, misalnya, karena alasan berikut. Misalkan kita memiliki daftar yang ditautkan dua kali lipat, dan kami memutuskan untuk menghapusnya. Untuk melakukan ini, Anda harus memblokir simpul itu sendiri, serta yang sebelumnya dan berikutnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat ini, sebelum dimulainya operasi, utas lainnya hanya menghapus, misalnya, simpul sebelumnya. Kami memblokir yang dihapus dan berhenti menunggu rilis node sebelumnya diblokir oleh utas lainnya. Dan dia diblokir untuk menunggu selanjutnya untuknya, yaitu simpul kami yang terhapus. Itu saja, itu jalan buntu. Jadi metode ini tidak dapat diandalkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika utas Anda tidak menyimpan pointer (atau iterator) ke node tertentu, maka tugas ini sangat disederhanakan. Bahkan, Anda hanya bisa melakukannya dengan alat STL. Aliran memblokir daftar, merujuk pada elemen apa pun di dalamnya (misalnya, dari awal, dari akhir, atau dengan mencari di dalamnya sesuai dengan beberapa kriteria), memproses atau menghapus elemen ini, menambahkan yang baru tanpa menyimpan tautan ke dalamnya, dan kemudian melengkapi daftar. Semua ini - secara eksklusif memblokir akses ke daftar dalam satu utas, memilikinya selama durasi operasi yang diperlukan. Dalam hal ini, sangat logis untuk menggunakan std :: list dan fasilitas penguncian perpustakaan. Untuk semua ini, perlu dicatat bahwa sementara utas Anda melakukan semua pekerjaan yang diperlukan, utas lainnya akan berhenti menunggu, mis. bekerja dengan daftar akan dilakukan dalam mode single-threaded.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mempertimbangkan skenario lain yang lebih kompleks, ketika sebuah thread menyimpan pointer atau iterator ke elemen yang dibutuhkannya. </font><font style="vertical-align: inherit;">Misalnya, program Anda bekerja pada beberapa perhitungan kompleks, mengambil data awal dari item daftar, dan kemudian, setelah pemrosesan, memperbarui nilainya, menambahkan hasil perhitungan di sana. </font><font style="vertical-align: inherit;">Namun, utas lainnya juga memiliki akses ke daftar yang sama. </font><font style="vertical-align: inherit;">Saya tidak membuat asumsi tentang sifat aplikasi: utas lain dapat dengan mudah menghapus elemen ini karena suatu alasan. </font><font style="vertical-align: inherit;">Atau pindahkan ke tempat lain. </font><font style="vertical-align: inherit;">Dengan demikian, bekerja dengan daftar menjadi bermasalah tidak hanya karena alasan multithreading dan sinkronisasi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah keberadaan elemen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa perbedaan mendasar antara daftar dan, katakanlah, array? Dalam </font><font style="vertical-align: inherit;">pengaturan daftar item yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">didistribusikan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Semua elemen array terletak di area memori tunggal. Bahkan jika Anda menyimpan pointer ke beberapa elemennya, Anda yakin bahwa akses ke alamatnya akan benar (tentu saja, jika array tidak dipindahkan dalam memori ke lokasi lain dengan ekstensi ukurannya, misalnya). Jika elemen yang Anda butuhkan dihapus atau dipindahkan ke utas lain, Anda cukup pergi ke alamat sebelumnya, Anda akan memahami dengan beberapa tanda bahwa elemen yang Anda butuhkan tidak ada di sini, lalu coba mencarinya, dll. Tentu saja, program harus mendukung kesempatan seperti itu sebelumnya. Tetapi, bagaimanapun juga, operasinya akan tetap benar selama Anda berada dalam batas memori yang benar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi yang sama sekali berbeda adalah dalam kasus daftar (serta dalam kasus pohon, grafik - struktur data dengan elemen yang didistribusikan). Jika sebuah elemen sesuai dengan pointer Anda dihapus di utas lain, Anda bahkan tidak akan mengetahuinya, dan jika Anda mencoba mengakses alamatnya, Anda akan menerima pelanggaran akses (paling banter). Bahkan jika itu tidak benar-benar dihapus dari memori (misalnya, jika smart pointer digunakan), itu akan dihapus dari daftar, mis. tidak akan menjadi bagian dari itu. Anda juga tidak akan tahu tentang ini. Pekerjaan yang benar dengan daftar rusak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, pekerjaan intensif multi-utas dengan daftar menciptakan skenario yang benar-benar fantastis. Anda bahkan dapat yakin bahwa semuanya baik-baik saja dengan elemen Anda dan pointer ke sana - hingga mengakses beberapa fungsi daftar untuk bekerja dengannya.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh. Biarkan ada bagian dari daftar, dan pointer ke node, yang kami tunjukkan sebagai (#), diteruskan ke beberapa metode daftar fungsi, sedangkan node yang terkait dengannya akan dilambangkan dengan angka relatif relatif terhadapnya. Pada saat fungsi dipanggil, diketahui bahwa elemen ini ada dan penunjuknya benar, yaitu, keadaan daftar di area ini adalah: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, biarkan simpul (#) dilewatkan sebagai parameter ke beberapa fungsi daftar. Fungsi ini, seperti biasa, diblokir sambil menunggu akses ke sana. Sementara dia menunggu, tiga utas bekerja di depannya, menghapus simpul (#) bersama-sama dengan yang berdekatan sehingga terjadi: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian 5 utas lainnya memasukkan 5 elemen lagi ke dalam daftar, dimulai dengan (-2). Kami menunjukkan elemen baru sebagai (nN), di mana N adalah angka relatif di antara lima, mulai dari nol:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu akhirnya aliran kami dipanggil, yang dipanggil dengan (#). Pertanyaannya adalah: apa yang harus dia lakukan dalam kasus ini, setelah semua (#) telah lama hilang? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jawaban: itu semua tergantung pada operasi, serta pada skenario untuk menggunakan daftar. Namun, karena kami mempertimbangkan kasus yang paling umum tanpa batasan, beberapa asumsi umum dapat dibuat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika ini adalah operasi hapus, maka cukup dengan hanya memeriksa apakah item yang ditentukan ada dalam daftar. Jika tidak, maka sudah dihapus, dan tidak ada lagi yang perlu dilakukan. Jika ya, maka hapus. Demikian pula untuk operasi membaca / mengubah isi node: jika node dihapus, maka sudah tidak ada yang membaca / memodifikasi. Tetapi masalah terbesar muncul selama operasi memasukkan node baru, serta ketika pindah ke yang berikutnya / sebelumnya. Di satu sisi, simpul yang ditentukan sudah tidak ada lagi, dan kegagalan dapat dikembalikan. Di sisi lain, simpul harus dimasukkan, dan situasi seperti itu dapat terjadi kapan saja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena prioritas (untuk kasus umum) masih keselamatan dan keandalan, dan hanya kecepatan, jelas bahwa ketika utas akhirnya mendapatkan waktu operasi di dalam fungsi, Anda harus menetapkan fakta keberadaan elemen dalam daftar: apakah sudah ada di sana atau belum? Ini menyelesaikan satu masalah: setidaknya kami tidak akan mengganggu seluruh daftar jika tidak ada simpul yang diminta di sana dan kami akan menghindari kesalahan akses memori dalam hal ini. Tapi itu tidak menyelesaikan masalah penyisipan dan transisi: tidak jelas ke mana harus memasukkan simpul baru dan pergi dari yang sudah dihapus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi untuk masalah keberadaan elemen akan dibahas secara rinci di bawah ini. </font><font style="vertical-align: inherit;">Pertanyaan tentang apa yang harus dilakukan ketika kami menemukan bahwa elemen tidak lagi ada, tetapi benar-benar diperlukan, berada di luar cakupan artikel ini, karena sepenuhnya tergantung pada algoritma pekerjaan menggunakan daftar program. </font><font style="vertical-align: inherit;">Tentu saja, itu harus mencakup skenario seperti itu dan reaksi yang sesuai dengannya: misalnya, jika tidak ada elemen, maka pergi ke bagian atas daftar atau melakukan beberapa operasi lain. </font><font style="vertical-align: inherit;">Hal utama yang perlu dipastikan dalam situasi ini adalah pengoperasian daftar yang benar dan aman, serta pemberitahuan situasi tersebut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian item langsung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan yang paling sederhana dan paling mudah adalah dengan memeriksa keberadaan elemen dalam daftar dengan secara berurutan melewatinya untuk mencari elemen yang diberikan. Itu hanya mencari elemen yang diberikan. Jika dia ada dalam daftar, kami bekerja dengannya. Jika tidak, maka, tergantung pada fungsinya, kami keluar dengan sukses atau gagal, dan membiarkan program panggilan memutuskan apa yang harus dilakukan dalam situasi ini. Yang utama adalah bahwa pekerjaan dengan daftar dalam hal apa pun akan benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode ini aman dan berfungsi penuh, tetapi, terutama untuk daftar besar, ini menyebabkan penurunan kinerja yang sangat besar. Bahkan, bekerja dengan daftar ternyata adalah single-threaded: daftar diblokir selama pencarian untuk elemen tertentu di dalamnya, dan utas lainnya tidak dapat mengaksesnya. Kedua, biaya overhead meningkat tajam - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masing-masing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operasi dengan daftar harus memeriksa apakah ada elemen yang diperlukan pada saat operasi, dan sebagian besar waktu dihabiskan bukan untuk pekerjaan yang bermanfaat, tetapi untuk memeriksa keberadaan elemen. </font><font style="vertical-align: inherit;">Namun demikian, pendekatan sederhana dan langsung ini sangat cocok untuk daftar volume kecil dan tidak terlalu intensif dengan operasi itu, serta pendekatan pertama untuk memecahkan masalah keberadaan elemen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bagaimana jika kita memiliki daftar dengan sejumlah besar elemen, dan bekerja dengannya sangat intensif: apakah banyak utas terus-menerus menambah, mengubah, dan menghapus elemen darinya? </font><font style="vertical-align: inherit;">Apakah ada cara untuk mempercepatnya?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memori atau kinerja</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada fakta yang diketahui bahwa peningkatan memori yang digunakan oleh program dapat meningkatkan kecepatan program. Sebagai contoh, suatu program sangat memanfaatkan hasil dari beberapa perhitungan. Alih-alih mengeksekusi semuanya lagi, Anda dapat menghitung semuanya di muka dan menyimpan hasilnya di beberapa tabel atau array. Kemudian program hanya mengakses sel yang diinginkan dalam tabel dan segera menerima nilai yang diinginkan, yang secara signifikan mempercepat pekerjaannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah pendekatan yang saya gunakan dalam kasus daftar. Buat bitmap. Kami menambahkan informasi layanan dari masing-masing elemennya, di samping penunjuk wajib ke elemen berikutnya dan, opsional, elemen sebelumnya, dua bidang baru: yang pertama adalah nomor uniknya dalam daftar ini, dan yang kedua adalah penunjuk ke daftar itu sendiri. Sekarang, ketika sebuah elemen dibuat, elemen tersebut diberi nomor unik, dan menetapkan unit dalam bitmap pada indeks yang sesuai. Ketika sebuah elemen dihapus, bit ini direset. Jumlah elemen yang dibuat terus meningkat setiap kali elemen baru dibuat - bit zeroed yang sudah digunakan tidak digunakan kembali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, ketika diperlukan untuk memeriksa keberadaan elemen yang diberikan, alih-alih mencarinya secara linear di seluruh daftar, bitmap diakses dengan mudah oleh indeks elemen ini di dalamnya, dan fakta keberadaannya segera ditetapkan, dan untuk waktu yang konstan, terlepas dari ukuran daftar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode ini memungkinkan Anda untuk mencapai kinerja maksimum, namun memiliki kelemahan serius. Pertama, Anda harus mengalokasikan memori untuk seluruh array sekaligus, bagian dari bit yang mungkin tidak diperlukan sama sekali selama program, tetapi memori ini dapat digunakan untuk kebutuhan lain. Masalah ini dan cara untuk memuluskan memori yang berlebihan akan dibahas di bawah ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelemahan kedua lebih serius dan menarik - setiap item daftar baru dibuat dengan jumlah yang meningkat secara monoton. Ini berarti bahwa cepat atau lambat bit bebas dari array akan habis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada titik ini, sayangnya, Anda harus berhenti, memblokir daftar dan mulai menayangkannya. Itu kompres bit dari array ini, menghapus semua bit nol dari elemen daftar yang sebelumnya dihapus sebelumnya, hanya menyisakan bit untuk elemen yang sebenarnya ada saat ini, menggeser semua bit ini ke awal array. Kita harus melalui seluruh daftar lagi, dan dalam mode single-threaded, menulis ulang semua indeks untuk setiap elemen. Manfaat nyata dari ini dibandingkan dengan pendekatan sebelumnya adalah bahwa dalam kasus ini hanya </font><b><font style="vertical-align: inherit;">satu yang</font></b><font style="vertical-align: inherit;"> akan dilakukan.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kali selama periode waktu yang lama. </font><font style="vertical-align: inherit;">Selanjutnya, daftar dapat terus berfungsi seperti sebelumnya dalam mode sangat cepat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, saya tidak bermaksud bahwa node hanya ditambahkan ke daftar, karena </font><font style="vertical-align: inherit;">dalam hal ini, semua bit array akan tunggal. </font><font style="vertical-align: inherit;">Saya sedang mempertimbangkan skenario di mana item dihapus dan ditambahkan secara intensif dan sewenang-wenang. </font><font style="vertical-align: inherit;">Itu </font><font style="vertical-align: inherit;">jumlah total item daftar dari awal kerjanya dapat sedikit berubah. </font><font style="vertical-align: inherit;">Tentu, pertanyaan memilih ukuran array tergantung pada sifat program. </font><font style="vertical-align: inherit;">Anda juga dapat selalu membuat array baru dengan volume yang lebih besar jika ukuran yang saat ini tidak cukup.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan nol bit dari elemen yang sebelumnya dihapus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melakukannya dengan cara lain: saat membuat elemen, cari bit nol pertama dari awal bitmap. Ini mengoptimalkan konsumsi memori, tetapi akan menyebabkan penurunan kinerja: sekarang lagi setiap kali Anda membuat elemen baru, Anda harus melakukan pekerjaan tambahan - lihat melalui array untuk mencari bit gratis. Tetapi dibandingkan dengan memeriksa keberadaan elemen dengan langsung melihat daftar, keuntungannya jelas: kita akan melihat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen yang berdekatan, dan setiap elemen dari array tersebut mengandung banyak bit, mis. </font><font style="vertical-align: inherit;">kami memproses banyak daftar node sekaligus (64 bit untuk sistem modern atau bahkan 128/256/512 jika menggunakan SSE / AVX). </font><font style="vertical-align: inherit;">Kami mencari kata pertama yang tidak sama dengan kata dengan semua unit bit, lalu kami mencari bit nol pertama dalam kata ini. </font><font style="vertical-align: inherit;">Bahkan, metode ini memiliki kecepatan sedang antara yang sebelumnya dan metode melihat langsung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi konsumsi memori untuk bit array yang tidak dihuni</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita menganggap pekerjaan panjang dan intensif dengan daftar, mengalokasikan sejumlah besar bit untuk itu. Tetapi kebetulan bahwa program tersebut sebenarnya bekerja secara berbeda: jarang mengakses daftar, melakukan operasi lain yang juga membutuhkan memori. Sebagai hasilnya, kami mendapatkan array bit yang hampir tidak terpakai dari volume besar dan masalah memori di bagian lain dari program ini. Ketidaknyamanan belaka! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux, sejauh yang saya tahu, secara otomatis menyelesaikan masalah ini (meskipun pengembang Linux yang berpengalaman membiarkan saya memperbaikinya, jika itu). Anda mengalokasikan memori untuk array, tetapi sebenarnya sistem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak mentransfer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memori ini ke array </font><font style="vertical-align: inherit;">sampai benar-benar diperlukan. Ada optimalisasi penggunaan memori. Windows tidak mengizinkan ini. Sebaliknya, itu memungkinkan, tetapi Anda harus melakukannya sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagi mereka yang sama sekali tidak terkini, saya akan menjelaskan: aplikasi Anda (lebih tepatnya, proses yang terkait dengannya), sistem mengalokasikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang alamat virtual yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besar - hingga 8 TB untuk Windows 64-bit. Memori fisik dalam sistem dapat jauh lebih sedikit - 8 atau 16 GB saat ini untuk komputer massal. </font><b><font style="vertical-align: inherit;">Menampilkan</font></b><font style="vertical-align: inherit;"> sistem operasi</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alamat ruang proses virtual Anda ke alamat memori fisik, melakukan ini secara transparan tanpa keterlibatan langsung Anda. Secara alami, sebagian besar memori virtual gratis dari suatu proses biasanya tidak dihuni. Jadi, ketika Anda meminta Windows untuk mengalokasikan memori dengan cara konvensional, ia secara bersamaan mengalokasikan memori ini baik di ruang virtual Anda dan dalam memori fisik. Jika Anda mengalokasikan bitmap volume besar, Anda berisiko segera menduduki semua memori yang tersedia pada mesin Anda tanpa menjamin bahwa memori ini mungkin diperlukan sama sekali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, seseorang dapat bertindak secara berbeda: menandai sebagian besar memori di ruang virtual proses, tetapi mentransfer fisik hanya jika benar-benar diperlukan. </font><font style="vertical-align: inherit;">Ini dapat dilakukan melalui penanganan pengecualian struktural di Windows, untuk detail, silakan merujuk ke buku oleh Richter D., Nazar K. - "Windows via C / C ++, Visual C ++ Programming".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini hanya akan menjadi ide dan teori, jika saya tidak mempraktikkan semua ide ini, dan tidak dalam bentuk program eksperimental sederhana: Saya melakukannya dengan hati-hati mungkin untuk produksi, bermaksud untuk menggunakannya dalam proyek nyata saya, oleh karena itu dalam bentuk ini Anda membutuhkannya dan bayangkan. </font><font style="vertical-align: inherit;">Saya pikir itu tidak adil dan terlalu egois untuk menerapkan apa yang dilakukan dalam sejumlah proyek saya yang terbatas jika ini bisa berguna atau setidaknya hanya menarik bagi kalangan pengembang yang luas. </font><font style="vertical-align: inherit;">Di sisi lain, pencipta perpustakaan Boost dan perpustakaan yang lebih khusus lainnya menawarkan karya mereka untuk semua orang benar-benar gratis. </font><font style="vertical-align: inherit;">Mengapa saya tidak bisa melakukan hal yang sama?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraksi - daftar tanpa data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membagi daftar menjadi dua level logis. Level pertama adalah daftar, yang masing-masing elemen tidak mengandung data yang berguna, tetapi hanya berisi informasi tambahan: pointer ke elemen tetangga, dan, secara opsional, dua bidang tambahan untuk mempercepat memeriksa keberadaan elemen dalam daftar. Namun, sudah pada level ini dimungkinkan untuk melakukan semua operasi dasar pada daftar: menambah dan menghapus elemen, memisahkan dan menggabungkan daftar, dll. Bahkan, saya fokus terutama pada level ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tingkat kedua adalah menambahkan data aktual ke item daftar, serta menambahkan operasi baru ke daftar untuk bekerja dengan data ini. Semua ini disediakan dalam C ++ oleh warisan. Namun detailnya akan dibahas di bawah ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rincian implementasi seperti itu menjadi dua level masuk akal: mengapa memperhitungkan ketersediaan data tertentu jika sejumlah operasi benar-benar independen dari data ini? Untuk setiap item daftar yang diberikan, Anda masih harus menghapusnya dan menambahkan yang baru ke daftar, serta melakukan operasi khas lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mulai dengan konsep yang sangat sederhana dan tidak rumit, diambil dari konstruksi bahasa C. Di awal artikel, pointer internal C dan C ++ digunakan di dalam dan di luar daftar. Satu-satunya perbedaan adalah bahwa penambahan data, sebagaimana ditunjukkan di atas, ditunda ke tanggal kemudian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan ada elemen daftar tanpa data, hanya berisi pointer (atau pointer) ke elemen tetangga. Kemudian kode yang sesuai untuk itu dapat secara skematis direpresentasikan sebagai berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;â€¦m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemen untuk daftar yang ditautkan secara tunggal berisi di dalamnya sendiri sebuah pointer ke elemen berikutnya, dan tidak lebih. Kelas daftar diparameterisasi oleh tipe elemen ini, menyiratkan bahwa tipe ini akan berubah pada tahap penambahan data. Ini berisi pointer ke elemen pertama dan terakhir di dalamnya. Karena saya awalnya menargetkan proyek ini hanya untuk Windows, bagian penting seperti SRWLock juga disertakan untuk memblokir daftar. Selanjutnya, konstruktor, destruktor, serta semua fungsi yang diperlukan untuk bekerja dengan daftar ditentukan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi ini mengandung dua masalah sekaligus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang pertama adalah akses terbuka ke konten informasi layanan elemen. Ini berarti bahwa, setelah memperoleh akses ke beberapa simpul, mis. memiliki pointer ke node ini, kita bisa langsung merujuk ke elemen selanjutnya atau sebelumnya.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini tidak dapat diterima terutama karena transisi ini melewati kunci dan, karenanya, melindungi daftar. Bahkan, misalkan memiliki pointer ke beberapa elemen pCurr, kami menyimpan nilai ke elemen berikutnya relatif ke dalam pointer pNext sebagai berikut: pNext = pCurr-&gt; pNext. Setelah itu, kami melakukan beberapa operasi panjang pada node pCurr ini. Pada saat yang sama, utas lainnya menghapus item daftar berikut tentang pCurr. Setelah selesai bekerja dengan pCurr, utas saat ini bergerak ke elemen berikutnya menggunakan nilai lama yang disimpan dalam pNext lokal dan menerima kesalahan akses atau perilaku yang tidak terdefinisi, karena elemen di alamat pNext lokal sudah tidak ada lagi, dan Anda perlu mengakses nilai yang diperbarui pCurr-&gt; pNext, jika item saat ini di pCurr, pada gilirannya,juga masih ada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua kesimpulan dapat diambil dari contoh ini untuk mencegah situasi ini:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari luar daftar, pergi ke simpul berikutnya / sebelumnya dan umumnya melakukan pekerjaan dengan elemen daftar hanya melalui fungsi (metode) dari kelas daftar yang mengunci daftar dan membuat akses ke daftar aman;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akses elemen sesegera mungkin segera sebelum mengaksesnya (misalnya, dapatkan pointer ke elemen berikutnya pNext = list.GetNext (pCurr) tidak di muka, tetapi segera sebelum kebutuhan untuk pindah ke node berikutnya muncul).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itulah sebabnya untuk menerapkan kesimpulan dari paragraf pertama, akses ke petunjuk ke elemen yang berdekatan dari luar harus dilarang:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah kedua sedikit lebih rumit. Untuk memahaminya, struktur kelas harus dijelaskan secara lebih rinci. Kelas daftar didefinisikan sebagai templat dan tidak berfungsi dengan elemen tipe ListElement_OneLinked, tetapi dengan tipe ListElement, diteruskan sebagai parameter templat. Ini dilakukan untuk dapat membuat node baru dengan data di dalam kelas. Untuk melakukan ini, Anda perlu mengetahui jenis simpul yang sedang dibuat. Tipe pasti dari daftar node belum diketahui: itu akan ditentukan kemudian bersama dengan data. Fungsi pembuatan elemen mengalokasikan memori untuknya, menginisialisasi pointer, dan kemudian mengembalikan pointer ke elemen yang dibuat dalam fungsi panggilan. Jadi dalam fungsi pemanggilan kelas turunan akan dimungkinkan untuk menginisialisasi properti lain dari elemen yang spesifik untuk kelas ini dan kemudian didefinisikan. Dengan kata lain,definisi yang tepat dari jenis node daftar dibiarkan untuk masa depan, dan agar daftar berfungsi dengan benar, hanya penting bahwa elemen-elemennya mengandung pointer pNext, sisanya tidak masalah sejauh ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, berdasarkan ListElement_OneLinked, kemudian oleh pewarisan, kelas baru akan dibuat untuk elemen dengan data spesifik dan diteruskan ke kelas List_OneLinked melalui parameter templat. Pada saat yang sama, kelas turunan baru akan dibuat berdasarkan List_OneLinked yang selanjutnya mendefinisikan operasi dengan data baru ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, bahkan opsi ini tidak sepenuhnya benar. Dalam versi sebelumnya dari kelas daftar, operasi konversi eksplisit tipe reinterpret_cast &lt;ListElement *&gt; (...) digunakan beberapa kali. Faktanya adalah bahwa kelas templat bekerja dengan tipe parameter templat ListElement, yang berasal dari ListElement_OneLinked / ListElement_TwoLinked. Dan dalam fungsi kelas, variabel dibuat dalam ekspresi tipe: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan pCurr-&gt; pNext di sini adalah pointer ke ListElement_OneLinked / ListElement_TwoLinked, sebagai anggota kelas dasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Output: Entah mendeklarasikan variabel yang menunjukkan tipe dasar eksplisit ListElement_OneLinked / ListElement_TwoLinked, atau melemparkannya ke tipe turunan secara eksplisit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, bahkan definisi eksplisit dari tipe dasar tidak benar, misalnya, dalam fungsi penghapusan daftar (pembersihan):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda mengubah jenis pointer:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ini berarti mereka akan dihapus oleh operasi</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hanya bagian-bagian dasar dari setiap node dalam daftar, yang salah. </font><font style="vertical-align: inherit;">Atau, sebagai opsi, pointer pCurr harus dikonversi ke jenis turunannya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, dalam hal apa pun, seseorang tidak dapat menghilangkan transformasi reinterpret_cast eksplisit dengan struktur kelas seperti itu, yang bukan solusi terbaik (lebih tepatnya, yang benar-benar buruk). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk alasan ini, untuk menghilangkan transformasi eksplisit seperti itu, diputuskan untuk mengubah kelas dasar untuk elemen (untuk daftar yang ditautkan dua kali lipat - serupa):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara singkat, ini dapat digambarkan sebagai berikut: elemen dasar daftar berisi pointer ke elemen lain, tetapi jenis pointer ini belum diketahui, karena dilewatkan oleh parameter template (definisi yang tepat dari tipe ini dibiarkan untuk masa depan). Dengan kata lain: pada tahap ini, jenis node daftar (yaitu apa yang akan terjadi pada akhirnya) belum ditentukan, itu akan ditentukan nanti. Tapi sekarang kita menyimpan pointer ke elemen masa depan, tipe belum dikenal. Jenis simpul daftar yang dihasilkan dilewatkan di sini sebagai parameter templat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, tidak ada konversi yang diperlukan, karena pointer dari tipe ListElement yang sama digunakan di mana-mana - baik di kelas daftar dan di kelas untuk node. ListElement di sini dan di kelas daftar adalah kelas terakhir untuk item dengan data tertentu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti bahwa sekarang kelas daftar telah menjadi seabstrak mungkin dari konten spesifiknya: hanya diketahui bahwa simpul-simpulnya mengandung pointer ke simpul-simpul lain yang serupa, dan menggunakan informasi ini, semua operasi dasar pada mereka dengan kunci multi-ulir yang sesuai dilakukan di kelas daftar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memecahkan masalah keberadaan elemen - pencarian sederhana (versi 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi pertama sangat sederhana dan mudah dan tidak melampaui kerangka yang dijelaskan di atas. </font><font style="vertical-align: inherit;">C ++ internal pointer digunakan, memori untuk elemen dialokasikan menggunakan operasi baru dan dihapus menggunakan delete, daftar diblokir pada bagian penting yang terkandung di dalamnya. </font><font style="vertical-align: inherit;">Saya tidak tahu atau curiga tentang cara perpustakaan STL, dan juga tentang tingkat di mana mereka membawa pemrograman dalam C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sudah pada tahap ini, dalam praktiknya, saya mengalami masalah keberadaan elemen yang dijelaskan sebelumnya dan menyadari bahwa hanya mengunci daftar tidak cukup. </font><font style="vertical-align: inherit;">Saya menavigasi daftar menggunakan fungsi yang sesuai dengan semua tindakan pencegahan, daftar itu diblokir dengan benar, tetapi program masih berhasil crash pada interval yang berbeda. </font><font style="vertical-align: inherit;">Saat itulah saya menemukan bahwa keberadaan elemen harus diperiksa, yang menyebabkan perubahan dalam logika fungsi-fungsi utama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan saya memberikan contoh fungsi menambahkan elemen setelah yang diberikan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlihat bahwa sebelum membuat elemen baru, ia memeriksa apakah elemen yang ditentukan ada dalam daftar dengan memanggil fungsi FindElement (...):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplikasi lebih lanjut dari kelas daftar multithreaded - kelas strategi (versi 18.02.2019, 11.27.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awalnya, proyek ini hanya ditujukan untuk Windows. Tetapi pada beberapa titik saya pikir, mengapa tidak menambah fleksibilitas untuk itu? Kenapa hanya windows? Lagi pula, daftar itu pada dasarnya diimplementasikan dalam C ++ murni, dari Windows hanya ada satu hal: bagian kritis dari SRWLock. Pada saat itu, saya sudah terbiasa dengan konsep kelas strategi. Anda dapat membaca tentang ini secara terperinci dalam buku Alexandrescu A. - "Desain modern dalam C ++." Ini menggambarkan banyak hal yang tidak biasa dan luar biasa yang dapat berguna bahkan sekarang, terlepas dari kenyataan bahwa buku tersebut sudah berusia 12 tahun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satunya adalah kelas strategi. Kelas strategi, pada kenyataannya, adalah perubahan perilaku kelas melalui template, seperti yang disebutkan B. Straustrup dalam bukunya yang terkenal. Hanya dalam buku Alexandrescu subjek ini diungkapkan secara luas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kelas Anda melakukan satu tindakan spesifik. </font><font style="vertical-align: inherit;">Anda dapat mengambil definisi tindakan ini di luar kelas, membuat kelas terpisah berdasarkan tindakan ini dan meneruskannya ke kelas sumber Anda sebagai parameter templat. </font><font style="vertical-align: inherit;">Ini menyulitkan kode, pembacaan dan pemahamannya, tetapi secara signifikan menambah fleksibilitas ke kelas Anda: untuk mengganti tindakan khusus ini dengan yang lain, yang serupa, Anda hanya perlu menulis strategi lain yang serupa dan meneruskannya ke kelas Anda sebagai parameter templat. </font><font style="vertical-align: inherit;">Sisa pekerjaan akan dilakukan oleh kompiler.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategi kunci</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menerapkan ini ke daftar yang dijelaskan, saya mengambil kunci melalui SRWLock ke dalam strategi yang terpisah, dan kemudian menulis beberapa strategi lain: melalui bagian kritis Windows yang biasa, melalui C ++ STL mutex, dll. </font><font style="vertical-align: inherit;">Maka akan dimungkinkan untuk menambahkan metode khusus Linux murni. </font><font style="vertical-align: inherit;">Dengan demikian, kelas telah menjadi tidak hanya cocok untuk Windows, tetapi saya selalu dapat dengan cepat mengkonfigurasi ulang kembali untuk Windows secara optimal, hanya dengan menentukan strategi yang diinginkan.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategi memori</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekitar titik ini, saya juga serius mulai belajar STL dan di antara alat pertama perpustakaan ini saya berkenalan dengan pointer cerdas. </font><font style="vertical-align: inherit;">Dan kemudian saya berpikir: mengapa saya tidak dapat menambahkan dukungan smart pointer ke daftar saya? </font><font style="vertical-align: inherit;">Lalu saya mengeluarkan jenis pointer, serta membuat dan menghapus data item daftar dalam strategi terpisah:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strategi serupa untuk pointer cerdas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strategi memori mengambil tiga parameter: jenis objek Type, serta pengalokasi memori dan penghapus. Berdasarkan pada jenis objek, strategi menciptakan jenis pointer ke tipe ini - baik Type * atau std :: shared_ptr, tergantung pada strategi, dan juga menawarkan fungsi yang sesuai untuk membuat dan menghapus objek. Fungsi-fungsi ini, jika kita berbicara tentang distributor dan penghapusan secara default, membuat objek baik melalui operasi Type baru atau melalui fungsi std :: make_shared (...). Semua ini berfungsi karena fakta bahwa pointer dereferencing sama untuk kedua pointer bawaan C ++ dan smart std :: shared_ptr. Tentu saja, dalam kasus daftar yang ditautkan ganda dan pointer pintar, untuk menghindari fitur yang tidak menyenangkan dari looping pointer, std :: lemah_ptr digunakan untuk pointer ke elemen sebelumnya,dan pada waktu kompilasi untuk daftar yang ditautkan dua kali lipat, tergantung pada strategi memori yang dipilih, Anda memilih cara melakukan dereferensi (ini adalah fitur baru C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, sekarang daftar tidak membuat elemen sendiri: itu mengarahkan panggilan ke strategi yang sesuai.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategi Ketersediaan Item</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, saya menempatkan solusi untuk masalah keberadaan elemen ke dalam strategi terpisah: jika daftar perlu memeriksa keberadaan beberapa elemennya, itu hanya mengalihkan panggilan ke strategi yang sesuai. Pendekatan pertama, langsung, dan canggung telah menjadi strategi pencarian langsung DirectSearch. Selanjutnya, saya mengembangkan dua strategi lagi berdasarkan dua pendekatan yang dijelaskan sebelumnya dengan bitmap dalam urutan deskripsi mereka: SearchByIndex_BitArray dan SearchByIndex_BitArray2. Untuk Windows, untuk kemungkinan secara bertahap menempati memori dengan bitmap saat mengisi, ia juga menambahkan dua strategi lagi: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal dan SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti disebutkan sebelumnya, agar strategi lanjutan ini berfungsi, item daftar harus mengandung indeks dalam bitmap dan penunjuk ke kelas dasar daftar (lihat di bawah), yaitu. </font><font style="vertical-align: inherit;">didefinisikan sebagai berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korelasi antara strategi memori dan strategi pemeriksaan elemen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah pemeriksaan lebih dekat, ternyata ada jebakan dalam hubungan antara strategi memori dan strategi untuk memeriksa keberadaan elemen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan Anda menggunakan pointer pintar sebagai strategi memori, serta strategi menggunakan bitmap untuk dengan cepat memeriksa item dalam daftar. Anda menghapus item, strategi memori mengatur ulang penunjuknya. Namun, elemen ini sebenarnya tidak dihapus dari memori, karena Anda memiliki smart pointer lain untuk itu dalam program panggilan Anda. Di masa depan, Anda membuka daftar dengan elemen ini, dan melakukan pengecekan dengan benar, merujuk pada datanya - indeks dalam bitmap dan penunjuk ke daftar. Elemen sebenarnya dihapus dari memori hanya ketika tidak ada lagi tautan ke sana.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini tidak terjadi ketika menggunakan pointer bawaan C ++. Dalam hal ini, strategi memori </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan menghapus item ini dari memori menggunakan operasi hapus. Di masa mendatang, Anda, seperti dalam kasus sebelumnya, merujuk ke daftar dengan elemen ini, dan itu akan mencoba </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengakses</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elemen di alamat ini untuk membaca indeks bitmap dan pointer ke daftar. Tetapi Anda tidak dapat melakukan ini: sebuah elemen telah dihapus dari memori! Dalam kasus terbaik, Anda akan mendapatkan pelanggaran akses, dalam perilaku terburuk, tidak terdefinisi ketika pustaka C ++, pustaka runtime, atau hanya sistem operasi yang menulis di sana nilai yang sepenuhnya sewenang-wenang yang dipertimbangkan oleh daftar dan mencoba menetapkan dari mereka fakta keberadaan elemen dalam daftar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, ternyata pointer internal hanya kompatibel dengan strategi pemeriksaan langsung DirectSearch, dan pointer cerdas dalam hal ini tidak hanya menawarkan keamanan bawaannya, tetapi juga peningkatan kinerja: hanya dengan penggunaannya bit array dapat digunakan yang secara signifikan meningkatkan kinerja daftar di mode multithreaded! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memastikan konsistensi dan menghilangkan konfigurasi strategi yang tidak kompatibel, saya menyertakan cek berikut di setiap kelas daftar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini membandingkan kelas strategi yang diteruskan ke daftar dan, jika mereka tidak kompatibel, berhenti kompilasi dengan output pesan kesalahan yang sesuai.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengecualian atau Pengembalian Kesalahan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awalnya, penanganan kesalahan daftar hanya dilakukan melalui pengecualian. </font><font style="vertical-align: inherit;">Tetapi entah bagaimana, di beberapa forum saya tidak ingat, saya membaca bahwa pengecualian memperlambat program, dan untuk kinerja maksimum Anda harus menggunakan pengembalian kesalahan tradisional. </font><font style="vertical-align: inherit;">Dia melakukannya dengan membuat dua kelas baru berdasarkan yang asli, hanya menulis ulang mereka untuk mengembalikan kesalahan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Kelas Dasar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi strategi di atas untuk memeriksa keberadaan elemen telah mengungkapkan satu masalah penting. Elemen daftar, seperti yang kita ingat, mengandung, di samping nomor unik dalam daftar ini, juga penunjuk ke daftar ini: setelah semua, kita dapat memiliki dua atau lebih daftar dalam program, yang masing-masing berisi bit array bendera sendiri untuk kehadiran elemen. Bagaimana memastikan bahwa elemen ini milik daftar khusus ini dan bukan milik orang lain? Hanya dengan menyimpan pointer ke seluruh daftar di dalam setiap elemen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa sekarang, dengan menambahkan berbagai strategi ke kelas daftar kami, kami telah menyulitkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipenya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Misalkan kita memiliki dua daftar berbeda dengan jenis elemen yang sama dan strategi memori yang sama, tetapi dengan strategi yang berbeda untuk mengunci dan memeriksa keberadaan elemen di dalamnya. Untuk kompiler, ini akan menjadi dua </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jenis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar. Pointer ke tipe apa yang akan disimpan dalam elemen? Selain itu, kelas untuk elemen tidak tahu sebelumnya strategi mana yang akan diterapkan, harus memperhitungkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semuanya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingat juga bahwa strategi pemblokiran, strategi untuk memeriksa keberadaan elemen, dan bahkan konektivitas (hanya terhubung atau terhubung dua kali lipat) dari daftar merujuk hanya pada perilaku daftar itu sendiri, tetapi sama sekali tidak berhubungan dengan </font><b><font style="vertical-align: inherit;">data</font></b><font style="vertical-align: inherit;"> yang disimpannya.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi kami, sebagai pengguna akhir kelas ini, tertarik pada data! </font><font style="vertical-align: inherit;">Jadi, di satu sisi, menggunakan kelas strategi, kami menambahkan fleksibilitas untuk diri kami sendiri, dan di sisi lain, kami mempersulit kehidupan kami dan menambah masalah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah mungkin entah bagaimana membuat serigala kenyang dan domba aman? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisa. </font><font style="vertical-align: inherit;">Anda dapat menyimpulkan pointer ke data dari kelas (mis., Dari tipe) daftar. </font><font style="vertical-align: inherit;">Selain dua tingkat organisasi dari daftar yang ditunjukkan di atas, satu lagi muncul - nol:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, karena </font><font style="vertical-align: inherit;">kelas nyata dari daftar diwarisi darinya, jika kita ingin mengakses data daftar terlepas dari jenis aslinya, kita harus merujuk ke ListBase kelas dasar. </font><font style="vertical-align: inherit;">Kami mendapatkan akses ke awal dan akhir daftar, dan kemudian bekerja dengan datanya seperti yang kita inginkan. </font><font style="vertical-align: inherit;">Jenis daftar tertentu, serta kombinasi strategi yang digunakan di dalamnya, tidak masalah.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sudah dalam ayunan penuh bekerja erat dengan STL dalam proyek nyata (bukan milikku :)), serta terus mempelajarinya dalam buku-buku, saya menarik perhatian pada for loop pada koleksi. </font><font style="vertical-align: inherit;">Bagaimanapun, siklus ini bukan hanya bagian dari STL, itu sudah menjadi bagian internal bahasa. </font><font style="vertical-align: inherit;">Saya pikir saya juga bisa menambahkan dukungan untuk itu dalam proyek saya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan ini, Anda perlu menambahkan dukungan untuk iterator, mengabstraksi dari cara spesifik bekerja dengan pointer dan menavigasi melalui daftar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh iterator:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang menjadi mungkin untuk menulis sebagai berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(â€¦)<font></font>
{<font></font>
      â€¦<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue memiliki tipe pointer ke item daftar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awalnya, saya memasukkan dukungan iterator hanya pada daftar yang didukung pengecualian. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasannya sederhana: karena kode di dalam loop tidak tersedia, tidak mungkin untuk menangani kesalahan dengan benar. </font><font style="vertical-align: inherit;">Yang tersisa adalah menangani pengecualian dengan membungkus lingkaran dalam blok percobaan. </font><font style="vertical-align: inherit;">Secara umum, berjalan daftar sedemikian rupa ketika utas lain secara intensif bekerja dengannya bukanlah ide yang baik: lebih baik untuk memblokir daftar sendiri, dan kemudian dengan tenang memeriksanya dalam mode single-threaded. </font><font style="vertical-align: inherit;">Tapi tetap saja, jika karena alasan tertentu Anda ingin melakukan persis sama seperti pada contoh di atas, maka sekarang ada peluang untuk ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generalisasi strategi untuk memeriksa keberadaan elemen pada wadah yang sewenang-wenang; </font><font style="vertical-align: inherit;">iterators untuk daftar tanpa pengecualian</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, saya awalnya merencanakan (dan masih berencana) untuk membuat tidak hanya daftar multi-threaded, tetapi juga pohon. Untuk beberapa kebutuhan mereka. Grafik juga dimungkinkan, tetapi pertama, saya tidak membutuhkannya, dan kedua, grafik adalah hal yang rumit dengan algoritma yang sangat sepele, dan saya tidak ingin menyelami tanpa kebutuhan khusus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam versi awal, strategi untuk memeriksa keberadaan elemen hanya berorientasi pada daftar, dan fungsinya menerima pointer ke elemen dan pointer ke kelas dasar daftar (ListBase *). Selanjutnya, saya berpikir: tetapi dalam kasus pohon, Anda harus melakukan hal yang persis sama! Apakah terpisah, tetapi pada dasarnya strategi yang sama persis?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusinya sederhana: abaikan daftarnya. </font><font style="vertical-align: inherit;">Ini berarti bahwa sekarang input akan diterima bukan oleh pointer ke elemen, tetapi oleh iterator. </font><font style="vertical-align: inherit;">Dan fungsi akan menjadi pelat untuk menerima pointer ke wadah dari jenis apa pun yang cocok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi sekarang fungsi aslinya, misalnya mendaftarkan daftar dalam bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berubah menjadi fungsi registrasi kontainer:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transisi melalui daftar oleh pointer diubah menjadi transisi melalui wadah abstrak menggunakan iterator. </font><font style="vertical-align: inherit;">Sekarang cukup bagi pohon untuk mengimplementasikan iteratornya, dan dukungannya dengan strategi ini sudah disediakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini membutuhkan pengulangan iterator ke daftar tanpa pengecualian, tetapi membuatnya tidak dapat diakses dari luar dan hanya ditujukan untuk penggunaan internal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptor data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah bekerja cukup intensif dengan STL, serta mengetik, meluncurkan dan mempelajari program pelatihan dari buku, saya menarik perhatian pada kesederhanaan bekerja dengan wadah STL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, perhatikan kode berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuat vektor dengan mengirimkannya jenis int yang saya butuhkan, dan hanya itu! Wadah segera siap untuk bekerja, jika saya tidak perlu mengubah beberapa parameter tambahan yang ditetapkan secara default, yang paling sering tidak terjadi! Bagi saya, melanjutkan dari organisasi tiga tingkat daftar, dalam setiap kasus saya harus terlebih dahulu membuat kelas baru untuk elemen, dan kemudian menulis kelas untuk daftar dengan data, menerapkan operasi khusus ke daftar akhir. Bayangkan berapa banyak pekerjaan! Dan jika Anda perlu membuat daftar lain untuk data lain, Anda harus mengulanginya lagi atau, dalam kasus ekstrim, menyalin kode sebelumnya, sedikit mengubahnya. Ini sudah menyerupai keributan yang sama dengan bahasa C dan Windows API, di mana untuk setiap tindakan elementer Anda harus mengisi semua data yang diperlukan untuk struktur, dan kemudian memanggil fungsi yang diinginkan. Dan ingatlah itu semuaAtau juga terus membaca MSDN, mempelajari argumen dari setiap fungsi baru! Rutin dan sangat tidak nyaman!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mulai mencari cara untuk mendapatkan kesempatan untuk membuat daftar saya dengan analogi dengan wadah STL sehingga saya tidak harus melakukan tugas yang sama setiap kali: membuat kelas terpisah untuk setiap item baru, dan kemudian kelas daftar terpisah untuk bekerja dengan elemen-elemen ini. Tipe. </font><font style="vertical-align: inherit;">Jadi ada adaptor untuk daftar dengan data data. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adaptor untuk daftar dengan data adalah kelas, dalam parameter template yang Anda lewati segera tipe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda butuhkan </font><font style="vertical-align: inherit;">, dan bukan elemen. </font><font style="vertical-align: inherit;">Tipe elemen, yang saya sebut tipe komposit elemen, berdasarkan data yang dibuatnya </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sendiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin terpisah yang layak disebutkan adalah akses ke data item. </font><font style="vertical-align: inherit;">Jenis elemen berisi operasi "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti bahwa jika ada pointer ke elemen pElement, maka untuk mengakses data yang disimpan di dalamnya, itu harus ditinjau dua kali:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali - untuk mengakses objek bertipe ListElementCompound_OneLinked oleh penunjuknya: ListElementCompound_OneLinked &amp; le = * pCurrElement, dan yang kedua kalinya - untuk mengakses data melalui operasi '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini terlihat sangat aneh dan tidak biasa, tetapi diasumsikan bahwa Anda tidak akan bekerja melalui pointer (untuk ini Anda sudah memiliki versi awal yang sudah jadi), tetapi melalui iterator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, saat membuat daftar berdasarkan adaptor, Anda menentukan strategi yang Anda butuhkan, seperti sebelumnya. </font><font style="vertical-align: inherit;">Berdasarkan pada semua parameter Anda, adaptor secara otomatis membuat jenis yang diperlukan dan meneruskannya ke daftar internal dasar, dari mana itu diwarisi. </font><font style="vertical-align: inherit;">Definisi kelas umum:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spesialisasi untuk daftar dengan pengecualian:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	â€¦<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlihat sangat tebal, bertingkat, dan jelek. Aku tahu. Tetapi kemudian definisi ini secara otomatis melakukan semua yang diperlukan, tanpa partisipasi langsung dari programmer yang berencana untuk menggunakannya. Dengan bantuan std :: conditional_t â€‹â€‹dan std :: is_same_v, strategi untuk memeriksa keberadaan elemen yang Anda kirimkan dibandingkan dengan strategi pencarian langsung dan, tergantung pada hasilnya, jenis elemen daftar yang sesuai dipilih: dengan indeks dalam bitmap dan penunjuk ke daftar atau tanpa . Ini akan menghemat memori Anda karena data tambahan yang tidak perlu di dalam setiap node jika Anda menggunakan strategi pencarian langsung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di dalam kelas, iterator khusus untuk itu hanya diimplementasikan, serta fungsi push_back () / push_front () yang diperlukan oleh analogi dengan STL, yang mengarahkan panggilan ke daftar multi-threaded dasar. </font><font style="vertical-align: inherit;">Anda dapat menambahkan fungsi-fungsi lain nanti, sehingga daftar menjadi sangat mirip dengan STL. </font><font style="vertical-align: inherit;">Tetapi pada saat yang sama akan ada dengan semua perlindungan dan opsi yang diperlukan untuk meningkatkan produktivitas di lingkungan multi-utas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bekerja dengan adaptor data mulai terlihat seperti ini. </font><font style="vertical-align: inherit;">Membuat objek daftar:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda puas dengan semua strategi dan parameter default, maka membuat daftar menjadi sangat singkat:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, di luar sama sekali tidak ada perbedaan dibandingkan dengan STL, kecuali bahwa nama kelas daftar berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda dapat bekerja dengannya seperti dalam cara lama, melalui fungsi-fungsi kelas dasar:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, angka dari 0 hingga 3 ditambahkan secara berurutan ke akhir daftar. Untuk mendapatkan argumen yang diteruskan ke konstruktor dari tipe yang dibuat ketika itu dibuat, Anda harus secara eksplisit meletakkan nilai-nilai dari tiga argumen pertama.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, ada ketidaknyamanan tertentu dalam secara eksplisit menunjukkan jenis, tetapi ini merupakan konsekuensi dari upaya untuk mengakses daftar lagi melalui fungsi sebelumnya untuk bekerja dengan pointer. </font><font style="vertical-align: inherit;">Jika Anda menambahkan fungsi kembali () ke adaptor, yang mengembalikan iterator, maka mengerjakannya tidak akan memiliki masalah seperti itu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menyesuaikan iterator dengan persyaratan STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
menjadi mungkin untuk menggunakan daftar dalam algoritma perpustakaan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
â€¦<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, Anda harus mengatur intersepsi dan penanganan pengecualian: semua contoh di atas adalah untuk bekerja dalam satu utas untuk menguji kompatibilitas dengan STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penggunaan algoritma STL memungkinkan hal yang menarik: Anda dapat menggunakan beberapa algoritma sekaligus, menjalankannya dalam beberapa utas secara paralel. Ini tidak dapat dilakukan dengan cara konvensional (misalnya, menggunakan std :: daftar dan cara memblokir) tanpa memiliki akses ke konten internal kelas daftar. Itu hanya mungkin untuk memblokir seluruh daftar selama durasi seluruh algoritma. Tentu saja, ini akan mempercepat pekerjaan untuk thread yang mengeksekusi algoritma, tetapi akan membuat daftar tidak dapat diakses oleh utas lainnya. Namun, jika Anda menerapkan kunci SRWLock "tipis" yang sama, Anda dapat menjalankan beberapa algoritma pada daftar secara bersamaan, jika mereka tidak mengubah daftar ini. Tetapi utas pertama yang akan ditulis akan berdiri menunggu selesainya operasi baca dari daftar oleh semua utas lainnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi daftar yang diusulkan memungkinkan Anda untuk mengatur pekerjaan dengannya secara lebih fleksibel. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat mengatur pekerjaan dengan daftar sedemikian rupa untuk mengeksekusi algoritma non-modifikasi di paruh pertama daftar dengan beberapa utas pada saat yang sama, sementara sejumlah utas lainnya dapat menambah atau mengubah sesuatu di paruh kedua daftar. </font><font style="vertical-align: inherit;">Fakta bahwa daftar diblokir selama durasi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operasi, dan bukan keseluruhan algoritma, akan memungkinkan "menulis" operasi tulis melalui urutan operasi membaca daftar, yang akan membuat bekerja dengannya lebih fleksibel, produktif dan efisien.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggabungkan dua varian kelas daftar dengan dan tanpa dukungan pengecualian menjadi satu dengan parameter boolean</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awalnya, daftar itu hanya dengan pengecualian. </font><font style="vertical-align: inherit;">Kemudian saya menambahkan yang baru - tanpa pengecualian pengembalian kesalahan, dan mengganti nama yang lama dengan penambahan huruf "E" dalam nama kelas: List_OneLinked_E dan List_TwoLinked_E. </font><font style="vertical-align: inherit;">Ini diperlukan untuk menunjukkan empat deklarasi kelas daftar di mana-mana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian saya memutuskan bahwa itu tidak nyaman karena berbagai alasan. </font><font style="vertical-align: inherit;">Mengapa kita memerlukan dua kelas yang sama sekali berbeda jika ini adalah daftar yang sama dengan atau tanpa dukungan pengecualian? </font><font style="vertical-align: inherit;">Saya menggabungkan kedua daftar dari masing-masing tipe menjadi satu kelas dengan parameter Boolean tambahan, dan implementasi spesifik mereka dengan dan tanpa pengecualian adalah dua spesialisasi dari satu kelas untuk parameter Boolean yang ditentukan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Template Operasi Penggabungan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operasi template dari menggabungkan daftar yang sebelumnya hanya berfungsi dengan daftar dengan tipe yang sama. Ini menggabungkan hanya daftar yang terhubung secara tunggal atau hanya daftar yang terhubung dua kali lipat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, jika Anda memikirkannya, tidak masalah apa jenis daftar yang terlibat dalam operasi: hanya terhubung atau terhubung dua kali lipat. Strategi pemblokiran mereka juga tidak penting, apa strategi mereka untuk memeriksa keberadaan elemen, dan apakah mereka mendukung penanganan pengecualian atau tidak. Semua ini hanya berlaku untuk organisasi daftar, tetapi tidak untuk data yang terkandung di dalamnya. Penting bahwa hanya tipe data dan strategi memori untuk elemen yang cocok. Karenanya, sekarang, setelah menggabungkan daftar dengan parameter Boolean tentang pengecualian, operasi input menerima daftar jenis apa pun dengan semua varian parameternya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, sebagai hasil dari jenis daftar, kompiler memilih, tergantung pada pengaturan parameter eksternal ce_bGetMinLinksList, daftar dengan konektivitas minimum atau maksimum dan, tergantung pada solusi ini, parameter yang sesuai digunakan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berdasarkan parameter yang dipilih, daftar hasil dibuat:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, pada daftar ini, pointer diatur ke awal daftar pertama dan akhir daftar kedua:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, daftar sebelumnya dihapus dan fungsi keluar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Titik lemah dari fungsi ini adalah penguncian ganda daftar dengan deadlock potensial:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat memperkenalkan beberapa fungsi untuk secara bersamaan mengunci dua daftar dalam operasi atom tunggal seperti std :: lock (mutex1, mutex2), namun, tidak semua strategi penguncian mendukung penguncian simultan dua objek sinkronisasi, seperti std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, dua daftar mungkin memiliki strategi penguncian yang berbeda. </font><font style="vertical-align: inherit;">Solusi untuk masalah ini (jika ada sama sekali) diserahkan ke masa depan.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilasi Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilasi diperiksa melalui proyek ListDataAdapterTest, awalnya ditulis dalam C ++ murni tanpa fitur khusus Windows, di Linux Ubuntu 16.04 LTS, kompiler g ++ 8.2.0. Sebagian besar nuansa minor mudah diperbaiki, dan proyek berhasil dikompilasi, dan output program bertepatan dengan output yang sama di bawah Windows. Namun, ini masalahnya jika Anda mengomentari garis menggabungkan daftar melalui operasi "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda membiarkannya apa adanya, kesalahan kompilasi akan terjadi dalam operasi "+" yang dijelaskan di atas, seolah-olah itu tidak dideklarasikan istimewa di kelas elemen komposit daftar. Kesalahan serupa terjadi di kelas strategi verifikasi langsung untuk elemen DirectSearch. Dalam Visual C ++, semuanya baik-baik saja di sini, namun, kesalahan yang sama ini muncul jika dalam kelas elemen komposit dan dalam kelas daftar mengomentari deklarasi operasi menggabungkan daftar dan DirectSearch sebagai hak istimewa. Tampaknya g ++ hanya melewatkan deklarasi ini dan mengeluh tentang anggota pribadi / yang dilindungi dari kelas yang sesuai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Dalam g ++ versi 9 (Ubuntu 20.04), kesalahan yang sama.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa pengumuman privilege dilewati dan bagaimana cara memperbaikinya, saya tidak mengerti. </font><font style="vertical-align: inherit;">Saya tidak pandai fitur kompiler GCC. </font><font style="vertical-align: inherit;">Meninggalkan momen ini juga untuk masa depan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kecuali untuk nuansa ini, tidak ada kesalahan kompilasi serius lainnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi struktur file header</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembaca yang budiman, saya menerbitkan proyek lengkap di bawah lisensi LGPL 3.0 di GitHub di: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ini adalah salah satu solusi yang terdiri dari beberapa proyek uji. </font><font style="vertical-align: inherit;">Kode utama daftar multithreaded, berdasarkan penerapannya melalui templat, terletak di beberapa file header:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - kelas dasar dari daftar tanpa data, yang mengimplementasikan semua operasi dasar dengan daftar, mungkin tanpa mendefinisikan data spesifik, serta adaptor STL serupa untuk data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - versi daftar dengan dukungan pengecualian.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - definisi kelas dasar untuk item daftar.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - definisi kode dan kelas kesalahan untuk pengecualian.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain file utama yang terdaftar, berikut ini juga diterapkan:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - strategi untuk bekerja dengan memori;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - strategi pemblokiran.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - strategi untuk memeriksa keberadaan elemen dalam daftar, dijelaskan secara abstrak untuk wadah apa pun dengan iterator.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain tugas akhir, saya juga menambahkan tiga versi lama di folder "Versi lama", sehingga Anda dapat mengevaluasi secara singkat bagaimana proyek berubah seiring perkembangannya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek utama, yang disebut Daftar, adalah program dengan antarmuka untuk Windows yang diimplementasikan secara hardcore melalui API Windows (Saya tidak tahu bagaimana lagi). Dalam program ini, Anda memilih jenis daftar (hanya terhubung atau terhubung dua kali lipat), dan juga menunjukkan jumlah elemen awal dan jumlah utas yang diinginkan. Item daftar berisi nilai 64-bit tunggal. Setelah membuat daftar, program di setiap utas dalam loop melompat maju atau mundur melalui daftar ke sejumlah elemen acak, dan kemudian menambahkan atau menghapus elemen. Tidak ada pekerjaan yang benar-benar bermanfaat dilakukan melalui daftar ini, dan semua energi dihabiskan untuk memanaskan atmosfer, tetapi ini tidak perlu: kita hanya perlu mengevaluasi operabilitas dan kinerja daftar dalam lingkungan multi-utas intensif.Ukuran kinerja adalah jumlah iterasi dari siklus di atas per detik, yang dilakukan oleh semua utas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar ini diatur dengan menunjukkan strategi yang sesuai dalam kode program dan kemudian mengkompilasi ulang. Semua strategi untuk program utama ditentukan dalam modul utama ListMain.cpp, strategi memori dipilih di ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, saya bereksperimen sedikit dengan eksperimen. Jujur saya akui. Terutama karena ada dalam beberapa kasus daftar item berubah secara signifikan. Agar kemurnian percobaan untuk mengukur kinerja, perlu dilakukan pengujian sedemikian rupa sehingga jumlah elemen rata-rata tidak berubah selama periode penelitian atau perubahan yang sangat tidak signifikan. Hanya dalam kondisi seperti itu akan adil untuk mengevaluasi nilai produktivitas berdasarkan nilai rata-rata. Jika ada yang tertarik, saya mengusulkan untuk mengatur eksperimen seperti itu sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak memperbaiki pengaturan awal tes karena alasan berikut. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, saya hanya malas.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertama, menurut pendapat saya, tidak ada yang tertarik pada nilai kinerja kuantitatif yang tepat</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan kesalahan yang dihitung</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : penting untuk mengevaluasi kinerja dan kinerja daftar dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cara yang berkualitas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kedua, ini memungkinkan Anda untuk mengevaluasi perubahan dalam kinerja daftar dengan pertumbuhan volumenya, yang juga merupakan informasi yang cukup penting dan menarik. </font><font style="vertical-align: inherit;">Karena alasan ini, saya tidak mengubah eksperimen asli. </font><font style="vertical-align: inherit;">Ketiga, kode pengujian yang sama dilakukan pada semua varian daftar, yang dalam pengertian ini menempatkan mereka dalam kondisi yang sama: fakta bahwa mereka berperilaku berbeda dalam kasus ini memungkinkan kita untuk menilai kualitas perubahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengaktifkan pengukuran kinerja, atur flag ce_bPerformanceMeasure di modul ListMain.cpp menjadi true. </font><font style="vertical-align: inherit;">Program ini akan membuat file "PerformanceMeasure.txt" dengan pasangan "jumlah elemen - jumlah siklus / detik", dipisahkan oleh simbol ":".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil Pengukuran Kinerja</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, saya tidak melakukan tes untuk semua kemungkinan konfigurasi daftar, karena ada banyak dari mereka. </font><font style="vertical-align: inherit;">Saya hanya fokus pada yang utama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengujian dilakukan atas pesanan saya yang sudah usang, tetapi konfigurasi masih sangat segar Intel Core i7-3930K, DDR3-1333, pengontrol memori 4-channel. </font><font style="vertical-align: inherit;">Kompilasi dilakukan melalui Visual Studio 2019 untuk mode Release x64, sistem operasi Windows 7 x64. </font><font style="vertical-align: inherit;">Saya tidak bermain dengan jumlah utas, jadi dalam semua pengujian, maksimum 12 utas yang tersedia dalam sistem ini selalu digunakan. </font><font style="vertical-align: inherit;">Daftar selalu dibuat dengan 10.000 item yang dipilih secara acak, dengan pengecualian tes terakhir.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian Strategi Memori</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan pointer bawaan, seperti yang saya sebutkan sebelumnya, hanya strategi pencarian langsung yang dapat digunakan untuk memeriksa keberadaan item dalam daftar. Dengan demikian, sehingga perbandingannya benar, dan untuk smart pointer, hanya strategi ini yang akan diterapkan dalam tes ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai strategi penguncian, bagian penting dengan kunci tipis dipilih sebagai yang paling produktif di Windows (lihat di bawah): ThreadLockingWin_SRWLock. Penanganan kesalahan dilakukan dengan mengembalikan kode kesalahan, mis. opsi tanpa pengecualian. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grafik ini menunjukkan jumlah siklus yang dilakukan oleh semua utas secara total per detik, tergantung pada durasi pengujian (dalam detik). Jelas, kinerja tidak konsisten karena sifat acak untaian yang mengakses daftar.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grafik kedua menunjukkan bagaimana jumlah item daftar berubah selama tes. Saya tidak akan membuat pernyataan bijaksana tentang jadwal ini, kecuali untuk yang sudah jelas: jelas bahwa mereka bekerja dengan cara yang sedikit berbeda, dan konektivitas daftar bersama dengan strategi memori berpengaruh. Daftar terkait ganda dengan pointer internal adalah satu-satunya yang secara tak terduga tidak berubah dalam ukuran rata-rata selama seluruh durasi tes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Produktivitas rata-rata (siklus) untuk periode yang diukur:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setidaknya dapat diperdebatkan bahwa opsi daftar dengan pointer pintar lebih lambat dari versi dengan pointer built-in, yang diharapkan. </font><font style="vertical-align: inherit;">Dalam kedua kasus, entah bagaimana ternyata yang terhubung secara tunggal lebih cepat daripada yang terhubung ganda, yang sekali lagi menunjukkan bahwa dalam mode multithreaded, banyak hal yang akrab dapat berubah.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menguji strategi ketersediaan barang</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang paling menarik adalah menguji strategi untuk memeriksa keberadaan elemen. Sebagai strategi memori, pointer pintar secara alami ditunjukkan karena alasan yang dijelaskan sebelumnya. Sisanya sama: mengunci dengan ThreadLockingWin_SRWLock dan menangani kesalahan dengan mengembalikan kode kesalahan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat mengatakan dengan pasti bahwa semua strategi bekerja kurang lebih sama. Hal ini dapat dimengerti: dalam daftar yang ditautkan sendiri, ketika Anda menghapus itemnya, Anda harus melihat daftar setiap kali ke item yang menunjukkan item yang akan dihapus. Ini membatalkan semua upaya untuk mengoptimalkan akses ke daftar dan mempercepat memeriksa keberadaan elemen di dalamnya. Oleh karena itu, daftar yang tertaut secara tunggal bukanlah pilihan terbaik untuk pekerjaan multithreaded yang mengalami gangguan intensif.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak akan memberikan grafik pada jumlah elemen: tidak ada yang menarik di sana. Saya hanya mencatat bahwa sekarang jumlah elemen dalam semua daftar meningkat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi yang sama sekali berbeda muncul untuk daftar yang ditautkan dua kali lipat. Untuk membuat grafik terlihat indah, saya bahkan mengecualikan strategi melihat langsung daftar DirectSearch darinya, karena oleh hasilnya jelas "jatuh" dari yang lain. Selain itu, saya meningkatkan jumlah elemen sebanyak 4 kali lipat, sehingga mencapai, tes berhenti.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama, kinerja mengakses daftar (serta beban prosesor, menjadi 99-100%) telah meningkat secara dramatis dan signifikan! Kedua, sepasang strategi dengan pengisian bit array secara berurutan memiliki kinerja yang kurang lebih sama yang tidak berubah selama pengujian. Kecepatan pasangan strategi kedua menurun secara nonlinier. Mengapa demikian, maka akan menjadi jelas dari grafik untuk jumlah node dalam daftar.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar dengan pasangan strategi pertama tumbuh dalam jumlah elemen, dan secara linear. Pasangan kedua memberikan pertumbuhan nonlinier secara signifikan, dan semakin besar jumlah elemen memiliki daftar, semakin lambat ia tumbuh. Ini bisa dimengerti sejak itu dengan peningkatan jumlah elemen saat membuat yang baru, rata-rata perlu untuk melihat lebih banyak bit dari array untuk mencari yang gratis. Pasangan strategi pertama tidak berurusan dengan ini, ia menggunakan bit baru untuk setiap elemen baru. Dengan demikian, daftar dengan strategi seperti itu memiliki kinerja akses maksimum dan paling dekat dengan daftar klasik: baik menciptakan dan menghapus elemen dilakukan dalam waktu yang konstan, terlepas dari jumlah elemen. Namun, itu memberikan beberapa jaminan integritas dan keamanan di lingkungan multi-threaded, meskipun dengan biaya sejumlah memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar dengan pasangan strategi kedua, tentu saja, terasa lebih lambat. Namun, ini masih jauh lebih cepat daripada opsi pemeriksaan langsung. Jadi Anda benar-benar dapat merekomendasikannya sebagai perantara dalam kinerja, tetapi lebih optimal dalam hal konsumsi memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, daftar dengan strategi pencarian langsung juga akan bekerja lebih lambat dengan peningkatan jumlah elemen di dalamnya: sejumlah besar elemen harus dilihat setiap kali. Hanya saja selama pengujian daftar tidak berhasil tumbuh begitu banyak sehingga menjadi nyata meskipun fluktuasi kinerja kacau.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai kinerja rata-rata menunjukkan bahwa strategi dengan bitmap selama pengisian berurutannya memungkinkan untuk meningkatkan produktivitas mengakses daftar sekitar 200 kali, yaitu. </font><font style="vertical-align: inherit;">2 urutan besarnya dibandingkan dengan strategi pencarian langsung. </font><font style="vertical-align: inherit;">Ini adalah perubahan yang sangat radikal. </font><font style="vertical-align: inherit;">Kinerja opsi dengan pengisian bit optimal-memori, seperti disebutkan di atas, tentu saja terasa lebih lambat, tetapi masih jauh lebih cepat daripada opsi dengan verifikasi langsung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu juga dicatat bahwa penggunaan mekanisme transfer memori berdasarkan permintaan agak memperlambat akses ke daftar. </font><font style="vertical-align: inherit;">Tidak terlalu kritis, tetapi efeknya ada dan terlihat, terutama - dalam varian dengan penggunaan memori yang ekonomis (garis kuning pada grafik).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian Strategi Blokir</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita lihat bagaimana kinerja daftar akan berubah ketika memilih strategi penguncian yang berbeda. </font><font style="vertical-align: inherit;">Saya menggunakan tiga jenis kunci: kunci "tipis" SRWLock, bagian kritis Windows biasa, dan mutasi STL. </font><font style="vertical-align: inherit;">Untuk sisa pengaturan, versi tercepat dari daftar digunakan: biconnected, smart pointer, strategi untuk memeriksa keberadaan elemen - SearchByIndex_BitArray, varian tanpa pengecualian. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda harapkan, kunci "tipis" meningkatkan kinerja hampir 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kecepatan bekerja dengan bagian kritis Windows dan mutasi STL hampir sama.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengecualian</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengevaluasi dampak pengecualian terhadap kinerja, saya melakukan tiga tes. </font><font style="vertical-align: inherit;">Dua yang pertama menggunakan daftar yang ditautkan dua kali lipat, smart pointer, strategi pemeriksaan kehadiran elemen - SearchByIndex_BitArray, dan bagian penting dari SRWLock. </font><font style="vertical-align: inherit;">Tes yang sama digunakan untuk tes terakhir, hanya kunci diganti dengan bagian kritis yang biasa untuk perbandingan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dapat dilihat bahwa dukungan untuk pengecualian benar-benar dapat mengurangi kecepatan pekerjaan, terutama jika Anda menggunakan opsi pemblokiran yang lebih â€œkasarâ€. </font><font style="vertical-align: inherit;">Namun, ingatlah bahwa dalam hal ini, dukungan untuk STL dan untuk loop dalam koleksi tidak akan tersedia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu adalah eksperimen berskala sangat besar bagi saya. Maksud saya bukan tes di atas, tetapi seluruh proyek. Dia tidak berharap dirinya begitu terseret. Namun demikian, saya melakukannya sepenuhnya dan sejauh yang saya rencanakan. Tentu saja, pada akhirnya, ini masih bukan versi final, tetapi hanya beberapa prototipe yang berfungsi, implementasi ide-ide yang dijelaskan di awal artikel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut hasil tes, jelas bahwa di bawah Windows itu ternyata menjadi daftar tertaut ganda tercepat dengan pointer pintar, strategi untuk memeriksa keberadaan elemen SearchByIndex_BitArray, bagian penting dari SRWLock dan tanpa pengecualian. Dalam konfigurasi ini, daftar menyediakan kinerja maksimum dengan akses kacau intensif ke berbagai thread dan perilaku paling dekat dengan daftar klasik dengan jaminan keamanan dalam mode multithreaded. Opsi dengan konsumsi memori yang lebih ekonomis juga sangat produktif (dibandingkan dengan verifikasi langsung DirectSearch), tetapi masih terasa lebih lambat daripada yang sebelumnya, dan kinerjanya menurun dengan peningkatan jumlah elemen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda berpikir bahwa saya akan berkampanye di sini untuk hal keren yang saya lakukan dan betapa hebatnya menggunakannya, maka tidak: pada kenyataannya, saya akan mulai dengan membuat Anda kecil hati. </font><font style="vertical-align: inherit;">Memang:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pikirkan tentang apakah mungkin menggunakan wadah dengan susunan elemen yang berbeda: misalnya array. </font><font style="vertical-align: inherit;">Itu tidak memiliki masalah seperti daftar.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    â€“       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   â€“     .    . ,   â€“          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategi dengan mentransfer memori ke bit array sesuai permintaan juga setidaknya sebagian membawa daftar multi-threaded lebih dekat ke yang klasik: setidaknya sampai array memori benar-benar penuh, itu akan memakan waktu persis seperti yang dibutuhkan. </font><font style="vertical-align: inherit;">Namun, ini memerlukan pengurangan kinerja.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Kerugian proyek:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan yang sebelumnya dicatat saling menghalangi dalam operasi daftar gabungan.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semoga ini menarik. Pemula bisa bermanfaat, karena semuanya dianggap dari yang sederhana sampai yang kompleks. Saya meminta para profesional untuk mengatakan berapa banyak, menurut pendapat Anda, ide-ide yang dijelaskan di sini dapat diterapkan dalam proyek nyata? Apakah ada kasus dalam aktivitas Anda ketika, menurut artinya, Anda membutuhkan daftar atau pohon, dan bukan wadah lain, tetapi itu menjadi hambatan dalam program Anda karena masalah yang dijelaskan di sini? Atau Anda harus banyak mengubah atau menyulitkan program. Jika Anda pernah bertemu ini sebelumnya, lalu bagaimana Anda mengatasi ini?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, pada dasarnya, proyek ini hanyalah realisasi pandangan saya sendiri tentang solusi dari masalah ini. </font><font style="vertical-align: inherit;">Kemungkinan ada beberapa opsi yang lebih baik. </font><font style="vertical-align: inherit;">Saya mengulangi pemikiran dari awal bahwa saya melakukannya pada awalnya untuk diri saya sendiri dan tidak berencana untuk menampilkannya di depan umum. </font><font style="vertical-align: inherit;">Tapi tetap saja, saya melakukannya karena alasan yang dijelaskan di sana, jadi saya akan senang menerima kritik yang membangun. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan peninjauan kode yang cermat, Anda dapat menemukan desain seperti itu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ilmu hitam ini layak mendapat artikel terpisah. </font><font style="vertical-align: inherit;">Benar, ini adalah hal yang bahkan kurang praktis daripada daftar multi-utas yang dijelaskan di sini, tetapi ia memiliki fitur anehnya sendiri. </font><font style="vertical-align: inherit;">Jika Anda tertarik dari mana asalnya dan mengapa itu muncul, dan Anda ingin saya membicarakannya nanti secara terperinci, tulis di komentar.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id506702/index.html">HDD yang paling andal menurut Backblaze Q1 2020</a></li>
<li><a href="../id506704/index.html">Mengapa menulis dalam PHP pada tahun 2020? Holivarim adalah podcast interaktif di Youtube Kamis ini</a></li>
<li><a href="../id506706/index.html">Kinerja Java modern ketika bekerja dengan sejumlah besar data, bagian 1</a></li>
<li><a href="../id506708/index.html">Otentikasi dua faktor VPN / Mikrotik - sederhana dan dapat diskalakan</a></li>
<li><a href="../id506710/index.html">Kelola beberapa buku alamat di Edisi Terbuka Sumber-Sumber Zimbra Collaboration</a></li>
<li><a href="../id506726/index.html">Pengalaman dalam menggunakan teknologi Rutoken untuk registrasi dan otorisasi pengguna dalam sistem (bagian 2)</a></li>
<li><a href="../id506730/index.html">Mendengus atau Suricata. Bagian 1: pilih IDS / IPS gratis untuk melindungi jaringan perusahaan</a></li>
<li><a href="../id506732/index.html">Penggunaan kembali komponen UI di seluruh organisasi</a></li>
<li><a href="../id506734/index.html">Perhitungan sementara dalam jaringan listrik</a></li>
<li><a href="../id506736/index.html">Berapa banyak metode yang harus di kelas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>