<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßú ‚ò∏Ô∏è üêú Como escalar uma √°rvore ‚ÜñÔ∏è ü§™ ü§πüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mais precisamente, como se livrar disso. Mas as primeiras coisas primeiro. Este artigo est√° um pouco fora do formato usual de artigo do PVS-Studio. Mu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como escalar uma √°rvore</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/502518/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/qz/ys/qfqzys_fndtbks6hb68atbrnyrq.png" alt="Quadro 2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais precisamente, como se livrar disso. </font><font style="vertical-align: inherit;">Mas as primeiras coisas primeiro. </font><font style="vertical-align: inherit;">Este artigo est√° um pouco fora do formato usual de artigo do PVS-Studio. </font><font style="vertical-align: inherit;">Muitas vezes escrevemos sobre a verifica√ß√£o de outros projetos, mas quase nunca abrimos a porta da nossa cozinha interna. </font><font style="vertical-align: inherit;">√â hora de corrigi-lo e falar sobre como o analisador √© constru√≠do por dentro. </font><font style="vertical-align: inherit;">Mais precisamente, sobre a parte mais importante de suas partes - a √°rvore de sintaxe. </font><font style="vertical-align: inherit;">O artigo se concentrar√° na parte do PVS-Studio relacionada √†s linguagens C e C ++.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiras coisas primeiro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A √°rvore de sintaxe √© a parte central de qualquer compilador. De uma forma ou de outra, o c√≥digo precisa ser apresentado de uma forma conveniente para o processamento do programa, e acontece que a estrutura da √°rvore √© mais adequada para isso. N√£o vou entrar em teoria aqui - basta dizer que a √°rvore reflete muito bem a hierarquia de express√µes e blocos no c√≥digo e, ao mesmo tempo, cont√©m apenas os dados necess√°rios para o trabalho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que o compilador tem a ver com o analisador est√°tico? O fato √© que essas duas ferramentas t√™m muito em comum. No est√°gio inicial de analisar o c√≥digo, eles fazem o mesmo trabalho. Primeiro, o c√≥digo √© dividido em um fluxo de tokens, que √© alimentado ao analisador. Em seguida, no processo de an√°lise sint√°tica e sem√¢ntica, os tokens s√£o organizados em uma √°rvore, que √© enviada mais adiante ao longo do pipeline. Nesse est√°gio, os compiladores podem executar otimiza√ß√µes intermedi√°rias antes de gerar c√≥digo bin√°rio, os analisadores est√°ticos come√ßam a ignorar os n√≥s e a executar v√°rias verifica√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No analisador PVS-Studio com uma √°rvore constru√≠da, v√°rias coisas acontecem:</font></font><br>
<br>
<ul>
<li>    .    , , ,     <i>using </i>  <i>typedef</i>,   . ,  .         ;</li>
<li>     .  ,          ;</li>
<li>   ,      ,    ,      ;</li>
<li>  .        (      ).          . ,         <i>nullptr</i>    ,    ,         .       ;</li>
<li>  .      ,      .        ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ estiver interessado nos detalhes de como a an√°lise funciona, recomendo a leitura do artigo ‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tecnologias usadas no analisador de c√≥digo PVS-Studio para encontrar erros e poss√≠veis vulnerabilidades</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù. </font><font style="vertical-align: inherit;">Alguns pontos da lista s√£o examinados em detalhes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veremos com mais detalhes o que acontece com a √°rvore dentro do analisador e como ela se parece. </font><font style="vertical-align: inherit;">Com uma breve introdu√ß√£o, √© hora de chegar ao fundo do assunto.</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/xk/o4/sixko4j1_uucanebxzup6slqpf8.png" alt="Imagem 1"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como funciona</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historicamente, o PVS-Studio usa uma √°rvore bin√°ria para representar o c√≥digo. Essa estrutura de dados cl√°ssica √© familiar a todos - temos um n√≥ que geralmente se refere a dois filhos. N√≥s que n√£o deveriam ter descendentes, chamarei terminais, todos os outros - n√£o terminais. Um n√£o-terminal pode, em alguns casos, n√£o ter n√≥s filhos, mas sua principal diferen√ßa em rela√ß√£o ao terminal √© que os descendentes s√£o fundamentalmente permitidos para ele. Os n√≥s terminais (ou folhas) n√£o t√™m a capacidade de se referir a algo diferente do pai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura usada no PVS-Studio √© um pouco diferente da √°rvore bin√°ria cl√°ssica - isso √© necess√°rio por conveni√™ncia. </font><font style="vertical-align: inherit;">N√≥s de terminal geralmente correspondem a palavras-chave, nomes de vari√°veis, literais e assim por diante. </font><font style="vertical-align: inherit;">N√£o terminais - v√°rios tipos de express√µes, blocos de c√≥digo, listas e similares, os elementos constituintes da √°rvore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do ponto de vista dos compiladores, tudo √© bastante padr√£o aqui, aconselho a todos os interessados ‚Äã‚Äãnos cl√°ssicos do g√™nero - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Dragon Book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estamos seguindo em frente. </font><font style="vertical-align: inherit;">Vejamos um exemplo de c√≥digo simples e como o analisador o v√™. </font><font style="vertical-align: inherit;">Al√©m disso, haver√° muitas fotos do nosso utilit√°rio interno de visualiza√ß√£o em √°rvore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, um exemplo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">return</span> a + b;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa fun√ß√£o simples ap√≥s o processamento pelo analisador ter√° a seguinte apar√™ncia (n√≥s n√£o terminais s√£o destacados em amarelo):</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/nj/od/eonjodrufyrv6p3w2riiysnfnpo.png" alt="Quadro 6"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa vis√£o tem seus pr√≥s e contras, e a √∫ltima, na minha opini√£o, um pouco mais. Mas vamos olhar para a √°rvore. Fa√ßa imediatamente uma reserva de que √© um pouco redundante, por exemplo, porque cont√©m pontua√ß√£o e par√™nteses. Do ponto de vista da compila√ß√£o, isso √© um lixo sup√©rfluo, mas essas informa√ß√µes s√£o algumas vezes necess√°rias ao analisador para algumas regras de diagn√≥stico. Em outras palavras, o analisador n√£o funciona com a √°rvore de sintaxe abstrata (AST), mas com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a √°rvore de an√°lise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (DT). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A √°rvore cresce da esquerda para a direita e de cima para baixo. Os n√≥s filhos esquerdos sempre cont√™m algo significativo, como declaradores. Se voc√™ olhar para a direita, veremos os n√£o terminais intermedi√°rios marcados com a palavra </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles s√£o necess√°rios apenas para que a √°rvore retenha sua estrutura. </font><font style="vertical-align: inherit;">Para as necessidades de an√°lise, esses n√≥s n√£o carregam nenhuma carga de informa√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto estaremos interessados ‚Äã‚Äãna parte esquerda da √°rvore. </font><font style="vertical-align: inherit;">Aqui est√° em um close maior:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/vf/gm/ku/vfgmku_i7oq4oakzu_2gnowmfk8.png" alt="Quadro 10"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este an√∫ncio apresenta. </font><font style="vertical-align: inherit;">O n√≥ pai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um objeto atrav√©s do qual voc√™ pode acessar n√≥s com o nome da fun√ß√£o e seus par√¢metros. </font><font style="vertical-align: inherit;">Ele tamb√©m armazena a assinatura codificada para o sistema de tipos. </font><font style="vertical-align: inherit;">Parece-me que esta imagem √© bastante visual e √© muito f√°cil comparar os elementos da √°rvore com o c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece f√°cil, certo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para maior clareza, vamos dar um exemplo mais simples. </font><font style="vertical-align: inherit;">Imagine que temos um c√≥digo que chama nossa fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">f(<span class="hljs-number">42</span>, <span class="hljs-number">23</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma chamada de fun√ß√£o na √°rvore ter√° a seguinte apar√™ncia:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/jx/r2/mfjxr27uqexjmd3olssajdys7lw.png" alt="Quadro 12"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura √© muito semelhante, somente aqui vemos uma chamada de fun√ß√£o em vez de sua declara√ß√£o. Agora, suponha que desej√°ssemos passar por todos os argumentos e fazer algo com cada um deles. Essa √© uma tarefa real, frequentemente encontrada no c√≥digo do analisador. √â claro que tudo n√£o se limita a argumentos e que tipos diferentes de n√≥s precisam ser classificados, mas agora consideraremos este exemplo espec√≠fico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que tenhamos apenas um ponteiro para o n√≥ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FUNCALL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pai </font><font style="vertical-align: inherit;">. De qualquer n√£o terminal, podemos obter os n√≥s filhos esquerdo e direito. O tipo de cada um deles √© conhecido. Conhecemos a estrutura da √°rvore, para que possamos alcan√ßar imediatamente o n√≥ sob o qual est√° a lista de argumentos - este √© o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , do qual o terminal cresce na figura </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√£o sabemos o n√∫mero de argumentos com anteced√™ncia e h√° v√≠rgulas na lista que, nesse caso, n√£o s√£o de nosso interesse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como faremos isso? </font><font style="vertical-align: inherit;">Leia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√°brica de bicicletas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que iterar atrav√©s de uma √°rvore √© bastante simples. Voc√™ s√≥ precisa escrever uma fun√ß√£o que fa√ßa isso e us√°-la em qualquer lugar. √â poss√≠vel passar um lambda como argumento para manipular cada elemento. Realmente seria assim, se n√£o fosse por algumas nuances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, andar em volta de uma √°rvore sempre deve ser um pouco diferente. A l√≥gica do processamento de cada n√≥ √© diferente, bem como a l√≥gica do trabalho com a lista inteira. Digamos, em um caso, queremos examinar os argumentos da lista e passar cada um deles para uma determinada fun√ß√£o para processamento. Em outro, queremos selecionar e retornar um argumento que atenda a alguns requisitos. Ou filtre a lista e descarte quaisquer elementos desinteressantes dela.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, √†s vezes voc√™ precisa conhecer o √≠ndice do elemento atual. </font><font style="vertical-align: inherit;">Por exemplo, queremos processar apenas os dois primeiros argumentos e parar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terceiro, vamos desviar do exemplo da fun√ß√£o. </font><font style="vertical-align: inherit;">Digamos que temos um c√≥digo como este:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">int</span> c = a + b;<font></font>
  c *= <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> c;
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse c√≥digo √© idiota, eu sei, mas vamos nos concentrar agora na apar√™ncia da √°rvore. </font><font style="vertical-align: inherit;">J√° vimos uma declara√ß√£o de fun√ß√£o, aqui precisamos do seu corpo:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/q6/hs/f0q6hsldd42blwuenxmv2t6vl7o.png" alt="Quadro 4"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este caso √© como uma lista de argumentos, mas voc√™ pode notar alguma diferen√ßa. </font><font style="vertical-align: inherit;">D√™ uma outra olhada na foto da se√ß√£o anterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ percebeu? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â isso mesmo, n√£o h√° v√≠rgulas nesta lista, o que significa que voc√™ pode process√°-lo em uma linha e n√£o se preocupar em ignorar separadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No total, temos pelo menos dois casos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista separada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lista completa.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como tudo isso acontece no c√≥digo do analisador. Aqui est√° um exemplo de percorrer uma lista de argumentos. Esta √© uma vers√£o simplificada de uma das fun√ß√µes no tradutor.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessArguments</span><span class="hljs-params">(Ptree* arglist)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  Ptree* args = Second(arglist);<font></font>
  <span class="hljs-keyword">while</span> (args)<font></font>
  {<font></font>
    Ptree* p = args-&gt;Car();<font></font>
    <span class="hljs-keyword">if</span> (!Eq(p, <span class="hljs-string">','</span>))<font></font>
    {<font></font>
      ProcessArg(p);<font></font>
    }<font></font>
<font></font>
    args = args-&gt;Cdr();<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se eu recebesse um d√≥lar toda vez que vir um c√≥digo semelhante, j√° ficaria rico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver o que acontece aqui. Devo dizer imediatamente que esse c√≥digo √© muito antigo, escrito muito antes do C ++ 11, sem mencionar os padr√µes mais modernos. Podemos dizer que procurei especificamente um fragmento dos tempos das civiliza√ß√µes antigas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, primeiramente, essa fun√ß√£o aceita uma lista de argumentos entre par√™nteses como entrada. Algo assim: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(42, 23) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fun√ß√£o </font><font style="vertical-align: inherit;">√© chamada aqui para obter o conte√∫do dos colchetes. Tudo o que ela faz √© mover uma vez para a direita e depois para a esquerda atrav√©s da √°rvore bin√°ria. Em seguida, o loop obt√©m sequencialmente os elementos: 42, depois uma v√≠rgula, depois 23 e, na pr√≥xima etapa, o ponteiro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">args</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">torna-se zero porque chegamos ao final do ramo. O loop, √© claro, pula v√≠rgulas desinteressantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fun√ß√µes semelhantes com l√≥gica ligeiramente alterada podem ser encontradas em muitos lugares, especialmente no c√≥digo antigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro exemplo. Como sei se h√° uma chamada para uma determinada fun√ß√£o em um determinado bloco de c√≥digo? Curtiu isso:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFunctionCalled</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* body, <span class="hljs-built_in">std</span>::string_view name)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">const</span> Ptree* statements = body;
  <span class="hljs-keyword">while</span> (statements)<font></font>
  {<font></font>
    <span class="hljs-keyword">const</span> Ptree* cur = statements-&gt;Car();
    <span class="hljs-keyword">if</span> (IsA(cur, ntExprStatement) &amp;&amp; IsA(cur-&gt;Car(), ntFuncallExpr))<font></font>
    {<font></font>
      <span class="hljs-keyword">const</span> Ptree* funcName = First(cur-&gt;Car());
      <span class="hljs-keyword">if</span> (Eq(funcName, name))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    statements = statements-&gt;Cdr();<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota. </font><font style="vertical-align: inherit;">Um leitor atento pode perceber. </font><font style="vertical-align: inherit;">Quantos anos tem ele? </font><font style="vertical-align: inherit;">L√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: string_view</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se destaca. </font><font style="vertical-align: inherit;">Tudo √© simples, mesmo o c√≥digo mais antigo √© gradualmente refatorado e gradualmente nada permanece. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seria bom usar algo mais elegante aqui, certo? </font><font style="vertical-align: inherit;">Bem, por exemplo, o algoritmo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> padr√£o </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Qual √© o algoritmo existente, mesmo para um intervalo normal, melhoraria bastante a legibilidade e facilitaria o suporte a esse c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar conseguir isso.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloque a √°rvore na caixa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso objetivo √© fazer com que a √°rvore se comporte como um cont√™iner STL. </font><font style="vertical-align: inherit;">Al√©m disso, n√£o devemos nos preocupar com a estrutura interna das listas, queremos iterar uniformemente os n√≥s, por exemplo, assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomethingWithTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* tree)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : someTreeContainer)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, aqui temos uma certa entidade chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">someTreeContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sobre a qual ainda n√£o sabemos. </font><font style="vertical-align: inherit;">Esse cont√™iner deve ter pelo menos m√©todos de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in√≠cio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que retornem iteradores. </font><font style="vertical-align: inherit;">Falando em iteradores, eles tamb√©m devem se comportar como os padr√£o. </font><font style="vertical-align: inherit;">Vamos come√ßar com eles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso mais simples, o iterador fica assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer   = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    m_node = Rest(m_node);<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para n√£o bagun√ßar o c√≥digo, removi alguns detalhes. </font><font style="vertical-align: inherit;">Os pontos principais aqui s√£o desreferenciamento e incremento. </font><font style="vertical-align: inherit;">O modelo √© necess√°rio para que o iterador possa trabalhar com dados constantes e n√£o constantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos escrever o cont√™iner no qual colocaremos o n√≥ da √°rvore. </font><font style="vertical-align: inherit;">Aqui est√° a op√ß√£o mais simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terminamos, podemos dispersar, obrigado pela aten√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o, espere um momento. </font><font style="vertical-align: inherit;">N√£o pode ser t√£o simples, certo? </font><font style="vertical-align: inherit;">Vamos voltar √†s nossas duas op√ß√µes de lista - com e sem delimitadores. </font><font style="vertical-align: inherit;">Aqui, ao incrementar, simplesmente pegamos o n√≥ certo da √°rvore, para que isso n√£o resolva o problema. </font><font style="vertical-align: inherit;">Ainda precisamos pular v√≠rgulas se quisermos trabalhar apenas com dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o √© um problema, apenas adicionamos um par√¢metro de modelo adicional ao iterador. </font><font style="vertical-align: inherit;">Digamos assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIteratorTag</span> :</span> <span class="hljs-keyword">uint8_t</span><font></font>
{<font></font>
  Statement,<font></font>
  List<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator { .... };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como isso nos ajudar√°? </font><font style="vertical-align: inherit;">Elementar. </font><font style="vertical-align: inherit;">Verificaremos esse par√¢metro em incrementos e nos comportaremos de acordo. </font><font style="vertical-align: inherit;">Felizmente, no C ++ 17, podemos resolver isso no est√°gio de compila√ß√£o usando a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constru√ß√£o if constexpr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
  </span>{<font></font>
    m_node = Rest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    m_node = RestRest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melhor, agora podemos escolher um iterador para atender √†s nossas necessidades. </font><font style="vertical-align: inherit;">O que fazer com os cont√™ineres? </font><font style="vertical-align: inherit;">Voc√™ pode, por exemplo, assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t, tag&gt;;<font></font>
  ....<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, n√≥s definitivamente terminamos? </font><font style="vertical-align: inherit;">De fato, n√£o de verdade.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso n√£o √© tudo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos olhar para este c√≥digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu realmente n√£o gosto muito desse c√≥digo, come√ßando do loop com o contador e terminando com o fato de que a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parece muito suspeita. </font><font style="vertical-align: inherit;">Agora ele continua sendo uma caixa preta para n√≥s, mas podemos assumir que ele retira o elemento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelo √≠ndice e retorna seu nome e n√≥ na √°rvore atrav√©s dos par√¢metros de sa√≠da. </font><font style="vertical-align: inherit;">O valor de retorno tamb√©m √© um pouco estranho. </font><font style="vertical-align: inherit;">Vamos nos livrar completamente disso - um trabalho ideal para o nosso iterador de lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o √© ruim. </font><font style="vertical-align: inherit;">Somente esse c√≥digo n√£o √© compilado. </font><font style="vertical-align: inherit;">Por qu√™? </font><font style="vertical-align: inherit;">Como o √≠ndice que removemos foi usado no corpo do loop abaixo da chamada para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N√£o vou dizer aqui exatamente como foi usado, porque n√£o √© importante agora. </font><font style="vertical-align: inherit;">Basta dizer que √© necess√°rio um √≠ndice. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, vamos adicionar uma vari√°vel e estragar nosso belo c√≥digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i++);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainda √© uma op√ß√£o de trabalho, mas eu pessoalmente reajo a algo assim:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/11/ie/ov11ieyylfaa2qjppdyjjo-yljy.png" alt="Quadro 7"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, vamos tentar resolver esse problema. </font><font style="vertical-align: inherit;">Precisamos de algo que possa contar elementos automaticamente. </font><font style="vertical-align: inherit;">Adicione um iterador com um contador. </font><font style="vertical-align: inherit;">Mais uma vez, pulei os detalhes extras por quest√µes de concis√£o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeCountingIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos escrever esse c√≥digo, certo?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] :<font></font>
            PtreeCountedContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, realmente podemos, mas h√° um problema. </font><font style="vertical-align: inherit;">Se voc√™ observar esse c√≥digo, poder√° perceber que introduzimos outra entidade - algo chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeCountedContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Parece que a situa√ß√£o est√° ficando complicada. </font><font style="vertical-align: inherit;">Eu realmente n√£o quero fazer malabarismos com diferentes tipos de cont√™ineres e, como eles s√£o iguais por dentro, a pr√≥pria m√£o pega a navalha de Occam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teremos que usar um iterador como um par√¢metro de modelo para o cont√™iner, mas mais sobre isso mais tarde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de zool√≥gico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Distraia os contadores e variedades de iteradores por um minuto. </font><font style="vertical-align: inherit;">Em busca de um desvio universal de n√≥s, esquecemos a coisa mais importante - a pr√≥pria √°rvore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√™ uma olhada neste c√≥digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a, b, c = <span class="hljs-number">0</span>, d;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que vemos na √°rvore:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/cq/sh/micqshmftdnb7xstjo71sng02s4.png" alt="Quadro 13"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos agora percorrer a lista de declaradores, mas primeiro vou lhe contar outra coisa sobre a √°rvore. </font><font style="vertical-align: inherit;">Todo o tempo antes disso, est√°vamos lidando com um ponteiro para a classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Essa √© a classe base da qual todos os outros tipos de n√≥s s√£o herdados. </font><font style="vertical-align: inherit;">Atrav√©s de suas interfaces, podemos obter informa√ß√µes adicionais. </font><font style="vertical-align: inherit;">Em particular, o n√≥ superior da figura pode retornar para n√≥s a lista de declaradores sem usar fun√ß√µes utilit√°rias como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Al√©m disso, n√£o precisamos de m√©todos de baixo n√≠vel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ol√° para os f√£s da linguagem Lisp). </font><font style="vertical-align: inherit;">Isso √© muito bom, pois no diagn√≥stico podemos ignorar a implementa√ß√£o da √°rvore. </font><font style="vertical-align: inherit;">Acho que todo mundo concorda que as abstra√ß√µes atuais s√£o muito ruins.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â assim que o desvio de todos os declaradores se parece:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> PtreeDeclarator*&gt;(decl));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retorna um cont√™iner </font><i><font style="vertical-align: inherit;">iter√°vel</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Seu tipo nesse caso √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeContainer &lt;const Ptree, PtreeIteratorTag :: List&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esse c√≥digo, tudo ficaria bem se n√£o fosse o elenco. </font><font style="vertical-align: inherit;">O fato √© que a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessDecl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deseja um ponteiro para uma classe derivada da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas nossos iteradores n√£o sabem nada sobre isso. </font><font style="vertical-align: inherit;">Gostaria de me livrar da necessidade de converter tipos manualmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que √© hora de mudar o iterador novamente e adicionar a capacidade de transmitir.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para n√£o escrever todos esses argumentos de modelo manualmente a cada vez, adicionamos alguns apelidos para todas as ocasi√µes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© melhor. </font><font style="vertical-align: inherit;">Agora, se n√£o precisarmos de castas, podemos especificar apenas o primeiro argumento do modelo e tamb√©m n√£o podemos entupir o valor do par√¢metro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tag</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas o que fazer com os cont√™ineres? </font><font style="vertical-align: inherit;">Deixe-me lembr√°-lo de que queremos ter apenas uma classe universal adequada para qualquer iterador. </font><font style="vertical-align: inherit;">Agora s√£o indecentemente muitas combina√ß√µes diferentes, e precisamos de simplicidade. </font><font style="vertical-align: inherit;">Algo assim:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xc/nv/ik/xcnvik7rkulnyybu6jngdpcrv4w.png" alt="Quadro 39"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, queremos que uma √∫nica classe de cont√™iner seja capaz de dar suporte a todos os tipos de nossos iteradores e de dizer a eles que tipo retornar quando fizer o cancelamento da refer√™ncia. </font><font style="vertical-align: inherit;">Em seguida, no c√≥digo, simplesmente criamos o cont√™iner de que precisamos e come√ßamos a trabalhar com ele sem pensar em quais iteradores precisamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinaremos essa quest√£o na pr√≥xima se√ß√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Magia de padr√µes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o aqui est√° o que precisamos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um cont√™iner que pode funcionar universalmente com qualquer iterador.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um iterador, que, dependendo da lista de n√≥s, pode funcionar com cada elemento e atrav√©s de um.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mesmo iterador, mas com um contador.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos os iteradores devem ser capazes de converter quando derreferencing, se o tipo for especificado adicionalmente.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro de tudo, precisamos vincular de alguma forma o tipo de cont√™iner ao tipo de iterador atrav√©s dos par√¢metros do modelo. </font><font style="vertical-align: inherit;">Aqui est√° o que aconteceu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
  ....<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, voc√™ pode adicionar mais m√©todos ao cont√™iner. </font><font style="vertical-align: inherit;">Por exemplo, √© assim que podemos descobrir o n√∫mero de elementos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou aqui est√° o operador de indexa√ß√£o:</font></font><br>
<br>
<pre><code class="cpp hljs">value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  size_type i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (i++ == index)<font></font>
    {<font></font>
      <span class="hljs-keyword">return</span> *it;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> value_type{};<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â claro que voc√™ precisa lidar com esses m√©todos com cuidado devido √† sua complexidade linear, mas √†s vezes eles s√£o √∫teis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para facilitar o uso, adicione aliases:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos criar cont√™ineres facilmente. </font><font style="vertical-align: inherit;">Digamos, na classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclaration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j√° mencionada </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> queremos obter um </font><font style="vertical-align: inherit;">cont√™iner </font><font style="vertical-align: inherit;">do m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cujo iterador ignora os separadores, enquanto n√£o h√° contador, e quando desreferenciado, ele retorna um valor do tipo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aqui est√° a declara√ß√£o desse cont√™iner:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> DeclList =<font></font>
      Iterators::PtreeItemList&lt;Ptree, PtreeDeclarator*&gt;;<font></font>
<span class="hljs-keyword">using</span> ConstDeclList =<font></font>
      Iterators::PtreeItemList&lt;<span class="hljs-keyword">const</span> Ptree, <span class="hljs-keyword">const</span> PtreeDeclarator*&gt;;<font></font>
             :<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(decl);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, finalmente, como a infer√™ncia de tipo para aliases aparecer√° apenas em C ++ 20, para criar mais convenientemente cont√™ineres no c√≥digo, adicionamos essas fun√ß√µes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeStatementList&lt;Node_t&gt; <span class="hljs-title">MakeStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeItemList&lt;Node_t&gt; <span class="hljs-title">MakeItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedStatementList&lt;Node_t&gt; <span class="hljs-title">MakeCountedStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedItemList&lt;Node_t&gt; <span class="hljs-title">MakeCountedItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se da fun√ß√£o que trabalhou com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Agora podemos escrever assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] : MakeCountedItemList(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare com a vers√£o original, parece-me, tornou-se melhor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© tudo, pessoal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© tudo para mim, obrigado por sua aten√ß√£o. </font><font style="vertical-align: inherit;">Espero que voc√™ tenha descoberto algo interessante ou at√© √∫til. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com o conte√∫do do artigo, parece que estou repreendendo o c√≥digo do nosso analisador e quero dizer que tudo est√° ruim por l√°. </font><font style="vertical-align: inherit;">Isso n√£o √© verdade. </font><font style="vertical-align: inherit;">Como qualquer projeto com uma hist√≥ria, nosso analisador est√° cheio de dep√≥sitos geol√≥gicos que permaneceram de √©pocas passadas. </font><font style="vertical-align: inherit;">Considere que acabamos de escavar, remover artefatos da civiliza√ß√£o antiga de baixo do solo e realizar a restaura√ß√£o para torn√°-los com boa apar√™ncia na prateleira.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P.S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haver√° muito c√≥digo aqui. </font><font style="vertical-align: inherit;">Eu duvidava de incluir a implementa√ß√£o de iteradores aqui ou n√£o e, no final, decidi inclu√≠-lo para n√£o deixar nada nos bastidores. </font><font style="vertical-align: inherit;">Se voc√™ n√£o est√° interessado em ler o c√≥digo, aqui vou dizer adeus a voc√™. </font><font style="vertical-align: inherit;">O resto, desejo-lhe um tempo agrad√°vel com modelos.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo</font></font></b>
                        <div class="spoiler_text"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterador regular</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeIterator(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
  pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> &amp;(**<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterador com contador</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeCountingIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
 <span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeCountingIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeCountingIterator(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeCountingIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> (**<span class="hljs-keyword">this</span>).first;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">size_type <span class="hljs-title">counter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_counter;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Container gen√©rico</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  PtreeContainer() = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> empty();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == <span class="hljs-literal">nullptr</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == node);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == other.get();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    size_type i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (i++ == index)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> *it;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> value_type{};<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>];<font></font>
  }<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    value_type last{};<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : *<span class="hljs-keyword">this</span>)<font></font>
    {<font></font>
      last = cur;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> last;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has_at_least</span><span class="hljs-params">(size_type n)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    size_type counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (++counter == n)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br>
</div>
                    </div><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png"></a></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Yuri Minaev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como escalar uma √°rvore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502500/index.html">A evolu√ß√£o de um scanner de passaporte: do artesanato em compensado aos neg√≥cios reais</a></li>
<li><a href="../pt502504/index.html">Coloque o d√≠gito do usu√°rio</a></li>
<li><a href="../pt502508/index.html">Rob√¥ de carrinho 2.0. Parte 2. Gerenciamento em rviz e sem elementos de beleza em rviz</a></li>
<li><a href="../pt502510/index.html">O que salvar na nuvem</a></li>
<li><a href="../pt502512/index.html">Resultados do concurso de especialistas em sof√°s: as regras da cutucada cient√≠fica</a></li>
<li><a href="../pt502520/index.html">Relat√≥rios em v√≠deo de relat√≥rios mitap sobre an√°lise de produtos</a></li>
<li><a href="../pt502554/index.html">Tecnologia da informa√ß√£o intermedi√°ria como sa√≠da da crise</a></li>
<li><a href="../pt502556/index.html">Confer√™ncia Microsoft Build 2020 - totalmente online hoje (veja diretamente Habr√©)</a></li>
<li><a href="../pt502558/index.html">Como colecionei f√≠sica das rodas na Unigine</a></li>
<li><a href="../pt502560/index.html">Basta dizer n√£o aos testes de ponta a ponta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>