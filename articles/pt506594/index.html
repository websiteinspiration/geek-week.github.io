<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎞️ 🙁 🕴🏽 Melhores práticas do Redis, parte 3 🧑🏿‍🤝‍🧑🏼 🈳 🐍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tradução final das seções Redis Best Practices no site oficial do Redis Labs. O mais incomum e interessante hoje sob o corte!
 
 
 A primeira parte es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Melhores práticas do Redis, parte 3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tradução final das seções </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Best Practices</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no site oficial do Redis Labs. </font><font style="vertical-align: inherit;">O mais incomum e interessante hoje sob o corte!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira parte está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o segundo está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo contém os seguintes tópicos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências de tempo em conjuntos ordenados;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências de tempo em conjuntos lexicograficamente classificados;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências de tempo em campos de bits;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padrão básico de limitação de largura de banda;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filtro de flores;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contador;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padrão de contagem de bits;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts Lua.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados da sequência de tempo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os dados da sequência de tempo, ou dados com uma ordem de tempo natural, podem ser modelados no Redis de várias maneiras, dependendo dos próprios dados e da maneira como você deseja acessá-los. </font><font style="vertical-align: inherit;">Veremos alguns desses padrões:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências de tempo em conjuntos ordenados;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências de tempo em conjuntos lexicograficamente classificados;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seqüências de tempo em campos de bits;</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequências de tempo em conjuntos classificados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sequências de tempo em conjuntos classificados (zsets) são uma maneira típica de modelar uma sequência de tempo no Redis. </font><font style="vertical-align: inherit;">Os conjuntos classificados consistem em objetos únicos cujas pontuações são armazenadas em uma chave. </font><font style="vertical-align: inherit;">O uso desse tipo de dados para conjuntos classificados significa que a contagem se comporta como um tipo de indicador de tempo (geralmente é um carimbo de hora com precisão de milissegundos) e o elemento é um dado gravado. </font><font style="vertical-align: inherit;">O único benefício é que, como essa é uma forma de conjunto, apenas elementos únicos são permitidos, e tentar gravar sequências de tempo com os mesmos valores atualizará apenas a pontuação. </font><font style="vertical-align: inherit;">Para ilustrar esse problema, tomamos o seguinte exemplo de registro periódico de temperatura:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carimbo de hora</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperatura, C</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você simplesmente adicioná-los ao conjunto classificado usando ZADD, poderá perder alguns valores: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTI-PATTERN</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que a terceira chamada para ZADD retorna 0, o que indica que o novo item não foi adicionado ao conjunto. Em ZRANGEBYSCORE, vemos que existem apenas dois registros no conjunto classificado. Por quê? Como o primeiro e o terceiro compartilham o mesmo objeto, acabamos de atualizar a conta para esse objeto. Existem várias maneiras de contornar esse problema. Uma delas é incluir alguns dados aleatórios com variação suficiente, garantindo assim a exclusividade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, crie um número real pseudo-aleatório de 0 a 1, inclusive, depois adicione-o ao nosso registro de data e hora. Em nosso exemplo, vamos deixá-lo na forma decimal para facilitar a leitura (na realidade, seria mais razoável simplesmente convertê-lo em uma string de 8 bytes para economizar espaço).</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, todos os ZADDs retornaram 1, indicando uma adição bem-sucedida, e ZRANGEBYSCORE retornou todos os valores. </font><font style="vertical-align: inherit;">Esse é um método de trabalho, no entanto, não é muito eficiente devido ao desperdício de bytes para garantir a exclusividade, o que aumenta a sobrecarga do armazenamento. </font><font style="vertical-align: inherit;">Na maioria dos casos, a exclusividade será simplesmente removida pelo seu aplicativo. </font><font style="vertical-align: inherit;">Deve-se observar que a adição de exclusividade não é necessária se seus dados já forem exclusivos (por exemplo, dados incluindo UUIDs). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esse método, você tem acesso a todos os métodos de conjuntos classificados para análise e controle:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYSCORE permite que você obtenha uma fatia específica entre dois carimbos de data / hora (ZREVRANGEBYSCORE retornará a fatia em ordem decrescente);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ZREMRANGEBYSCORE permite excluir um intervalo específico de carimbos de data e hora;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT - o número de elementos entre o intervalo do registro de data e hora;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE - permite obter a interseção de duas partes de dados e salvá-las sob uma nova chave;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE - permite obter a união de dois dados e também salvá-lo com uma nova chave. </font><font style="vertical-align: inherit;">Você também pode usar isso para duplicar um conjunto classificado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operações ZINTERSTORE e ZUNIONSTORE que funcionam com várias chaves. </font><font style="vertical-align: inherit;">Ao trabalhar com um ambiente compartilhado, você deve ter cuidado para verificar se sua nova chave está no mesmo segmento; caso contrário, esses comandos levarão a um erro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequências de tempo em conjuntos lexicograficamente classificados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra maneira de trabalhar com seqüências de tempo é usar as propriedades lexicográficas de conjuntos classificados para armazenar um registro de data e hora e valor. Se você ainda não está familiarizado com isso, é hora de ler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta seção</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esse método, armazenamos tudo com a mesma contagem e primeiro codificamos o carimbo de data e hora e adicionamos o valor como um elemento. Veja um exemplo:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nessas três chamadas do ZADD, o registro de data e hora é separado do valor por dois pontos, e podemos ver que 1 é retornado a cada vez, o que significa que todos os três foram adicionados. No ZRANGE, vemos o pedido salvo. Por quê? Em conjuntos classificados, se a pontuação for a mesma, os resultados com a mesma pontuação serão ordenados por classificação binária. Como os registros de data e hora nesse período têm o mesmo número de dígitos, tudo será classificado corretamente (se os registros de data e hora forem anteriores a 2002 ou depois de 2285, você precisará de mais dígitos para preencher). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obter um intervalo de valores desse tipo, use o comando ZRANGEBYLEX:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo argumento tem um prefixo (indicando a exclusividade do valor (a inclusão é denotada por [). Na prática, esse formato torna a inclusão e a exclusividade irrelevantes, uma vez que o registro de data e hora sempre será seguido por dados adicionais. O terceiro argumento + indica a falta de limites do limite superior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tente obter a data entre 1589392160001 e 1589392165001 inclusive:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que os dados do registro de data e hora 1589392165001 não foram incluídos na amostra, apesar do prefixo inclusivo? </font><font style="vertical-align: inherit;">Quero acreditar que Redis de alguma forma entende que esse é um carimbo de data e hora. </font><font style="vertical-align: inherit;">De fato, o Redis apenas vê a classificação binária. </font><font style="vertical-align: inherit;">Na classificação binária, 1589392165001: 21 é maior que 1589392165001 inclusivo ou exclusivo. </font><font style="vertical-align: inherit;">A maneira correta de incluir isso no limite superior é adicionar 1 milissegundo ao limite superior desejado e usar a exclusividade:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sequências temporárias com conjuntos ordenados lexicograficamente têm um conjunto semelhante de comandos úteis, como sequências temporárias com conjuntos ordenados simplesmente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX - Obtém um intervalo de valores em ordem crescente ou decrescente;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX - remove um intervalo classificado específico de valores;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT - Obtém o número de elementos em um intervalo classificado de valores.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ZINTERSTORE e o ZUNIONSTORE podem ser usados ​​em conjuntos ordenados lexicograficamente, mas há um risco de perda de dados, porque combinações duplicadas de carimbos de data e hora e valores não serão duplicados no resultado retornado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode se perguntar por que escolher conjuntos ordenados com registro de data e hora em vez de codificar conjuntos ordenados lexicograficamente. </font><font style="vertical-align: inherit;">Como regra, é melhor trabalhar com conjuntos lexicograficamente classificados para seqüências de tempo - se os valores nem sempre forem exclusivos, os carimbos de data e hora serão mais eficazes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequências temporais de campo de bits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis podem efetivamente armazenar seqüências de tempo em campos de bits. </font><font style="vertical-align: inherit;">Para fazer isso, você deve primeiro selecionar um ponto de referência arbitrário e um formato numérico. </font><font style="vertical-align: inherit;">Veja o exemplo da medição de temperatura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que desejemos medir a temperatura a cada minuto e definiremos o ponto de partida para a meia-noite todos os dias. </font><font style="vertical-align: inherit;">Medimos a temperatura ambiente em graus Celsius. </font><font style="vertical-align: inherit;">Você pode estruturar os dados da seguinte maneira:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 minuto = byte 0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a temperatura é gravada em um número não assinado de 8 bits (0-255).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por um dia, os dados são digitados em cerca de 1,44 kb. </font><font style="vertical-align: inherit;">Você pode registrar a temperatura com o comando BITFIELD:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, usando a tecla bit-ts, o valor da temperatura 22 é gravado no número de 8 bits não assinado (u8) à meia-noite (# 0) Os </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
campos de bits não se limitam aos valores de 8 bits não assinados. </font><font style="vertical-align: inherit;">Preste atenção ao sinal da libra antes do deslocamento. </font><font style="vertical-align: inherit;">Isso significa que o alinhamento ocorrerá no tipo selecionado. </font><font style="vertical-align: inherit;">Por exemplo, se você especificar "# 79" - isso significa o 79º byte, "79" - o 79º bit (consulte a ajuda do BITFIELD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O deslocamento pode ser alinhado pelo tipo do número armazenado, começando em 0. Por exemplo, se queremos escrever 1 da manhã, considerando os slots zero, usamos o deslocamento # 59 ou deslocamento # 719 ao meio-dia.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O exemplo também mostra que BITFIELD é variável, ou seja, </font><font style="vertical-align: inherit;">Você pode trabalhar com vários valores em uma chamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione mais alguns valores:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora vamos extrair:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A assinatura do subcomando GET bit é semelhante à assinatura SET, com a única diferença de que ele não aceita um valor como terceiro argumento. </font><font style="vertical-align: inherit;">É normal quando conhecemos todos os índices que precisamos obter, mas às vezes precisamos de uma faixa de valores, e cada byte individualmente será muito estressante. </font><font style="vertical-align: inherit;">Podemos usar o comando GETRANGE. </font><font style="vertical-align: inherit;">Em uma situação normal, é usado para obter bytes de uma sequência, mas os BITFIELDs são apenas outra maneira de endereçar os mesmos dados.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O comando retornou os bytes 59 a 61 em hexadecimal (23, 21 e 20 em decimal. Os idiomas do cliente manipulam os dados binários melhor que o redis-cli e geralmente podem obter uma matriz de bytes específica do idioma. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso exemplo, usamos os bytes 0 , 59-61 e 719. O que acontece se solicitarmos bytes que ainda não foram definidos?</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis retorna bytes não especificados como 0. Isso pode causar dificuldades ao trabalhar com dados de sequência de tempo - a lógica do aplicativo precisa distinguir entre 0 e um valor indefinido. </font><font style="vertical-align: inherit;">Arredondamentos e omissões de valores 0 são possíveis, especialmente ao usar números inteiros assinados, pois esse pode ser um valor válido no meio do seu intervalo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A duração real da sequência de tempo realmente depende do último byte. </font><font style="vertical-align: inherit;">No exemplo, o último byte armazenado é 719, portanto, o comprimento dos dados é 720 bytes.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As seqüências de tempo baseadas no BITFIELD são um padrão poderoso e compacto para armazenar dados numéricos ou binários. </font><font style="vertical-align: inherit;">No entanto, esta solução não cobre todos os casos de uso, e seu uso deve ser cuidadosamente considerado para atender às suas necessidades.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padrão básico de limite de largura de banda</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Criar limitadores de largura de banda com Redis é fácil graças aos comandos INCR e EXPIRE. </font><font style="vertical-align: inherit;">A idéia é que você deseja limitar solicitações a um serviço específico por um determinado período de tempo. </font><font style="vertical-align: inherit;">Suponha que tenhamos um serviço no qual os usuários sejam identificados por uma chave de API. </font><font style="vertical-align: inherit;">O serviço tem um limite de 20 solicitações por minuto. </font><font style="vertical-align: inherit;">Para implementar isso, queremos criar uma chave Redis na chave da API a cada minuto. </font><font style="vertical-align: inherit;">Para não desarrumar o banco de dados, o período de validade da chave também é definido como 1 minuto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chave da API - zA21X31, negrito - limite atingido:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Key</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vinte</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vinte</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expira em</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A chave é composta da chave da API e do número do minuto através de dois pontos. </font><font style="vertical-align: inherit;">Como as teclas sempre expiram, basta usar apenas os números dos minutos - com o início da nova hora, podemos ter certeza de que não existem outras 59 teclas (elas expiraram 59 minutos atrás). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como isso funciona:</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o resultado for menor que 20 ou não definido, vá para a etapa 4; caso contrário, vá para a etapa 3;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibir uma mensagem de erro, fechar a conexão e finalizar;</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continue o programa.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dois pontos principais:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O INCR em uma chave inexistente sempre será 1;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIRE está localizado dentro da transação MULTI junto com o INCR, o que significa que será uma operação atômica.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pior cenário é se, por alguma razão muito estranha e improvável, o servidor Redis morrer entre INCR e EXPIRE. </font><font style="vertical-align: inherit;">Ao restaurar dados da AOF ou de uma réplica na memória, o INCR não será restaurado porque a transação não foi concluída. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao usar esse padrão, é possível que um usuário tenha duas chaves: uma que está sendo usada no momento e a outra que expira neste minuto. </font><font style="vertical-align: inherit;">No entanto, o padrão é muito eficaz.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtro Bloom</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O filtro Bloom é uma estrutura de dados probabilística interessante que você pode usar para verificar se um item foi adicionado anteriormente. Aqui está o texto intencionalmente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A probabilidade é que só possa haver uma resposta falsa positiva, mas não uma falsa negativa. O Bloom Filter fornece uma maneira muito mais compacta e rápida de verificar a disponibilidade do que salvar todos os elementos em um conjunto e chamar SISMEMBER.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O filtro Bloom funciona passando um elemento pela função de hash rápido, selecionando bits dele e configurando-os para 1 e 0 em um determinado intervalo no campo de bit. Para verificar a presença de um filtro, os mesmos bits são selecionados. Muitos elementos podem ter bits que se sobrepõem, mas como a função hash cria identificadores exclusivos, se um bit do hash ainda é 0, sabemos que ele não foi adicionado antes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Redis usa o filtro há muitos anos como uma biblioteca cliente que usa GETBIT e SETBIT para trabalhar com campos de bits. Felizmente, o módulo ReBloom está disponível no Redis 4.0, o que elimina a necessidade de criar sua própria implementação do filtro Bloom.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um bom caso de uso para esse filtro é verificar se o nome de usuário já foi usado. </font><font style="vertical-align: inherit;">Não há problemas com tamanhos de dados pequenos, mas à medida que o serviço cresce, as consultas ao banco de dados podem ser caras. </font><font style="vertical-align: inherit;">Isso é fácil de corrigir com o ReBloom. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione alguns nomes para o teste:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora teste o filtro Bloom:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como esperado, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornou 0. Isso significa que esse nome não foi usado. </font><font style="vertical-align: inherit;">Embora seja impossível dizer com certeza, uma vez que os bits podem simplesmente se sobrepor entre vários elementos. </font><font style="vertical-align: inherit;">Basicamente, a chance de falsos positivos é baixa, mas não é igual a 0. À medida que o filtro Bloom é preenchido, a chance aumenta, mas você pode ajustar a taxa de erro e o tamanho inicial (o padrão é 0,01 e 100, respectivamente).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contador</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um contador no Redis pode ser implementado de várias maneiras. </font><font style="vertical-align: inherit;">O mais óbvio é INCR et al (INCRBY, INCRBYFLOAT, HINCRBY, HINCRBYFLOAT, ZINCRBY), que pode ser encontrado simplesmente lendo a documentação. </font><font style="vertical-align: inherit;">Menos óbvio é o uso de BITCOUNT e PFADD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padrão de contagem de bits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNT conta o número de bits definido como 1 no campo de bits por chave. </font><font style="vertical-align: inherit;">Isso pode ser usado para calcular uma série de atividades durante um período arbitrário de tempo (semelhante ao padrão de seqüências de tempo nos campos de bits). </font><font style="vertical-align: inherit;">O processo é escolher um ponto no tempo e cada bit representa uma unidade de período. </font><font style="vertical-align: inherit;">Cada vez que uma ação é executada durante esse período, execute SETBIT a uma distância de 1 unidade do último ponto.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ponto de partida]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aja</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aja</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aja</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para calcular em que minutos das 12:00 às 12:30 atividades ocorreu, você pode fazer o seguinte:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, esse padrão responde à pergunta “Quantas vezes?” Em vez de “Quantas vezes?”. </font><font style="vertical-align: inherit;">Por exemplo, um usuário pode estar ativo 20 vezes em um minuto, mas isso contará como 1. A </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vantagem real desse modelo é que ele fornece a pontuação mínima possível por um determinado período de tempo, já que os bits são os blocos de armazenamento mais elementares. </font><font style="vertical-align: inherit;">Este é literalmente o menor repositório (não compactado) para contagem.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contar itens exclusivos pode ser complicado. Isso geralmente significa armazenar cada elemento exclusivo e, em seguida, invocar essas informações de alguma forma. No Redis, isso pode ser feito usando muitas e uma equipe, no entanto, tanto o volume ocupado quanto a complexidade de tempo serão muito grandes. O HyperLogLog fornece uma alternativa probabilística. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O HyperLogLog é internamente semelhante a um filtro Bloom, também alimenta elementos através de uma função hash não criptográfica e define bits em um campo de bits. Porém, diferentemente do filtro Bloom, o HyperLogLog armazena um contador de elementos, que é incrementado quando um novo elemento é adicionado que não foi adicionado antes. Isso fornece uma baixa taxa de erro ao contar elementos únicos em um conjunto. O HyperLogLog está embutido no Redis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem 3 comandos HyperLogLog no Redis: PFADD, PFCOUNT e PFMERGE. </font><font style="vertical-align: inherit;">Digamos que criamos um scanner da web e queremos contar o número de URLs exclusivos de páginas visualizadas durante o dia. </font><font style="vertical-align: inherit;">Para cada página, execute o seguinte comando:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada chave acima é indexada por dia. </font><font style="vertical-align: inherit;">Para ver quantas páginas foram visualizadas em 13/06/2020, você pode fazer o seguinte:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para visualizar o número de páginas de 13/06/2020 e 14/06/2020, use o comando PFMERGE para criar uma nova chave com um valor que combine dois contadores. </font><font style="vertical-align: inherit;">Observe que, como </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é armazenado em ambos os conjuntos, ele será calculado uma vez:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa operação pode funcionar com várias chaves, portanto, tenha cuidado em um ambiente dividido, para que as chaves estejam no mesmo fragmento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts Lua</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os Redis podem fazer coisas incríveis apenas a partir de "redis-cli" e ainda mais entre Redis e sua linguagem de programação. Às vezes, porém, pode ser necessário um comportamento que não pode ser obtido na arquitetura cliente-servidor devido a problemas de eficiência ou segurança - a lógica precisa ser executada na camada do banco de dados. Nesses casos, Lua vem em socorro. Lua trabalha no Redis como uma linguagem de script. Com ele, você pode executar o código no Redis, sem o custo de transporte de e para o cliente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um caso de teste está adicionando um valor a um campo de hash. </font><font style="vertical-align: inherit;">Embora os Redis possam adicionar facilmente um valor a uma chave de cadeia usando APPEND, não há comando para adicionar um valor a um campo de hash. </font><font style="vertical-align: inherit;">Você pode tentar obter isso extraindo o valor do cliente, adicionando uma nova linha ao valor e eliminando os campos de hash, mas isso é uma má ideia. </font><font style="vertical-align: inherit;">Como isso não é atômico, é provável que, enquanto você adiciona um valor, outro cliente possa alterá-lo mais cedo e você substitua o novo valor.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cliente 1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cliente 2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[olá retorna]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[adiciona "mundo" a "olá"]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver na linha 2, a atualização será perdida. </font><font style="vertical-align: inherit;">Você pode usar scripts Lua para solucionar esse problema e remover o custo de envio / recebimento de valores do cliente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em qualquer editor de texto, crie um script e chame-o de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aconteceu.lua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na primeira linha, crie uma variável local </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , na qual salvamos o valor atual da chave de hash do primeiro argumento passado e o campo é o primeiro argumento não-chave. É importante entender que os scripts Lua em tempo de execução distinguem entre argumentos chave e não chave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na segunda linha, HSET é chamado para a mesma chave e campo e, em seguida, combinamos o valor original com o segundo argumento não-chave. Isso retorna ao Redis, portanto, manteremos o valor de retorno HSET original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A execução direta de scripts Lua com o comando EVAL pode ser confusa e ineficiente. </font><font style="vertical-align: inherit;">O Redis possui um cache de script interno que permite pré-carregar o script e acessá-lo usando o hash SHA1 do script principal. </font><font style="vertical-align: inherit;">Você pode baixar esse script na linha de comando usando "cat" e "redis-cli". </font><font style="vertical-align: inherit;">Observe que, se seu script diferir em pelo menos um caractere, ele terá um hash completamente diferente.</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você pode usar EVALSHA para chamar o script e adicionar:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro argumento para o comando EVALSHA é o hash do script gerado pelo SCRIPT LOAD. O segundo argumento é o número de chaves. No nosso caso, a chave é uma. O terceiro argumento é a chave na qual executamos a ação. E, finalmente, o quarto é o valor que adicionamos ao campo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a adição ocorre dentro do script Lua, o script acima será interrompido porque os scripts Lua são executados de forma síncrona e atômica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora Lua possa ser muito útil na resolução de problemas, você precisa usá-lo com cuidado. O script bloqueia o servidor e pode levar a um banco de dados não responsivo. Em situações de sharding, os scripts tentam salvar todas as operações em um único servidor para evitar erros cruzados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É aqui que a seção Redis Best Practices termina. </font><font style="vertical-align: inherit;">Não tenha medo de experimentar, o Redis é muito rico em funcionalidades. </font><font style="vertical-align: inherit;">Deixe seus casos de uso interessantes nos comentários. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que as técnicas descritas o ajudem, se não diretamente, pelo menos apontando o caminho certo para resolver problemas!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt506574/index.html">Visualização de uma lista de mulheres vencedoras do Prêmio Nobel na forma de cristais em 3d usando Vue, WebGL, three.js</a></li>
<li><a href="../pt506578/index.html">Volume de chumbo gerenciado</a></li>
<li><a href="../pt506586/index.html">FizzBuzz lógico</a></li>
<li><a href="../pt506588/index.html">O que é um algoritmo! (parte 2)</a></li>
<li><a href="../pt506590/index.html">Conferência DEVOXX UK. Escolha uma estrutura: Docker Swarm, Kubernetes ou Mesos. Parte 2</a></li>
<li><a href="../pt506598/index.html">Microsoft: Rust является 'лучшим шансом' в отрасли программирования безопасных систем</a></li>
<li><a href="../pt506600/index.html">O contrato para o desenvolvimento do site em termos de gerenciamento de projetos (teoria + amostra)</a></li>
<li><a href="../pt506604/index.html">Simultaneidade e eficiência: Python vs FSM</a></li>
<li><a href="../pt506606/index.html">Criação de clicker PIXI.js</a></li>
<li><a href="../pt506610/index.html">WAL-G: Backups e recuperação de banco de dados PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>