<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèø ‚úçüèª üéôÔ∏è S905X processor (secured boot) software security overview ‚úäüèæ ‚Ü©Ô∏è üë§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss software protection on the S905X processor. The ultimate goal is to launch unauthorized software.
 
 S905X
 The S905X proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>S905X processor (secured boot) software security overview</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488982/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article will discuss software protection on the S905X processor. </font><font style="vertical-align: inherit;">The ultimate goal is to launch unauthorized software.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S905X</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The S905X processor is an ARM Cortex-A53 with a clock frequency of up to 1.5 GHz, stuffed with all kinds of decoders for video and audio streams, such as H.265 4K, VP9, ‚Äã‚Äãsupporting 4KUHD, etc. </font><font style="vertical-align: inherit;">In general, not a bad choice. </font><font style="vertical-align: inherit;">Unlike its predecessor, AMLogic integrated the so-called ‚ÄúAdvanced TrustZone security system‚Äù into this processor, which controls all critical system operations, such as accessing protected areas of ROM memory, checking the signature and decrypting software, etc. </font><font style="vertical-align: inherit;">Detailed documentation on this topic can be found on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manufacturer's</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> website </font><font style="vertical-align: inherit;">.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SecureOS acts as ATOS-V1.5-g3e467d9 (I will not assert, I did not check).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Training</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having disassembled the prefix, I easily found the RxD, TxD and GND pins for UART. </font><font style="vertical-align: inherit;">On the reverse side there was a connector for the reset button (not verified) and a place for the connector. </font><font style="vertical-align: inherit;">Judging by the location, the connector looked like a board-to-board for an alternative eMMS card (pinout is naturally absent). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e7/ws/oz/e7wsoz1cpn6iinl5tjz__nc6xoc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Free-access documentation for the S905 such critical topics as, for example, the boot sequence didn‚Äôt touch on much or less and was practically useless from the point of view of RE. </font><font style="vertical-align: inherit;">Putting the documentation aside, I connected UART and ... was pleasantly surprised by the processor loading speed. </font><font style="vertical-align: inherit;">But that‚Äôs probably all. </font><font style="vertical-align: inherit;">U-Boot didn‚Äôt react at all to the keyboard and, after some hardware settings, smartly loaded and launched the Android kernel.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U-Boot'a boot log</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs"> GXL:BL1:9ac50e:bb16dc;FEAT:BDFC31BC:0;POC:3;RCY:0;EMMC:0;READ:0;0.0;0.0;CHK:0;<font></font>
TE: 351954<font></font>
<font></font>
BL2 Built : 16:42:36, Nov  3 2016. <font></font>
gxl g3eddb43 - xiaobo.gu@droid05<font></font>
<font></font>
set vcck to 1120 mv<font></font>
set vddee to 1000 mv<font></font>
Board ID = 4<font></font>
CPU clk: 1200MHz<font></font>
DQS-corr enabled<font></font>
DDR scramble enabled<font></font>
DDR3 chl: Rank0+1 @ 768MHz - FAIL<font></font>
DDR3 chl: Rank0 @ 768MHz - PASS<font></font>
Rank0: 1024MB(auto)-2T-11<font></font>
DataBus test pass!<font></font>
AddrBus test pass!<font></font>
-s<font></font>
Load fip header from eMMC, src: 0x0000c200, des: 0x01400000, size: 0x00004000<font></font>
aml log : R2048 check pass!<font></font>
New fip structure!<font></font>
Load bl30 from eMMC, src: 0x00010200, des: 0x01700000, size: 0x0000d600<font></font>
aml log : R2048 check pass!<font></font>
Load bl31 from eMMC, src: 0x00020200, des: 0x01700000, size: 0x00015400<font></font>
aml log : R2048 check pass!<font></font>
Load bl32 from eMMC, src: 0x00038200, des: 0x01700000, size: 0x00035a00<font></font>
aml log : R2048 check pass!<font></font>
Load bl33 from eMMC, src: 0x00070200, des: 0x01700000, size: 0x000aa200<font></font>
aml log : R2048 check pass!<font></font>
NOTICE:  BL3-1: v1.0(debug):fb68908<font></font>
NOTICE:  BL3-1: Built : 18:30:11, Nov  1 2016<font></font>
aml log : bl31 detect secure boot !<font></font>
[Image: gxl_v1.1.3154-065f772 2016-09-29 14:08:54 yan.wang@droid05]<font></font>
<font></font>
OPS=0x84<font></font>
<font></font>
bc fc af 5f a2 b4 4d 4b 1c 91 59 9f [1.280536 Inits done]<font></font>
<font></font>
secure task start!<font></font>
high task start!<font></font>
low task start!<font></font>
INFO:    BL3-1: Initializing runtime services<font></font>
INFO:    BL3-1: Initializing BL3-2<font></font>
INFO:    BL3-2: ATOS-V1.5-g3e467d9 #1 Mon Aug 22 17:11:43 CST 2016 arm<font></font>
INFO:    BL3-2: chip version = RevC (21:C - 0:0)<font></font>
INFO:    BL3-2: crypto engine DMA<font></font>
INFO:    BL3-2: secure time TEE<font></font>
INFO:    BL3-1: Preparing for EL3 exit to normal world<font></font>
INFO:    BL3-1: Next image address = 0x1000000<font></font>
INFO:    BL3-1: Next image spsr = 0x3c9<font></font>
<font></font>
<font></font>
U-Boot 2015.01 (Nov 23 2018 - 15:50:35)<font></font>
<font></font>
DRAM:  1 GiB<font></font>
Relocation Offset is: 36ec8000<font></font>
register usb cfg[0][1] = 0000000037f5e258<font></font>
[CANVAS]canvas init<font></font>
vpu: error: vpu: check dts: FDT_ERR_BADMAGIC, load default parameters<font></font>
vpu: clk_level = 7<font></font>
vpu: set clk: 666667000Hz, readback: 666660000Hz(0x300)<font></font>
vpp: vpp_init<font></font>
boot_device_flag : 1<font></font>
Nand PHY Ver:1.01.001.0006 (c) 2013 Amlogic Inc.<font></font>
init bus_cycle=6, bus_timing=7, system=5.0ns<font></font>
reset failed<font></font>
get_chip_type and ret:fffffffe<font></font>
get_chip_type and ret:fffffffe<font></font>
chip detect failed and ret:fffffffe<font></font>
nandphy_init failed and ret=0xfffffff1<font></font>
MMC:   aml_priv-&gt;desc_buf = 0x0000000033ec86b0<font></font>
aml_priv-&gt;desc_buf = 0x0000000033eca9d0<font></font>
SDIO Port B: 0, SDIO Port C: 1<font></font>
emmc/sd response timeout, cmd8, status=0x1ff2800<font></font>
emmc/sd response timeout, cmd55, status=0x1ff2800<font></font>
[mmc_startup] mmc refix success<font></font>
[mmc_init] mmc init success<font></font>
mmc read lba=0x14000, blocks=0x400<font></font>
      Amlogic multi-dtb tool<font></font>
      Multi dtb detected<font></font>
      Multi dtb tool version: v2 .<font></font>
      Support 2 dtbs.<font></font>
        aml_dt soc: gxl platform: sx6b6x variant: 1g<font></font>
        dtb 0 soc: gxl   plat: sx6b6x   vari: 1g<font></font>
        dtb 1 soc: gxl   plat: sx6b6x   vari: 2g<font></font>
      Find match dtb: 0<font></font>
start dts,buffer=0000000033ecd270,dt_addr=0000000033ecda70<font></font>
parts: 11<font></font>
00:      logo	0000000002000000 1<font></font>
01:  recovery	0000000002000000 1<font></font>
02:       rsv	0000000000800000 1<font></font>
03:       tee	0000000000800000 1<font></font>
04:     crypt	0000000002000000 1<font></font>
05:      misc	0000000002000000 1<font></font>
06: instaboot	0000000020000000 1<font></font>
07:      boot	0000000002000000 1<font></font>
08:    system	0000000050000000 1<font></font>
09:     cache	0000000040000000 2<font></font>
10:      data	ffffffffffffffff 4<font></font>
get_dtb_struct: Get emmc dtb OK!<font></font>
overide_emmc_partition_table: overide cache <font></font>
[mmc_get_partition_table] skip partition cache.<font></font>
Partition table get from SPL is : <font></font>
        name                        offset              size              flag<font></font>
===================================================================================<font></font>
   0: bootloader                         0            400000                  0<font></font>
   1: reserved                     2400000           4000000                  0<font></font>
   2: cache                        6c00000          40000000                  2<font></font>
   3: env                         47400000            800000                  0<font></font>
   4: logo                        48400000           2000000                  1<font></font>
   5: recovery                    4ac00000           2000000                  1<font></font>
   6: rsv                         4d400000            800000                  1<font></font>
   7: tee                         4e400000            800000                  1<font></font>
   8: crypt                       4f400000           2000000                  1<font></font>
   9: misc                        51c00000           2000000                  1<font></font>
  10: instaboot                   54400000          20000000                  1<font></font>
  11: boot                        74c00000           2000000                  1<font></font>
  12: system                      77400000          50000000                  1<font></font>
  13: data                        c7c00000         10a400000                  4<font></font>
mmc read lba=0x12000, blocks=0x2<font></font>
mmc read lba=0x12002, blocks=0x2<font></font>
mmc_read_partition_tbl: mmc read partition OK!<font></font>
eMMC/TSD partition table have been checked OK!<font></font>
mmc env offset: 0x47400000 <font></font>
WARNING: 'recovery_from_sdcard' neither in running nor in imported env!<font></font>
WARNING: 'recovery_from_udisk' neither in running nor in imported env!<font></font>
In:    serial<font></font>
Out:   serial<font></font>
Err:   serial<font></font>
hpd_state=0<font></font>
cvbs performance type = 6, table = 0<font></font>
[store]To run cmd[emmc dtb_read 0x1000000 0x40000]<font></font>
read emmc dtb<font></font>
      Amlogic multi-dtb tool<font></font>
      Multi dtb detected<font></font>
      Multi dtb tool version: v2 .<font></font>
      Support 2 dtbs.<font></font>
        aml_dt soc: gxl platform: sx6b6x variant: 1g<font></font>
        dtb 0 soc: gxl   plat: sx6b6x   vari: 1g<font></font>
        dtb 1 soc: gxl   plat: sx6b6x   vari: 2g<font></font>
      Find match dtb: 0<font></font>
Net:   dwmac.c9410000<font></font>
wipe_data=successful<font></font>
wipe_cache=successful<font></font>
upgrade_step=2<font></font>
[OSD]load fb addr from dts<font></font>
[OSD]failed to get fb addr for logo<font></font>
[OSD]use default fb_addr parameters<font></font>
[OSD]fb_addr for logo: 0x3d800000<font></font>
[OSD]load fb addr from dts<font></font>
[OSD]failed to get fb addr for logo<font></font>
[OSD]use default fb_addr parameters<font></font>
[OSD]fb_addr for logo: 0x3d800000<font></font>
[CANVAS]addr=0x3d800000 width=3840, height=2160<font></font>
amlkey_init() enter!<font></font>
[EFUSE_MSG]keynum is 4<font></font>
[BL31]: tee size: 0<font></font>
[KM]Error:f[key_manage_query_size]L507:key[deviceid] not programed yet<font></font>
gpio: pin GPIOAO_2 (gpio 102) value is 1<font></font>
get_cpu_id flag_12bit=1<font></font>
SARADC channel(0) is 0x3e1.<font></font>
SARADC closed.<font></font>
Hit Enter or space or Ctrl+C key to stop autoboot -- :  0 <font></font>
[imgread]szTimeStamp[2019121002280214]<font></font>
[imgread]secureKernelImgSz=0x977000<font></font>
aml log : R2048 check pass!<font></font>
aml log : R2048 check pass!<font></font>
aml log : R2048 check pass!<font></font>
ee_gate_off ...<font></font>
## Booting Android Image at 0x01080000 ...<font></font>
reloc_addr =33f4d440<font></font>
copy done<font></font>
      Amlogic multi-dtb tool<font></font>
      Single dtb detected<font></font>
load dtb from 0x1000000 ......<font></font>
   Uncompressing Kernel Image ... OK<font></font>
   kernel loaded at 0x01080000, end = 0x02258fd0<font></font>
   Loading Ramdisk to 33d12000, end 33eb6000 ... OK<font></font>
   Loading Device Tree to 000000001fff3000, end 000000001ffff8f4 ... OK<font></font>
signature: <font></font>
fdt_instaboot: no instaboot image<font></font>
<font></font>
Starting kernel ...<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is worth noting that U-Boot (bl33) itself was already running in the ‚Äúnormal world‚Äù environment (BL3-1 switched the mode immediately before transferring control to it). Those. even if we somehow take control of the U-Boot, we will only have limited access to the system. In principle, this is not so important. After all, even if you remove the ROM dump, pull out the AES keys and open RSA from the fuse, then there will be no big sense from this, because there is still no RSA private key. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Boot itself did not read any keys. He loaded the kernel into memory and called on Security Monitor to decrypt and verify the code. Security Monitor did everything necessary and told U-Boot to load the kernel or not. In general, a serious approach to software protection with its own TrustedOS and some kind of functionality like BIOS.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My further plan was to access eMMC memory.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eMMC</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To connect to eMMC, it was necessary to find at least the DAT_0, CLK, CMD and GND pins. </font><font style="vertical-align: inherit;">And also find out at what voltage the eMMC controller worked (1V8 or 3V3). </font><font style="vertical-align: inherit;">It was impossible to do this visually and for trace tracks I pulled out eMMC myself. </font><font style="vertical-align: inherit;">Since the chip was in my hands, after tracing I connected it to the adapter and dumped a full dump. </font><font style="vertical-align: inherit;">Unfortunately, I did not have professional equipment and I used improvised materials for this. </font><font style="vertical-align: inherit;">The result is such a ‚ÄúDead Bug‚Äù.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/pc/gy/nh/pcgynhclzvh74tcdsd7e9txdrjs.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, actually the pinout of the connector:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xd/70/rv/xd70rv-hv6luye5bmv5hqpfgy40.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the pinout was done, I looked at how the processor behaves without eMMC. Judging by the log, ROM after an unsuccessful attempt to boot from eMMC tried to load the code from the mSD card. This was encouraging. I quickly uploaded the dump to the mSD card and turned on the console. A small surprise awaited me here. ROM downloaded the BL2 code from the card and transferred control to it (that means the ‚Äúboot‚Äù section on eMMC was not involved and there was no need for root access). Well, when the turn came to U-Boot, he complained a couple of times about the lack of eMMC (dev 1) and for a long time without thinking he stopped in the terminal.</font></font><br>
<br>
<pre><code class="plaintext hljs">cmd store failed <font></font>
Err imgread(L132):Fail to read 0x100000B from part[recovery] at offset 0<font></font>
gxl_sx6b6x_768_v2#version<font></font>
<font></font>
<font></font>
U-Boot 2015.01 (Nov 23 2018 - 15:50:35)<font></font>
aarch64-none-elf-gcc (crosstool-NG linaro-1.13.1-4.8-2013.11 - Linaro GCC 2013.10) 4.8.3 20131111 (prerelease)<font></font>
GNU ld (crosstool-NG linaro-1.13.1-4.8-2013.11 - Linaro GCC 2013.10) 2.23.2.20130610 Linaro 2013.10-4<font></font>
gxl_sx6b6x_768_v2#<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a start, it was not bad at all. After some experiments with the terminal, I added the bootdelay = 5 parameter to the ‚Äúenv‚Äù section, calculated the new checksum and soldered the eMMC back. With the new option, I was hoping the U-Boot could be stopped. But in practice, everything was different. It seems that U-Boot was not interested in this parameter and the boot process was no different from the regular one. It‚Äôs sad, because a terminal with an eMMC connected was necessary for me for further actions. With a little thought, I closed DAT_0 to ground and inserted my mSD card. ROM now could not load code from eMMC and switched to mSD. Having loaded U-Boot in this way, I opened the contacts and asked:</font></font><br>
<br>
<pre><code class="plaintext hljs">gxl_sx6b6x_768_v2#mmc dev 1<font></font>
<font></font>
emmc/sd response timeout, cmd8, status=0x1ff2800<font></font>
emmc/sd response timeout, cmd55, status=0x1ff2800<font></font>
[mmc_startup] mmc refix success<font></font>
[mmc_init] mmc init success<font></font>
mmc read lba=0x14000, blocks=0x400<font></font>
      Amlogic multi-dtb tool<font></font>
      Multi dtb detected<font></font>
      Multi dtb tool version: v2 .<font></font>
      Support 2 dtbs.<font></font>
        aml_dt soc: gxl platform: sx6b6x variant: 1g<font></font>
        dtb 0 soc: gxl   plat: sx6b6x   vari: 1g<font></font>
        dtb 1 soc: gxl   plat: sx6b6x   vari: 2g<font></font>
      Find match dtb: 0<font></font>
start dts,buffer=0000000033ee4050,dt_addr=0000000033ee4850<font></font>
parts: 11<font></font>
00:      logo	0000000002000000 1<font></font>
01:  recovery	0000000002000000 1<font></font>
02:       rsv	0000000000800000 1<font></font>
03:       tee	0000000000800000 1<font></font>
04:     crypt	0000000002000000 1<font></font>
05:      misc	0000000002000000 1<font></font>
06: instaboot	0000000020000000 1<font></font>
07:      boot	0000000002000000 1<font></font>
08:    system	0000000050000000 1<font></font>
09:     cache	0000000040000000 2<font></font>
10:      data	ffffffffffffffff 4<font></font>
get_dtb_struct: Get emmc dtb OK!<font></font>
overide_emmc_partition_table: overide cache <font></font>
[mmc_get_partition_table] skip partition cache.<font></font>
Partition table get from SPL is : <font></font>
        name                        offset              size              flag<font></font>
===================================================================================<font></font>
   0: bootloader                         0            400000                  0<font></font>
   1: reserved                     2400000           4000000                  0<font></font>
   2: cache                        6c00000          40000000                  2<font></font>
   3: env                         47400000            800000                  0<font></font>
   4: logo                        48400000           2000000                  1<font></font>
   5: recovery                    4ac00000           2000000                  1<font></font>
   6: rsv                         4d400000            800000                  1<font></font>
   7: tee                         4e400000            800000                  1<font></font>
   8: crypt                       4f400000           2000000                  1<font></font>
   9: misc                        51c00000           2000000                  1<font></font>
  10: instaboot                   54400000          20000000                  1<font></font>
  11: boot                        74c00000           2000000                  1<font></font>
  12: system                      77400000          50000000                  1<font></font>
  13: data                        c7c00000         10a400000                  4<font></font>
mmc read lba=0x12000, blocks=0x2<font></font>
mmc read lba=0x12002, blocks=0x2<font></font>
mmc_read_partition_tbl: mmc read partition OK!<font></font>
eMMC/TSD partition table have been checked OK!<font></font>
switch to partitions #0, OK<font></font>
mmc1(part 0) is current device<font></font>
gxl_sx6b6x_768_v2#<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Boot did not resist and happily switched to eMMC. </font><font style="vertical-align: inherit;">I looked, of course, what was in the bootdelay parameter. </font><font style="vertical-align: inherit;">And instead of my five, I saw 0. there again. It looks like U-Boot at some point wrote down 0 there, in case someone suddenly changes something there. </font><font style="vertical-align: inherit;">But it didn‚Äôt interest me anymore and the topic with eMMC was closed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: having a pinout of the connector, you can connect to eMMC without soldering the chip. </font><font style="vertical-align: inherit;">To do this, you need a special adapter with a voltage converter, because </font><font style="vertical-align: inherit;">eMMC controller runs on 1V8 and if you connect an ordinary SD adapter to 3V3, there is a risk of burning components lying on the 1V8 bus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It will also be necessary to remove this resistor, otherwise the processor will interfere with the adapter.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d0/in/aj/d0inajjkrgclzhes-4l84uvpxmk.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Missing components</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having full access to the U-Boot terminal, I had to do two things: get to the DeviceTree set-top box and convince U-Boot to abandon the Security Monitor services related to kernel testing. For the first launch, it would be nice to have the original kernel, so as not to waste time debugging a new one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was extremely easy to get DeviceTree. I asked:</font></font><br>
<br>
<pre><code class="plaintext hljs">gxl_sx6b6x_768_v2#emmc dtb_read 0x1000000 0x40000<font></font>
<font></font>
read emmc dtb<font></font>
gxl_sx6b6x_768_v2#<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and he was in my pocket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Boot required a detailed analysis. From the log it followed that U-Boot itself was loaded and decrypted initially at 0x1000000, and subsequently transferred itself to 0x36ES8000 (offset). I dumped U-Boot and analyzed it in IDA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I was interested in the place where the Security Monitor was accessed from the bootm command. Here it is </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fj/2s/mj/fj2smjpajdxwjdarboyyp_obfvc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X0 - AML_D_P_IMG_DECRYPT </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X1 - nLoadAddr </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X2 - GXB_IMG_SIZE </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X3 - GXB_IMG_DEC_ALL</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To remove the original kernel dump, it was necessary to load it into memory via the imgread function and modify bootm so that immediately after calling aml_sec_boot_check memory was issued starting from the address 0x1080000 to the terminal (this is certainly not the only way). </font><font style="vertical-align: inherit;">To do this, I wrote a piece of code and downloaded it to the right place. </font><font style="vertical-align: inherit;">Here's what happened (of course, I can‚Äôt give a full log):</font></font><br>
<br>
<pre><code class="plaintext hljs">gxl_sx6b6x_768_v2#imgread kernel boot<font></font>
<font></font>
[imgread]szTimeStamp[2019121002280214]<font></font>
[imgread]secureKernelImgSz=0x977000<font></font>
gxl_sx6b6x_768_v2#bootm<font></font>
<font></font>
aml log : R2048 check pass!<font></font>
aml log : R2048 check pass!<font></font>
aml log : R2048 check pass!<font></font>
<font></font>
Ready for dumping kernel<font></font>
<font></font>
41 4e 44 52 4f 49 44 21 20 d8 7b 20 20 20 08 01  | ANDROID!<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to the kernel, I also got ramdisk (it can come in handy in case there are any important drivers or firmware, for example, for WiFi).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm not Android anymore</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the first launch of my software, I made uImage from the original kernel, built my rootfs on the basis of Busybox and used my own dtb. </font><font style="vertical-align: inherit;">I loaded all three parts directly from the USB drive and ran the ‚Äúbootm‚Äù command, disabling decryption and image verification before.</font></font><br>
<br>
<pre><code class="plaintext hljs">gxl_sx6b6x_768_v2#usb start<font></font>
(Re)start USB...<font></font>
USB0:   USB3.0 XHCI init start<font></font>
Register 2000140 NbrPorts 2<font></font>
Starting the controller<font></font>
USB XHCI 1.00<font></font>
scanning bus 0 for devices... 2 USB Device(s) found<font></font>
       scanning usb for storage devices... 1 Storage Device(s) found<font></font>
gxl_sx6b6x_768_v2#mw.l 0x37ed240c 0xd2800000<font></font>
gxl_sx6b6x_768_v2#fatload usb 0:1 0x1000000 dtb.img<font></font>
reading dtb.img<font></font>
40960 bytes read in 43 ms (929.7 KiB/s)<font></font>
gxl_sx6b6x_768_v2#fatload usb 0:1 0x2000000 uImage<font></font>
reading uImage<font></font>
8116288 bytes read in 4197 ms (1.8 MiB/s)<font></font>
gxl_sx6b6x_768_v2#fatload usb 0:1 0x3000000 rootfs.img.uboot<font></font>
reading rootfs.img.uboot<font></font>
1041462 bytes read in 563 ms (1.8 MiB/s)<font></font>
gxl_sx6b6x_768_v2#bootm 0x2000000 0x3000000 0x1000000<font></font>
<font></font>
ee_gate_off ...<font></font>
## Booting kernel from Legacy Image at 02000000 ...<font></font>
   Image Name:   S905X Original<font></font>
   Image Type:   AArch64 Linux Kernel Image (gzip compressed)<font></font>
   Data Size:    8116224 Bytes = 7.7 MiB<font></font>
   Load Address: 01080000<font></font>
   Entry Point:  01080000<font></font>
   Verifying Checksum ... OK<font></font>
## Loading init Ramdisk from Legacy Image at 03000000 ...<font></font>
   Image Name:   Root Filesystem<font></font>
   Image Type:   AArch64 Linux RAMDisk Image (gzip compressed)<font></font>
   Data Size:    1041398 Bytes = 1017 KiB<font></font>
   Load Address: 033d1200<font></font>
   Entry Point:  033d1200<font></font>
   Verifying Checksum ... OK<font></font>
      Amlogic multi-dtb tool<font></font>
      Single dtb detected<font></font>
load dtb from 0x1000000 ......<font></font>
## Flattened Device Tree blob at 01000000<font></font>
   Booting using the fdt blob at 0x1000000<font></font>
   Uncompressing Kernel Image ... OK<font></font>
   kernel loaded at 0x01080000, end = 0x02258fd0<font></font>
   Loading Ramdisk to 33db8000, end 33eb63f6 ... OK<font></font>
   Loading Device Tree to 000000001fff3000, end 000000001ffff8f4 ... OK<font></font>
fdt_instaboot: no instaboot image<font></font>
<font></font>
Starting kernel ...<font></font>
<font></font>
uboot time: 136710682 us<font></font>
[    0.000000@0] Initializing cgroup subsys cpu<font></font>
[    0.000000@0] Initializing cgroup subsys cpuacct<font></font>
[    0.000000@0] Linux version 3.14.29 (build@build2) (gcc version 4.9.2 20140904 (prerelease) (crosstool-NG linaro-1.13.1-4.9-2014.09 - Linaro GCC 4.9-2014.09) ) #1 SMP PREEMPT Thu Sep 12 21:24:53 MSK 2019<font></font>
[    0.000000@0] CPU: AArch64 Processor [410fd034] revision 4<font></font>
<font></font>
[    6.302659@2] meson_uart c81004c0.serial: ttyS0 use xtal(8M) 24000000 change 115200 to 115200<font></font>
# cat /proc/cpuinfo<font></font>
Processor	: AArch64 Processor rev 4 (aarch64)<font></font>
processor	: 0<font></font>
processor	: 1<font></font>
processor	: 2<font></font>
processor	: 3<font></font>
Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt <font></font>
CPU implementer	: 0x41<font></font>
CPU architecture: 8<font></font>
CPU variant	: 0x0<font></font>
CPU part	: 0xd03<font></font>
CPU revision	: 4<font></font>
<font></font>
Hardware	: Amlogic<font></font>
Serial		: 210c84009f59911c4b4db4a25faffcbc<font></font>
#<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jailbreak</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Due to the fact that U-Boot was immunized against changing env parameters (this concerned not only ‚Äúbootdelay‚Äù), it was impossible to influence the boot process through env, and in order to load its software, the prefix had to be connected to the computer. </font><font style="vertical-align: inherit;">This option did not suit me at all. </font><font style="vertical-align: inherit;">Having analyzed the entire loading chain, this command caught my attention:</font></font><br>
<br>
<pre><code class="plaintext hljs">init_display=osd open;osd clear;imgread pic logo bootup $loadaddr;bmp display $bootup_offset;bmp scale
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
in particular:</font></font><br>
<br>
<pre><code class="plaintext hljs">imgread pic logo bootup $loadaddr
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where U-Boot was loading a certain ‚Äúbootup‚Äù resource at the address loadaddr = 0x1080000. </font><font style="vertical-align: inherit;">The resource itself was described by such a structure:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource_header</span>{</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> 	magic;		<span class="hljs-comment">/* Image Header Magic Number	*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> 	hcrc;		<span class="hljs-comment">/* Image Header CRC Checksum	*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>	size;		<span class="hljs-comment">/* Image Data Size		*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>	start;		<span class="hljs-comment">/* item data offset in the image*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>	end;		<span class="hljs-comment">/* Entry Point Address		*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>	next;		<span class="hljs-comment">/* Next item head offset in the image*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>	dcrc;		<span class="hljs-comment">/* Image Data CRC Checksum	*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>	index;		<span class="hljs-comment">/* Operating System		*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>	nums;		<span class="hljs-comment">/* CPU architecture		*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   type;		<span class="hljs-comment">/* Image Type			*/</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> 	comp;		<span class="hljs-comment">/* Compression Type		*/</span>
	<span class="hljs-keyword">char</span> 	name[<span class="hljs-number">32</span>];		<span class="hljs-comment">/* Image Name			*/</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, the ‚Äúsize‚Äù and ‚Äústart‚Äù parameters were interesting. Proceeding from them and also the ‚Äúloadaddr‚Äù parameter, U-Boot resolved three new parameters for direct reading from eMMC. Ideally, of course, he downloaded the picture from the ‚Äúlogo‚Äù section at 0x000B00C0 into memory at 0x1130000 ... I think the course of my thoughts is now clear. I solved new parameters ‚Äúsize‚Äù and ‚Äústart‚Äù and wrote my code, which was saved on eMMC. After such manipulations, U-Boot was no longer reading a picture, but an exploit, which immediately gained control. The exploit consisted of several lines in assembler.</font></font><br>
<br>
<pre><code class="plaintext hljs">LDR X21, printf<font></font>
ADR X0, .message<font></font>
BLR X21<font></font>
<font></font>
LDR X21, run_command<font></font>
ADR X0, .command<font></font>
MOV X1,#0x0<font></font>
BLR X21<font></font>
<font></font>
.align 4<font></font>
printf: .quad 0x37EE50A0<font></font>
.align 4<font></font>
run_command: .quad 0x37EE9BA0<font></font>
<font></font>
.align 4<font></font>
.message: .string "\nJailbreaking BL3-3...\n"<font></font>
.align 4<font></font>
.command: .string "fatload mmc 0:1 0x1000000 uboot.bin; go 0x1000000"<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He read uboot.bin from the first section of the mSD card and transferred control to it (uboot.bin was a freshly collected unencrypted U-Boot. Of course, it was possible to use a native modified one). </font><font style="vertical-align: inherit;">It turns out that the boot process returned to the place where BL3-1 decrypted the original U-Boot and transferred control to it. </font><font style="vertical-align: inherit;">Only this time, the unsigned code was already running. </font><font style="vertical-align: inherit;">And now the download from eMMS looked like this (the last fragment):</font></font><br>
<br>
<pre><code class="plaintext hljs">Hit Enter or space or Ctrl+C key to stop autoboot -- :  0<font></font>
<font></font>
Jailbreaking BL3-3...<font></font>
card in<font></font>
[mmc_init] mmc init success<font></font>
reading uboot.bin<font></font>
408579 bytes read in 28 ms (13.9 MiB/s)<font></font>
## Starting application at 0x01000000 ...<font></font>
<font></font>
<font></font>
U-Boot 2017.11-02414-g9b5924abf2-dirty (Mar 01 2020 - 22:17:58 +0100) p212<font></font>
<font></font>
DRAM:  1 GiB<font></font>
MMC:   mmc@72000: 0, mmc@74000: 1<font></font>
reading uboot.env<font></font>
In:    serial@4c0<font></font>
Out:   serial@4c0<font></font>
Err:   serial@4c0<font></font>
[BL31]: tee size: 0<font></font>
[BL31]: tee size: 0<font></font>
Net:   <font></font>
Warning: ethernet@c9410000 (eth0) using random MAC address - 22:10:89:5b:74:85<font></font>
eth0: ethernet@c9410000<font></font>
Hit any key to stop autoboot:  2 0<font></font>
=&gt; version<font></font>
U-Boot 2017.11-02414-g9b5924abf2-dirty (Mar 01 2020 - 22:17:58 +0100) p212<font></font>
<font></font>
aarch64-elf-gcc (Linaro GCC 7.2-2017.11) 7.2.1 20171011<font></font>
GNU ld (Linaro_Binutils-2017.11) 2.28.2.20170706<font></font>
=&gt; <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So that the prefix does not lie idle on the shelf, I decided to put LibreElec on it. Freshly assembled image almost immediately launched without any problems. The kernel was finalized with a small file, drivers for WiFi and remote control were installed, and the poweroff function was redone. And everything worked fine, but then I remembered that the console also supports Bluetooth, which naturally did not work in LibreElec. Although I did not need it, I still decided to set it up to complement the picture. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On board was Ampak's AP6255 chip, responsible for both WiFi and Bluetooth. UART Bluetooth was connected to ttyS1, but the chip did not respond to any HCI commands and pretended to be dead. Moreover, on the native core, the chip, as expected, responded to the team.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The documentation for this chip is very poor and all that could be extracted from there is a pinout. First of all, I checked the chip power and BT_WAKE pin. Everything was normal. Having experimented with the driver itself and the ttyS1 port, I did not get any result - the chip was silent as a partisan and I connected an oscilloscope to it. On it I checked and compared all the electronic UART signals (RTS, TXD, RXD, CTS). Everything was normal. Next, I checked the reset sequence, which is controlled via rfkill (these were the BT_WAKE and BT_REGON pins). But here everything was all right. Then I checked the LPO pin, where according to the documentation a signal with a frequency of 32.768KHz should enter, but even here I saw a signal on the oscilloscope. In general, everything was in order, but the chip did not work with my core. After spending a couple more days disassembling the original UART driver, I returned to the LPO signal and measured its frequency.The result showed 26KHz. Oh how.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The wifi_dt driver was responsible for this signal, which in my core did not correctly generate the frequency. I disassembled the original driver and took over the initialization of the pwm signal from there and ... the chip came to life (later I found a version of this driver with the correct signal). And so, the chip was ready for further tuning, but I had no idea how to put it on alert, because I did not find any drivers / firmware / documentation for it. In the original Android, there was nothing in the kernel log except rfkill when working with Bluetooth. This is understandable, because there was no kernel driver, and the launch took place at the user level. It was necessary to somehow get to the log of Android itself, and for this, root access to the device was needed. To do this, in my naivety, I added the necessary settings to the system section and turned on adb.But with this scenario, Android noticed something was wrong and refused to start at all, referring to some manipulations there ... Well, no, no. I restored the system partition and redid rootfs by simply including sh there. After the subsequent launch, I had root access in the terminal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how the chip was initialized.</font></font><br>
<br>
<pre><code class="plaintext hljs">5759  5781 I bt_hci_h4: hal_open<font></font>
5759  5781 I bt_userial_vendor: userial vendor open: opening /dev/ttyS1<font></font>
5759  5781 E bt_userial_vendor: userial vendor open success!!<font></font>
5759  5781 I bt_userial_vendor: device fd = 52 open<font></font>
5759  5781 I bt_hwcfg: bt vendor lib: set UART baud 2000000<font></font>
5759  5781 I bt_hwcfg: FW prepatch file: /etc/bluetooth/4335/bcm4335_prepatch.hcd<font></font>
5759  5781 I bt_hwcfg: bt vendor lib: loading prepatch /etc/bluetooth/4335/bcm4335_prepatch.hcd<font></font>
5759  5781 D bt_hwcfg: Chipset BCM4335A0<font></font>
5759  5781 D bt_hwcfg: Target name = [BCM4335A0]<font></font>
5759  5781 I bt_hwcfg: FW patchfile: /etc/bluetooth/4335/bcm4335.hcd<font></font>
5759  5781 I bt_hwcfg: bt vendor lib: set UART baud 115200<font></font>
5759  5781 D bt_hwcfg: Settlement delay -- 200 ms<font></font>
5759  5781 I bt_hwcfg: Setting fw settlement delay to 200 <font></font>
5759  5781 I bt_hwcfg: bt vendor lib: set UART baud 2000000<font></font>
5759  5781 I bt_hwcfg: Setting local bd addr to 22:22:99:F7:B6:BD<font></font>
5759  5781 I bt_hwcfg: vendor lib fwcfg completed<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This information was enough to write a program that did the same. </font><font style="vertical-align: inherit;">The last step was to launch hciattach and LibreElec recognized Bluetooth properly. </font><font style="vertical-align: inherit;">Now the device has been fully configured. </font><font style="vertical-align: inherit;">If anyone is interested, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here is the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finished image.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488960/index.html">Programming, Immunity and the Army</a></li>
<li><a href="../en488962/index.html">Can I write scripts in C ++?</a></li>
<li><a href="../en488964/index.html">Urgent tasks. May the Savior come</a></li>
<li><a href="../en488966/index.html">Ansible playbooks is a code: we check, test, continuously integrate. Ivan Ponomarev</a></li>
<li><a href="../en488968/index.html">Simple detection of performance problems in PostgreSQL</a></li>
<li><a href="../en488984/index.html">‚ÄúIf sites work better, it will be perfect‚Äù: interview with Playwright developer Andrey Lushnikov</a></li>
<li><a href="../en488986/index.html">Who is a mentor and what kind of flexible skills should he have</a></li>
<li><a href="../en488990/index.html">Overview of the full-face mask of UNIX 5100, filters to it, comparison with UNIX 5000, 6100 models and PPM-88 mask</a></li>
<li><a href="../en488994/index.html">DDR5? Yes, we barely met DDR4</a></li>
<li><a href="../en488998/index.html">Why AI requirements can only make matters worse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>