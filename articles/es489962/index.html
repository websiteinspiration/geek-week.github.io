<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 😻 🃏 Distribución de datos en Apache Ignite 🐷 ⏱️ 🏇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Hola! Esta publicación es una versión ligeramente abreviada de mi conferencia homónima en la reunión de la comunidad Apache Ignite . Puede ver la ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Distribución de datos en Apache Ignite</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/489962/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Hola! </font><font style="vertical-align: inherit;">Esta publicación es una versión ligeramente abreviada de mi conferencia homónima en la reunión de la comunidad </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Ignite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Puede </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versión completa del video junto con las preguntas y respuestas </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">aquí</font></a><font style="vertical-align: inherit;"> , y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descargar las</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diapositivas </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">aquí</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En el informe, traté de mostrar con ejemplos cómo se distribuyen los datos en Apache Ignite.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué necesitas distribuir algo?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un historial bastante estándar del desarrollo de cualquier sistema que requiera almacenamiento y procesamiento de datos es el logro de un cierto límite. O hay una gran cantidad de datos y no se colocan físicamente en el dispositivo de almacenamiento, o la carga está creciendo a una velocidad tal que un servidor ya no puede procesar tantas solicitudes. Hay casos frecuentes cuando ambos ocurren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como regla, llegan a una de dos soluciones: fragmentar el almacenamiento existente o cambiar a una base de datos distribuida. Ambas soluciones tienen una serie de características comunes, la más obvia de las cuales es el uso de más de un nodo para trabajar con datos. Además, a muchos nodos los llamaré topología.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema de la distribución de datos entre los nodos de topología se puede formular como un conjunto de requisitos, que nuestra distribución debe satisfacer:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se necesita un algoritmo que permita que todos los nodos de la topología y las aplicaciones del cliente lleguen a la misma conclusión sobre en qué nodo o nodos se encuentra el determinado objeto (o clave).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uniformidad de distribución. </font><font style="vertical-align: inherit;">Cuanto más uniformemente se distribuyan los datos entre nodos, más uniformemente se distribuirá la carga en estos nodos. </font><font style="vertical-align: inherit;">Aquí supongo que nuestros nodos tienen aproximadamente los mismos recursos.</font></font></li>
<li>  .      ,       ,    .   ,       ,       ,     .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lograr los dos primeros requisitos es bastante fácil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un enfoque familiar, que se usa a menudo al equilibrar la carga entre servidores funcionalmente equivalentes, dividiendo el módulo N, donde N es el número de nodos en la topología y tenemos una correspondencia uno a uno entre el número de nodo y su identificador. Entonces, todo lo que tenemos que hacer es representar la clave del objeto como un valor numérico utilizando una función hash y tomar el resto de la división entre N del valor obtenido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zi/7x/ii/zi7xiiu8xmrjgaeghuc8xkekubk.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El diagrama muestra la distribución de 16 claves en 3 nodos. Se puede ver que esta distribución es uniforme, y el algoritmo para obtener el nodo para el objeto es simple y garantiza que si todos los nodos de la topología usan este algoritmo, se obtendrá el mismo resultado para la misma clave y el mismo N.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¿qué sucede si introducimos el cuarto nodo en la topología? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/ro/-i/82ro-ipa6d3lw8stb_fx7e9_wos.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestra función ha cambiado, ahora tomamos el resto de la división por 4, no por 3. Y si la función ha cambiado, entonces la distribución ha cambiado, y mucho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, la ubicación anterior de los objetos para la versión anterior de la topología de tres nodos se muestra en rojo, y la posición de los objetos para la nueva versión de la topología de cuatro nodos es verde, respectivamente. Esto es muy similar a los archivos diff habituales, pero en lugar de archivos tenemos nodos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es fácil ver que los datos se han movido no solo al nuevo nodo, sino que también hubo un intercambio de datos entre los nodos que ya estaban en la topología. Aquellos. observamos tráfico espurio entre nodos y no se cumple el requisito de un cambio mínimo en la distribución.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dos formas populares de resolver el problema de la distribución de datos, teniendo en cuenta los requisitos enumerados, son las siguientes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash constante</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo de peso aleatorio más grande (HRW), también conocido como hash de Rendezvous.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambos algoritmos son muy simples. </font><font style="vertical-align: inherit;">Sus descripciones en Wikipedia encajan en varias oraciones. </font><font style="vertical-align: inherit;">Aunque es difícil llamarlos obvios. </font><font style="vertical-align: inherit;">Para aquellos interesados, recomiendo leer los artículos originales </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing consistente y árboles aleatorios: protocolos de almacenamiento en caché distribuidos para aliviar puntos calientes en la World Wide Web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un esquema de mapas basado en nombres para Rendezvous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lo más comprensible, en mi opinión, la idea de un algoritmo de hash consistente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se transmite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">este curso de Stanford</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos estos algoritmos con más detalle.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing consistente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El truco que subyace al algoritmo de hash consistente es asignar ambos nodos y objetos almacenados al mismo espacio identificador. </font><font style="vertical-align: inherit;">Esto hace que nuestras entidades, objetos y nodos aparentemente diferentes sean comparables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener dicho mapeo, simplemente aplicamos la misma función hash a las teclas de los objetos y a los identificadores de los nodos. </font><font style="vertical-align: inherit;">El resultado de la función hash para el nodo se llamará un token, esto nos será útil más adelante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Representamos nuestro espacio identificador en forma de círculo, es decir. </font><font style="vertical-align: inherit;">simplemente asumimos que el valor identificador máximo sigue inmediatamente al valor identificador mínimo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, para determinar en qué nodo vive el objeto, debe obtener el valor de la función hash de su clave, y luego simplemente moverse en el sentido de las agujas del reloj alrededor del círculo hasta que encontremos la ficha de un nodo en el camino. La dirección del movimiento no es importante, pero debe ser fija. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El movimiento imaginario en el sentido de las agujas del reloj es funcionalmente equivalente a una búsqueda binaria en una matriz ordenada de tokens de nodo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/dh/fy/cadhfyrlc9b_maoinnjw0kvp6fm.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el diagrama, cada sector de un color particular refleja el espacio identificador del que es responsable un nodo particular. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si agregamos un nuevo nodo, entonces ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v7/an/3r/v7an3r9bwxn9hnziy-w7umr5viq.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... dividirá uno de los sectores en dos partes y asumirá completamente las teclas correspondientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, el nodo 3 se hizo cargo de parte de las claves del nodo 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, este enfoque proporciona una distribución bastante desigual de los objetos entre los nodos, porque depende en gran medida de los identificadores de los propios nodos. ¿Cómo se puede mejorar este enfoque? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede asignar más de un token a los nodos (generalmente cientos). Esto se puede lograr, por ejemplo, introduciendo muchas funciones hash para el nodo (una por token) o aplicando repetidamente la misma función hash al token obtenido en el paso anterior. Pero no debemos olvidarnos de las colisiones. No debe haber dos nodos con el mismo token. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7i/m2/ay/7im2ay5cr_ydc5hh62vlwcaqhp0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, cada nodo tiene 4 tokens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qué más es importante mencionar: si queremos garantizar la seguridad de los datos en el caso de que un nodo abandone la topología, entonces debemos almacenar las claves en varios nodos (las llamadas réplicas o copias de seguridad). </font><font style="vertical-align: inherit;">En el caso del algoritmo hash consistente, las réplicas serán los siguientes nodos N-1 en el círculo, donde N es el factor de replicación. </font><font style="vertical-align: inherit;">Por supuesto, el orden de los nodos debe estar determinado por un token específico (por ejemplo, por el primero), porque </font><font style="vertical-align: inherit;">cuando se usan múltiples tokens para cada uno de ellos, la disposición de los nodos puede diferir. </font><font style="vertical-align: inherit;">Preste atención al esquema: no tiene un patrón claro de repetición de nodos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto al requisito de un cambio mínimo en la distribución al cambiar la topología, se cumple porque el orden mutuo de los nodos en el círculo no cambia. </font><font style="vertical-align: inherit;">Aquellos. </font><font style="vertical-align: inherit;">eliminar un nodo de la topología no cambiará la relación de orden entre los nodos restantes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cita hash</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo de hash de Rendezvous parece incluso más simple que el hashing consistente. El algoritmo se basa en el mismo principio de invariancia de las relaciones de orden. Pero en lugar de hacer comparables nodos y objetos, solo hacemos nodos para un objeto específico comparable. Aquellos. Determinamos la relación de orden entre los nodos para cada objeto de forma independiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De nuevo hashing nos ayuda con esto. Pero ahora, para determinar el peso del nodo N para un objeto O dado, mezclamos el identificador del objeto con el identificador del nodo y tomamos el hash de esta mezcla. Una vez realizada esta operación para cada nodo, obtenemos un conjunto de pesos por el cual clasificamos los nodos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El nodo que resultó ser el primero y será responsable de almacenar el objeto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como todos los nodos de la topología usan los mismos datos de entrada, el resultado para ellos será idéntico. Que satisface el primer requisito. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/hs/bw/oxhsbwgq8xrlfrirs8xupmx3hww.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considera un ejemplo. Aquí tenemos una relación de orden entre tres nodos para cuatro claves diferentes. El amarillo indica el nodo con el mayor peso, es decir el nodo que finalmente será responsable de una clave particular. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue otro nodo a la topología.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hc/a9/4s/hca94sz_p5pz-lwflppuqlm7c54.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo coloqué deliberadamente en diagonal para tener en cuenta todas las opciones posibles. Aquí, el nodo 3, que se muestra en verde, ingresó a la topología. Por lo tanto, la distribución de peso de los nodos para cada una de las claves ha cambiado. El rojo indica los nodos que han cambiado su ubicación en la lista para una clave en particular, porque Los pesos de estos nodos eran menores que el peso del nodo agregado. Sin embargo, este cambio afectó solo a una de las claves, K3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derivemos traicioneramente un nodo de una topología. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/gr/d_/dsgrd_q9ai9yi9p5x08ubfgflem.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez más, los cambios afectaron solo una clave, esta vez K1. Los objetos restantes no fueron afectados. La razón, como en el caso del hashing consistente, es la invariabilidad de la relación de orden entre cualquier par de nodos. Aquellos. Se cumple el requisito de un cambio mínimo en la distribución y no hay tráfico espurio entre los nodos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La distribución de la cita se ve bastante bien y no requiere trucos adicionales en comparación con el hashing consistente como tokens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En caso de que queramos admitir la replicación, el siguiente nodo de la lista será la primera réplica del objeto, el siguiente nodo será la segunda réplica, etc.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo se usa el hash de encuentro en Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La llamada función de afinidad es responsable de la distribución de datos en Apache Ignite (consulte la interfaz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). La implementación predeterminada es el hash de encuentro (consulte la clase </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RendezvousAffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero a lo que debe prestar atención es que Apache Ignite no asigna objetos almacenados directamente a los nodos de topología. En cambio, se introduce un concepto adicional: partición. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una partición es un contenedor para objetos y una unidad de replicación. Además, el número de particiones para un caché particular (este es un análogo de la tabla en las bases de datos familiares) se establece en la etapa de configuración y no cambia durante el ciclo de vida del caché.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, podemos mostrar objetos en particiones usando una división de módulo efectiva, y usar hashing de encuentro para mostrar particiones en nodos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/wr/vt/wdwrvtuau9ywcgq4uqk0hhqscu8.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porque el número de particiones para la memoria caché es constante, luego podemos calcular la distribución de la partición por nodos una vez y almacenar en caché el resultado hasta que se cambie la topología. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada nodo calcula esta distribución de forma independiente, pero en todos los nodos con los mismos datos de entrada, esta distribución será idéntica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partición puede tener varias copias, las llamamos copias de seguridad. La partición primaria se llama partición primaria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para la mejor distribución de claves entre particiones y particiones por nodos, se debe cumplir la siguiente regla: el número de particiones debe ser significativamente mayor que el número de nodos, a su vez, el número de claves debe ser significativamente mayor que el número de particiones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las cachés en Ignite se particionan y replican. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una memoria caché particionada, el número de copias de seguridad se establece en la etapa de creación de la memoria caché. Las particiones (primarias y copias de seguridad) se distribuyen uniformemente entre los nodos. Tal caché es más adecuada para trabajar con datos operativos, como proporciona el mejor rendimiento de escritura, que depende directamente de la cantidad de copias de seguridad. En general, cuantas más copias de seguridad, más nodos deben confirmar el registro clave.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/fs/_u/hhfs_ujczi2m1p8kl4c5z3p2ra4.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, el caché tiene una copia de seguridad. </font><font style="vertical-align: inherit;">Aquellos. </font><font style="vertical-align: inherit;">podemos perder un nodo y no perder datos, porque </font><font style="vertical-align: inherit;">Las copias de seguridad de la partición nunca se almacenan en el mismo nodo que la partición primaria o su otra copia de seguridad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la memoria caché replicada, el número de copias de seguridad siempre es igual al número de nodos de topología menos 1. Es decir, </font><font style="vertical-align: inherit;">cada nodo siempre contiene copias de todas las particiones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/fk/by/n-fkbyie-hipm40twvyg_erjjm0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal caché es más adecuada para trabajar con datos que rara vez cambian (por ejemplo, directorios) y proporciona la mayor disponibilidad, como </font><font style="vertical-align: inherit;">podemos perder nodos N-1 (en este caso 3) sin perder datos. </font><font style="vertical-align: inherit;">También en esta opción, obtendremos el máximo rendimiento de lectura si permitimos leer datos de las particiones primarias y las copias de seguridad.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocación de datos en Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un concepto importante a tener en cuenta para obtener el mejor rendimiento es la colocación. Colocación es la colocación de cualquier objeto en el mismo lugar. En nuestro caso, los objetos son entidades almacenadas en la memoria caché, y un lugar es un nodo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si los objetos se distribuyen entre particiones de la misma función de afinidad, es lógico que los objetos con la misma clave de afinidad caigan en la misma partición y, por lo tanto, en el mismo nodo. En Ignite, esto se llama colocación de afinidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por defecto, una clave de afinidad es la clave principal de un objeto. Pero en Ignite, puede usar cualquier otro campo de un objeto como clave de afinidad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La colocación reduce significativamente la cantidad de datos enviados entre nodos para realizar cálculos o consultas SQL, lo que naturalmente lleva a una reducción en el tiempo dedicado a estas tareas. Considere este concepto con el ejemplo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deje que nuestro modelo de datos consista en dos entidades: orden (orden) y posición de orden (artículo de orden). Un pedido puede corresponder a muchos artículos. Los identificadores de pedido y línea de pedido son independientes, pero la línea de pedido tiene una clave externa que se refiere al pedido correspondiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que necesitamos realizar alguna tarea, que para cada orden debe realizar cálculos para las posiciones de este orden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por defecto, una clave de afinidad es una clave primaria. Por lo tanto, los pedidos y las posiciones se distribuirán entre los nodos de acuerdo con sus claves principales, que, según recuerdo, son independientes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/q-/vq/tkq-vq1_sbghpcqdsz8ythpehim.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el diagrama, las órdenes están representadas por cuadrados y posiciones en círculos. El color indica que el artículo pertenece al pedido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con esta distribución de datos, nuestra tarea hipotética se enviará al nodo donde se encuentra el orden deseado, y luego tendrá que leer las posiciones de todos los demás nodos, o enviar una subtarea a estos nodos y obtener el resultado del cálculo. Esta es una interacción de red innecesaria que puede y debe evitarse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué sucede si le decimos a Ignite que los artículos de pedido deben colocarse en los mismos nodos que los mismos pedidos, es decir? ¿recolectar datos? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como clave de afinidad para la posición, tomamos la clave externa OrderId y este campo se utilizará al calcular la partición a la que pertenece el registro. Además, dentro de la partición, siempre podemos encontrar nuestro objeto por la clave primaria.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/uq/kg/lvuqkgzf9gpoot8gjnr25uxb6ve.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, si ambas memorias caché (Order y OrderItem) usan la misma función de afinidad con los mismos parámetros, nuestros datos estarán cerca y no necesitaremos recorrer la red para buscar artículos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuración de afinidad en Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la implementación actual, un objeto de función de afinidad es un parámetro de configuración de caché. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función de afinidad en sí toma los siguientes argumentos al crear:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Número de particiones;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El número de copias de seguridad (de hecho, este también es el parámetro de configuración de la memoria caché);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtro de respaldo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bandera excluye a los vecinos.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas configuraciones no se pueden cambiar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la cantidad de particiones y copias de seguridad, todo parece estar claro. Hablaré sobre el filtro de respaldo y la bandera excludeNeighbours un poco más tarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tiempo de ejecución, la función de afinidad de entrada recibe la topología de clúster actual, esencialmente una lista de nodos de clúster, y calcula la distribución de particiones por nodos de acuerdo con los ejemplos que mostré cuando hablé sobre el algoritmo de hash de encuentro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto al filtro de respaldo, este es un predicado que le permite prohibir que las funciones de afinidad asignen particiones de respaldo a un nodo para el cual el predicado devolvió falso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ejemplo, supongamos que nuestros nodos físicos (servidores) están ubicados en el centro de datos en diferentes bastidores. Por lo general, cada bastidor tiene su propio poder independiente ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/ts/wy/5etswypgpotv2e9exzu3gsyl9f8.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y si perdemos el rack, perdemos los datos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/hy/5d/nzhy5dzl77t7pxhtxbtqubcbzek.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, perdimos la mitad de las particiones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero si configuramos el filtro de copia de seguridad correcto, la distribución cambiará de tal manera ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/90/gy/2090gyzlg_0-80-dhkw8hvplftm.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... que si se pierde el bastidor, no habrá pérdida de datos y aún estarán disponibles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/eg/k5/ooegk5vas7xhk7qzrergws5ieli.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El indicador excludeNeighbours realiza una función similar y, de hecho, es una abreviatura para un caso específico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A menudo, varios nodos Ignite se ejecutan en el mismo host físico. Este caso es muy similar al ejemplo con bastidores en el centro de datos, solo que ahora estamos luchando contra la pérdida de datos con la pérdida del host, no los bastidores. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/ze/wn/tkzewnmjc5iigjd_appzyvfoheo.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resto es igual. Puede implementar este comportamiento utilizando un filtro de respaldo. Esta bandera es un legado histórico y puede eliminarse en la próxima versión principal de Ignite.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que hablé sobre la función de afinidad y la distribución de datos, todo lo que un desarrollador que usa Apache Ignite necesita saber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusión, veamos un ejemplo de la distribución de 16 particiones de acuerdo con la topología de 3 nodos. Por simplicidad y claridad, creemos que las particiones no tienen copias de seguridad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acabo de tomar y escribí una pequeña prueba que me trajo la distribución real: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/lm/np/yylmnpenoifogzoo0lig3kzw_5g.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, la uniformidad de la distribución no es ideal. Pero el error será notablemente menor con un aumento en el número de nodos y particiones. La regla principal que debe observarse es que el número de particiones es significativamente mayor que el número de nodos. Ahora, en Ignite, el número predeterminado de particiones para un caché particionado es 1024. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora agregue un nuevo nodo a la topología.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xd/xf/sp/xdxfspt29ky3x0gfceqi_xiswv0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parte de las partes se mudaron a él. Al mismo tiempo, se observó el requisito de un cambio mínimo en la distribución: el nuevo nodo recibió parte de las particiones, mientras que los otros nodos no intercambiaron particiones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eliminamos de la topología el nodo que estaba presente en él en la etapa inicial: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b5/il/ymb5ilednyy4dxf6ynojfva7gao.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ahora todas las particiones que estaban asociadas con el nodo cero se redistribuyeron a otros nodos de la topología, sin violar nuestros requisitos de distribución.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, la solución a problemas complejos a menudo se basa en ideas bastante triviales, aunque no del todo obvias. </font><font style="vertical-align: inherit;">Las soluciones descritas se utilizan en la mayoría de las bases de datos distribuidas y hacen un buen trabajo. </font><font style="vertical-align: inherit;">Pero estas decisiones son aleatorias y, por lo tanto, la uniformidad de distribución dista mucho de ser ideal. </font><font style="vertical-align: inherit;">¿Se puede mejorar la uniformidad sin sacrificar el rendimiento y otros requisitos de distribución? </font><font style="vertical-align: inherit;">La pregunta permanece abierta.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489952/index.html">Fondos de escritorio en vivo y motivadores</a></li>
<li><a href="../es489954/index.html">Seagate SkyHawk AI: enorme y vengativo</a></li>
<li><a href="../es489956/index.html">Animamos RecyclerView fácilmente sin cambiar a ViewPager2</a></li>
<li><a href="../es489958/index.html">Explicación: por qué wc en Haskell resultó ser "más rápido" que el análogo en C</a></li>
<li><a href="../es489960/index.html">Compilación automatizada de una aplicación Delphi</a></li>
<li><a href="../es489968/index.html">Capturamos la degradación de las baterías AA y AAA a corrientes de 0.3 de la capacitancia</a></li>
<li><a href="../es489970/index.html">Programador, Pack y John Steinbeck</a></li>
<li><a href="../es489974/index.html">Kha vs HTML5: compilando JavaScript en C ++</a></li>
<li><a href="../es489984/index.html">AMA sobre udalenka: pregunta - respondemos</a></li>
<li><a href="../es489986/index.html">Power Stage Designer Utility - Herramienta para desarrolladores de Power Electronics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>