<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏻 🚱 👨🏼‍✈️ 有关C ++中协程的更多信息 💧 🐀 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好
 
 作为C ++ 20主题研究的一部分，我们一次看到了Yandex中心博客上一篇相当古老的文章（2018年9月），该文章被称为“ 为C ++ 20做准备。CoroutinesTS有一个真实的例子。”最后以以下非常有表现力的投票结束：
 
 
 
 “为什么不这样做”，我们决定并翻译了大卫·...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>有关C ++中协程的更多信息</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大家好</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为C ++ 20主题研究的一部分，我们一次看到了Yandex中心博客上一篇相当古老的文章（2018年9月），该文章被称为“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为C ++ 20做准备。CoroutinesTS有一个真实的例子</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。”最后以以下非常有表现力的投票结束：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“为什么不这样做”，我们决定并翻译了大卫·皮拉尔斯基（David Pilarski）的文章，标题为“协程介绍”。该文章发表于一年多前，但希望您无论如何都会觉得很有趣。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样了。经过大量的怀疑，争议和对该功能的准备之后，WG21就协程在C ++中的外观达成了共识-并且它们很可能会进入C ++20。由于这是一个主要功能，我认为现在是时候准备和研究它了。现在（您还记得，还有更多的模块，概念，学习范围...）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多仍然反对协程。他们经常抱怨开发的复杂性，许多定制点，以及由于动态内存分配可能未优化而导致的性能欠佳（也许；））。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开发批准的（正式发布的）技术规范（TS）的同时，甚至尝试并行开发Corutin的另一种机制。</font><font style="vertical-align: inherit;">在这里，我们将讨论TS（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术规范</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">中描述的那些协程</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">反过来，另一种方法属于Google。</font><font style="vertical-align: inherit;">结果，事实证明Google的方法存在许多问题，要解决这些问题通常需要C ++的奇怪附加功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，决定采用Microsoft开发的Corutin版本（由TS赞助）。</font><font style="vertical-align: inherit;">本文将讨论这种协程。</font><font style="vertical-align: inherit;">因此，让我们从...的问题开始</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是协程？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
协程已经存在于许多编程语言中，例如Python或C＃。</font><font style="vertical-align: inherit;">协程是创建异步代码的另一种方法。</font><font style="vertical-align: inherit;">它们与流程有何不同，为什么协程应作为专用语言功能实现，最后将在本节中说明它们的用途。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于什么是协程存在严重的误解。</font><font style="vertical-align: inherit;">根据使用它们的环境，它们可能被称为：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无堆栈协程</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈协程</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿色溪流</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纤维类</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古鲁丁</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好消息：堆叠的corutins，绿色的溪流，纤维和gorutins是一回事（但有时它们以不同的方式使用）。我们将在本文的后面部分讨论它们，我们将它们称为纤维或协程。但是无堆栈协程具有一些功能，需要单独讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了理解协程，包括在直观的层面上，让我们简要地了解一下函数，以及（让我们这样说）“他们的API”。与他们合作的标准方法是致电并等待其完成：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调用该函数后，已经无法暂停或恢复其工作。您只能对函数执行两项操作：</font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。启动该功能后，您必须等待直到完成。如果再次调用该函数，则将从头开始执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于协程，情况就不同了。您不仅可以启动和停止它们，还可以暂停和继续它们。它们仍然与核心流程不同，因为协程本身并不拥挤（另一方面，协程通常是指流程，并且流程正在拥挤）。要理解这一点，请考虑使用Python定义的生成器。让这样的东西在Python中称为生成器，在C ++中将称为协程。从此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">站点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取一个示例</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此代码的工作方式如下：函数调用</font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导致创建协程对象。</font><font style="vertical-align: inherit;">在枚举协程对象的每个步骤中，协程本身都会恢复工作并仅在</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码中</font><font style="vertical-align: inherit;">的关键字之后暂停它</font><font style="vertical-align: inherit;">；</font><font style="vertical-align: inherit;">然后返回序列中的下一个整数（for循环是调用</font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恢复协程</font><font style="vertical-align: inherit;">的函数的语法糖</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">该代码通过遇到break语句来结束循环。</font><font style="vertical-align: inherit;">在这种情况下，corutin永远不会结束，但是很容易想到corutin到达终点并结束的情况。</font><font style="vertical-align: inherit;">正如我们所看到的，到korutine适用的操作</font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">[注意：C ++还提供了创建和销毁操作，但在直观了解协程的背景下它们并不重要]。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程作为图书馆</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，现在大致清楚了什么是协程。</font><font style="vertical-align: inherit;">您可能知道有用于创建光纤对象的库。</font><font style="vertical-align: inherit;">问题是，为什么我们需要专用语言功能形式的协程，而不仅仅是需要使用协程的库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们试图回答这个问题，并说明堆叠式和非堆叠式协程之间的区别。</font><font style="vertical-align: inherit;">这种差异是理解corutin作为语言一部分的关键。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈协程</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，让我们首先讨论什么是堆栈协程，它们如何工作以及为什么可以将它们实现为库。</font><font style="vertical-align: inherit;">对它们的解释相对简单，因为它们在设计方面类似于流。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
纤维或堆栈corutin具有单独的堆栈，可用于处理函数调用。</font><font style="vertical-align: inherit;">为了确切地了解这种协程是如何工作的，我们从底层的角度简要地看一下函数框架和函数调用。</font><font style="vertical-align: inherit;">但首先，让我们谈谈纤维的特性。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们有自己的栈，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光纤的寿命不取决于调用它们的代码（通常它们具有用户定义的调度程序），</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以将光纤从一根线上拆下并连接到另一根线上，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合作计划（光纤必须决定切换到另一个光纤/调度程序），</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法在同一线程中同时工作。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上述属性产生以下效果：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切换光纤的上下文应该由光纤的用户执行，而不是由操作系统执行（此外，操作系统可以释放光纤，释放其工作所在的线程），</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两根光纤之间没有真正的数据竞争，因为在任何给定时间，它们中只有一根可以处于活动状态，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光纤设计人员必须能够选择合适的地点和时间，在适当的时间和地点将计算能力返回给可能的调度程序或调用方。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光纤中的输入/输出操作必须是异步的，以便其他光纤可以执行任务而不会互相阻塞。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们仔细研究一下光纤的操作，并首先说明堆栈如何参与函数调用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，堆栈是存储局部变量和函数参数所需的连续内存块。但是，更重要的是，在每个函数调用之后（有一些例外），其他信息都被压入堆栈，该信息告诉被调用函数如何返回调用者并恢复处理器寄存器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中一些寄存器具有特殊的分配，并且在调用函数时，它们会存储在堆栈中。这些是寄存器（在ARM体系结构中）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SP-堆栈指针</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LR-通信寄存器</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC-程序计数器</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈指针</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（SP）是一个寄存器，其中包含与当前函数调用相关的堆栈起始地址。由于现有的值，您可以轻松地引用存储在堆栈中的参数和局部变量。</font><font style="vertical-align: inherit;">调用函数时</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，通信寄存器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（LR）非常重要。它存储返回地址（主叫方的地址），当前功能执行完成后将在该地址执行代码。调用该功能时，PC将保存在LR中。函数返回后，将使用LR恢复PC。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序计数器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（PC）是当前正在执行的指令的地址。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每当调用一个函数时，都会保存链接列表，以便该函数知道程序完成后应返回的位置。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用和返回函数</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
时</font><i><font style="vertical-align: inherit;">PC和LR寄存器的行为</font></i><font style="vertical-align: inherit;">在执行堆栈协程时，被调用函数使用先前分配的堆栈来存储其参数和局部变量。</font><font style="vertical-align: inherit;">由于有关在corutin堆栈上调用的每个功能的所有信息都存储在堆栈中，因此光纤可以暂停该corutin中的任何功能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看这张照片中发生了什么。</font><font style="vertical-align: inherit;">首先，每根光纤和线都有自己独立的堆栈。</font><font style="vertical-align: inherit;">绿色表示序列号，表示操作顺序。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程内的常规函数​​调用。</font><font style="vertical-align: inherit;">内存分配在堆栈上。</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> –     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用堆栈协程时，不需要确保其使用的专用语言功能。</font><font style="vertical-align: inherit;">可以使用库很好地实现整个堆栈的可用性，并且已经存在专门为此目的设计的库：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost .Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在所有这些库中，只有Boost是C ++，其余所有都是C。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关这些库如何工作的详细说明，</font><font style="vertical-align: inherit;">请参见</font><font style="vertical-align: inherit;">文档。</font><font style="vertical-align: inherit;">但是，总的来说，所有这些库都允许您为光纤创建一个单独的堆栈，并提供恢复协程（在调用方的倡议下）和暂停（从内部）它的机会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一个例子</font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该库具有用于协程的内置调度程序。</font><font style="vertical-align: inherit;">所有光纤都在同一根线中运行。</font><font style="vertical-align: inherit;">由于corutin规划是协作的，因此光纤必须首先决定何时将控制权返回给调度程序。</font><font style="vertical-align: inherit;">在此示例中，这在调用yield函数时发生，这会暂停协程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于没有其他光纤，因此光纤规划人员总是决定恢复协程。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无堆栈协程</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无堆栈协程的属性与堆栈协程的属性略有不同。</font><font style="vertical-align: inherit;">但是，它们具有相同的基本特征，因为也可以启动未堆叠的协程，并且在它们暂停后可以恢复运行。</font><font style="vertical-align: inherit;">我们可能会在C ++ 20中找到这种类型的协程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们谈论Corutin的相似特性，那么协程可以：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin与呼叫者紧密相连：当调用协程时，执行将转移给她，协程的结果会转移回给调用者。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叠层corutin的寿命等于其叠层的寿命。</font><font style="vertical-align: inherit;">无堆栈协程的寿命等于其对象的寿命。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在无堆栈协程的情况下，无需分配整个堆栈。它们消耗的内存比堆栈的要少得多，但这恰好是由于它们的某些限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，如果它们不为堆栈分配内存，那么它们如何工作？在这种情况下，使用堆栈协程时应将所有数据存储在堆栈中。答：在调用方的堆栈上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无堆栈协程的秘密在于它们只能使自己停止于最顶层的功能。对于所有其他功能，它们的数据位于被调用方的堆栈上，因此从corutin调用的所有功能必须在corutin的工作暂停之前完成。协程维护其状态所需的所有数据都在堆上动态分配。这通常需要几个局部变量和参数，这比必须事先分配的整个堆栈要紧凑得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看看无堆栈的corutins的工作原理：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挑战无堆栈的corutin</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，现在只有一个堆栈-这是线程的主堆栈。</font><font style="vertical-align: inherit;">让我们逐步看一下该图中显示的内容（这里的协程激活框是两种颜色-黑色显示存储在堆栈中的颜色，蓝色显示存储在堆中的颜色）。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规函数调用，其框架存储在堆栈中</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数创建一个协程</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">也就是说，它在堆上的某个位置为其分配激活帧。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常函数调用。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">致电Corutin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Corutin的身体有规律地突出。</font><font style="vertical-align: inherit;">该程序的执行方式与常规功能相同。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从协程调用常规函数。</font><font style="vertical-align: inherit;">同样，一切仍然在堆栈上发生[请注意：此刻您不能暂停协程，因为这不是协程中最重要的功能]</font></font></li>
<li>       [:     .]</li>
<li>  –  ,        ,     .</li>
<li>  </li>
<li><b>  </b> –      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，很明显，在第二种情况下，暂停和恢复Corutin工作的所有操作都需要记住少得多的数据，但是，协程只能自行恢复，也只能从最高功能暂停。所有函数调用和协程以相同的方式发生，但是，两次调用之间必须保存一些其他数据，并且该函数必须能够跳转到挂起点并恢复局部变量的状态。协程框架和功能框架之间没有其他区别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
肾上腺皮质激素还可以引起其他协程（在此示例中未显示）。</font><font style="vertical-align: inherit;">在无堆栈协程的情况下，每次调用都会为新的协程数据分配新的空间（重复调用协程，动态内存也可以分配多次）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
协程需要提供专用语言功能的原因是因为编译器需要确定哪些变量描述了协程的状态，并创建构造型代码以跳转到暂停点。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皮质激素的实际使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++中的协程可以与其他语言相同的方式使用。</font><font style="vertical-align: inherit;">协程将简化拼写：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发电机</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步输入/输出代码 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">惰性计算</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件驱动的应用</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望通过阅读本文可以了解：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么在C ++中需要将协程实现为专用语言功能</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆叠式协程和非堆叠式协程有什么区别？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么需要协程</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491986/index.html">RemoteLoRa-超过ON / OFF</a></li>
<li><a href="../zh-CN491988/index.html">Red Hat OpenShift 4.2和4.3的新增功能？</a></li>
<li><a href="../zh-CN491990/index.html">与中国芯片ADC Hx711一起使用（结论）</a></li>
<li><a href="../zh-CN491992/index.html">分析师发展</a></li>
<li><a href="../zh-CN491994/index.html">从Cocoapods迁移到Swift Package Manager</a></li>
<li><a href="../zh-CN492000/index.html">产品第一。燃尽</a></li>
<li><a href="../zh-CN492002/index.html">吸光翼：超级黑蝴蝶的秘密</a></li>
<li><a href="../zh-CN492004/index.html">如何从程序员成长为经理（“我想成为大海的情妇”）</a></li>
<li><a href="../zh-CN492006/index.html">PWA的力量：具有300行神经网络JS代码的视频监视系统</a></li>
<li><a href="../zh-CN492008/index.html">IT动机研究的结果：开发人员对他们的工作满意吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>