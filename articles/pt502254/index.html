<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👙 👩🏽‍🤝‍👩🏻 ♒️ PostgreSQL: Programação do lado do servidor na linguagem humana (PL / Perl, PL / Python, PL / v8) 🦇 🌠 🤜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Postgres é conhecido por sua extensibilidade, que também se aplica ao suporte a linguagens procedurais (PL). Ninguém pode se gabar de um idioma com ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL: Programação do lado do servidor na linguagem humana (PL / Perl, PL / Python, PL / v8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Postgres é conhecido por sua extensibilidade, que também se aplica ao suporte a linguagens procedurais (PL). Ninguém pode se gabar de um </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idioma com uma</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista de idiomas desse tamanho, e potencialmente essa lista não é de todo limitada: para conectar o idioma ao servidor, não é necessário nenhum esforço extra. Você pode até criar seu próprio idioma e torná-lo um idioma processual do servidor. Alterações no DBMS não exigirão isso. Como muito mais, essa extensibilidade foi incorporada à arquitetura do Postgres desde o início. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É possível e às vezes necessário escrever linguagens PL para tarefas. Melhor ainda, se alguém escrever uma estrutura para escrever linguagens para que você possa escrever não em C, mas para escolher uma linguagem que seja mais confortável para um desenvolvedor de linguagem. Como no FDW, que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser escrito em Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo foi escrito com base em vários relatórios e master classes sobre esse tópico, elaborados pelo autor nas conferências </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não se trata de exotismo, mas das linguagens de procedimentos mais comuns PL / Perl, PL / Python e PL / V8 (ou seja, JavaScript) e comparação de seus recursos com PL / pgSQL.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando vale a pena usar esses idiomas? </font><font style="vertical-align: inherit;">Quando o SQL e o PL / pgSQL estão ausentes?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, quando você precisar trabalhar com estruturas complexas, com algoritmos: atravessando árvores, por exemplo, ou quando a análise de HTML ou XML for necessária, especialmente ao extraí-las dos arquivos;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando você precisa gerar dinamicamente SQL complexo (relatórios, ORM). </font><font style="vertical-align: inherit;">No PL / pgSQL, não é apenas inconveniente, mas também funciona mais devagar em alguns casos;</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   —    .   , ,   untrusted- (  — . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E mais uma coisa: se você escrever algo em C, poderá criar um protótipo nessas linguagens que sejam mais adaptadas ao desenvolvimento rápido.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como incorporar um idioma no Postgres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar o idioma que você precisa: escreva em C de uma a três funções:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER - um manipulador de chamadas que executará uma função no idioma (esta é uma parte necessária);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE - manipulador de blocos anônimos (se você quiser que o idioma suporte blocos anônimos);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VALIDADOR - função de verificação de código ao criar uma função (se você deseja que essa verificação seja feita).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é descrito em detalhes na documentação </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Idiomas prontos para uso" e outros idiomas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem apenas quatro idiomas suportados "prontos para uso": </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tcl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas o cócegas é um tributo à história: poucas pessoas o usam agora, não falamos mais sobre isso. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl, PL / Python e, é claro, PL / pgSQL são suportados pela comunidade Postgres. O suporte para outros idiomas que não são da caixa é dos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mantenedores</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - empresas, comunidades ou desenvolvedores específicos interessados ​​em fazer o idioma funcionar dentro do DBMS. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> promove o Google. Mas de tempos em tempos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existem razões</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duvide do futuro sem nuvens do PL / V8. O atual mantenedor do projeto PL / V8 do Google, Jerry Sievert, está considerando o suporte a JS baseado em servidor postgres com base em um mecanismo diferente (como o QuickJS), pois o PL / V8 é difícil de construir e requer 3-5 GB todo tipo de coisa no Linux durante a construção, e isso geralmente leva a problemas em diferentes sistemas operacionais. Mas o PL / V8 é amplamente utilizado e exaustivamente testado. É possível que PL / JS apareça como uma alternativa a outro mecanismo JS, ou por enquanto apenas como um nome, ao qual nos acostumaremos durante o período de transição. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raramente é usado. Eu, pessoalmente, não precisava escrever em PL / Java, porque no PL / Perl e no PL / V8 há funcionalidade suficiente para quase todas as tarefas. Até o Python não adiciona recursos em particular. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Útil para quem gosta de estatísticas e ama este idioma. Também não vamos falar sobre ele aqui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As linguagens populares não são necessariamente populares nos armazenamentos de gravação: existe o PL / PHP, mas agora praticamente não é suportado por ninguém - há poucos que desejam escrever procedimentos de servidor. Para a linguagem PL / Ruby, a imagem é de alguma forma a mesma, embora a linguagem pareça ser mais moderna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma linguagem procedural baseada em Go está sendo desenvolvida, veja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, ao que parece, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Será necessário estudá-los. Para os fãs teimosos da concha, há até </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , é difícil imaginar o que possa ser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há pelo menos uma linguagem procedural específica de domínio (DSL) que é estritamente especializada para sua tarefa - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que costumava ser muito popular para proxy e balanceamento de carga do servidor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, abordaremos os principais idiomas mais usados. Obviamente, isso é PL / PgSQL, PL / Perl, PL / Python e PL / V8, os chamaremos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os idiomas “prontos para o uso” são realmente quase literalmente instalados prontos para uso - geralmente a instalação é simples. Mas para instalar o PL / V8, se você não encontrou um pacote com a versão necessária no repositório do seu sistema operacional, isso é quase uma façanha, pois para isso você precisará criar o V8 inteiro ou, em outras palavras, o Chromium. Ao mesmo tempo, toda a infraestrutura de desenvolvimento será baixada do google.com juntamente com a própria V8 - conte com alguns gigabytes de tráfego. Para o Postgres 11 no Ubuntu, o pacote PL / V8 ainda não apareceu, apenas o V8 para PG 10 está disponível no repositório até o momento.Se desejar, monte-o manualmente. Também é importante que a versão que você encontrará no repositório provavelmente seja bastante antiga. No momento da publicação do artigo, a versão mais recente é 2.3.14.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após a instalação do idioma, você também deve "criar" o idioma - registre-o no diretório do sistema. </font><font style="vertical-align: inherit;">Isso deve ser feito pela equipe.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(em vez de plperl, você pode substituir o nome de outro idioma, existem algumas nuances, veja abaixo). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós olhamos para o que aconteceu:</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PL / pgSQL não precisa ser criado especialmente, pois sempre está no banco de dados. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenção! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL não deve ser confundido com SQL. </font><font style="vertical-align: inherit;">Este é um idioma diferente. </font><font style="vertical-align: inherit;">No entanto, o Postgres também pode escrever funções em SQL simples.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padrões</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No mundo do DBMS, eles costumam falar sobre conformidade com os padrões SQL. </font><font style="vertical-align: inherit;">As linguagens processuais também têm padrões, embora não sejam discutidas com tanta frequência. </font><font style="vertical-align: inherit;">O padrão </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / PSM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é altamente compatível com a linguagem processual do DB2. </font><font style="vertical-align: inherit;">Sua implementação está longe de PL / pgSQL, embora conceitualmente eles estejam próximos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o padrão para procedimentos Java e PL / Java é uma boa combinação.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiomas confiáveis ​​e não confiáveis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As linguagens procedurais do Postgres são confiáveis ​​(CONFIÁVEIS) e não confiáveis ​​(NÃO CONFIÁVEIS). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em idiomas CONFIÁVEIS, não há possibilidade de trabalho direto com E / S, incluindo a rede e, de fato, com os recursos do sistema. Portanto, essas funções podem ser criadas por qualquer usuário do banco de dados, estragar alguma coisa e ele não poderá aprender muito. Funções em idiomas não confiáveis ​​só podem ser criadas por um supervisor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o intérprete de idiomas suportar essas restrições, ele poderá ser usado para criar os idiomas TRUSTED e UNTRUSTED. Então, com o Perl, existem diferentes idiomas </font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Letra </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no final, revela o caráter não confiável da língua. </font><font style="vertical-align: inherit;">O Python existe apenas em uma versão não confiável. </font><font style="vertical-align: inherit;">PL / v8 - pelo contrário, apenas em confiável. </font><font style="vertical-align: inherit;">Como resultado, o PL / v8 não pode carregar nenhum módulo ou biblioteca do disco, apenas do banco de dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma função no idioma NÃO CONFIÁVEL pode fazer qualquer coisa: envie um email, execute ping em um site, faça login em um banco de dados externo e execute uma solicitação HTTP. </font><font style="vertical-align: inherit;">Os idiomas confiáveis ​​são limitados ao processamento de dados do banco de dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelo Trusted incluem: </font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por NÃO CONFIÁVEL incluem: </font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe: o PL / Python não existe como CONFIÁVEL (já que você não pode definir restrições no acesso aos recursos) e PLpgSQL e PL / V8 são o contrário: eles não são CONFIÁVEIS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas Perl e Java estão disponíveis nas duas versões.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL vs PL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código PL / pgSQL funciona nativamente com todos os tipos de dados que o Postgres possui. Outros idiomas não possuem muitos tipos de Postgres, e o intérprete de idiomas se encarrega de converter os dados em uma representação interna do idioma, substituindo os tipos obscuros pelo texto. No entanto, ele pode ser ajudado com a ajuda do TRANSFORM, sobre o qual falarei mais perto do final do artigo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As chamadas de função no PL / pgSQL costumam ser mais caras. Funções em outros idiomas podem acessar suas bibliotecas sem consultar o catálogo do sistema. O PL / pgSQL não pode funcionar assim. Algumas consultas no PL / pgSQL funcionam por um longo tempo devido ao fato de muitos tipos serem suportados: para adicionar dois números inteiros, o intérprete precisa perceber que ele está lidando com números inteiros e não com outros tipos exóticos, e depois decide como dobrá-los e somente depois disso os dobrará. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como PL / pgSQL é CONFIÁVEL, você não pode trabalhar com a rede e os discos dela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando se trata de trabalhar com estruturas de dados aninhadas, o PL / pgSQL possui apenas ferramentas Postgres para trabalhar com JSON, que são muito complicadas e improdutivas. Em outras linguagens, trabalhar com estruturas aninhadas é muito mais simples e econômico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PL / * possui seu próprio gerenciamento de memória e você precisa monitorar a memória, ou talvez limitá-la. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você deve monitorar cuidadosamente o tratamento de erros, que também é diferente para todos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas no PL / * existe um contexto global de intérpretes e pode ser usado, por exemplo, para armazenar dados em cache, incluindo planos de consulta. </font><font style="vertical-align: inherit;">Se o idioma não for confiável, a rede e as unidades estarão disponíveis. </font><font style="vertical-align: inherit;">Todos esses idiomas funcionam com o banco de dados, via de regra, através do SPI, mas mais sobre isso posteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos considerar em mais detalhes os recursos dos idiomas PL / *.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O interpretador Perl é um grande pedaço de código na memória, mas, felizmente, ele não é criado quando a conexão é aberta, mas apenas quando o primeiro procedimento / função armazenada PL / Perl é iniciado. </font><font style="vertical-align: inherit;">Quando é inicializado, o código especificado nos parâmetros de configuração do Postgres é executado. </font><font style="vertical-align: inherit;">Normalmente, os módulos são carregados e as pré-computações são feitas. </font><font style="vertical-align: inherit;">
Se você adicionou ao arquivo de configuração enquanto o banco de dados está em execução, faça o Postgres reler a configuração. </font><font style="vertical-align: inherit;">Neste artigo, os exemplos usam um módulo </font><font style="vertical-align: inherit;">para visualizar estruturas de dados. </font><font style="vertical-align: inherit;">
Existem parâmetros para inicialização separada de TRUSTED e UNTRUSTED Perl e, é claro, um parâmetro </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Quem programa em Perl sabe que sem </font><font style="vertical-align: inherit;">ela não é uma linguagem, mas um mal-entendido.</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nele, o intérprete é criado da mesma maneira na primeira vez que é acessado. E aqui é importante decidir imediatamente qual python você deseja: segundo ou terceiro. Como você sabe, o Python existe em duas versões populares (Python 2 e Python 3), mas o problema é que seus so-shki não se dão bem em um único processo: existe um conflito pelo nome. Se você trabalhou com a v2 em uma sessão e depois chamou a v3, o Postgres falhará e, para o processo do servidor (back-end), esse será um erro fatal. Para acessar uma versão diferente, você precisa abrir outra sessão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diferentemente do Perl, não é possível dizer ao python o que fazer durante a inicialização. Outro inconveniente: os liners únicos são inconvenientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em todas as funções do Python, dois dicionários são definidos - estático </font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e global </font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Global </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">troque dados com todas as funções em um back-end - o que é atraente e perigoso ao mesmo tempo. </font><font style="vertical-align: inherit;">Cada função possui um dicionário estático. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No PL / Python, você pode fazer subtransações, as quais discutiremos abaixo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É apenas confiável. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Convenientemente, os dados JSON são convertidos automaticamente em uma estrutura JS. No PL / V8, como no PL / Python, você pode fazer subtransações. Existe uma interface para chamadas de funções simplificadas. Essa é a única linguagem processual em questão na qual as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funções da janela podem ser definidas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eles sugerem que eles </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podem ser definidos no PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas esse idioma está fora do escopo deste artigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E somente no PL / V8 há um tempo limite de execução. É verdade que não está ativado por padrão, e se você criar o PL / V8 manualmente, precisará dizer que ele foi ativado durante a montagem e, em seguida, você pode definir tempos limite para chamadas de função com o parâmetro de configuração.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A inicialização no PL / V8 parece interessante: como é confiável, não pode ler a biblioteca do disco, não pode carregar nada de qualquer lugar. </font><font style="vertical-align: inherit;">Ele pode pegar tudo o que precisa apenas da base. </font><font style="vertical-align: inherit;">Portanto, é definida uma função inicializada armazenada, chamada quando o intérprete de idioma é iniciado. </font><font style="vertical-align: inherit;">O nome da função é especificado em um parâmetro de configuração especial:</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante a inicialização, variáveis ​​e funções globais podem ser criadas atribuindo seus valores aos atributos dessa variável. </font><font style="vertical-align: inherit;">Por exemplo, assim:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparação de PL / Perl vs PL / Python vs PL / V8 na prática</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá Mundo!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos executar um exercício simples com o resultado desta frase nos três idiomas, primeiro no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E deixe que ele faça outra coisa útil, por exemplo, conta sua versão:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você também pode usar as funções Perl habituais </font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais precisamente no PL / Python3u (não confiável) - para maior certeza.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode usar </font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Há muitas coisas que você pode extrair das mensagens do Postgres: elas contêm Dica, Detalhes, número da linha e muitos outros parâmetros. </font><font style="vertical-align: inherit;">No PL / Python, eles podem ser passados, mas não nos outros idiomas em consideração: seus meios só podem ser amaldiçoados com uma linha de texto simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No PL / Python, cada nível de log do postgres tem sua própria função: AVISO, AVISO, DEBUG, LOG, INFO, FATAL. </font><font style="vertical-align: inherit;">Se for ERRO, a transação caiu, se FATAL, todo o back-end caiu. </font><font style="vertical-align: inherit;">Felizmente, o assunto não chegou ao pânico. </font><font style="vertical-align: inherit;">Você pode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ler aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nesse idioma, o Hello world é muito parecido com o pearl. </font><font style="vertical-align: inherit;">Você pode parar de </font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar </font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e isso também será tratamento de erros, embora as ferramentas não sejam tão avançadas quanto no Python. </font><font style="vertical-align: inherit;">Se você escrever</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o efeito será, a propósito, o mesmo.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhar com a base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como trabalhar com um banco de dados a partir de procedimentos armazenados. O Postgres possui uma SPI (Server Programming Interface). Este é um conjunto de funções C que está disponível para todos os autores de extensões. Quase todas as linguagens PL fornecem wrappers para SPI, mas cada linguagem o faz de maneira um pouco diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É improvável que uma função escrita em C, mas usando SPI, proporcione um ganho significativo em comparação com PL / PgSQL e outras linguagens de procedimentos. Mas uma função C que ignora o SPI e trabalha com dados sem intermediários (por exemplo </font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) funcionará uma ordem de magnitude mais rapidamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Java também usa SPI. Mas trabalhar com o banco de dados ainda acontece no estilo do JDBC e no padrão JDBC. Para o criador do código em PL / Java, tudo acontece como se você estivesse trabalhando em um aplicativo cliente, mas o JNI (Java Native Interface) converte chamadas para o banco de dados nas mesmas funções SPI. É conveniente e não há obstáculos fundamentais para traduzir esse princípio em PL / Perl e PL / Python, mas por alguma razão isso não foi feito e, até o momento, não é visível nos planos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, se desejar, você pode ir a bases estrangeiras da maneira usual - através do DBI ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . É possível banco de dados local, mas por quê.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você não entrar no tópico holístico "processo na base x processo no cliente" e prosseguir imediatamente do processamento máximo mais próximo dos dados (pelo menos para não direcionar amostras gigantes pela rede), a solução para usar as funções armazenadas no servidor será naturalmente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : lembre-se de que o SPI possui alguma sobrecarga e as consultas SQL nas funções podem ser mais lentas do que sem funções. O 13º postgres incluiu um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch de Konstantin Knizhnik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que reduz esses custos. Mas, é claro, o processamento dos resultados da consulta em uma função armazenada não requer a transferência do resultado para o cliente e, portanto, pode ser benéfico em termos de desempenho. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segurança</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: um conjunto de funções depuradas e testadas isola a estrutura do banco de dados do usuário, protege contra injeções de SQL e outras travessuras. </font><font style="vertical-align: inherit;">Caso contrário, continuará sendo uma dor de cabeça para todos os desenvolvedores de aplicativos. </font><font style="vertical-align: inherit;">Reutilização de </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se um grande número de aplicativos complexos funcionar com o banco de dados, é conveniente armazenar funções úteis no servidor, em vez de escrevê-las novamente em cada aplicativo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como e de que forma obtemos dados do banco de dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tudo é simples e claro. </font><font style="vertical-align: inherit;">A chamada </font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna o número de linhas processadas, o status e a matriz de linhas selecionadas pela consulta SQL:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python, a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consulta e o resultado se parecem com isso, mas aqui a função não retorna uma estrutura de dados, mas um objeto especial com o qual você pode trabalhar de maneiras diferentes. </font><font style="vertical-align: inherit;">Geralmente, ele finge ser uma matriz e, consequentemente, você pode extrair cadeias de caracteres.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora pegamos a 1ª linha, saímos de lá X e obtemos o valor - o número.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ver a estrutura, usamos a função de biblioteca JSON.stringify, que não precisa ser carregada especialmente, ela já está pronta para uso como parte do PL / v8 por padrão. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blindagem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar injeções SQL maliciosas, alguns caracteres nas consultas devem ser escapados. Para fazer isso, em primeiro lugar, existem funções SPI e funções correspondentes (escritas em C) em idiomas que funcionam como wrappers SPI. Por exemplo, em PL / Perl: </font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- recebe apóstrofos e dobra 'e \. Projetado para a triagem de dados de texto. </font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- mesmo, mas </font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertido para NULL. </font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- cita o nome da tabela ou campo, se necessário. Útil no caso em que você está construindo uma consulta SQL e substituindo os nomes dos objetos de banco de dados nela. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se: o nome da tabela não deve ser escapado como uma linha de texto. </font><font style="vertical-align: inherit;">É por isso que existe uma função </font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas no PL / Perl existem outras funções para escapar dos dados de tipos individuais de postagens: </font><font style="vertical-align: inherit;">
Uma função </font><font style="vertical-align: inherit;">deve aceitar qualquer tipo e transformar caracteres duvidosos atípicos em algo obviamente óbvio. </font><font style="vertical-align: inherit;">Funciona com um grande número de tipos, mas, no entanto, não com todos. </font><font style="vertical-align: inherit;">Ela, por exemplo, não entenderá os </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">tipos de intervalo</font></a><font style="vertical-align: inherit;"> e os perceberá simplesmente como cadeias de texto.</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem </font><font style="vertical-align: inherit;">três funções semelhantes </font><font style="vertical-align: inherit;">no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e elas funcionam da mesma maneira:</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As funções do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8 são</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iguais </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro! </font><font style="vertical-align: inherit;">Tudo é o mesmo até características sintáticas.</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atuação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual idioma é o mais rápido? Geralmente eles respondem: C. Mas a resposta correta é C </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL. Por que SQL? O fato é que uma função nesse idioma nem sempre é executada explicitamente. Ele pode ser incorporado à solicitação (o agendador incorporará a função no corpo da solicitação principal), otimizará bem a solicitação e o resultado será mais rápido. Mas sob que condições o código pode ser incorporado em uma solicitação? Existem algumas condições simples que você pode ler sobre, digamos, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por exemplo, uma função não deve ser executada com os direitos do proprietário (para ser DEFINER DE SEGURANÇA). A maioria das funções simples se encaixa nessas condições. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, mediremos "no joelho", não seriamente. Precisamos de uma comparação aproximada. Primeiro ligue o tempo:</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (os tempos de execução dos comandos abaixo são os valores médios arredondados que o autor recebeu em um PC de seis anos sem carga. Eles podem ser comparados entre si, mas não afirmam ser científicos):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funciona muito rápido. </font><font style="vertical-align: inherit;">Em outros idiomas, é desperdiçado tempo chamando funções do idioma. </font><font style="vertical-align: inherit;">Obviamente, na primeira vez em que a solicitação for executada mais lentamente, devido à inicialização do intérprete. </font><font style="vertical-align: inherit;">Então estabiliza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Era o Python 2. Agora, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lembre-se: Python2 e Python3 não vivem em paz na mesma sessão, é possível um conflito de nomes):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, finalmente, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas é de alguma forma muito rápido. </font><font style="vertical-align: inherit;">Vamos tentar executar a consulta 1000 vezes ou 1 milhão de vezes, de repente a diferença será mais perceptível: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que, com o PL / V8, o experimento foi realizado com mil, e não um milhão de iterações. Com recursos moderados, o PL / V8 em um ciclo de 1 milhão de operações consome toda a memória e paralisa completamente o carro. Já em mil iterações, o processo do postgres seleciona 3,5 GB de memória e 100% de gravação no disco. De fato, o postgres lança o ambiente V8 e, é claro, consome memória. Depois de executar a solicitação, esse monstro turbo não vai devolver memória. Para liberar memória, você precisa encerrar a sessão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que o PL / pgSQL já é 2 vezes mais rápido que o PL / Perl e o PL / Python. O PL / V8 ainda está um pouco atrás deles, mas no final do artigo ele está parcialmente reabilitado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, Perl com Python nessas experiências mostra aproximadamente os mesmos resultados. </font><font style="vertical-align: inherit;">O Perl costumava ser um pouco inferior ao Python; nas versões modernas, é um pouco mais rápido. </font><font style="vertical-align: inherit;">O terceiro python é um pouco mais lento que o segundo. </font><font style="vertical-align: inherit;">Toda a diferença está dentro de 15%.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho com PREPARE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pessoas que sabem vão entender: algo está errado. </font><font style="vertical-align: inherit;">O PL / pgSQL pode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">armazenar em cache automaticamente os planos de consulta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, em PL / *, cada vez que a consulta foi agendada novamente. </font><font style="vertical-align: inherit;">De uma maneira boa, você precisa preparar solicitações, criar um plano de solicitações e, de acordo com esse plano, elas devem ser executadas quantas vezes forem necessárias. </font><font style="vertical-align: inherit;">No PL / *, você pode trabalhar explicitamente com os planos de consulta, que tentaremos começar com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nossas duas linguagens, quase alcançamos PL / pgSQL, e a terceira também queria, mas não alcançou a linha de chegada devido aos crescentes requisitos de memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas se você não leva em conta a memória, fica claro que todos os idiomas quase se enfrentam - e não por acaso. </font><font style="vertical-align: inherit;">O gargalo deles agora é comum - trabalhando com o banco de dados por meio do SPI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho computacional</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que o desempenho do idioma descansou no trabalho com o banco de dados. </font><font style="vertical-align: inherit;">Para comparar idiomas, vamos tentar calcular algo sem recorrer ao banco de dados, por exemplo, a soma dos quadrados. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que PL / Perl e PL / Python ultrapassaram e superaram PL / pgSQL, eles são 4 vezes mais rápidos. </font><font style="vertical-align: inherit;">E os oito estão rasgando todo mundo! </font><font style="vertical-align: inherit;">Mas é realmente por nada? </font><font style="vertical-align: inherit;">Ou vamos conseguir isso pela cabeça? </font><font style="vertical-align: inherit;">Sim nós vamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O número no JavaScript é flutuante e o resultado é rápido, mas não preciso: 333333833333127550 em vez de 33333383333353500000. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a fórmula pela qual o resultado exato é </font><font style="vertical-align: inherit;">calculado </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">∑ = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como exercício, você pode provar isso usando indução matemática. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na ordem do riso</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em Javascript, </font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele ainda faz um float, não um Int. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apareceu na V8 em 2018 </font><font style="vertical-align: inherit;">e agora pode ser contado com certeza, mas com um prejuízo para a velocidade, pois não é um número inteiro de 64 bits, mas um número inteiro de profundidade de bits arbitrária. </font><font style="vertical-align: inherit;">No entanto, no PL / V8 essa inovação ainda não foi atingida. </font><font style="vertical-align: inherit;">Em outras linguagens procedurais, números de bits arbitrários (análogos do SQL </font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) são suportados por bibliotecas especiais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em Perl, há um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo Math :: em ponto flutuante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a aritmética com precisão arbitrária, e em Python o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em ponto flutuante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pacote </font><font style="vertical-align: inherit;">é um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> invólucro </font><font style="vertical-align: inherit;">em torno do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU MPFR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioteca </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funções de desempenho para classificação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um exemplo prático, que mostra a diferença no desempenho da classificação por função, se essa função estiver escrita em idiomas diferentes. </font><font style="vertical-align: inherit;">Tarefa: classificar os campos de texto que contêm os números dos números do diário, que podem ser os seguintes:</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa. </font><font style="vertical-align: inherit;">na verdade, é uma string, mas começa com um número e você precisa classificar por esses números. </font><font style="vertical-align: inherit;">Portanto, para classificar corretamente como seqüências de caracteres, suplementamos a parte numérica com zeros à esquerda para obter:</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, eu sei que essa não é a única solução para o problema (e nem exatamente). </font><font style="vertical-align: inherit;">Mas, por exemplo, serve. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para solicitar um tipo, </font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrevemos funções em PL / Perl, SQL, PL / Python e PL / V8 que convertem os números de diário para este formulário:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha biblioteca de 15,5 mil artigos de periódicos, uma consulta usando uma função no PL / Perl leva cerca de 64ms contra 120ms no PL / Python e 200ms no PL / PgSQL. </font><font style="vertical-align: inherit;">Mas o mais rápido - PL / v8: 54ms. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao experimentar a classificação, forneça a quantidade necessária de memória de trabalho para que a classificação entre na memória (EXPLAIN será exibido </font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">A quantidade de memória é definida pelo parâmetro </font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memória</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl não gosta de estruturas em loop, ele não sabe como limpá-las. </font><font style="vertical-align: inherit;">Se você </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiver um ponteiro para </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ponteiro para </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o contador de referência nunca será redefinido e a memória não será liberada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os idiomas de coleta de lixo têm outros problemas. </font><font style="vertical-align: inherit;">Não se sabe, por exemplo, quando a memória será liberada ou se será liberada. </font><font style="vertical-align: inherit;">Ou - se você não cuidar disso de propósito - os colecionadores irão coletar lixo no momento mais inoportuno. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas também existem recursos de gerenciamento de memória diretamente relacionados ao Postgres. </font><font style="vertical-align: inherit;">Existem estruturas que o SPI aloca, e o Perl nem sempre percebe que eles precisam ser liberados. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
NÃO é assim:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E por aí vai:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após a execução, o manipulador </font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permanecerá vivo, apesar de não existir um único vínculo vivo com ele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo bem, você só precisa se lembrar da necessidade de liberar explicitamente recursos com </font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca flui</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o plano é liberado automaticamente:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mesma história que Perl. </font><font style="vertical-align: inherit;">Não flui assim:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‘
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E por aí vai:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Novamente: não esqueça de liberar recursos. </font><font style="vertical-align: inherit;">Aqui está. </font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não flui:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parâmetros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É hora de entender como os argumentos são passados ​​para as funções. </font><font style="vertical-align: inherit;">Nos exemplos, passaremos 4 parâmetros com tipos para a função:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma matriz;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytea e</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font><font style="vertical-align: inherit;">
eles entram no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Será JSON ou JSONB - neste caso, não faz diferença: eles ainda ficam na forma de uma string. Essa é uma taxa pela versatilidade: o Postgres possui muitos tipos, de diferentes graus de "embutido". Exigir do desenvolvedor que, com o novo tipo, ele imediatamente forneça funções de conversão para todos os PL / *, seria demais. Por padrão, muitos tipos são passados ​​como seqüências de caracteres. Mas isso nem sempre é conveniente, você deve analisar esses termos. Obviamente, gostaria que os dados do Postgres se transformassem imediatamente nas estruturas Perl apropriadas. Por padrão, isso não acontece, mas a partir da 9.6, o mecanismo TRANSFORM apareceu - a capacidade de definir funções de conversão de tipos: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para criar TRANSFORM, você precisa escrever duas funções em C: uma converterá dados de um determinado tipo para um lado e o outro de volta. </font><font style="vertical-align: inherit;">Observe que o TRANSFORM trabalha em quatro locais:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao passar parâmetros para uma função;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao retornar um valor de função;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao passar parâmetros para uma chamada SPI dentro de uma função;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após o recebimento do resultado da chamada SPI dentro da função.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRANSFORMAR JSONB para Perl e Python, desenvolvido por Anton Bykov, apareceu na 11ª versão do Postgres. </font><font style="vertical-align: inherit;">Agora você não precisa analisar o JSONB, ele entra no Perl imediatamente como a estrutura correspondente. </font><font style="vertical-align: inherit;">Você deve criar a extensão jsonb_plperl e, em seguida, você pode usar TRANSFORM:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode chamar esta função para verificar se o JSONB se transformou em um hash de pérola:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma questão completamente diferente! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O autor deste artigo também ajudou no desenvolvimento de TRANSFORMs. Descobriu-se que um tipo de dados tão simples, como </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passado ao PL / Perl de forma inconveniente, como seqüências de texto </font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas, no entendimento de Perl, a string 'f' é verdadeira. Para eliminar o inconveniente, foi inventado um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch que definia a conversão para o tipo booleano</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este patch atingiu o PostgreSQL 13 e estará disponível em breve. Devido à sua simplicidade, o bool_plperl pode servir como um modelo inicial mínimo para gravar qualquer outra conversão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que alguém desenvolva TRANSFORM para outros tipos de dados (bytea, matrizes, datas, numéricos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como os parâmetros são passados ​​no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma matriz é convertida em uma matriz - isso é bom (uma vez que as matrizes multidimensionais da versão PG10 também são corretamente transferidas para python). </font><font style="vertical-align: inherit;">No Perl, uma matriz foi convertida em um objeto de uma classe especial. </font><font style="vertical-align: inherit;">Bem, </font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformado. </font><font style="vertical-align: inherit;">Sem TRANSFORM, o jsonb será passado como uma string. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver de que forma os parâmetros entram no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONB convertido em um objeto JavaScript sem TRANSFORMAR! </font><font style="vertical-align: inherit;">Os tipos de Postgres temporários também são convertidos para o tipo JS de data. </font><font style="vertical-align: inherit;">A mesma coisa com booleano. </font><font style="vertical-align: inherit;">Todas as transformações já estão incorporadas no PL / V8.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhar com infinito</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A constante INFINITY não é usada com muita frequência, mas o trabalho mal feito com ela é perigoso. </font><font style="vertical-align: inherit;">No PostgreSQL, Infinity e -Infinity existem como valores especiais para alguns tipos temporários e de ponto flutuante. </font><font style="vertical-align: inherit;">Mas a transferência do Infinity para linguagens procedurais e vice-versa deve ser discutida em detalhes, pois trabalhar com elas pode depender não apenas da linguagem, mas também das bibliotecas, do sistema operacional e até do hardware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Python possui um módulo Numpy que define o infinito numérico:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl também tem infinito, ele usa uma string </font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que pode ser reduzida para </font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por exemplo, você poderia dizer:</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ou</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No PL / Perl, PL / Python, PL / v8, o infinito numérico do Postgres é passado corretamente, mas uma data infinita não está correta. </font><font style="vertical-align: inherit;">Em vez disso, no PL / Perl e no PL / Python, não há tipo de dados interno para o tempo, uma string chega lá. </font><font style="vertical-align: inherit;">No PL / V8, existe um tipo interno Date, e a data usual de um postgres se transforma nele. </font><font style="vertical-align: inherit;">Mas o V8 não sabe a data sem fim e, quando transferido, se transforma </font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passando parâmetros para solicitações preparadas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De volta a </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, considere como os parâmetros são passados ​​para lá. </font><font style="vertical-align: inherit;">Idiomas diferentes têm muito em comum, pois todos são baseados no SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao preparar uma consulta no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , você precisa determinar o tipo de parâmetros que são passados ​​e, ao executar a consulta, especifica apenas os valores desses parâmetros (os parâmetros são passados ​​para o PL / pgSQL da mesma maneira).</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essência é a mesma, mas a sintaxe é um pouco diferente:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8, as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferenças são mínimas:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tudo é diferente. </font><font style="vertical-align: inherit;">Lá, o SPI claramente não é usado, mas uma conexão pseudo-JDBC ao banco de dados é formada. </font><font style="vertical-align: inherit;">Para um programador de PL / Java, tudo acontece como se ele estivesse criando um aplicativo cliente. </font><font style="vertical-align: inherit;">Isso é conveniente, e também se pode abordar o design do PL / Perl e PL / Python, mas por algum motivo isso não foi feito (no entanto, ninguém proíbe a criação de mais algumas implementações do PL / Perl e PL / Python).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhar com cursor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as funções SPI que usamos quando acessamos o banco de dados - </font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e outras - têm um parâmetro que limita o número de linhas retornadas. </font><font style="vertical-align: inherit;">Se você precisar de muitas linhas retornadas, não poderá usar um cursor para puxá-las um pouco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os cursores funcionam em todos esses idiomas. </font><font style="vertical-align: inherit;">Em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl,</font></font></b> <br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retorna um cursor do qual você pode extrair cadeias uma de cada vez. </font><font style="vertical-align: inherit;">Não é necessário fechar o cursor, ele se fechará. </font><font style="vertical-align: inherit;">Mas se você quiser redescobri-lo novamente, poderá explicitamente fechá-lo com um comando </font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tudo é muito parecido, mas o cursor é apresentado como um objeto pelo qual você pode percorrer:</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / v8,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tudo também é muito parecido, mas não se esqueça de liberar o plano de consulta preparado:</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8: Acesso rápido aos recursos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No PL / V8, você pode chamar uma função não de um SELECT regular, mas encontrá-la pelo nome e iniciá-la imediatamente com </font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas lembre-se de que, em JS, uma função não pode ser polimórfica, como no PostgreSQL, na qual funções com o mesmo nome, mas com parâmetros diferentes, podem coexistir. </font><font style="vertical-align: inherit;">No PL / v8, é claro, podemos criar funções polimórficas, mas </font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haverá um erro </font><font style="vertical-align: inherit;">ao tentar usá- </font><font style="vertical-align: inherit;">lo.</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se uma função por nome não for ambígua, poderá ser chamada sem SPI e conversões de tipo, ou seja, </font><font style="vertical-align: inherit;">muito mais rapido. </font><font style="vertical-align: inherit;">Por exemplo, assim:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transações</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Postgres 11 é muito divertido: </font><font style="vertical-align: inherit;">procedimentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reais</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apareceram </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O Postgres costumava ter apenas recursos. </font><font style="vertical-align: inherit;">A alegria não se deve apenas à compatibilidade e conformidade com o padrão SQL, mas por que: nos procedimentos, você pode confirmar e reverter transações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PL / Perl e o PL / Python já possuem funções SPI para gerenciamento de transações, enquanto o PL / V8 ainda não. </font><font style="vertical-align: inherit;">No PL / Perl, essas funções são chamadas </font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e um exemplo de uso está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No PL / Python, este é </font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtransação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As subtransações são convenientes para o tratamento correto de erros na lógica complexa de vários níveis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dentro de uma transação, cada bloco com a palavra-chave EXCEPTION é uma subtransação. Você pode ler sobre alguns problemas de desempenho e confiabilidade que podem surgir neste caso, por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não </font><font style="vertical-align: inherit;">há subtransações explícitas </font><font style="vertical-align: inherit;">no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas elas podem ser simuladas através de savaepoints. Aparentemente, se você desejar, é fácil escrever um módulo pearl que implemente subtransações de forma explícita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> subtransações apareceram há muito tempo: das 9.5 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explícitas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , antes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as implícitas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Você pode definir uma transação, envolvê-la</font></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e executar. </font><font style="vertical-align: inherit;">Se a subtransação cair, cairemos no bloco </font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se não cairmos, entraremos no bloco </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e seguiremos em frente.</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um design semelhante existe no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , apenas na sintaxe JS.</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tente, mas não abuse :) O conhecimento de PL / * pode trazer alguns benefícios. </font><font style="vertical-align: inherit;">Como qualquer ferramenta, eles gostam de ser usados ​​para o propósito a que se destinam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PL / v8 é muito promissor, mas às vezes se comporta inesperadamente e tem vários problemas. </font><font style="vertical-align: inherit;">Portanto, é melhor tirar os idiomas da caixa se eles forem adequados para sua tarefa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero agradecer a Igor Levshin (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Igor_Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), que me ajudou muito na preparação do material para o artigo e lançou algumas idéias úteis, além de Evgeny Sergeev e Alexey Fadeev pelas correções que propuseram.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502236/index.html">Modelagem de aeronaves infantis - em um nível decente</a></li>
<li><a href="../pt502246/index.html">O que as respostas ousadas de Alice têm em comum com os drones?</a></li>
<li><a href="../pt502248/index.html">Um novo GOST para recursos digitais entrou em vigor: todas as plataformas devem estar acessíveis para pessoas com deficiência</a></li>
<li><a href="../pt502250/index.html">Aviação Civil Hoje: Aspectos Importantes e Desafios do Treinamento</a></li>
<li><a href="../pt502252/index.html">Controle remoto e drones</a></li>
<li><a href="../pt502256/index.html">Como visualizar um gráfico de integração de primavera usando o Neo4j?</a></li>
<li><a href="../pt502260/index.html">O ESP-NOW é um protocolo de comunicação alternativo para o ESP8266 e o ​​ESP32. Conceitos Básicos</a></li>
<li><a href="../pt502262/index.html">Por que AIOps e monitoramento abrangente para o banco ou sobre o que são construídas as relações com os clientes</a></li>
<li><a href="../pt502264/index.html">Infraestrutura de chave pública. Emissão de certificados em condições de auto-isolamento</a></li>
<li><a href="../pt502266/index.html">Aurora na plataforma Intel. Amanhecer da Era Exaflops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>