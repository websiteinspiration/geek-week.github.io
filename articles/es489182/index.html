<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥪 📯 👈🏻 varchar (max) -varchar (max) y en producción 👩🏾‍⚕️ 🚬 👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente participé en una discusión sobre el impacto en el rendimiento de especificar longitudes en columnas nvarchar. Los argumentos fueron razo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>varchar (max) -varchar (max) y en producción</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489182/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recientemente participé en una discusión sobre el impacto en el rendimiento de especificar longitudes en columnas nvarchar. Los argumentos fueron razonables en ambos lados, y como tenía tiempo libre, decidí probar un poco. El resultado fue esta publicación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spoiler: no es tan simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas las pruebas se realizaron en SQL Server 2014 Developer Edition, se obtuvieron aproximadamente los mismos resultados en SQL Server 2016 (con ligeras diferencias). Lo siguiente debería ser relevante para SQL Server 2005-2016 (y las pruebas se requieren en 2017/2019, ya que han aparecido las adaptaciones de memoria adaptativa, lo que puede corregir algo la situación). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitamos un procedimiento almacenado de Erik Darling </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sp_pressure_detector</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que le permite obtener mucha información sobre el estado actual del sistema y</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Query Stress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una utilidad de código abierto muy buena Adam Machanic / Erik Ejlskov Jensen para la prueba de carga de MS SQL Server.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De qué estamos hablando</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La pregunta que estoy tratando de responder es si la elección de la longitud del campo (n) varchar afecta el rendimiento (en adelante, simplemente varchar está en todas partes, aunque todo también es relevante para nvarchar), o puede usar varchar (max) y no steam, porque si la longitud de la cadena es &lt;8000 (4000 para nvarchar) caracteres, luego varchar (max) y varchar (N) se almacenan EN FILA.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puesto de cocina</font></font></h3><br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-comment">##v10  (i int, d datetime, v varchar(10));</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-comment">##v100 (i int, d datetime, v varchar(100));</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-comment">##vmax (i int, d datetime, v varchar(max));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creamos 3 tablas de tres campos, la diferencia está solo en la longitud de varchar: 10/100 / max. </font><font style="vertical-align: inherit;">Y llénalos con los mismos datos:</font></font><br>
<br>
<pre><code class="sql hljs">;<span class="hljs-keyword">with</span> x <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> x <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>)<font></font>
, xx <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> x <span class="hljs-keyword">from</span> x x1, x x2)<font></font>
, xxx <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> x <span class="hljs-keyword">from</span> xx x1, xx x2, xx x3)<font></font>
, xxxx <span class="hljs-keyword">as</span> (
	<span class="hljs-keyword">select</span> row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (<span class="hljs-keyword">select</span> <span class="hljs-literal">null</span>)) i<font></font>
		, <span class="hljs-keyword">dateadd</span>(<span class="hljs-keyword">second</span>, row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (<span class="hljs-keyword">select</span> <span class="hljs-literal">null</span>)), <span class="hljs-string">'20200101'</span>) d<font></font>
		, <span class="hljs-keyword">cast</span> (row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (<span class="hljs-keyword">select</span> <span class="hljs-literal">null</span>)) <span class="hljs-keyword">as</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>))  v 		
	<span class="hljs-keyword">from</span> xxx x1, xxx x2, xxx x3<font></font>
) <span class="hljs-comment">--262144 </span>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-comment">##v10			--varchar(10)</span>
<span class="hljs-keyword">select</span> i, d, v <span class="hljs-keyword">from</span> xxxx;	<font></font>
<font></font>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-comment">##v100			--varchar(100)</span>
<span class="hljs-keyword">select</span> i, d, v <span class="hljs-keyword">from</span> <span class="hljs-comment">##v10;</span><font></font>
<font></font>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-comment">##vmax			--varchar(max)</span>
<span class="hljs-keyword">select</span> i, d, v <span class="hljs-keyword">from</span> <span class="hljs-comment">##v10;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, cada tabla contendrá 262144 filas. </font><font style="vertical-align: inherit;">La columna I (entero) contiene números no repetidos del 1 al 262145; </font><font style="vertical-align: inherit;">d (datetime) fechas únicas y v (varchar) - cast (I como varchar (10)). </font><font style="vertical-align: inherit;">Para hacerlo un poco más parecido a la vida real, cree un índice de clúster único en i:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered <span class="hljs-keyword">index</span> <span class="hljs-comment">#cidx10 on ##v10(i);</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered <span class="hljs-keyword">index</span> <span class="hljs-comment">#cidx100 on ##v100(i);</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered <span class="hljs-keyword">index</span> <span class="hljs-comment">#cidxmax on ##vmax(i);</span></code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, veamos los planes para la ejecución de diferentes solicitudes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, verifique que la selección por campo varchar no dependa de su longitud (si &lt;8000 caracteres están almacenados allí). </font><font style="vertical-align: inherit;">Incluimos un plan de ejecución válido y miramos:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##v10 where v = '123';</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##v100 where v = '123';</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##vmax where v = '123';</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/ae/ge/jmaegeqd37k-dqa1xelhluv0p7y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curiosamente, la diferencia, aunque pequeña, está ahí. </font><font style="vertical-align: inherit;">El plan de consulta con varchar (max) primero selecciona todas las filas y luego las filtra, y varchar (10) y varchar (100) verifican las coincidencias al escanear el índice agrupado. </font><font style="vertical-align: inherit;">Debido a esto, el escaneo tarda casi 3 veces más: 0.068 segundos versus 0.022 para varchar (10). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos qué sucede si simplemente mostramos la columna varchar y seleccionamos los datos por la clave de índice del clúster:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##v10  where i between 200000 and 201000;</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##v100 where i between 200000 and 201000;</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##vmax where i between 200000 and 201000; </span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/-s/kb/cf-skbsef6akggupmzetfl2p8go.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí todo está claro: no hay diferencia para tales solicitudes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora para la parte interesante. </font><font style="vertical-align: inherit;">En la solicitud anterior, obtuvimos solo 1001 filas, y ahora queremos ordenarlas por columna no indexada. </font><font style="vertical-align: inherit;">Intentamos:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##v10  where i between 200000 and 201000 order by d;</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##v100 where i between 200000 and 201000 order by d;</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##vmax where i between 200000 and 201000 order by d;</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/do/49/yjdo497l7navh17mbg02_gqx8us.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Y qué es tan amarillo?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/me/42/eyme42eioy1wftu3xupiblsy4i8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Divertido, es decir </font><font style="vertical-align: inherit;">la solicitud solicitó y recibió 6.5 megabytes de RAM para la clasificación, y solo usó 96 kilobytes. </font><font style="vertical-align: inherit;">Y cuánto peor será si hay más líneas. </font><font style="vertical-align: inherit;">Bueno, que no sea 1000, sino 100000:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/m9/yj/4em9yjzwjh3nnoqfgfyx54rsing.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero aquí es más serio. </font><font style="vertical-align: inherit;">Además, la primera solicitud que funciona con el varchar más pequeño (10) tampoco está satisfecha con algo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/q8/ni/cq/q8nicqpp2upyxdn1tqkkrj9pmiw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la izquierda hay una advertencia de la última solicitud: se solicitaron 500 megabytes y solo se usaron 9,5 megabytes. </font><font style="vertical-align: inherit;">Y a la derecha hay una advertencia de clasificación: se solicitaron 8840 kilobytes, pero no había suficientes y se escribieron y leyeron otras 360 páginas (8 kb cada una) de tempdb. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aquí surge la pregunta: ¿WTF?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La respuesta es cómo funciona el Optimizador de consultas de SQL Server. Para ordenar algo, primero debe poner algo en la memoria. ¿Cómo entender cuánta memoria se necesita? En general, sabemos cuánto tipo de datos ocupa espacio. Pero, ¿qué pasa con las cadenas de longitud variable? Pero es más interesante con ellos. Al asignar memoria para los tipos de unión / hash, SQL Server considera que están medio llenos en promedio. Y asigna memoria para ellos como (tamaño / 2) * el número esperado de líneas. Pero varchar (max) puede almacenar hasta 2 GB: ¿cuánto asignar? SQL Server cree que habrá la mitad de varchar (8000), es decir aproximadamente 4 kb por línea.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo interesante es que esta asignación de memoria genera problemas no solo con varchar (max), si el tamaño de sus varchars se elige con amor para que la mayoría de ellos estén medio llenos y más grandes, esto también genera problemas. </font><font style="vertical-align: inherit;">Problemas de un plan diferente, pero no menos grave. </font><font style="vertical-align: inherit;">En la figura anterior hay una descripción: SQL Server no pudo asignar correctamente la memoria para ordenar un pequeño varchar y usó tempdb para almacenar resultados intermedios. </font><font style="vertical-align: inherit;">Si tempdb se encuentra en discos lentos, o es utilizado activamente por otras solicitudes, esto puede convertirse en un cuello de botella.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrés de consulta SQL</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos qué sucede cuando se ejecutan consultas masivas. </font><font style="vertical-align: inherit;">Ejecute el Estrés de consultas SQL, conéctelo a nuestro servidor y diga ejecutar todas estas consultas 10 veces en 50 hilos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados de la primera consulta:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/9r/q8/qv9rq8c7z6tbyqb9k7jqck2yhae.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_9/vw/he/_9vwhedfjdaa22mkptjacumozfa.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5c/um/uv/5cumuvx4-sfl5nojbis65jcdapo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es interesante, pero sin índices, cuando se busca, varchar (max) se muestra peor que nadie, y es mucho peor en términos de tiempo de procesador para la iteración y el tiempo de ejecución general. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sp_pressure_detector no muestra nada interesante aquí, así que no cito su salida. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultados de la segunda consulta:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/om/nz/yo/omnzyo0dirov8grjqv_xknozi8a.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/um/l8/ck/uml8ckphegosxfz61vucy5cdhmc.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jp/gc/qw/jpgcqwftgnarvin2dubbszhlb0e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí se espera todo, igual de bueno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora para la parte interesante. </font><font style="vertical-align: inherit;">Una consulta con la clasificación de las mil filas resultantes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/s3/7g/nks37ghsmhyoeu2ufnwjtucspng.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/k8/md/v5k8mduwaak5levom_53ew9tb-c.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/dt/cm/urdtcmhikdmqqn17is5z7lgwnom.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo resultó ser exactamente igual que con la solicitud anterior: no hay muchas líneas, la clasificación no causa problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, la última consulta que clasifica de manera irrazonable muchas filas (agregué las 1000 principales para no extraer toda la lista ordenada):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/so/qf/4x/soqf4xayshv3s96prh41gbho98o.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/mo/xz/2dmoxznaetv7dae_o8yfwqewgx0.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/s5/0n/aps50nstvvlezyr4qq16jjw8xmu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aquí está la salida de sp_pressure_detector:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/ta/-d/5v/ta-d5vvomd180-etwq7kvvkplyy.png"></div></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué nos dice él? </font><font style="vertical-align: inherit;">Todas las sesiones solicitan 489 MB cada una (para ordenar), pero solo 22 de ellas tenían suficiente memoria para SQL Server, ¡incluso teniendo en cuenta que todas estas 22 sesiones usan solo 9 MB cada una! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se dispone de un total de 11 GB de memoria, se asignaron 229 sesiones a 489.625 cada una y SQL Server solo tenía 258 megabytes disponibles, y también quieren obtener nuevas sesiones para 489. ¿Qué debo hacer? </font><font style="vertical-align: inherit;">Espere hasta que la memoria se libere; esperan, sin siquiera comenzar a ejecutarse. </font><font style="vertical-align: inherit;">¿Qué harán los usuarios si tales solicitudes se realizan en sus sesiones? </font><font style="vertical-align: inherit;">Demasiado para esperar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, preste atención a la figura con varchar (10), las solicitudes con varchar (10) tomaron más tiempo que las solicitudes con varchar (100), y esto a pesar del hecho de que tengo tempdb en un disco muy rápido. </font><font style="vertical-align: inherit;">Cuanto peor sea la unidad en tempdb, más lenta se ejecutará la consulta.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota separada para SQL Server 2012/2014</font></font></b><div class="spoiler_text"> SQL Server 2012/2014       sort spills.      char/nchar –     spill’  tempdb. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MS    </a>,        ,       .<br>
<br>
 :<br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-comment">##c6  (i int, d datetime, v char(6));</span>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-comment">##c6 (i, d, v)</span>
<span class="hljs-keyword">select</span> i, d, v
<span class="hljs-keyword">from</span> <span class="hljs-comment">##v10</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##c6 where i between 100000 and 200000 order by d;</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ui/f4/b8/uif4b8p9mykxr4vt6nzawwr67_e.png"></div><br>
    (      ):<br>
<br>
<pre><code class="sql hljs">DBCC TRACEON (7470, -1);</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/re/lk/wyrelkcbyfaybdahpngtbvakkla.png"></div><br>
    , spill’  .<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga cuidado al ordenar sus consultas donde tenga (n) columnas varchar. Si aún se necesita la clasificación, es altamente deseable que la columna de clasificación tenga un índice. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que para obtener una ordenación no es necesario utilizar explícitamente el orden por: su apariencia también es posible con combinaciones de fusión, por ejemplo. El mismo problema con la asignación de memoria también es posible con las combinaciones hash, por ejemplo, con varchar (max):</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> top <span class="hljs-number">100</span> * 
<span class="hljs-keyword">from</span> <span class="hljs-comment">##vmax v1</span>
<span class="hljs-keyword">inner</span> <span class="hljs-keyword">hash</span> <span class="hljs-keyword">join</span> <span class="hljs-comment">##v10 v2 on v1.i = v2.i</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ui/zw/65/uizw65mjcy5wysloq-ujohovj1o.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡2.5 GB de memoria asignada, 25 megabytes usados! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La principal conclusión para mí</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el tamaño de la columna (n) varchar - ¡IMPORTANTE! Si el tamaño es demasiado pequeño, son posibles los derrames en tempdb; si es demasiado grande, las solicitudes de memoria son demasiado grandes. Si hay algún tipo, sería conveniente declarar la longitud de varchar como la longitud promedio de registro * 2, y en el caso de SQL Server 2012/2014, incluso más. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión inesperada para mí</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : varchar (max), que contiene menos de 8000 caracteres, en realidad funciona más lentamente, con filtros. Todavía no sé cómo explicarlo. Cavaré más. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retiro de bonificación para mí</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ya casi haciendo clic en "publicar", pensé que incluso con varchar (max) puede experimentar el problema de "small varchar'a". </font><font style="vertical-align: inherit;">De hecho, cuando se almacena en varchar (max) más de 4000 caracteres (2000 para nvarchar), la clasificación puede ser un problema.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-comment">##vmax(i, d, v)</span>
<span class="hljs-keyword">select</span> i, d, <span class="hljs-keyword">replicate</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">4000</span>) v
<span class="hljs-keyword">from</span> <span class="hljs-comment">##v10;</span><font></font>
<font></font>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##vmax where i between 200000 and 201000 order by d;</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1r/al/gj/1ralgj_dructufbdmv9okrtarqu.png"></div><br>
<pre><code class="sql hljs"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> <span class="hljs-comment">##vmax;</span><font></font>
<font></font>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-comment">##vmax(i, d, v)</span>
<span class="hljs-keyword">select</span> i, d, <span class="hljs-keyword">replicate</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">4100</span>) v
<span class="hljs-keyword">from</span> <span class="hljs-comment">##v10;</span><font></font>
<font></font>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-comment">##vmax where i between 200000 and 201000 order by d;</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wa/hp/s7/wahps7atcyg7xmdkuo0rg6-ojhu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué al principio escribí que no todo es tan simple? </font><font style="vertical-align: inherit;">Porque, por ejemplo, en la computadora portátil de mi casa con un disco medio muerto, los derrames en tempdb al ordenar varchar "pequeño" llevaron al hecho de que tales solicitudes se ejecutaron ORDEN más lento que solicitudes similares con varchar (max). </font><font style="vertical-align: inherit;">Si tiene un buen hardware, puede que no sea un problema, pero no debe olvidarse de ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que sería aún más interesante es ver si hay algún problema debido a los tamaños demasiado grandes / pequeños de los varchars en otros DBMS. </font><font style="vertical-align: inherit;">Si tiene la oportunidad de comprobarlo, me alegrará compartirlo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pequeño bono</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, no es posible detectar tales problemas usando el caché del plan de consulta. </font><font style="vertical-align: inherit;">Aquí hay ejemplos de planes del caché: por desgracia, no hay advertencias en ellos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/g5/kg/eug5kgej0aai31sbnd3ukzp31qm.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/su/vg/yp/suvgypz4s5ejzxv_9zootujvoim.png"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489164/index.html">Actualización de clúster de Kubernetes sin tiempo de inactividad</a></li>
<li><a href="../es489166/index.html">Acerca del funcionamiento de una PC con el ejemplo de Windows 10 y el teclado de la Parte 2</a></li>
<li><a href="../es489172/index.html">Fijamos la autorización de ActiveDirectory a Kubernetes con Keycloak</a></li>
<li><a href="../es489174/index.html">Principio de responsabilidad única (SRP) con Laravel</a></li>
<li><a href="../es489178/index.html">GSMout: recibe SMS y llamadas "en casa"</a></li>
<li><a href="../es489188/index.html">Iniciar sesión en un entorno microservicio .Net en la práctica</a></li>
<li><a href="../es489190/index.html">Estudio de RedHat: el código abierto desplaza el software propietario del segmento empresarial</a></li>
<li><a href="../es489192/index.html">Smart Engines ingresó a los tres primeros en el ranking FWCI entre las organizaciones básicas de FizTech</a></li>
<li><a href="../es489194/index.html">Cómo OpenShift está cambiando la estructura organizativa de una organización de TI. La evolución de los modelos organizacionales al pasar a PaaS</a></li>
<li><a href="../es489196/index.html">Humo Mágico: Microcontroladores vs. Reguladores Lineales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>