<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 🤚🏼 🧙🏾 Rのカテゴリカルデータの階層的クラスタリング 🔲 🤘🏻 🔐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="コース「Applied Analytics on R」の受講者のために翻訳が準備されました。
 
 
 
 
 これは、実際のデータに基づいてクライアントをクラスタリングする最初の試みであり、貴重な経験をしてくれました。数値変数を使用したクラスタリングについてはインターネット上に多くの記事があります...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rのカテゴリカルデータの階層的クラスタリング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/461741/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コース</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Applied Analytics on R」の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受講者のために翻訳が準備されました</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/wq/q0/sp/wqq0sphqihtnsg1f8eor15ffkgi.png"><br>
<hr><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、実際のデータに基づいてクライアントをクラスタリングする最初の試みであり、貴重な経験をしてくれました。</font><font style="vertical-align: inherit;">数値変数を使用したクラスタリングについてはインターネット上に多くの記事がありますが、やや難しいカテゴリカルデータの解決策を見つけるのはそれほど簡単ではありませんでした。</font><font style="vertical-align: inherit;">カテゴリカルデータのクラスタリング手法はまだ開発中です。別の投稿で、別の投稿を試します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、カテゴリデータをクラスタリングすると意味のある結果が得られない可能性があると多くの人が信じています-これは部分的に当てはまります（&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrossValidatedに関する優れた説明を参照）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）あるとき、私は次のように思いました。それらは単にコホートに分けることができます。」ただし、コホート分析も常に推奨されるわけではありません。特に、多数のレベルを持つかなりの数のカテゴリ変数の場合、5〜7個のコホートを簡単に処理できますが、22個の変数があり、それぞれに5つのレベルがある場合（たとえば、個別の見積もりによる顧客調査1 、2、3、4、および5）、そしてどのクライアントの特性グループを扱っているかを理解する必要があります-22x5のコホートを取得します。誰もそのような仕事に煩わされたくありません。そして、ここでクラスタリングが役立ちます。そこで、この投稿では、クラスタリングを開始したらすぐに自分が知りたいことについてお話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタリングプロセス自体は3つのステップで構成されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非類似性のマトリックスを構築することは、間違いなくクラスタリングにおける最も重要な決定です。</font><font style="vertical-align: inherit;">以降の手順はすべて、作成した非類似度マトリックスに基づいています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタリング方法の選択。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスター評価。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿は、クラスタリングの基本原則と環境Rでのその実装について説明する、一種の紹介になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非類似度マトリックス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタリングの基礎は非類似度マトリックスです。非類似度マトリックスは、データセット内のポイントが互いに（削除されて）どれだけ異なるかを数学的に説明します。これにより、互いに最も近いポイントをさらにグループ化したり、最も離れたポイントを互いに分離したりすることができます-これがクラスタリングの主な考え方です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非類似度マトリックスは個々のデータポイント間の距離に基づいて作成されるため、この段階では、データタイプ間の違いが重要です。数値データのポイント間の距離（よく知られている例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユークリッド距離</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を想像するのは簡単ですが</font><font style="vertical-align: inherit;">、カテゴリカルデータ（Rの因子）の場合、すべてがそれほど明白ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合に非類似度行列を作成するには、いわゆるガバー距離を使用する必要があります。 ：私はこの概念の数学的な部分を掘り下げませんが、私は単純にリンクを提供します&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;と&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そこ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このため、私</font><font style="vertical-align: inherit;">はパッケージの</font></font><code>daisy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリック</font><font style="vertical-align: inherit;">を使用することを好み</font></font><code>metric = c("gower")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>cluster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">#-----   -----#</span>
<span class="hljs-comment">#    ,       ,     ,   ,   </span><font></font>
library(dplyr)<font></font>
<span class="hljs-comment">#    </span><font></font>
set.seed(40)<font></font>
<span class="hljs-comment">#    </span>
<span class="hljs-comment">#    ;   data.frame()    </span>
<span class="hljs-comment">#    ,   200   1  200</span><font></font>
id.s &lt;- c(1:200) %&gt;%<font></font>
        factor()<font></font>
budget.s &lt;- sample(c("small", "med", "large"), 200, <span class="hljs-keyword">replace</span> = T) %&gt;%<font></font>
            factor(<span class="hljs-keyword">levels</span>=c(<span class="hljs-string">"small"</span>, <span class="hljs-string">"med"</span>, <span class="hljs-string">"large"</span>), <font></font>
            ordered = <span class="hljs-literal">TRUE</span>)<font></font>
origins.s &lt;- <span class="hljs-keyword">sample</span>(c(<span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>, <span class="hljs-string">"z"</span>), <span class="hljs-number">200</span>, <span class="hljs-keyword">replace</span> = T, <font></font>
             prob = c(<span class="hljs-number">0.7</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.15</span>))<font></font>
area.s &lt;- <span class="hljs-keyword">sample</span>(c(<span class="hljs-string">"area1"</span>, <span class="hljs-string">"area2"</span>, <span class="hljs-string">"area3"</span>, <span class="hljs-string">"area4"</span>), <span class="hljs-number">200</span>, 
          <span class="hljs-keyword">replace</span> = T,<font></font>
          prob = c(<span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.2</span>))<font></font>
source.s &lt;- <span class="hljs-keyword">sample</span>(c(<span class="hljs-string">"facebook"</span>, <span class="hljs-string">"email"</span>, <span class="hljs-string">"link"</span>, <span class="hljs-string">"app"</span>), <span class="hljs-number">200</span>,   
            <span class="hljs-keyword">replace</span> = T,<font></font>
            prob = c(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>))
<span class="hljs-comment">##  &nbsp;—     </span>
dow.s &lt;- <span class="hljs-keyword">sample</span>(c(<span class="hljs-string">"mon"</span>, <span class="hljs-string">"tue"</span>, <span class="hljs-string">"wed"</span>, <span class="hljs-string">"thu"</span>, <span class="hljs-string">"fri"</span>, <span class="hljs-string">"sat"</span>, <span class="hljs-string">"sun"</span>), <span class="hljs-number">200</span>, <span class="hljs-keyword">replace</span> = T,<font></font>
         prob = c(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>)) %&gt;%<font></font>
         factor(<span class="hljs-keyword">levels</span>=c(<span class="hljs-string">"mon"</span>, <span class="hljs-string">"tue"</span>, <span class="hljs-string">"wed"</span>, <span class="hljs-string">"thu"</span>, <span class="hljs-string">"fri"</span>, <span class="hljs-string">"sat"</span>, <span class="hljs-string">"sun"</span>), <font></font>
        ordered = <span class="hljs-literal">TRUE</span>)
<span class="hljs-comment">#  </span>
dish.s &lt;- <span class="hljs-keyword">sample</span>(c(<span class="hljs-string">"delicious"</span>, <span class="hljs-string">"the one you don't like"</span>, <span class="hljs-string">"pizza"</span>), <span class="hljs-number">200</span>, <span class="hljs-keyword">replace</span> = T)<font></font>
            <font></font>
<span class="hljs-comment">#   data.frame()     </span><font></font>
synthetic.customers &lt;- data.frame(id.s, budget.s, origins.s, area.s, source.s, dow.s, dish.s)<font></font>
<span class="hljs-comment">#-----   -----#</span>
<span class="hljs-keyword">library</span>(cluster) 
<span class="hljs-comment">#      </span>
<span class="hljs-comment">#   : daisy(), diana(), clusplot()</span>
gower.dist &lt;- daisy(synthetic.customers[ ,<span class="hljs-number">2</span>:<span class="hljs-number">7</span>], metric = c(<span class="hljs-string">"gower"</span>))
<span class="hljs-comment"># class(gower.dist) </span>
<span class="hljs-comment">## , </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非類似度マトリックスは準備ができています。</font><font style="vertical-align: inherit;">200観測の場合、迅速に構築されますが、大きなデータセットを処理する場合は、非常に大量の計算が必要になる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、最初にデータセットをクリーンアップし、行から因子への必要な変換を実行し、欠損値を追跡する必要がある可能性が非常に高くなります。</font><font style="vertical-align: inherit;">私の場合、データセットには欠損値の行も含まれており、毎回美しくクラスター化されていたので、値（alas！）を見るまで、それは宝物であるように見えました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタリングアルゴリズム</font></font></h2>&nbsp;<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタリングは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-meansと階層的である</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことをすでにご存じかもしれません</font><font style="vertical-align: inherit;">。この投稿では、2番目の方法に焦点を当てます。2番目の方法はより柔軟で、さまざまなアプローチが可能です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凝集</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（下から上）または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分割</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;（上から下）の</font><font style="vertical-align: inherit;">いずれかの</font><font style="vertical-align: inherit;">クラスタリングアルゴリズム</font><font style="vertical-align: inherit;">を選択できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nl/vp/u4/nlvpu4e8ykoh_nd_el_4i6plh8q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出典：&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UC Business Analytics Rプログラミングガイド</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
凝集型クラスタリングはクラスターから始まります&nbsp; </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;。ここ&nbsp; </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;で、は観測値の数です。それぞれが個別のクラスターであると想定されています。次に、アルゴリズムはそれらの間で最も類似したデータポイントを見つけてグループ化しようとします-これがクラスター形成の始まりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分割クラスタリングは逆の方法で実行されます。最初は、n個のデータポイントがすべて1つの大きなクラスターであると想定され、次に、類似性が最も低いものは個別のグループに分割されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの方法のどれを選択するかを決定するときは、常にすべてのオプションを試すことが理にかなっていますが、一般に、&nbsp; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凝集クラスタリングは小さなクラスタを識別するのに優れており、ほとんどのコンピュータプログラムで使用され、分割クラスタリングは大きなクラスタを識別するのにより適しています</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
個人的には、使用する方法を決定する前に、樹状図（クラスタリングのグラフィック表現）を確認することを好みます。後で見るように、いくつかのデンドログラムはバランスが取れていますが、非常に無秩序です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
＃以下のコードの主な入力は非類似度（距離行列）です</font></font><br>
<pre><code class="sql hljs"><span class="hljs-comment">#            </span>
<span class="hljs-comment">#           &nbsp;—        &nbsp;—   </span>
<span class="hljs-comment">#------------  ------------#</span><font></font>
divisive.clust &lt;- diana(as.matrix(gower.dist), <font></font>
                  diss = TRUE, keep.diss = TRUE)<font></font>
plot(divisive.clust, main = "Divisive")</code></pre><br>
<img src="https://habrastorage.org/webt/54/mp/m1/54mpm19v8jkkpmj6usehxlgr5qk.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">#------------   ------------#</span>
<span class="hljs-comment">#     </span>
<span class="hljs-comment">#        &nbsp;—     ,     </span>
<span class="hljs-comment">#    (complete linkages)</span><font></font>
aggl.clust.c &lt;- hclust(gower.dist, method = "complete")<font></font>
plot(aggl.clust.c,<font></font>
     main = "Agglomerative, complete linkages")</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタリング品質評価</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&nbsp;この段階では、異なるクラスタリングアルゴリズムと異なる数のクラスターの間で選択を行う必要があります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常識に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">導かれることを忘れずに、さまざまな評価方法を使用できます</font><font style="vertical-align: inherit;">。選択の意味が</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に重要で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるため、これらの単語を太字と斜体で強調表示しました。</font><font style="vertical-align: inherit;">&nbsp;クラスターの数とデータをグループに分割する方法は、実用的な観点から実用的であるはずです。カテゴリー変数の値の組み合わせの数は有限ですが（それらは離散的であるため）、それらに基づく分解は意味がありません。また、非常に少数のクラスターを作成したくない場合もあります。この場合、クラスターが一般化しすぎます。最後に、それはすべてあなたの目標と分析のタスクに依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、クラスターを作成するときは、明確に定義されたデータポイントのグループを取得することに関心があります。そのため、クラスター内のそのようなポイント間の距離（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはコンパクトさ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は最小になり、グループ間の距離（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離可能性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は可能な限り最大になります。</font><font style="vertical-align: inherit;">これは直感的に簡単に理解できます。ポイント間の距離は、非類似度マトリックスに基づいて取得される非類似度の尺度です。</font><font style="vertical-align: inherit;">したがって、クラスタリングの品質の評価は、コンパクトさと分離可能性の評価に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2つのアプローチを示し、そのうちの1つが意味のない結果をもたらす可能性があることを示します。</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エルボー法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：分析の最も重要な要素がクラスターのコンパクトさ、つまりグループ内の類似性である場合は、</font><i><font style="vertical-align: inherit;">エルボー法</font></i><font style="vertical-align: inherit;">から始めます。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シルエット評価方法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：データの一貫性の尺度として使用される</font><i><font style="vertical-align: inherit;">シルエット</font></i><font style="vertical-align: inherit;">グラフは、1つのクラスター内の各ポイントが隣接するクラスター内のポイントにどれだけ近いかを示します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、これらの2つの方法は異なる結果をもたらすことが多く、混乱を招く可能性があります。最大数のコンパクトさと最大の明確な分離は、異なる数のクラスターで達成されるため、データの実際の意味に関する常識と理解が重要な役割を果たします。最終決定をするとき。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析できるメトリックもいくつかあります。</font><font style="vertical-align: inherit;">それらを直接コードに追加します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">#      ,       </span>
<span class="hljs-comment">#      ,     ,  &nbsp;—  </span>
<span class="hljs-comment">#     ,      ,         ,   ,    </span><font></font>
library(fpc)<font></font>
cstats.table &lt;- function(dist, tree, k) {<font></font>
clust.assess &lt;- c("cluster.number","n","within.cluster.ss","average.within","average.between",<font></font>
                  "wb.ratio","dunn2","avg.silwidth")<font></font>
clust.size &lt;- c("cluster.size")<font></font>
stats.names &lt;- c()<font></font>
row.clust &lt;- c()<font></font>
output.stats &lt;- matrix(ncol = k, nrow = length(clust.assess))<font></font>
cluster.sizes &lt;- matrix(ncol = k, nrow = k)<font></font>
for(i in c(1:k)){<font></font>
  row.clust[i] &lt;- paste("Cluster-", i, " size")<font></font>
}<font></font>
for(i in c(2:k)){<font></font>
  stats.names[i] &lt;- paste("Test", i-1)<font></font>
  <font></font>
  for(j in seq_along(clust.assess)){<font></font>
    output.stats[j, i] &lt;- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]<font></font>
    <font></font>
  }<font></font>
  <font></font>
  for(d in 1:k) {<font></font>
    cluster.sizes[d, i] &lt;- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]<font></font>
    dim(cluster.sizes[d, i]) &lt;- c(length(cluster.sizes[i]), 1)<font></font>
    cluster.sizes[d, i]<font></font>
    <font></font>
  }<font></font>
}<font></font>
output.stats.df &lt;- data.frame(output.stats)<font></font>
cluster.sizes &lt;- data.frame(cluster.sizes)<font></font>
cluster.sizes[is.na(cluster.sizes)] &lt;- 0<font></font>
rows.all &lt;- c(clust.assess, row.clust)<font></font>
<span class="hljs-comment"># rownames(output.stats.df) &lt;- clust.assess</span><font></font>
output &lt;- rbind(output.stats.df, cluster.sizes)[ ,-1]<font></font>
colnames(output) &lt;- stats.names[2:k]<font></font>
rownames(output) &lt;- rows.all<font></font>
is.num &lt;- sapply(output, is.numeric)<font></font>
output[is.num] &lt;- lapply(output[is.num], round, 2)<font></font>
output<font></font>
}<font></font>
<span class="hljs-comment">#     :      7</span>
<span class="hljs-comment">#     ,           </span><font></font>
stats.df.divisive &lt;- cstats.table(gower.dist, divisive.clust, 7)<font></font>
stats.df.divisive</code></pre><br>
<img src="https://habrastorage.org/webt/r-/g_/ou/r-g_oukwyorhqnsls_cbg4c8spw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、クラスター内の観測値間の平均距離を表すaverage.withinインジケーターは、instance.cluster.ss（クラスター内の観測値間の距離の二乗の合計）と同様に減少します。シルエットの平均幅（avg.silwidth）はそれほど明確に変化しませんが、逆の関係が依然として見られます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスターサイズの不均衡に注意してください。クラスター内で比類のない数の観測を急いで使用することはありません。理由の1つは、データセットが不均衡である可能性があり、一部の観測グループが分析の他のすべてのグループを上回ります-これは良好ではなく、エラーを引き起こす可能性が高いです。</font></font><br>
<br>
<code>stats.df.aggl &lt;-cstats.table(gower.dist, aggl.clust.c, 7) #      </code><br>
<br>
<code>stats.df.aggl</code><br>
<br>
<img src="https://habrastorage.org/webt/a_/-u/aa/a_-uaa_nff99nuyobulroyk_hka.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全な通信方法に基づく凝集型階層クラスタリングが、グループごとの観測数の点でどのようにバランスが取れているかに注意してください。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment"># ---------    ---------#</span>
<span class="hljs-comment">#   «»      </span>
<span class="hljs-comment">#    ,     7 </span><font></font>
library(ggplot2)<font></font>
<span class="hljs-comment"># </span>
<span class="hljs-comment">#  </span><font></font>
ggplot(data = data.frame(t(cstats.table(gower.dist, divisive.clust, 15))), <font></font>
  aes(x=cluster.number, y=within.cluster.ss)) + <font></font>
  geom_point()+<font></font>
  geom_line()+<font></font>
  ggtitle("Divisive clustering") +<font></font>
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +<font></font>
  theme(plot.title = element_text(hjust = 0.5))</code></pre><br>
<img src="https://habrastorage.org/webt/kw/kz/xy/kwkzxyuuzwhe0yst9kteg9inias.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、「ひじ」のグラフを作成しました。</font><font style="vertical-align: inherit;">これは、観測値間の2乗距離の合計（観測値の近接度の測定値として使用します。これが小さいほど、クラスター内の測定値が互いにより近くなります）がクラスターの数によってどのように変化するかを示します。</font><font style="vertical-align: inherit;">理想的には、さらにクラスタリングすると二乗和（SS）がわずかに減少する点で、明確な「エルボーベンド」が表示されます。</font><font style="vertical-align: inherit;">下のグラフでは、約7で停止します。ただし、この場合、クラスターの1つは2つの観測のみで構成されます。</font><font style="vertical-align: inherit;">集積クラスタリング中に何が起こるか見てみましょう。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">#      </span><font></font>
ggplot(data = data.frame(t(cstats.table(gower.dist, aggl.clust.c, 15))), <font></font>
  aes(x=cluster.number, y=within.cluster.ss)) + <font></font>
  geom_point()+<font></font>
  geom_line()+<font></font>
  ggtitle("Agglomerative clustering") +<font></font>
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +<font></font>
  theme(plot.title = element_text(hjust = 0.5))</code></pre><br>
<img src="https://habrastorage.org/webt/y0/ck/q-/y0ckq-zxtzg0fbjr9gcq1jgorvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
凝集「エルボー」は除算に似ていますが、グラフは滑らかに見えます-曲がりはそれほど顕著ではありません。分割クラスタリングと同様に、7つのクラスターに焦点を当てますが、これら2つの方法のどちらかを選択する場合は、凝集法によって得られるクラスターサイズの方が好きです。互いに比較できる方が良いです。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment"># </span><font></font>
ggplot(data = data.frame(t(cstats.table(gower.dist, divisive.clust, 15))), <font></font>
  aes(x=cluster.number, y=avg.silwidth)) + <font></font>
  geom_point()+<font></font>
  geom_line()+<font></font>
  ggtitle("Divisive clustering") +<font></font>
  labs(x = "Num.of clusters", y = "Average silhouette width") +<font></font>
  theme(plot.title = element_text(hjust = 0.5))</code></pre><br>
<img src="https://habrastorage.org/webt/u9/nj/nf/u9njnfcjqbxbzlfgpl5sxqailra.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シルエット推定法を使用するときは、最大となるシルエット係数を与える量を選択する必要があります。これは、分離していると見なすのに十分離れているクラスターが必要だからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シルエット係数の範囲は–1〜1で、1はクラスター内の良好な一貫性に対応し、–1はあまり良くありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のチャートの場合、5つのクラスターではなく9つのクラスターを選択します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較のために：「単純な」ケースでは、シルエットグラフは以下のものに似ています。私たちのものとはかなり違いますが、ほとんどです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/18/yw/uj/18ywujz8uh4q5hhnhtxlzrgs1nm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出典：&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Sailors</font></font></a></i><br>
<br>
<pre><code class="sql hljs">ggplot(data = data.frame(t(cstats.table(gower.dist, aggl.clust.c, 15))), <font></font>
  aes(x=cluster.number, y=avg.silwidth)) + <font></font>
  geom_point()+<font></font>
  geom_line()+<font></font>
  ggtitle("Agglomerative clustering") +<font></font>
  labs(x = "Num.of clusters", y = "Average silhouette width") +<font></font>
  theme(plot.title = element_text(hjust = 0.5))</code></pre><br>
<img src="https://habrastorage.org/webt/vk/f1/fl/vkf1fln-v-nedwuh6rzbjkxz2pg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シルエット幅チャートは、データセットを分割すればするほど、クラスターがより明確になることを示しています。ただし、最終的には個々のポイントに到達するため、これは必要ありません。ただし、これは、クラスター数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">増加を開始した場合に表示されるとおりです</font><font style="vertical-align: inherit;">。たとえば</font></font><code>k=30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;、次のグラフを受け取った</font><font style="vertical-align: inherit;">とき&nbsp; </font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sz/nq/sy/sznqsykdros9uf8clfabfg8yb94.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まとめると、データセットを分割すればするほど、クラスターは良くなりますが、個々のポイントに到達できません（たとえば、上のグラフでは、30のクラスターを選択しており、データポイントは200しかありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私たちの場合の凝集クラスタリングは私にははるかにバランスが取れているようです：クラスターサイズは多かれ少なかれ同等です（分割法で除算するときは、2つの観測のみのクラスターを見てください！）、そしてこの方法で得られた7つのクラスターで停止します。それらがどのように見え、何でできているか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットは、2Dまたは3Dで視覚化する必要がある6つの変数で構成されているため、一生懸命作業する必要があります。カテゴリカルデータの性質により、いくつかの制限が課されるため、既製のソリューションが機能しない場合があります。私はする必要があります：a）観測がクラスターに分割される方法を確認する、b）観測が分類される方法を理解する。したがって、私はa）カラー樹状図、b）各クラスター内の変数ごとの観測数のヒートマップを作成しました。</font></font><br>
<br>
<pre><code class="sql hljs">library("ggplot2")<font></font>
library("reshape2")<font></font>
library("purrr")<font></font>
library("dplyr")<font></font>
<span class="hljs-comment">#   </span><font></font>
library("dendextend")<font></font>
dendro &lt;- as.dendrogram(aggl.clust.c)<font></font>
dendro.col &lt;- dendro %&gt;%<font></font>
  <span class="hljs-keyword">set</span>(<span class="hljs-string">"branches_k_color"</span>, k = <span class="hljs-number">7</span>, <span class="hljs-keyword">value</span> =   c(<span class="hljs-string">"darkslategray"</span>, <span class="hljs-string">"darkslategray4"</span>, <span class="hljs-string">"darkslategray3"</span>, <span class="hljs-string">"gold3"</span>, <span class="hljs-string">"darkcyan"</span>, <span class="hljs-string">"cyan3"</span>, <span class="hljs-string">"gold3"</span>)) %&gt;%
  <span class="hljs-keyword">set</span>(<span class="hljs-string">"branches_lwd"</span>, <span class="hljs-number">0.6</span>) %&gt;%
  <span class="hljs-keyword">set</span>(<span class="hljs-string">"labels_colors"</span>, 
      <span class="hljs-keyword">value</span> = c(<span class="hljs-string">"darkslategray"</span>)) %&gt;% 
  <span class="hljs-keyword">set</span>(<span class="hljs-string">"labels_cex"</span>, <span class="hljs-number">0.5</span>)<font></font>
ggd1 &lt;- as.ggdend(dendro.col)<font></font>
ggplot(ggd1, theme = theme_minimal()) +<font></font>
  labs(x = <span class="hljs-string">"Num. observations"</span>, y = <span class="hljs-string">"Height"</span>, title = <span class="hljs-string">"Dendrogram, k = 7"</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/iy/hf/jx/iyhfjxt9q7vztvwbaazmqlzzno0.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">#     ( )</span><font></font>
ggplot(ggd1, labels = T) + <font></font>
  scale_y_reverse(expand = c(0.2, 0)) +<font></font>
  coord_polar(theta="x")</code></pre><br>
<img src="https://habrastorage.org/webt/if/4g/yv/if4gyv42vtgecjd9n-b_0bb91rs.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment"># &nbsp;—  </span>
<span class="hljs-comment">#   &nbsp;—      </span>
<span class="hljs-comment">#    ,     </span><font></font>
clust.num &lt;- cutree(aggl.clust.c, k = 7)<font></font>
synthetic.customers.cl &lt;- cbind(synthetic.customers, clust.num)<font></font>
cust.long &lt;- melt(data.frame(lapply(synthetic.customers.cl, as.character), stringsAsFactors=FALSE), <font></font>
                  id = c("id.s", "clust.num"), factorsAsStrings=T)<font></font>
cust.long.q &lt;- cust.long %&gt;%<font></font>
  group_by(clust.num, variable, value) %&gt;%<font></font>
  mutate(count = n_distinct(id.s)) %&gt;%<font></font>
  distinct(clust.num, variable, value, count)<font></font>
<span class="hljs-comment"># heatmap.c ,     &nbsp;— ,   ,    </span><font></font>
heatmap.c &lt;- ggplot(cust.long.q, aes(x = clust.num, y =        factor(value, levels = c("x","y","z",                                                                   "mon", "tue", "wed", "thu", "fri","sat","sun",                                                       "delicious", "the one you don't like", "pizza",                                                             "facebook", "email", "link", "app",                                                             "area1", "area2", "area3", "area4",                                                             "small", "med", "large"), ordered = T))) +<font></font>
  <font></font>
  geom_tile(aes(fill = count))+<font></font>
  scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4")<font></font>
<span class="hljs-comment">#           </span><font></font>
cust.long.p &lt;- cust.long.q %&gt;%<font></font>
  group_by(clust.num, variable) %&gt;%<font></font>
  mutate(perc = count / sum(count)) %&gt;%<font></font>
  arrange(clust.num)<font></font>
heatmap.p &lt;- ggplot(cust.long.p, aes(x = clust.num, y = factor(value, levels = c("x","y","z",<font></font>
      "mon", "tue", "wed", "thu", "fri","sat", "sun",                                                                     "delicious", "the one you don't like", "pizza",                                             "facebook", "email", "link", "app",                                             "area1", "area2", "area3", "area4",                                           "small", "med", "large"), ordered = T))) +<font></font>
  <font></font>
geom_tile(aes(fill = perc), alpha = 0.85)+<font></font>
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +<font></font>
  geom_hline(yintercept = 3.5) + <font></font>
  geom_hline(yintercept = 10.5) + <font></font>
  geom_hline(yintercept = 13.5) + <font></font>
  geom_hline(yintercept = 17.5) + <font></font>
  geom_hline(yintercept = 21.5) + <font></font>
  scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4")<font></font>
heatmap.p</code></pre><br>
<img src="https://habrastorage.org/webt/c5/gg/y5/c5ggy5vih07qcfi4h26mgcvkfgy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒートマップは、初期因子（最初に使用した変数）の各因子レベルで行われた観測数をグラフで示します。</font><font style="vertical-align: inherit;">濃い青色は、クラスター内の比較的多数の観測に対応しています。</font><font style="vertical-align: inherit;">このヒートマップは、曜日（日曜日、土曜日...月曜日）とバスケットサイズ（大、中、小）の場合、各セルの顧客数はほぼ同じであることを示しています。これは、これらのカテゴリが分析のために決定的ではないことを意味している可能性があります。おそらく、それらを考慮する必要はありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、非類似度行列を計算し、階層的クラスタリングの凝集法と分割法をテストし、クラスターの品質を評価するためのエルボー法とシルエット法に慣れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
部門別および集合型の階層的クラスタリングは、このトピックを研究するための良いスタートですが、真にクラスタ分析を習得したい場合は、そこで停止しないでください。他の多くの方法とテクニックがあります。数値データのクラスタリングとの主な違いは、非類似度行列の計算です。クラスタリングの品質を評価するとき、すべての標準的な方法が信頼できる意味のある結果を与えるわけではありません-シルエット法はおそらく適切ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、この例を作成してからしばらく時間が経過したため、私のアプローチには多くの欠点があり、フィードバックがあれば喜んでいます。私の分析の重要な問題の1つは、クラスタリング自体には関連していませんでした。  </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のデータセットは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;多くの点で</font><i><font style="vertical-align: inherit;">不均衡</font></i><font style="vertical-align: inherit;">であり、この瞬間は考慮されていませんでした。これはクラスタリングに顕著な影響を及ぼしました。クライアントの70％が「市民権」因子の1つのレベルに属しており、このグループが取得したクラスターのほとんどを支配していたため、因子の他のレベル内の差異を計算することが困難でした。次回は、データセットのバランスを取り、クラスタリングの結果を比較してみます。しかし、その詳細については別の投稿で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私のコードを複製する場合は、githubへのリンクを次に示します。&nbsp;</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/khunreus/cluster-categorical</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この記事をお楽しみください。</font></font><br>
<br>
<i><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私を助けた情報源：</font></font></h3></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
階層的クラスタリングガイド（データの準備、クラスタリング、視覚化）-このブログは、R環境でのビジネス分析に興味がある人にとって興味深いでしょう：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :&nbsp; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//uc-r.github.io/hc_clustering</font></a><font style="vertical-align: inherit;"> &nbsp;および&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https：// uc-r。 github.io/kmeans_clusteringクラスター</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
検証：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :&nbsp; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//www.sthda.com/english/articles/29-cluster-validation-essentials/97-cluster-validation-statistics-must-know-methods/</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ドキュメント分類の例（階層的およびk-means method）：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//eight2late.wordpress.com/2015/07/22/a-gentle-introduction-to-cluster-analysis-using-r/非常に興味深いdenextendパッケージを使用して、さまざまなクラスターの構造を比較することができますメソッド：&nbsp;</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://cran.r-project.org/web/packages/dendextend/vignettes/introduction.html#the-set-function</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
樹形図だけでなく、クラスターグラムもあります：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ://www.r-statistics.com/&nbsp; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2010/06 / clustergram-visualization-and-diagnostics-for-cluster-analysis-r-code /</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ヒートマップとデンドログラムの組み合わせ：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :&nbsp; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//jcoliver.github.io/learn-r/008-ggplot-dendrograms-and- heatmaps.html</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私は個人的に記事&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5025633/（GitHubの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :&nbsp; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//github.com/khunreus/EnsCat</font></a><font style="vertical-align: inherit;">）</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja461729/index.html">脱獄を使用してデータを抽出する：リスクと結果</a></li>
<li><a href="../ja461733/index.html">英語学習：9つのアメリカンスタイルのイディオム</a></li>
<li><a href="../ja461735/index.html">FFmpeg DXVA2ハードウェアデコードプラクティス</a></li>
<li><a href="../ja461737/index.html">JavaScript + VSコードで最新のTDDの環境を収集します</a></li>
<li><a href="../ja461739/index.html">バックエンドユナイテッド4：オクローシカ。インシデント</a></li>
<li><a href="../ja461743/index.html">セキュリティウィーク31：VLCの脆弱性と壊れた電話</a></li>
<li><a href="../ja461745/index.html">DeviceLock DLP：個人データを突破するためのロシアの闇市場の価格（およびTinkoff Bankの回答への応答）</a></li>
<li><a href="../ja461747/index.html">ユーザー数が5,000万人近くのアプリケーションにMLを実装した方法。ズベルバンクエクスペリエンス</a></li>
<li><a href="../ja461749/index.html">美しさは見る人の目にある</a></li>
<li><a href="../ja461751/index.html">モバイルアプリ開発へのデザイナーの貢献</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>