<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📠 👩🏿‍🤝‍👨🏻 ◻️ Comment provoquer une fuite de mémoire dans une application Angular? 👨🏻‍🏭 🤰 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La performance est la clé du succès d'une application Web. Par conséquent, les développeurs doivent savoir comment les fuites de mémoire se produisent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment provoquer une fuite de mémoire dans une application Angular?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503312/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La performance est la clé du succès d'une application Web. Par conséquent, les développeurs doivent savoir comment les fuites de mémoire se produisent et comment y faire face. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette connaissance est particulièrement importante lorsque l'application avec laquelle le développeur traite atteint une certaine taille. Si vous ne faites pas assez attention aux fuites de mémoire, alors tout peut se retrouver avec le développeur entrant dans «l'équipe pour éliminer les fuites de mémoire» (je devais faire partie d'une telle équipe). </font><font style="vertical-align: inherit;">
Des fuites de mémoire peuvent se produire pour diverses raisons. Cependant, je pense que lorsque vous utilisez Angular, vous pouvez rencontrer un modèle qui correspond à la cause la plus courante des fuites de mémoire. Il existe un moyen de gérer ces fuites de mémoire. Et la meilleure chose, bien sûr, n'est pas de lutter contre les problèmes, mais de les éviter.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/bg/op/jz/bgopjzk2msaiedpikpoa1qcv2cm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que la gestion de la mémoire?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript utilise un système de gestion automatique de la mémoire. </font><font style="vertical-align: inherit;">Le cycle de vie de la mémoire se compose généralement de trois étapes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocation de la mémoire nécessaire.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec la mémoire allouée, effectuer des opérations de lecture et d'écriture.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Libérer de la mémoire une fois qu'elle n'est plus nécessaire.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dit que la gestion automatique de la mémoire - c'est une source potentielle de confusion. </font><font style="vertical-align: inherit;">Cela peut donner aux développeurs une fausse impression qu'ils n'ont pas à se soucier de la gestion de la mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous ne vous souciez pas du tout de la gestion de la mémoire, cela signifie qu'après que votre application aura atteint une certaine taille, vous risquez de rencontrer une fuite de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, les fuites de mémoire peuvent être considérées comme la mémoire allouée à l'application, dont elle n'a plus besoin, mais qui n'est pas libérée. </font><font style="vertical-align: inherit;">En d'autres termes, ce sont des objets qui n'ont pas pu subir d'opérations de récupération de place.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne la collecte des ordures?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cours de la procédure de collecte des ordures, ce qui est assez logique, tout ce qui peut être considéré comme des «ordures» est nettoyé. </font><font style="vertical-align: inherit;">Le garbage collector nettoie la mémoire dont l'application n'a plus besoin. </font><font style="vertical-align: inherit;">Afin de déterminer les zones de mémoire dont l'application a encore besoin, le garbage collector utilise l'algorithme «mark and sweep» (algorithme de balisage). </font><font style="vertical-align: inherit;">Comme son nom l'indique, cet algorithme se compose de deux phases - la phase de marquage et la phase de balayage.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Phase de drapeau</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les objets et leurs liens sont présentés sous la forme d'un arbre. </font><font style="vertical-align: inherit;">La racine de l'arbre est, dans la figure suivante, un nœud </font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En JavaScript, c'est un objet </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chaque objet a un drapeau spécial. </font><font style="vertical-align: inherit;">Appelons ce drapeau </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans la phase de signalisation, tout d'abord, tous les indicateurs </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont définis sur une valeur </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/436/b8a/433436b8a72bc7a207bd66c5b76788f5.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au début, les drapeaux des objets marqués sont mis à faux,</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
puis l'arborescence d'objets est parcourue. </font><font style="vertical-align: inherit;">Tous les drapeaux d'</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objets accessibles à partir du nœud</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont définis sur</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et les drapeaux de ces objets qui ne peuvent pas être atteints, restent dans la valeur</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objet est considéré comme inaccessible s'il ne peut pas être atteint à partir de l'objet racine.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/d14/a50/1cfd14a50f9be4e7aa402052982eb253.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets accessibles sont marqués comme étant marqués = true, les objets inaccessibles comme marqués = false.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Par conséquent, tous les indicateurs d'</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objets inaccessibles restent dans la valeur</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La mémoire n'a pas encore été libérée, mais, une fois la phase de marquage terminée, tout est prêt pour la phase de nettoyage.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Phase de nettoyage</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mémoire est effacée précisément à cette phase de l'algorithme. Ici, tous les objets inaccessibles (ceux dont l'indicateur </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reste dans la valeur </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sont détruits par le garbage collector.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/75f/f16/8a075ff162428195665afe583a85151f.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arborescence d'objets après la récupération de place. </font><font style="vertical-align: inherit;">Tous les objets dont l'indicateur marqué est défini sur false sont détruits par le garbage collector. Le</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
garbage collection est effectué périodiquement pendant l'exécution du programme JavaScript. </font><font style="vertical-align: inherit;">Au cours de cette procédure, la mémoire est libérée et peut être libérée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-être la question suivante se pose ici: "Si le garbage collector supprime tous les objets marqués comme inaccessibles - comment créer une fuite de mémoire?". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le point ici est que l'objet ne sera pas traité par le garbage collector si l'application n'en a pas besoin, mais vous pouvez toujours l'atteindre à partir du nœud racine de l'arborescence d'objets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme ne peut pas savoir si l'application utilisera une partie de la mémoire à laquelle elle peut accéder ou non. </font><font style="vertical-align: inherit;">Seul un programmeur possède une telle connaissance.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuites de mémoire angulaire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus souvent, des fuites de mémoire se produisent au fil du temps lorsqu'un composant est rendu à plusieurs reprises. </font><font style="vertical-align: inherit;">Par exemple - via le routage ou suite à l'utilisation de la directive </font></font><code>*ngIf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Disons, dans une situation où certains utilisateurs avancés travaillent avec l'application toute la journée sans mettre à jour la page de l'application dans le navigateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de reproduire ce scénario, nous allons créer une construction de deux composants. </font><font style="vertical-align: inherit;">Ce seront les composants </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-sub *ngIf="hide"&gt;&lt;/app-sub&gt;`</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
&nbsp;&nbsp;hide = <span class="hljs-literal">false</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.hide = !<span class="hljs-keyword">this</span>.hide, <span class="hljs-number">50</span>);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle de composant </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise le composant </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La chose la plus intéressante ici est que notre composant utilise une fonction </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui commute l'indicateur </font></font><code>hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes les 50 ms. Il en résulte qu'un composant est restitué toutes les 50 ms </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Autrement dit, la création de nouvelles instances de la classe est effectuée </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ce code imite le comportement d'un utilisateur qui travaille toute la journée avec une application Web sans actualiser une page dans un navigateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons, en </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mis en œuvre différents scénarios, dans l'utilisation desquels, au fil du temps, des changements dans la quantité de mémoire utilisée par l'application commencent à apparaître. Notez que le composant</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reste toujours le même. </font><font style="vertical-align: inherit;">Dans chaque scénario, nous découvrirons si nous avons affaire à une fuite de mémoire en analysant la consommation de mémoire du processus du navigateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la consommation de mémoire du processus augmente avec le temps, cela signifie que nous sommes confrontés à une fuite de mémoire. </font><font style="vertical-align: inherit;">Si un processus utilise une quantité de mémoire plus ou moins constante, cela signifie soit qu'il n'y a pas de fuite de mémoire, soit que la fuite, bien que présente, ne se manifeste pas de manière assez évidente.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Scénario # 1: énorme pour la boucle</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre premier scénario est représenté par une boucle qui s'exécute 100 000 fois. </font><font style="vertical-align: inherit;">Dans la boucle, des valeurs aléatoires sont ajoutées au tableau. </font><font style="vertical-align: inherit;">N'oublions pas que le composant est restitué toutes les 50 ms. </font><font style="vertical-align: inherit;">Jetez un œil au code et réfléchissez si nous avons créé une fuite de mémoire ou non.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;arr = [];<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.arr.push(<span class="hljs-built_in">Math</span>.random());<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que ce code ne doive pas être envoyé en production, il ne crée pas de fuite de mémoire. </font><font style="vertical-align: inherit;">À savoir, la consommation de mémoire ne dépasse pas la plage limitée à une valeur de 15 Mo. </font><font style="vertical-align: inherit;">Par conséquent, il n'y a aucune fuite de mémoire. </font><font style="vertical-align: inherit;">Ci-dessous, nous expliquerons pourquoi il en est ainsi.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Scénario 2: abonnement à BehaviorSubject</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce scénario, nous nous abonnons </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et attribuons une valeur à une constante. </font><font style="vertical-align: inherit;">Y a-t-il une fuite de mémoire dans ce code? </font><font style="vertical-align: inherit;">Comme précédemment, n'oubliez pas que le composant est rendu toutes les 50 ms.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, comme dans l'exemple précédent, il n'y a pas de fuite de mémoire.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Scénario 3: attribuer une valeur à un champ de classe dans un abonnement</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, presque le même code est présenté comme dans l'exemple précédent. </font><font style="vertical-align: inherit;">La principale différence est que la valeur n'est pas attribuée à une constante, mais à un champ de classe. </font><font style="vertical-align: inherit;">Et maintenant, pensez-vous qu'il y a une fuite dans le code?</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous croyez qu'il n'y a pas de fuite ici - vous avez absolument raison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le scénario # 1, il n'y a pas d'abonnement. </font><font style="vertical-align: inherit;">Dans les scénarios n ° 2 et 3, nous avons souscrit au flux de l'objet observé initialisé dans notre composante. </font><font style="vertical-align: inherit;">Il semble que nous soyons en sécurité en souscrivant aux flux de composants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que se passe-t-il si nous ajoutons un service à notre programme?</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénarios utilisant le service</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les scénarios suivants, nous allons réviser les exemples ci-dessus, mais cette fois, nous nous abonnerons au flux fourni par le service </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Voici le code de service.</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({
&nbsp;&nbsp;<span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyService</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;some$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="hljs-number">42</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devant nous est un service simple. </font><font style="vertical-align: inherit;">Il s'agit simplement d'un service qui fournit stream ( </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sous la forme d'un champ de classe publique.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Scénario 4: abonnement à un flux et attribution d'une valeur à une constante locale</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous recréerons ici le même schéma que celui déjà décrit précédemment. </font><font style="vertical-align: inherit;">Mais cette fois, nous nous abonnons au flux </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et non au champ du composant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y a-t-il une fuite de mémoire? </font><font style="vertical-align: inherit;">Encore une fois, lorsque vous répondez à cette question, n'oubliez pas que le composant est utilisé </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et rendu plusieurs fois.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous avons finalement créé une fuite de mémoire. </font><font style="vertical-align: inherit;">Mais c'est une petite fuite. </font><font style="vertical-align: inherit;">Par "petite fuite", j'entends celle qui, avec le temps, entraîne une lente augmentation de la quantité de mémoire consommée. </font><font style="vertical-align: inherit;">Cette augmentation est à peine perceptible, mais une inspection rapide de l'instantané du tas a montré la présence de nombreuses instances non supprimées </font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Scénario 5: abonnement à un service et attribution d'une valeur à un champ de classe</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous nous abonnons à nouveau à </font></font><code>dummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais cette fois, nous attribuons la valeur résultante au champ de classe, et non une constante locale.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et ici, nous avons finalement créé une fuite de mémoire importante. </font><font style="vertical-align: inherit;">La consommation de mémoire rapidement, en moins d'une minute, a dépassé 1 Go. </font><font style="vertical-align: inherit;">Parlons pourquoi il en est ainsi.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HenQuand une fuite de mémoire s'est-elle produite?</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez peut-être remarqué que dans les trois premiers scénarios, nous n'avons pas pu créer de fuite de mémoire. </font><font style="vertical-align: inherit;">Ces trois scénarios ont quelque chose en commun: tous les liens sont locaux vers le composant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous nous abonnons à un objet observable, il stocke une liste d'abonnés. </font><font style="vertical-align: inherit;">Notre rappel est également sur cette liste, et le rappel peut se référer à notre composant.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/49f/92e/bda49f92eb184ad1eb78231a4144b71c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aucune fuite de mémoire</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lorsqu'un composant est détruit, c'est-à-dire lorsque Angular n'a plus de lien vers lui, ce qui signifie que le composant ne peut pas être atteint depuis le nœud racine, l'objet observé et sa liste d'abonnés ne peuvent pas non plus être atteints depuis le nœud racine. Par conséquent, l'objet composant entier est récupéré.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tant que nous sommes abonnés à un objet observable, dont les liens ne sont qu'à l'intérieur du composant, aucun problème ne se pose. Mais lorsque le service entre en jeu, la situation change.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/6f7/b5b/4546f7b5b2ab2d2858f550740243189e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuite de mémoire</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dès que nous nous sommes abonnés à un objet observable fourni par un service ou une autre classe, nous avons créé une fuite de mémoire. </font><font style="vertical-align: inherit;">Cela est dû à l'objet observé, en raison de sa liste d'abonnés. </font><font style="vertical-align: inherit;">Pour cette raison, le rappel, et donc le composant, sont accessibles à partir du nœud racine, bien qu'Angular n'ait pas de référence directe au composant. </font><font style="vertical-align: inherit;">Par conséquent, le garbage collector ne touche pas l'objet correspondant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais clarifier: vous pouvez utiliser de telles constructions, mais vous devez travailler avec elles correctement, et pas comme nous le faisons.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bon travail d'abonnement</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin d'éviter une fuite de mémoire, il est important de se désinscrire correctement de l'objet observé, en le faisant lorsque l'abonnement n'est plus nécessaire. Par exemple, lorsqu'un composant est détruit. Il existe de nombreuses façons de se désinscrire d'un objet observé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'expérience de conseiller les propriétaires de grands projets d'entreprise indique que dans cette situation, il est préférable d'utiliser l'entité </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">créée par l'équipe </font></font><code>new Subject&lt;void&gt;()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en combinaison avec l'opérateur </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;private destroy$: Subject&lt;<span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-keyword">void</span>&gt;();<font></font>
&nbsp;&nbsp;randomNumber = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummyService.some$.pipe(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;takeUntil(<span class="hljs-keyword">this</span>.destroy$)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-keyword">this</span>.randomNumber = value);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;ngOnDestroy(): <span class="hljs-keyword">void</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.complete();<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous nous désinscrivons de l'abonnement en utilisant l' </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateur et </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">après la destruction du composant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons implémenté un hook de cycle de vie dans le composant </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chaque fois qu'un composant est détruit, nous appelons les </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthodes </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'appel est </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">très important car cet appel efface l'abonnement </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous utilisons l'opérateur </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et lui transmettons notre flux </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela garantit que l'abonnement est effacé (c'est-à-dire que nous nous sommes désabonnés de l'abonnement) après la destruction du composant.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment ne pas oublier d'effacer les abonnements?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est facile d'oublier d'ajouter le composant </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et d'oublier d'appeler </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ainsi que </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le cycle de vie du crochet </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Même si j'ai enseigné cela aux équipes travaillant sur des projets, je l'ai souvent oublié moi-même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, il existe une merveilleuse règle de linter, qui fait partie d'un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensemble de règles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui vous permet d'assurer une bonne désinscription des abonnements. </font><font style="vertical-align: inherit;">Vous pouvez définir un ensemble de règles comme celui-ci:</font></font><br>
<br>
<pre><code class="javascript hljs">npm install @angular-extensions/lint-rules --save-dev
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, il doit être connecté à </font></font><code>tslint.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-string">"extends"</span>: [
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"tslint:recommended"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"@angular-extensions/lint-rules"</span><font></font>
&nbsp;&nbsp;]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vous recommande fortement d'utiliser cet ensemble de règles dans vos projets. </font><font style="vertical-align: inherit;">Cela vous fera économiser de nombreuses heures de débogage pour trouver les sources de fuites de mémoire.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Angular, il est très facile de créer une situation entraînant des fuites de mémoire. </font><font style="vertical-align: inherit;">Même de petits changements de code dans des endroits qui, apparemment, ne devraient pas être liés à des fuites de mémoire, peuvent entraîner de graves conséquences néfastes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La meilleure façon d'éviter les fuites de mémoire est de gérer correctement vos abonnements. </font><font style="vertical-align: inherit;">Malheureusement, l'opération de nettoyage des abonnements nécessite une grande précision de la part du développeur. </font><font style="vertical-align: inherit;">C'est facile à oublier. </font><font style="vertical-align: inherit;">Par conséquent, il est recommandé d'appliquer des règles </font></font><code>@angular-extensions/lint-rules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vous aident à organiser le bon travail avec vos abonnements. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> référentiel avec le code sous-jacent à ce matériel. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avez-vous rencontré des fuites de mémoire dans des applications angulaires?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr503288/index.html">Comment nous avons recherché des candidats à l'aide de l'apprentissage automatique</a></li>
<li><a href="../fr503290/index.html">Quadricoptère industriel DJI Matrice 300 RTK</a></li>
<li><a href="../fr503300/index.html">Le livre «Rick et Morty. Guide du dessin animé le plus brillant de toutes les galaxies »</a></li>
<li><a href="../fr503302/index.html">Accélérer la construction d'un projet sur CMake + GCC: précompilation des fichiers d'en-tête</a></li>
<li><a href="../fr503310/index.html">Que pensent les programmeurs seniors?</a></li>
<li><a href="../fr503318/index.html">Profession: Programmeur. Tout n'est pas clair</a></li>
<li><a href="../fr503322/index.html">Développement de firmware: introduction</a></li>
<li><a href="../fr503324/index.html">«Au sommet» de Brad Stalberg et Steve Magness: prévention de la combustion spontanée (première partie)</a></li>
<li><a href="../fr503328/index.html">Nous compilons l'application Spring Boot en natif à l'aide de GraalVM</a></li>
<li><a href="../fr503330/index.html">Comment apprendre d'un data scientist: les compétences techniques les plus recherchées</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>