<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌐 📁 👜 Paul Graham: Brevedad = Fuerza 🍚 🌭 📪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy en HackerNews planteamos una discusión sobre el artículo de Paul Graham en 2002 y decidimos resucitar su traducción de la inexistencia.
 
 
 
 "La...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paul Graham: Brevedad = Fuerza</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/502926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoy en HackerNews planteamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una discusión sobre el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> artículo de Paul Graham en 2002 y decidimos resucitar su traducción de la inexistencia.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/643/390/da8643390d5501c1411a3ba972dbe2ac.jpg" alt="imagen"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"La cantidad de significado comprimido en un espacio pequeño </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
por signos algebraicos, es otra circunstancia que facilita </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
los razonamientos a los que estamos acostumbrados a continuar con su ayuda". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Babbage (1791-1871)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En una discusión sobre el artículo </font><font style="vertical-align: inherit;">LL1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la lista de correo LL1, Paul Prescod expresó una idea que no se me olvida.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de Python es la regularidad y la legibilidad, pero no la brevedad.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, un lenguaje de programación probablemente no debería pretender serlo. </font><font style="vertical-align: inherit;">Según tengo entendido, brevedad (concisión, concisión, compacidad) = fuerza. </font><font style="vertical-align: inherit;">Y si es así, haciendo una sustitución, obtenemos:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de Python es la regularidad y la legibilidad, pero no el poder.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lo cual, a su vez, no es un compromiso muy bueno (si es realmente un compromiso), que vale la pena hacer. </font><font style="vertical-align: inherit;">Parece que si dices: el objetivo del lenguaje Python no es ser un lenguaje de programación efectivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Brevedad = fuerza? </font><font style="vertical-align: inherit;">Esta parece una pregunta importante, tal vez la pregunta más importante para aquellos involucrados en el desarrollo de idiomas. </font><font style="vertical-align: inherit;">Todavía no estoy seguro de que la respuesta sea simplemente "sí", pero para empezar, esta es una buena hipótesis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hipótesis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi hipótesis es que la brevedad es poder, o están tan cerca que, con la excepción de los casos patológicos, puede tomarlos por algo idéntico.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La brevedad, me parece, es para lo que se crean los lenguajes de programación. Las computadoras serían igualmente felices si recibieran instrucciones directamente en lenguaje de máquina. Creo que la razón principal por la que vamos a desarrollar lenguajes de alto nivel es para obtener la ventaja de expresar (y más importante, pensar) diez líneas en un lenguaje de alto nivel, lo que requeriría 1000 líneas de código de máquina. En otras palabras, el objetivo principal de los lenguajes de alto nivel es acortar el código fuente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el código fuente más corto es el propósito de los lenguajes de alto nivel, y la fuerza de algo es una medida de qué tan bien se logra el objetivo, entonces la fuerza del lenguaje de programación es cuánto reduce sus programas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por el contrario, un lenguaje que no hace que sus programas sean más pequeños hace un mal trabajo de un lenguaje de programación, al igual que un cuchillo que corta mal o una impresión ilegible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métrica</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Y en qué sentido es menos? </font><font style="vertical-align: inherit;">La medida más común del tamaño del código fuente es el número de líneas. </font><font style="vertical-align: inherit;">Pero esta medida es común solo por la simplicidad de la medición, y no creo que nadie crea que es una buena prueba del tamaño del programa. </font><font style="vertical-align: inherit;">Los idiomas tienen diferentes convenciones sobre lo que se puede colocar en una línea; </font><font style="vertical-align: inherit;">bastantes líneas en C pueden tener solo uno o dos separadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra prueba simple es el número de caracteres en el programa, pero este no es demasiado bueno; </font><font style="vertical-align: inherit;">Algunos idiomas (como Perl) tienen identificadores más cortos que otros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que la mejor medida del tamaño de un programa puede ser el número de elementos, donde el elemento es algo que podría convertirse en un vértice separado en el árbol de origen. El nombre de una variable o función es un elemento; un número entero o un número real es un elemento; un segmento literal de texto es un elemento; un elemento de una directiva de patrón o formato es un elemento. Hay casos límite (¿es "-5" uno o dos elementos?), Pero creo que la mayoría de ellos son iguales en todos los idiomas, por lo que no afectarán demasiado la comparación.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta medida debe concretarse, y puede requerir interpretación adicional en el caso de algunos lenguajes específicos, pero me parece que está tratando de medir lo correcto: el número de partes del programa. </font><font style="vertical-align: inherit;">El árbol de origen es lo que dibuja en su mente para representar el programa y, por lo tanto, el tamaño de este árbol es proporcional a la cantidad de trabajo necesario para escribirlo o leerlo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diseño</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta medida nos permitiría comparar diferentes idiomas, pero este no es, al menos para mí, su valor básico. Y el valor de la prueba de brevedad es una guía para diseñar idiomas. La comparación de idiomas más útil es comparar dos variaciones posibles del mismo idioma. ¿Qué puedo hacer en el idioma para acortar los programas? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la carga conceptual de un programa es proporcional a su complejidad, y un programador determinado puede soportar una cierta carga conceptual, entonces esto es lo mismo que preguntar: ¿cómo pueden ayudar los programadores a hacer más? Y esto, me parece, es lo mismo que preguntar: ¿cómo diseñar un buen lenguaje?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Por cierto, la falsedad de este ya barbudo dicho "todos los idiomas son equivalentes" se ve más claramente cuando se diseñan idiomas. Cuando creas un nuevo idioma, constantemente comparas dos idiomas, uno en el que haría X, y el otro en el que no, para que decida qué es mejor. Si fuera una pregunta sin sentido, podría lanzar una moneda.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tener un objetivo de brevedad parece ser una buena manera de encontrar nuevas ideas. </font><font style="vertical-align: inherit;">Si encuentra una manera de acortar los programas, esto no es una coincidencia: probablemente haya encontrado una nueva abstracción útil. </font><font style="vertical-align: inherit;">Incluso podría escribir un programa que obtenga fragmentos repetidos en el código fuente. </font><font style="vertical-align: inherit;">Se pueden encontrar nuevas ideas entre los idiomas que tienen fama de ser concisos: Forth, Joy, Icon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparación</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero en escribir sobre estas cosas fue, hasta donde yo sé, Fred Brooks con su libro Mythical Man-Month. Escribió que los programadores generan la misma cantidad de código independientemente del idioma. Cuando lo leí por primera vez a los 20 años, fue una gran sorpresa, y me pareció que esto tenía enormes consecuencias. Esto significa que (a) la única forma de escribir programas más rápido es usar un lenguaje más corto, y (b) el que se haya molestado en hacer esto preguntará a los competidores que no lo hacen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conjetura de Brooks, si es cierta, puede ser la esencia misma de la piratería. Desde entonces, a lo largo de los años, he prestado atención a todo lo que sería relevante para el tema: desde estudios teóricos hasta historias sobre proyectos individuales. No vi nada que contradiga esta hipótesis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero no he visto ninguna evidencia clara, y no espero verlas. Estudios como la comparación de los lenguajes de programación Lutz Prekelt, aunque producen los resultados esperados, tienden a utilizar tareas que son demasiado pequeñas para una prueba significativa. La mejor prueba para un idioma es lo que sucede en los programas escritos en un mes. Y si está convencido, como yo, de que el objetivo principal de los idiomas es ser un buen idioma en el que piensan (en lugar de un idioma en el que dan instrucciones a la computadora después de que lo piense), entonces la prueba real para el idioma es ¿Qué novedades puedes escribir sobre él? Por lo tanto, comparar idiomas basados ​​en una especificación predefinida es algo incorrecto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La verdadera prueba para el idioma es qué tan bien puede encontrar y resolver nuevos problemas en él, pero no las tareas formuladas por otra persona. Estos son criterios diferentes. En el arte, las herramientas como el bordado y el mosaico funcionan bien si sabe de antemano lo que desea obtener, pero absolutamente indecente si no lo sabe. Si desea revelar una imagen en el proceso de escribir una imagen (lo que debe hacer al revelar cosas tan complejas como, por ejemplo, la imagen de una persona), debe usar una herramienta más flexible como lápiz, tinta o pinturas al óleo. Por supuesto, los tapices y los mosaicos se hacen así: primero se crea una imagen, y luego solo se copia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que es poco probable que tengamos una comparación adecuada de la fuerza relativa de los lenguajes de programación. Tendremos comparaciones exactas, pero no correctas. En particular, es probable que los estudios dirigidos explícitamente a las comparaciones de idiomas usen tareas pequeñas y necesariamente usarán un conjunto predefinido de tareas, y por lo tanto tenderán a subestimar los idiomas más poderosos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es probable que los informes en esta área, aunque serán menos precisos que los estudios "científicos", sean más significativos. Por ejemplo, Ulf Wieger de Ericsson realizó un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estudio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y llegó a la conclusión de que Erlang es 4-10 veces más corto que C ++, y que la velocidad de desarrollo de software es proporcionalmente mayor:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La comparación de proyectos internos en Ericsson revela una productividad similar en líneas de código por hora, incluidas todas las fases de desarrollo, independientemente del lenguaje utilizado (Erlang, PLEX, C, C ++ o Java). </font><font style="vertical-align: inherit;">Diferencias de idioma: solo en la cantidad total de código fuente.</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este estudio también indica claramente que no aparece en el libro de Brooks (ya que solo midió líneas de código depurado): los programas escritos en lenguajes más potentes tienden a contener menos errores. </font><font style="vertical-align: inherit;">Esto ya es suficiente, y probablemente en tareas como los conmutadores de red, esto es más importante que el rendimiento del programador.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sabores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, puedes confiar en tu instinto. ¿Qué es la programación en este lenguaje? Creo que para crear un mejor lenguaje deberías volverse hipersensible a lo bien que el lenguaje te permite pensar en él, y luego elegir o desarrollar un lenguaje que te parezca más adecuado. Si alguna propiedad del idioma es inconveniente o restrictiva, no se preocupe, lo sabrá.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero tal hipersensibilidad hará que los lenguajes torpes se vuelvan insoportables para usted. </font><font style="vertical-align: inherit;">Encuentro que la programación en lenguajes que no tienen macros es insoportablemente restrictiva, como si alguien acostumbrado a la tipificación dinámica considerara insoportablemente restrictivo el retorno a los idiomas, donde los tipos deberían describirse para cada variable declarada y es imposible declarar una lista que consta de elementos diferentes tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y no estoy solo. </font><font style="vertical-align: inherit;">Conozco a muchos hackers de Lisp con quienes sucedió algo similar. </font><font style="vertical-align: inherit;">De hecho, la medida más precisa de la fuerza relativa de un lenguaje de programación podría ser la proporción de programadores que conocen un idioma determinado que realizarán cualquier trabajo en el que se deba usar este idioma, independientemente del área temática.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitaciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente, muchos hackers saben lo que se siente cuando el lenguaje parece restrictivo. </font><font style="vertical-align: inherit;">Esta es probablemente la misma sensación que cuando te quedas atascado en un atasco en la calle por el que quieres conducir y tienes que hacer un largo desvío. </font><font style="vertical-align: inherit;">Quiere decir algo y el lenguaje no le permite hacer esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, un lenguaje limitante no es un lenguaje sucinto. </font><font style="vertical-align: inherit;">El problema no es que no puedas expresar algo, sino que el desvío que este lenguaje te obliga a hacer es demasiado largo. </font><font style="vertical-align: inherit;">Haga este experimento mental: desea escribir algún tipo de programa, y ​​el lenguaje no le permite hacerlo de la manera que planeó, sino que lo hace más corto. </font><font style="vertical-align: inherit;">Al menos para mí esto no sería demasiado restrictivo. </font><font style="vertical-align: inherit;">Como si un policía lo dirigiera desde un atasco hacia una carretera más corta en lugar de un desvío largo. </font><font style="vertical-align: inherit;">¡Guauu!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me parece que la sensación de limitación básicamente (¿en un 90 por ciento?) Proviene del hecho de que estás obligado a hacer que el programa sea más largo en el idioma en el que estás escribiendo, en comparación con el idioma en el que piensas. </font><font style="vertical-align: inherit;">La limitación es básicamente una brevedad insuficiente, por lo que cuando un idioma parece ser limitante, significa que no es lo suficientemente corto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legibilidad</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cita con la que comencé también menciona otras dos cualidades: regularidad y legibilidad. </font><font style="vertical-align: inherit;">Realmente no entiendo qué es la regularidad y cuáles son los beneficios del código legible y regular en comparación con el código legible. </font><font style="vertical-align: inherit;">Pero creo que sé lo que se entiende por legibilidad, y también me parece que esto tiene que ver con la brevedad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí debemos tener cuidado con los conceptos de legibilidad de una sola línea de código y la legibilidad del programa en su conjunto. </font><font style="vertical-align: inherit;">Solo lo último es importante. </font><font style="vertical-align: inherit;">Estoy de acuerdo en que una línea en BASIC es más legible que una en Lisp, pero un programa escrito en BASIC tendrá más líneas que el mismo programa escrito en Lisp. </font><font style="vertical-align: inherit;">Leer el programa BASIC requerirá más esfuerzo.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esfuerzo total = esfuerzo para leer una línea * número de líneas</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No estoy tan seguro de que la legibilidad sea proporcional a la brevedad, pero definitivamente la brevedad es un factor en la legibilidad (consulte la fórmula anterior). Por lo tanto, no tiene sentido decir que el propósito del lenguaje es la legibilidad, pero no la brevedad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para un usuario que ve un idioma determinado por primera vez, la legibilidad línea por línea significa que este idioma le parecerá inofensivo. Por lo tanto, la legibilidad línea por línea puede ser una buena decisión de marketing, aunque es una mala decisión de diseño. Es isomorfo con respecto al método de pago a plazos: en lugar de sentirse intimidado por un depósito grande, le ofrece al comprador un pequeño pago mensual. El pago en partes no es rentable para él, así como la legibilidad línea por línea, para el programador. El comprador debe hacer muchos pagos pequeños, así como el programador debe leer muchas líneas legibles por separado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta relación existía incluso antes del advenimiento de los lenguajes de programación. </font><font style="vertical-align: inherit;">Si lee novelas y artículos de periódicos, su primera experiencia leyendo un artículo en matemáticas puede ser aterradora: leer una página lleva media hora. </font><font style="vertical-align: inherit;">Sin embargo, estoy seguro de que el problema no está en la notación, como podría parecer a primera vista. </font><font style="vertical-align: inherit;">Un artículo en matemáticas es difícil de leer porque las ideas en sí mismas son complejas. </font><font style="vertical-align: inherit;">Si expresa las mismas ideas en prosa (como lo hicieron los matemáticos antes de pensar en una breve notación), leerlas no sería más fácil, porque esta sola página se convertiría en un libro completo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En que grado</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos no estaban de acuerdo con la idea de brevedad = fuerza. Creo que, en lugar de discutir si esto es así, sería más útil preguntar en qué medida la brevedad es poder. Porque está claro que la brevedad es uno de los principales propósitos de los lenguajes de programación. Y si no, ¿cuál es su propósito y cuán importantes son esas otras funciones? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Propongo esto para no hacer la discusión más civilizada. Realmente quiero saber la respuesta. ¿Cuándo, si esto sucede, el lenguaje se vuelve lo suficientemente conciso?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La hipótesis con la que comencé fue que, a excepción de algunos casos patológicos, la brevedad es idéntica a la fuerza. </font><font style="vertical-align: inherit;">Quise decir que serán idénticos en cualquier lenguaje desarrollado por alguien, pero si alguien quiere crear un lenguaje específicamente para refutar esta hipótesis, entonces probablemente funcionará. </font><font style="vertical-align: inherit;">Pero tampoco estoy muy seguro de eso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiomas pero no programas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe quedar claro que estamos hablando de la brevedad de los idiomas, no de los programas individuales. Por supuesto, algunos programas se pueden escribir muy estrictamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribí sobre esto en el libro "Acerca de Lisp". Para que la macro se justifique a sí misma, debe ahorrar muchas veces más espacio en relación con su propia longitud. Si alguna macro voluminosa guarda diez líneas de código cada vez que la usa, y la macro en sí misma consta de diez líneas, obtendrá ahorros en líneas si la usa más de dos veces. Pero esto sigue siendo un mal movimiento, ya que las definiciones de macro son más difíciles de leer que el código normal. Es posible que deba usar la macro 10 o 20 veces antes de que mejore la legibilidad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estoy seguro de que en cualquier idioma tales compromisos son posibles (aunque sospecho que las apuestas se plantean en idiomas fuertes). Todos los programadores han visto código que se acorta extremadamente debido a las dudosas técnicas de programación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, es indiscutible, al menos para mí, que los programas pueden ser lo suficientemente concisos. La pregunta es, ¿pueden los idiomas mismos ser cortos? ¿Pueden los lenguajes obligar a los programadores a escribir brevemente (en elementos) a costa de la legibilidad?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una razón por la que es difícil imaginar un lenguaje demasiado conciso es que si hay una forma demasiado compacta de expresar algo, entonces probablemente habrá una forma más larga. Por ejemplo, si le parece que el uso de macros o funciones de alto nivel en Lisp es demasiado denso, puede escribir código que sea isomorfo a Pascal. Si no desea expresar el factorial en el lenguaje de Arc como una llamada a una función de alto nivel, </font></font><br>
<br>
<code>(rec zero 1 * 1-)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
entonces también puede escribir una definición recursiva: </font></font><br>
<br>
<code>(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aunque no puedo dar ejemplos tan inmediatamente, me interesa la pregunta: ¿puede el lenguaje ser demasiado corto? ¿Hay algún idioma que te obligue a escribir código ilegible? Si alguien tiene algún ejemplo, me alegraría verlo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Recuerde: estoy interesado en los programas que tienen una alta densidad de acuerdo con la medida de los "elementos" descritos anteriormente, pero no los programas que son cortos solo porque se pueden omitir los separadores y todo tiene nombres que tienen un solo carácter). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se publicó por primera vez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<hr><br>
<br>
<img src="https://habrastorage.org/webt/nk/j2/oz/nkj2oztxanscb6lhq19l-dfv2z8.jpeg" alt="imagen" align="left"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprenda los detalles de cómo obtener una profesión solicitada desde cero o subir de nivel en habilidades y salario tomando los cursos en línea de SkillFactory:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso de profesión de científico de datos (24 meses) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curso de Analista de Datos Profesionales (18 meses)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso de Python para desarrollo web (9 meses)</font></font></a></li>
</ul> <br>
<br clear="left"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es502916/index.html">Pruebas unitarias para el código RxSwift</a></li>
<li><a href="../es502918/index.html">Error con la directiva #line en el compilador de Visual C ++</a></li>
<li><a href="../es502920/index.html">A medida que probamos el rendimiento de nuevos procesadores en la nube para 1C de acuerdo con la prueba de Gilyov</a></li>
<li><a href="../es502922/index.html">El marketing de multitudes como una herramienta para mejorar la vitalidad del negocio</a></li>
<li><a href="../es502924/index.html">Revisión del teléfono Snom D735 IP</a></li>
<li><a href="../es502928/index.html">Mini-conferencia "Trabajo seguro con servicios en la nube"</a></li>
<li><a href="../es502930/index.html">Azure DevOps y App Center en lugar de granjas de prueba: simplifique y acelere el desarrollo móvil con servicios en la nube</a></li>
<li><a href="../es502932/index.html">Ley de Patrick Mackenzie: la economía del software es más de lo que piensas, incluso dada la ley de Patrick Mackenzie</a></li>
<li><a href="../es502934/index.html">Cómo reducir los costos publicitarios en Yandex.Direct y Google Ads: 9 trucos de vida</a></li>
<li><a href="../es502940/index.html">Cómo no convertir un boletín en spam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>