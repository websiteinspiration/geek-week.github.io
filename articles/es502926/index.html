<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåê üìÅ üëú Paul Graham: Brevedad = Fuerza üçö üå≠ üì™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy en HackerNews planteamos una discusi√≥n sobre el art√≠culo de Paul Graham en 2002 y decidimos resucitar su traducci√≥n de la inexistencia.
 
 
 
 "La...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paul Graham: Brevedad = Fuerza</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/502926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoy en HackerNews planteamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una discusi√≥n sobre el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> art√≠culo de Paul Graham en 2002 y decidimos resucitar su traducci√≥n de la inexistencia.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/643/390/da8643390d5501c1411a3ba972dbe2ac.jpg" alt="imagen"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"La cantidad de significado comprimido en un espacio peque√±o </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
por signos algebraicos, es otra circunstancia que facilita </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
los razonamientos a los que estamos acostumbrados a continuar con su ayuda". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Babbage (1791-1871)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En una discusi√≥n sobre el art√≠culo </font><font style="vertical-align: inherit;">LL1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la lista de correo LL1, Paul Prescod expres√≥ una idea que no se me olvida.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de Python es la regularidad y la legibilidad, pero no la brevedad.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, un lenguaje de programaci√≥n probablemente no deber√≠a pretender serlo. </font><font style="vertical-align: inherit;">Seg√∫n tengo entendido, brevedad (concisi√≥n, concisi√≥n, compacidad) = fuerza. </font><font style="vertical-align: inherit;">Y si es as√≠, haciendo una sustituci√≥n, obtenemos:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de Python es la regularidad y la legibilidad, pero no el poder.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lo cual, a su vez, no es un compromiso muy bueno (si es realmente un compromiso), que vale la pena hacer. </font><font style="vertical-align: inherit;">Parece que si dices: el objetivo del lenguaje Python no es ser un lenguaje de programaci√≥n efectivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øBrevedad = fuerza? </font><font style="vertical-align: inherit;">Esta parece una pregunta importante, tal vez la pregunta m√°s importante para aquellos involucrados en el desarrollo de idiomas. </font><font style="vertical-align: inherit;">Todav√≠a no estoy seguro de que la respuesta sea simplemente "s√≠", pero para empezar, esta es una buena hip√≥tesis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hip√≥tesis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi hip√≥tesis es que la brevedad es poder, o est√°n tan cerca que, con la excepci√≥n de los casos patol√≥gicos, puede tomarlos por algo id√©ntico.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La brevedad, me parece, es para lo que se crean los lenguajes de programaci√≥n. Las computadoras ser√≠an igualmente felices si recibieran instrucciones directamente en lenguaje de m√°quina. Creo que la raz√≥n principal por la que vamos a desarrollar lenguajes de alto nivel es para obtener la ventaja de expresar (y m√°s importante, pensar) diez l√≠neas en un lenguaje de alto nivel, lo que requerir√≠a 1000 l√≠neas de c√≥digo de m√°quina. En otras palabras, el objetivo principal de los lenguajes de alto nivel es acortar el c√≥digo fuente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el c√≥digo fuente m√°s corto es el prop√≥sito de los lenguajes de alto nivel, y la fuerza de algo es una medida de qu√© tan bien se logra el objetivo, entonces la fuerza del lenguaje de programaci√≥n es cu√°nto reduce sus programas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por el contrario, un lenguaje que no hace que sus programas sean m√°s peque√±os hace un mal trabajo de un lenguaje de programaci√≥n, al igual que un cuchillo que corta mal o una impresi√≥n ilegible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©trica</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øY en qu√© sentido es menos? </font><font style="vertical-align: inherit;">La medida m√°s com√∫n del tama√±o del c√≥digo fuente es el n√∫mero de l√≠neas. </font><font style="vertical-align: inherit;">Pero esta medida es com√∫n solo por la simplicidad de la medici√≥n, y no creo que nadie crea que es una buena prueba del tama√±o del programa. </font><font style="vertical-align: inherit;">Los idiomas tienen diferentes convenciones sobre lo que se puede colocar en una l√≠nea; </font><font style="vertical-align: inherit;">bastantes l√≠neas en C pueden tener solo uno o dos separadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra prueba simple es el n√∫mero de caracteres en el programa, pero este no es demasiado bueno; </font><font style="vertical-align: inherit;">Algunos idiomas (como Perl) tienen identificadores m√°s cortos que otros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que la mejor medida del tama√±o de un programa puede ser el n√∫mero de elementos, donde el elemento es algo que podr√≠a convertirse en un v√©rtice separado en el √°rbol de origen. El nombre de una variable o funci√≥n es un elemento; un n√∫mero entero o un n√∫mero real es un elemento; un segmento literal de texto es un elemento; un elemento de una directiva de patr√≥n o formato es un elemento. Hay casos l√≠mite (¬øes "-5" uno o dos elementos?), Pero creo que la mayor√≠a de ellos son iguales en todos los idiomas, por lo que no afectar√°n demasiado la comparaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta medida debe concretarse, y puede requerir interpretaci√≥n adicional en el caso de algunos lenguajes espec√≠ficos, pero me parece que est√° tratando de medir lo correcto: el n√∫mero de partes del programa. </font><font style="vertical-align: inherit;">El √°rbol de origen es lo que dibuja en su mente para representar el programa y, por lo tanto, el tama√±o de este √°rbol es proporcional a la cantidad de trabajo necesario para escribirlo o leerlo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dise√±o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta medida nos permitir√≠a comparar diferentes idiomas, pero este no es, al menos para m√≠, su valor b√°sico. Y el valor de la prueba de brevedad es una gu√≠a para dise√±ar idiomas. La comparaci√≥n de idiomas m√°s √∫til es comparar dos variaciones posibles del mismo idioma. ¬øQu√© puedo hacer en el idioma para acortar los programas? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la carga conceptual de un programa es proporcional a su complejidad, y un programador determinado puede soportar una cierta carga conceptual, entonces esto es lo mismo que preguntar: ¬øc√≥mo pueden ayudar los programadores a hacer m√°s? Y esto, me parece, es lo mismo que preguntar: ¬øc√≥mo dise√±ar un buen lenguaje?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Por cierto, la falsedad de este ya barbudo dicho "todos los idiomas son equivalentes" se ve m√°s claramente cuando se dise√±an idiomas. Cuando creas un nuevo idioma, constantemente comparas dos idiomas, uno en el que har√≠a X, y el otro en el que no, para que decida qu√© es mejor. Si fuera una pregunta sin sentido, podr√≠a lanzar una moneda.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tener un objetivo de brevedad parece ser una buena manera de encontrar nuevas ideas. </font><font style="vertical-align: inherit;">Si encuentra una manera de acortar los programas, esto no es una coincidencia: probablemente haya encontrado una nueva abstracci√≥n √∫til. </font><font style="vertical-align: inherit;">Incluso podr√≠a escribir un programa que obtenga fragmentos repetidos en el c√≥digo fuente. </font><font style="vertical-align: inherit;">Se pueden encontrar nuevas ideas entre los idiomas que tienen fama de ser concisos: Forth, Joy, Icon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero en escribir sobre estas cosas fue, hasta donde yo s√©, Fred Brooks con su libro Mythical Man-Month. Escribi√≥ que los programadores generan la misma cantidad de c√≥digo independientemente del idioma. Cuando lo le√≠ por primera vez a los 20 a√±os, fue una gran sorpresa, y me pareci√≥ que esto ten√≠a enormes consecuencias. Esto significa que (a) la √∫nica forma de escribir programas m√°s r√°pido es usar un lenguaje m√°s corto, y (b) el que se haya molestado en hacer esto preguntar√° a los competidores que no lo hacen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conjetura de Brooks, si es cierta, puede ser la esencia misma de la pirater√≠a. Desde entonces, a lo largo de los a√±os, he prestado atenci√≥n a todo lo que ser√≠a relevante para el tema: desde estudios te√≥ricos hasta historias sobre proyectos individuales. No vi nada que contradiga esta hip√≥tesis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero no he visto ninguna evidencia clara, y no espero verlas. Estudios como la comparaci√≥n de los lenguajes de programaci√≥n Lutz Prekelt, aunque producen los resultados esperados, tienden a utilizar tareas que son demasiado peque√±as para una prueba significativa. La mejor prueba para un idioma es lo que sucede en los programas escritos en un mes. Y si est√° convencido, como yo, de que el objetivo principal de los idiomas es ser un buen idioma en el que piensan (en lugar de un idioma en el que dan instrucciones a la computadora despu√©s de que lo piense), entonces la prueba real para el idioma es ¬øQu√© novedades puedes escribir sobre √©l? Por lo tanto, comparar idiomas basados ‚Äã‚Äãen una especificaci√≥n predefinida es algo incorrecto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La verdadera prueba para el idioma es qu√© tan bien puede encontrar y resolver nuevos problemas en √©l, pero no las tareas formuladas por otra persona. Estos son criterios diferentes. En el arte, las herramientas como el bordado y el mosaico funcionan bien si sabe de antemano lo que desea obtener, pero absolutamente indecente si no lo sabe. Si desea revelar una imagen en el proceso de escribir una imagen (lo que debe hacer al revelar cosas tan complejas como, por ejemplo, la imagen de una persona), debe usar una herramienta m√°s flexible como l√°piz, tinta o pinturas al √≥leo. Por supuesto, los tapices y los mosaicos se hacen as√≠: primero se crea una imagen, y luego solo se copia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que es poco probable que tengamos una comparaci√≥n adecuada de la fuerza relativa de los lenguajes de programaci√≥n. Tendremos comparaciones exactas, pero no correctas. En particular, es probable que los estudios dirigidos expl√≠citamente a las comparaciones de idiomas usen tareas peque√±as y necesariamente usar√°n un conjunto predefinido de tareas, y por lo tanto tender√°n a subestimar los idiomas m√°s poderosos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es probable que los informes en esta √°rea, aunque ser√°n menos precisos que los estudios "cient√≠ficos", sean m√°s significativos. Por ejemplo, Ulf Wieger de Ericsson realiz√≥ un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estudio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y lleg√≥ a la conclusi√≥n de que Erlang es 4-10 veces m√°s corto que C ++, y que la velocidad de desarrollo de software es proporcionalmente mayor:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La comparaci√≥n de proyectos internos en Ericsson revela una productividad similar en l√≠neas de c√≥digo por hora, incluidas todas las fases de desarrollo, independientemente del lenguaje utilizado (Erlang, PLEX, C, C ++ o Java). </font><font style="vertical-align: inherit;">Diferencias de idioma: solo en la cantidad total de c√≥digo fuente.</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este estudio tambi√©n indica claramente que no aparece en el libro de Brooks (ya que solo midi√≥ l√≠neas de c√≥digo depurado): los programas escritos en lenguajes m√°s potentes tienden a contener menos errores. </font><font style="vertical-align: inherit;">Esto ya es suficiente, y probablemente en tareas como los conmutadores de red, esto es m√°s importante que el rendimiento del programador.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sabores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, puedes confiar en tu instinto. ¬øQu√© es la programaci√≥n en este lenguaje? Creo que para crear un mejor lenguaje deber√≠as volverse hipersensible a lo bien que el lenguaje te permite pensar en √©l, y luego elegir o desarrollar un lenguaje que te parezca m√°s adecuado. Si alguna propiedad del idioma es inconveniente o restrictiva, no se preocupe, lo sabr√°.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero tal hipersensibilidad har√° que los lenguajes torpes se vuelvan insoportables para usted. </font><font style="vertical-align: inherit;">Encuentro que la programaci√≥n en lenguajes que no tienen macros es insoportablemente restrictiva, como si alguien acostumbrado a la tipificaci√≥n din√°mica considerara insoportablemente restrictivo el retorno a los idiomas, donde los tipos deber√≠an describirse para cada variable declarada y es imposible declarar una lista que consta de elementos diferentes tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y no estoy solo. </font><font style="vertical-align: inherit;">Conozco a muchos hackers de Lisp con quienes sucedi√≥ algo similar. </font><font style="vertical-align: inherit;">De hecho, la medida m√°s precisa de la fuerza relativa de un lenguaje de programaci√≥n podr√≠a ser la proporci√≥n de programadores que conocen un idioma determinado que realizar√°n cualquier trabajo en el que se deba usar este idioma, independientemente del √°rea tem√°tica.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitaciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente, muchos hackers saben lo que se siente cuando el lenguaje parece restrictivo. </font><font style="vertical-align: inherit;">Esta es probablemente la misma sensaci√≥n que cuando te quedas atascado en un atasco en la calle por el que quieres conducir y tienes que hacer un largo desv√≠o. </font><font style="vertical-align: inherit;">Quiere decir algo y el lenguaje no le permite hacer esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, un lenguaje limitante no es un lenguaje sucinto. </font><font style="vertical-align: inherit;">El problema no es que no puedas expresar algo, sino que el desv√≠o que este lenguaje te obliga a hacer es demasiado largo. </font><font style="vertical-align: inherit;">Haga este experimento mental: desea escribir alg√∫n tipo de programa, y ‚Äã‚Äãel lenguaje no le permite hacerlo de la manera que plane√≥, sino que lo hace m√°s corto. </font><font style="vertical-align: inherit;">Al menos para m√≠ esto no ser√≠a demasiado restrictivo. </font><font style="vertical-align: inherit;">Como si un polic√≠a lo dirigiera desde un atasco hacia una carretera m√°s corta en lugar de un desv√≠o largo. </font><font style="vertical-align: inherit;">¬°Guauu!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me parece que la sensaci√≥n de limitaci√≥n b√°sicamente (¬øen un 90 por ciento?) Proviene del hecho de que est√°s obligado a hacer que el programa sea m√°s largo en el idioma en el que est√°s escribiendo, en comparaci√≥n con el idioma en el que piensas. </font><font style="vertical-align: inherit;">La limitaci√≥n es b√°sicamente una brevedad insuficiente, por lo que cuando un idioma parece ser limitante, significa que no es lo suficientemente corto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legibilidad</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cita con la que comenc√© tambi√©n menciona otras dos cualidades: regularidad y legibilidad. </font><font style="vertical-align: inherit;">Realmente no entiendo qu√© es la regularidad y cu√°les son los beneficios del c√≥digo legible y regular en comparaci√≥n con el c√≥digo legible. </font><font style="vertical-align: inherit;">Pero creo que s√© lo que se entiende por legibilidad, y tambi√©n me parece que esto tiene que ver con la brevedad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ debemos tener cuidado con los conceptos de legibilidad de una sola l√≠nea de c√≥digo y la legibilidad del programa en su conjunto. </font><font style="vertical-align: inherit;">Solo lo √∫ltimo es importante. </font><font style="vertical-align: inherit;">Estoy de acuerdo en que una l√≠nea en BASIC es m√°s legible que una en Lisp, pero un programa escrito en BASIC tendr√° m√°s l√≠neas que el mismo programa escrito en Lisp. </font><font style="vertical-align: inherit;">Leer el programa BASIC requerir√° m√°s esfuerzo.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esfuerzo total = esfuerzo para leer una l√≠nea * n√∫mero de l√≠neas</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No estoy tan seguro de que la legibilidad sea proporcional a la brevedad, pero definitivamente la brevedad es un factor en la legibilidad (consulte la f√≥rmula anterior). Por lo tanto, no tiene sentido decir que el prop√≥sito del lenguaje es la legibilidad, pero no la brevedad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para un usuario que ve un idioma determinado por primera vez, la legibilidad l√≠nea por l√≠nea significa que este idioma le parecer√° inofensivo. Por lo tanto, la legibilidad l√≠nea por l√≠nea puede ser una buena decisi√≥n de marketing, aunque es una mala decisi√≥n de dise√±o. Es isomorfo con respecto al m√©todo de pago a plazos: en lugar de sentirse intimidado por un dep√≥sito grande, le ofrece al comprador un peque√±o pago mensual. El pago en partes no es rentable para √©l, as√≠ como la legibilidad l√≠nea por l√≠nea, para el programador. El comprador debe hacer muchos pagos peque√±os, as√≠ como el programador debe leer muchas l√≠neas legibles por separado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta relaci√≥n exist√≠a incluso antes del advenimiento de los lenguajes de programaci√≥n. </font><font style="vertical-align: inherit;">Si lee novelas y art√≠culos de peri√≥dicos, su primera experiencia leyendo un art√≠culo en matem√°ticas puede ser aterradora: leer una p√°gina lleva media hora. </font><font style="vertical-align: inherit;">Sin embargo, estoy seguro de que el problema no est√° en la notaci√≥n, como podr√≠a parecer a primera vista. </font><font style="vertical-align: inherit;">Un art√≠culo en matem√°ticas es dif√≠cil de leer porque las ideas en s√≠ mismas son complejas. </font><font style="vertical-align: inherit;">Si expresa las mismas ideas en prosa (como lo hicieron los matem√°ticos antes de pensar en una breve notaci√≥n), leerlas no ser√≠a m√°s f√°cil, porque esta sola p√°gina se convertir√≠a en un libro completo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En que grado</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos no estaban de acuerdo con la idea de brevedad = fuerza. Creo que, en lugar de discutir si esto es as√≠, ser√≠a m√°s √∫til preguntar en qu√© medida la brevedad es poder. Porque est√° claro que la brevedad es uno de los principales prop√≥sitos de los lenguajes de programaci√≥n. Y si no, ¬øcu√°l es su prop√≥sito y cu√°n importantes son esas otras funciones? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Propongo esto para no hacer la discusi√≥n m√°s civilizada. Realmente quiero saber la respuesta. ¬øCu√°ndo, si esto sucede, el lenguaje se vuelve lo suficientemente conciso?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La hip√≥tesis con la que comenc√© fue que, a excepci√≥n de algunos casos patol√≥gicos, la brevedad es id√©ntica a la fuerza. </font><font style="vertical-align: inherit;">Quise decir que ser√°n id√©nticos en cualquier lenguaje desarrollado por alguien, pero si alguien quiere crear un lenguaje espec√≠ficamente para refutar esta hip√≥tesis, entonces probablemente funcionar√°. </font><font style="vertical-align: inherit;">Pero tampoco estoy muy seguro de eso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiomas pero no programas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe quedar claro que estamos hablando de la brevedad de los idiomas, no de los programas individuales. Por supuesto, algunos programas se pueden escribir muy estrictamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escrib√≠ sobre esto en el libro "Acerca de Lisp". Para que la macro se justifique a s√≠ misma, debe ahorrar muchas veces m√°s espacio en relaci√≥n con su propia longitud. Si alguna macro voluminosa guarda diez l√≠neas de c√≥digo cada vez que la usa, y la macro en s√≠ misma consta de diez l√≠neas, obtendr√° ahorros en l√≠neas si la usa m√°s de dos veces. Pero esto sigue siendo un mal movimiento, ya que las definiciones de macro son m√°s dif√≠ciles de leer que el c√≥digo normal. Es posible que deba usar la macro 10 o 20 veces antes de que mejore la legibilidad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estoy seguro de que en cualquier idioma tales compromisos son posibles (aunque sospecho que las apuestas se plantean en idiomas fuertes). Todos los programadores han visto c√≥digo que se acorta extremadamente debido a las dudosas t√©cnicas de programaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, es indiscutible, al menos para m√≠, que los programas pueden ser lo suficientemente concisos. La pregunta es, ¬øpueden los idiomas mismos ser cortos? ¬øPueden los lenguajes obligar a los programadores a escribir brevemente (en elementos) a costa de la legibilidad?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una raz√≥n por la que es dif√≠cil imaginar un lenguaje demasiado conciso es que si hay una forma demasiado compacta de expresar algo, entonces probablemente habr√° una forma m√°s larga. Por ejemplo, si le parece que el uso de macros o funciones de alto nivel en Lisp es demasiado denso, puede escribir c√≥digo que sea isomorfo a Pascal. Si no desea expresar el factorial en el lenguaje de Arc como una llamada a una funci√≥n de alto nivel, </font></font><br>
<br>
<code>(rec zero 1 * 1-)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
entonces tambi√©n puede escribir una definici√≥n recursiva: </font></font><br>
<br>
<code>(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aunque no puedo dar ejemplos tan inmediatamente, me interesa la pregunta: ¬øpuede el lenguaje ser demasiado corto? ¬øHay alg√∫n idioma que te obligue a escribir c√≥digo ilegible? Si alguien tiene alg√∫n ejemplo, me alegrar√≠a verlo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Recuerde: estoy interesado en los programas que tienen una alta densidad de acuerdo con la medida de los "elementos" descritos anteriormente, pero no los programas que son cortos solo porque se pueden omitir los separadores y todo tiene nombres que tienen un solo car√°cter). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se public√≥ por primera vez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<hr><br>
<br>
<img src="https://habrastorage.org/webt/nk/j2/oz/nkj2oztxanscb6lhq19l-dfv2z8.jpeg" alt="imagen" align="left"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprenda los detalles de c√≥mo obtener una profesi√≥n solicitada desde cero o subir de nivel en habilidades y salario tomando los cursos en l√≠nea de SkillFactory:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso de profesi√≥n de cient√≠fico de datos (24 meses) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curso de Analista de Datos Profesionales (18 meses)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso de Python para desarrollo web (9 meses)</font></font></a></li>
</ul> <br>
<br clear="left"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es502916/index.html">Pruebas unitarias para el c√≥digo RxSwift</a></li>
<li><a href="../es502918/index.html">Error con la directiva #line en el compilador de Visual C ++</a></li>
<li><a href="../es502920/index.html">A medida que probamos el rendimiento de nuevos procesadores en la nube para 1C de acuerdo con la prueba de Gilyov</a></li>
<li><a href="../es502922/index.html">El marketing de multitudes como una herramienta para mejorar la vitalidad del negocio</a></li>
<li><a href="../es502924/index.html">Revisi√≥n del tel√©fono Snom D735 IP</a></li>
<li><a href="../es502928/index.html">Mini-conferencia "Trabajo seguro con servicios en la nube"</a></li>
<li><a href="../es502930/index.html">Azure DevOps y App Center en lugar de granjas de prueba: simplifique y acelere el desarrollo m√≥vil con servicios en la nube</a></li>
<li><a href="../es502932/index.html">Ley de Patrick Mackenzie: la econom√≠a del software es m√°s de lo que piensas, incluso dada la ley de Patrick Mackenzie</a></li>
<li><a href="../es502934/index.html">C√≥mo reducir los costos publicitarios en Yandex.Direct y Google Ads: 9 trucos de vida</a></li>
<li><a href="../es502940/index.html">C√≥mo no convertir un bolet√≠n en spam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>