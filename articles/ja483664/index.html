<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏽 👵 🤱 TensorFlowのKeras機能API 💕 ❇️ 🔐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kerasには、ニューラルネットワークアーキテクチャであるSequentialおよびFunctionalを迅速に構築するための2つのAPIがあります。前者でニューラルネットワークの順次アーキテクチャのみを構築できる場合は、Functional APIを使用して、任意の有向非循環グラフの形式でニューラ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>TensorFlowのKeras機能API</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483664/"><img src="https://habrastorage.org/webt/w1/zr/n8/w1zrn8ydafoxahso_ig7vx1stfg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerasには、ニューラルネットワークアーキテクチャであるSequentialおよびFunctionalを迅速に構築するための2つのAPIがあります。</font><font style="vertical-align: inherit;">前者でニューラルネットワークの順次アーキテクチャのみを構築できる場合は、Functional APIを使用して、任意の有向非循環グラフの形式でニューラルネットワークを定義できます。これにより、複雑なモデルを構築する機会が大幅に増えます。</font><font style="vertical-align: inherit;">この記事は、TensorFlowウェブサイトの機能API機能ガイドを翻訳したものです。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型APIを使用すると、シーケンシャルAPIよりも柔軟にモデルを作成できます。これは、非線形トポロジのモデル、共通のレイヤーを持つモデル、複数の入力または出力を持つモデルを処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディープラーニングモデルは通常、層の有向非循環グラフ（DAG）であるという事実に基づいてい</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">機能APIは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">層のグラフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">作成する</font></b><font style="vertical-align: inherit;">ためのツールのセットです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のモデルを考えてみましょう：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（入力：784次元ベクトル）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ↧ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[高密度層（64要素、reluアクティベーション）] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ↧ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[高密度層（64要素、reluアクティベーション）] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ↧ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[高密度層（10要素、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 softmax </font><font style="vertical-align: inherit;">アクティベーション）] </font><font style="vertical-align: inherit;">↧ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（出力：確率分布10クラス）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは3つのレイヤーの単純なグラフです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functional APIを使用してこのモデルを構築するには、まず入力ノードを作成する必要があります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<font></font>
<font></font>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、データの次元を示しています。784次元のベクトルです。</font><font style="vertical-align: inherit;">データの量は常に省略されていることに注意してください。各要素の次元のみを示しています。</font><font style="vertical-align: inherit;">画像用の画像サイズ `（32、32、3）`を入力するには、次のようにします。</font></font><br>
<br>
<pre><code class="python hljs">img_inputs = keras.Input(shape=(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返されるものには</font></font><code>inputs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モデルに転送する予定のデータのサイズとタイプに関する情報</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">含まれています。</font></font><br>
<br>
<pre><code class="python hljs">inputs.shape</code></pre><br>
<pre><code class="python hljs">TensorShape([<span class="hljs-literal">None</span>, <span class="hljs-number">784</span>])</code></pre><br>
<pre><code class="python hljs">inputs.dtype</code></pre><br>
<pre><code class="python hljs">tf.float32</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオブジェクトのレイヤーを呼び出して、レイヤーグラフに新しいノードを作成します</font></font><code>inputs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers<font></font>
<font></font>
dense = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>)<font></font>
x = dense(inputs)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「レイヤーの呼び出し」は、「入力」から作成したレイヤーに矢印を描くのと同じです。</font><font style="vertical-align: inherit;">入力を</font></font><code>dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤーに</font><font style="vertical-align: inherit;">「渡す」</font><font style="vertical-align: inherit;">と、を受け取り</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイヤーグラフにいくつかのレイヤーを追加してみましょう。</font></font><br>
<br>
<pre><code class="python hljs">x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>)(x)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、レイヤーグラフで入力と出力を指定して</font><font style="vertical-align: inherit;">作成できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">model = keras.Model(inputs=inputs, outputs=outputs)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルを決定するプロセス全体をもう一度見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'img'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>)(inputs)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs=inputs, outputs=outputs, name=<span class="hljs-string">'mnist_model'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルの要約がどのようになるか見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs">model.summary()</code></pre><br>
<pre><code class="python hljs">Model: <span class="hljs-string">"mnist_model"</span><font></font>
_________________________________________________________________<font></font>
Layer (type)                 Output Shape              Param <span class="hljs-comment">#   </span><font></font>
=================================================================<font></font>
img (InputLayer)             [(<span class="hljs-literal">None</span>, <span class="hljs-number">784</span>)]             <span class="hljs-number">0</span>         <font></font>
_________________________________________________________________<font></font>
dense_3 (Dense)              (<span class="hljs-literal">None</span>, <span class="hljs-number">64</span>)                <span class="hljs-number">50240</span>     <font></font>
_________________________________________________________________<font></font>
dense_4 (Dense)              (<span class="hljs-literal">None</span>, <span class="hljs-number">64</span>)                <span class="hljs-number">4160</span>      <font></font>
_________________________________________________________________<font></font>
dense_5 (Dense)              (<span class="hljs-literal">None</span>, <span class="hljs-number">10</span>)                <span class="hljs-number">650</span>       <font></font>
=================================================================<font></font>
Total params: <span class="hljs-number">55</span>,<span class="hljs-number">050</span>
Trainable params: <span class="hljs-number">55</span>,<span class="hljs-number">050</span>
Non-trainable params: <span class="hljs-number">0</span>
_________________________________________________________________</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルをグラフとして描くこともできます：</font></font><br>
<br>
<pre><code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string">'my_first_model.png'</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/oq/4o/vl/oq4ovlxewr3hxczaldchmbeyfua.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてオプションで、構築されたグラフ上の各レイヤーの入力と出力の次元を導き出します：</font></font><br>
<br>
<pre><code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string">'my_first_model_with_shape_info.png'</span>, show_shapes=<span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/fn/rm/hc/fnrmhcqknnsjdcgmqp9w6dpong8.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この画像と私たちが書いたコードは同じです。</font><font style="vertical-align: inherit;">コードバージョンでは、バインド矢印は単に呼び出し操作に置き換えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「レイヤーグラフ」はディープラーニングモデルの非常に直感的なメンタルイメージであり、Functional APIはこのメンタルイメージを密接に反映するモデルを作成する方法です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニング、評価、結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンシャルモデルと同様に、Functional APIを使用して構築されたモデルのトレーニング、評価、および推論作業。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単なデモを検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、MNIST画像データセットを読み込み、ベクターに変換し、データでモデルをトレーニングし（テストサンプルの作業品質を監視しながら）、最後にテストデータでモデルを評価します。</font></font><br>
<br>
<pre><code class="python hljs">(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()<font></font>
x_train = x_train.reshape(<span class="hljs-number">60000</span>, <span class="hljs-number">784</span>).astype(<span class="hljs-string">'float32'</span>) / <span class="hljs-number">255</span>
x_test = x_test.reshape(<span class="hljs-number">10000</span>, <span class="hljs-number">784</span>).astype(<span class="hljs-string">'float32'</span>) / <span class="hljs-number">255</span><font></font>
<font></font>
model.compile(loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,<font></font>
              optimizer=keras.optimizers.RMSprop(),<font></font>
              metrics=[<span class="hljs-string">'accuracy'</span>])<font></font>
history = model.fit(x_train, y_train,<font></font>
                    batch_size=<span class="hljs-number">64</span>,<font></font>
                    epochs=<span class="hljs-number">5</span>,<font></font>
                    validation_split=<span class="hljs-number">0.2</span>)<font></font>
test_scores = model.evaluate(x_test, y_test, verbose=<span class="hljs-number">2</span>)<font></font>
print(<span class="hljs-string">'Test loss:'</span>, test_scores[<span class="hljs-number">0</span>])<font></font>
print(<span class="hljs-string">'Test accuracy:'</span>, test_scores[<span class="hljs-number">1</span>]) </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存とシリアライズ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型APIを使用して構築されたモデルの保存とシリアル化は、シーケンシャルモデルの場合とまったく同じように機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能モデルを保存する標準的な方法は、</font></font><code>model.save(</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を呼び出す</font><font style="vertical-align: inherit;">ことです。これにより、モデル全体を1つのファイルに保存できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルを作成したコードにアクセスできなくなった場合でも、後でこのファイルから同じモデルを復元できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このファイルに含まれるもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルのアーキテクチャ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの重みの値（トレーニング中に取得された）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルトレーニング構成（渡したもの</font></font><code>compile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプティマイザーとその条件（ある場合）（これにより、中断したところからトレーニングを再開できます）</font></font></li>
</ul><br>
<pre><code class="python hljs">
model.save(<span class="hljs-string">'path_to_my_model.h5'</span>)
<span class="hljs-keyword">del</span> model
<span class="hljs-comment"># Recreate the exact same model purely from the file:</span>
model = keras.models.load_model(<span class="hljs-string">'path_to_my_model.h5'</span>)
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じレイヤーグラフを使用して複数のモデルを定義する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型APIでは、モデルは層グラフで入力データと出力データを指定することによって作成されます。</font><font style="vertical-align: inherit;">つまり、単一の層グラフを使用して複数のモデルを生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の例では、同じレイヤースタックを使用して2つのモデルを作成します。</font><font style="vertical-align: inherit;">入力画像を16次元ベクトルに変換</font><font style="vertical-align: inherit;">する</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデル</font></font><code> (encoder)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、</font></font><code> (autoencoder) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニング用の</font><font style="vertical-align: inherit;">エンドツーエンドモデル</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="python hljs">encoder_input = keras.Input(shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>), name=<span class="hljs-string">'img'</span>)<font></font>
x = layers.Conv2D(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(encoder_input)<font></font>
x = layers.Conv2D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.MaxPooling2D(<span class="hljs-number">3</span>)(x)<font></font>
x = layers.Conv2D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.Conv2D(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
encoder_output = layers.GlobalMaxPooling2D()(x)<font></font>
<font></font>
encoder = keras.Model(encoder_input, encoder_output, name=<span class="hljs-string">'encoder'</span>)<font></font>
encoder.summary()<font></font>
<font></font>
x = layers.Reshape((<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>))(encoder_output)<font></font>
x = layers.Conv2DTranspose(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.Conv2DTranspose(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.UpSampling2D(<span class="hljs-number">3</span>)(x)<font></font>
x = layers.Conv2DTranspose(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
decoder_output = layers.Conv2DTranspose(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
<font></font>
autoencoder = keras.Model(encoder_input, decoder_output, name=<span class="hljs-string">'autoencoder'</span>)<font></font>
autoencoder.summary()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デコードアーキテクチャをエンコードアーキテクチャと厳密に対称にして、出力データの次元を入力データと同じにすることに注意してください</font></font><code>(28, 28, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">レイヤー</font></font><code>Conv2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">レイヤー</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">逆であり、</font><font style="vertical-align: inherit;">レイヤー</font></font><code>Conv2DTranspose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はレイヤー</font></font><code>MaxPooling2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">逆になり</font></font><code>UpSampling2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルはレイヤーとして呼び出すことができます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任意のモデルをレイヤーである</font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かの</font><font style="vertical-align: inherit;">ように</font><font style="vertical-align: inherit;">使用し、別のレイヤーの出力</font><font style="vertical-align: inherit;">上</font><font style="vertical-align: inherit;">または出力で</font><font style="vertical-align: inherit;">呼び出すことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルを呼び出すことにより、そのアーキテクチャを再利用するだけでなく、その重みも再利用することに注意してください。</font><font style="vertical-align: inherit;">実際に見てみましょう。</font><font style="vertical-align: inherit;">次に、自動エンコーダーの例をもう1つ示します。エンコーダーモデル、デコーダーモデルが作成され、それらが2つの呼び出しで接続されて自動エンコーダーモデルが取得されます。</font></font><br>
<br>
<pre><code class="python hljs">encoder_input = keras.Input(shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>), name=<span class="hljs-string">'original_img'</span>)<font></font>
x = layers.Conv2D(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(encoder_input)<font></font>
x = layers.Conv2D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.MaxPooling2D(<span class="hljs-number">3</span>)(x)<font></font>
x = layers.Conv2D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.Conv2D(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
encoder_output = layers.GlobalMaxPooling2D()(x)<font></font>
<font></font>
encoder = keras.Model(encoder_input, encoder_output, name=<span class="hljs-string">'encoder'</span>)<font></font>
encoder.summary()<font></font>
<font></font>
decoder_input = keras.Input(shape=(<span class="hljs-number">16</span>,), name=<span class="hljs-string">'encoded_img'</span>)<font></font>
x = layers.Reshape((<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>))(decoder_input)<font></font>
x = layers.Conv2DTranspose(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.Conv2DTranspose(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.UpSampling2D(<span class="hljs-number">3</span>)(x)<font></font>
x = layers.Conv2DTranspose(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
decoder_output = layers.Conv2DTranspose(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
<font></font>
decoder = keras.Model(decoder_input, decoder_output, name=<span class="hljs-string">'decoder'</span>)<font></font>
decoder.summary()<font></font>
<font></font>
autoencoder_input = keras.Input(shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>), name=<span class="hljs-string">'img'</span>)<font></font>
encoded_img = encoder(autoencoder_input)<font></font>
decoded_img = decoder(encoded_img)<font></font>
autoencoder = keras.Model(autoencoder_input, decoded_img, name=<span class="hljs-string">'autoencoder'</span>)<font></font>
autoencoder.summary()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、モデルはネストできます。モデルはサブモデルを含むことができます（モデルはレイヤーと見なすことができるため）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネスティングモデルの一般的なユースケースは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensmbling</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、モデルのセットを、予測を平均化する1つのモデルに組み合わせる方法を次に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_model</span>():</span>
  inputs = keras.Input(shape=(<span class="hljs-number">128</span>,))<font></font>
  outputs = layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'sigmoid'</span>)(inputs)
  <span class="hljs-keyword">return</span> keras.Model(inputs, outputs)<font></font>
<font></font>
model1 = get_model()<font></font>
model2 = get_model()<font></font>
model3 = get_model()<font></font>
<font></font>
inputs = keras.Input(shape=(<span class="hljs-number">128</span>,))<font></font>
y1 = model1(inputs)<font></font>
y2 = model2(inputs)<font></font>
y3 = model3(inputs)<font></font>
outputs = layers.average([y1, y2, y3])<font></font>
ensemble_model = keras.Model(inputs=inputs, outputs=outputs)</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なグラフトポロジの操作</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数の入力と出力を備えたモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能APIは、複数の入力と出力の操作を簡素化します。</font><font style="vertical-align: inherit;">これは、シーケンシャルAPIでは実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは簡単な例です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顧客のアプリケーションを優先順位でランク付けして適切な部門に送信するシステムを作成するとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルには3つの入力があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションヘッダー（テキスト入力）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのテキストコンテンツ（テキスト入力）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーが追加したタグ（カテゴリ入力）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルには2つの出力があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0から1までの優先順位スコア（スカラーS字型出力）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションを処理する必要がある部門（多くの部門に関するsoftmax出力）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functional APIを使用して、数行でモデルを作成してみましょう。</font></font><br>
<br>
<pre><code class="python hljs">num_tags = <span class="hljs-number">12</span>  <span class="hljs-comment">#    </span>
num_words = <span class="hljs-number">10000</span>  <span class="hljs-comment">#        </span>
num_departments = <span class="hljs-number">4</span>  <span class="hljs-comment">#    </span><font></font>
<font></font>
title_input = keras.Input(shape=(<span class="hljs-literal">None</span>,), name=<span class="hljs-string">'title'</span>)  <span class="hljs-comment">#     </span>
body_input = keras.Input(shape=(<span class="hljs-literal">None</span>,), name=<span class="hljs-string">'body'</span>)  <span class="hljs-comment">#     </span>
tags_input = keras.Input(shape=(num_tags,), name=<span class="hljs-string">'tags'</span>)  <span class="hljs-comment">#    `num_tags`</span><font></font>
<font></font>
<span class="hljs-comment">#      64- </span>
title_features = layers.Embedding(num_words, <span class="hljs-number">64</span>)(title_input)
<span class="hljs-comment">#      64- </span>
body_features = layers.Embedding(num_words, <span class="hljs-number">64</span>)(body_input)<font></font>
<font></font>
<span class="hljs-comment">#        128- </span>
title_features = layers.LSTM(<span class="hljs-number">128</span>)(title_features)
<span class="hljs-comment">#        32- </span>
body_features = layers.LSTM(<span class="hljs-number">32</span>)(body_features)<font></font>
<font></font>
<span class="hljs-comment">#         </span><font></font>
x = layers.concatenate([title_features, body_features, tags_input])<font></font>
<font></font>
<span class="hljs-comment">#        </span>
priority_pred = layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'sigmoid'</span>, name=<span class="hljs-string">'priority'</span>)(x)
<span class="hljs-comment">#      </span>
department_pred = layers.Dense(num_departments, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'department'</span>)(x)<font></font>
<font></font>
<span class="hljs-comment">#   ,    </span><font></font>
model = keras.Model(inputs=[title_input, body_input, tags_input],<font></font>
                    outputs=[priority_pred, department_pred])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルグラフを描きましょう：</font></font><br>
<br>
<pre><code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string">'multi_input_and_output_model.png'</span>, show_shapes=<span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/gc/hk/uw/gchkuwc_zgefnaf4tx0ercck8bc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルをコンパイルするとき、各出力に異なる損失関数を割り当てることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各損失関数に異なる重みを割り当てて、学習損失関数全体への寄与を変えることもできます。</font></font><br>
<br>
<pre><code class="python hljs">model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
              loss=[<span class="hljs-string">'binary_crossentropy'</span>, <span class="hljs-string">'categorical_crossentropy'</span>],<font></font>
              loss_weights=[<span class="hljs-number">1.</span>, <span class="hljs-number">0.2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力レイヤーに名前を付けたので、損失関数も指定できます。</font></font><br>
 <br>
<pre><code class="python hljs">model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
              loss={<span class="hljs-string">'priority'</span>: <span class="hljs-string">'binary_crossentropy'</span>,
                    <span class="hljs-string">'department'</span>: <span class="hljs-string">'categorical_crossentropy'</span>},<font></font>
              loss_weights=[<span class="hljs-number">1.</span>, <span class="hljs-number">0.2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力データとラベルのNumpy配列のリストを渡すことにより、モデルをトレーニングできます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
<font></font>
<span class="hljs-comment"># Dummy input data</span>
title_data = np.random.randint(num_words, size=(<span class="hljs-number">1280</span>, <span class="hljs-number">10</span>))<font></font>
body_data = np.random.randint(num_words, size=(<span class="hljs-number">1280</span>, <span class="hljs-number">100</span>))<font></font>
tags_data = np.random.randint(<span class="hljs-number">2</span>, size=(<span class="hljs-number">1280</span>, num_tags)).astype(<span class="hljs-string">'float32'</span>)
<span class="hljs-comment"># Dummy target data</span>
priority_targets = np.random.random(size=(<span class="hljs-number">1280</span>, <span class="hljs-number">1</span>))<font></font>
dept_targets = np.random.randint(<span class="hljs-number">2</span>, size=(<span class="hljs-number">1280</span>, num_departments))<font></font>
<font></font>
model.fit({<span class="hljs-string">'title'</span>: title_data, <span class="hljs-string">'body'</span>: body_data, <span class="hljs-string">'tags'</span>: tags_data},<font></font>
          {<span class="hljs-string">'priority'</span>: priority_targets, <span class="hljs-string">'department'</span>: dept_targets},<font></font>
          epochs=<span class="hljs-number">2</span>,<font></font>
          batch_size=<span class="hljs-number">32</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクト</font></font><code>Dataset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">fitを呼び出すと</font><font style="vertical-align: inherit;">、などのリストのタプル</font></font><code>([title_data, body_data, tags_data], [priority_targets, dept_targets])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または辞書のタプル</font><font style="vertical-align: inherit;">が返され</font></font><code>({'title': title_data, 'body': body_data, 'tags': tags_data}, {'priority': priority_targets, 'department': dept_targets})</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resnetモデルのトレーニング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数の入力と出力を持つモデルに加えて、Functional APIは、非線形接続、つまりレイヤーが直列に接続されていないモデルのトポロジの操作を簡素化します。</font><font style="vertical-align: inherit;">このようなモデルは、（名前が示すように）シーケンシャルAPIを使用して実装することもできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これの一般的な使用例は、残余接続です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実証するために、CIFAR10のResNetトレーニングモデルを作成してみましょう。</font></font><br>
<br>
<pre><code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>), name=<span class="hljs-string">'img'</span>)<font></font>
x = layers.Conv2D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(inputs)<font></font>
x = layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
block_1_output = layers.MaxPooling2D(<span class="hljs-number">3</span>)(x)<font></font>
<font></font>
x = layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>)(block_1_output)<font></font>
x = layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>)(x)<font></font>
block_2_output = layers.add([x, block_1_output])<font></font>
<font></font>
x = layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>)(block_2_output)<font></font>
x = layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, padding=<span class="hljs-string">'same'</span>)(x)<font></font>
block_3_output = layers.add([x, block_2_output])<font></font>
<font></font>
x = layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)(block_3_output)<font></font>
x = layers.GlobalAveragePooling2D()(x)<font></font>
x = layers.Dense(<span class="hljs-number">256</span>, activation=<span class="hljs-string">'relu'</span>)(x)<font></font>
x = layers.Dropout(<span class="hljs-number">0.5</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs, outputs, name=<span class="hljs-string">'toy_resnet'</span>)<font></font>
model.summary()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルグラフを描きましょう：</font></font><br>
<br>
<pre><code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string">'mini_resnet.png'</span>, show_shapes=<span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/qj/vi/bk/qjvibkpx9zrbp09rcfhj_drtlzc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして彼女に教える：</font></font><br>
<br>
<pre><code class="python hljs">(x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()<font></font>
x_train = x_train.astype(<span class="hljs-string">'float32'</span>) / <span class="hljs-number">255.</span>
x_test = x_test.astype(<span class="hljs-string">'float32'</span>) / <span class="hljs-number">255.</span>
y_train = keras.utils.to_categorical(y_train, <span class="hljs-number">10</span>)<font></font>
y_test = keras.utils.to_categorical(y_test, <span class="hljs-number">10</span>)<font></font>
<font></font>
model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
              loss=<span class="hljs-string">'categorical_crossentropy'</span>,<font></font>
              metrics=[<span class="hljs-string">'acc'</span>])<font></font>
model.fit(x_train, y_train,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">1</span>,<font></font>
          validation_split=<span class="hljs-number">0.2</span>)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤー共有</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型APIのもう1つの優れた使用法は、一般的なレイヤーを使用するモデルです。共通レイヤーは、同じモデルで再利用されるレイヤーのインスタンスです。レイヤーグラフの複数のパスに関連するフィーチャを調査します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共通のレイヤーは、同じスペースから（たとえば、同じ辞書を持つ2つの異なるテキストから）入力データをエンコードするためによく使用されます。これらのレイヤーは、これらの異なるデータ間で情報を交換し、少ないデータでそのようなモデルをトレーニングできるようにするためです。特定の単語が入力の1つに現れた場合、これにより、一般レベルを通過するすべての入力での処理が容易になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能APIでレイヤーを共有するには、レイヤーの同じインスタンスを数回呼び出すだけです。</font><font style="vertical-align: inherit;">たとえば、ここで</font></font><code>Embedding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2つのテキスト入力で</font><font style="vertical-align: inherit;">レイヤー</font><font style="vertical-align: inherit;">が共有されています。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   1000    128- </span>
shared_embedding = layers.Embedding(<span class="hljs-number">1000</span>, <span class="hljs-number">128</span>)<font></font>
<font></font>
<span class="hljs-comment">#    </span>
text_input_a = keras.Input(shape=(<span class="hljs-literal">None</span>,), dtype=<span class="hljs-string">'int32'</span>)<font></font>
<font></font>
<span class="hljs-comment">#    </span>
text_input_b = keras.Input(shape=(<span class="hljs-literal">None</span>,), dtype=<span class="hljs-string">'int32'</span>)<font></font>
<font></font>
<span class="hljs-comment">#          </span><font></font>
encoded_input_a = shared_embedding(text_input_a)<font></font>
encoded_input_b = shared_embedding(text_input_b)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤーグラフ内のノードの取得と再利用 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functional APIで操作するレイヤーグラフは静的データ構造であるため、それにアクセスして確認できます。</font><font style="vertical-align: inherit;">これは、たとえば画像の形式で機能モデルを構築する方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、中間層（グラフの「ノード」）のアクティブ化にアクセスして、他の場所で使用することもできます。</font><font style="vertical-align: inherit;">これは、たとえば、特性の抽出に非常に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を見てみましょう。</font><font style="vertical-align: inherit;">これは、ImageNetで事前トレーニングされたスケールを備えたVGG19モデルです。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> tensorflow.keras.applications <span class="hljs-keyword">import</span> VGG19<font></font>
<font></font>
vgg19 = VGG19()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これらは、グラフデータ構造をクエリすることによって取得される中間モデルのアクティブ化です。</font></font><br>
<br>
<pre><code class="python hljs">features_list = [layer.output <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> vgg19.layers]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの機能を使用して、中間レベルのアクティベーション値を返す新しい機能抽出モデルを作成できます-すべて3行で実行できます</font></font><br>
 <br>
<pre><code class="python hljs">feat_extraction_model = keras.Model(inputs=vgg19.input, outputs=features_list)<font></font>
<font></font>
img = np.random.random((<span class="hljs-number">1</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>)).astype(<span class="hljs-string">'float32'</span>)<font></font>
extracted_features = feat_extraction_model(img)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、他の場合と同様に、ニューラルスタイルの転送を実装する場合に便利です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムレイヤーを作成してAPIを拡張する</font></font></h2><br>
<code>tf.keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幅広い組み込みレイヤーがあります。 ：ここではいくつかの例であり、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンボリューション層は：</font></font><code>Conv1D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Conv2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Conv3D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Conv2DTranspose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,,など</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイヤープール：</font></font><code>MaxPooling1D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>MaxPooling2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>MaxPooling3D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>AveragePooling1D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,,など</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイヤーRNN： 、</font><font style="vertical-align: inherit;">、</font></font><code>GRU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> </font><font style="vertical-align: inherit;">,,など</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">,,等</font><font style="vertical-align: inherit;">
必要なものが見つからない場合は、独自のレイヤーを作成することで、APIを簡単に拡張できます。</font><font style="vertical-align: inherit;">
すべてのレイヤーは、クラス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">サブクラス化して</font><font style="vertical-align: inherit;">実装します</font><font style="vertical-align: inherit;">。レイヤーによって実行される計算を決定</font><font style="vertical-align: inherit;">
するメソッド</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">レイヤーのウェイトを作成</font><font style="vertical-align: inherit;">
するメソッド</font><font style="vertical-align: inherit;">（これは単なるスタイルの規則です。ウェイトはで作成することもできます</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">
簡単な</font><font style="vertical-align: inherit;">レイヤーの</font><font style="vertical-align: inherit;">実装は</font><font style="vertical-align: inherit;">次のとおりです。</font></font><code>LSTM</code><font style="vertical-align: inherit;"></font><code>ConvLSTM2D</code><font style="vertical-align: inherit;"></font><br>
<code>BatchNormalization</code><font style="vertical-align: inherit;"></font><code>Dropout</code><font style="vertical-align: inherit;"></font><code>Embedding</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>Layer</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>call</code><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><code>build</code><font style="vertical-align: inherit;"></font><code>__init__</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>Dense</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDense</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, units=<span class="hljs-number">32</span></span>):</span><font></font>
    super(CustomDense, self).__init__()<font></font>
    self.units = units<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build</span>(<span class="hljs-params">self, input_shape</span>):</span>
    self.w = self.add_weight(shape=(input_shape[<span class="hljs-number">-1</span>], self.units),<font></font>
                             initializer=<span class="hljs-string">'random_normal'</span>,<font></font>
                             trainable=<span class="hljs-literal">True</span>)<font></font>
    self.b = self.add_weight(shape=(self.units,),<font></font>
                             initializer=<span class="hljs-string">'random_normal'</span>,<font></font>
                             trainable=<span class="hljs-literal">True</span>)<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span>
    <span class="hljs-keyword">return</span> tf.matmul(inputs, self.w) + self.b<font></font>
<font></font>
inputs = keras.Input((<span class="hljs-number">4</span>,))<font></font>
outputs = CustomDense(<span class="hljs-number">10</span>)(inputs)<font></font>
<font></font>
model = keras.Model(inputs, outputs)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムレイヤーでシリアル化をサポートする</font></font><code>get_config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は、レイヤーインスタンスのコンストラクター引数を返す</font><font style="vertical-align: inherit;">メソッドも定義する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDense</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, units=<span class="hljs-number">32</span></span>):</span><font></font>
    super(CustomDense, self).__init__()<font></font>
    self.units = units<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build</span>(<span class="hljs-params">self, input_shape</span>):</span>
    self.w = self.add_weight(shape=(input_shape[<span class="hljs-number">-1</span>], self.units),<font></font>
                             initializer=<span class="hljs-string">'random_normal'</span>,<font></font>
                             trainable=<span class="hljs-literal">True</span>)<font></font>
    self.b = self.add_weight(shape=(self.units,),<font></font>
                             initializer=<span class="hljs-string">'random_normal'</span>,<font></font>
                             trainable=<span class="hljs-literal">True</span>)<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span>
    <span class="hljs-keyword">return</span> tf.matmul(inputs, self.w) + self.b<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_config</span>(<span class="hljs-params">self</span>):</span>
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'units'</span>: self.units}<font></font>
<font></font>
<font></font>
inputs = keras.Input((<span class="hljs-number">4</span>,))<font></font>
outputs = CustomDense(<span class="hljs-number">10</span>)(inputs)<font></font>
<font></font>
model = keras.Model(inputs, outputs)<font></font>
config = model.get_config()<font></font>
<font></font>
new_model = keras.Model.from_config(<font></font>
    config, custom_objects={<span class="hljs-string">'CustomDense'</span>: CustomDense})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションで、</font></font><code>from_config (cls, config)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成ディクショナリを指定して、レイヤーインスタンスの再作成を担当</font><font style="vertical-align: inherit;">するクラスメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実装することもでき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">デフォルトの実装</font></font><code>from_config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のようになります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_config</span>(<span class="hljs-params">cls, config</span>):</span>
  <span class="hljs-keyword">return</span> cls(**config)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型APIを使用する場合</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functional APIを使用して新しいモデルを作成</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するか、直接</font><font style="vertical-align: inherit;">サブクラスを作成するほうがよい場合を判断するにはどうすればよい</font><font style="vertical-align: inherit;">ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、Functional APIはより高レベルで使いやすいものであり、サブクラス化されたモデルではサポートされていない多数の関数があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、モデルをサブクラス化すると、層の有向非循環グラフとして簡単に説明できないモデルを作成するときに大きな柔軟性が得られます（たとえば、Functional APIでTree-RNNを実装できないため、直接サブクラス化する必要があります</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能APIの長所：</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示すプロパティはすべて、シーケンシャルモデル（データ構造でもあります）に当てはまりますが、サブクラスモデル（データ構造ではなくPythonコードです）にも当てはまります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functional APIは、より短いコードを生成します。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ</font></font><code>super(MyClass, self).__init__(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、いいえ</font></font><code>def call(self, ...):</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、など </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較：</font></font><br>
<br>
<pre><code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number">32</span>,))<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>)(inputs)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>)(x)<font></font>
mlp = keras.Model(inputs, outputs)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブクラス化されたバージョンの場合：</font></font><br>
 <br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MLP</span>(<span class="hljs-params">keras.Model</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, **kwargs</span>):</span><font></font>
    super(MLP, self).__init__(**kwargs)<font></font>
    self.dense_1 = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>)<font></font>
    self.dense_2 = layers.Dense(<span class="hljs-number">10</span>)<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span><font></font>
    x = self.dense_1(inputs)<font></font>
    <span class="hljs-keyword">return</span> self.dense_2(x)<font></font>
<font></font>
<span class="hljs-comment">#   .</span><font></font>
mlp = MLP()<font></font>
<span class="hljs-comment">#    .</span>
<span class="hljs-comment">#            .</span>
_ = mlp(tf.zeros((<span class="hljs-number">1</span>, <span class="hljs-number">32</span>))) </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成時にモデルが検証されます。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型APIでは、入力仕様（形状とdtype）が事前に（ `Input`を介して）作成され、レイヤーを呼び出すたびに、レイヤーは渡された仕様が想定と一致することを確認します。そうでない場合、有用なエラーメッセージが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、Functional APIを使用して作成したモデルが確実に起動します。</font><font style="vertical-align: inherit;">すべてのデバッグ（収束デバッグに関連しない）は、実行時ではなく、モデル構築中に静的に発生します。</font><font style="vertical-align: inherit;">これは、コンパイラでの型チェックに似ています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能モデルはグラフィカルに表現でき、テストも可能です。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例で見たように、モデルをグラフの形で描画でき、たとえば、グラフの中間ノードに簡単にアクセスして、中間層のアクティブ化を抽出して再利用できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">features_list = [layer.output for layer in vgg19.layers]<font></font>
feat_extraction_model = keras.Model(inputs=vgg19.input, outputs=features_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能モデルはコードの一部というよりデータ構造であるため、安全にシリアル化でき、ソースコードにアクセスせずにまったく同じモデルを再作成できる単一のファイルとして保存できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能的なAPIの弱点</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的アーキテクチャはサポートしていません。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能APIは、モデルをDAGレイヤーとして処理します。</font><font style="vertical-align: inherit;">これはほとんどのディープラーニングアーキテクチャに当てはまりますが、すべての人に当てはまるわけではありません。たとえば、再帰ネットワークやツリーRNNはこの前提を満たしていないため、Functional APIに実装できません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合によっては、すべてを最初から作成する必要があります。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高度なアーキテクチャを作成するときは、「DAGレイヤーの定義」を超えて何かを実行したい場合があります。たとえば、モデルのインスタンスでいくつかのカスタムトレーニングおよび出力メソッドを使用できます。</font><font style="vertical-align: inherit;">これにはサブクラス化が必要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなAPIスタイルの組み合わせ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型APIとモデルのサブクラスのどちらを選択するかは、モデルの1つのカテゴリに限定するバイナリソリューションではないことに注意することが重要です。</font><font style="vertical-align: inherit;">tf.keras APIのすべてのモデルは、シーケンシャルモデル、機能モデル、またはサブクラス化されたモデル/レイヤーをゼロから作成したものであっても、相互に対話できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブクラス化されたモデル/レイヤーの一部として、いつでも機能モデルまたはシーケンシャルモデルを使用できます。</font></font><br>
<br>
<pre><code class="python hljs">units = <span class="hljs-number">32</span>
timesteps = <span class="hljs-number">10</span>
input_dim = <span class="hljs-number">5</span><font></font>
<font></font>
<span class="hljs-comment"># Define a Functional model</span>
inputs = keras.Input((<span class="hljs-literal">None</span>, units))<font></font>
x = layers.GlobalAveragePooling1D()(inputs)<font></font>
outputs = layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'sigmoid'</span>)(x)<font></font>
model = keras.Model(inputs, outputs)<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRNN</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><font></font>
    super(CustomRNN, self).__init__()<font></font>
    self.units = units<font></font>
    self.projection_1 = layers.Dense(units=units, activation=<span class="hljs-string">'tanh'</span>)<font></font>
    self.projection_2 = layers.Dense(units=units, activation=<span class="hljs-string">'tanh'</span>)
    <span class="hljs-comment"># Our previously-defined Functional model</span><font></font>
    self.classifier = model<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span><font></font>
    outputs = []<font></font>
    state = tf.zeros(shape=(inputs.shape[<span class="hljs-number">0</span>], self.units))
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(inputs.shape[<span class="hljs-number">1</span>]):<font></font>
      x = inputs[:, t, :]<font></font>
      h = self.projection_1(x)<font></font>
      y = h + self.projection_2(state)<font></font>
      state = y<font></font>
      outputs.append(y)<font></font>
    features = tf.stack(outputs, axis=<span class="hljs-number">1</span>)<font></font>
    print(features.shape)<font></font>
    <span class="hljs-keyword">return</span> self.classifier(features)<font></font>
<font></font>
rnn_model = CustomRNN()<font></font>
_ = rnn_model(tf.zeros((<span class="hljs-number">1</span>, timesteps, input_dim)))
 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆に、</font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のパターンのいずれかに一致</font><font style="vertical-align: inherit;">するメソッドを実装する場合は、Functional APIでサブクラス化されたレイヤーまたはモデルを使用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>call(self, inputs, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font><code>inputs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、はテンソルまたはネストされたテンソル構造（たとえば、テンソルのリスト）、および</font></font><code>**kwargs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は非テンソル引数（入力ではない）です。 。</font></font><br>
<code>call(self, inputs, training=None, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where </font></font><code>training</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、レイヤー、学習、出力がどのモードで動作するかを示すブール値です。</font></font><br>
<code>call(self, inputs, mask=None, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font><code>mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、ブールマスクテンソルです（たとえば、RNNに役立ちます）。</font></font><br>
<code>call(self, inputs, training=None, mask=None, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-もちろん、レイヤーの動作を同時に定義する両方のパラメーターを持つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、カスタムレイヤーまたはモデルに `get_config`メソッドを実装する場合、それを使用して作成する機能モデルはシリアル化可能であり、複製されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、ゼロから作成されたカスタムRNNを使用する小さな例です機能モデル：</font></font><br>
<br>
<pre><code class="python hljs">units = <span class="hljs-number">32</span>
timesteps = <span class="hljs-number">10</span>
input_dim = <span class="hljs-number">5</span>
batch_size = <span class="hljs-number">16</span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRNN</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><font></font>
    super(CustomRNN, self).__init__()<font></font>
    self.units = units<font></font>
    self.projection_1 = layers.Dense(units=units, activation=<span class="hljs-string">'tanh'</span>)<font></font>
    self.projection_2 = layers.Dense(units=units, activation=<span class="hljs-string">'tanh'</span>)<font></font>
    self.classifier = layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'sigmoid'</span>)<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span><font></font>
    outputs = []<font></font>
    state = tf.zeros(shape=(inputs.shape[<span class="hljs-number">0</span>], self.units))
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(inputs.shape[<span class="hljs-number">1</span>]):<font></font>
      x = inputs[:, t, :]<font></font>
      h = self.projection_1(x)<font></font>
      y = h + self.projection_2(state)<font></font>
      state = y<font></font>
      outputs.append(y)<font></font>
    features = tf.stack(outputs, axis=<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> self.classifier(features)<font></font>
<font></font>
<span class="hljs-comment">#          </span>
<span class="hljs-comment">#  `batch_shape`,     `CustomRNN`  </span>
<span class="hljs-comment">#    (     `state`).</span><font></font>
inputs = keras.Input(batch_shape=(batch_size, timesteps, input_dim))<font></font>
x = layers.Conv1D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>)(inputs)<font></font>
outputs = CustomRNN()(x)<font></font>
<font></font>
model = keras.Model(inputs, outputs)<font></font>
<font></font>
rnn_model = CustomRNN()<font></font>
_ = rnn_model(tf.zeros((<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Functional APIガイドは終了です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ディープラーニングモデルを構築するための強力なツールセットが手に入りました。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証後、翻訳はTensorflow.orgにも表示されます。</font><font style="vertical-align: inherit;">Tensorflow.orgウェブサイトのドキュメントのロシア語への翻訳に参加したい場合は、個人またはコメントでご連絡ください。</font><font style="vertical-align: inherit;">修正やコメントはありがたいです。</font><font style="vertical-align: inherit;">例として、有向非循環グラフでもあるGoogLeNetモデルの画像を使用しました。</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja483652/index.html">可能であれば私に嘘をつく：社会技術的ペンテストを実施する機能</a></li>
<li><a href="../ja483654/index.html">集会でのフィードバックは1対1で、なぜうまくいかないのか、どうやってそれを修正しようとするのか？</a></li>
<li><a href="../ja483656/index.html">小売でのTableauですか？</a></li>
<li><a href="../ja483660/index.html">インフラ管理用の電報ボット</a></li>
<li><a href="../ja483662/index.html">Cisco Threat ResponseとCisco Stealthwatch Enterpriseの統合</a></li>
<li><a href="../ja483666/index.html">Volodyaとオゾン発生器について</a></li>
<li><a href="../ja483668/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo. 397（2020年1月6日〜12日）</a></li>
<li><a href="../ja483670/index.html">MACアドレスについて知りたいすべて</a></li>
<li><a href="../ja483674/index.html">バイナリニューラルネットワークの仕組みと、2020年に普及する理由</a></li>
<li><a href="../ja483676/index.html">エンドツーエンドのマーケティング分析システムの実装の有効性とコストの評価</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>