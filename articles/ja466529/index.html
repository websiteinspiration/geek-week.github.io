<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕 🔇 🤘🏽 JVMのコンパイルタイプ：ブラックマジックセッションの公開 🧔🏿 💙 💅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！
 
 本日は、JVMでコンパイルするためのオプションを例にまとめた記事の翻訳にご注目ください。Java 9以降でサポートされるAOTコンパイルには特に注意が払われます。
 
 読書を楽しむ！
 
 Javaでプログラミングしたことがある人なら誰でも、インスタントコンパイル（J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JVMのコンパイルタイプ：ブラックマジックセッションの公開</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本日は、JVMでコンパイルするためのオプションを例にまとめた記事の翻訳にご注目ください。</font><font style="vertical-align: inherit;">Java 9以降でサポートされるAOTコンパイルには特に注意が払われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読書を楽しむ！</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでプログラミングしたことがある人なら誰でも、インスタントコンパイル（JIT）や、おそらく実行前のコンパイル（AOT）について聞いたことがあると思います。さらに、「解釈された」言語とは何かを説明する必要はありません。この記事では、これらすべての機能がJava仮想マシン、JVMにどのように実装されるかを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでプログラミングする場合、Javaソースコード（.javaファイル）をJavaバイトコード（.classファイル）に収集するコンパイラー（「javac」プログラムを使用）を実行する必要があることをご存じでしょう。</font><font style="vertical-align: inherit;">Javaバイトコードは中間言語です。</font><font style="vertical-align: inherit;">これは「中間」と呼ばれます。これは、実際のコンピューティングデバイス（CPU）では理解されず、コンピューターで実行できないため、ソースコードとプロセッサで実行される「ネイティブ」マシンコード間の移行形式を表すためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaバイトコードが特定の作業を行うために、それを実行させるには3つの方法があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中間コードを直接実行します。</font><font style="vertical-align: inherit;">「解釈」する必要があると言う方がより適切で正しいです。</font><font style="vertical-align: inherit;">JVMにはJavaインタープリターがあります。</font><font style="vertical-align: inherit;">ご存知のように、JVMが機能するには、「java」プログラムを実行する必要があります。</font></font></li>
<li>            CPU     .  ,      (Just in Time)   «».</li>
<li>3  ,    ,          CPU    .        AoT (Ahead of Time).</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、（1）はインタープリターの作業、（2）はJITコンパイルの結果、（3）はAOTコンパイルの結果です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全を期すために、ソースコードを直接解釈する4番目のアプローチがあることを述べますが、Javaではこれは受け入れられません。これは、たとえばPythonで行われます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、「java」が（1）（2）JITコンパイラーおよび/または（3）AOTコンパイラーのインタープリターとして、そしていつ、どのように機能するかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに-原則として、「java」は（1）と（2）の両方を実行します。 Java 9以降、3番目のオプションも可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><code>Test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、今後の例で使用される</font><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">return</span> a;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) {<font></font>
      System.out.println(<span class="hljs-string">"call "</span> + Integer.valueOf(i));
      <span class="hljs-keyword">long</span> a = System.nanoTime();
      <span class="hljs-keyword">new</span> Test().f();
      <span class="hljs-keyword">long</span> b = System.nanoTime();<font></font>
      System.out.println(<span class="hljs-string">"elapsed= "</span> + (b-a));<font></font>
    }<font></font>
<font></font>
  }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、オブジェクトをインスタンス化し</font></font><code>Test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関数を</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10回続けて</font><font style="vertical-align: inherit;">循環的に呼び出す</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。関数</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はほとんど何もしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、上記のコードをコンパイルして実行すると、出力はかなり期待されます（もちろん、経過時間の値はあなたにとっては異なります）：</font></font><br>
<br>
<pre><code class="plaintext hljs">call 1<font></font>
elapsed= 5373<font></font>
call 2<font></font>
elapsed= 913<font></font>
call 3<font></font>
elapsed= 654<font></font>
call 4<font></font>
elapsed= 623<font></font>
call 5<font></font>
elapsed= 680<font></font>
call 6<font></font>
elapsed= 710<font></font>
call 7<font></font>
elapsed= 728<font></font>
call 8<font></font>
elapsed= 699<font></font>
call 9<font></font>
elapsed= 853<font></font>
call 10<font></font>
elapsed= 645</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今問題は：この結論は、インタプリタとしての「java」の作業の結果、つまりオプション（1）、JITコンパイラとしての「java」、つまりオプション（2）の結果なのか、それともAOTコンパイルに何らかの関係があるのか、つまり、オプション（3）？この記事では、これらすべての質問に対する正しい答えを見つけます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が言いたい最初の答えは、おそらくここでは（1）だけが起こるということです。ここでは、デフォルトのJVMオプションを変更する環境変数が設定されているかどうかわからないため、「可能性が高い」と言います。余分なものがインストールされておらず、これがデフォルトで「java」が機能する方法である場合、ここではオプション（1）のみを100％監視しています。つまり、コードは完全に解釈されます。私はこれを確信しています：</font></font><br>
<br>
<ul>
<li>   “java”,  <code>-XX:CompileThreshold=invocations</code>       <code>invocations=1500</code>   JVM (   JVM  ).      10 ,  10 &lt; 1500,       .  ,      ,   ()    ,      .      .</li>
<li>  ,       ,  ,     .      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：JVMはクライアントモードまたはサーバーモードで動作でき、最初のケースと2番目のケースでデフォルトで設定されるオプションは異なります。原則として、JVMが起動された環境またはコンピューターに応じて、起動モードに関する決定は自動的に行われます。以下で</font></font><code>–client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プログラムがクライアントモードで実行されていることを疑わないように、</font><font style="vertical-align: inherit;">すべての起動時にオプションを示し</font><font style="vertical-align: inherit;">ます。このオプションは、この投稿で説明したい側面には影響しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションで「java」を実行した場合</font></font><code>-XX:PrintCompilation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関数が動的にコンパイルされると、プログラムは行を出力します。 JITコンパイルは関数ごとに個別に実行されることを忘れないでください。クラス内の一部の関数はバイトコードのままである（つまり、コンパイルされない）場合がありますが、他の関数はすでにJITコンパイルに合格している場合があります。つまり、プロセッサで直接実行する準備ができています。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下にオプションも追加します</font></font><code>-Xbatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このオプションは</font></font><code>-Xbatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、出力をより見やすくするためにのみ必要です。それ以外の場合、JITコンパイルは（解釈とともに）競争的に進行し、コンパイル後の出力は実行時に（のため</font></font><code>-XX:PrintCompilation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">奇妙に見えることがあります</font><font style="vertical-align: inherit;">。ただし、このオプション</font></font><code>–Xbatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はバックグラウンドコンパイルを無効にするため、JITコンパイルを実行する前に、プログラムの実行が停止されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（読みやすくするために、各オプションは新しい行から記述します）</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java -client -Xbatch <font></font>
-XX:+PrintCompilation <font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、このコマンドの出力を挿入しません。デフォルトでは、JVMは多くの内部関数（たとえば、java、sun、jdkパッケージに関連する）をコンパイルするため、出力は非常に長くなるため、画面上では、274行の内部関数があります。 、およびさらにいくつか-プログラムのまさに結論に至るまで）。</font><font style="vertical-align: inherit;">この調査を簡単にするために、内部クラスのJITコンパイルをキャンセルするか、自分のメソッドに対してのみ選択的に有効にします（</font></font><code>Test.f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">これを行うには、別のオプションを指定する必要があります</font></font><code>-XX:CompileCommand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">多くのコマンド（コンパイル）を指定できるので、それらを別のファイルに入れる方が簡単です。</font><font style="vertical-align: inherit;">幸い、オプションがあります</font></font><code>-XX:CompileCommandFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それでは、ファイルの作成に進んでください。</font></font><code>hotspot_compiler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に説明する理由から</font><font style="vertical-align: inherit;">名前を付けて</font><font style="vertical-align: inherit;">、次のように書きます。</font></font><br>
<br>
<pre><code class="plaintext hljs">quiet<font></font>
exclude java/* *<font></font>
exclude jdk/* *<font></font>
exclude sun/* *</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、java、jdk、およびsunで始まるすべてのパッケージからすべてのクラスのすべての関数（最後の*）を除外していることを完全に明確にする必要があります（パッケージ名は/で区切られ、*を使用できます）。</font><font style="vertical-align: inherit;">このコマンド</font></font><code>quiet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、除外されたクラスについて何も書き込まないようにJVMに指示するため、現在コンパイルされているクラスのみがコンソールに出力されます。</font><font style="vertical-align: inherit;">だから、私は実行します：</font></font><br>
<br>
<pre><code class="plaintext hljs">java -client -Xbatch <font></font>
-XX:+PrintCompilation <font></font>
-XX:CompileCommandFile=hotspot_compiler <font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコマンドの出力について説明する前に、このファイルに名前を付けたことを思い出します。これ</font></font><code>hotspot_compiler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Oracle JDKでは</font></font><code>.hotspot_compiler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラコマンドを使用してファイルにデフォルト</font><font style="vertical-align: inherit;">名</font><font style="vertical-align: inherit;">が設定されて</font><font style="vertical-align: inherit;">いるようです（確認していません）</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、結論は次のとおりです。</font></font><br>
<br>
<pre><code class="plaintext hljs">many lines like this 111    1     n 0       java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native)   (static)<font></font>
call 1<font></font>
some more lines like this 161   48     n 0       java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native)   (static)<font></font>
elapsed= 7558<font></font>
call 2<font></font>
elapsed= 1532<font></font>
call 3<font></font>
elapsed= 920<font></font>
call 4<font></font>
elapsed= 732<font></font>
call 5<font></font>
elapsed= 774<font></font>
call 6<font></font>
elapsed= 815<font></font>
call 7<font></font>
elapsed= 767<font></font>
call 8<font></font>
elapsed= 765<font></font>
call 9<font></font>
elapsed= 757<font></font>
call 10<font></font>
elapsed= 868</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、一部のメソッドがまだコンパイルされている理由がわかりません。</font></font><code>java.lang.invoke.MethodHandler.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく無効にできないものもあります。問題の内容を理解しました-この投稿を更新します。ただし、ご覧のように、他のすべてのコンパイル手順（以前は274行でした）が消えています。さらなる例では、出力からコンパイルログも削除します</font></font><code>java.lang.invoke.MethodHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こったか見てみましょう。これで、関数を10回実行する単純なコードができました。ドキュメントで示されているように、この関数はコンパイルではなく解釈され、ログに表示されるようになりました（同時に、コンパイルログには表示されません。つまり、JITコンパイルの対象ではありません）。さて、あなたは「java」ツールが動作しているのを見ただけで、100％のケースで私たちの機能を解釈し、解釈するだけです。したがって、オプション（1）で計算されたボックスをチェックできます。 （2）の動的コンパイルに移ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントによると、関数を1,500回実行して、JITコンパイルが実際に行われていることを確認できます。ただし、通話オプションを使用することもできます。</font></font><code>-XX:CompileThreshold=invocations</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1500の代わりに必要な値を設定します。ここで指摘しましょう。5。これは、次のことを期待することを意味します。関数fの5つの「解釈」の後、JVMはメソッドをコンパイルし、コンパイルされたバージョンを実行する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
java -client -Xbatch</font></font><br>
<br>
<pre><code class="plaintext hljs">-XX:+PrintCompilation <font></font>
-XX:CompileCommandFile=hotspot_compiler <font></font>
-XX:CompileThreshold=5 <font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコマンドを実行した場合、上記の例と比較して何も変わっていないことに気づいたかもしれません。</font><font style="vertical-align: inherit;">つまり、コンパイルはまだ行われません。</font><font style="vertical-align: inherit;">ドキュメントによると、</font><font style="vertical-align: inherit;">デフォルトで機能する</font></font><code>-XX:CompileThreshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disabledの場合にのみ機能することがわかりました</font></font><code>TieredCompilation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼女はオフにした：</font></font><code>-XX:-TieredCompilation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">階層化コンパイルは、JVMの起動速度と巡航速度の両方を改善するためにJava 7で導入された機能です。</font><font style="vertical-align: inherit;">この投稿では重要ではないので、無効にしてかまいません。</font><font style="vertical-align: inherit;">このコマンドをもう一度実行してみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">java -client -Xbatch<font></font>
-XX:+PrintCompilation<font></font>
-XX:CompileCommandFile=hotspot_compiler<font></font>
-XX:CompileThreshold=5<font></font>
-XX:-TieredCompilation<font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが出力です（思い出してください、私はに関する行をスキップしました</font></font><code>java.lang.invoke.MethodHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="plaintext hljs">call 1<font></font>
elapsed= 9411<font></font>
call 2<font></font>
elapsed= 1291<font></font>
call 3<font></font>
elapsed= 862<font></font>
call 4<font></font>
elapsed= 1023<font></font>
call 5<font></font>
    227   56    b        Test::&lt;init&gt; (5 bytes)<font></font>
    228   57    b        Test::f (4 bytes)<font></font>
elapsed= 1051739<font></font>
call 6<font></font>
elapsed= 18516<font></font>
call 7<font></font>
elapsed= 940<font></font>
call 8<font></font>
elapsed= 769<font></font>
call 9<font></font>
elapsed= 855<font></font>
call 10<font></font>
elapsed= 838</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的にコンパイルされた関数Test.fを歓迎します（こんにちは！）</font></font><code>Test::&lt;init&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CompileThresholdを5に設定したため、番号5を呼び出した直後。JVMは関数を5回解釈してからコンパイルし、最後にコンパイルされたバージョンを実行します。関数はコンパイルされているため、より高速に実行されるはずですが、この関数は何も実行しないため、ここでは検証できません。これは別の投稿の良いトピックだと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくご想像のとおり、ここでは別の関数がコンパイルされています。つまり</font></font><code>Test::&lt;init&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これはクラスコンストラクター</font></font><code>Test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。コードはコンストラクター（new </font></font><code>Test()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">呼び出すため、</font><font style="vertical-align: inherit;">呼び出される</font></font><code>f </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たびに、関数と同時にコンパイルされ、</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5回の呼び出しの後に正確に</font><font style="vertical-align: inherit;">コンパイルされ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、これによりオプション（2）、JITコンパイルの説明を終了できます。ご覧のとおり、この場合、関数は最初にJVMによって解釈され、次に5回解釈した後に動的にコンパイルされます。 JITコンパイルに関する最後の詳細、つまりオプションについて説明します</font></font><code>-XX:+PrintAssembly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その名前が示すように、関数のコンパイル済みバージョン（コンパイル済みバージョン=ネイティブマシンコード=アセンブラコード）をコンソールに出力します。ただし、これはライブラリパスに逆アセンブラがある場合にのみ機能します。逆アセンブラーはJVMによって異なる場合があると思いますが、ここでは、openjdkの逆アセンブラーであるhsdisを扱っています。 hsdisライブラリまたはそのバイナリファイルのソースコードは、さまざまな場所で取得できます。この場合、このファイルをコンパイルしてに配置し</font></font><code>hsdis-amd64.so</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font><code>JAVA_HOME/lib/server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、このコマンドを実行できます。</font><font style="vertical-align: inherit;">しかし、最初にそれを実行するためにそれ</font></font><code>-XX:+PrintAssembly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を追加する必要</font></font><code>-XX:+UnlockDiagnosticVMOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります</font></font><code>PrintAssembly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それは</font><font style="vertical-align: inherit;">オプションを追加</font><font style="vertical-align: inherit;">すること</font><font style="vertical-align: inherit;">も必要</font><font style="vertical-align: inherit;">であり、それは</font><font style="vertical-align: inherit;">オプション</font><font style="vertical-align: inherit;">に続く必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行わないと、JVMによってオプションの誤った使用に関する警告が表示されます</font></font><code>PrintAssembly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このコードを実行してみましょう：</font></font><br>
<br>
<pre><code class="plaintext hljs">java -client -Xbatch<font></font>
-XX:+PrintCompilation<font></font>
-XX:CompileCommandFile=hotspot_compiler<font></font>
-XX:CompileThreshold=5<font></font>
-XX:-TieredCompilation<font></font>
-XX:+UnlockDiagnosticVMOptions<font></font>
-XX:+PrintAssembly<font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力は長くなり、次のような行があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">0x00007f4b7cab1120: mov    0x8(%rsi),%r10d<font></font>
0x00007f4b7cab1124: shl    $0x3,%r10<font></font>
0x00007f4b7cab1128: cmp    %r10,%rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、対応する関数はネイティブマシンコードにコンパイルされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、オプション3、AOTについて説明します。実行前のコンパイルであるAOTは、バージョン9まではJavaで利用できませんでした</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。JDK9には新しいツールjaotcが導入されました-名前が示すとおり、これはJava用のAOTコンパイラーです。これは、Java「javac」コンパイラを実行してから、Java「jaotc」用のAOTコンパイラを実行し、通常どおりJVM「java」を実行するという考え方です。 JVMは通常、解釈とJITコンパイルを実行します。ただし、関数にAOTでコンパイルされたコードがある場合、関数はそれを直接使用し、解釈やJITコンパイルに頼りません。説明させてください。AOTコンパイラーを実行する必要はありません。これはオプションであり、使用する場合、実行する前に必要なクラスのみをコンパイルできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AOTでコンパイルされたバージョンで構成されるライブラリを作成してみましょう</font></font><code>Test::f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">忘れないでください。これを自分で行うには、ビルド150以降にJDK 9が必要です。</font></font><br>
<br>
<pre><code class="plaintext hljs">jaotc --output=libTest.so Test.class</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果</font></font><code>libTest.so</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クラスに含まれる関数のAOTコンパイルされたネイティブコードを含むライブラリが</font><font style="vertical-align: inherit;">生成され</font></font><code>Test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このライブラリで定義されている文字を表示できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">nm libTest.so</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの結論では、とりわけ、次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000000002120 t Test.f()I<font></font>
00000000000021a0 t Test.&lt;init&gt;()V<font></font>
00000000000020a0 t Test.main([Ljava/lang/String;)V</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべての関数、コンストラクター</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、静的メソッド</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はライブラリーに存在します</font></font><code>libTest.so</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対応する「java」オプションの場合と同様に、この場合、このオプションにはファイルを含めることができます。これには、jaotcに-compile-commandsオプションがあります。 JEP 295は、ここでは示しませんが関連する例を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「java」を実行して、AOTでコンパイルされたメソッドが使用されているかどうかを確認してみましょう。以前と同じように「java」を実行すると、AOTライブラリーは使用されず、これは当然のことです。この新機能を使用</font></font><code>-XX:AOTLibrary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するには、指定する必要</font><font style="vertical-align: inherit;">があるオプションが用意さ</font><font style="vertical-align: inherit;">れています。</font></font><br>
<br>
<pre><code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のAOTライブラリーをコンマで区切って指定できます。</font><font style="vertical-align: inherit;">テストプログラムの動作はまったく変更されていないため、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコマンドの出力は、なし</font></font><code>AOTLibrary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">「java」を起動した場合とまったく同じ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">AOTでコンパイルされた関数が使用されているかどうかを確認するために、別の新しいオプションを追加することができます</font></font><code>-XX:+PrintAOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">java<font></font>
-XX:AOTLibrary=./libTest.so<font></font>
-XX:+PrintAOT<font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの出力前の</font></font><code>Test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコマンドは、次のことを示しています。</font></font><br>
<br>
<pre><code class="plaintext hljs"> 9    1     loaded    ./libTest.so  aot library<font></font>
99    1     aot[ 1]   Test.main([Ljava/lang/String;)V<font></font>
99    2     aot[ 1]   Test.f()I<font></font>
99    3     aot[ 1]   Test.&lt;init&gt;()V</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予定どおり、AOTライブラリーがロードされ、AOTでコンパイルされた関数が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味がある場合は、次のコマンドを実行して、JITコンパイルが行われているかどうかを確認できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">java -client -Xbatch<font></font>
-XX:+PrintCompilation<font></font>
-XX:CompileCommandFile=hotspot_compiler<font></font>
-XX:CompileThreshold=5<font></font>
-XX:-TieredCompilation<font></font>
-XX:AOTLibrary=./libTest.so<font></font>
-XX:+PrintAOT<font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想どおり、Testクラスのメソッドは実行前にコンパイルされ、ライブラリとして提供されるため、JITコンパイルは行われません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能な質問は次のとおりです。ネイティブ関数コードを提供する場合、JVMはネイティブコードが廃止されているか、古くなっているかをどのように判断しますか？</font><font style="vertical-align: inherit;">最後の例として、関数</font></font><code> f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">変更して</font><font style="vertical-align: inherit;">aを6に設定します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
  <span class="hljs-keyword">int</span> a = <span class="hljs-number">6</span>;
  <span class="hljs-keyword">return</span> a;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、クラスファイルを変更するためだけに行いました。</font><font style="vertical-align: inherit;">次に、javacをコンパイルして、上記と同じコマンドを実行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">javac Test.java<font></font>
java -client -Xbatch<font></font>
-XX:+PrintCompilation<font></font>
-XX:CompileCommandFile=hotspot_compiler<font></font>
-XX:CompileThreshold=5<font></font>
-XX:-TieredCompilation<font></font>
-XX:AOTLibrary=./libTest.so<font></font>
-XX:+PrintAOT<font></font>
Test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、「javac」の後に「jaotc」を実行しなかったため、AOTライブラリのコードは古くなり、正しくなくなり、関数</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には= 5が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の「java」コマンドの出力は、次のことを示しています。</font></font><br>
<br>
<pre><code class="plaintext hljs">228   56    b        Test::&lt;init&gt; (5 bytes)<font></font>
229   57    b        Test::f (5 bytes)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、この場合の関数は動的にコンパイルされたため、AOTコンパイルの結果のコードは使用されませんでした。</font><font style="vertical-align: inherit;">そのため、クラスファイルで変更が検出されました。</font><font style="vertical-align: inherit;">javacを使用してコンパイルを実行すると、そのフィンガープリントがクラスに入力され、クラスのフィンガープリントもAOTライブラリに格納されます。</font><font style="vertical-align: inherit;">クラスの新しいフィンガープリントはAOTライブラリに格納されているものとは異なるため、事前にコンパイルされたネイティブコード（AOT）は使用されませんでした。</font><font style="vertical-align: inherit;">実行する前に、コンパイルの最後のバージョンについて私が伝えたかったのはそれだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、JVMがどのようにJavaコードを実行するかを解釈し、動的にコンパイルする（JIT）または事前に（AOT）することを簡単で現実的な例で説明し、説明しようとしました-さらに、最後の機会はJDK 9にのみ現れました。新着。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466517/index.html">ワシントン大学ローカリゼーショントレーニング</a></li>
<li><a href="../ja466519/index.html">AWS Lambdaの詳細な分析</a></li>
<li><a href="../ja466521/index.html">C for Metal-Intelグラフィックスカードでのコンピューティング用の貴金属</a></li>
<li><a href="../ja466525/index.html">PSD iPhoneレイアウトとは何ですか？</a></li>
<li><a href="../ja466527/index.html">カピバラページオブジェクトを使用したウェブサイトユーザー機能のテスト</a></li>
<li><a href="../ja466533/index.html">パスティルダ：結果</a></li>
<li><a href="../ja466535/index.html">deepCloneの再考</a></li>
<li><a href="../ja466537/index.html">本番環境でのJavaScriptモジュールの使用：現在の状況。パート1</a></li>
<li><a href="../ja466539/index.html">本番環境でのJavaScriptモジュールの使用：現在の状況。パート2</a></li>
<li><a href="../ja466541/index.html">DbToolを使用して.NETアプリケーションにデータベースをシードする（コア）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>