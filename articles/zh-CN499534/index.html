<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌 💸 🃏 Python后端服务开发指南 🚤 📶 💃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨，我叫Alexander Vasin，我是Edadil的后端开发人员。这种材料的想法始于我想将入门级作业（Ya.Disk）解析到Yandex 后端开发学校的事实。我开始描述某些技术选择和测试方法的所有细微差别……事实证明这根本不是分析，而是关于如何用Python编写后端的非常详细的指南。从最初的想...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Python后端服务开发指南</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/499534/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嗨，我叫Alexander Vasin，我是Edadil的后端开发人员。这种材料的想法始于我想将入门级作业（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya.Disk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">解析</font><font style="vertical-align: inherit;">到Yandex </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">后端开发</font></a><font style="vertical-align: inherit;">学校</font><font style="vertical-align: inherit;">的事实</font><font style="vertical-align: inherit;">。我开始描述某些技术选择和测试方法的所有细微差别……事实证明这根本不是分析，而是关于如何用Python编写后端的非常详细的指南。从最初的想法开始，仅对服务有要求，在此示例中可以方便地拆卸工具和技术。结果，我醒来了十万个字符。要仔细考虑所有细节，确实需要太多。因此，该程序适用于下一个100 KB：如何从选择工具到部署如何构建服务后端。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pm/sz/r2/pmszr288srjaplio0w_utpnb4ym.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TL; DR：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有应用程序的GitHub代表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和谁喜欢（真正的）长读-请在猫的陪伴下进行。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用Python开发和测试REST API服务，将其包装在轻量级Docker容器中，并使用Ansible进行部署。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用不同的工具以不同的方式实现REST API服务。</font><font style="vertical-align: inherit;">所描述的解决方案不是唯一的解决方案，我根据个人经验和偏好选择了实现和工具。</font></font></blockquote><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们做什么？</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择什么工具？</font></font></a></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发展历程</font></font></a><br>
 <ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么需要从setup.py开始？</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何指定依赖版本？</font></font></a></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库</font></font></a><br>
 <ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们设计方案</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述SQLAlchemy中的模式</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自订Alembic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们产生移民</font></font></a></li>
</ul></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据序列化</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开机自检/导入</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修补程序/进口/ $ import_id /公民/ $ civil_id</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民/生日</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /城镇/统计/百分位数/年龄</font></font></a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试中</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开机自检/导入</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修补程序/进口/ $ import_id /公民/ $ civil_id</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民/生日</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /城镇/统计/百分位数/年龄</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移居</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部件</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">词</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部署</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">压力测试</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有什么可以做的？</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后</font></font></a></li>
</ul><br>
<a name="task"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们做什么？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象一下，一家在线礼品店计划在不同地区发起一项行动。</font><font style="vertical-align: inherit;">为了使销售策略有效，需要进行市场分析。</font><font style="vertical-align: inherit;">该商店有一个供应商，该供应商定期发送（例如，通过邮件）卸载有关居民信息的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们开发一个Python REST API服务，该服务将分析提供的数据并按月确定来自不同城市的不同年龄段居民的礼物需求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在服务中实现以下处理程序：</font></font><br>
<br>
<ul>
<li> <code>POST /imports</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加带有数据的新上传；</font></font><br>
 </li>
<li> <code>GET /imports/$import_id/citizens</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回指定流量的居民；</font></font><br>
 </li>
<li> <code>PATCH /imports/$import_id/citizens/$citizen_id</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在指定的卸载过程中更改有关居民（及其亲属）的信息；</font></font><br>
 </li>
<li> <code>GET /imports/$import_id/citizens/birthdays</code><br>
  ,        ( ),   ;<br>
 </li>
<li> <code>GET /imports/$import_id/towns/stat/percentile/age</code><br>
 50-, 75-  99-   ( )      .<br>
 </li>
</ul><br>
<a name="tools"></a><h1>  ?</h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们正在使用熟悉的框架，库和DBMS用Python编写服务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font><font style="vertical-align: inherit;">视频课程的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4个讲座中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，描述了各种DBMS及其功能。在我的实现中，我选择了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DBMS </font><font style="vertical-align: inherit;">，它已建立了可靠的解决方案，并提供了出色</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的俄语文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，强大的俄语社区（您可以随时用俄语找到问题的答案），甚至</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免费课程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。关系模型非常通用，并且被许多开发人员很好地理解。尽管可以在任何NoSQL DBMS上完成相同的操作，但是在本文中，我们将考虑PostgreSQL。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该服务的主要目标-数据库和客户端之间通过网络进行的数据传输-并不意味着处理器上会有很大的负载，但是需要能够一次处理多个请求。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10个讲座中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑了异步方法。它使您可以在同一OS进程中高效地为多个客户端提供服务（例如，与Flask / Django中使用的前叉模型不同，该模型创建了多个进程来处理来自用户的请求，每个进程都消耗内存，但是大部分时间是空闲的）因此，作为编写服务的库，我选择了异步</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.aio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aiohttp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">视频课程</font><font style="vertical-align: inherit;">
的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">第5讲</font></a><font style="vertical-align: inherit;">讲述</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">SQLAlchemy</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/or/rj/pn/orrjpnx6upvsipcqbsql7f36vzc.png"></a><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您将复杂的查询分解为多个部分，重复使用它们，使用动态字段集生成查询（例如，PATCH处理器允许使用任意字段进行部分驻留更新），并直接关注业务逻辑。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncpg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驱动程序</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">可以</font></a><font style="vertical-align: inherit;">处理这些请求并以最快的速度传输数据</font><font style="vertical-align: inherit;">，而</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncpgsa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将帮助他们结识朋友</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我最喜欢的用于管理数据库状态和进行迁移的工具是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alembic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。顺便说一下，我最近在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moscow Python中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谈到了它</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">棉花糖</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
计划简洁地描述了验证的逻辑</font><font style="vertical-align: inherit;">（包括检查家庭纽带）。使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/maximdanilchenko/aio"><font style="vertical-align: inherit;">aiohttp-spec</font></a><font style="vertical-align: inherit;">模块</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/maximdanilchenko/aio"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我链接了aiohttp处理程序和用于数据验证的方案，其好处是可以生成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式的文档</font><font style="vertical-align: inherit;">并将其显示在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形界面中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了编写测试，我</font></font><code>pytest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3个讲座中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择了</font><font style="vertical-align: inherit;">更多有关</font><font style="vertical-align: inherit;">测试的</font><font style="vertical-align: inherit;">内容</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了调试和分析该项目，我使用了PyCharm调试器（第</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9节</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7章的演讲中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍了如何在</font><font style="vertical-align: inherit;">打包的</font><font style="vertical-align: inherit;">任何计算机上</font><font style="vertical-align: inherit;">（甚至在不同的OS上）运行</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而无需调整应用程序环境来启动和轻松地在服务器上安装/更新/删除应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于部署，我选择了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它允许您以声明方式描述服务器及其服务的所需状态，通过ssh进行工作，并且不需要特殊的软件。</font></font><br>
<br>
<a name="development"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发展历程</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定给Python包起一个名称，</font></font><code>analyzer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用以下结构：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/ly/wt/oxlywtje20xt5ceou8pbtfp8an8.png" width="550"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在文件中，</font></font><code>analyzer/__init__.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我发布了有关该包的一般信息：描述（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docstring</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），版本，许可证，开发人员联系方式。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用内置的帮助进行查看</font></font></b>
                        <div class="spoiler_text"><pre><code class="bash hljs">$ python<font></font>
&gt;&gt;&gt; import analyzer<font></font>
&gt;&gt;&gt; <span class="hljs-built_in">help</span>(analyzer)<font></font>
<font></font>
Help on package analyzer:<font></font>
<font></font>
NAME<font></font>
    analyzer<font></font>
<font></font>
DESCRIPTION<font></font>
      REST API,    .<font></font>
<font></font>
PACKAGE CONTENTS<font></font>
    api (package)<font></font>
    db (package)<font></font>
    utils (package)<font></font>
<font></font>
DATA<font></font>
    __all__ = (<span class="hljs-string">'__author__'</span>, <span class="hljs-string">'__email__'</span>, <span class="hljs-string">'__license__'</span>, <span class="hljs-string">'__maintainer__'</span>,...<font></font>
    __email__ = <span class="hljs-string">'alvassin@yandex.ru'</span>
    __license__ = <span class="hljs-string">'MIT'</span>
    __maintainer__ = <span class="hljs-string">'Alexander Vasin'</span><font></font>
<font></font>
VERSION<font></font>
    0.0.1<font></font>
<font></font>
AUTHOR<font></font>
    Alexander Vasin<font></font>
<font></font>
FILE<font></font>
    /Users/alvassin/Work/backendschool2019/analyzer/__init__.py</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该软件包有两个输入点-REST API服务（</font></font><code>analyzer/api/__main__.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和数据库状态管理实用程序（</font></font><code>analyzer/db/__main__.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">文件的调用</font></font><code>__main__.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是有原因的-首先，这样的名称引起了人们的注意，它清楚地表明文件是入口点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，由于这种进入点的方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>     python -m</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment"># REST API</span>
$ python -m analyzer.api --<span class="hljs-built_in">help</span><font></font>
<font></font>
<span class="hljs-comment">#    </span>
$ python -m analyzer.db --<span class="hljs-built_in">help</span></code></pre><br>
<a name="setuppy"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么需要从setup.py开始？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
展望未来，我们将考虑如何分发应用程序：它可以打包为zip（以及wheel / egg-）归档文件，rpm包，macOS的pkg文件，并安装在远程计算机，虚拟机，MacBook或Docker-容器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该文件的主要目的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>setup.py</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是用的应用程序描述该软件包</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
该文件必须包含有关程序包的常规信息（名称，版本，作者等），但是您还可以在其中指定工作所需的模块，“额外”依赖项（例如，用于测试），入口点（例如，可执行命令）。 ）和口译员的要求。</font><font style="vertical-align: inherit;">
Setuptools插件使您可以从描述的软件包中收集工件。有内置的插件：zip，egg，rpm，macOS pkg。其余的插件通过PyPI分发：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">wheel</font></a><font style="vertical-align: inherit;">，</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">distutils</a>/<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">setuptools</a></code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最下面一行描述一个文件，我们获得了很多机会。</font><font style="vertical-align: inherit;">这就是为什么要开始开发新项目的原因</font></font><code>setup.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在函数中，</font></font><code>setup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相关模块由列表指示：</font></font><br>
<br>
<pre><code class="python hljs">setup(..., install_requires=[<span class="hljs-string">"aiohttp"</span>, <span class="hljs-string">"SQLAlchemy"</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我在单独的文件中描述了依赖项，</font></font><code>requirements.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>requirements.dev.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在中使用了其内容</font></font><code>setup.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对我来说，它似乎更灵活，而且还有一个秘密：稍后，它将允许您更快地构建Docker映像。</font><font style="vertical-align: inherit;">在安装应用程序本身之前，将依赖性设置为一个单独的步骤，并且在重建Docker容器时，它将位于缓存中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了</font></font><code>setup.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够从文件</font></font><code>requirements.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和中</font><font style="vertical-align: inherit;">读取依赖项</font></font><code>requirements.dev.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，编写了该函数：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_requirements</span>(<span class="hljs-params">fname: str</span>) -&gt; list:</span><font></font>
    requirements = []<font></font>
    <span class="hljs-keyword">with</span> open(fname, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> fp:
        <span class="hljs-keyword">for</span> req <span class="hljs-keyword">in</span> parse_requirements(fp.read()):<font></font>
            extras = <span class="hljs-string">'[{}]'</span>.format(<span class="hljs-string">','</span>.join(req.extras)) <span class="hljs-keyword">if</span> req.extras <span class="hljs-keyword">else</span> <span class="hljs-string">''</span><font></font>
            requirements.append(<font></font>
                <span class="hljs-string">'{}{}{}'</span>.format(req.name, extras, req.specifier)<font></font>
            )<font></font>
    <span class="hljs-keyword">return</span> requirements</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得一提的是，</font></font><code>setuptools</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当默认组件源分布仅包括汇编文件</font></font><code>.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>.cpp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于依赖项文件</font></font><code>requirements.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，请</font></font><code>requirements.dev.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在文件中明确指定它们</font></font><code>MANIFEST.in</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全setup.py</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> importlib.machinery <span class="hljs-keyword">import</span> SourceFileLoader<font></font>
<font></font>
<span class="hljs-keyword">from</span> pkg_resources <span class="hljs-keyword">import</span> parse_requirements
<span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> find_packages, setup<font></font>
<font></font>
module_name = <span class="hljs-string">'analyzer'</span><font></font>
<font></font>
<span class="hljs-comment"># ,     (   ), </span>
<span class="hljs-comment">#   __init__.py   machinery.</span><font></font>
module = SourceFileLoader(<font></font>
    module_name, os.path.join(module_name, <span class="hljs-string">'__init__.py'</span>)<font></font>
).load_module()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_requirements</span>(<span class="hljs-params">fname: str</span>) -&gt; list:</span><font></font>
    requirements = []<font></font>
    <span class="hljs-keyword">with</span> open(fname, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> fp:
        <span class="hljs-keyword">for</span> req <span class="hljs-keyword">in</span> parse_requirements(fp.read()):<font></font>
            extras = <span class="hljs-string">'[{}]'</span>.format(<span class="hljs-string">','</span>.join(req.extras)) <span class="hljs-keyword">if</span> req.extras <span class="hljs-keyword">else</span> <span class="hljs-string">''</span><font></font>
            requirements.append(<font></font>
                <span class="hljs-string">'{}{}{}'</span>.format(req.name, extras, req.specifier)<font></font>
            )<font></font>
    <span class="hljs-keyword">return</span> requirements<font></font>
<font></font>
setup(<font></font>
    name=module_name,<font></font>
    version=module.__version__,<font></font>
    author=module.__author__,<font></font>
    author_email=module.__email__,<font></font>
    license=module.__license__,<font></font>
    description=module.__doc__,<font></font>
    long_description=open(<span class="hljs-string">'README.rst'</span>).read(),<font></font>
    url=<span class="hljs-string">'https://github.com/alvassin/backendschool2019'</span>,<font></font>
    platforms=<span class="hljs-string">'all'</span>,<font></font>
    classifiers=[<font></font>
        <span class="hljs-string">'Intended Audience :: Developers'</span>,
        <span class="hljs-string">'Natural Language :: Russian'</span>,
        <span class="hljs-string">'Operating System :: MacOS'</span>,
        <span class="hljs-string">'Operating System :: POSIX'</span>,
        <span class="hljs-string">'Programming Language :: Python'</span>,
        <span class="hljs-string">'Programming Language :: Python :: 3'</span>,
        <span class="hljs-string">'Programming Language :: Python :: 3.8'</span>,
        <span class="hljs-string">'Programming Language :: Python :: Implementation :: CPython'</span><font></font>
    ],<font></font>
    python_requires=<span class="hljs-string">'&gt;=3.8'</span>,<font></font>
    packages=find_packages(exclude=[<span class="hljs-string">'tests'</span>]),<font></font>
    install_requires=load_requirements(<span class="hljs-string">'requirements.txt'</span>),<font></font>
    extras_require={<span class="hljs-string">'dev'</span>: load_requirements(<span class="hljs-string">'requirements.dev.txt'</span>)},<font></font>
    entry_points={<font></font>
        <span class="hljs-string">'console_scripts'</span>: [
            <span class="hljs-comment"># f-strings  setup.py   - </span>
            <span class="hljs-comment"># .</span>
            <span class="hljs-comment">#   ,     Python 3.8, </span>
            <span class="hljs-comment"># source distribution       </span>
            <span class="hljs-comment">#   Python.     </span>
            <span class="hljs-comment"># .</span>
            <span class="hljs-string">'{0}-api = {0}.api.__main__:main'</span>.format(module_name),
            <span class="hljs-string">'{0}-db = {0}.db.__main__:main'</span>.format(module_name)<font></font>
        ]<font></font>
    },<font></font>
    include_package_data=<span class="hljs-literal">True</span>
)</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用以下命令在开发模式下安装项目（在可编辑模式下，Python不会将整个软件包安装在文件夹中</font></font><code>site-packages</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而只会创建链接，因此对软件包文件所做的任何更改将立即可见）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#      extra- "dev"</span>
pip install -e <span class="hljs-string">'.[dev]'</span><font></font>
<font></font>
<span class="hljs-comment">#      </span>
pip install -e .</code></pre><br>
<a name="requirements"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何指定依赖版本？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当开发人员积极开发其程序包时，这非常好-积极修复其中的错误，出现新功能并更快地获得反馈。但是有时，依赖库中的更改不向后兼容，如果您事先不考虑，则会导致应用程序出错。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于每个相关程序包，您可以指定一个特定版本，例如</font></font><code>aiohttp==3.6.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这样就可以保证应用程序将使用经过测试的依赖库的那些版本专门构建。但是这种方法有一个缺点-如果开发人员在不影响向后兼容性的从属程序包中修复了严重的错误，则此修复程序将不会进入应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一种版本控制方式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语义版本控制</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，建议以以下格式提交版本</font></font><code>MAJOR.MINOR.PATCH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><code>MAJOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当添加向后不兼容的更改时增加；</font></font></li>
<li><code>MINOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在添加新功能并支持向后兼容性时增加；</font></font></li>
<li><code>PATCH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在添加具有向后兼容性支持的错误修复程序时增加。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果依赖包遵循这一方法（其中的作者在README和更新日志文件通常会报告），就足以固定的值</font></font><code>MAJOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>MINOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并限制了补丁版本的最低值：</font></font><code>&gt;= MAJOR.MINOR.PATCH, == MAJOR.MINOR.*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">〜=</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符实现此要求</font><font style="vertical-align: inherit;">。例如，它将</font></font><code>aiohttp~=3.6.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许为</font></font><code>aiohttp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本3.6.3（而不是3.7）</font><font style="vertical-align: inherit;">安装PIP </font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果指定依赖版本的间隔，这将提供另一个优势-依赖库之间不会存在版本冲突。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要开发需要不同依赖包的库，则不要允许它使用一个特定版本，而要允许一个间隔。</font><font style="vertical-align: inherit;">这样，库用户就可以更轻松地使用它（突然他们的应用程序需要相同的依赖包，但版本不同）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
语义版本控制只是软件包的作者和使用者之间的协议。</font><font style="vertical-align: inherit;">它不能保证作者编写的代码没有错误，也不能在新版软件包中犯错误。</font></font><br>
<br>
<a name="db"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库</font></font></h2><br>
<a name="dbstructure"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们设计方案</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
POST / imports处理程序的描述提供了一个有关居民信息的卸载示例：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上载范例</font></font></b>
                        <div class="spoiler_text"><pre><code class="json hljs">{
  <span class="hljs-attr">"citizens"</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">"citizen_id"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"town"</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">"street"</span>: <span class="hljs-string">" "</span>,
      <span class="hljs-attr">"building"</span>: <span class="hljs-string">"1675"</span>,
      <span class="hljs-attr">"apartment"</span>: <span class="hljs-number">7</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"  "</span>,
      <span class="hljs-attr">"birth_date"</span>: <span class="hljs-string">"26.12.1986"</span>,
      <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"male"</span>,
      <span class="hljs-attr">"relatives"</span>: [<span class="hljs-number">2</span>]<font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">"citizen_id"</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">"town"</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">"street"</span>: <span class="hljs-string">" "</span>,
      <span class="hljs-attr">"building"</span>: <span class="hljs-string">"1675"</span>,
      <span class="hljs-attr">"apartment"</span>: <span class="hljs-number">7</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"  "</span>,
      <span class="hljs-attr">"birth_date"</span>: <span class="hljs-string">"01.04.1997"</span>,
      <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"male"</span>,
      <span class="hljs-attr">"relatives"</span>: [<span class="hljs-number">1</span>]<font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">"citizen_id"</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">"town"</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">"street"</span>: <span class="hljs-string">" "</span>,
      <span class="hljs-attr">"building"</span>: <span class="hljs-string">"2"</span>,
      <span class="hljs-attr">"apartment"</span>: <span class="hljs-number">11</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"  "</span>,
      <span class="hljs-attr">"birth_date"</span>: <span class="hljs-string">"23.11.1986"</span>,
      <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"female"</span>,
      <span class="hljs-attr">"relatives"</span>: []<font></font>
    },<font></font>
    ...<font></font>
  ]<font></font>
}</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先想到的是存储所有关于居住在一个表中的信息</font></font><code>citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们的关系就由现场代表</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数列表形式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是这种方法有几个缺点</font></font></b>
                        <div class="spoiler_text"><ol>
<li>   <code>GET /imports/$import_id/citizens/birthdays</code>   ,      ,     <code>citizens</code>   .          <code>relatives</code>    <code>UNNEST</code>.<br>
<br>
     ,  <b>    10- </b>:<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <font></font>
    relations.citizen_id, <font></font>
    relations.relative_id, <font></font>
    date_part(<span class="hljs-string">'month'</span>, relatives.birth_date) <span class="hljs-keyword">as</span> relative_birth_month
<span class="hljs-keyword">FROM</span> (
	<span class="hljs-keyword">SELECT</span><font></font>
        citizens.import_id, <font></font>
        citizens.citizen_id,<font></font>
        <span class="hljs-keyword">UNNEST</span>(citizens.relatives) <span class="hljs-keyword">as</span> relative_id
	<span class="hljs-keyword">FROM</span> citizens
    <span class="hljs-keyword">WHERE</span> import_id = <span class="hljs-number">1</span>
) <span class="hljs-keyword">as</span> relations
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> citizens <span class="hljs-keyword">as</span> relatives <span class="hljs-keyword">ON</span>
    relations.import_id = relatives.import_id <span class="hljs-keyword">AND</span><font></font>
    relations.relative_id = relatives.citizen_id<font></font>
</code></pre><br>
 </li>
<li>    <b>    <code>relatives</code>   PostgreSQL</b>,   :    <code>relatives</code>     ,      .       (     )         .</li>
</ol></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我决定将工作所需的所有数据恢复为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三范式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并获得以下结构：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/pf/px/dipfpxxw142kafiect0yhrtt4uo.png"><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导入</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表</font><font style="vertical-align: inherit;">由一个自动递增的列组成</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">需要在表中创建外键检查</font></font><code>citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
 </li>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">citizen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表</font><font style="vertical-align: inherit;">存储</font><font style="vertical-align: inherit;">有关居民的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标量数据</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（除有关家庭关系的信息外的所有字段）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用对（</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>citizen_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">作为主键</font><font style="vertical-align: inherit;">，以确保</font></font><code>citizen_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架内</font><font style="vertical-align: inherit;">居民的唯一性</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外键</font></font><code>citizens.import_id -&gt; imports.import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可确保该字段</font></font><code>citizens.import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅包含现有卸载。</font></font><br>
 </li>
<li>  <b>relations</b>    <b> </b>. <br>
<br>
<b>     </b> (     ):           <code>citizens</code>  <code>relations</code>     .<br>
     (<code>import_id</code>, <code>citizen_id</code>, <code>relative_id</code>)  ,      <code>import_id</code>   <code>citizen_id</code>   c  <code>relative_id</code>. <br>
<br>
       : <code>(relations.import_id, relations.citizen_id) -&gt; (citizens.import_id, citizens.citizen_id)</code>  <code>(relations.import_id, relations.relative_id) -&gt; (citizens.import_id, citizens.citizen_id)</code>, ,        <code>citizen_id</code>   <code>relative_id</code>   .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该结构</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用PostgreSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保</font><b><font style="vertical-align: inherit;">数据</font></b><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">完整性</font></b><font style="vertical-align: inherit;">，使您可以</font><font style="vertical-align: inherit;">从数据库中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效地获取与亲戚的居民</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但</font><font style="vertical-align: inherit;">在通过竞争性查询更新有关居民的信息时</font><font style="vertical-align: inherit;">会</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受到种族条件的限制</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（我们将仔细研究PATCH处理程序的实现）。</font></font><br>
<br>
<a name="do_sqlalchemy"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述SQLAlchemy中的模式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我讨论了如何使用SQLAlchemy创建查询，您需要使用特殊对象描述数据库架构：使用</font><font style="vertical-align: inherit;">存储与数据库有关的所有元信息</font></font><code>sqlalchemy.Table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的注册表</font><font style="vertical-align: inherit;">来描述表</font><font style="vertical-align: inherit;">并链接到</font><font style="vertical-align: inherit;">表</font></font><code>sqlalchemy.MetaData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。顺便说一句，注册表</font></font><code>MetaData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅可以存储Python中描述的元信息，还可以以SQLAlchemy对象的形式表示数据库的真实状态。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此功能还允许Alembic比较条件并自动生成迁移代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一下，每个数据库都有其自己的默认约束命名方案。</font><font style="vertical-align: inherit;">为了避免浪费时间命名新的约束或搜索/调用要删除的约束，SQLAlchemy建议使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命名约定命名</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可以在注册表中定义它们</font></font><code>MetaData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个MetaData注册表并将命名模式传递给它</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"># analyzer/db/schema.py</span>
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> MetaData<font></font>
<font></font>
convention = {<font></font>
    <span class="hljs-string">'all_column_names'</span>: <span class="hljs-keyword">lambda</span> constraint, table: <span class="hljs-string">'_'</span>.join([<font></font>
        column.name <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> constraint.columns.values()<font></font>
    ]),<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-string">'ix'</span>: <span class="hljs-string">'ix__%(table_name)s__%(all_column_names)s'</span>,<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-string">'uq'</span>: <span class="hljs-string">'uq__%(table_name)s__%(all_column_names)s'</span>,<font></font>
<font></font>
    <span class="hljs-comment">#  CHECK-constraint-</span>
    <span class="hljs-string">'ck'</span>: <span class="hljs-string">'ck__%(table_name)s__%(constraint_name)s'</span>,<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-string">'fk'</span>: <span class="hljs-string">'fk__%(table_name)s__%(all_column_names)s__%(referred_table_name)s'</span>,<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-string">'pk'</span>: <span class="hljs-string">'pk__%(table_name)s'</span><font></font>
}<font></font>
metadata = MetaData(naming_convention=convention)</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果指定命名模式，则Alembic将在自动生成迁移过程中使用它们，并将根据它们命名所有约束。</font><font style="vertical-align: inherit;">将来，</font></font><code>MetaData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将需要</font><font style="vertical-align: inherit;">创建的注册表</font><font style="vertical-align: inherit;">来描述表：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们用SQLAlchemy对象描述数据库模式</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"># analyzer/db/schema.py</span>
<span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, unique<font></font>
<font></font>
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> (<font></font>
    Column, Date, Enum <span class="hljs-keyword">as</span> PgEnum, ForeignKey, ForeignKeyConstraint, Integer,<font></font>
    String, Table<font></font>
)<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@unique</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gender</span>(<span class="hljs-params">Enum</span>):</span>
    female = <span class="hljs-string">'female'</span>
    male = <span class="hljs-string">'male'</span><font></font>
<font></font>
<font></font>
imports_table = Table(<font></font>
    <span class="hljs-string">'imports'</span>,<font></font>
    metadata,<font></font>
    Column(<span class="hljs-string">'import_id'</span>, Integer, primary_key=<span class="hljs-literal">True</span>)<font></font>
)<font></font>
<font></font>
citizens_table = Table(<font></font>
    <span class="hljs-string">'citizens'</span>,<font></font>
    metadata,<font></font>
    Column(<span class="hljs-string">'import_id'</span>, Integer, ForeignKey(<span class="hljs-string">'imports.import_id'</span>),<font></font>
           primary_key=<span class="hljs-literal">True</span>),<font></font>
    Column(<span class="hljs-string">'citizen_id'</span>, Integer, primary_key=<span class="hljs-literal">True</span>),<font></font>
    Column(<span class="hljs-string">'town'</span>, String, nullable=<span class="hljs-literal">False</span>, index=<span class="hljs-literal">True</span>),<font></font>
    Column(<span class="hljs-string">'street'</span>, String, nullable=<span class="hljs-literal">False</span>),<font></font>
    Column(<span class="hljs-string">'building'</span>, String, nullable=<span class="hljs-literal">False</span>),<font></font>
    Column(<span class="hljs-string">'apartment'</span>, Integer, nullable=<span class="hljs-literal">False</span>),<font></font>
    Column(<span class="hljs-string">'name'</span>, String, nullable=<span class="hljs-literal">False</span>),<font></font>
    Column(<span class="hljs-string">'birth_date'</span>, Date, nullable=<span class="hljs-literal">False</span>),<font></font>
    Column(<span class="hljs-string">'gender'</span>, PgEnum(Gender, name=<span class="hljs-string">'gender'</span>), nullable=<span class="hljs-literal">False</span>),<font></font>
)<font></font>
<font></font>
relations_table = Table(<font></font>
    <span class="hljs-string">'relations'</span>,<font></font>
    metadata,<font></font>
    Column(<span class="hljs-string">'import_id'</span>, Integer, primary_key=<span class="hljs-literal">True</span>),<font></font>
    Column(<span class="hljs-string">'citizen_id'</span>, Integer, primary_key=<span class="hljs-literal">True</span>),<font></font>
    Column(<span class="hljs-string">'relative_id'</span>, Integer, primary_key=<span class="hljs-literal">True</span>),<font></font>
    ForeignKeyConstraint(<font></font>
        (<span class="hljs-string">'import_id'</span>, <span class="hljs-string">'citizen_id'</span>),<font></font>
        (<span class="hljs-string">'citizens.import_id'</span>, <span class="hljs-string">'citizens.citizen_id'</span>)<font></font>
    ),<font></font>
    ForeignKeyConstraint(<font></font>
        (<span class="hljs-string">'import_id'</span>, <span class="hljs-string">'relative_id'</span>),<font></font>
        (<span class="hljs-string">'citizens.import_id'</span>, <span class="hljs-string">'citizens.citizen_id'</span>)<font></font>
    ),<font></font>
)<font></font>
</code></pre></div>
                    </div><br>
<a name="db_alembic"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自订Alembic</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
描述数据库模式时，有必要生成迁移，但是为此，您首先需要配置Alembic，这也将在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5章中进行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用命令</font></font><code>alembic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您必须执行以下步骤：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装包： </font></font><code>pip install alembic</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化Alembic ：</font></font><code>cd analyzer &amp;&amp; alembic init db/alembic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此命令将创建一个配置文件</font></font><code>analyzer/alembic.ini</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和一个</font></font><code>analyzer/db/alembic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含以下内容</font><font style="vertical-align: inherit;">的文件夹</font><font style="vertical-align: inherit;">：</font></font><br>
 <ul>
<li> <code>env.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-每次启动Alembic时都会调用。</font><font style="vertical-align: inherit;">连接到Alembic注册表</font></font><code>sqlalchemy.MetaData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中包含对数据库所需状态的描述，并包含有关开始迁移的说明。</font></font><br>
 </li>
<li><code>script.py.mako</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -根据其生成迁移的模板。</font></font></li>
<li><code>versions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Alembic将在其中搜索（并生成）迁移文件的文件夹。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在alembic.ini文件中指定数据库地址：</font></font><br>
<br>
<pre><code class="plaintext hljs">; analyzer/alembic.ini<font></font>
[alembic] <font></font>
sqlalchemy.url = postgresql://user:hackme@localhost/analyzer</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定所需数据库状态的描述（注册表</font></font><code>sqlalchemy.MetaData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），以便Alembic可以自动生成迁移：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># analyzer/db/alembic/env.py</span>
<span class="hljs-keyword">from</span> analyzer.db <span class="hljs-keyword">import</span> schema<font></font>
target_metadata = schema.metadata</code></pre></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alembic已配置并且可以使用，但在我们的情况下，此配置有几个缺点：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该实用程序</font><font style="vertical-align: inherit;">在当前工作目录中</font></font><code>alembic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搜索</font></font><code>alembic.ini</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您</font></font><code>alembic.ini</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以指定命令行参数的</font><font style="vertical-align: inherit;">路径</font><font style="vertical-align: inherit;">，但这很不方便：我希望能够从任何文件夹中调用命令而无需其他参数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要将Alembic配置为与特定数据库一起使用，您需要更改文件</font></font><code>alembic.ini</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，为环境变量和/或命令行参数指定数据库设置会更加方便</font></font><code>--pg-url</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该实用程序</font></font><code>alembic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的名称与我们的服务名称并没有很好的关联（用户实际上可能根本没有Python，并且对Alembic一无所知）。</font><font style="vertical-align: inherit;">例如，如果服务的所有可执行命令都具有公共前缀，则对于最终用户将更加方便</font></font><code>analyzer-*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些问题可以用一个小的包装纸解决。 </font></font><code>analyzer/db/__main__.py:</code><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alembic使用标准模块来处理命令行参数</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">argparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它允许您</font></font><code>--pg-url</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从环境变量中</font><font style="vertical-align: inherit;">添加具有</font><font style="vertical-align: inherit;">默认值</font><font style="vertical-align: inherit;">的可选参数</font></font><code>ANALYZER_PG_URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编码</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> alembic.config <span class="hljs-keyword">import</span> CommandLine, Config
<span class="hljs-keyword">from</span> analyzer.utils.pg <span class="hljs-keyword">import</span> DEFAULT_PG_URL<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><font></font>
    alembic = CommandLine()<font></font>
    alembic.parser.add_argument(<font></font>
        <span class="hljs-string">'--pg-url'</span>, default=os.getenv(<span class="hljs-string">'ANALYZER_PG_URL'</span>, DEFAULT_PG_URL),<font></font>
        help=<span class="hljs-string">'Database URL [env var: ANALYZER_PG_URL]'</span><font></font>
    )<font></font>
    options = alembic.parser.parse_args()<font></font>
<font></font>
    <span class="hljs-comment">#    Alembic</span><font></font>
    config = Config(file_=options.config, ini_section=options.name,<font></font>
                    cmd_opts=options)<font></font>
<font></font>
    <span class="hljs-comment">#   sqlalchemy.url   Alembic</span>
    config.set_main_option(<span class="hljs-string">'sqlalchemy.url'</span>, options.pg_url)<font></font>
<font></font>
    <span class="hljs-comment">#   alembic</span><font></font>
    exit(alembic.run_cmd(config, options))<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    main()</code></pre></div>
                    </div></li>
<li><font style="vertical-align: inherit;"></font><code>alembic.ini</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以相对于可执行文件的位置而不是用户的当前工作目录来计算</font><font style="vertical-align: inherit;">文件的路径</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编码</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> alembic.config <span class="hljs-keyword">import</span> CommandLine, Config
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<font></font>
<font></font>
<font></font>
PROJECT_PATH = Path(__file__).parent.parent.resolve()<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><font></font>
    alembic = CommandLine()<font></font>
    options = alembic.parser.parse_args()<font></font>
<font></font>
    <span class="hljs-comment">#     (alembic.ini),   </span>
    <span class="hljs-comment">#    </span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isabs(options.config):<font></font>
        options.config = os.path.join(PROJECT_PATH, options.config)<font></font>
<font></font>
    <span class="hljs-comment">#    Alembic</span><font></font>
    config = Config(file_=options.config, ini_section=options.name,<font></font>
                    cmd_opts=options)<font></font>
<font></font>
    <span class="hljs-comment">#      alembic   (,  alembic</span>
    <span class="hljs-comment">#   env.py,       )</span>
    alembic_location = config.get_main_option(<span class="hljs-string">'script_location'</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isabs(alembic_location):<font></font>
        config.set_main_option(<span class="hljs-string">'script_location'</span>,<font></font>
                               os.path.join(PROJECT_PATH, alembic_location))<font></font>
<font></font>
    <span class="hljs-comment">#   alembic</span><font></font>
    exit(alembic.run_cmd(config, options))<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    main()</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备好</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于管理数据库状态</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">实用程序后</font></a><font style="vertical-align: inherit;">，可以将其注册</font></font><code>setup.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为可执行命令，并使用最终用户可以理解的名称，例如</font></font><code>analyzer-db</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在setup.py中注册可执行命令</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<font></font>
<font></font>
setup(..., entry_points={<font></font>
    <span class="hljs-string">'console_scripts'</span>: [
        <span class="hljs-string">'analyzer-db = analyzer.db.__main__:main'</span><font></font>
    ]<font></font>
})<font></font>
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重新安装模块后，将生成一个文件，</font></font><code>env/bin/analyzer-db</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且该命令</font></font><code>analyzer-db</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将变为可用：</font></font><br>
<br>
<pre><code class="bash hljs">$ pip install -e <span class="hljs-string">'.[dev]'</span></code></pre><br>
<a name="db_alembic_migrations"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们产生移民</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了生成迁移，需要两个状态：所需状态（我们用SQLAlchemy对象描述了状态）和实际状态（在我们的例子中，数据库为空）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为提高Postgres的最简单方法是使用Docker，为方便起见，我添加了一个命令</font></font><code>make postgres</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该命令</font><font style="vertical-align: inherit;">在后台使用PostgreSQL在端口5432上运行容器：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提高PostgreSQL并生成迁移</font></font></b>
                        <div class="spoiler_text"><pre><code class="bash hljs">$ make postgres<font></font>
...<font></font>
$ analyzer-db revision --message=<span class="hljs-string">"Initial"</span> --autogenerate<font></font>
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.<font></font>
INFO  [alembic.runtime.migration] Will assume transactional DDL.<font></font>
INFO  [alembic.autogenerate.compare] Detected added table <span class="hljs-string">'imports'</span>
INFO  [alembic.autogenerate.compare] Detected added table <span class="hljs-string">'citizens'</span>
INFO  [alembic.autogenerate.compare] Detected added index <span class="hljs-string">'ix__citizens__town'</span> on <span class="hljs-string">'['</span>town<span class="hljs-string">']'</span>
INFO  [alembic.autogenerate.compare] Detected added table <span class="hljs-string">'relations'</span>
  Generating /Users/alvassin/Work/backendschool2019/analyzer/db/alembic/versions/d5f704ed4610_initial.py ...  <span class="hljs-keyword">done</span></code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alembic通常在生成迁移的日常工作中做得很好，但是我想提请注意以下方面：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在创建的表中指定的用户数据类型是自动创建的（在我们的示例中为- </font></font><code>gender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但是</font></font><code>downgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会生成</font><font style="vertical-align: inherit;">删除它们的代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您应用，回滚，然后再次应用迁移，这将导致错误，因为指定的数据类型已经存在。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在降级方法中删除性别数据类型</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> alembic <span class="hljs-keyword">import</span> op
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Enum<font></font>
<font></font>
GenderType = Enum(<span class="hljs-string">'female'</span>, <span class="hljs-string">'male'</span>, name=<span class="hljs-string">'gender'</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">upgrade</span>():</span><font></font>
    ...<font></font>
    <span class="hljs-comment">#      GenderType   </span>
    op.create_table(<span class="hljs-string">'citizens'</span>, ...,<font></font>
                    Column(<span class="hljs-string">'gender'</span>, GenderType, nullable=<span class="hljs-literal">False</span>))<font></font>
    ...<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downgrade</span>():</span>
    op.drop_table(<span class="hljs-string">'citizens'</span>)<font></font>
<font></font>
    <span class="hljs-comment">#       </span>
    GenderType.drop(op.get_bind())</code></pre></div>
                    </div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在该方法中，</font></font><code>downgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时可以删除某些操作（如果我们删除整个表，则不能单独删除其索引）：</font></font><br>
 <br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downgrade</span>():</span>
op.drop_table(<span class="hljs-string">'relations'</span>)<font></font>
<font></font>
<span class="hljs-comment">#      citizens,    </span>
<span class="hljs-comment">#    </span>
op.drop_index(op.f(<span class="hljs-string">'ix__citizens__town'</span>), table_name=<span class="hljs-string">'citizens'</span>)<font></font>
op.drop_table(<span class="hljs-string">'citizens'</span>)<font></font>
op.drop_table(<span class="hljs-string">'imports'</span>)</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
固定并准备好迁移后，我们将其应用：</font></font><br>
<br>
<pre><code class="bash hljs">$ analyzer-db upgrade head<font></font>
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.<font></font>
INFO  [alembic.runtime.migration] Will assume transactional DDL.<font></font>
INFO  [alembic.runtime.migration] Running upgrade  -&gt; d5f704ed4610, Initial</code></pre><br>
<a name="application"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始创建处理程序之前，必须配置aiohttp应用程序。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您查看aiohttp快速入门，则可以编写如下内容</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> logging<font></font>
<font></font>
<span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
    <span class="hljs-comment">#  </span><font></font>
    logging.basicConfig(level=logging.DEBUG)<font></font>
<font></font>
    <span class="hljs-comment">#  </span><font></font>
    app = web.Application()<font></font>
<font></font>
    <span class="hljs-comment">#  </span><font></font>
    app.router.add_route(...)<font></font>
<font></font>
    <span class="hljs-comment">#  </span><font></font>
    web.run_app(app)<font></font>
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此代码引发了许多问题，并具有许多缺点：</font></font><br>
<br>
<ul>
<li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何配置应用程序？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少必须指定用于连接客户端的主机和端口，以及用于连接数据库的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我真的很想在模块的帮助下解决此问题</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ConfigArgParse</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：它扩展了标准</font><font style="vertical-align: inherit;">模块</font><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>argparse</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并允许使用命令行参数，环境变量（对于配置Docker容器必不可少的）甚至配置文件（以及组合这些方法）进行配置。</font><font style="vertical-align: inherit;">使用</font></font><code>ConfigArgParse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，您还可以验证应用程序配置参数的值。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用ConfigArgParse处理参数的示例</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web
<span class="hljs-keyword">from</span> configargparse <span class="hljs-keyword">import</span> ArgumentParser, ArgumentDefaultsHelpFormatter<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.utils.argparse <span class="hljs-keyword">import</span> positive_int<font></font>
<font></font>
parser = ArgumentParser(<font></font>
    <span class="hljs-comment">#        ANALYZER_,</span>
    <span class="hljs-comment">#  ANALYZER_API_ADDRESS  ANALYZER_API_PORT</span>
    auto_env_var_prefix=<span class="hljs-string">'ANALYZER_'</span>,<font></font>
<font></font>
    <span class="hljs-comment">#     </span><font></font>
    formatter_class=ArgumentDefaultsHelpFormatter<font></font>
)<font></font>
<font></font>
parser.add_argument(<span class="hljs-string">'--api-address'</span>, default=<span class="hljs-string">'0.0.0.0'</span>,<font></font>
                    help=<span class="hljs-string">'IPv4/IPv6 address API server would listen on'</span>)<font></font>
<font></font>
<span class="hljs-comment">#      </span>
parser.add_argument(<span class="hljs-string">'--api-port'</span>, type=positive_int, default=<span class="hljs-number">8081</span>,<font></font>
                    help=<span class="hljs-string">'TCP port API server would listen on'</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
    <span class="hljs-comment">#   ,     </span>
    <span class="hljs-comment">#  ,    </span><font></font>
    args = parser.parse_args()<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    app = web.Application()<font></font>
    web.run_app(app, host=args.api_address, port=args.api_port)<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    main()</code></pre></div>
                    </div><br>
, <code>ConfigArgParse</code>,   <code>argparse</code>,           (     <code>-h</code>  <code>--help</code>).       :<br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"></b>
                        <div class="spoiler_text"><pre><code class="bash hljs">$ python __main__.py --<span class="hljs-built_in">help</span><font></font>
usage: __main__.py [-h] [--api-address API_ADDRESS] [--api-port API_PORT]<font></font>
<font></font>
If an arg is specified <span class="hljs-keyword">in</span> more than one place, <span class="hljs-keyword">then</span> commandline values override environment variables <span class="hljs-built_in">which</span> override defaults.<font></font>
<font></font>
optional arguments:<font></font>
  -h, --<span class="hljs-built_in">help</span>            show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span><font></font>
  --api-address API_ADDRESS<font></font>
                        IPv4/IPv6 address API server would listen on [env var: ANALYZER_API_ADDRESS] (default: 0.0.0.0)<font></font>
  --api-port API_PORT   TCP port API server would listen on [env var: ANALYZER_API_PORT] (default: 8081)</code></pre></div>
                    </div></li>
<li>             — ,    «»     .          ,  <strong>     </strong>. <br>
<br>
    <code>os.environ.clear()</code>,  Python            (,      <code>asyncio</code>?),        ,   <code>ConfigArgParser</code>.<br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable
<span class="hljs-keyword">from</span> configargparse <span class="hljs-keyword">import</span> ArgumentParser
<span class="hljs-keyword">from</span> yarl <span class="hljs-keyword">import</span> URL<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.api.app <span class="hljs-keyword">import</span> create_app
<span class="hljs-keyword">from</span> analyzer.utils.pg <span class="hljs-keyword">import</span> DEFAULT_PG_URL<font></font>
<font></font>
ENV_VAR_PREFIX = <span class="hljs-string">'ANALYZER_'</span><font></font>
<font></font>
parser = ArgumentParser(auto_env_var_prefix=ENV_VAR_PREFIX)<font></font>
parser.add_argument(<span class="hljs-string">'--pg-url'</span>, type=URL, default=URL(DEFAULT_PG_URL),<font></font>
                   help=<span class="hljs-string">'URL to use to connect to the database'</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear_environ</span>(<span class="hljs-params">rule: Callable</span>):</span>
    <span class="hljs-string">"""
      ,     
     rule
    """</span>
    <span class="hljs-comment">#   os.environ    tuple,    </span>
    <span class="hljs-comment"># os.environ   </span>
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> filter(rule, tuple(os.environ)):<font></font>
        os.environ.pop(name)<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
    <span class="hljs-comment">#  </span><font></font>
    args = parser.parse_args()<font></font>
<font></font>
    <span class="hljs-comment">#      ANALYZER_</span>
    clear_environ(<span class="hljs-keyword">lambda</span> i: i.startswith(ENV_VAR_PREFIX))<font></font>
<font></font>
    <span class="hljs-comment">#  </span><font></font>
    app = create_app(args)<font></font>
    ...<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    main()</code></pre></div>
                    </div></li>
<li> <strong>   stderr/      .</strong><br>
<br>
 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 9</a> ,    <code>logging.basicConfig()</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>   stderr</code></a>.<br>
<br>
       ,       .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>   aiomisc.<br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">    aiomisc</b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> logging<font></font>
<font></font>
<span class="hljs-keyword">from</span> aiomisc.log <span class="hljs-keyword">import</span> basic_config<font></font>
<font></font>
basic_config(logging.DEBUG, buffered=<span class="hljs-literal">True</span>)    
</code></pre></div>
                    </div></li>
<li> <strong>  ,     </strong>    ?    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>fork</code></a>     ,           (,  Windows   ).<br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv<font></font>
<font></font>
<span class="hljs-keyword">import</span> forklib
<span class="hljs-keyword">from</span> aiohttp.web <span class="hljs-keyword">import</span> Application, run_app
<span class="hljs-keyword">from</span> aiomisc <span class="hljs-keyword">import</span> bind_socket
<span class="hljs-keyword">from</span> setproctitle <span class="hljs-keyword">import</span> setproctitle<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
    sock = bind_socket(address=<span class="hljs-string">'0.0.0.0'</span>, port=<span class="hljs-number">8081</span>, proto_name=<span class="hljs-string">'http'</span>)<font></font>
    setproctitle(<span class="hljs-string">f'[Master] <span class="hljs-subst">{os.path.basename(argv[<span class="hljs-number">0</span>])}</span>'</span>)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>():</span>
        setproctitle(<span class="hljs-string">f'[Worker] <span class="hljs-subst">{os.path.basename(argv[<span class="hljs-number">0</span>])}</span>'</span>)<font></font>
        app = Application()<font></font>
        run_app(app, sock=sock)<font></font>
<font></font>
    forklib.fork(os.cpu_count(), worker, auto_restart=<span class="hljs-literal">True</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    main()<font></font>
</code></pre></div>
                    </div></li>
<li>    <strong>   -    </strong>?  ,      (   —    )    ,      <code>nobody</code>.      —     .<br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pwd<font></font>
<font></font>
<span class="hljs-keyword">from</span> aiohttp.web <span class="hljs-keyword">import</span> run_app
<span class="hljs-keyword">from</span> aiomisc <span class="hljs-keyword">import</span> bind_socket<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.api.app <span class="hljs-keyword">import</span> create_app<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
    <span class="hljs-comment">#  </span>
    sock = bind_socket(address=<span class="hljs-string">'0.0.0.0'</span>, port=<span class="hljs-number">8085</span>, proto_name=<span class="hljs-string">'http'</span>)<font></font>
<font></font>
    user = pwd.getpwnam(<span class="hljs-string">'nobody'</span>)<font></font>
    os.setgid(user.pw_gid)<font></font>
    os.setuid(user.pw_uid)<font></font>
<font></font>
    app = create_app(...)<font></font>
    run_app(app, sock=sock)<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    main()</code></pre></div>
                    </div></li>
<li>            <code>create_app</code>,         .</li>
</ul><br>
<a name="serialization"></a><h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有成功的处理程序响应都将以JSON格式返回。</font><font style="vertical-align: inherit;">客户也可以方便地以序列化形式接收有关错误的信息（例如，查看哪些字段未通过验证）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该文档</font></font><code>aiohttp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了一种方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.aio"><code>json_response</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该方法</font><font style="vertical-align: inherit;">接受一个对象，将其序列化为JSON，然后返回一个</font><font style="vertical-align: inherit;">内部</font></font><code>aiohttp.web.Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含标头</font></font><code>Content-Type: application/json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和序列化数据</font><font style="vertical-align: inherit;">的新对象</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何使用json_response序列化数据</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> aiohttp.web <span class="hljs-keyword">import</span> Application, View, run_app
<span class="hljs-keyword">from</span> aiohttp.web_response <span class="hljs-keyword">import</span> json_response<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeView</span>(<span class="hljs-params">View</span>):</span>
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> json_response({<span class="hljs-string">'hello'</span>: <span class="hljs-string">'world'</span>})<font></font>
<font></font>
<font></font>
app = Application()<font></font>
app.router.add_route(<span class="hljs-string">'*'</span>, <span class="hljs-string">'/hello'</span>, SomeView)<font></font>
run_app(app)<font></font>
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是还有另一种方法：aiohttp允许您在注册表中为特定类型的响应数据注册任意串行器</font></font><code>aiohttp.PAYLOAD_REGISTRY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，您可以</font></font><code>aiohttp.JsonPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapping</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的对象</font><font style="vertical-align: inherit;">指定序列化</font><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，处理程序返回一个</font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数为的响应数据</font><font style="vertical-align: inherit;">的对象就足够了</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">aiohttp将找到与数据类型匹配的序列化器并序列化响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了在一个地方描述对象的序列化这一事实之外，这种方法还更加灵活-它使您可以实现非常有趣的解决方案（我们将在处理程序中考虑其中一种用例</font></font><code>GET /imports/$import_id/citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何使用aiohttp.PAYLOAD_REGISTRY序列化数据</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MappingProxyType
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Mapping<font></font>
<font></font>
<span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> PAYLOAD_REGISTRY, JsonPayload
<span class="hljs-keyword">from</span> aiohttp.web <span class="hljs-keyword">import</span> run_app, Application, Response, View<font></font>
<font></font>
PAYLOAD_REGISTRY.register(JsonPayload, (Mapping, MappingProxyType))<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeView</span>(<span class="hljs-params">View</span>):</span>
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> Response(body={<span class="hljs-string">'hello'</span>: <span class="hljs-string">'world'</span>})<font></font>
<font></font>
<font></font>
app = Application()<font></font>
app.router.add_route(<span class="hljs-string">'*'</span>, <span class="hljs-string">'/hello'</span>, SomeView)<font></font>
run_app(app)<font></font>
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的是要了解</font></font><code>json_response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，像一样</font></font><code>aiohttp.JsonPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它们使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>json.dumps</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法序列化复杂数据类型</font><font style="vertical-align: inherit;">的标准</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，例如，</font></font><code>datetime.date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>asyncpg.Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>asyncpg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据库作为此类的实例返回记录）。</font><font style="vertical-align: inherit;">而且，某些复杂的对象可能包含其他对象：在数据库的一条记录中可能有一个type字段</font></font><code>datetime.date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python开发人员已经解决了这个问题：该方法</font></font><code>json.dumps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您使用参数</font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定需要序列化不熟悉的对象时调用的函数。</font><font style="vertical-align: inherit;">该函数应将不熟悉的对象转换为可以序列化json模块的类型。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何扩展JsonPayload以序列化任意对象</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial, singledispatch
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Any<font></font>
<font></font>
<span class="hljs-keyword">from</span> aiohttp.payload <span class="hljs-keyword">import</span> JsonPayload <span class="hljs-keyword">as</span> BaseJsonPayload
<span class="hljs-keyword">from</span> aiohttp.typedefs <span class="hljs-keyword">import</span> JSONEncoder<font></font>
<font></font>
<span class="hljs-meta">@singledispatch</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span>(<span class="hljs-params">value</span>):</span>
    <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">f'Unserializable value: <span class="hljs-subst">{value!r}</span>'</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@convert.register(Record)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_asyncpg_record</span>(<span class="hljs-params">value: Record</span>):</span>
    <span class="hljs-string">"""
        , 
    asyncpg
    """</span>
    <span class="hljs-keyword">return</span> dict(value)<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@convert.register(date)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_date</span>(<span class="hljs-params">value: date</span>):</span>
    <span class="hljs-string">"""
       date      —  
      .     
      ..
    """</span>
    <span class="hljs-keyword">return</span> value.strftime(<span class="hljs-string">'%d.%m.%Y'</span>)<font></font>
    <font></font>
 <font></font>
dumps = partial(json.dumps, default=convert)<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonPayload</span>(<span class="hljs-params">BaseJsonPayload</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,
                 value: Any,
                 encoding: str = <span class="hljs-string">'utf-8'</span>,
                 content_type: str = <span class="hljs-string">'application/json'</span>,
                 dumps: JSONEncoder = dumps,
                 *args: Any,
                 **kwargs: Any</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        super().__init__(value, encoding, content_type, dumps, *args, **kwargs)</code></pre></div>
                    </div><br>
<a name="handlers"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aiohttp允许您使用异步函数和类来实现处理程序。</font><font style="vertical-align: inherit;">类具有更大的可扩展性：首先，可以将属于一个处理程序的代码放在一个位置，其次，类允许您使用继承来消除代码重复（例如，每个处理程序都需要数据库连接）。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序基类</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> aiohttp.web_urldispatcher <span class="hljs-keyword">import</span> View
<span class="hljs-keyword">from</span> asyncpgsa <span class="hljs-keyword">import</span> PG<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseView</span>(<span class="hljs-params">View</span>):</span><font></font>
    URL_PATH: str<font></font>
<font></font>
<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pg</span>(<span class="hljs-params">self</span>) -&gt; PG:</span>
        <span class="hljs-keyword">return</span> self.request.app[<span class="hljs-string">'pg'</span>]
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于很难读取一个大文件，因此我决定将处理程序拆分为多个文件。</font><font style="vertical-align: inherit;">小文件会导致弱连接，例如，如果处理程序中有环导入，则意味着实体的组成可能有问题。</font></font><br>
<br>
<a name="imports_handler"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开机自检/导入</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
输入处理程序接收带有有关居民数据的json。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许的最大请求大小</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在aiohttp由选项控制</font></font><code>client_max_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://docs.aiohttp.org/en/stable/web_reference.html&amp;usg=ALkJrhiOfjnJYTbtcwcLp-BtL7K1apuyzg#aio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是2 MB默认</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果超出限制，则aiohttp将返回状态为413：请求实体太大错误的HTTP响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，具有最长行和数字的正确json重约63兆字节，因此需要扩展对请求大小的限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，您需要</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查并反序列化数据</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果它们不正确，则需要返回HTTP响应</font></font><code>400: Bad Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我需要两个方案</font></font><code>Marhsmallow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。第一个</font></font><code>CitizenSchema</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，检查每个居民的数据，并将生日快乐字符串反序列化为对象</font></font><code>datetime.date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有必填字段的数据类型，格式和可用性；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺乏陌生的田野；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出生日期必须以格式表示，</font></font><code>DD.MM.YYYY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且从将来起就没有任何意义；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个居民的亲属列表必须包含此上载中存在的居民的唯一标识符。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二种方案</font></font><code>ImportSchema</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是整体检查卸载：</font></font><br>
<br>
<ul>
<li><code>citizen_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 卸货中的每个居民应是唯一的；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家庭关系应该是双向的（如果1号居民在亲戚名单中有2号居民，那么2号居民也必须有1号亲戚）。</font></font></li>
</ul><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果数据正确，则必须</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用新的唯一</font><strong><font style="vertical-align: inherit;">数据将其添加到数据库中</font></strong></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要添加数据，您将需要在不同的表中执行几个查询。</font><font style="vertical-align: inherit;">为了避免在发生错误或异常（例如，断开未收到完整响应的客户端时，aiohttp </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://docs.aio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会抛出CancelledError异常</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）时，</font><font style="vertical-align: inherit;">部分避免在数据库中部分添加数据</font><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须使用transaction</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有必要将数据部分添加到表中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为在对PostgreSQL的一次查询中，参数不能超过32,767。</font><font style="vertical-align: inherit;">表中有</font></font><code>citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9个字段。</font><font style="vertical-align: inherit;">因此，对于1个查询，只能将32,767 / 9 = 3,640行插入到此表中，并且在一次上载中，最多可容纳10,000个居民。</font></font><br>
<br>
<a name="citizens_handler"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序返回所有居民，以指定的进行卸载</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果指定的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上传不存在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则必须返回404：未找到HTTP响应。</font><font style="vertical-align: inherit;">对于需要现有卸载的处理程序，此行为似乎很常见，因此我将验证代码放入了单独的类中。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带卸载处理程序的基类</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> aiohttp.web_exceptions <span class="hljs-keyword">import</span> HTTPNotFound
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> select, exists<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.db.schema <span class="hljs-keyword">import</span> imports_table<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImportView</span>(<span class="hljs-params">BaseView</span>):</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">import_id</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> int(self.request.match_info.get(<span class="hljs-string">'import_id'</span>))<font></font>
<font></font>
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_import_exists</span>(<span class="hljs-params">self</span>):</span><font></font>
        query = select([<font></font>
            exists().where(imports_table.c.import_id == self.import_id)<font></font>
        ])<font></font>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">await</span> self.pg.fetchval(query):
            <span class="hljs-keyword">raise</span> HTTPNotFound()
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要获取每个居民的亲属列表，您将需要在</font></font><code>LEFT JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表</font></font><code>citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与表之间进行</font></font><code>relations</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汇总，汇总</font></font><code>relations.relative_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">分组</font><font style="vertical-align: inherit;">的字段</font></font><code>citizen_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果居民没有亲戚，那么他</font></font><code>LEFT JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将在该字段中为他返回</font></font><code>relations.relative_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，</font></font><code>NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且由于汇总，亲戚列表将如下所示</font></font><code>[NULL]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要修复此错误值，我使用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array_remove</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据库以某种格式存储日期</font></font><code>YYYY-MM-DD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是我们需要一种格式</font></font><code>DD.MM.YYYY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从技术上讲，您可以在序列化响应时使用SQL查询或在Python端格式化日期</font></font><code>json.dumps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（asyncpg将字段值</font></font><code>birth_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为类的实例</font><font style="vertical-align: inherit;">返回</font></font><code>datetime.date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我选择在Python端进行序列化，因为它</font></font><code>birth_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><code>datetime.date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目中</font><font style="vertical-align: inherit;">唯一</font><font style="vertical-align: inherit;">具有单一格式的对象（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“序列化数据”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一节</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管处理器执行了两个请求（检查是否存在卸载和居民列表请求），</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是并不需要使用事务</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。缺省情况下，PostgreSQL使用隔离级别，</font></font><code>READ COMMITTED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使在一个事务中，对其他已成功完成的事务的所有更改也将可见（添加新行，更改现有行）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文本视图中最大的上传可能需要约63兆字节-这是很多，尤其是考虑到可能同时到达多个接收数据的请求时。</font><font style="vertical-align: inherit;">有一种相当有趣的方法</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游标</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据库中获取数据</font><font style="vertical-align: inherit;">并将其分部分发送给客户端</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我们需要实现两个对象：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据库返回记录的</font></font><code>SelectQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">对象</font></font><code>AsyncIterable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在第一次调用时，它连接到数据库，打开一个事务并创建一个游标；在进一步的迭代中，它从数据库中返回记录。</font><font style="vertical-align: inherit;">它由处理程序返回。</font></font><br>
 <br>
 <div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SelectQuery代码</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> AsyncIterable
<span class="hljs-keyword">from</span> asyncpgsa.transactionmanager <span class="hljs-keyword">import</span> ConnectionTransactionContextManager
<span class="hljs-keyword">from</span> sqlalchemy.sql <span class="hljs-keyword">import</span> Select<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectQuery</span>(<span class="hljs-params">AsyncIterable</span>):</span>
    <span class="hljs-string">"""
    ,     PostgreSQL   
    ,  ,    
    """</span>
    PREFETCH = <span class="hljs-number">500</span><font></font>
<font></font>
    __slots__ = (<font></font>
        <span class="hljs-string">'query'</span>, <span class="hljs-string">'transaction_ctx'</span>, <span class="hljs-string">'prefetch'</span>, <span class="hljs-string">'timeout'</span><font></font>
    )<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, query: Select,
                 transaction_ctx: ConnectionTransactionContextManager,
                 prefetch: int = None,
                 timeout: float = None</span>):</span><font></font>
        self.query = query<font></font>
        self.transaction_ctx = transaction_ctx<font></font>
        self.prefetch = prefetch <span class="hljs-keyword">or</span> self.PREFETCH<font></font>
        self.timeout = timeout<font></font>
<font></font>
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__aiter__</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.transaction_ctx <span class="hljs-keyword">as</span> conn:<font></font>
            cursor = conn.cursor(self.query, prefetch=self.prefetch,<font></font>
                                 timeout=self.timeout)<font></font>
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cursor:
                <span class="hljs-keyword">yield</span> row
</code></pre></div>
                    </div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font></font><code>AsyncGenJSONListPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在异步生成器上进行迭代，将数据从异步生成器序列化为JSON并将数据分批发送给客户端的序列化器。</font><font style="vertical-align: inherit;">它被注册</font></font><code>aiohttp.PAYLOAD_REGISTRY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为对象的序列化器</font></font><code>AsyncIterable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
 <br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncGenJSONListPayload代码</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<font></font>
<font></font>
<span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> Payload<font></font>
<font></font>
<font></font>
<span class="hljs-comment"># ,    JSON  asyncpg.Record  datetime.date</span>
dumps = partial(json.dumps, default=convert, ensure_ascii=<span class="hljs-literal">False</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncGenJSONListPayload</span>(<span class="hljs-params">Payload</span>):</span>
    <span class="hljs-string">"""
       AsyncIterable,     
     JSON   
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value, encoding: str = <span class="hljs-string">'utf-8'</span>,
                 content_type: str = <span class="hljs-string">'application/json'</span>,
                 root_object: str = <span class="hljs-string">'data'</span>,
                 *args, **kwargs</span>):</span><font></font>
        self.root_object = root_object<font></font>
        super().__init__(value, content_type=content_type, encoding=encoding,<font></font>
                         *args, **kwargs)<font></font>
<font></font>
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">self, writer</span>):</span>
        <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">await</span> writer.write(<font></font>
            (<span class="hljs-string">'{"%s":['</span> % self.root_object).encode(self._encoding)<font></font>
        )<font></font>
<font></font>
        first = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self._value:
            <span class="hljs-comment">#      </span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> first:
                <span class="hljs-keyword">await</span> writer.write(<span class="hljs-string">b','</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                first = <span class="hljs-literal">False</span><font></font>
<font></font>
            <span class="hljs-keyword">await</span> writer.write(dumps(row).encode(self._encoding))<font></font>
<font></font>
        <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">await</span> writer.write(<span class="hljs-string">b']}'</span>)</code></pre></div>
                    </div></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，在处理程序中，可以创建一个对象</font></font><code>SelectQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">向其</font><font style="vertical-align: inherit;">传递一个SQL查询和一个函数以打开事务，然后将其返回给</font></font><code>Response body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序代码</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"># analyzer/api/handlers/citizens.py</span>
<span class="hljs-keyword">from</span> aiohttp.web_response <span class="hljs-keyword">import</span> Response
<span class="hljs-keyword">from</span> aiohttp_apispec <span class="hljs-keyword">import</span> docs, response_schema<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.api.schema <span class="hljs-keyword">import</span> CitizensResponseSchema
<span class="hljs-keyword">from</span> analyzer.db.schema <span class="hljs-keyword">import</span> citizens_table <span class="hljs-keyword">as</span> citizens_t
<span class="hljs-keyword">from</span> analyzer.utils.pg <span class="hljs-keyword">import</span> SelectQuery<font></font>
<font></font>
<span class="hljs-keyword">from</span> .query <span class="hljs-keyword">import</span> CITIZENS_QUERY
<span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> BaseImportView<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitizensView</span>(<span class="hljs-params">BaseImportView</span>):</span>
    URL_PATH = <span class="hljs-string">r'/imports/{import_id:\d+}/citizens'</span><font></font>
<font></font>
<span class="hljs-meta">    @docs(summary='    ')</span>
<span class="hljs-meta">    @response_schema(CitizensResponseSchema())</span>
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">await</span> self.check_import_exists()<font></font>
<font></font>
        query = CITIZENS_QUERY.where(<font></font>
            citizens_t.c.import_id == self.import_id<font></font>
        )<font></font>
        body = SelectQuery(query, self.pg.transaction())<font></font>
        <span class="hljs-keyword">return</span> Response(body=body)
</code></pre></div>
                    </div><br>
<code>aiohttp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font><font style="vertical-align: inherit;">为</font><font style="vertical-align: inherit;">注册表</font><font style="vertical-align: inherit;">中类型的对象</font><font style="vertical-align: inherit;">检测已注册的</font></font><code>aiohttp.PAYLOAD_REGISTRY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列化</font></font><code>AsyncGenJSONListPayload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序</font></font><code>AsyncIterable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，序列化程序将遍历该对象</font></font><code>SelectQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将数据发送到客户端。在第一个调用中，对象</font></font><code>SelectQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收到数据库的连接，打开一个事务并创建一个游标；在进一步的迭代中，它将使用游标从数据库接收数据并逐行返回它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法不允许每次请求都为全部数据分配内存，但是它具有特殊性：如果发生错误，则应用程序将无法将相应的HTTP状态返回给客户端（毕竟，HTTP状态，标头已经发送到客户端并且正在写入数据）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发生异常时，除了断开连接之外，别无其他。</font><font style="vertical-align: inherit;">当然，可以确保有异常，但是客户端将无法准确了解发生了什么错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，即使处理器从数据库中接收了所有数据，也可能出现类似情况，但是在向客户端传输数据时网络会闪烁-没有人对此感到安全。</font></font><br>
<br>
<a name="update_citizen_handler"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修补程序/进口/ $ import_id /公民/ $ civil_id</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序将接收到unload的标识符</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，常驻居民</font></font><code>citizen_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及带有有关常驻居民的新数据的json。</font><font style="vertical-align: inherit;">如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不存在卸载或驻留</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则必须返回HTTP响应</font></font><code>404: Not Found</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
客户端传输的数据必须经过</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证和反序列化</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果它们不正确，则必须返回HTTP响应</font></font><code>400: Bad Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我实现了一个棉花糖计划</font></font><code>PatchCitizenSchema</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来检查：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定字段的数据类型和格式。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出生日期。</font><font style="vertical-align: inherit;">必须以一种格式指定它，</font></font><code>DD.MM.YYYY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且从将来起就不再有意义。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个居民的亲戚名单。</font><font style="vertical-align: inherit;">它必须具有居民的唯一标识符。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
字段中指示的亲戚是否存在</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能单独检查：如果将</font></font><code>relations</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不存在的居民</font><font style="vertical-align: inherit;">添加到表中，</font><font style="vertical-align: inherit;">PostgreSQL将返回一个</font></font><code>ForeignKeyViolationError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以处理</font><font style="vertical-align: inherit;">的错误</font><font style="vertical-align: inherit;">，并且可以返回HTTP状态</font></font><code>400: Bad Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果客户端</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为不存在的居民或正在卸载</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的客户发送了</font><b><font style="vertical-align: inherit;">不正确的数据，</font></b><font style="vertical-align: inherit;">应该返回什么状态</font><font style="vertical-align: inherit;">？从语义上讲，首先检查卸载和驻留程序的存在（如果不存在，则返回</font></font><code>404: Not Found</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后检查客户端是否发送了正确的数据（如果没有，则返回return </font></font><code>400: Bad Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">，是更正确的选择</font><font style="vertical-align: inherit;">。实际上，首先检查数据通常更便宜，并且只有在数据正确的情况下才访问数据库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这两个选项都是可以接受的，但是我决定选择一个更便宜的第二个选项，因为在任何情况下，操作的结果都是不会影响任何错误的错误（客户端将更正数据，然后发现该居民不存在）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果数据正确，则必须</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新有关数据库中居民的信息</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在处理程序中，您将需要对不同的表进行几个查询。如果发生错误或异常，则必须撤消对数据库的更改，因此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须在transaction中执行查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法</font></font><code>PATCH</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅允许您</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为居民</font><b><font style="vertical-align: inherit;">转移某些字段</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必须以这样的方式编写处理程序：在访问客户端未指定的数据时，处理程序不会崩溃，并且也不会对未更改数据的表执行查询。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果客户指定了该字段</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则必须获取现有亲属的列表。如果已更改，请确定</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须删除</font><font style="vertical-align: inherit;">表中的哪些记录</font><font style="vertical-align: inherit;">以及添加</font><font style="vertical-align: inherit;">哪些记录，</font><font style="vertical-align: inherit;">以使数据库与客户的要求保持一致。默认情况下，PostgreSQL使用事务隔离</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> READ COMMITTED</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这意味着，作为当前事务的一部分，更改将对其他已完成事务的现有（以及新记录）记录可见。这可能导致</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">竞争要求之间出现竞争状态</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设居民正在卸货</font></font><code>#1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><code>#2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>#3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有血缘关系。该服务同时收到两个更改居民编号1 </font></font><code><nobr>{"relatives": [2]}</nobr></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和的</font><font style="vertical-align: inherit;">请求</font></font><code><nobr>{"relatives": [3]}</nobr></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 aiohttp将创建两个处理程序，这些处理程序同时从PostgreSQL接收居民的当前状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个处理程序都不会检测到单个相关关系，而是会决定添加具有指定亲属的新关系。结果，居民＃1与亲戚有相同的领域</font></font><code>[2,3]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/go/bk/mz/gobkmzuhzr47rfzgvtygkxb1stm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种行为不能被称为明显。预期有两种方法可以决定比赛的结果：仅完成第一个请求，第二个返回HTTP响应</font></font><br>
<code>409: Conflict</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以便客户端重复请求），或依次执行请求（仅在第一个请求完成后处理第二个请求）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以通过打开隔离模式来实现第一个选项</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>SERIALIZABLE</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果在处理请求期间有人已经设法更改和提交数据，则将引发异常，可以处理该异常并返回相应的HTTP状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该解决方案的缺点-PostgreSQL中的大量锁</font></font><code>SERIALIZABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会引发异常，即使竞争性查询更改了来自不同卸载的居民记录。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推荐锁定</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机制</font><font style="vertical-align: inherit;">。如果您获得了这样的锁定</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则针对不同卸载的竞争性请求将能够并行运行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要在一个上传中处理竞争性请求，您可以实现任何选项的行为：该函数</font></font><code>pg_try_advisory_xact_lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试获取锁定，然后</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它立即返回布尔结果（如果无法获取锁，则可能引发异常），并</font></font><code>pg_advisory_xact_lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待直到</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
资源可用于阻塞（在这种情况下，请求将按顺序执行，我决定使用此选项）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，处理程序必须</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回有关已更新resident的当前信息</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。可以限制自己将数据从他的请求返回给客户端（因为我们正在将响应返回给客户端，这意味着没有异常，并且所有请求都已成功完成）。或-在修改数据库并从结果生成响应的查询中使用RETURNING关键字。但是，这两种方法都不允许我们通过国家竞争来审视和检验案件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该服务没有高负载要求，所以我决定再次请求有关居民的所有数据，并从数据库返回客户真实的结果。 </font></font><br>
<br>
<a name="citizen_birthdays_handler"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民/生日</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序计算卸货的每个居民将送给其亲戚的礼物数量（一阶）。</font><font style="vertical-align: inherit;">该数字按月份分组，并使用指定的进行上传</font></font><code>import_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上传不存在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则必须返回HTTP响应</font></font><code>404: Not Found</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有两个实现选项：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据库中获取有亲戚的居民的数据，并且在Python方面，按月汇总数据并为数据库中没有数据的月份生成列表。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在数据库中编译一个json请求，并为缺少的月份添加存根。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我选择了第一个选项-看起来更容易理解和支持。可以通过将</font></font><code>JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有家庭关系的表（</font></font><code>relations.citizen_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-我们认为其亲戚的生日的居民）从表中</font></font><code>citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（包含要获取月份的出生日期</font><font style="vertical-align: inherit;">）中</font><font style="vertical-align: inherit;">获得给定月份</font><font style="vertical-align: inherit;">的生日数</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
月值不得包含前导零。</font></font><code>birth_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用该函数</font><font style="vertical-align: inherit;">从字段中获得的月份</font></font><code>date_part</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能包含前导零。要删除它，我</font><font style="vertical-align: inherit;">在SQL查询中</font><font style="vertical-align: inherit;">执行</font></font><code>cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font></font><code>integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管处理程序需要满足两个请求（检查是否存在卸载并获取有关生日和礼物的信息），</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但不需要</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行</font><b><font style="vertical-align: inherit;">交易</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
缺省情况下，PostgreSQL使用READ COMMITTED模式，在该模式中，所有新记录（由其他事务添加）和现有记录（由其他事务修改）在成功完成后都将在当前事务中可见。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，如果在接收数据时添加了新上传，则不会影响现有上传。</font><font style="vertical-align: inherit;">如果在接收数据时执行了更改居民的请求，则该数据将不可见（如果尚未完成更改数据的交易），或者该交易将完全完成并且所有更改将立即可见。</font><font style="vertical-align: inherit;">从数据库获得的完整性将不会受到侵犯。</font></font><br>
<br>
<a name="town_age_stat_handler"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /城镇/统计/百分位数/年龄</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序使用指定的import_id计算样本中按城市划分的居民年龄（完整年）的第50、75和99％。</font><font style="vertical-align: inherit;">如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上传不存在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则必须返回HTTP响应</font></font><code>404: Not Found</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管处理器执行了两个请求（检查是否存在卸载并获取居民列表），</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是并不需要使用事务</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有两个实现选项：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据库中按城市分组，获取居民的年龄，然后在python端使用numpy（在任务中指定为参考）计算百分位数，并四舍五入到小数点后两位。</font></font></li>
<li>     PostgreSQL:  percentile_cont     ,             SQL-,  numpy   .</li>
</ol> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个选项需要在应用程序和PostgreSQL之间传输较少的数据，但是并没有一个非常明显的陷阱：在PostgreSQL中，舍入是数学的（</font></font><code>SELECT ROUND(2.5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回3），而在Python-记帐中，</font><font style="vertical-align: inherit;">舍入</font><font style="vertical-align: inherit;">到最接近的整数（</font></font><code>round(2.5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回2）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要测试处理程序，PostgreSQL和Python中的实现必须相同（在Python中使用数学舍入来实现函数看起来更容易）。</font><font style="vertical-align: inherit;">值得注意的是，当计算百分位数时，numpy和PostgreSQL可以返回略有不同的数字，但是考虑到四舍五入，这种差异将不明显。</font></font><br>
<br>
<a name="testing"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试中</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此应用程序中需要检查什么？首先，要确保操作人员符合要求，并在尽可能接近战斗环境的环境中执行所需的工作。其次，更改数据库状态的迁移可以正常工作。第三，有许多辅助功能也可以通过测试正确覆盖。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">由于</font></a><font style="vertical-align: inherit;">它的灵活性和易用性，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytest框架</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它提供了一种强大的机制来为测试准备环境- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">夹具</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即具有装饰器的功能</font></font><code>pytest.mark.fixture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其名称可以由测试中的参数指定。</font><font style="vertical-align: inherit;">如果pytest在测试注释中检测到带有灯具名称的参数，它将执行该灯具并将结果传递给该参数的值。</font><font style="vertical-align: inherit;">如果夹具是生成器，那么测试参数将使用返回的值</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且在测试完成之后，</font><font style="vertical-align: inherit;">夹具</font><font style="vertical-align: inherit;">的第二部分</font><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">被执行，这可以清除资源或关闭连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于大多数测试，我们需要一个PostgreSQL数据库。</font><font style="vertical-align: inherit;">为了将测试彼此隔离，可以在每个测试之前创建一个单独的数据库，并在执行之后将其删除。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每个测试创建一个夹具数据库</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> uuid<font></font>
<font></font>
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine
<span class="hljs-keyword">from</span> sqlalchemy_utils <span class="hljs-keyword">import</span> create_database, drop_database
<span class="hljs-keyword">from</span> yarl <span class="hljs-keyword">import</span> URL<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.utils.pg <span class="hljs-keyword">import</span> DEFAULT_PG_URL<font></font>
<font></font>
PG_URL = os.getenv(<span class="hljs-string">'CI_ANALYZER_PG_URL'</span>, DEFAULT_PG_URL)<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@pytest.fixture</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postgres</span>():</span>
    tmp_name = <span class="hljs-string">'.'</span>.join([uuid.uuid4().hex, <span class="hljs-string">'pytest'</span>])<font></font>
    tmp_url = str(URL(PG_URL).with_path(tmp_name))<font></font>
    create_database(tmp_url)<font></font>
<font></font>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment">#      postgres  -</span>
        <span class="hljs-keyword">yield</span> tmp_url
    <span class="hljs-keyword">finally</span>:<font></font>
        drop_database(tmp_url)<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_db</span>(<span class="hljs-params">postgres</span>):</span>
    <span class="hljs-string">"""
     ,  PostgreSQL
    """</span><font></font>
    engine = create_engine(postgres)<font></font>
    <span class="hljs-keyword">assert</span> engine.execute(<span class="hljs-string">'SELECT 1'</span>).scalar() == <span class="hljs-number">1</span>
    engine.dispose()</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑到不同数据库和驱动程序的功能，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sqlalchemy_utils</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
模块出色地完成了此任务</font><font style="vertical-align: inherit;">。例如，PostgreSQL不允许</font></font><code>CREATE DATABASE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在事务块中</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">。创建数据库时，它将</font></font><code>sqlalchemy_utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换</font></font><code>psycopg2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（通常执行事务中的所有请求）为自动提交模式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个重要功能：如果至少一个客户端连接到PostgreSQL，则无法删除数据库，但是</font></font><code>sqlalchemy_utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在删除数据库之前会断开所有客户端的连接。即使某些具有活动连接的测试挂起，数据库也将被成功删除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要处于不同状态的PostgreSQL：为了测试迁移，我们需要一个干净的数据库，而处理程序则要求所有迁移都适用。</font><font style="vertical-align: inherit;">您可以使用Alembic命令以编程方式更改数据库的状态；它们需要Alembic配置对象来调用它们。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个夹具Alembic配置对象</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> SimpleNamespace<font></font>
<font></font>
<span class="hljs-keyword">import</span> pytest<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.utils.pg <span class="hljs-keyword">import</span> make_alembic_config<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@pytest.fixture()</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alembic_config</span>(<span class="hljs-params">postgres</span>):</span>
    cmd_options = SimpleNamespace(config=<span class="hljs-string">'alembic.ini'</span>, name=<span class="hljs-string">'alembic'</span>,<font></font>
                                  pg_url=postgres, raiseerr=<span class="hljs-literal">False</span>, x=<span class="hljs-literal">None</span>)
    <span class="hljs-keyword">return</span> make_alembic_config(cmd_options)</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，灯具</font></font><code>alembic_config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有参数</font></font><code>postgres</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>pytest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅可以指示测试对灯具的依赖性，还可以指示灯具之间的依赖性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种机制使您可以灵活地分离逻辑并编写非常简洁且可重用的代码。</font></font><br>
<br>
<a name="testing_handlers"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试处理程序需要具有创建的表和数据类型的数据库。要应用迁移，您必须以编程方式调用upgrade Alembic命令。要调用它，您需要一个具有Alembic配置的对象，我们已经使用fixtures定义了它</font></font><code>alembic_config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。具有迁移功能的数据库看起来像一个完全独立的实体，可以表示为一个固定装置：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> alembic.command <span class="hljs-keyword">import</span> upgrade<font></font>
<font></font>
<span class="hljs-meta">@pytest.fixture</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">migrated_postgres</span>(<span class="hljs-params">alembic_config, postgres</span>):</span>
    upgrade(alembic_config, <span class="hljs-string">'head'</span>)
    <span class="hljs-comment">#  DSN  ,    </span>
    <span class="hljs-keyword">return</span> postgres</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当项目中有许多迁移时，它们在每个测试中的应用程序可能会花费太多时间。为了加快这一过程，您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一次带有迁移的数据库，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其用作模板</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了用于测试处理程序的数据库之外，您还需要一个正在运行的应用程序，以及一个配置为与此应用程序一起使用的客户端。为了使应用程序易于测试，我将其创建放入一个具有</font></font><code>create_app</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行参数</font><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">中：数据库，REST API的端口等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动应用程序的参数也可以表示为单独的固定装置。要创建它们，您将需要确定用于运行测试应用程序的空闲端口以及迁移到的临时数据库的地址。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确定空闲端口，我使用</font></font><code>aiomisc_unused_port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了aiomisc软件包中</font><font style="vertical-align: inherit;">的灯具</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个标准的夹具</font></font><code>aiohttp_unused_port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以，但是它返回一个确定空闲端口的函数，同时它</font></font><code>aiomisc_unused_port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">立即返回端口号。</font><font style="vertical-align: inherit;">对于我们的应用程序，我们只需要确定一个空闲端口，因此我决定不使用call编写额外的代码行</font></font><code>aiohttp_unused_port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@pytest.fixture</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arguments</span>(<span class="hljs-params">aiomisc_unused_port, migrated_postgres</span>):</span>
    <span class="hljs-keyword">return</span> parser.parse_args(<font></font>
        [<font></font>
            <span class="hljs-string">'--log-level=debug'</span>,
            <span class="hljs-string">'--api-address=127.0.0.1'</span>,
            <span class="hljs-string">f'--api-port=<span class="hljs-subst">{aiomisc_unused_port}</span>'</span>,
            <span class="hljs-string">f'--pg-url=<span class="hljs-subst">{migrated_postgres}</span>'</span><font></font>
        ]<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用处理程序进行的所有测试均暗含对REST API的请求；</font></font><code>aiohttp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要</font><font style="vertical-align: inherit;">直接与应用程序一起工作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我制作了一个启动应用程序的夹具，并使用工厂</font></font><code>aiohttp_client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建并返回了连接到该应用程序的标准测试客户端</font></font><code>aiohttp.test_utils.TestClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> analyzer.api.app <span class="hljs-keyword">import</span> create_app<font></font>
<font></font>
<span class="hljs-meta">@pytest.fixture</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api_client</span>(<span class="hljs-params">aiohttp_client, arguments</span>):</span><font></font>
    app = create_app(arguments)<font></font>
    client = <span class="hljs-keyword">await</span> aiohttp_client(app, server_kwargs={
        <span class="hljs-string">'port'</span>: arguments.api_port<font></font>
    })<font></font>
<font></font>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> client
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-keyword">await</span> client.close()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，如果在测试参数中指定夹具，</font></font><code>api_client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则会发生以下情况：</font></font><br>
<br>
<ol>
<li> <code>postgres</code>    (  <code>migrated_postgres</code>).</li>
<li> <code>alembic_config</code>    Alembic,      (  <code>migrated_postgres</code>).</li>
<li> <code>migrated_postgres</code>   (  <code>arguments</code>).</li>
<li> <code>aiomisc_unused_port</code>    (  <code>arguments</code>).</li>
<li> <code>arguments</code>     (  <code>api_client</code>).</li>
<li> <code>api_client</code>          .</li>
<li> .</li>
<li> <code>api_client</code>     .</li>
<li> <code>postgres</code>   .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
夹具使您可以避免重复代码，但是除了在测试中准备环境之外，还有另一个可能存在很多相同代码的潜在地方-应用程序请求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，发出请求，我们希望获得某种HTTP状态。其次，如果状态与期望的状态匹配，则在处理数据之前，需要确保它们具有正确的格式。在这里很容易出错，并编写一个处理程序以执行正确的计算并</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回正确的结果，但由于响应格式不正确而无法通过自动验证</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例如，忘记将答案包装在带有key的字典中</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。所有这些检查都可以在一个地方完成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在模块中</font></font><code>analyzer.testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我为每个处理程序准备了一个辅助函数，该函数检查HTTP的状态以及使用棉花糖的响应格式。 </font></font><br>
<br>
<a name="test_citizens_handler"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定从返回居民的处理程序开始，因为它对于检查其他更改数据库状态的处理程序的结果非常有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我故意没有使用从处理程序向数据库添加数据的代码</font></font><code>POST /imports</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管将其变成一个单独的函数并不困难。</font><font style="vertical-align: inherit;">处理程序的代码具有更改的属性，并且如果添加到数据库中的代码中有任何错误，则测试有可能会停止按预期工作，并且对开发人员隐式停止显示错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于此测试，我定义了以下测试数据集：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与几个亲戚一起卸货。</font><font style="vertical-align: inherit;">检查每个居民是否正确地形成了带有亲戚标识符的列表。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与一位没有亲戚的居民一起卸货。</font><font style="vertical-align: inherit;">检查该字段</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否为空列表（由于</font></font><code>LEFT JOIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询，亲戚列表可能相等</font></font><code>[None]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与自己亲戚的居民一起卸货。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空卸货。</font><font style="vertical-align: inherit;">检查处理程序是否允许添加空卸载，并且不会因错误而崩溃。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在每次上传单独运行相同的测试，我用另一种非常强大的pytest机制- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这种机制允许您将测试函数包装在装饰器中，</font></font><code>pytest.mark.parametrize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在其中描述每个单独的测试用例测试函数应采用哪些参数。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何参数化测试</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> pytest<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.utils.testing <span class="hljs-keyword">import</span> generate_citizen<font></font>
<font></font>
datasets = [<font></font>
    <span class="hljs-comment">#    </span><font></font>
    [<font></font>
        generate_citizen(citizen_id=<span class="hljs-number">1</span>, relatives=[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),<font></font>
        generate_citizen(citizen_id=<span class="hljs-number">2</span>, relatives=[<span class="hljs-number">1</span>]),<font></font>
        generate_citizen(citizen_id=<span class="hljs-number">3</span>, relatives=[<span class="hljs-number">1</span>])<font></font>
    ],<font></font>
<font></font>
    <span class="hljs-comment">#   </span><font></font>
    [<font></font>
        generate_citizen(relatives=[])<font></font>
    ],<font></font>
<font></font>
    <span class="hljs-comment">#   ,    </span><font></font>
    [<font></font>
        generate_citizen(citizen_id=<span class="hljs-number">1</span>, name=<span class="hljs-string">''</span>, gender=<span class="hljs-string">'male'</span>,<font></font>
                         birth_date=<span class="hljs-string">'17.02.2020'</span>, relatives=[<span class="hljs-number">1</span>])<font></font>
    ],<font></font>
<font></font>
    <span class="hljs-comment">#  </span><font></font>
    [],<font></font>
]<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@pytest.mark.parametrize('dataset', datasets)</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_get_citizens</span>(<span class="hljs-params">api_client, dataset</span>):</span>
    <span class="hljs-string">"""
        4 ,    
    """</span></code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，测试会将上传内容添加到数据库，然后使用对处理程序的请求，它将接收有关居民的信息，并将参考上传内容与接收到的内容进行比较。但是，您如何比较居民？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个居民都由标量字段和一个字段</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-亲戚标识符列表组成。 Python中的列表是有序类型，在比较每个列表元素的顺序时确实很重要，但是在将列表与同级进行比较时，顺序不重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在比较之前将其</font><font style="vertical-align: inherit;">带入</font><font style="vertical-align: inherit;">集合，则在进行比较时无法找出其中一个居民</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复的情况。如果使用亲属标识符对列表进行排序，则可以避免亲属标识符顺序不同的问题，但同时可以检测重复项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在将两个具有居民的清单进行比较时，一个人可能会遇到类似的问题：从技术上讲，卸货中居民的顺序并不重要，但重要的是要检测一个卸货中是否有两个居民具有相同的标识符，而另一个居民中没有。</font><font style="vertical-align: inherit;">因此，除了与亲戚组织清单外，每个居民的亲戚还需要安排居民进行每次卸货。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于比较居民的任务将不只一次出现，因此我实现了两个功能：一个用于比较两个居民，第二个用于将两个列表与居民进行比较：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较居民</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterable, Mapping<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalize_citizen</span>(<span class="hljs-params">citizen</span>):</span>
    <span class="hljs-string">"""
         
    """</span>
    <span class="hljs-keyword">return</span> {**citizen, <span class="hljs-string">'relatives'</span>: sorted(citizen[<span class="hljs-string">'relatives'</span>])}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare_citizens</span>(<span class="hljs-params">left: Mapping, right: Mapping</span>) -&gt; bool:</span>
    <span class="hljs-string">"""
      
    """</span>
    <span class="hljs-keyword">return</span> normalize_citizen(left) == normalize_citizen(right)<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare_citizen_groups</span>(<span class="hljs-params">left: Iterable, right: Iterable</span>) -&gt; bool:</span>
    <span class="hljs-string">"""
          ,   
      
    """</span>
    left = [normalize_citizen(citizen) <span class="hljs-keyword">for</span> citizen <span class="hljs-keyword">in</span> left]<font></font>
    left.sort(key=<span class="hljs-keyword">lambda</span> citizen: citizen[<span class="hljs-string">'citizen_id'</span>])<font></font>
<font></font>
    right = [normalize_citizen(citizen) <span class="hljs-keyword">for</span> citizen <span class="hljs-keyword">in</span> right]<font></font>
    right.sort(key=<span class="hljs-keyword">lambda</span> citizen: citizen[<span class="hljs-string">'citizen_id'</span>])
    <span class="hljs-keyword">return</span> left == right
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保此处理程序不会返回其他卸载的居民，我决定在每次测试之前添加一个居民的额外卸载。</font></font><br>
<br>
<a name="test_imports_handler"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开机自检/导入</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我定义了以下数据集来测试处理程序：</font></font><br>
<br>
<ul>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的数据，有望成功添加到数据库中。</font></font></b><br>
 <br>
<ul>
<li>    ( ).<br>
<br>
      .    ,     ,    insert    ,    .</li>
<li>   ( , ).<br>
<br>
,            .<br>
 </li>
<li>    .<br>
<br>
     ,       . :)<br>
 </li>
<li>    <br>
<br>
,  aiohttp             PostgreSQL    32 767  (    ).<br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空卸载</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序应考虑到这种情况，不要摔倒，尝试对有居民的表进行空插入。</font></font><br>
 </li>
</ul><br>
 </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据错误，期望HTTP响应为400：请求错误。</font></font></b><br>
 <br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出生日期不正确（未来时态）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">citizen_id在上载中不是唯一的。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲戚关系显示不正确（只有一位居民到另一位居民，但没有反馈）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">居民在卸货中没有亲戚。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家庭纽带不是唯一的。</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果处理器成功运行并且添加了数据，则需要将居民添加到数据库中，并将其与标准卸载进行比较。</font><font style="vertical-align: inherit;">为了获得居民，我使用了已经测试过的处理程序</font></font><code>GET /imports/$import_id/citizens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，为了进行比较，使用了一个function </font></font><code>compare_citizen_groups</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="test_update_citizen_handler"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修补程序/进口/ $ import_id /公民/ $ civil_id</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据验证在许多方面类似于处理程序中描述的方法，但</font></font><code>POST /imports</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一些例外：只有一个居民，并且客户端只能传递</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他想要的那些字段</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定对错误的数据使用以下集合，以验证处理程序将返回HTTP响应</font></font><code>400: Bad request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定了该字段，但数据类型和/或格式不正确</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出生日期不正确（未来时间）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含一个在卸载中不存在的亲戚。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还需要验证处理程序是否正确更新了有关居民及其亲属的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，请创建一个包含三个居民的上传文件，其中两个是亲戚，然后为所有标量字段发送一个具有新值的请求，并在该字段中添加一个新的相对标识符</font></font><code>relatives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保处理程序在测试之前区分不同卸货的居民（例如，不要将具有相同标识符的居民与另一个卸货的居民进行更改），我创建了一个额外的卸货，其中三个居民具有相同的标识符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序必须保存标量字段的新值，添加新的指定亲戚并删除与旧的未指定亲戚的关系。</font><font style="vertical-align: inherit;">亲属关系的所有变化都应是双边的。</font><font style="vertical-align: inherit;">其他卸载不应更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于此类处理程序可能会遇到竞争条件（这在“开发”部分中进行了讨论），因此我添加了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个附加测试</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一个复制了竞争状态的问题（扩展了处理程序类并删除了锁），第二个复制了竞争状态的问题没有被复制。</font></font><br>
<br>
<a name="test_citizen_birthdays_handler"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /公民/生日</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了测试此处理程序，我选择了以下数据集：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">居民在一个月内有一个亲戚，在另一个月有两个亲戚的卸货。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与一位没有亲戚的居民一起卸货。</font><font style="vertical-align: inherit;">检查处理程序是否在计算中未将其考虑在内。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空卸货。</font><font style="vertical-align: inherit;">检查处理程序是否不会失败，并在响应中返回12个月的正确字典。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与自己亲戚的居民一起卸货。</font><font style="vertical-align: inherit;">检查居民是否会购买其出生月份的礼物。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理程序必须在响应中返回所有月份，即使这些月份中没有生日也是如此。</font><font style="vertical-align: inherit;">为避免重复，我制作了一个函数，您可以将字典传递给该函数，以便对缺失月份的值进行补充。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保处理程序能够区分不同卸货的居民，我添加了两个亲戚的额外卸货。</font><font style="vertical-align: inherit;">如果处理程序在计算中错误地使用它们，则结果将不正确，并且处理程序将因错误而掉落。</font></font><br>
<br>
<a name="test_town_age_stat_handler"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /进口/ $ import_id /城镇/统计/百分位数/年龄</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该测试的独特之处在于它的工作结果取决于当前时间：根据当前日期计算居民的年龄。</font><font style="vertical-align: inherit;">为确保测试结果不会随时间变化，必须记录当前日期，居民的出生日期和预期结果。</font><font style="vertical-align: inherit;">这将使重现任何甚至边缘的情况变得容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最佳修复日期是什么？</font><font style="vertical-align: inherit;">处理程序使用PostgreSQL函数计算居民的年龄</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>AGE</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">将第一个参数作为需要计算年龄的日期，将第二个参数作为基准日期（由常量定义</font></font><code>TownAgeStatView.CURRENT_DATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将处理程序中的基准日期替换为测试时间</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch<font></font>
<font></font>
<span class="hljs-keyword">import</span> pytz<font></font>
<font></font>
CURRENT_DATE = datetime(<span class="hljs-number">2020</span>, <span class="hljs-number">2</span>, <span class="hljs-number">17</span>, tzinfo=pytz.utc)<font></font>
<font></font>
<font></font>
<span class="hljs-meta">@patch('analyzer.api.handlers.TownAgeStatView.CURRENT_DATE', new=CURRENT_DATE)</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_get_ages</span>(<span class="hljs-params">...</span>):</span>
    ...</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了测试处理程序，我选择了以下数据集（对于所有指示一个城市的居民，因为处理程序按城市汇总结果）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与几位生日为明天（年龄-364天）的居民进行卸货。</font><font style="vertical-align: inherit;">检查处理器在计算中仅使用整整年数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与今天（年龄-刚好是几年）生日的居民一起卸货。</font><font style="vertical-align: inherit;">它检查区域情况-今天不应将其生日减去今天的居民的年龄再减去1年。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空卸货。</font><font style="vertical-align: inherit;">处理程序不应该掉在上面。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算百分位数的</font></font><code>numpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">带有线性插值，以及我为它们计算的测试基准结果。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还需要将分数百分比值四舍五入到小数点后两位。</font><font style="vertical-align: inherit;">如果使用PostgreSQL在处理程序中进行四舍五入，并使用Python计算参考数据，则可能会注意到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Python 3和PostgreSQL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><strong><font style="vertical-align: inherit;">四舍五入会产生不同的结果</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs"># Python 3<font></font>
round(2.5)<font></font>
&gt; 2<font></font>
<font></font>
-- PostgreSQL<font></font>
SELECT ROUND(2.5)<font></font>
&gt; 3<font></font>
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实是，Python使用四舍五入</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到最接近的偶数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而PostgreSQL </font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">数学（半数）。</font><font style="vertical-align: inherit;">如果在PostgreSQL中执行计算和舍入，那么在测试中也使用数学舍入是正确的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，我以文本格式描述了具有出生日期的数据集，但是阅读这种格式的测试很不方便：每次我不得不计算脑海中每个居民的年龄以记住特定数据集正在检查的内容时。</font><font style="vertical-align: inherit;">当然，您可以通过代码中的注释来解决问题，但是我决定走得更远，并编写了一个函数</font></font><code>age2date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该函数</font><font style="vertical-align: inherit;">可以让您以年龄的形式描述出生日期：年数和天数。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像这样</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> pytz<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.utils.testing <span class="hljs-keyword">import</span> generate_citizen<font></font>
<font></font>
<font></font>
CURRENT_DATE = datetime(<span class="hljs-number">2020</span>, <span class="hljs-number">2</span>, <span class="hljs-number">17</span>, tzinfo=pytz.utc)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age2date</span>(<span class="hljs-params">years: int, days: int = <span class="hljs-number">0</span>, base_date=CURRENT_DATE</span>) -&gt; str:</span><font></font>
    birth_date = copy(base_date).replace(year=base_date.year - years)<font></font>
    birth_date -= timedelta(days=days)<font></font>
    <span class="hljs-keyword">return</span> birth_date.strftime(BIRTH_DATE_FORMAT)<font></font>
<font></font>
<span class="hljs-comment">#    ?  ,     ?</span>
generate_citizen(birth_date=<span class="hljs-string">'17.02.2009'</span>)<font></font>
<font></font>
<span class="hljs-comment">#   11       </span>
generate_citizen(birth_date=age2date(years=<span class="hljs-number">11</span>))
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保处理程序能够区分不同卸货的居民，我为来自另一城市的一名居民添加了另一项卸货：如果处理程序错误地使用了卸货，结果中将出现一个额外的城市，并且测试将中断。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个有趣的事实：当我在2020年2月29日编写此测试时，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于Faker中的一个错误</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我突然停止了向居民产生卸载</font><font style="vertical-align: inherit;">（2020年是leap年，而Faker选择的其他年份也并非总是leap年）不是2月29日）。</font><font style="vertical-align: inherit;">记住要记录日期并测试边缘情况！</font></font></blockquote><br>
<a name="test_migrations"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移居</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
迁移代码乍一看似乎很明显，而且最不容易出错，为什么要进行测试？这是一个非常危险的错误：最隐蔽的迁移错误会在最不适当的时刻表现出来。即使它们不会破坏数据，也可能导致不必要的停机时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
项目中存在的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迁移会更改数据库的结构，但不会更改数据。哪些常见错误可以防止此类迁移？</font></font><br>
<br>
<ul>
<li>  <code>downgrade</code>           (     ,      ,     ).<br>
<br>
   ,        (--):         ,        —    .<br>
 </li>
<li>C   .</li>
<li>    ( ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些错误大多数将通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">楼梯测试</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测到</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他的想法-用一个单一的迁移，始终执行方法</font></font><code>upgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>downgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>upgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个迁移。</font><font style="vertical-align: inherit;">这样的测试足以将其添加到项目中一次，它不需要支持并且会忠实地服务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果迁移除了结构之外还会更改数据，则有必要编写至少一个单独的测试，以检查方法中的数据正确更改</font></font><code>upgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并返回中的初始状态</font></font><code>downgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以防万一：一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有测试不同迁移示例的项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我准备了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一份有关</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">莫斯科Python中</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Alembic</font></a><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">报告</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="build"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部件</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将要部署的最终构件以及作为组装结果要获得的构件是Docker映像。要构建，必须</font><font style="vertical-align: inherit;">使用Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择基本映像</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。官方映像的大小</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>python:latest</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约为1 GB，如果用作基本映像，则带有应用程序的映像将很大。有些</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图像基于Alpine OS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其尺寸要小得多。但是，随着安装的软件包数量的增加，最终映像的大小将增加，结果，即使基于Alpine收集的映像也不会那么小。我选择了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snakepacker / python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为基本映像</font><font style="vertical-align: inherit;">-它比Alpine映像重一些，但是基于Ubuntu，Ubuntu提供了大量的软件包和库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一种方式</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减少应用程序的映像大小</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在最终映像中不要包括</font><b><font style="vertical-align: inherit;">带有程序</font></b><font style="vertical-align: inherit;">集头的编译器，库和文件，而应用程序不需要这些文件，程序库和文件头。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，您可以使用</font><font style="vertical-align: inherit;">Docker </font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多阶段组装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用“大量”映像</font></font><code>snakepacker/python:all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（〜1 GB，〜500 MB压缩），创建一个虚拟环境，将所有依赖项和应用程序包安装到其中。</font><font style="vertical-align: inherit;">该映像是组装专用的，它可以包含编译器，所有必需的库和带标头的文件。</font></font><br>
<br>
<pre><code class="python hljs">FROM snakepacker/python:all <span class="hljs-keyword">as</span> builder<font></font>
<font></font>
<span class="hljs-comment">#   </span>
RUN python3<span class="hljs-number">.8</span> -m venv /usr/share/python3/app<font></font>
<font></font>
<span class="hljs-comment">#  source distribution     </span><font></font>
COPY dist/ /mnt/dist/<font></font>
RUN /usr/share/python3/app/bin/pip install /mnt/dist/*</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将完成的虚拟环境复制到一个“轻量”映像</font></font><code>snakepacker/python:3.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（约100 MB，压缩后约50 MB）中，该</font><font style="vertical-align: inherit;">映像</font><font style="vertical-align: inherit;">仅包含所需版本的Python的解释器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要说明：在虚拟环境中，使用绝对路径，因此必须将其复制到在收集器容器中组装时所使用的相同地址。</font></font><br>
<br>
<pre><code class="python hljs">FROM snakepacker/python:<span class="hljs-number">3.8</span> <span class="hljs-keyword">as</span> api<font></font>
<font></font>
<span class="hljs-comment">#       builder</span>
COPY --<span class="hljs-keyword">from</span>=builder /usr/share/python3/app /usr/share/python3/app<font></font>
<font></font>
<span class="hljs-comment">#  ,     </span>
<span class="hljs-comment"># </span><font></font>
RUN ln -snf /usr/share/python3/app/bin/analyzer-* /usr/local/bin/<font></font>
<font></font>
<span class="hljs-comment">#        </span>
CMD [<span class="hljs-string">"analyzer-api"</span>]</code></pre></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减少构建映像所花费的时间</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以在将其安装到虚拟环境中之前安装与应用程序相关的模块。</font><font style="vertical-align: inherit;">然后，Docker将缓存它们，并且如果它们没有更改，将不会重新安装。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全Dockerfile</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment">###############      ################</span>
<span class="hljs-comment">#  — «» (~1 ,    ~500 )    </span>
<span class="hljs-comment">#    </span>
FROM snakepacker/python:all <span class="hljs-keyword">as</span> builder<font></font>
<font></font>
<span class="hljs-comment">#      pip</span>
RUN python3<span class="hljs-number">.8</span> -m venv /usr/share/python3/app<font></font>
RUN /usr/share/python3/app/bin/pip install -U pip<font></font>
<font></font>
<span class="hljs-comment">#   ,  .   </span>
<span class="hljs-comment"># Docker   ,  requirements.txt  </span><font></font>
COPY requirements.txt /mnt/<font></font>
RUN /usr/share/python3/app/bin/pip install -Ur /mnt/requirements.txt<font></font>
<font></font>
<span class="hljs-comment">#  source distribution     </span><font></font>
COPY dist/ /mnt/dist/<font></font>
RUN /usr/share/python3/app/bin/pip install /mnt/dist/* \<font></font>
    &amp;&amp; /usr/share/python3/app/bin/pip check<font></font>
<font></font>
<span class="hljs-comment">###########################   ############################</span>
<span class="hljs-comment">#    «» (~100 ,    ~50 )   Python</span>
FROM snakepacker/python:<span class="hljs-number">3.8</span> <span class="hljs-keyword">as</span> api<font></font>
<font></font>
<span class="hljs-comment">#         builder</span>
COPY --<span class="hljs-keyword">from</span>=builder /usr/share/python3/app /usr/share/python3/app<font></font>
<font></font>
<span class="hljs-comment">#  ,     </span>
<span class="hljs-comment"># </span><font></font>
RUN ln -snf /usr/share/python3/app/bin/analyzer-* /usr/local/bin/<font></font>
<font></font>
<span class="hljs-comment">#        </span>
CMD [<span class="hljs-string">"analyzer-api"</span>]</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了便于组装，我添加了一个命令</font></font><code>make upload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该命令</font><font style="vertical-align: inherit;">收集Docker映像并将其上传到hub.docker.com。</font></font><br>
<br>
<a name="ci"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">词</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，代码已包含测试，并且我们可以构建Docker映像，是时候使这些过程自动化。想到的第一件事是：运行测试以创建池请求，并在向master分支添加更改时，收集一个新的Docker映像并将其上传到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker Hub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub Packages</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果您不打算公开分发该映像）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub Actions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决了这个问题</font><font style="vertical-align: inherit;">。为此，必须在文件夹中创建一个YAML文件，</font></font><code>.github/workflows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在其中描述一个工作流程（包含两个任务：</font></font><code>test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>publish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），我将其命名为</font></font><code>CI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每当</font><font style="vertical-align: inherit;">使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">服务</font></a><font style="vertical-align: inherit;">启动工作流时</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">都会执行</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该任务</font></font><code>test</code><font style="vertical-align: inherit;"></font><code>CI</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用PostgreSQL拾取一个容器，等待它可用，然后</font></font><code>pytest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在容器中</font><font style="vertical-align: inherit;">启动</font></font><code>snakepacker/python:all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该任务</font></font><code>publish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有在变化已被添加到分支执行</font></font><code>master</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果任务</font></font><code>test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功。</font><font style="vertical-align: inherit;">它通过容器收集源代码分发</font></font><code>snakepacker/python:all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后使用收集并加载Docker映像</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>docker/build-push-action@v1</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作流程的完整描述</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">name: CI<font></font>
<font></font>
# Workflow      <font></font>
#   -  master<font></font>
on:<font></font>
  push:<font></font>
    branches: [ master ]<font></font>
  pull_request:<font></font>
    branches: [ master ]<font></font>
<font></font>
jobs:<font></font>
  #       workflow<font></font>
  test:<font></font>
    runs-on: ubuntu-latest<font></font>
<font></font>
    services:<font></font>
      postgres:<font></font>
        image: docker://postgres<font></font>
        ports:<font></font>
          - 5432:5432<font></font>
        env:<font></font>
          POSTGRES_USER: user<font></font>
          POSTGRES_PASSWORD: hackme<font></font>
          POSTGRES_DB: analyzer<font></font>
<font></font>
    steps:<font></font>
      - uses: actions/checkout@v2<font></font>
      - name: test<font></font>
        uses: docker://snakepacker/python:all<font></font>
        env:<font></font>
          CI_ANALYZER_PG_URL: postgresql://user:hackme@postgres/analyzer<font></font>
        with:<font></font>
          args: /bin/bash -c "pip install -U '.[dev]' &amp;&amp; pylama &amp;&amp; wait-for-port postgres:5432 &amp;&amp; pytest -vv --cov=analyzer --cov-report=term-missing tests"<font></font>
<font></font>
  #    Docker-  <font></font>
  publish:<font></font>
    #        master<font></font>
    if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/master'<font></font>
    # ,   test   <font></font>
    needs: test<font></font>
    runs-on: ubuntu-latest<font></font>
    steps:<font></font>
      - uses: actions/checkout@v2<font></font>
      - name: sdist<font></font>
        uses: docker://snakepacker/python:all<font></font>
        with:<font></font>
          args: make sdist<font></font>
<font></font>
      - name: build-push<font></font>
        uses: docker/build-push-action@v1<font></font>
        with:<font></font>
          username: ${{ secrets.REGISTRY_LOGIN }}<font></font>
          password: ${{ secrets.REGISTRY_TOKEN }}<font></font>
          repository: alvassin/backendschool2019<font></font>
          target: api<font></font>
          tags: 0.0.1, latest<font></font>
</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在GitHub的“操作”选项卡中向主服务器添加更改时，您可以看到测试的启动，Docker映像的组装和加载：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r5/qx/pm/r5qxpmy7mlttqniibfvxadvzitw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且在master分支中创建池请求时，任务的结果也将显示在其中</font></font><code>test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/d9/nk/pzd9nkmxq7a75fnlcw2tx37i308.png"><br>
<br>
<a name="deployment"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部署</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要将应用程序部署在提供的服务器上，您需要安装Docker，Docker Compose，使用应用程序和PostgreSQL启动容器并应用迁移。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Ansible的配置管理系统可以自动执行这些步骤。它是用Python编写的，不需要特殊的代理（直接通过ssh连接），使用jinja模板，并允许在YAML文件中声明性地描述所需的状态。声明性方法使您不必考虑系统的当前状态以及使系统进入所需状态所需的操作。所有这些工作都靠在Ansible模块的肩膀上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ansible允许您将逻辑上相关的任务分组为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角色</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后重用它们。我们将需要两个角色：</font></font><code>docker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（安装和配置Docker）和</font></font><code>analyzer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（安装和配置应用程序）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该角色</font></font><code>docker</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将包含Docker的存储库添加到系统，安装并配置软件包</font></font><code>docker-ce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>docker-compose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（可选）您可以将REST API设置为在服务器重新引导后自动恢复。 Ubuntu允许您借助初始化系统解决此问题</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>systemd</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它控制代表各种资源（守护程序，套接字，安装点和其他）的单元。要将新单元添加到systemd，必须在单独的.service文件中描述其配置，并将该文件放置在一个特殊文件夹中，例如</font></font><code>/etc/systemd/system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后可以启动该设备，并为其启用自动加载功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包</font></font><code>docker-ce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在安装过程中，它将自动创建具有设备配置的文件-您只需要确保该文件正在运行并在系统启动时打开即可。</font><font style="vertical-align: inherit;">对于Docker，Compose </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>  docker-compose@.service</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将由Ansible创建。</font></font><code>@</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名称中</font><font style="vertical-align: inherit;">的符号</font><font style="vertical-align: inherit;">向systemd指示该单元是模板。</font><font style="vertical-align: inherit;">这使您可以</font></font><code>docker-compose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用参数</font><font style="vertical-align: inherit;">启动服务</font><font style="vertical-align: inherit;">-例如，使用我们的服务名称，该名称将被替换，而不是</font></font><code>%i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单元配置文件中：</font></font><br>
<br>
<pre><code class="plaintext hljs">[Unit]<font></font>
Description=%i service with docker compose<font></font>
Requires=docker.service<font></font>
After=docker.service<font></font>
<font></font>
[Service]<font></font>
Type=oneshot<font></font>
RemainAfterExit=true<font></font>
WorkingDirectory=/etc/docker/compose/%i<font></font>
ExecStart=/usr/local/bin/docker-compose up -d --remove-orphans<font></font>
ExecStop=/usr/local/bin/docker-compose down<font></font>
<font></font>
[Install]<font></font>
WantedBy=multi-user.target</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该角色将从</font></font><code>analyzer</code></b><font style="vertical-align: inherit;"></font><code>docker-compose.yml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址</font><font style="vertical-align: inherit;">处的模板生成文件</font></font><code>/etc/docker/compose/analyzer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将应用程序注册为自动启动的服务，</font></font><code>systemd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后应用迁移。</font><font style="vertical-align: inherit;">角色准备好后，您需要描述剧本。</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
<font></font>
- name: Gathering facts<font></font>
  hosts: all<font></font>
  become: yes<font></font>
  gather_facts: yes<font></font>
<font></font>
- name: Install docker<font></font>
  hosts: docker<font></font>
  become: yes<font></font>
  gather_facts: no<font></font>
  roles:<font></font>
    - docker<font></font>
<font></font>
- name: Install analyzer<font></font>
  hosts: api<font></font>
  become: yes<font></font>
  gather_facts: no<font></font>
  roles:<font></font>
    - analyzer</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主机列表以及角色中使用的变量可以在清单文件中指定</font></font><code>hosts.ini</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">[api]<font></font>
130.193.51.154<font></font>
<font></font>
[docker:children]<font></font>
api<font></font>
<font></font>
[api:vars]<font></font>
analyzer_image = alvassin/backendschool2019<font></font>
analyzer_pg_user = user<font></font>
analyzer_pg_password = hackme<font></font>
analyzer_pg_dbname = analyzer</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备好所有Ansible文件后，运行它：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ ansible-playbook -i hosts.ini deploy.yml</code></pre><br>
<a name="load_testing"></a><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于压力测试</font></font></b>
                        <div class="spoiler_text">,   ,     .      ,      -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>.     :      ,    —   ,         10 . ,         (, ,   CI-):           .<br>
<br>
,     ,      ,        10 .   ?  ,          ,   .  ,     ,       .<br>
<br>
          RPS,      :      . ,    ,     <code>import_id</code>,    <code>POST /imports</code>      .      . <br>
<br>
,       Python 3,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Locust</a>. <br>
<br>
   ,      <code>locustfile.py</code>     <code>locust</code>.         -     .<br>
<br>
 Locust   .    ,        .       <br>
 <code>self.round</code>           .<br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">    locustfile.py</b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"># locustfile.py</span>
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">from</span> http <span class="hljs-keyword">import</span> HTTPStatus<font></font>
<font></font>
<span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpLocust, constant, task, TaskSet
<span class="hljs-keyword">from</span> locust.exception <span class="hljs-keyword">import</span> RescheduleTask<font></font>
<font></font>
<span class="hljs-keyword">from</span> analyzer.api.handlers <span class="hljs-keyword">import</span> (<font></font>
    CitizenBirthdaysView, CitizensView, CitizenView, TownAgeStatView<font></font>
)<font></font>
<span class="hljs-keyword">from</span> analyzer.utils.testing <span class="hljs-keyword">import</span> generate_citizen, generate_citizens, url_for<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnalyzerTaskSet</span>(<span class="hljs-params">TaskSet</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><font></font>
        super().__init__(*args, **kwargs)<font></font>
        self.round = <span class="hljs-number">0</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_dataset</span>(<span class="hljs-params">self</span>):</span><font></font>
        citizens = [<font></font>
            <span class="hljs-comment">#     .   </span>
            <span class="hljs-comment"># PATCH-  relatives    </span>
            <span class="hljs-comment"># ,     - </span>
            <span class="hljs-comment"># (     ,    </span>
            <span class="hljs-comment"># ).</span>
            generate_citizen(citizen_id=<span class="hljs-number">1</span>, relatives=[<span class="hljs-number">2</span>]),<font></font>
            generate_citizen(citizen_id=<span class="hljs-number">2</span>, relatives=[<span class="hljs-number">1</span>]),<font></font>
            *generate_citizens(citizens_num=<span class="hljs-number">9998</span>, relations_num=<span class="hljs-number">1000</span>,<font></font>
                               start_citizen_id=<span class="hljs-number">3</span>)<font></font>
        ]<font></font>
        <span class="hljs-keyword">return</span> {citizen[<span class="hljs-string">'citizen_id'</span>]: citizen <span class="hljs-keyword">for</span> citizen <span class="hljs-keyword">in</span> citizens}<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, method, path, expected_status, **kwargs</span>):</span>
        <span class="hljs-keyword">with</span> self.client.request(<font></font>
                method, path, catch_response=<span class="hljs-literal">True</span>, **kwargs<font></font>
        ) <span class="hljs-keyword">as</span> resp:
            <span class="hljs-keyword">if</span> resp.status_code != expected_status:<font></font>
                resp.failure(<span class="hljs-string">f'expected status <span class="hljs-subst">{expected_status}</span>, '</span>
                             <span class="hljs-string">f'got <span class="hljs-subst">{resp.status_code}</span>'</span>)<font></font>
            logging.info(<font></font>
                <span class="hljs-string">'round %r: %s %s, http status %d (expected %d), took %rs'</span>,<font></font>
                self.round, method, path, resp.status_code, expected_status,<font></font>
                resp.elapsed.total_seconds()<font></font>
            )<font></font>
            <span class="hljs-keyword">return</span> resp<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_import</span>(<span class="hljs-params">self, dataset</span>):</span>
        resp = self.request(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'/imports'</span>, HTTPStatus.CREATED,<font></font>
                            json={<span class="hljs-string">'citizens'</span>: list(dataset.values())})
        <span class="hljs-keyword">if</span> resp.status_code != HTTPStatus.CREATED:
            <span class="hljs-keyword">raise</span> RescheduleTask
        <span class="hljs-keyword">return</span> resp.json()[<span class="hljs-string">'data'</span>][<span class="hljs-string">'import_id'</span>]<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_citizens</span>(<span class="hljs-params">self, import_id</span>):</span><font></font>
        url = url_for(CitizensView.URL_PATH, import_id=import_id)<font></font>
        self.request(<span class="hljs-string">'GET'</span>, url, HTTPStatus.OK,<font></font>
                     name=<span class="hljs-string">'/imports/{import_id}/citizens'</span>)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_citizen</span>(<span class="hljs-params">self, import_id</span>):</span>
        url = url_for(CitizenView.URL_PATH, import_id=import_id, citizen_id=<span class="hljs-number">1</span>)<font></font>
        self.request(<span class="hljs-string">'PATCH'</span>, url, HTTPStatus.OK,<font></font>
                     name=<span class="hljs-string">'/imports/{import_id}/citizens/{citizen_id}'</span>,<font></font>
                     json={<span class="hljs-string">'relatives'</span>: [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>)]})<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_birthdays</span>(<span class="hljs-params">self, import_id</span>):</span><font></font>
        url = url_for(CitizenBirthdaysView.URL_PATH, import_id=import_id)<font></font>
        self.request(<span class="hljs-string">'GET'</span>, url, HTTPStatus.OK,<font></font>
                     name=<span class="hljs-string">'/imports/{import_id}/citizens/birthdays'</span>)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_town_stats</span>(<span class="hljs-params">self, import_id</span>):</span><font></font>
        url = url_for(TownAgeStatView.URL_PATH, import_id=import_id)<font></font>
        self.request(<span class="hljs-string">'GET'</span>, url, HTTPStatus.OK,<font></font>
                     name=<span class="hljs-string">'/imports/{import_id}/towns/stat/percentile/age'</span>)<font></font>
<font></font>
<span class="hljs-meta">    @task</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">workflow</span>(<span class="hljs-params">self</span>):</span>
        self.round += <span class="hljs-number">1</span><font></font>
        dataset = self.make_dataset()<font></font>
<font></font>
        import_id = self.create_import(dataset)<font></font>
        self.get_citizens(import_id)<font></font>
        self.update_citizen(import_id)<font></font>
        self.get_birthdays(import_id)<font></font>
        self.get_town_stats(import_id)<font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsiteUser</span>(<span class="hljs-params">HttpLocust</span>):</span><font></font>
    task_set = AnalyzerTaskSet<font></font>
    wait_time = constant(<span class="hljs-number">1</span>)</code></pre></div>
                    </div><br>
 100  c  ,  ,        :<br>
<br>
<img src="https://habrastorage.org/webt/qx/ri/b3/qxrib3jily9gzmexxhupu35tipa.png"><br>
<br>
       ,           ( — 95 ,  — ).        .<br>
<br>
<img src="https://habrastorage.org/webt/dn/px/fn/dnpxfn5ly7vttziqnnfpvvdsl9g.png"><br>
<br>
      —     Ansible       ~20.15  ~20.30    Locust.<br>
<br>
<img src="https://habrastorage.org/webt/om/1e/ok/om1eoknqvzqmyez-plpgykhz8io.png"></div>
                    </div><br>
<a name="whatelse"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有什么可以做的？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对应用程序进行性能分析表明，在查询的总执行时间中，约有四分之一用于序列化和反序列化JSON：从服务发送和接收了大量数据。使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orjson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库可以大大加快这些过程</font><font style="vertical-align: inherit;">，但是必须对服务进行一点准备- </font></font><code>orjson</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不是标准模块的直接替代品，</font></font><code>json</code> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，生产需要该服务的多个副本以确保容错能力和应付负载。要管理一组服务，您需要一个工具来显示该服务的副本是否“有效”。这个问题可以通过一个处理程序来解决，该处理程序</font></font><code>/health</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮询工作所需的所有资源，在本例中为数据库。如果</font></font><code>SELECT 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在不到一秒钟的时间内执行，该服务仍然有效。如果没有，则需要注意。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当应用程序非常密集地使用网络时，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uvloop</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">凉爽</font></a><font style="vertical-align: inherit;">地提高性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个重要因素是代码的可读性。我的一位同事Yuri Shikanov编写了一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">灰色</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模块，该模块结合了几种</font><font style="vertical-align: inherit;">用于自动验证和执行代码的</font><font style="vertical-align: inherit;">工具</font><font style="vertical-align: inherit;">，可以轻松地将其添加到</font></font><code>pre-commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Git挂钩中，并使用单个配置文件或环境变量进行设置。 Gray允许您对导入（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">进行排序</font><font style="vertical-align: inherit;">，根据新版本的语言（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyupgrade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">优化python表达式</font><font style="vertical-align: inherit;">，在函数调用，导入，列表等末尾添加逗号（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add-trailing-comma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），并且还引用了一种形式（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unify</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<a name="final"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* * *</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是我的全部：我们开发了测试，进行了测试，组装和部署了服务，还进行了负载测试。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">致谢</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我要对那些花时间参与本文，回顾代码，介绍我的想法和评论的人表示由衷的感谢：Maria Zelenova </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泽尔马</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，弗拉基米尔·索洛马汀 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，阿纳斯塔西娅Semenova </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">莫尔科夫</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尤里·希卡诺夫（Yuri Shikanov） </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地藏</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，米哈伊尔（Mikhail Shushpanov） </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">米舒什</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，帕维尔·莫辛 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帕夫卡兹</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 特别是德米特里·奥尔洛夫（Dmitry Orlov） </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orlovdl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499518/index.html">视频会议现在是市场和新技术。Longrid，第一部分</a></li>
<li><a href="../zh-CN499522/index.html">Windows 10 2004（20H1）的所有创新</a></li>
<li><a href="../zh-CN499524/index.html">Quarkus：使用来自JBoss EAP Quickstart的helloworld示例升级应用程序</a></li>
<li><a href="../zh-CN499528/index.html">超越费马大定理的“惊人”数学桥梁</a></li>
<li><a href="../zh-CN499532/index.html">数字一词：使用Yandex.Metrica进行免费的博客分析habravebinary</a></li>
<li><a href="../zh-CN499536/index.html">Growbox作为认识自己的方法</a></li>
<li><a href="../zh-CN499540/index.html">3D游戏渲染如何工作：纹理和纹理过滤</a></li>
<li><a href="../zh-CN499542/index.html">顶级法卡波夫·青色</a></li>
<li><a href="../zh-CN499544/index.html">在Google表格中学习神经网络</a></li>
<li><a href="../zh-CN499546/index.html">模拟摄像机EVR-Y2022F的固件开发</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>