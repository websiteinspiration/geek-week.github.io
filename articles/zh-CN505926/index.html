<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏾 🛍️ ☝🏾 关于Apophenia，Telegonia和Time Travel的问题（以及以_开头的功能） 👧 🦃 🧚🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1958年，德国神经心理学家克劳斯·康拉德（Klaus Konrad）创造了术语“阿波芬症”（源自拉丁语阿波芬-表达判断，使之变得明确；该术语可追溯至宗教启示录，它表示在认知过程之外获得的知识），隐含着心理的特性，即能力查看无意义或随机事实或数据中的关系，并巧合地发现意义。有意义的交流的幻觉。我们的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于Apophenia，Telegonia和Time Travel的问题（以及以_开头的功能）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505926/"><blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1958年，德国神经心理学家克劳斯·康拉德（Klaus Konrad）创造了术语“阿波芬症”（源自拉丁语阿波芬-表达判断，使之变得明确；该术语可追溯至宗教启示录，它表示在认知过程之外获得的知识），隐含着心理的特性，即能力查看无意义或随机事实或数据中的关系，并巧合地发现意义。有意义的交流的幻觉。我们的大脑一直在寻找模式，但是经常会犯错误，并且有不合理的愿望去查看不存在的模式。遵循巧合和偶然性的特殊愿望。这称为复音。在数学统计中，这是第一类标准错误。</font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nepryakhin N.“我在操纵你”</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么我还记得这个术语，尤其是关于IT资源？</font><font style="vertical-align: inherit;">因为在程序调试过程中寻找不同事实之间的关系是决定其成功的主要因素之一。</font><font style="vertical-align: inherit;">工作中存在许多随机的错误，每个错误都不表明其发生的原因，并且不影响程序整体的运行，这似乎有些混乱。</font><font style="vertical-align: inherit;">但是，如果您试图找到它们之间的关系，则可以用一行代码立即解决很多问题……或者确保该关系不过是开发人员想象中的思维游戏。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1章“代理与协调人”</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这一切都是在开发代理程序的过程中开始的，该代理程序在远程服务器上执行许多任务，并通过客户端-服务器机制接收任务列表。代理通过端口34002（与之连接的本地协调器）提升了服务器的性能，他们检查了彼此的授权，如果一切顺利，则代理将执行所需的操作并返回顶部。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tr/mz/kl/trmzklssjskomt-sxqhxfdpbihq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化的程序方案</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
代理</font><i><font style="vertical-align: inherit;">程序的</font></i><font style="vertical-align: inherit;">一个明显步骤是创建您自己的fork，可以在其中执行exec系列中的任何功能，以便用正在启动的程序替换进程。在这种情况下，代理会收到该进程的pid，该pid允许等待它的完成或强制终止它。但是，一切都进行得很顺利，为了使协调员能够收到有关所做工作的报告，有必要返回stdout和stderr的结论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个问题可以通过几种方法解决-将进程new（dup2）FD传递给stdout和stderr，然后在父进程中读取它们；将stderr重定向到stdout并使用popen;将stdout和stderr描述符重写为文件，并在完成后读取它们。我们选择后一种方法，因为用第一种方法读取需要额外的代码和同步（并且如果不连续读取，则在达到2 MB后将在管道缓冲区用尽时停止记录），而第二种方法则失去了stdout和stderr之间的区别。因此，选择了最简单的方法-将stdout和stderr关闭到一个新进程，然后在需要覆盖输出的地方通过open打开文件。根据open的文档，它使用最小的可用FD索引，这就是为什么代码简单明了的原因：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化的代码如下所示（已删除错误检查以提高可读性）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代码已启动，命令输出已成功写入文件，它已完成并准备在“战斗”系统上工作。</font><font style="vertical-align: inherit;">或不？</font><font style="vertical-align: inherit;">在测试阶段，出现了一个小错误，“证明”了时间旅行（或至少是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电报</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的可能性</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二章“ Telegonia”</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题是这样的：在启动程序完成之后，以及在代理本身完成之后，在文件中找到以下行，其中应包含正在启动的程序的输出（我们将子程序的stdout重定向到该行）：</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-05 16:58:49]      :34002</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等一下！但这是代理本身输出的一行-名为fork（）的父进程！不仅如此，代理在被调用程序结束后的一段时间显示此行！如何将座席的其余所有输出写入stdout，并且其中一行可以进入文件，座席的全部工作是在waitpid完成后对其进行读取？读取文件时可能出现错误，从而使内存受挫？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _exec_readfile(struct frs_json * target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename) {<font></font>
    FILE * fp;<font></font>
    <span class="hljs-keyword">char</span> linebuff[VEN_PIPE_READ_SIZE + <span class="hljs-number">1</span>] = { <span class="hljs-number">0</span> };<font></font>
    fp = fopen(filename, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!fp)<font></font>
        frs_err(<span class="hljs-string">" \"%s\"    "</span>, filename);
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span>(fgets(linebuff, VEN_PIPE_READ_SIZE, fp))<font></font>
            frs_json_string(target, <span class="hljs-literal">NULL</span>, bxi_strtrimr(linebuff));<font></font>
    }<font></font>
    fclose(fp);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎没有什么可以击败内存的（测试覆盖了frs_ *）。</font><font style="vertical-align: inherit;">那么，此fp如何影响代理输出（在执行此功能几分钟后发生）？</font><font style="vertical-align: inherit;">自然地，有些电报-他们触摸了文件以进行阅读，并且9个月后，我们从其中的“第一伙伴”那里得到了一条线。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9g/pv/c7/9gpvc7fjwrn55pggacmexfxbohm.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的FD受到斑马</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Valgrind的</font><i><font style="vertical-align: inherit;">抚摸，</font></i><font style="vertical-align: inherit;">没有发现任何问题，这使我们有些不高兴。</font><font style="vertical-align: inherit;">毕竟，他的全能分析器没有看到内存访问错误，他们只花了很多时间徒劳地进行分析。</font><font style="vertical-align: inherit;">还是没有白费？</font><font style="vertical-align: inherit;">如果没有内存访问错误，则表示逻辑错误。</font><font style="vertical-align: inherit;">但是，什么逻辑错误可能导致这种影响呢？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章“两台服务器”</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，发现了第二个错误。</font><font style="vertical-align: inherit;">在QtCreator调试下的启动过程中（我们将其用作开发环境，即C项目本身）成功完成了与该程序相关的所有过程，并且未出现此错误。</font><font style="vertical-align: inherit;">但是，值得尝试直接启动该程序，然后（通过合法方法）终止该程序，因为该程序第二次停止启动。</font></font><br>
<br>
<pre><code class="plaintext hljs">^C[2020-06-05 16:58:46]    "Interrupt",   <font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]     <font></font>
[2020-06-05 16:58:50]      </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想到小型gregrins会从内部破坏程序机制，从而破坏程序的一部分，然后破坏另一部分是正确的。</font><font style="vertical-align: inherit;">但是程序员的才华表明，这些错误之间存在某种联系。</font><font style="vertical-align: inherit;">哪一个？</font><font style="vertical-align: inherit;">谁知道，但这就是为什么它并非一无是处！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
查找启动失败的原因很容易。</font><font style="vertical-align: inherit;">查看该程序的系统日志就足够了，其中清楚且清楚地定义了原因：</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-06 14:40:12] frs_socket_bind  :34002   ("Address already in use" (98))<font></font>
[2020-06-06 14:40:12]      :34002<font></font>
[2020-06-06 14:40:12] ven_server_start     </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它是如何启动的？</font><font style="vertical-align: inherit;">谁发射的？</font><font style="vertical-align: inherit;">你在一分钟前结束了！</font></font><br>
<br>
<pre><code class="plaintext hljs">$ ps aux | grep vento<font></font>
alex     14144  0.0  0.0 156780  7212 pts/0    Sl+  14:39   0:00 ./vento</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真正推出。</font><font style="vertical-align: inherit;">但是也许只是一个意外？</font></font><br>
<br>
<pre><code class="plaintext hljs">kill -9 14144</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次，程序启动，但是在程序结束之后，拥有端口34002的进程仍然存在：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     14144 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后谁结束了？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑运行时lsof -i的输出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们推出：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     151640 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，一个插座，一台服务器</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，一台Reich</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
客户端在这里连接到它并设置一些命令... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这是什么？</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    4u  IPv4 12890329      0t0  TCP localhost:34002-&gt;localhost:46154 (ESTABLISHED)</code></pre><br>
<img src="https://habrastorage.org/webt/wp/wq/62/wpwq62hwasqdflzz9bxomgjvebq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣的事实＃197766：早晚应该出现对《星球大战》的引用</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
两个服务器端口？</font><font style="vertical-align: inherit;">尽管我们的服务器未使用REUSEPORT标志。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4章“ CLOEXEC”</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
嗯...也许在服务器实现中缺少CLOEXEC标志？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们仔细看看标志：</font></font><br>
<br>
<pre><code class="plaintext hljs">$man fork<font></font>
       *  The child process is created  with  a  single  thread—the  one  that<font></font>
          called  fork().   The  entire virtual address space of the parent is<font></font>
          replicated in the child, including the states of mutexes,  condition<font></font>
          variables,  and other pthreads objects; the use of pthread_atfork(3)<font></font>
          may be helpful for dealing with problems that this can cause.<font></font>
<font></font>
       *  The child inherits copies of the parent's set of open file  descrip‐<font></font>
          tors.   Each  file  descriptor  in the child refers to the same open<font></font>
          file description (see open(2)) as the corresponding file  descriptor<font></font>
          in  the parent.  This means that the two file descriptors share open<font></font>
          file status flags, file offset,  and  signal-driven  I/O  attributes<font></font>
          (see the description of F_SETOWN and F_SETSIG in fcntl(2)).<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调用fork（）函数将创建该进程当前线程的副本，并创建每个打开的进程描述符的副本（并且由于在UNIX [-like]系统上“一切都是文件”，因此网络描述符将与文件描述符一起倾斜）</font></font><br>
<br>
<pre><code class="plaintext hljs">$man exec<font></font>
       The exec() family of functions replaces the current process image with a new process image.  The functions described in<font></font>
       this manual page are front-ends for execve(2).  (See the manual page  for  execve(2)  for  further  details  about  the<font></font>
       replacement of the current process image.)</code></pre><br>
<pre><code class="plaintext hljs">$man execve<font></font>
       *  By  default,  file  descriptors  remain open across an execve().  File descriptors that are marked close-on-exec are<font></font>
          closed; see the description of FD_CLOEXEC in fcntl(2).  (If a file descriptor is closed, this will cause the release<font></font>
          of  all record locks obtained on the underlying file by this process.  See fcntl(2) for details.)  POSIX.1 says that<font></font>
          if file descriptors 0, 1, and 2 would otherwise be closed after a successful execve(), and the  process  would  gain<font></font>
          privilege because the set-user-ID or set-group_ID mode bit was set on the executed file, then the system may open an<font></font>
          unspecified file for each of these file descriptors.  As a general principle, no portable  program,  whether  privi‐<font></font>
          leged or not, can assume that these three file descriptors will remain closed across an execve().</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们不希望被调用的进程收到描述符的副本，则必须将标志FD_CLOEXEC / SOCK_CLOEXEC设置给它。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一般情况下，这将是合乎逻辑的，如果它被打上要以复制，在根目录访问文件避免漏标签，但该标志出现在POSIX-2001，所以现在这是我们的传统，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">争议</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<pre><code class="cpp hljs">server-&gt;socket = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, <span class="hljs-number">0</span>);</code></pre><br>
<pre><code class="cpp hljs">fcntl(client, F_SETFD, FD_CLOEXEC);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，不，我们的标志已按原样设置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那会怎样 </font><font style="vertical-align: inherit;">内核会忽略该标志吗？</font><font style="vertical-align: inherit;">有人在甩他吗？</font><font style="vertical-align: inherit;">最重要的是，为什么在应用程序完成后，占用端口的进程仍留在系统中？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试关闭主服务器并使用gdb连接到其余进程：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ sudo gdb -p 27506<font></font>
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git<font></font>
[...]<font></font>
Reading symbols from /lib/x86_64-linux-gnu/libgcc_s.so.1...(no debugging symbols found)...done.<font></font>
0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
88	../sysdeps/unix/sysv/linux/futex-internal.h:     .<font></font>
(gdb) bt<font></font>
#0  0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
#1  __pthread_cond_wait_common (abstime=0x0, mutex=0x55f485d38368, cond=0x55f485d38390) at pthread_cond_wait.c:502<font></font>
#2  __pthread_cond_wait (cond=0x55f485d38390, mutex=0x55f485d38368) at pthread_cond_wait.c:655<font></font>
#3  0x00007f503d948097 in _frs_signal_wait (signal=0x55f485d38340, filename=0x7f503d7315c8 "fen_server.c", fileline=298)<font></font>
    at ./projects/shared/libforseti/code/thread/frs_signal.c:250<font></font>
#4  0x00007f503d728044 in _server_wait (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:298<font></font>
#5  0x00007f503d72822d in fen_server_free (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:351</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stop stop stop，什么server_free？</font><font style="vertical-align: inherit;">我们完成了错误的过程吗？</font><font style="vertical-align: inherit;">毕竟，这里应该是echo应用程序的启动！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还是不应该？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5章“一个字符”</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们发送字符串echo，但是您需要将应用程序的完整路径放在exec中，因为与同一个系统不同，我们不在外壳环境中运行它。</font><font style="vertical-align: inherit;">更改为/ bin / echo，并注意问题已消失。</font><font style="vertical-align: inherit;">但是事实证明，当我们从exec的角度给出错误的命令时，我们将继续在同一进程中工作，而不用正在运行的应用程序替换它，这意味着...</font></font><br>
<br>
<pre><code class="cpp hljs">        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好，是的，退出已完成。</font><font style="vertical-align: inherit;">但这如何使服务器关闭？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*! \brief   */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) __attribute__((destructor));
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) {<font></font>
    fen_server_free(g_server);<font></font>
    frs_inf(<span class="hljs-string">"   "</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在一切都准备就绪。</font><font style="vertical-align: inherit;">这两个错误实际上是相互关联的，现在您甚至可以确切地说出如何：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g0/sk/-s/g0sk-sf74ratdovfkkoqny7ongu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，修复错误工作的系统仍然存在。</font><font style="vertical-align: inherit;">我们会像开玩笑说电视大师一样，然后用锤子敲打：</font><font style="vertical-align: inherit;">到出口一词</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加上一个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ _” </font><b><font style="vertical-align: inherit;">符号</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);<font></font>
        _exit(EXIT_FAILURE);<font></font>
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在发生了什么？</font><font style="vertical-align: inherit;">没什么特别的，除了现在终止过程将在不调用通过atexit注册的函数的情况下结束。</font><font style="vertical-align: inherit;">在较旧的glibc实现中，这将是对_exit系统调用的调用；在较新的实现中，将调用exit_group以更正确地完成所有程序线程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，两个错误都被击败了，您说“ apofenia”，“您只想知道”，“没有联系”。</font><font style="vertical-align: inherit;">我将</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盒子上</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">盒子，否则人类将不再飞向太空。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN505898/index.html">克劳德·香农（Claude Shannon）：各行各业的杰克，小丑，信息论之父</a></li>
<li><a href="../zh-CN505900/index.html">个人成瘾：全尺寸40毫米，不带线，持续72小时，需支付8000卢布</a></li>
<li><a href="../zh-CN505904/index.html">JUG茹＃5在线直播周</a></li>
<li><a href="../zh-CN505906/index.html">来自overthewire.org的演练强盗</a></li>
<li><a href="../zh-CN505918/index.html">索尼电话界面-残疾人广告</a></li>
<li><a href="../zh-CN505928/index.html">为什么函数式编程如此复杂</a></li>
<li><a href="../zh-CN505946/index.html">使用Django / Django REST存储图像</a></li>
<li><a href="../zh-CN505954/index.html">Alpine.js-事件和全局数据仓库</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>