<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 🏇 👨🏼‍🎓 Frontend Odnoklassniki baru: meluncurkan React in Java. Bagian II 🖖🏻 👩🏿‍🤝‍👨🏾 👨🏼‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami melanjutkan kisah tentang bagaimana, di dalam Odnoklassniki, dengan bantuan GraalVM, kami berhasil berteman dengan Java dan JavaScript dan mulai ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Frontend Odnoklassniki baru: meluncurkan React in Java. Bagian II</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/486810/"><img src="https://habrastorage.org/webt/sz/_g/7x/sz_g7xhw5t9siczpovdjhzzsgru.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melanjutkan kisah tentang bagaimana, di dalam Odnoklassniki, dengan bantuan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraalVM,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami berhasil berteman dengan Java dan JavaScript dan mulai bermigrasi ke sistem besar dengan banyak kode lawas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian kedua artikel ini, kita akan berbicara secara rinci tentang peluncuran, perakitan, dan integrasi aplikasi pada tumpukan baru, selami spesifik pekerjaan mereka baik pada klien maupun di server, serta membahas kesulitan yang dihadapi dalam perjalanan kami dan menjelaskan solusi untuk membantu mereka mengatasi . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda belum membaca bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sangat merekomendasikan melakukan ini. </font><font style="vertical-align: inherit;">Dari sini Anda akan belajar tentang sejarah frontend di Odnoklassniki dan berkenalan dengan fitur-fitur historisnya, melalui jalur menemukan solusi untuk masalah yang telah terakumulasi dalam 13 tahun proyek kami, dan pada akhirnya Anda akan terjun ke fitur teknis dari implementasi server dari keputusan yang kami buat.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi UI</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menulis kode UI, kami memilih alat yang paling canggih: Bereaksi bersama dengan MobX, Modul CSS, ESLint, TypeScript, Lerna. </font><font style="vertical-align: inherit;">Semua ini dikumpulkan menggunakan Webpack.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ed/tp/gx/edtpgxyuy6rxy4nvalwn_dhhkva.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur aplikasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang ditulis di bagian sebelumnya artikel ini, untuk menerapkan migrasi bertahap, kami akan memasukkan komponen baru di situs dalam elemen DOM dengan nama kustom yang akan berfungsi di dalam tumpukan UI baru, sedangkan untuk sisa situs akan terlihat seperti elemen DOM dengan API-nya. Isi elemen-elemen ini dapat dirender di server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa itu? Di dalamnya ada aplikasi MVC keren, modis, modern yang berjalan di React dan menyediakan API DOM standar: atribut, metode pada elemen DOM ini, dan acara.</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/fg/um/dw/fgumdwotb43klsvwwtlvx4x1bd4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menjalankan komponen seperti itu, kami telah mengembangkan mekanisme khusus. Apa yang dia lakukan? Pertama, ia menginisialisasi aplikasi sesuai dengan deskripsinya. Kedua, ia mengikat komponen ke simpul DOM tertentu di mana ia mulai. Ada juga dua mesin (untuk klien dan untuk server) yang dapat menemukan dan membuat komponen-komponen ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ln/dg/wz/lndgwzg5ggcfgsnnsfdnrdmue8u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa ini dibutuhkan? Faktanya adalah bahwa ketika seluruh situs dibuat pada React, maka biasanya komponen situs dirender ke dalam elemen root halaman, dan komponen ini tidak masalah apa yang ada di luar, tetapi hanya apa yang ada di dalamnya yang menarik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, semuanya lebih rumit: sejumlah aplikasi perlu kesempatan untuk memberi tahu halaman kami di situs "Saya, dan ada sesuatu yang berubah dalam diri saya." Sebagai contoh, kalender perlu mengadakan acara yang diklik pengguna pada tombol, dan tanggal telah berubah, atau di luar Anda memerlukan kemampuan sehingga di dalam kalender Anda dapat mengubah tanggal. Untuk ini, mesin aplikasi mengimplementasikan fasad dalam fungsionalitas dasar aplikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat mengirimkan komponen ke klien, perlu bahwa mesin situs lama dapat meluncurkan komponen ini. Untuk melakukan ini, selama pembangunan, informasi yang diperlukan untuk peluncurannya dikumpulkan.</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"events-calendar"</span>: {
        <span class="hljs-attr">"bundleName"</span>: <span class="hljs-string">"events-calendar"</span>,
        <span class="hljs-attr">"js"</span>: <span class="hljs-string">"events-calendar-h4h5m.js"</span>,
        <span class="hljs-attr">"css"</span>: <span class="hljs-string">"events-calendar-h4h5m.css"</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marker khusus ditambahkan ke atribut tag komponen, yang mengatakan bahwa aplikasi ini adalah tipe baru, kodenya dapat diambil dari file JS tertentu. </font><font style="vertical-align: inherit;">Pada saat yang sama, ia memiliki atribut sendiri yang diperlukan untuk menginisialisasi komponen ini: mereka membentuk keadaan awal komponen di toko.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">events-calendar</span>	<span class="hljs-attr">data-module</span>=<span class="hljs-string">"react-loader"</span>
			<span class="hljs-attr">data-bundle</span>=<span class="hljs-string">"events-calendar.js"</span>
			<span class="hljs-attr">date</span>=<span class="hljs-string">".."</span>
			<span class="hljs-attr">marks</span>=<span class="hljs-string">"[{..}]"</span>
			…
/&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk rehidrasi, itu bukan pemeran status aplikasi yang digunakan, tetapi atribut, yang memungkinkan penghematan lalu lintas. </font><font style="vertical-align: inherit;">Mereka datang dalam bentuk yang dinormalisasi, dan, sebagai aturan, lebih kecil dari toko yang dibuat aplikasi. </font><font style="vertical-align: inherit;">Pada saat yang sama, waktu untuk membuat ulang toko dari atribut pada klien adalah singkat, sehingga biasanya dapat diabaikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, untuk kalender, atribut hanya memiliki tanggal yang disorot, dan toko sudah memiliki matriks dengan informasi lengkap untuk bulan itu. </font><font style="vertical-align: inherit;">Jelas, tidak ada gunanya mentransfernya dari server.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara menjalankan kode?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konsep ini diuji pada fungsi-fungsi sederhana yang memberikan garis untuk server atau menulis innerHTML untuk klien Tetapi dalam kode nyata ada modul dan TypeScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada solusi standar untuk klien, misalnya, mengumpulkan kode menggunakan Webpack, yang dengan sendirinya menggiling semuanya dan memberikannya kepada klien dalam bentuk bundel bundel. Dan apa yang harus dilakukan untuk server saat menggunakan GraalVM?</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/sr/f7/yn/srf7ynd8airmxgybkgu4wnpe82c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita pertimbangkan dua opsi. Yang pertama adalah mengetikkan TypeScript dalam JavaScript, seperti yang mereka lakukan untuk Node.js. Sayangnya, opsi ini tidak berfungsi dalam konfigurasi kami ketika JavaScript adalah bahasa tamu di GraalVM. Dalam hal ini, JavaScript tidak memiliki sistem modular, atau bahkan sinkronisasi. Karena modularitas dan bekerja dengan asinkron memberikan runtime spesifik: NodeJS atau browser. Dan dalam kasus kami, server memiliki JavaScript yang hanya dapat menjalankan kode secara serempak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi kedua - Anda cukup menjalankan kode server dari file yang sama yang dikumpulkan untuk klien. Dan opsi ini berfungsi. Tetapi ada masalah bahwa server membutuhkan implementasi lain untuk sejumlah metode. Misalnya, fungsi renderToString () akan dipanggil pada server untuk membuat komponen, dan ReactDOM.render () pada klien. Atau contoh lain dari artikel sebelumnya: untuk mendapatkan teks dan pengaturan di server, fungsi yang disediakan Java akan dipanggil, dan pada klien itu akan menjadi implementasi di JS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai solusi untuk masalah ini, Anda dapat menggunakan alias dari Webpack. Mereka memungkinkan Anda untuk membuat dua implementasi dari kelas yang kita butuhkan: untuk klien dan server. Kemudian, dalam file konfigurasi untuk klien dan server, tentukan implementasi yang sesuai.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/rb/0o/carb0o0rvb1q0pw8eerxnsy4ova.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi dua file konfigurasi adalah dua rakitan. </font><font style="vertical-align: inherit;">Setiap kali, mengumpulkan semuanya secara terpisah untuk server dan untuk klien panjang dan sulit untuk didukung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda harus membuat konfigurasi sedemikian rupa sehingga semuanya terkumpul dalam sekali jalan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi webpack untuk menjalankan JS di server dan klien</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menemukan solusi untuk masalah ini, mari kita lihat bagian proyek yang terdiri dari: </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/zh/mi/e9/zhmie9o6zghd5vgeyd10pjonffq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, proyek memiliki runtime pihak ketiga (vendor), yang sama untuk klien dan untuk server. </font><font style="vertical-align: inherit;">Hampir tidak pernah berubah. </font><font style="vertical-align: inherit;">Rantime dapat diberikan kepada pengguna, dan ia akan di-cache pada klien hingga kami memperbarui versi perpustakaan pihak ketiga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, ada runtime kami (inti), yang memastikan peluncuran aplikasi. </font><font style="vertical-align: inherit;">Ini memiliki metode dengan implementasi yang berbeda untuk klien dan server. </font><font style="vertical-align: inherit;">Misalnya, mendapatkan teks pelokalan, pengaturan, dan sebagainya. </font><font style="vertical-align: inherit;">Runtime ini juga jarang berubah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketiga, ada kode komponen. </font><font style="vertical-align: inherit;">Itu sama untuk klien dan untuk server, yang memungkinkan Anda untuk men-debug kode aplikasi di browser tanpa memulai server sama sekali. </font><font style="vertical-align: inherit;">Jika ada yang tidak beres pada klien, Anda dapat melihat kesalahan di konsol browser, mengingat semuanya dan pastikan bahwa tidak ada kesalahan saat memulai di server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara total, tiga bagian diperoleh yang perlu dirakit. </font><font style="vertical-align: inherit;">Kami ingin:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasikan perakitan masing-masing bagian secara terpisah.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letakkan dependensi di antara mereka sehingga masing-masing bagian tidak jatuh ke dalam apa yang ada di yang lain.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kumpulkan semuanya dalam satu pass.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana menjelaskan secara terpisah bagian-bagian yang akan terdiri dari majelis? </font><font style="vertical-align: inherit;">Ada multikonfigurasi di webpack: Anda cukup memberikan array ekspor modul yang disertakan di setiap bagian.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = [{
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./vendors.js'</span>,<font></font>
}, {<font></font>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./core.js'</span><font></font>
}, {<font></font>
 <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span><font></font>
}];<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya akan baik-baik saja, tetapi di masing-masing bagian ini kode dari modul-modul di mana bagian ini bergantung akan diduplikasi: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ut/am/ax/utamaxl7z4op6x8iivfcmufn7ec.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, dalam set dasar plugin webpack ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DllPlugin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memungkinkan Anda untuk mendapatkan daftar modul yang disertakan di dalamnya untuk setiap bagian yang dirakit. Misalnya, untuk vendor, Anda dapat mengetahui modul spesifik mana yang termasuk dalam bagian ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika membangun bagian lain, misalnya, perpustakaan inti, kita dapat mengatakan bahwa mereka bergantung pada bagian vendor. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/nv/lu/el/nvluelzxzvy_5oofujylu4wmufk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, selama perakitan webpack, DllPlugin akan melihat inti tergantung pada beberapa pustaka yang sudah ada di vendor, dan tidak akan menambahkannya ke inti, tetapi cukup tautkan ke dalamnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alhasil, tiga potong dirangkai sekaligus dan saling bergantung. </font><font style="vertical-align: inherit;">Ketika aplikasi pertama diunduh ke klien, pustaka runtime dan inti akan disimpan dalam cache browser. </font><font style="vertical-align: inherit;">Dan karena Odnoklassniki adalah situs, tab yang dengannya pengguna dapat membuka "selamanya", berkeliaran akan terjadi sangat jarang. </font><font style="vertical-align: inherit;">Dalam kebanyakan kasus, dengan rilis versi baru situs, hanya kode aplikasi yang akan diperbarui.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengiriman Sumberdaya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan masalah dengan contoh bekerja dengan teks-teks lokal yang disimpan dalam database terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika sebelumnya di suatu tempat di server Anda membutuhkan teks dalam komponen, Anda bisa memanggil fungsi untuk mendapatkan teks.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> pkg = l10n(<span class="hljs-string">'smiles'</span>);<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    : { pkg.getText('title') }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mendapatkan teks di server tidak sulit, karena aplikasi server dapat membuat permintaan cepat ke database atau bahkan men-cache semua teks dalam memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara mendapatkan teks dalam komponen pada reaksi yang diberikan pada server di GraalVM? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang telah dibahas di bagian pertama artikel, dalam konteks JS, Anda dapat menambahkan metode ke objek global yang ingin Anda akses dari JavaScript. </font><font style="vertical-align: inherit;">Diputuskan untuk membuat kelas dengan semua metode yang tersedia untuk JavaScript.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerMethods</span> </span>{<font></font>
    …<font></font>
    <font></font>
    <span class="hljs-comment">/**
     *     
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">(String pkg, String key)</span> </span>{<font></font>
        …<font></font>
    }<font></font>
    <font></font>
    …<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian letakkan instance dari kelas ini dalam konteks JavaScript global:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Java   </span>
js.putMember(<span class="hljs-string">"serverMethods"</span>, serverMethods);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, dari JavaScript dalam implementasi server, kami cukup memanggil fungsi:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getText</span>(<span class="hljs-params">pkg: string, key: string</span>): <span class="hljs-title">string</span> </span>{
    <span class="hljs-keyword">return</span> global.serverMethods.getText(pkg, key);<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, ini akan menjadi pemanggilan fungsi di Jawa yang akan mengembalikan teks yang diminta. Interaksi sinkron langsung dan tidak ada panggilan HTTP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada klien, sayangnya, dibutuhkan waktu yang sangat lama untuk membahas HTTP dan menerima teks untuk setiap panggilan ke fungsi penyisipan teks dalam komponen. Anda dapat mengunduh terlebih dahulu semua teks ke klien, tetapi teks itu sendiri berbobot puluhan megabita, dan ada jenis sumber daya lainnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/6e/ij/lg6eijxb_rvzshqiyih2gyuvy5a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengguna akan bosan menunggu sampai semuanya diunduh sebelum memulai aplikasi. Karena itu, metode ini tidak cocok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya hanya ingin menerima teks-teks yang diperlukan dalam aplikasi tertentu. Teks kami dipecah menjadi beberapa paket. Oleh karena itu, Anda dapat mengumpulkan paket-paket yang diperlukan untuk aplikasi dan mengunduhnya bersama bundel. Saat aplikasi dimulai, semua teks sudah akan berada di cache klien.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara mengetahui teks mana yang dibutuhkan aplikasi? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menandatangani perjanjian bahwa paket teks dalam kode diperoleh dengan memanggil fungsi l10n (), di mana nama paket ditransmisikan HANYA dalam bentuk string literal:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> pkg = l10n(<span class="hljs-string">'smiles'</span>);<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    { pkg.getLMsg('title') }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menulis sebuah plugin webpack yang, dengan menganalisis pohon kode komponen AST, menemukan semua panggilan ke fungsi l10n () dan mengumpulkan nama paket dari argumen. </font><font style="vertical-align: inherit;">Demikian pula, plugin mengumpulkan informasi tentang jenis sumber daya lain yang dibutuhkan oleh aplikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada output setelah perakitan untuk setiap aplikasi, kami mendapatkan konfigurasi dengan sumber dayanya:</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"events-calendar"</span>: {
       <span class="hljs-attr">"pkg"</span>:  [
           <span class="hljs-string">"calendar"</span>,
           <span class="hljs-string">"dates"</span><font></font>
       ],<font></font>
       <span class="hljs-attr">"cfg"</span>:  [
           <span class="hljs-string">"config1"</span>,
           <span class="hljs-string">"config2"</span><font></font>
       ],<font></font>
       <span class="hljs-attr">"bundleName"</span>:  <span class="hljs-string">"events-calendar"</span>,
       <span class="hljs-attr">"js"</span>:  <span class="hljs-string">"events-calendar.js"</span>,
       <span class="hljs-attr">"css"</span>:  <span class="hljs-string">"events-calendar.css"</span>,<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan tentu saja, kita tidak boleh lupa tentang memperbarui teks. </font><font style="vertical-align: inherit;">Karena di server semua teks selalu mutakhir, dan klien memerlukan mekanisme pembaruan cache yang terpisah, misalnya, pengamat atau pendorong.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode lama dalam baru</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan transisi yang mulus, timbul masalah untuk menggunakan kembali kode lama dalam komponen baru, karena ada komponen besar dan kompleks (misalnya, pemutar video), menulis ulang yang akan memakan banyak waktu, dan Anda harus menggunakannya dalam tumpukan baru sekarang. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jz/pg/te/jzpgtesmq75odhrqyvbg2grbw9u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa masalahnya?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situs lama dan aplikasi Bereaksi baru memiliki siklus hidup yang sangat berbeda. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menempelkan kode sampel lama di dalam aplikasi Bereaksi, maka kode ini tidak akan memulai, karena Bereaksi tidak tahu cara mengaktifkannya. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena siklus hidup yang berbeda, Bereaksi dan mesin yang lama mungkin secara bersamaan mencoba untuk mengubah isi kode lama, yang dapat menyebabkan efek samping yang tidak menyenangkan. </font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah ini, kelas dasar umum dialokasikan untuk komponen yang berisi kode lama. </font><font style="vertical-align: inherit;">Kelas memungkinkan pewaris untuk mengoordinasikan siklus hidup aplikasi Bereaksi dan gaya lama.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldCodeBase</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<font></font>
<font></font>
    <span class="hljs-attr">ref</span>: React.RefObject&lt;HTMLElement&gt; = React.createRef();<font></font>
<font></font>
    componentDidMount() {<font></font>
        <span class="hljs-comment">//       DOM</span>
        <span class="hljs-keyword">this</span>.props.activate(<span class="hljs-keyword">this</span>.ref.current!); <font></font>
    }<font></font>
<font></font>
    componentWillUnmount() {<font></font>
        <span class="hljs-comment">//       DOM</span>
        <span class="hljs-keyword">this</span>.props.deactivate(<span class="hljs-keyword">this</span>.ref.current!); <font></font>
    }<font></font>
<font></font>
    shouldComponentUpdate() {<font></font>
        <span class="hljs-comment">// React     , </span>
        <span class="hljs-comment">//   React-. </span>
        <span class="hljs-comment">//     .</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.ref}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas memungkinkan Anda untuk membuat potongan kode yang bekerja dengan cara lama, atau menghancurkan, sementara tidak akan ada interaksi simultan dengan mereka. </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekatkan kode lama di server</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam praktiknya, ada kebutuhan untuk komponen pembungkus (misalnya, pop-up), yang isinya bisa apa saja, termasuk yang dibuat menggunakan teknologi lama. </font><font style="vertical-align: inherit;">Anda perlu mengetahui cara menanamkan kode apa pun di server di dalam komponen tersebut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel sebelumnya, kami berbicara tentang menggunakan atribut untuk meneruskan parameter ke komponen baru di klien dan server.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span> <span class="hljs-attr">users</span>=<span class="hljs-string">"[1,2,3]"</span> /&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang kita masih ingin menyisipkan sepotong markup di sana, yang artinya bukan atribut. </font><font style="vertical-align: inherit;">Untuk ini, diputuskan untuk menggunakan sistem slot.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ui:part</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"old-code"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>old component<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ui:part</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat dalam contoh di atas, di dalam kode komponen aplikasi keren, slot kode lama yang mengandung komponen lama dijelaskan. </font><font style="vertical-align: inherit;">Kemudian, di dalam komponen reaksi, tempat di mana Anda ingin menempelkan isi slot ini ditunjukkan:</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">UiPart</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"old-code"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    );<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesin server membuat komponen reaksi ini dan membingkai konten slot di tag &lt;ui-part&gt;, menetapkan atribut data-part-id = "old-code" ke dalamnya. </font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ui-part</span> <span class="hljs-attr">data-part-id</span>=<span class="hljs-string">"old-code"</span>&gt;</span><font></font>
            old code<font></font>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ui-part</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika rendering sisi server JS di GraalVM tidak cocok dengan batas waktu, maka kami melakukan fallback ke rendering klien. </font><font style="vertical-align: inherit;">Untuk melakukan ini, mesin di server hanya memberikan slot, membingkai mereka di tag templat sehingga browser tidak berinteraksi dengan kode mereka.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ui-part</span> <span class="hljs-attr">data-part-id</span>=<span class="hljs-string">"old-code"</span>&gt;</span><font></font>
            old code<font></font>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ui-part</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi pada klien? </font><font style="vertical-align: inherit;">Mesin klien hanya memindai kode komponen, mengumpulkan tag &lt;ui-part&gt;, menerima isinya dalam bentuk string, dan meneruskannya ke fungsi rendering bersama dengan parameter lainnya.</font></font><br>
 <br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> tagName = <span class="hljs-string">'cool-app'</span>;
<span class="hljs-keyword">var</span> reactComponent = components[tagName];<font></font>
reactComponent.render({<font></font>
       <span class="hljs-attr">tagName</span>: tagName,
       <span class="hljs-attr">attrs</span>: attrs,
       <span class="hljs-attr">parts</span>: parts,
       <span class="hljs-attr">node</span>: element<font></font>
});<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode komponen yang memasukkan slot ke lokasi yang diinginkan adalah sebagai berikut: </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OldCodeBase</span>&lt;<span class="hljs-title">IProps</span>&gt; </span>{<font></font>
<font></font>
	render() {<font></font>
		<span class="hljs-keyword">const</span> id = <span class="hljs-keyword">this</span>.props.id;
		<span class="hljs-keyword">const</span> parts = <span class="hljs-keyword">this</span>.props.parts;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!parts.hasOwnProperty(id)) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
		}<font></font>
<font></font>
		<span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'ui-part'</span>, {
			<span class="hljs-string">'data-part-id'</span>: id,
			<span class="hljs-attr">ref</span>: <span class="hljs-keyword">this</span>.ref,
			<span class="hljs-attr">dangerouslySetInnerHTML</span>: { <span class="hljs-attr">__html</span>: parts[id] }<font></font>
		});<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, ini diwarisi dari kelas OldCodeBase, yang memecahkan masalah interaksi antara tumpukan yang lama dan yang baru. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/ge/cc/a3/gecca3dlxac9crp48u9pvoyc4vs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda dapat menulis pop-up dan mengisinya menggunakan tumpukan baru atau permintaan dari server menggunakan pendekatan lama. </font><font style="vertical-align: inherit;">Dalam hal ini, komponen akan berfungsi dengan benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini memungkinkan Anda untuk secara bertahap memigrasi komponen situs ke tumpukan baru. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hanya ini adalah salah satu persyaratan utama untuk frontend baru.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua orang bertanya-tanya seberapa cepat GraalVM bekerja. </font><font style="vertical-align: inherit;">Pengembang Odnoklassniki melakukan berbagai tes dengan Bereaksi aplikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi sederhana yang mengembalikan string setelah pemanasan membutuhkan waktu sekitar 1 mikrodetik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komponen (lagi setelah pemanasan) - dari 0,5 hingga 6 milidetik, tergantung pada ukurannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GraalVM berakselerasi lebih lambat dari V8. </font><font style="vertical-align: inherit;">Tetapi untuk saat pemanasannya, situasinya menjadi lancar berkat kemunduran rendering klien. </font><font style="vertical-align: inherit;">Karena ada begitu banyak pengguna, mesin virtual memanas dengan cepat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang berhasil Anda lakukan</font></font></h3><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalankan JavaScript di server di dunia Java Classmates.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat kode isomorfik untuk UI.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan tumpukan modern yang diketahui semua vendor front-end.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat platform umum dan pendekatan tunggal untuk menulis UI.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai transisi yang lancar tanpa mempersulit operasi dan tidak memperlambat rendering server.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berharap pengalaman Odnoklassniki dan contoh-contohnya akan bermanfaat bagi Anda dan Anda akan menemukannya untuk digunakan dalam pekerjaan Anda.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486810/">https://habr.com/ru/post/id486810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486798/index.html">Apakah ada GameDev di Sakhalin? Akhir</a></li>
<li><a href="../id486800/index.html">Cassandra. Bagaimana tidak mati jika Anda hanya tahu Oracle</a></li>
<li><a href="../id486802/index.html">Orang-orang bertemu dengan sistem pemberi rekomendasi. Faktorisasi</a></li>
<li><a href="../id486804/index.html">Informatika Kesehatan Global: Teknologi Cloud</a></li>
<li><a href="../id486808/index.html">Tes kehamilan elektronik dari apotek: cara kerjanya</a></li>
<li><a href="../id486814/index.html">Zabbix: topologi jaringan jelas dan otomatis</a></li>
<li><a href="../id486818/index.html">Porting Quake ke iPod Classic</a></li>
<li><a href="../id486820/index.html">70 Pertanyaan Wawancara Javascript</a></li>
<li><a href="../id486822/index.html">[Di dermaga] Berkibar. Bagian 4. Untuk pengembang web</a></li>
<li><a href="../id486824/index.html">Saran buruk ketika bekerja dengan ANTLR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>