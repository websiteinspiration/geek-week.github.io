<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏻 🗳️ 🔦 Unityでタワーディフェンスを作成する：敵 🙅 📕 ✊🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ 最初の部分：タイルとパスの検索 ]
 
 

- 敵作成ポイントの配置。
- 敵の出現とフィールド全体の動き。
- 一定速度で滑らかなモーションを作成します。
- 敵のサイズ、速度、配置を変更します。
 これは、単純なタワーディフェンスゲームのチュートリアルのパート2 です。敵を作成するプロセス...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityでタワーディフェンスを作成する：敵</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452756/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の部分：タイルとパスの検索</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font></i><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵作成ポイントの配置。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵の出現とフィールド全体の動き。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一定速度で滑らかなモーションを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵のサイズ、速度、配置を変更します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、単純な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タワーディフェンス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームのチュートリアルのパート2 </font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">敵を作成するプロセスと、最も近いエンドポイントへの移動を考慮します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルはUnity 2018.3.0f2で作成されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/cf3/311/2dbcf331117740aa403cb12a757ae6fd.jpg" width="512" height="256"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終点に向かう途中の敵。</font></font></i><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵作成（スポーン）ポイント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵の作成を​​開始する前に、フィールドのどこに配置するかを決める必要があります。</font><font style="vertical-align: inherit;">これを行うには、スポーンポイントを作成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルコンテンツ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スポーンポイントは別のタイプのタイルコンテンツなので、にエントリを追加し</font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> GameTileContentType {<font></font>
	Empty, Destination, Wall, SpawnPoint<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それを視覚化するためのプレハブを作成します。</font><font style="vertical-align: inherit;">開始点のプレハブの複製は非常に適しています。コンテンツのタイプを変更して、別のマテリアルを提供するだけです。</font><font style="vertical-align: inherit;">オレンジにしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/522/28d/e3952228dacd6801a6f5d2fb53826cc2.png" width="320" height="104"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーンポイントの構成。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテンツファクトリにスポーンポイントサポートを追加し、プレハブへのリンクを付与します。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField</span>]<font></font>
	GameTileContent spawnPointPrefab = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTileContent <span class="hljs-title">Get</span> (<span class="hljs-params">GameTileContentType type</span>)</span> {
		<span class="hljs-keyword">switch</span> (type) {
			<span class="hljs-keyword">case</span> GameTileContentType.Destination: <span class="hljs-keyword">return</span> Get(destinationPrefab);
			<span class="hljs-keyword">case</span> GameTileContentType.Empty: <span class="hljs-keyword">return</span> Get(emptyPrefab);
			<span class="hljs-keyword">case</span> GameTileContentType.Wall: <span class="hljs-keyword">return</span> Get(wallPrefab);
			<span class="hljs-keyword">case</span> GameTileContentType.SpawnPoint: <span class="hljs-keyword">return</span> Get(spawnPointPrefab);<font></font>
		}<font></font>
		Debug.Assert(<span class="hljs-literal">false</span>, <span class="hljs-string">"Unsupported type: "</span> + type);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10f/036/a17/10f036a17ae271cf7b7f7c9694e01782.png" width="320" height="142"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーンポイントをサポートするファクトリ。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーンポイントを有効または無効にする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の切り替え方法と同様に、スポーンポイントの状態を切り替える方法をに追加し</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ただし、スポーンポイントはパスの検索に影響しないため、変更後は新しいパスを探す必要はありません。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ToggleSpawnPoint</span> (<span class="hljs-params">GameTile tile</span>)</span> {
		<span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.SpawnPoint) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Empty) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint);<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゲームは、敵がいてスポーンポイントが必要な場合にのみ意味があります。</font><font style="vertical-align: inherit;">したがって、ゲームフィールドには少なくとも1つのスポーンポイントが含まれている必要があります。</font><font style="vertical-align: inherit;">将来、敵を追加するときにスポーンポイントにもアクセスする必要があるため、リストを使用して、これらのポイントを持つすべてのタイルを追跡しましょう。</font><font style="vertical-align: inherit;">スポーンポイントの状態を切り替えるときにリストを更新し、最後のスポーンポイントが削除されないようにします。</font></font><br>
<br>
<pre><code class="cs hljs">	List&lt;GameTile&gt; spawnPoints = <span class="hljs-keyword">new</span> List&lt;GameTile&gt;();<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ToggleSpawnPoint</span> (<span class="hljs-params">GameTile tile</span>)</span> {
		<span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.SpawnPoint) {
			<span class="hljs-keyword">if</span> (spawnPoints.Count &gt; <span class="hljs-number">1</span>) {<font></font>
				spawnPoints.Remove(tile);<font></font>
				tile.Content = contentFactory.Get(GameTileContentType.Empty);<font></font>
			}<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tile.Content.Type == GameTileContentType.Empty) {<font></font>
			tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint);<font></font>
			spawnPoints.Add(tile);<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、スポーンポイントを設定して、フィールドの初期の正しい状態を作成する必要があります。</font><font style="vertical-align: inherit;">左下隅にある最初のタイルだけを含めましょう。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span> (<span class="hljs-params">
		Vector2Int size, GameTileContentFactory contentFactory
	</span>)</span> {<font></font>
		…<font></font>
<font></font>
		ToggleDestination(tiles[tiles.Length / <span class="hljs-number">2</span>]);<font></font>
		ToggleSpawnPoint(tiles[<span class="hljs-number">0</span>]);<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、別のタッチでスポーンポイントの状態が切り替わることを確認しますが、Shiftキーを押したままにすると（キーストロークはメソッドによってチェックされます</font></font><code>Input.GetKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、エンドポイントの状態が切り替わります</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleAlternativeTouch</span> (<span class="hljs-params"></span>)</span> {<font></font>
		GameTile tile = board.GetTile(TouchRay);<font></font>
		<span class="hljs-keyword">if</span> (tile != <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.LeftShift)) {<font></font>
				board.ToggleDestination(tile);<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {<font></font>
				board.ToggleSpawnPoint(tile);<font></font>
			}<font></font>
		}<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f9/cd6/22b/2f9cd622bf1aa41023e5204e1f4caa9a.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーンドットのフィールド。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーンポイントにアクセスする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールドはすべてのタイルを扱いますが、敵はその責任を負いません。</font></font><code>GetSpawnPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスパラメータ</font><font style="vertical-align: inherit;">を持つ一般的なメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">介して、スポーンポイントにアクセスできるようにし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTile <span class="hljs-title">GetSpawnPoint</span> (<span class="hljs-params"><span class="hljs-keyword">int</span> index</span>)</span> {
		<span class="hljs-keyword">return</span> spawnPoints[index];<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのインデックスが正しいかを知るには、スポーンポイントの数に関する情報が必要なので、一般的なgetterプロパティを使用して一般的なものにします。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> SpawnPointCount =&gt; spawnPoints.Count;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵のスポーン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵をスポーンすることは、タイルのコンテンツを作成することにいくらか似ています。</font><font style="vertical-align: inherit;">工場でプレハブインスタンスを作成し、それをフィールドに配置します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工場</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分たちが作ったものをすべて自分のステージに置く、敵の工場を作ります。この機能はすでにあるファクトリーと共通なので、そのためのコードを共通の基本クラスに入れましょう</font></font><code>GameObjectFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>CreateGameObjectInstance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なプレハブパラメータ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つ</font><font style="vertical-align: inherit;">1つのメソッド</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">十分です</font><font style="vertical-align: inherit;">。インスタンスを作成して返し、シーン全体を管理します。メソッドを作成</font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。つまり、クラスとそのクラスから継承するすべてのタイプでのみ使用できます。クラスが行うことはこれだけであり、完全に機能するファクトリとして使用するためのものではありません。したがって、それをとしてマークすると</font></font><code>abstract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、オブジェクトのインスタンスを作成できなくなります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameObjectFactory</span> : <span class="hljs-title">ScriptableObject</span> {<font></font>
<font></font>
	Scene scene;<font></font>
<font></font>
	<span class="hljs-keyword">protected</span> T CreateGameObjectInstance&lt;T&gt; (T prefab) <span class="hljs-keyword">where</span> T : MonoBehaviour {
		<span class="hljs-keyword">if</span> (!scene.isLoaded) {
			<span class="hljs-keyword">if</span> (Application.isEditor) {<font></font>
				scene = SceneManager.GetSceneByName(name);<font></font>
				<span class="hljs-keyword">if</span> (!scene.isLoaded) {<font></font>
					scene = SceneManager.CreateScene(name);<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {<font></font>
				scene = SceneManager.CreateScene(name);<font></font>
			}<font></font>
		}<font></font>
		T instance = Instantiate(prefab);<font></font>
		SceneManager.MoveGameObjectToScene(instance.gameObject, scene);<font></font>
		<span class="hljs-keyword">return</span> instance;<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このタイプのファクトリーを継承</font></font><code>CreateGameObjectInstance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してメソッド</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">使用するように</font><font style="vertical-align: inherit;">
変更し</font><font style="vertical-align: inherit;">、シーンコントロールコードを削除します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
[<span class="hljs-meta">CreateAssetMenu</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameTileContentFactory</span> : <span class="hljs-title">GameObjectFactory</span> {<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-comment">//Scene contentScene;</span><font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function">GameTileContent <span class="hljs-title">Get</span> (<span class="hljs-params">GameTileContent prefab</span>)</span> {<font></font>
		GameTileContent instance = CreateGameObjectInstance(prefab);<font></font>
		instance.OriginFactory = <span class="hljs-keyword">this</span>;
		<span class="hljs-comment">//MoveToFactoryScene(instance.gameObject);</span>
		<span class="hljs-keyword">return</span> instance;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//void MoveToFactoryScene (GameObject o) {</span>
	<span class="hljs-comment">//	…</span>
        <span class="hljs-comment">//}</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後</font><font style="vertical-align: inherit;">、メソッド</font><font style="vertical-align: inherit;">と付随するメソッド</font><font style="vertical-align: inherit;">を使用して、</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのプレハブのインスタンスを</font><font style="vertical-align: inherit;">作成する新しいタイプ</font><font style="vertical-align: inherit;">を作成します</font><font style="vertical-align: inherit;">。</font></font><code>Enemy</code><font style="vertical-align: inherit;"></font><code>Get</code><font style="vertical-align: inherit;"></font><code>Reclaim</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
[<span class="hljs-meta">CreateAssetMenu</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnemyFactory</span> : <span class="hljs-title">GameObjectFactory</span> {<font></font>
	<font></font>
	[<span class="hljs-meta">SerializeField</span>]<font></font>
	Enemy prefab = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Enemy <span class="hljs-title">Get</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Enemy instance = CreateGameObjectInstance(prefab);<font></font>
		instance.OriginFactory = <span class="hljs-keyword">this</span>;
		<span class="hljs-keyword">return</span> instance;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reclaim</span> (<span class="hljs-params">Enemy enemy</span>)</span> {<font></font>
		Debug.Assert(enemy.OriginFactory == <span class="hljs-keyword">this</span>, <span class="hljs-string">"Wrong factory reclaimed!"</span>);<font></font>
		Destroy(enemy.gameObject);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいタイプ</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は当初、元の工場を追跡するだけで済みました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span> {<font></font>
<font></font>
	EnemyFactory originFactory;<font></font>
<font></font>
	<span class="hljs-keyword">public</span> EnemyFactory OriginFactory {
		<span class="hljs-keyword">get</span> =&gt; originFactory;
		<span class="hljs-keyword">set</span> {<font></font>
			Debug.Assert(originFactory == <span class="hljs-literal">null</span>, <span class="hljs-string">"Redefined origin factory!"</span>);<font></font>
			originFactory = <span class="hljs-keyword">value</span>;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレハブ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵は視覚化を必要とします。それは、ロボット、クモ、幽霊、もっと簡単なもの、たとえば、私たちが使用する立方体などです。</font><font style="vertical-align: inherit;">しかし、一般的に、敵には複雑な3Dモデルがあります。</font><font style="vertical-align: inherit;">その便利なサポートを提供するために、コンポーネントのみが接続されている敵のプレハブ階層のルートオブジェクトを使用します</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/348/428/7c6348428b50732e0a13efcdadfc9fff.png" width="320" height="160"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレハブルート </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオブジェクトを、モデルルートになる唯一の子要素として作成しましょう。</font><font style="vertical-align: inherit;">変換単位の値が必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce7/691/330/ce7691330dd6c6813d2a64398c582c2a.png" width="320" height="120"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルのルート。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルルートのタスクは、敵の座標のローカル原点を基準にして3Dモデルを配置し、敵が立っているまたはぶら下がっている参照点と見なすようにすることです。</font><font style="vertical-align: inherit;">私たちの場合、モデルは標準のハーフサイズの立方体になり、それにダークブルーの色を付けます。</font><font style="vertical-align: inherit;">これをモデルルートの子にし、地面に立つようにY位置を0.25に設定します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/7a3/808/65b7a3808f469e2723b344afccd94f8f.png" width="320" height="206"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューブモデル </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、敵のプレハブは、3つのネストされたオブジェクト（プレハブルート、モデルルート、キューブ）で構成されます。</font><font style="vertical-align: inherit;">単純な立方体にとってはバストのように見えるかもしれませんが、そのようなシステムを使用すると、その機能を気にせずに敵を移動してアニメーション化できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/0c9/abb/62a0c9abb59605150235ba6cec73eeb2.png" width="225" height="74"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵のプレハブ階層。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵の工場を作り、それにプレハブを割り当てましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae3/ee2/345/ae3ee23456931ac6f989a763deb8b7b1.png" width="320" height="88"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセットファクトリ。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵をフィールドに配置する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵をフィールドに配置するには</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、敵の工場へのリンクを受け取る必要があります。</font><font style="vertical-align: inherit;">多くの敵が必要なため、1秒あたりの敵の数で表される、スポーンの速度を調整する構成オプションを追加します。</font><font style="vertical-align: inherit;">許容範囲は0.1〜10で、デフォルト値は1です。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField</span>]<font></font>
	EnemyFactory enemyFactory = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
	[<span class="hljs-meta">SerializeField, Range(0.1f, 10f)</span>]
	<span class="hljs-keyword">float</span> spawnSpeed = <span class="hljs-number">1f</span>;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/56b/338/20156b3384b45ab95d7aef5ed5397480.png" width="320" height="144"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵のファクトリーとスポーン速度4のゲーム。でのスポーン</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の進行状況を追跡</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、速度に時間のデルタを掛けて増加させます。</font><font style="vertical-align: inherit;">prggressの値が1を超える場合、値を減らし、新しいメソッドを使用して敵をスポーンします</font></font><code>SpawnEnemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">速度が速すぎてフレーム時間が非常に長く、複数の敵が同時に作成されない場合に備えて、進行状況が1を超えるまでこれを続けます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">float</span> spawnProgress;<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
<font></font>
		spawnProgress += spawnSpeed * Time.deltaTime;<font></font>
		<span class="hljs-keyword">while</span> (spawnProgress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			spawnProgress -= <span class="hljs-number">1f</span>;<font></font>
			SpawnEnemy();<font></font>
		}<font></font>
	}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FixedUpdateで進行状況を更新する必要はありませんか？</font></font></b><div class="spoiler_text">,  ,     tower defense     .           ,         .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼がしてみましょう</font></font><code>SpawnEnemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドからランダムスポーンポイントを受け取り、このタイルで敵を作成します。</font><font style="vertical-align: inherit;">自分自身を正しく配置</font><font style="vertical-align: inherit;">する</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を示します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpawnEnemy</span> (<span class="hljs-params"></span>)</span> {<font></font>
		GameTile spawnPoint =<font></font>
			board.GetSpawnPoint(Random.Range(<span class="hljs-number">0</span>, board.SpawnPointCount));<font></font>
		Enemy enemy = enemyFactory.Get();<font></font>
		enemy.SpawnOn(spawnPoint);<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とりあえず</font></font><code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、自分の位置をタイルの中心に設定</font><font style="vertical-align: inherit;">するだけ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">プレハブモデルが正しく配置されているため、敵の立方体はこのタイルの上にあります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnOn</span> (<span class="hljs-params">GameTile tile</span>)</span> {<font></font>
		transform.localPosition = tile.transform.localPosition;<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b5/74a/ce9/8b574ace93bd2c7f7829d41f9208a138.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵はスポーンポイントに出現します。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵を動かす</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵が現れた後、彼はパスに沿って最も近い終点まで移動を開始する必要があります。</font><font style="vertical-align: inherit;">これを達成するには、敵をアニメートする必要があります。</font><font style="vertical-align: inherit;">タイルからタイルへの単純な滑らかな滑りから始め、次にそれらの動きをより困難にします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵のコレクション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵の状態を更新するには、チュートリアルの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト管理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリーズで使用されたのと同じアプローチを使用し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">彼が生きているかどうかについての情報を返す</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なメソッド</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加し</font><font style="vertical-align: inherit;">ます。この段階では常にtrueになります。</font><font style="vertical-align: inherit;">とりあえず、時間のデルタに従って彼を前進させるだけです。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		transform.localPosition += Vector3.forward * Time.deltaTime;<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、生きている敵のリストを維持し、すべてを更新して、死んだ敵のリストから削除する必要があります。</font><font style="vertical-align: inherit;">このすべてのコードをに入れることができますが</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、代わりにそれを分離して型を作成します</font></font><code>EnemyCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、何も継承しないシリアライズ可能なクラスです。</font><font style="vertical-align: inherit;">敵を追加する一般的な方法とコレクション全体を更新する別の方法を彼に与えます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections.Generic;<font></font>
<font></font>
[<span class="hljs-meta">System.Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnemyCollection</span> {<font></font>
<font></font>
	List&lt;Enemy&gt; enemies = <span class="hljs-keyword">new</span> List&lt;Enemy&gt;();<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span> (<span class="hljs-params">Enemy enemy</span>)</span> {<font></font>
		enemies.Add(enemy);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enemies.Count; i++) {
			<span class="hljs-keyword">if</span> (!enemies[i].GameUpdate()) {
				<span class="hljs-keyword">int</span> lastIndex = enemies.Count - <span class="hljs-number">1</span>;<font></font>
				enemies[i] = enemies[lastIndex];<font></font>
				enemies.RemoveAt(lastIndex);<font></font>
				i -= <span class="hljs-number">1</span>;<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのようなコレクションを1つだけ作成するだけで十分です。各フレームでそれを更新し、作成した敵をそれに追加します。</font><font style="vertical-align: inherit;">新しい敵が発生する可能性があるとすぐに敵を更新し、更新が即座に行われるようにします。</font></font><br>
<br>
<pre><code class="cs hljs">	EnemyCollection enemies = <span class="hljs-keyword">new</span> EnemyCollection();<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		enemies.GameUpdate();<font></font>
	}<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpawnEnemy</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		enemies.Add(enemy);<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/eb8/dc6/25feb8dc6f0d3a5a66be43f311cd7818.png" width="230" height="230"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵は前進しています。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道中の動き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵はすでに動いていますが、これまでのところ進路をたどっていません。これを行うには、彼らは次にどこへ行くかを知る必要があります。したがって、</font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パス上の次のタイルを取得</font><font style="vertical-align: inherit;">するための</font><font style="vertical-align: inherit;">共通のゲッタープロパティを指定します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">public</span> GameTile NextTileOnPath =&gt; nextOnPath;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出るタイルと入るタイルを知っている敵は、1つのタイルを移動するための開始点と終了点を決定できます。敵はこれらの2点間の位置を補間して、それらの動きを追跡できます。移動が完了した後、このプロセスは次のタイルに対して繰り返されます。ただし、パスはいつでも変更できます。移動の過程でさらにどこに移動するかを決定する代わりに、計画されたルートに沿って移動し続け、それをチェックして、次のタイルに到達します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはしてみましょう</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それがパスの変化に影響されないように、両方のタイルを追跡します。彼はまた、各フレームでそれらを受け取る必要がないように位置を追跡し、移動のプロセスを追跡します。</font></font><br>
<br>
<pre><code class="cs hljs">	GameTile tileFrom, tileTo;<font></font>
	Vector3 positionFrom, positionTo;<font></font>
	<span class="hljs-keyword">float</span> progress;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのフィールドはで初期化し</font></font><code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。最初のポイントは敵の移動元のタイルであり、終了ポイントはパス上の次のタイルです。これは、敵がエンドポイントで作成されない限り、次のタイルが存在することを前提としています。次に、タイルの位置をキャッシュし、進行状況をリセットします。敵のメソッド</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は同じフレームで呼び出される</font><font style="vertical-align: inherit;">ため、ここで敵の位置を設定する必要はありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnOn</span> (<span class="hljs-params">GameTile tile</span>)</span> {
		<span class="hljs-comment">//transform.localPosition = tile.transform.localPosition;</span>
		Debug.Assert(tile.NextTileOnPath != <span class="hljs-literal">null</span>, <span class="hljs-string">"Nowhere to go!"</span>, <span class="hljs-keyword">this</span>);<font></font>
		tileFrom = tile;<font></font>
		tileTo = tile.NextTileOnPath;<font></font>
		positionFrom = tileFrom.transform.localPosition;<font></font>
		positionTo = tileTo.transform.localPosition;<font></font>
		progress = <span class="hljs-number">0f</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
増分の進行はで実行され</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。一定の時間差を追加して、敵が1タイル/秒の速度で移動するようにします。進行が完了すると、データ</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が値</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">なる</font><font style="vertical-align: inherit;">ようにデータがシフトさ</font><font style="vertical-align: inherit;">れ、パス上の次のタイル</font><font style="vertical-align: inherit;">が</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しくなり</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。次に、進捗を減らします。データが関連になると、間に敵の位置を補間</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。内挿は進行中であるため、その値は必ず0から1の範囲内にあるため、sを使用できます</font></font><code>Vector3.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime;<font></font>
		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			tileFrom = tileTo;<font></font>
			tileTo = tileTo.NextTileOnPath;<font></font>
			positionFrom = positionTo;<font></font>
			positionTo = tileTo.transform.localPosition;<font></font>
			progress -= <span class="hljs-number">1f</span>;<font></font>
		}<font></font>
		transform.localPosition =<font></font>
			Vector3.LerpUnclamped(positionFrom, positionTo, progress);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、敵は経路をたどりますが、終点に到達しても動作しません。</font><font style="vertical-align: inherit;">したがって、位置</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font><font style="vertical-align: inherit;">変更する前</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、パスの次のタイルをと比較する必要があります</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もしそうなら、私たちは終点に到達し、敵はその動きを終えました。</font><font style="vertical-align: inherit;">そのために再生を実行して返し</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			tileFrom = tileTo;<font></font>
			tileTo = tileTo.NextTileOnPath;<font></font>
			<span class="hljs-keyword">if</span> (tileTo == <span class="hljs-literal">null</span>) {<font></font>
				OriginFactory.Reclaim(<span class="hljs-keyword">this</span>);
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
			}<font></font>
			positionFrom = positionTo;<font></font>
			positionTo = tileTo.transform.localPosition;<font></font>
			progress -= <span class="hljs-number">1f</span>;<font></font>
		}</code></pre><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵は最短経路をたどります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵がタイルの中心から別のタイルに移動しています。</font><font style="vertical-align: inherit;">彼らはタイルの中央でのみ動きの状態を変えるので、フィールドの変化に即座に対応できないことを考慮する価値があります。</font><font style="vertical-align: inherit;">これは、敵がたった今設置された壁を通って移動することを意味します。</font><font style="vertical-align: inherit;">彼らが独房に向かって動き始めたら、彼らを止めるものは何もない。</font><font style="vertical-align: inherit;">そのため、壁にも実際のパスが必要です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵はパスの変化に反応します。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端から端までの動き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイルの中心間の動きと方向の急激な変化は、敵がブロックを動かしている抽象的なゲームでは正常に見えますが、通常、スムーズな動きはより美しく見えます。</font><font style="vertical-align: inherit;">実装の最初のステップは、中心ではなく、タイルの端に沿った動きです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接するタイル間のエッジポイントは、それらの位置を平均化することによって見つけることができます。</font><font style="vertical-align: inherit;">各敵のすべてのステップで計算するのではなく、パスをに変更したときにのみ計算し</font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">プロパティを使用して利用できるようにします</font></font><code>ExitPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">public</span> Vector3 ExitPoint { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
	…<font></font>
	<font></font>
	<span class="hljs-function">GameTile <span class="hljs-title">GrowPathTo</span> (<span class="hljs-params">GameTile neighbor</span>)</span> {<font></font>
		…<font></font>
		neighbor.ExitPoint =<font></font>
			(neighbor.transform.localPosition + transform.localPosition) * <span class="hljs-number">0.5f</span>;
		<span class="hljs-keyword">return</span>
			neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal">null</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一の特殊なケースは最後のセルで、その出口点はその中心になります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BecomeDestination</span> (<span class="hljs-params"></span>)</span> {<font></font>
		distance = <span class="hljs-number">0</span>;<font></font>
		nextOnPath = <span class="hljs-literal">null</span>;<font></font>
		ExitPoint = transform.localPosition;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルの中心ではなく、出口点を使用するように</font><font style="vertical-align: inherit;">
変更</font><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime;<font></font>
		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			…<font></font>
			positionTo = tileFrom.ExitPoint;<font></font>
			progress -= <span class="hljs-number">1f</span>;<font></font>
		}<font></font>
		transform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnOn</span> (<span class="hljs-params">GameTile tile</span>)</span> {<font></font>
		…<font></font>
		positionTo = tileFrom.ExitPoint;<font></font>
		progress = <span class="hljs-number">0f</span>;<font></font>
	}</code></pre><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵は端の間を移動します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この変更の副作用は、パスの変更により敵が方向転換したときに、一秒間静止したままになることです。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回転すると敵が止まります。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリエンテーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵は方向を変えるまでパスに沿って移動しますが。</font><font style="vertical-align: inherit;">彼らが動く方向を見ることができるように、彼らは彼らがたどっている道の方向を知る必要があります。</font><font style="vertical-align: inherit;">また、方法の検索中にこれを決定するので、これは敵によって行われる必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
北、東、南、西の4つの方向があります。</font><font style="vertical-align: inherit;">それらを列挙しましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Direction {<font></font>
	North, East, South, West<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パスの方向を格納</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">プロパティを指定します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">public</span> Direction PathDirection { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }</code></pre><br><font style="vertical-align: inherit;"></font><code>GrowTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティを設定</font><font style="vertical-align: inherit;">
する方向パラメータkを追加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私たちは終わりから始まりまでのパスを成長させているので、方向は私たちがパスを成長させているところとは逆になります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTile <span class="hljs-title">GrowPathNorth</span> (<span class="hljs-params"></span>)</span> =&gt; GrowPathTo(north, Direction.South);<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTile <span class="hljs-title">GrowPathEast</span> (<span class="hljs-params"></span>)</span> =&gt; GrowPathTo(east, Direction.West);<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTile <span class="hljs-title">GrowPathSouth</span> (<span class="hljs-params"></span>)</span> =&gt; GrowPathTo(south, Direction.North);<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> GameTile <span class="hljs-title">GrowPathWest</span> (<span class="hljs-params"></span>)</span> =&gt; GrowPathTo(west, Direction.East);<font></font>
<font></font>
	<span class="hljs-function">GameTile <span class="hljs-title">GrowPathTo</span> (<span class="hljs-params">GameTile neighbor, Direction direction</span>)</span> {<font></font>
		…<font></font>
		neighbor.PathDirection = direction;<font></font>
		<span class="hljs-keyword">return</span>
			neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal">null</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方向を四元数で表されたターンに変換する必要があります。</font></font><code>GetRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方向を</font><font style="vertical-align: inherit;">呼び出すだけ</font><font style="vertical-align: inherit;">でよいので、拡張メソッドを作成してみましょう。</font><font style="vertical-align: inherit;">一般的な静的メソッドを追加し</font></font><code>DirectionExtensions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、必要な四元数をキャッシュする配列と</font></font><code>GetRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、対応する方向の値を返す</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この場合、拡張クラスを列挙型と同じファイルに配置することは理にかなっています。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Direction {<font></font>
	North, East, South, West<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DirectionExtensions</span> {<font></font>
<font></font>
	<span class="hljs-keyword">static</span> Quaternion[] rotations = {<font></font>
		Quaternion.identity,<font></font>
		Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">90f</span>, <span class="hljs-number">0f</span>),<font></font>
		Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">180f</span>, <span class="hljs-number">0f</span>),<font></font>
		Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">270f</span>, <span class="hljs-number">0f</span>)<font></font>
	};<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Quaternion <span class="hljs-title">GetRotation</span> (<span class="hljs-params"><span class="hljs-keyword">this</span> Direction direction</span>)</span> {
		<span class="hljs-keyword">return</span> rotations[(<span class="hljs-keyword">int</span>)direction];<font></font>
	}<font></font>
}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張方法とは何ですか？</font></font></b><div class="spoiler_text">  —      ,      - .     , , ,    .         <code>this</code>.      ,     .   ,    .<br>
<br>
       ? ,  ,       ,     .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スポーン</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ときと新しいタイルに入るたびに</font><font style="vertical-align: inherit;">方向を変えることができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">データを更新すると、タイル</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は方向を示します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime;<font></font>
		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			…<font></font>
			transform.localRotation = tileFrom.PathDirection.GetRotation();<font></font>
			progress -= <span class="hljs-number">1f</span>;<font></font>
		}<font></font>
		transform.localPosition =<font></font>
			Vector3.LerpUnclamped(positionFrom, positionTo, progress);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnOn</span> (<span class="hljs-params">GameTile tile</span>)</span> {<font></font>
		…<font></font>
		transform.localRotation = tileFrom.PathDirection.GetRotation();<font></font>
		progress = <span class="hljs-number">0f</span>;<font></font>
	}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方向転換</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方向を瞬時に変えるのではなく、位置の間を補間する方法と同様に、ターン間の値を補間することをお勧めします。</font><font style="vertical-align: inherit;">ある方向から別の方向に移動するには、実行する必要のある方向の変化を知る必要があります。</font><font style="vertical-align: inherit;">これには列挙型を追加します。列挙型</font></font><code>Direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は小さく、密接に関連しているため</font><font style="vertical-align: inherit;">、と同じファイルに配置できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Direction {<font></font>
	North, East, South, West<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> DirectionChange {<font></font>
	None, TurnRight, TurnLeft, TurnAround<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回</font></font><code>GetDirectionChangeTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、現在の方向から次の方向への方向の変更を返す</font><font style="vertical-align: inherit;">別の拡張メソッドを追加</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">方向が一致する場合、シフトはありません。</font><font style="vertical-align: inherit;">次のものが現在より多い場合、これは右へのターンです。</font><font style="vertical-align: inherit;">しかし、方向が繰り返されているため、次が現在のものより3つ少ない場合も同じ状況になります。</font><font style="vertical-align: inherit;">左折すると同じで、足し算と引き算だけで場所が変わります。</font><font style="vertical-align: inherit;">残っている唯一のケースはターンバックです。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DirectionChange <span class="hljs-title">GetDirectionChangeTo</span> (<span class="hljs-params">
		<span class="hljs-keyword">this</span> Direction current, Direction next
	</span>)</span> {
		<span class="hljs-keyword">if</span> (current == next) {
			<span class="hljs-keyword">return</span> DirectionChange.None;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current + <span class="hljs-number">1</span> == next || current - <span class="hljs-number">3</span> == next) {
			<span class="hljs-keyword">return</span> DirectionChange.TurnRight;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current - <span class="hljs-number">1</span> == next || current + <span class="hljs-number">3</span> == next) {
			<span class="hljs-keyword">return</span> DirectionChange.TurnLeft;<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> DirectionChange.TurnAround;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回転は1次元のみなので、角度の線形補間で十分です。</font><font style="vertical-align: inherit;">方向の角度を度数で取得する別の拡張メソッドを追加します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> <span class="hljs-title">GetAngle</span> (<span class="hljs-params"><span class="hljs-keyword">this</span> Direction direction</span>)</span> {
		<span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>)direction * <span class="hljs-number">90f</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、方向、方向の変更、および補間を実行する必要のある角度を追跡する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	Direction direction;<font></font>
	DirectionChange directionChange;<font></font>
	<span class="hljs-keyword">float</span> directionAngleFrom, directionAngleTo;</code></pre><br>
<code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">難しくなっているので、状態準備コードを別のメソッドに移動しましょう。</font><font style="vertical-align: inherit;">敵の初期状態を導入状態に指定するので、これをと呼びます</font></font><code>PrepareIntro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この状態では、敵は最初のタイルの中央から端に移動するため、方向は変わりません。</font><font style="vertical-align: inherit;">角度</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnOn</span> (<span class="hljs-params">GameTile tile</span>)</span> {<font></font>
		Debug.Assert(tile.NextTileOnPath != <span class="hljs-literal">null</span>, <span class="hljs-string">"Nowhere to go!"</span>, <span class="hljs-keyword">this</span>);<font></font>
		tileFrom = tile;<font></font>
		tileTo = tile.NextTileOnPath;<font></font>
		<span class="hljs-comment">//positionFrom = tileFrom.transform.localPosition;</span>
		<span class="hljs-comment">//positionTo = tileFrom.ExitPoint;</span>
		<span class="hljs-comment">//transform.localRotation = tileFrom.PathDirection.GetRotation();</span>
		progress = <span class="hljs-number">0f</span>;<font></font>
		PrepareIntro();<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareIntro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		positionFrom = tileFrom.transform.localPosition;<font></font>
		positionTo = tileFrom.ExitPoint;<font></font>
		direction = tileFrom.PathDirection;<font></font>
		directionChange = DirectionChange.None;<font></font>
		directionAngleFrom = directionAngleTo = direction.GetAngle();<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、小さな状態機械のようなものを作成します。</font><font style="vertical-align: inherit;">単純化するために</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ステータスコードを新しいメソッドに移動します</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここでは</font><font style="vertical-align: inherit;">、敵がパスを終了したかどうかを確認するためにそれらを使用するため</font><font style="vertical-align: inherit;">、タイル</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">への変更のみを残し</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime;<font></font>
		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			…<font></font>
			<span class="hljs-comment">//positionFrom = positionTo;</span>
			<span class="hljs-comment">//positionTo = tileFrom.ExitPoint;</span>
			<span class="hljs-comment">//transform.localRotation = tileFrom.PathDirection.GetRotation();</span>
			progress -= <span class="hljs-number">1f</span>;<font></font>
			PrepareNextState();<font></font>
		}<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい状態に移行するときは、常に位置を変更し、方向の変化を見つけ、現在の方向を更新し、角度</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をに</font><font style="vertical-align: inherit;">シフトする</font><font style="vertical-align: inherit;">必要があり</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私たちはもう方向転換をしません。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareNextState</span> (<span class="hljs-params"></span>)</span> {<font></font>
		positionFrom = positionTo;<font></font>
		positionTo = tileFrom.ExitPoint;<font></font>
		directionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection);<font></font>
		direction = tileFrom.PathDirection;<font></font>
		directionAngleFrom = directionAngleTo;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のアクションは方向の変更に依存します。</font><font style="vertical-align: inherit;">オプションごとにメソッドを追加しましょう。</font><font style="vertical-align: inherit;">前進する場合、角度</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は現在のセルのパスの方向と一致します。</font><font style="vertical-align: inherit;">さらに、敵が正面を向くように回転を設定する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareForward</span> (<span class="hljs-params"></span>)</span> {<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
		directionAngleTo = direction.GetAngle();<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターンの場合、すぐにはターンしません。</font><font style="vertical-align: inherit;">別の角度に補間する必要があります。右に曲がるには90°以上、左に曲がるには90°少なく、後ろに曲がるには180°大きくなります。</font><font style="vertical-align: inherit;">角度値が359°から0°に変化したために間違った方向に回転するのを防ぐため、角度</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は現在の方向を基準にして示す必要があります。</font></font><code>Quaternion.Euler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扱える</font><font style="vertical-align: inherit;">ので角度が0°未満や360°以上になる心配はありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">90f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom - <span class="hljs-number">90f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">180f</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して方向を変更し、4つのメソッドのどれを呼び出すかを決定</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareNextState</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		<span class="hljs-keyword">switch</span> (directionChange) {
			<span class="hljs-keyword">case</span> DirectionChange.None: PrepareForward(); <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> DirectionChange.TurnRight: PrepareTurnRight(); <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> DirectionChange.TurnLeft: PrepareTurnLeft(); <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>: PrepareTurnAround(); <span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、方向が変わったかどうかを確認する必要があります。</font><font style="vertical-align: inherit;">その場合は、2つのコーナーの間を補間し、回転を設定します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		transform.localPosition =<font></font>
			Vector3.LerpUnclamped(positionFrom, positionTo, progress);<font></font>
		<span class="hljs-keyword">if</span> (directionChange != DirectionChange.None) {
			<span class="hljs-keyword">float</span> angle = Mathf.LerpUnclamped(<font></font>
				directionAngleFrom, directionAngleTo, progress<font></font>
			);<font></font>
			transform.localRotation = Quaternion.Euler(<span class="hljs-number">0f</span>, angle, <span class="hljs-number">0f</span>);<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵は回っています。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲線の動き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
曲がるときに敵をカーブに沿って動かすことで、動きを改善できます。</font><font style="vertical-align: inherit;">タイルの端から端まで歩く代わりに、円の4分の1を歩くようにします。</font><font style="vertical-align: inherit;">この円の中心は、タイルにコーナー共通に位置</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵がタイルを入力し、それに沿って同じエッジに</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/8a6/3a5/1d78a63a58d34a1d8cc9ff56a0b23cc3.png" width="256" height="256"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">右折する四分の一円の回転。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実現するには、三角法を使用して敵を弧を描いて動かすと同時に、回転させます。</font><font style="vertical-align: inherit;">ただし、これは回転のみを使用して簡略化することができ、一時的に敵の座標のローカル原点を円の中心に移動します。</font><font style="vertical-align: inherit;">これを行うには、敵モデルの位置を変更する必要があるため</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、設定フィールドからアクセスできるこのモデルへ</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">リンクを</font><font style="vertical-align: inherit;">提供</font><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField</span>]<font></font>
	Transform model = <span class="hljs-keyword">default</span>;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72b/13c/28e/72b13c28ed9d6a8d34f3e17536e964cd.png" width="320" height="56"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルを参考にした敵。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前進または後退の準備として、モデルは標準的な位置、つまり敵の座標のローカル原点に移動する必要があります。</font><font style="vertical-align: inherit;">それ以外の場合は、モデルを測定単位の半分、つまり転換点から遠い回転円の半径だけシフトする必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareForward</span> (<span class="hljs-params"></span>)</span> {<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
		directionAngleTo = direction.GetAngle();<font></font>
		model.localPosition = Vector3.zero;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">90f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0f</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom - <span class="hljs-number">90f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0f</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">180f</span>;<font></font>
		model.localPosition = Vector3.zero;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今度は敵自身が転換点に移動する必要があります。</font><font style="vertical-align: inherit;">これを行うには、ユニットの半分も移動する必要がありますが、正確なオフセットは方向によって異なります。</font></font><code>Direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thisに補助的な拡張メソッドを</font><font style="vertical-align: inherit;">追加しましょう</font></font><code>GetHalfVector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">static</span> Vector3[] halfVectors = {<font></font>
		Vector3.forward * <span class="hljs-number">0.5f</span>,<font></font>
		Vector3.right * <span class="hljs-number">0.5f</span>,<font></font>
		Vector3.back * <span class="hljs-number">0.5f</span>,<font></font>
		Vector3.left * <span class="hljs-number">0.5f</span><font></font>
	};<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">GetHalfVector</span> (<span class="hljs-params"><span class="hljs-keyword">this</span> Direction direction</span>)</span> {
		<span class="hljs-keyword">return</span> halfVectors[(<span class="hljs-keyword">int</span>)direction];<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右または左に曲がるときに対応するベクトルを追加します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">90f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0f</span>);<font></font>
		transform.localPosition = positionFrom + direction.GetHalfVector();<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom - <span class="hljs-number">90f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0f</span>);<font></font>
		transform.localPosition = positionFrom + direction.GetHalfVector();<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、引き返すとき、その位置は通常の開始点でなければなりません。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">180f</span>;<font></font>
		model.localPosition = Vector3.zero;<font></font>
		transform.localPosition = positionFrom;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、出口点を計算するとき</font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ベクトルの半分</font><font style="vertical-align: inherit;">を使用できるため</font><font style="vertical-align: inherit;">、タイルの2つの位置にアクセスする必要はありません。</font></font><br>
<br>
<pre><code class="cs hljs">		neighbor.ExitPoint =<font></font>
			neighbor.transform.localPosition + direction.GetHalfVector();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、方向を変更するときに</font></font><code>Enemy.GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、回転が動きに関与しているため、の</font><font style="vertical-align: inherit;">位置を補間する必要はありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		<span class="hljs-keyword">if</span> (directionChange == DirectionChange.None) {<font></font>
			transform.localPosition =<font></font>
				Vector3.LerpUnclamped(positionFrom, positionTo, progress);<font></font>
		}<font></font>
		<span class="hljs-comment">//if (directionChange != DirectionChange.None) {</span>
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">float</span> angle = Mathf.LerpUnclamped(<font></font>
				directionAngleFrom, directionAngleTo, progress<font></font>
			);<font></font>
			transform.localRotation = Quaternion.Euler(<span class="hljs-number">0f</span>, angle, <span class="hljs-number">0f</span>);<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}</code></pre><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵は角を曲がってスムーズに曲がります。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一定の速度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点まで、敵がタイル内をどのように移動するかに関係なく、敵の速度は常に1秒あたり1タイルに等しくなっています。</font><font style="vertical-align: inherit;">ただし、それらがカバーする距離は状態によって異なるため、1秒あたりの単位で表される速度は異なります。</font><font style="vertical-align: inherit;">この速度を一定にするためには、状態に応じて進行速度を変える必要があります。</font><font style="vertical-align: inherit;">したがって、進行状況乗数フィールドを追加し、それを使用してでデルタをスケーリングし</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">float</span> progress, progressFactor;<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime * progressFactor;<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、進行状況が状態によって変化する場合、残りの進行状況値を次の状態に直接使用することはできません。</font><font style="vertical-align: inherit;">したがって、新しい状態を準備する前に、進行状況を正規化し、新しい状態で新しい乗数を適用する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime * progressFactor;<font></font>
		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {<font></font>
			…<font></font>
			<span class="hljs-comment">//progress -= 1f;</span>
			progress = (progress - <span class="hljs-number">1f</span>) / progressFactor;<font></font>
			PrepareNextState();<font></font>
			progress *= progressFactor;<font></font>
		}<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前進するために変更は必要ないため、1の係数を使用します。右または左に曲がると、敵は半径withの円の4分の1を通過するため、カバーされる距離は¼πになります。</font></font><code>progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この値で割った値に等しい。</font><font style="vertical-align: inherit;">引き返すのに時間がかかりすぎないように、進行を2倍にして、0.5秒かかります。</font><font style="vertical-align: inherit;">最後に、紹介の動きはタイルの半分しかカバーしないため、一定の速度を維持するには、その進行状況も2倍にする必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareForward</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">1f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">1f</span> / (Mathf.PI * <span class="hljs-number">0.25f</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">1f</span> / (Mathf.PI * <span class="hljs-number">0.25f</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">2f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareIntro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">2f</span>;<font></font>
	}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距離が1/4 * piに等しいのはなぜですか？</font></font></b><div class="spoiler_text">   2π,   .         ,    ½,    ½π × ½.</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終状態</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
紹介状態になっているので、最後の状態を追加しましょう。</font><font style="vertical-align: inherit;">敵は現在、エンドポイントに到達した直後に消失していますが、エンドタイルの中央に到達するまで、消失を延期しましょう。</font><font style="vertical-align: inherit;">こののメソッドを作成して、</font></font><code>PrepareOutro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順方向の動きを設定しますが、一定の速度を維持するために、進行状況が2倍になったタイルの中心にのみ移動します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareOutro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		positionTo = tileFrom.transform.localPosition;<font></font>
		directionChange = DirectionChange.None;<font></font>
		directionAngleTo = direction.GetAngle();<font></font>
		model.localPosition = Vector3.zero;<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
		progressFactor = <span class="hljs-number">2f</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ためには</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あまりにも早く敵を破壊しないように、私たちはそれからタイルのシフトを削除します。</font><font style="vertical-align: inherit;">今からやります</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、</font><font style="vertical-align: inherit;">最終状態の終了後にのみ</font><font style="vertical-align: inherit;">、</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻りを</font><font style="vertical-align: inherit;">チェックし</font><font style="vertical-align: inherit;">ます</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GameUpdate</span> (<span class="hljs-params"></span>)</span> {<font></font>
		progress += Time.deltaTime * progressFactor;<font></font>
		<span class="hljs-keyword">while</span> (progress &gt;= <span class="hljs-number">1f</span>) {
			<span class="hljs-comment">//tileFrom = tileTo;</span>
			<span class="hljs-comment">//tileTo = tileTo.NextTileOnPath;</span>
			<span class="hljs-keyword">if</span> (tileTo == <span class="hljs-literal">null</span>) {<font></font>
				OriginFactory.Reclaim(<span class="hljs-keyword">this</span>);
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
			}<font></font>
			…<font></font>
		}<font></font>
		…<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タイルのシフトから始めます。</font><font style="vertical-align: inherit;">次に、位置を設定した後、位置を設定する</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前に</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タイルが</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">と等しいかどうかを確認し</font><font style="vertical-align: inherit;">ます</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その場合は、最終状態を準備し、メソッドの残りの部分をスキップします。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareNextState</span> (<span class="hljs-params"></span>)</span> {<font></font>
		tileFrom = tileTo;<font></font>
		tileTo = tileTo.NextTileOnPath;<font></font>
		positionFrom = positionTo;<font></font>
		<span class="hljs-keyword">if</span> (tileTo == <span class="hljs-literal">null</span>) {<font></font>
			PrepareOutro();<font></font>
			<span class="hljs-keyword">return</span>;<font></font>
		}<font></font>
		positionTo = tileFrom.ExitPoint;<font></font>
		…<font></font>
	}</code></pre><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一定の速度と最終状態の敵。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敵の変動</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵のストリームがあり、それらはすべて同じ立方体であり、同じ速度で動いています。</font><font style="vertical-align: inherit;">結果は、個々の敵よりも長い蛇のようです。</font><font style="vertical-align: inherit;">それらのサイズ、変位、および速度をランダム化することにより、それらをより異なったものにしましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロートレンジ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵のパラメータを変更し、値の範囲から敵の特性をランダムに選択します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">オブジェクトの管理、形状の構成の</font></a></font><code>FloatRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で作成した</font><font style="vertical-align: inherit;">構造</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">ここ</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">役立ちます</font><font style="vertical-align: inherit;">ので、コピーしてみましょう。</font><font style="vertical-align: inherit;">唯一の変更は、1つのパラメーターを持つコンストラクターを追加し、readonly-propertiesを使用して最小値と最大値へのアクセスを開くことでしたので、間隔は変更できませんでした。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
[<span class="hljs-meta">System.Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> FloatRange {<font></font>
<font></font>
	[<span class="hljs-meta">SerializeField</span>]
	<span class="hljs-keyword">float</span> min, max;<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Min =&gt; min;<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Max =&gt; max;<font></font>
	<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> RandomValueInRange {
		<span class="hljs-keyword">get</span> {
			<span class="hljs-keyword">return</span> Random.Range(min, max);<font></font>
		}<font></font>
	}<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FloatRange</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> <span class="hljs-keyword">value</span></span>)</span> {<font></font>
		min = max = <span class="hljs-keyword">value</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FloatRange</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max</span>)</span> {
		<span class="hljs-keyword">this</span>.min = min;
		<span class="hljs-keyword">this</span>.max = max &lt; min ? min : max;<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、間隔を制限するために属性セットをコピーします。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FloatRangeSliderAttribute</span> : <span class="hljs-title">PropertyAttribute</span> {<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Min { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Max { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FloatRangeSliderAttribute</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max</span>)</span> {<font></font>
		Min = min;<font></font>
		Max = max &lt; min ? min : max;<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なのはスライダーの視覚化だけなので、それ</font></font><code>FloatRangeSliderDrawer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エディター</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォルダーに</font><font style="vertical-align: inherit;">コピーし</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEditor;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
[<span class="hljs-meta">CustomPropertyDrawer(typeof(FloatRangeSliderAttribute))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FloatRangeSliderDrawer</span> : <span class="hljs-title">PropertyDrawer</span> {<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span> (<span class="hljs-params">
		Rect position, SerializedProperty property, GUIContent label
	</span>)</span> {
		<span class="hljs-keyword">int</span> originalIndentLevel = EditorGUI.indentLevel;<font></font>
		EditorGUI.BeginProperty(position, label, property);<font></font>
<font></font>
		position = EditorGUI.PrefixLabel(<font></font>
			position, GUIUtility.GetControlID(FocusType.Passive), label<font></font>
		);<font></font>
		EditorGUI.indentLevel = <span class="hljs-number">0</span>;<font></font>
		SerializedProperty minProperty = property.FindPropertyRelative(<span class="hljs-string">"min"</span>);<font></font>
		SerializedProperty maxProperty = property.FindPropertyRelative(<span class="hljs-string">"max"</span>);
		<span class="hljs-keyword">float</span> minValue = minProperty.floatValue;
		<span class="hljs-keyword">float</span> maxValue = maxProperty.floatValue;
		<span class="hljs-keyword">float</span> fieldWidth = position.width / <span class="hljs-number">4f</span> - <span class="hljs-number">4f</span>;
		<span class="hljs-keyword">float</span> sliderWidth = position.width / <span class="hljs-number">2f</span>;<font></font>
		position.width = fieldWidth;<font></font>
		minValue = EditorGUI.FloatField(position, minValue);<font></font>
		position.x += fieldWidth + <span class="hljs-number">4f</span>;<font></font>
		position.width = sliderWidth;<font></font>
		FloatRangeSliderAttribute limit = attribute <span class="hljs-keyword">as</span> FloatRangeSliderAttribute;<font></font>
		EditorGUI.MinMaxSlider(<font></font>
			position, <span class="hljs-keyword">ref</span> minValue, <span class="hljs-keyword">ref</span> maxValue, limit.Min, limit.Max<font></font>
		);<font></font>
		position.x += sliderWidth + <span class="hljs-number">4f</span>;<font></font>
		position.width = fieldWidth;<font></font>
		maxValue = EditorGUI.FloatField(position, maxValue);<font></font>
		<span class="hljs-keyword">if</span> (minValue &lt; limit.Min) {<font></font>
			minValue = limit.Min;<font></font>
		}<font></font>
		<span class="hljs-keyword">if</span> (maxValue &lt; minValue) {<font></font>
			maxValue = minValue;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxValue &gt; limit.Max) {<font></font>
			maxValue = limit.Max;<font></font>
		}<font></font>
		minProperty.floatValue = minValue;<font></font>
		maxProperty.floatValue = maxValue;<font></font>
<font></font>
		EditorGUI.EndProperty();<font></font>
		EditorGUI.indentLevel = originalIndentLevel;<font></font>
	}<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルスケール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まずは敵のスケールを変更します。</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションにスケール設定</font><font style="vertical-align: inherit;">を追加</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">スケールの範囲は大きすぎてはなりませんが、ミニチュアで巨大な種類の敵を作成するには十分です。</font><font style="vertical-align: inherit;">標準値が1で、0.5〜2の範囲内にあるもの。この間隔でランダムなスケールを選択</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、新しい方法で敵に渡し</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField, FloatRangeSlider(0.5f, 2f)</span>]<font></font>
	FloatRange scale = <span class="hljs-keyword">new</span> FloatRange(<span class="hljs-number">1f</span>);<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Enemy <span class="hljs-title">Get</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Enemy instance = CreateGameObjectInstance(prefab);<font></font>
		instance.OriginFactory = <span class="hljs-keyword">this</span>;<font></font>
		instance.Initialize(scale.RandomValueInRange);<font></font>
		<span class="hljs-keyword">return</span> instance;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>Enemy.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、すべての次元で同じであるモデルのスケールを設定するだけです。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> scale</span>)</span> {<font></font>
		model.localScale = <span class="hljs-keyword">new</span> Vector3(scale, scale, scale);<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/cc3/f08/1a7cc3f082406d5c8672125ceb94913c.png" width="320" height="60" alt="検査官"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/396/7cf/ffe3967cfcfb6391269a5a7691317c60.png" width="230" height="230" alt="シーン"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケールの範囲は0.5〜1.5です。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスオフセット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵の流れの均一性をさらに破壊するために、タイル内の敵の相対的な位置を変更できます。彼らは前進するので、この方向へのシフトは彼らの移動のタイミングを変えるだけであり、あまり目立ちません。したがって、タイルの中心を通る理想的なパスから離れて、それらを横にシフトします。</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターバルにパスオフセット</font><font style="vertical-align: inherit;">を追加し</font><font style="vertical-align: inherit;">、ランダムオフセットをメソッドに渡し</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。オフセットは負または正にすることができますが、neverを超えてはなりません。これにより、敵が隣接するタイルに移動するためです。さらに、敵がフォローしているタイルを超えないようにしたいので、実際には間隔はたとえば0.4未満になりますが、実際の制限は敵のサイズによって異なります。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField, FloatRangeSlider(-0.4f, 0.4f)</span>]<font></font>
	FloatRange pathOffset = <span class="hljs-keyword">new</span> FloatRange(<span class="hljs-number">0f</span>);<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Enemy <span class="hljs-title">Get</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Enemy instance = CreateGameObjectInstance(prefab);<font></font>
		instance.OriginFactory = <span class="hljs-keyword">this</span>;<font></font>
		instance.Initialize(<font></font>
			scale.RandomValueInRange, pathOffset.RandomValueInRange<font></font>
		);<font></font>
		<span class="hljs-keyword">return</span> instance;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パスの変位は移動するパスに影響を与える</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、追跡する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">float</span> pathOffset;<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> scale, <span class="hljs-keyword">float</span> pathOffset</span>)</span> {<font></font>
		model.localScale = <span class="hljs-keyword">new</span> Vector3(scale, scale, scale);
		<span class="hljs-keyword">this</span>.pathOffset = pathOffset;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正確に真っ直ぐに移動する場合（導入、最終、または通常の前方移動中）、モデルにオフセットを直接適用するだけです。</font><font style="vertical-align: inherit;">あなたが後ろを向いたときも同じことが起こります。</font><font style="vertical-align: inherit;">右または左に曲がると、モデルが既に変位しています。これは、パスの変位に関連します。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareForward</span> (<span class="hljs-params"></span>)</span> {<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
		directionAngleTo = direction.GetAngle();<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset, <span class="hljs-number">0f</span>);<font></font>
		progressFactor = <span class="hljs-number">1f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">90f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset - <span class="hljs-number">0.5f</span>, <span class="hljs-number">0f</span>);<font></font>
		transform.localPosition = positionFrom + direction.GetHalfVector();<font></font>
		progressFactor = <span class="hljs-number">1f</span> / (Mathf.PI * <span class="hljs-number">0.25f</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom - <span class="hljs-number">90f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset + <span class="hljs-number">0.5f</span>, <span class="hljs-number">0f</span>);<font></font>
		transform.localPosition = positionFrom + direction.GetHalfVector();<font></font>
		progressFactor = <span class="hljs-number">1f</span> / (Mathf.PI * <span class="hljs-number">0.25f</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + <span class="hljs-number">180f</span>;<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset, <span class="hljs-number">0f</span>);<font></font>
		transform.localPosition = positionFrom;<font></font>
		progressFactor = <span class="hljs-number">2f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareIntro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset, <span class="hljs-number">0f</span>);<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
		progressFactor = <span class="hljs-number">2f</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareOutro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset, <span class="hljs-number">0f</span>);<font></font>
		transform.localRotation = direction.GetRotation();<font></font>
		progressFactor = <span class="hljs-number">2f</span>;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回転中の経路の変位により半径が変化するため、乗数の進行状況を計算するプロセスを変更する必要があります。</font><font style="vertical-align: inherit;">右折の半径を取得するには、パスオフセットをfromから差し引き、左折の場合は追加する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">1f</span> / (Mathf.PI * <span class="hljs-number">0.5f</span> * (<span class="hljs-number">0.5f</span> - pathOffset));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">1f</span> / (Mathf.PI * <span class="hljs-number">0.5f</span> * (<span class="hljs-number">0.5f</span> + pathOffset));<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
180°回転するときの回転半径も取得します。この場合、パスのオフセットに等しい半径で円の半分をカバーするため、距離はオフセットのπ倍になります。ただし、これは変位がゼロの場合は機能せず、変位が小さいとターンが速すぎます。瞬時の回転を回避するために、最小半径を強制して速度を計算することができます（例：0.2）。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		directionAngleTo = directionAngleFrom + (pathOffset &lt; <span class="hljs-number">0f</span> ? <span class="hljs-number">180f</span> : <span class="hljs-number">-180f</span>);<font></font>
		model.localPosition = <span class="hljs-keyword">new</span> Vector3(pathOffset, <span class="hljs-number">0f</span>);<font></font>
		transform.localPosition = positionFrom;<font></font>
		progressFactor =<font></font>
			<span class="hljs-number">1f</span> / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number">0.2f</span>));<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/8b2/b16/1db8b2b164cba05ff6f8fe7ffa0eed71.png" width="320" height="40" alt="検査官"></div><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスオフセットの範囲は-0.25〜0.25です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今度は、敵が向きを変えても相対変位を変更しないことに注意してください。</font><font style="vertical-align: inherit;">したがって、各敵のパスの全長には独自のパスがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
敵が隣接するタイルに到達しないようにするには、可能な最大のスケールも考慮する必要があります。</font><font style="vertical-align: inherit;">サイズを最大値の1に制限したので、キューブの最大許容オフセットは0.25です。</font><font style="vertical-align: inherit;">最大サイズが1.5の場合、最大変位は0.125に削減されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後にランダム化するのは敵の速度です。</font><font style="vertical-align: inherit;">間隔をもう1つ追加</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、作成した敵のコピーに値を転送します。</font><font style="vertical-align: inherit;">メソッドの2番目の引数にしましょう</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">敵が遅すぎたり速すぎたりしないようにして、ゲームがささいに単純になったり不可能になったりしないようにします。</font><font style="vertical-align: inherit;">間隔を0.2〜5に制限しましょう。</font><font style="vertical-align: inherit;">速度は1秒あたりの単位で表されます。これは、前進する場合にのみ1秒あたりのタイルに対応します。</font></font><br>
<br>
<pre><code class="cs hljs">	[<span class="hljs-meta">SerializeField, FloatRangeSlider(0.2f, 5f)</span>]<font></font>
	FloatRange speed = <span class="hljs-keyword">new</span> FloatRange(<span class="hljs-number">1f</span>);<font></font>
<font></font>
	[<span class="hljs-meta">SerializeField, FloatRangeSlider(-0.4f, 0.4f)</span>]<font></font>
	FloatRange pathOffset = <span class="hljs-keyword">new</span> FloatRange(<span class="hljs-number">0f</span>);<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Enemy <span class="hljs-title">Get</span> (<span class="hljs-params"></span>)</span> {<font></font>
		Enemy instance = CreateGameObjectInstance(prefab);<font></font>
		instance.OriginFactory = <span class="hljs-keyword">this</span>;<font></font>
		instance.Initialize(<font></font>
			scale.RandomValueInRange,<font></font>
			speed.RandomValueInRange,<font></font>
			pathOffset.RandomValueInRange<font></font>
		);<font></font>
		<span class="hljs-keyword">return</span> instance;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は追跡してスピードを上げなければなりません。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
	…<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span> (<span class="hljs-params"><span class="hljs-keyword">float</span> scale, <span class="hljs-keyword">float</span> speed, <span class="hljs-keyword">float</span> pathOffset</span>)</span> {<font></font>
		model.localScale = <span class="hljs-keyword">new</span> Vector3(scale, scale, scale);
		<span class="hljs-keyword">this</span>.speed = speed;
		<span class="hljs-keyword">this</span>.pathOffset = pathOffset;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速度を明示的に設定しなかった場合は、常に値1を使用しました。ここで、速度に対する進行乗数の依存関係を作成する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareForward</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = speed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnRight</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = speed / (Mathf.PI * <span class="hljs-number">0.5f</span> * (<span class="hljs-number">0.5f</span> - pathOffset));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnLeft</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = speed / (Mathf.PI * <span class="hljs-number">0.5f</span> * (<span class="hljs-number">0.5f</span> + pathOffset));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareTurnAround</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor =<font></font>
			speed / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number">0.2f</span>));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareIntro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">2f</span> * speed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareOutro</span> (<span class="hljs-params"></span>)</span> {<font></font>
		…<font></font>
		progressFactor = <span class="hljs-number">2f</span> * speed;<font></font>
	}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b8/e55/eeb/0b8e55eeb25d36349f606f0da60d3720.png" width="320" height="60"></div><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.75–1.25の範囲の速度。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、エンドポイントに移動する美しい敵のストリームを手に入れました。</font><font style="vertical-align: inherit;">次のチュートリアルでは、それらに対処する方法を学びます。</font><font style="vertical-align: inherit;">いつリリースされるか知りたいですか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreonで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のページをフォローしてください</font><font style="vertical-align: inherit;">！</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF記事</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452746/index.html">著書「The Art of Programming in R. Immersing in Big Data」</a></li>
<li><a href="../ja452748/index.html">NGINXから最新のアプリケーションを開発するための原則。パート1</a></li>
<li><a href="../ja452750/index.html">OpenLiteSpeed内外のNextcloud：リバースプロキシの構成</a></li>
<li><a href="../ja452752/index.html">自家製ビッグデータ。パート1. AWSクラスターでのSparkストリーミングの実践</a></li>
<li><a href="../ja452754/index.html">最も人気のあるDockerイメージの19％にrootパスワードがない</a></li>
<li><a href="../ja452760/index.html">ビタミンD。飲むか飲まないか、それが問題です。（または、私が処方されていない分析にどのように合格したかについての物語）</a></li>
<li><a href="../ja452762/index.html">MVCC-7。自動洗浄</a></li>
<li><a href="../ja452764/index.html">[ピーター]セルゲイメルニコフとJUG.ruとの出会い-超光速のプロファイリング：理論と実践</a></li>
<li><a href="../ja452766/index.html">プログレッシブストリーミングテクノロジー、またはフリーズなしでネットワーク経由で4kビデオを視聴する方法</a></li>
<li><a href="../ja452768/index.html">海外進出を決意した場合の商品デザイン</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>