<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍢 👩🏾‍🤝‍👨🏻 👦🏻 PostgreSQL Antipatterns: how deep is the rabbit hole? go through the hierarchy 🐤 🔇 🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In complex ERP-systems, many entities have a hierarchical nature , when homogeneous objects line up in an ancestor-descendant relationship tree - this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: how deep is the rabbit hole? go through the hierarchy</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/501614/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In complex ERP-systems, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">many entities have a hierarchical nature</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , when homogeneous objects line up in an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ancestor-descendant relationship tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is the organizational structure of the enterprise (all these branches, departments and work groups), and the product catalog, and work areas, and geography points of sale, ... </font><font style="vertical-align: inherit;">
In fact, there is not a single </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">sphere of business automation</font></a><font style="vertical-align: inherit;"> where at least some hierarchy would not be the result. But even if you do not work “for business,” you can still easily come across hierarchical relationships. Trite, even your family tree or floor scheme of the premises in the shopping center is the same structure. </font><font style="vertical-align: inherit;">
There are many ways to store such a tree in a DBMS, but today we will focus on only one option:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/-o/tq/ad/-otqadbymksleulmgjdpxf6e2bo.png"></a><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hier(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">integer</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, pid<font></font>
    <span class="hljs-built_in">integer</span>
      <span class="hljs-keyword">REFERENCES</span> hier<font></font>
, <span class="hljs-keyword">data</span>
    <span class="hljs-keyword">json</span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> hier(pid); <span class="hljs-comment">--  ,  FK    ,    PK</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And while you peer into the depths of the hierarchy, it patiently waits for how [naive] your "naive" ways of working with such a structure will turn out.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/na/_z/nxna_zsl1hv506-owlmrxybpute.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's analyze the typical emerging tasks, their implementation in SQL and try to improve their performance.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#1. </font><font style="vertical-align: inherit;">How deep is the rabbit hole?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let’s take, for definiteness, that this structure will reflect the subordination of departments in the structure of the organization: departments, divisions, sectors, branches, working groups ... whatever you call them.</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kl/yg/ck/klygckuyurttjnrskva_a6clwfy.png"></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we generate our 'tree' of 10K elements</font></font></b>
                        <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hier
<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-number">1</span>::<span class="hljs-built_in">integer</span> <span class="hljs-keyword">id</span>
  , <span class="hljs-string">'{1}'</span>::<span class="hljs-built_in">integer</span>[] pids
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span> + <span class="hljs-number">1</span>
  , pids[<span class="hljs-number">1</span>:(random() * array_length(pids, <span class="hljs-number">1</span>))::<span class="hljs-built_in">integer</span>] || (<span class="hljs-keyword">id</span> + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> &lt; <span class="hljs-number">10000</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  pids[array_length(pids, <span class="hljs-number">1</span>)] <span class="hljs-keyword">id</span>
, pids[array_length(pids, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>] pid
<span class="hljs-keyword">FROM</span>
  T;</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with the simplest task - to find all employees who work within a specific sector, or in terms of a hierarchy - to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find all descendants of a node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It would also be nice to get the “depth” of the descendant ... All this may be necessary, for example, to build some kind of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complex selection from the list of IDs of these employees</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything would be fine if these descendants there are only a couple of levels and quantitatively within a dozen, but if there are more than 5 levels, and there are already dozens of descendants, there may be problems. </font><font style="vertical-align: inherit;">Let's see how the traditional “down the tree” search options are written (and work). </font><font style="vertical-align: inherit;">But first, we determine which of the nodes will be the most interesting for our research. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"deepest"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> subtrees:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span><font></font>
  , pid<font></font>
  , <span class="hljs-built_in">ARRAY</span>[<span class="hljs-keyword">id</span>] <span class="hljs-keyword">path</span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    pid <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    hier.id<font></font>
  , hier.pid<font></font>
  , T.path || hier.id<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    hier<font></font>
      <span class="hljs-keyword">ON</span> hier.pid = T.id<font></font>
)<font></font>
<span class="hljs-keyword">TABLE</span> T <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> array_length(<span class="hljs-keyword">path</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs"> id  | pid  | path<font></font>
---------------------------------------------<font></font>
7624 | 7623 | {7615,7620,7621,7622,7623,7624}<font></font>
4995 | 4994 | {4983,4985,4988,4993,4994,4995}<font></font>
4991 | 4990 | {4983,4985,4988,4989,4990,4991}<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"widest"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> subtrees:</font></font><br>
<br>
<pre><code class="sql hljs">...
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">path</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">id</span>
, <span class="hljs-keyword">count</span>(*)
<span class="hljs-keyword">FROM</span><font></font>
  T<font></font>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">2</span> <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs">id   | count<font></font>
------------<font></font>
5300 |   30<font></font>
 450 |   28<font></font>
1239 |   27<font></font>
1573 |   25<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For these queries, we used a typical </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursive JOIN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<img src="https://habrastorage.org/webt/lx/cx/3n/lxcx3n6k4cttix3mbrcoj8hyap8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, with such a query model, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">number of iterations will coincide with the total number of descendants</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (and there are several dozen of them), and this can take quite substantial resources, and, as a result, time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's check on the "widest" subtree:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    hier.id<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    hier<font></font>
      <span class="hljs-keyword">ON</span> hier.pid = T.id<font></font>
)<font></font>
<span class="hljs-keyword">TABLE</span> T;</code></pre><br>
<img src="https://habrastorage.org/webt/gx/xg/q6/gxxgq6p6c0eynpmffoohetg2iye.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[look at explain.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
As expected, we found all 30 entries. </font><font style="vertical-align: inherit;">But they spent 60% of the whole time on this - because they did 30 searches on the index. </font><font style="vertical-align: inherit;">And less - is it possible?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mass proofreading by index</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And for each node, do we need to make a separate index request? It turns out that no - we can read from the index </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on several keys at once</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with </font><b><font style="vertical-align: inherit;">one call</font></b></font><code>= ANY(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in each such group of identifiers we can take all the IDs found in the previous step by "nodes". That is, at each next step we will </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediately search for all the descendants of a certain level at once</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But, it’s bad luck, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a recursive selection, you cannot refer to yourself in a sub-query</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but we just need to somehow select exactly what was found at the previous level ... It turns out that you cannot make a sub-query to the entire sample, but to its specific field - can. And this field can also be an array - which is what we need to use</font></font><code>ANY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It sounds a little wild, but on the diagram - everything is simple.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/_t/qz/fm_tqzx1c9ri4-mbrgtxqvjizri.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-built_in">ARRAY</span>[<span class="hljs-keyword">id</span>] <span class="hljs-keyword">id</span>$
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-keyword">id</span>
      <span class="hljs-keyword">FROM</span><font></font>
        hier<font></font>
      <span class="hljs-keyword">WHERE</span>
        pid = <span class="hljs-keyword">ANY</span>(T.id$)<font></font>
    ) <span class="hljs-keyword">id</span>$
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">coalesce</span>(<span class="hljs-keyword">id</span>$, <span class="hljs-string">'{}'</span>) &lt;&gt; <span class="hljs-string">'{}'</span> <span class="hljs-comment">--     -  </span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(<span class="hljs-keyword">id</span>$) <span class="hljs-keyword">id</span>
<span class="hljs-keyword">FROM</span>
  T;</code></pre><br>
<img src="https://habrastorage.org/webt/i0/a-/sk/i0a-sk-ytooivrkxwyxsq-ipnoi.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[look at explain.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
And here the most important thing is not even </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">winning 1.5 times in time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but that we subtracted fewer buffers, since we have only 5 calls to the index instead of 30! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An additional bonus is the fact that after the final unnest identifiers will remain ordered by “levels”.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node tag</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next consideration that will help improve productivity is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that “leaves” cannot have children</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , that is, they don’t need to look down for anything. In the formulation of our task, this means that if we went along the chain of departments and reached the employee, then there is no need to search further on this branch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's introduce an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">additional </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> into our table </font><font style="vertical-align: inherit;">, which will tell us right away whether this particular entry in our tree is a “node” </font><b><font style="vertical-align: inherit;">—that is</font></b><font style="vertical-align: inherit;"> , if it can have any children at all.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> hier
  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> branch <span class="hljs-built_in">boolean</span>;<font></font>
<font></font>
<span class="hljs-keyword">UPDATE</span><font></font>
  hier T<font></font>
<span class="hljs-keyword">SET</span>
  branch = <span class="hljs-literal">TRUE</span>
<span class="hljs-keyword">WHERE</span>
  <span class="hljs-keyword">EXISTS</span>(
    <span class="hljs-keyword">SELECT</span>
      <span class="hljs-literal">NULL</span>
    <span class="hljs-keyword">FROM</span><font></font>
      hier<font></font>
    <span class="hljs-keyword">WHERE</span><font></font>
      pid = T.id<font></font>
    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><font></font>
);<font></font>
<span class="hljs-comment">--   : 3033    42 .</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fine! </font><font style="vertical-align: inherit;">It turns out that only a little more than 30% of all tree elements have descendants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now </font></font><code>LATERAL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we’ll </font><font style="vertical-align: inherit;">apply a slightly different mechanics - connecting to the recursive part through </font><font style="vertical-align: inherit;">, which will allow us to immediately access the fields of the recursive “table”, and use the aggregate function with the filtering condition based on the node to reduce the set of keys:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f1/3x/vb/f13xvb2zblngijramviz8kpidks.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    array_agg(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">id</span>$<font></font>
  , array_agg(<span class="hljs-keyword">id</span>) FILTER(<span class="hljs-keyword">WHERE</span> branch) ns$
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    X.*<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> (
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">id</span>$<font></font>
    , array_agg(<span class="hljs-keyword">id</span>) FILTER(<span class="hljs-keyword">WHERE</span> branch) ns$
    <span class="hljs-keyword">FROM</span><font></font>
      hier<font></font>
    <span class="hljs-keyword">WHERE</span>
      pid = <span class="hljs-keyword">ANY</span>(T.ns$)<font></font>
  ) X<font></font>
    <span class="hljs-keyword">ON</span> <span class="hljs-keyword">coalesce</span>(T.ns$, <span class="hljs-string">'{}'</span>) &lt;&gt; <span class="hljs-string">'{}'</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(<span class="hljs-keyword">id</span>$) <span class="hljs-keyword">id</span>
<span class="hljs-keyword">FROM</span>
  T;</code></pre><br>
<img src="https://habrastorage.org/webt/jc/6r/fa/jc6rfaqvbbvy6avqifoi1bf5chk.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[look at explain.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
We were able to reduce another appeal to the index and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">won more than 2 times in terms of the amount</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deducted.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 2 </font><font style="vertical-align: inherit;">Back to the roots</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This algorithm will be useful if you need to collect records for all elements “up the tree”, while maintaining information about which source sheet (and with which indicators) caused it to fall into the sample — for example, to generate a summary report with aggregation to nodes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ah/xs/xb/ahxsxbntkmfs884ggqqqvoeyqbc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The further should be taken exclusively as proof-of-concept, since the request is very cumbersome. </font><font style="vertical-align: inherit;">But if it dominates your database - it is worth considering the use of such techniques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a couple of simple statements:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">better to read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the same record from the database </font><b><font style="vertical-align: inherit;">only once</font></b><font style="vertical-align: inherit;"> .</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entries from the database are </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more efficiently read in a "bundle"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> than individually.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's try to design the query we need.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Step 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, at the initialization of the recursion (where without it!) We will have to subtract the entries of the leaves themselves from the set of source identifiers:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    rec <span class="hljs-comment">--    </span>
  , <span class="hljs-keyword">id</span>::<span class="hljs-built_in">text</span> chld <span class="hljs-comment">--  ""    </span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier rec<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-string">'{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192}'</span>::<span class="hljs-built_in">integer</span>[])
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If it seemed strange to someone that the “set” is stored in a string, not an array, then there is a simple explanation. </font><font style="vertical-align: inherit;">For strings, there is a built-in aggregating “gluing” function </font></font><code>string_agg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but for arrays, no. </font><font style="vertical-align: inherit;">Although it is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not difficult to implement it yourself</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Step 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we would get a set of section IDs that will need to be subtracted further. </font><font style="vertical-align: inherit;">Almost always, they will be duplicated in different records of the source set - so we would </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group them</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , while maintaining information about the source leaves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But here three troubles await us:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The "sub-recursive" part of a query cannot contain aggregate functions c </font></font><code>GROUP BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A call to a recursive “table” cannot be in a nested subquery.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A query in the recursive part cannot contain a CTE.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, all of these problems are quite easily bypassed. </font><font style="vertical-align: inherit;">Let's start from the end.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTE in the recursive part</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> how </font><b><font style="vertical-align: inherit;">it</font></b><font style="vertical-align: inherit;"> works:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (<font></font>
  ...<font></font>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">WITH</span> T (...)
  <span class="hljs-keyword">SELECT</span> ...<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so it works, brackets decide!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (<font></font>
  ...<font></font>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><font></font>
  (<font></font>
    <span class="hljs-keyword">WITH</span> T (...)
    <span class="hljs-keyword">SELECT</span> ...<font></font>
  )<font></font>
)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nested query for recursive "table"</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm ... A call to a recursive CTE cannot be in a subquery. </font><font style="vertical-align: inherit;">But it can be inside the CTE! </font><font style="vertical-align: inherit;">A sub-request can already refer to this CTE!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GROUP BY inside recursion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It’s unpleasant, but ... We also have a simple way to simulate GROUP BY using </font></font><code>DISTINCT ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">window functions!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span>
  (rec).pid <span class="hljs-keyword">id</span>
, string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) chld
<span class="hljs-keyword">FROM</span><font></font>
  tree<font></font>
<span class="hljs-keyword">WHERE</span>
  (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span> <span class="hljs-comment">--  !</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so it works!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>((rec).pid)<font></font>
  (rec).pid <span class="hljs-keyword">id</span>
, string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (rec).pid) chld
<span class="hljs-keyword">FROM</span><font></font>
  tree<font></font>
<span class="hljs-keyword">WHERE</span>
  (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we see why the numeric ID turned into text - so that they can be glued together with a comma!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Step 3</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the finale, we have nothing left:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we read records of "sections" on a set of grouped IDs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">match the subtracted sections with the “sets” of source sheets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Expand” the set string using </font></font><code>unnest(string_to_array(chld, ',')::integer[])</code></li>
</ul><br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    rec<font></font>
  , <span class="hljs-keyword">id</span>::<span class="hljs-built_in">text</span> chld
  <span class="hljs-keyword">FROM</span><font></font>
    hier rec<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-string">'{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192}'</span>::<span class="hljs-built_in">integer</span>[])
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><font></font>
  (<font></font>
    <span class="hljs-keyword">WITH</span> prnt <span class="hljs-keyword">AS</span> (
      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>((rec).pid)<font></font>
        (rec).pid <span class="hljs-keyword">id</span>
      , string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (rec).pid) chld
      <span class="hljs-keyword">FROM</span><font></font>
        tree<font></font>
      <span class="hljs-keyword">WHERE</span>
        (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><font></font>
    )<font></font>
    , nodes <span class="hljs-keyword">AS</span> (
      <span class="hljs-keyword">SELECT</span><font></font>
        rec<font></font>
      <span class="hljs-keyword">FROM</span><font></font>
        hier rec<font></font>
      <span class="hljs-keyword">WHERE</span>
        <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-built_in">ARRAY</span>(
          <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">id</span>
          <span class="hljs-keyword">FROM</span><font></font>
            prnt<font></font>
        ))<font></font>
    )<font></font>
    <span class="hljs-keyword">SELECT</span><font></font>
      nodes.rec<font></font>
    , prnt.chld<font></font>
    <span class="hljs-keyword">FROM</span><font></font>
      prnt<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      nodes<font></font>
        <span class="hljs-keyword">ON</span> (nodes.rec).id = prnt.id<font></font>
  )<font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(string_to_array(chld, <span class="hljs-string">','</span>)::<span class="hljs-built_in">integer</span>[]) leaf<font></font>
, (rec).*<font></font>
<span class="hljs-keyword">FROM</span>
  tree;</code></pre><br>
<img src="https://habrastorage.org/webt/hl/e5/jn/hle5jn8eolot086fr-ecmutxlye.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">[  explain.tensor.ru]</a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501598/index.html">A modest guide to database schemas</a></li>
<li><a href="../en501600/index.html">Game console stm32</a></li>
<li><a href="../en501604/index.html">Translation of Andrew Un's book, Passion for Machine Learning. Chapters 51 and 52</a></li>
<li><a href="../en501610/index.html">Custom scrollbar in Angular</a></li>
<li><a href="../en501612/index.html">Which graphics card to choose for your computer in 2020</a></li>
<li><a href="../en501616/index.html">Client portrait: compose and count</a></li>
<li><a href="../en501622/index.html">Case: how to create a content plan for a B2B blog based on information semantics</a></li>
<li><a href="../en501624/index.html">Actual models of linguistic localization in the field of IT and digital communications. Part 2</a></li>
<li><a href="../en501628/index.html">Interview with Alexander Filippov, Lead Game Designer World of Tanks Blitz</a></li>
<li><a href="../en501630/index.html">Five security risks when working remotely</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>