<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔔 👩🏾‍⚖️ 🌍 C # 8 dan validitas nol. Bagaimana kita hidup dengan ini 👩🏽‍🌾 🙍🏿 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo rekan! Sudah waktunya untuk menyebutkan bahwa kami memiliki rencana untuk merilis buku fundamental Ian Griffiths di C # 8:
 
 
 Sementara itu, di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # 8 dan validitas nol. Bagaimana kita hidup dengan ini</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo rekan! </font><font style="vertical-align: inherit;">Sudah waktunya untuk menyebutkan bahwa kami memiliki rencana untuk merilis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buku</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fundamental </font><font style="vertical-align: inherit;">Ian Griffiths di C # 8:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/to/l-/iwtol-20o3gyqy1ppgnewp68giw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sementara itu, di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">nya,</font></a><font style="vertical-align: inherit;"> penulis telah menerbitkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terkait </font><font style="vertical-align: inherit;">di mana ia mempertimbangkan seluk-beluk fenomena baru seperti nullability, null-obliviousness, dan null-awareness. </font><font style="vertical-align: inherit;">Kami telah menerjemahkan kedua artikel dalam satu tajuk dan menyarankan untuk membahasnya.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur baru yang paling ambisius di C # 8.0 disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referensi nullable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan dari fitur baru ini adalah untuk memperlancar kerusakan dari hal yang berbahaya, yang pernah disebut oleh ilmuwan komputer Tony Hoar sebagai " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kesalahan miliaran dolar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font><font style="vertical-align: inherit;">C # memiliki kata kunci</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(padanan yang ditemukan dalam banyak bahasa lain), dan akar kata kunci ini dapat ditelusuri kembali ke bahasa Algol W, dalam perkembangan yang diikuti Hoar. Dalam bahasa kuno ini (muncul pada tahun 1966), variabel yang merujuk pada instance dari jenis tertentu dapat menerima makna khusus, menunjukkan bahwa saat ini variabel ini tidak dirujuk di mana pun. Peluang ini sangat banyak dipinjam, dan saat ini banyak ahli (termasuk Hoar sendiri) percaya bahwa ini telah menjadi sumber kesalahan perangkat lunak yang paling mahal sepanjang masa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang salah dengan mengasumsikan nol? Di dunia di mana tautan apa pun bisa mengarah ke nol, Anda harus mempertimbangkan ini di mana pun tautan apa pun digunakan dalam kode Anda, jika tidak, Anda berisiko ditolak saat runtime. Terkadang tidak terlalu membebani; jika Anda menginisialisasi variabel dengan ekspresi </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di tempat yang sama di mana Anda mendeklarasikannya, maka Anda tahu bahwa variabel ini tidak sama dengan nol. Tetapi bahkan contoh sederhana seperti itu penuh dengan beban kognitif: sebelum rilis C # 8, kompiler tidak dapat memberi tahu Anda jika Anda melakukan sesuatu yang dapat mengubah nilai ini menjadi </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tetapi, segera setelah Anda mulai menjahit fragmen kode yang berbeda, menjadi jauh lebih sulit untuk menilai dengan pasti tentang hal-hal seperti itu: seberapa besar kemungkinan properti ini yang saya baca sekarang dapat kembali </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Apakah diizinkan mengirim</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke dalam metode itu? Dalam situasi apa saya dapat yakin bahwa metode yang saya panggil akan mengatur argumen ini </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan untuk </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi ke nilai yang berbeda? Selain itu, masalahnya bahkan tidak terbatas pada mengingat untuk memeriksa hal-hal seperti itu; tidak sepenuhnya jelas apa yang harus Anda lakukan jika Anda mencapai nol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan tipe numerik dalam C # tidak ada masalah seperti itu: jika Anda menulis fungsi yang mengambil beberapa angka sebagai input dan sebagai hasilnya, Anda tidak perlu bertanya-tanya apakah nilai yang ditransmisikan benar-benar angka, dan jika ada di antara mereka yang bisa digabungkan. Saat memanggil fungsi seperti itu, tidak perlu dipikirkan apakah ia dapat mengembalikan sesuatu sebagai ganti nomor. Kecuali jika perkembangan acara semacam itu menarik minat Anda sebagai opsi: dalam hal ini, Anda dapat mendeklarasikan parameter atau hasil dari tipe tersebut</font></font><code>int?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menunjukkan bahwa dalam kasus khusus ini Anda benar-benar ingin mengizinkan transmisi atau pengembalian nilai nol. Jadi, untuk tipe numerik dan, dalam arti yang lebih umum, tipe signifikan, toleransi nol selalu menjadi salah satu hal yang dilakukan secara sukarela, sebagai pilihan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapun jenis referensi, sebelum C # 8.0, izin nol tidak hanya ditetapkan secara default, tetapi juga tidak dapat dinonaktifkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, untuk alasan kompatibilitas ke belakang, validitas nol terus beroperasi secara default bahkan di C # 8.0, karena fungsi bahasa baru di area ini tetap dinonaktifkan hingga Anda secara eksplisit memintanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, segera setelah Anda mengaktifkan fitur baru ini - semuanya berubah. Cara termudah untuk mengaktifkannya adalah menambahkannya </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di dalam elemen.</font></font><code>&lt;PropertyGroup&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam file Anda </font></font><code>.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. (Saya perhatikan bahwa lebih banyak kontrol kerawang juga tersedia. Jika Anda benar-benar membutuhkannya, Anda dapat mengonfigurasi perilaku yang diizinkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara terpisah di setiap baris. Namun, ketika kami baru-baru ini memutuskan untuk memasukkan fitur ini di semua proyek kami, ternyata itu akan diaktifkan pada skala satu proyek pada satu waktu adalah tugas yang bisa dilakukan.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika tautan yang diizinkan dalam C # 8.0 </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diaktifkan sepenuhnya, situasinya berubah: sekarang, secara default, diasumsikan bahwa tautan tidak mengizinkan nol hanya jika Anda sendiri tidak menentukan yang sebaliknya, persis seperti jenis yang signifikan ( bahkan sintaksnya sama: Anda dapat menulis int ?, jika Anda benar-benar ingin nilai integer menjadi opsional. Sekarang Anda menulis string ?, jika Anda bermaksud bahwa Anda menginginkan referensi string atau</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah perubahan yang sangat signifikan, dan, pertama-tama, karena signifikansinya, fitur baru ini dinonaktifkan secara default. Microsoft dapat merancang fitur bahasa ini secara berbeda: Anda dapat membiarkan tautan default tidak dapat dihapus dan memperkenalkan sintaksis baru yang memungkinkan Anda menentukan bahwa Anda ingin memastikan bahwa itu tidak diizinkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mungkin ini akan menurunkan bilah ketika menjelajahi kemungkinan ini, tetapi dalam jangka panjang solusi seperti itu akan salah, karena dalam praktiknya sebagian besar tautan dalam massa besar kode C # tidak dirancang untuk menunjukkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengasumsikan nol adalah pengecualian, bukan aturan, dan itulah sebabnya, ketika fitur bahasa baru ini diaktifkan, mencegah nol menjadi standar baru. Ini tercermin bahkan dalam nama fitur asli: "referensi nullable." Namanya penasaran, mengingat bahwa tautan dapat mengarah </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kembali ke C # 1.0. Tetapi para pengembang memilih untuk menekankan bahwa sekarang asumsi nol masuk ke dalam kategori hal-hal yang perlu diminta secara eksplisit. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C # 8.0 memperlancar proses memperkenalkan tautan permisif </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena memungkinkan Anda untuk memperkenalkan fitur ini secara bertahap. Seseorang tidak harus membuat pilihan ya atau tidak. Ini sangat berbeda dari fitur yang </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditambahkan dalam C # 5.0, yang cenderung menyebar: pada kenyataannya, operasi asinkron mengharuskan pemanggil untuk</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan oleh karena itu, kode yang memanggil penelepon ini harus </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan seterusnya, ke paling atas tumpukan. Untungnya, jenis yang memungkinkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibangun secara berbeda: mereka dapat diimplementasikan secara selektif dan bertahap. Anda dapat mengerjakan file satu per satu, atau bahkan baris demi baris, jika perlu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aspek yang paling penting dari jenis memungkinkan</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Terima kasih yang transisi ke mereka disederhanakan), adalah bahwa secara default mereka dinonaktifkan. Kalau tidak, sebagian besar pengembang akan menolak untuk menggunakan C # 8.0, karena transisi seperti itu akan menyebabkan peringatan di hampir semua basis kode. Namun, untuk alasan yang sama, ambang entri untuk menggunakan fitur baru ini terasa agak tinggi: jika fitur baru membuat perubahan dramatis sehingga dinonaktifkan secara default, maka Anda mungkin tidak ingin mengacaukannya, tetapi ada masalah yang terkait dengan beralih ke fitur ini. akan selalu tampak tidak perlu repot. Tapi ini akan memalukan, karena fitur ini sangat berharga. Ini membantu untuk menemukan bug dalam kode sebelum pengguna melakukannya untuk Anda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, jika Anda mempertimbangkan untuk memperkenalkan jenis yang memungkinkan</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pastikan untuk mencatat bahwa Anda dapat memperkenalkan fitur ini langkah demi langkah. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya peringatan</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Level kontrol paling kasar atas seluruh proyek setelah nyala / mati yang sederhana adalah kemampuan untuk mengaktifkan peringatan tanpa memperhatikan anotasi. Misalnya, jika saya sepenuhnya mengaktifkan asumsi nol untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling.Json</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di repositori </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">, menambah </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grup properti dalam file proyek, maka dalam keadaan saat ini 20 peringatan dari kompiler akan segera muncul. Namun, jika saya menggunakannya, saya </font></font><code>&lt;Nullablegt;warnings&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya akan mendapatkan satu peringatan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi tunggu! Mengapa lebih sedikit peringatan ditampilkan kepada saya? Pada akhirnya, di sini saya hanya meminta peringatan. Jawaban untuk pertanyaan ini tidak sepenuhnya jelas: faktanya adalah bahwa beberapa variabel dan ekspresi dapat menjadi </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol-lupa. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null Neutrality</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C # mendukung dua interpretasi validitas nol. Pertama, variabel apa pun dari tipe referensi dapat dinyatakan sebagai diterima atau tidak </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kedua, kompiler akan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kapan pun </font><font style="vertical-align: inherit;">memungkinkan secara logis menyimpulkan apakah variabel ini dapat berada </font><font style="vertical-align: inherit;">pada titik tertentu dalam kode. Artikel ini hanya membahas jenis pertama yang dapat diterima</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Yaitu, tentang jenis statis variabel (pada kenyataannya, ini tidak hanya berlaku untuk variabel dan parameter dan bidang yang dekat dengan mereka dalam roh, baik statis dan diterimanya secara logis deducible yang </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditentukan untuk setiap ekspresi di C #.) Bahkan, diterimanya </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam arti pertama , yang sedang kami pertimbangkan adalah perpanjangan dari sistem tipe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, ternyata jika kita hanya fokus pada penerimaan nol untuk suatu jenis, situasinya tidak akan koheren seperti yang diduga. Ini bukan hanya kontras antara "validitas nol" dan "tidak valid</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". Bahkan, ada dua kemungkinan lagi. Ada kategori "tidak dikenal", yang wajib karena ketersediaan obat generik; jika Anda memiliki parameter tipe tidak terbatas, maka tidak akan mungkin menemukan apa pun tentang validitasnya </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: kode yang menggunakan metode atau tipe umum yang sesuai dapat menggantikan argumen di dalamnya, baik mengizinkan atau tidak mengizinkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anda dapat menambahkan pembatasan, tetapi sering kali pembatasan seperti itu tidak diinginkan, karena mereka mempersempit ruang lingkup jenis atau metode umum. Jadi, untuk variabel atau ekspresi dari beberapa parameter tipe tidak terbatas, </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">validitas (non) nol harus tidak diketahui; mungkin, dalam setiap kasus, pertanyaan penerimaan</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu akan diputuskan secara terpisah untuk mereka, tetapi kami tidak tahu opsi mana yang akan muncul dalam kode umum, karena itu akan bergantung pada argumen tipe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kategori terakhir disebut "netral". Dengan prinsip "netralitas" semuanya berfungsi sebelum C # 8.0, dan itu akan berfungsi jika Anda tidak mengaktifkan kemampuan untuk bekerja dengan tautan yang dapat dibatalkan. (Pada dasarnya, ini adalah contoh dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retroaktif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Meskipun gagasan netralitas nol pertama kali diperkenalkan dalam C # 8.0 sebagai keadaan alami kode sebelum mengaktifkan validitas nol untuk referensi, desainer C # bersikeras bahwa properti ini tidak pernah benar-benar asing bagi C #.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin Anda tidak perlu menjelaskan apa arti "netralitas" dalam kasus ini, karena dalam nada inilah C # selalu bekerja, jadi Anda sendiri memahami segalanya ... meskipun, mungkin, ini sedikit tidak jujur. Jadi dengarkan: di dunia di mana diketahui tentang penerimaan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karakteristik paling penting dari </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekspresi-netral adalah bahwa mereka tidak menyebabkan peringatan tentang penerimaan nol. Anda dapat menetapkan ekspresi nol-netral sebagai </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel yang </font><font style="vertical-align: inherit;">diizinkan </font><font style="vertical-align: inherit;">, tetapi tidak diizinkan. </font></font><code>Null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-variabel netral (serta properti, bidang, dll.), Anda dapat menetapkan ekspresi yang oleh kompiler dianggap "mungkin </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" atau "tidak </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu sebabnya, jika Anda hanya mengaktifkan peringatan, maka tidak akan ada banyak peringatan baru. Semua kode tetap dalam konteks anotasi dinonaktifkan yang dinonaktifkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga semua variabel, parameter, bidang, dan properti akan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">netral, dan ini berarti bahwa Anda tidak akan menerima peringatan apa pun jika Anda mencoba menggunakannya bersama dengan entitas yang mempertimbangkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mengapa saya mendapat peringatan sama sekali? Alasan umum adalah karena upaya untuk menjalin pertemanan dengan cara yang tidak dapat diterima dua potong kode yang memperhitungkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sebagai contoh, misalkan saya memiliki perpustakaan di mana tautan permisif sepenuhnya disertakan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan perpustakaan ini memiliki kelas yang dibuat sangat mendalam sebagai berikut:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NullableAwareClass</span><font></font>
	{<font></font>
	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span>? GetNullable() =&gt; DateTime.Now.Hour &gt; <span class="hljs-number">12</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">"morning"</span>;<font></font>
	<font></font>
<font></font>
	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">RequireNonNull</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> s</span>)</span> =&gt; s.Length;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, dalam proyek lain, saya dapat menulis kode ini dalam konteks di mana peringatan validitas nol diaktifkan, tetapi anotasi yang sesuai dinonaktifkan: </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">UseString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> x</span>)</span> =&gt; NullableAwareClass.RequireNonNull(x);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena anotasi tentang validitas nol dinonaktifkan, parameter di </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">netral. </font><font style="vertical-align: inherit;">Ini berarti bahwa kompilator tidak dapat menentukan apakah kode ini benar atau tidak. </font><font style="vertical-align: inherit;">Jika penyusun mengeluarkan peringatan dalam kasus di mana </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekspresi netral dicampur dengan yang memperhitungkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sebagian besar dari peringatan ini dapat dianggap meragukan - oleh karena itu, peringatan tidak dikeluarkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan pembungkus ini, saya sebenarnya menyembunyikan fakta bahwa kode memperhitungkan validitas akun </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini berarti bahwa sekarang saya dapat menulis seperti ini:</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">int</span> x = UseString(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompiler tahu apa yang </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bisa dikembalikan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi karena saya memanggil metode dengan parameter nol-netral, program tidak tahu apakah ini benar atau salah. Menggunakan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pembungkus -neutral, saya melucuti kompiler, yang sekarang tidak melihat masalah di sini. Namun, jika saya menggabungkan kedua metode ini secara langsung, semuanya akan berbeda:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> y = NullableAwareClass.RequireNonNull(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini saya menyampaikan hasilnya </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kepada </font></font><code>RequireNonNull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika saya mencoba melakukan ini dalam konteks di mana peringatan nol diaktifkan, kompiler akan menghasilkan peringatan, terlepas dari apakah saya menghidupkan atau mematikan konteks anotasi yang sesuai. Dalam kasus khusus ini, konteks anotasi tidak masalah, karena tidak ada deklarasi dengan tipe referensi. Jika Anda mengaktifkan peringatan tentang asumsi nol, tetapi menonaktifkan anotasi yang sesuai, maka semua deklarasi akan menjadi </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">netral, yang, bagaimanapun, tidak berarti bahwa semua ekspresi menjadi seperti itu. Jadi, kita tahu bahwa hasilnya </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol. Karena itu, kami mendapat peringatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meringkas: karena semua deklarasi dalam konteks anotasi dinonaktifkan yang memungkinkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral, kami tidak akan mendapatkan banyak peringatan, karena sebagian besar ekspresi adalah </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral. Tetapi kompiler masih akan dapat menangkap kesalahan yang terkait dengan asumsi </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kasus-kasus tersebut ketika ekspresi tidak melewati beberapa perantara null-netral. Selain itu, manfaat terbesar dalam hal ini adalah dari mendeteksi kesalahan yang terkait dengan upaya untuk melakukan dereferensi nilai null potensial menggunakan </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, misalnya:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> z = NullableAwareClass.GetNullable().Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kode Anda dirancang dengan baik, maka seharusnya tidak ada banyak kesalahan seperti ini. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anotasi bertahap dari seluruh proyek</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah Anda mengambil langkah pertama - cukup aktifkan peringatan, maka Anda dapat melanjutkan ke aktivasi bertahap anotasi, file per file. Sangat mudah untuk memasukkan mereka segera di seluruh proyek, lihat di mana file peringatan muncul - dan kemudian pilih file di mana ada relatif sedikit peringatan. Sekali lagi, nonaktifkan mereka di tingkat seluruh proyek, dan tulis di bagian atas file yang Anda pilih </font></font><code>#nullable enable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini akan sepenuhnya mengaktifkan asumsi </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(baik untuk peringatan dan untuk anotasi) di seluruh file (kecuali jika Anda mematikannya lagi menggunakan arahan lain</font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Lalu, Anda dapat menelusuri seluruh file dan memastikan bahwa semua entitas yang kemungkinan nol diberi anotasi sebagai membolehkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(mis., Tambahkan </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), lalu berurusan dengan peringatan di file ini, jika ada yang tersisa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin ternyata menambahkan semua penjelasan yang diperlukan adalah yang diperlukan untuk menghilangkan semua peringatan. Kebalikannya juga dimungkinkan: Anda mungkin memperhatikan bahwa ketika Anda dengan rapi mencatat satu file tentang validitas</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, peringatan lain muncul di file lain yang menggunakannya. Biasanya, tidak ada banyak peringatan seperti itu, dan Anda punya waktu untuk memperbaikinya dengan cepat. Tetapi, jika karena alasan tertentu setelah langkah ini Anda hanya tenggelam dalam peringatan, maka Anda masih memiliki beberapa solusi. Pertama, Anda dapat membatalkan pilihan, meninggalkan file ini dan mengambil yang lain. Kedua, Anda dapat mematikan anotasi secara selektif untuk anggota yang menurut Anda paling banyak menimbulkan masalah. ( </font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggunakan </font><font style="vertical-align: inherit;">arahan </font><font style="vertical-align: inherit;">sebanyak yang Anda inginkan, sehingga Anda dapat mengontrol pengaturan validitas nol bahkan baris demi baris, jika Anda mau.) Mungkin jika Anda kembali ke file ini nanti ketika Anda sudah mengaktifkan validitas nol di sebagian besar proyek, Anda akan melihat lebih sedikit peringatan dari yang pertama kali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada saat-saat ketika masalah tidak dapat diselesaikan dengan cara yang begitu mudah. </font><font style="vertical-align: inherit;">Jadi, dalam skenario tertentu yang terkait dengan serialisasi (misalnya, ketika menggunakan Json.NET atau Entity Framework), pekerjaan mungkin lebih sulit. </font><font style="vertical-align: inherit;">Saya pikir masalah ini layak mendapat artikel terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tautan dengan asumsi </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meningkatkan ekspresifitas kode Anda dan meningkatkan kemungkinan kompiler akan menangkap kesalahan Anda sebelum pengguna menabraknya. </font><font style="vertical-align: inherit;">Karena itu, lebih baik untuk memasukkan fitur ini jika memungkinkan. </font><font style="vertical-align: inherit;">Dan, jika Anda memasukkannya secara selektif, maka manfaatnya akan mulai terasa lebih cepat.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id501502/index.html">Sintesis Digital Lab Baru Berlanjut Harris Book dan Membantu Membuat Video Game FPGA</a></li>
<li><a href="../id501506/index.html">Tentang kebocoran GDI dan pentingnya keberuntungan</a></li>
<li><a href="../id501508/index.html">Sialan CRM lama</a></li>
<li><a href="../id501510/index.html">Tampilan baru pada pengembangan Fullstack dengan kerangka kerja Ruby on Rails</a></li>
<li><a href="../id501516/index.html">Mari matikan ruang hampa ?! Alexey Lesovsky</a></li>
<li><a href="../id501522/index.html">Webinar Skillbox Gratis: Game Menulis dalam PHP, Unity, dan Unreal Engine</a></li>
<li><a href="../id501524/index.html">Rahasia sinkronisasi medan elektromagnetik Bumi dan organisme hidup</a></li>
<li><a href="../id501526/index.html">Mengapa Bahasa Inggris Kanada dianggap "kotor" dan apa hubungannya Keanu Reeves dengan itu?</a></li>
<li><a href="../id501528/index.html">Buku "Bash and cybersecurity: serangan, pertahanan, dan analisis dari baris perintah Linux"</a></li>
<li><a href="../id501534/index.html">Sekarang dengan COVID-19 juga ada ruam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>