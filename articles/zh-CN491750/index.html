<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏻 👨🏿‍🎓 🧐 我们写子串的搜索要比教科书更好 🍮 🈯️ 🦏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="工程师的一生充满了惊奇：特别是当您必须处理生产率问题时。例如，如果您尝试运行这段Java代码，会发生什么？看起来很无辜：
 
 

// String.repeat JDK 11 : final var needle = "A".repeat(500000) + "B"; final var hay...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我们写子串的搜索要比教科书更好</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491750/"><img src="https://habrastorage.org/webt/ri/ei/to/rieitoeutxefbbjts6ag-carfqk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工程师的一生充满了惊奇：特别是当您必须处理生产率问题时。</font><font style="vertical-align: inherit;">例如，如果您尝试运行这段Java代码，会发生什么？</font><font style="vertical-align: inherit;">看起来很无辜：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//   String.repeat  JDK 11  :</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> needle = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">500000</span>) + <span class="hljs-string">"B"</span>;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> haystack = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">1000000</span>) + <span class="hljs-string">"B"</span>;<font></font>
System.out.println(haystack.indexOf(needle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们等待，等待，等待...至少在我的2015 OpenJDK 13笔记本电脑上，在大海捞针中找到针头大约需要一分钟。</font><font style="vertical-align: inherit;">我们的老式JVM经历了数十年的性能调整，它有效地实现了内在函数</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等。</font><font style="vertical-align: inherit;">可能出了什么问题？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是由其作者</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinasMedžiūnas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供的几篇文章系列的开始，这些文章</font><font style="vertical-align: inherit;">最初发表在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WiX Engineering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">博客上</font><font style="vertical-align: inherit;">。</font></font><br>
</blockquote><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
采取什么是输入定睛一看：数据是专门挑选，以实现在最坏的情况下（二次性能</font></font><code>O(nm)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哪里</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是长度</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是长度</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）为天真的字符串搜索算法。我们将遍历中的所有字符</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果它们与前几个字符重合，则</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将在内循环中继续</font><font style="vertical-align: inherit;">运行</font><font style="vertical-align: inherit;">-依此类推，直到第一个不匹配的字符为止。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能会认为此示例没有用，因为此类输入数据是专门设计和归档的，实际上您不会遇到这种情况。三思而后行。如果您正在处理一个Web服务，该Web服务的用户可以加载任意字符串，并且在该服务的后面某处运行代码，该怎么办？</font></font><code>indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这些线上？然后，只有少数恶意请求（如上述请求）会使您的服务瘫痪。至少值得了解有关输入数据的最坏情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，存在</font><font style="vertical-align: inherit;">具有线性复杂度（</font><font style="vertical-align: inherit;">）的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子字符串搜索算法</font></font></a><font style="vertical-align: inherit;"></font><code>O(n+m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。他们对上面示例中的数据没有任何问题。例如，以下Scala代码执行相同的操作，但在同一台计算机，相同的JVM上并在后台使用完全相同的代码以毫秒为单位运行</font></font><code>java.lang.String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs">val needle = <span class="hljs-string">"A"</span> * <span class="hljs-number">500000</span> + <span class="hljs-string">"B"</span>
val haystack = <span class="hljs-string">"A"</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">"B"</span>
println(haystack.indexOfSlice(needle))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
巨大差异的秘诀在于方法内部</font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala标准库的一部分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它实现了聪明的线性</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">。不，我并不是说X语言比Y语言更好。不幸的是，这里的一切都更加复杂！例如，</font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Scala中，这是一种通用方法，不仅适用于字符串，而且适用于其他顺序集合，并且不仅可以比较字符，还可以比较其他类型的元素。它应该比</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在中间情况下来自Java（我们将在后面讨论）。因此，我们有一个有效的算法，在最坏的情况下性能要好得多，但是平均而言，它速度较慢，因为它的常数部分要大得多。诸如此类的难题是调优性能中的典型问题。没有能够解决所有问题的神奇药丸-您需要仔细分析问题并做出正确的微基准测试。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你还在听我说吗好！您看，这只是一个介绍。我想激励您处理算法的理论复杂性和实际性能。在本文的其余部分，我们将研究几种子字符串搜索算法的一些实现及其基准。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将探索三种子串搜索算法。它们都在线性时间内工作，并且需要预处理，而线性依赖于长度</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只需</font><font style="vertical-align: inherit;">计算</font><font style="vertical-align: inherit;">一次即可，然后可以在几次搜索尝试中重复使用。这是合理的，因为在许多情况下，我们需要一次又一次地搜索同一行。即使我们不这样做，预计算也不是特别昂贵的操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面的所有算法都会绕过其中的每个字符</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能连续执行一次（不能按索引进行随机访问），因此它们在流式传输模式下都可以正常工作。</font><font style="vertical-align: inherit;">本文是在基于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架的生产用代理服务器上的实际工作过程中提出的</font><font style="vertical-align: inherit;">，这影响了一些API设计决策。</font><font style="vertical-align: inherit;">另外，由于我们需要对字节缓冲区进行搜索，因此代码将与一起使用</font></font><code>Byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是与一起使用</font></font><code>Char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt（KMP算法）</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一种可以追溯到上世纪70年代的著名子字符串搜索算法。</font><font style="vertical-align: inherit;">它</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在文献中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">很好的描述</font></a><font style="vertical-align: inherit;">，因此</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">在此</font></a><font style="vertical-align: inherit;">不再详细描述。</font><font style="vertical-align: inherit;">ILC基于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态机</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在初步计算阶段，基于构造链接索引数组</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在搜索过程中，机器在输入处</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个接一个地</font><font style="vertical-align: inherit;">接受字符</font><font style="vertical-align: inherit;">，并相应地更新其内部状态（该状态在关系表中仅存在一个索引）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">实现</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二进制子串搜索算法</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，我不得不独立发明该算法的名称：在文献中我从未见过这样的事情。结果，我的名字叫“移位位掩码”。后来发现，该算法及其变种自1964年以来就以各种不同的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英文名称</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而闻名，</font><font style="vertical-align: inherit;">例如“ Bitap”，“ Shift-or”，“ Shift-and”，“ Baeza-Yates – Gonnet”。感谢为我找到它的读者。这篇文章早于此消息就已经写了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法基于一个非常简单的想法，并且效果很好，因为几乎没有跳转，并且它基于几个原始二进制运算。因此，它限制了</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要查找</font><font style="vertical-align: inherit;">的长度</font><font style="vertical-align: inherit;">：它不能超过64个字节。这个数字只是由</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在JVM中。</font><font style="vertical-align: inherit;">对于大量的实际任务，此限制足够大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自从我自己开发此算法以来，我将尝试更详细地讨论它。</font><font style="vertical-align: inherit;">首先，我们预先计算所需上下文的搜索上下文</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeBitMasks</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Array</span>[<span class="hljs-type">Long</span>] = {<font></font>
    require(needle.length &lt;= <span class="hljs-number">64</span>, <span class="hljs-string">"Maximum supported search pattern length is 64."</span>)
    <span class="hljs-keyword">val</span> bitMasks = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Long</span>](<span class="hljs-number">256</span>)
    <span class="hljs-keyword">var</span> bit = <span class="hljs-number">1</span>L
    <span class="hljs-keyword">for</span> (c &lt;- needle) {<font></font>
      bitMasks(toUnsignedInt(c)) |= bit<font></font>
      bit &lt;&lt;= <span class="hljs-number">1</span><font></font>
    }<font></font>
    bitMasks<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们</font><font style="vertical-align: inherit;">为每个可能的字节值（256个</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">预计算</font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（64位</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">对于一些字节的值</font><font style="vertical-align: inherit;">，它</font><font style="vertical-align: inherit;">包含了包含所有位置，其单位</font><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，下面是字符串“ abracadabra”的位掩码：</font><font style="vertical-align: inherit;">
此外，您需要预先计算</font><font style="vertical-align: inherit;">，这将有助于了解我们找到了完全匹配的内容。</font><font style="vertical-align: inherit;">它看起来像一个值</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">位置</font><font style="vertical-align: inherit;">有点</font><font style="vertical-align: inherit;">：</font></font><code>Long</code><font style="vertical-align: inherit;"></font><code>bitMask</code><font style="vertical-align: inherit;"></font><code>X</code><font style="vertical-align: inherit;"></font><code>bitmask</code><font style="vertical-align: inherit;"></font><code>X</code><font style="vertical-align: inherit;"></font><code>needle</code><font style="vertical-align: inherit;"></font><br>
<br>
<a rel="noopener noreferrer" href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/099/0d9/f95/0990d9f9590612cce258139fb7c287bd.png"></a><br>
<br><font style="vertical-align: inherit;"></font><code>successBitMask</code><font style="vertical-align: inherit;"></font><code>Long</code><font style="vertical-align: inherit;"></font><code>1</code><font style="vertical-align: inherit;"></font><code>needle.length — 1</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeSuccessBitMask</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Long</span> = {
    <span class="hljs-number">1</span>L &lt;&lt; (needle.length - <span class="hljs-number">1</span>)<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，实际上，您需要进行搜索。我们要存储的唯一可变状态是</font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。对于每个字节</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们移位</font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个左</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位，设置在其最显著位</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并做了逐位</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结果之间</font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从当前处理的字节值来计算</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（这个</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重置在那些地方所有的位</font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不当前处理的字节匹配）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在处理完每个字节之后，只有那些处于适当位置的位才能幸免。并且在处理完每个字节后，所有位都向左移动一个位置。如果位“存活”在迭代次数等于长度</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-我们找到了火柴！我们可以使用以下方法验证这一点</font></font><code>successBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(value: <span class="hljs-type">Byte</span>): <span class="hljs-type">Boolean</span> = {<font></font>
    currentMask = ((currentMask &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>) &amp; bitMasks(toUnsignedInt(value))<font></font>
    (currentMask &amp; successBitMask) == <span class="hljs-number">0</span>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果发现某些内容，</font><font style="vertical-align: inherit;">上述方法将返回</font><font style="vertical-align: inherit;">，并且看起来违反直觉。</font><font style="vertical-align: inherit;">可以理解，该值</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示需要继续搜索，但会</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">停止</font><font style="vertical-align: inherit;">搜索</font><font style="vertical-align: inherit;">-这是由于如上所述，该</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API已</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与Netty兼容。</font><font style="vertical-align: inherit;">如果你想知道如何执行搜索，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是一个例子。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，所有逻辑都归结为一些简单的处理器指令。</font><font style="vertical-align: inherit;">不幸的是，仍然存在对数组索引范围的完全无用的检查</font></font><code>bitMasks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是JDK无法删除的（我查看了由几个不同的JDK生成的汇编程序）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">完整实现</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aho korasik</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font><font style="vertical-align: inherit;">自1975年以来已知的</font><font style="vertical-align: inherit;">另一种</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流行算法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它的独特之处（有时是非常有用的）是能够一次搜索多个</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符，而来自其中的所有字符仅</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被绕过一次（我认为这太棒了！）。所有这些工作的想法是对KMP算法的扩展，KMP算法是一种使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前缀树</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的有限状态机</font><font style="vertical-align: inherit;">（基于几个</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">树</font></a></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），其中包含指向链接的链接（与KMP中的一维数组进行比较）。基于这些链接，自动机的内部状态在每个已处理符号之后在前缀树的节点之间切换，并且某些节点指示针对特定符号的肯定搜索结果</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这里的预计算阶段相当复杂，但是搜索阶段出乎意料地非常简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala上可行的实现</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的链接</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个完全不完整的子字符串搜索算法列表。</font><font style="vertical-align: inherit;">我们还尝试了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabin-Karp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boyer-Moore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这两者中，Boyer-Moore表现出可比的性能，但是它们都与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流媒体</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不兼容</font><font style="vertical-align: inherit;">（使用</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按索引的</font><font style="vertical-align: inherit;">随机访问</font><font style="vertical-align: inherit;">），因此我从调查中删除了它们。</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准测试</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将对上述三种算法进行基准测试，此外，还要查看方法</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Java）和</font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Scala）的结果。老实说，这不是一个完全正确的比较，因为它</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于字符串，并且所有其他方法都位于字节数组上。但这似乎并没有使这种比较的结果无效。此外，我还包括了</font></font><code>Bytes.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番石榴（v.28.1）</font><font style="vertical-align: inherit;">的结果</font><font style="vertical-align: inherit;">。此方法适用于字节数组。然后他们在Google上写了-他们在那里写的所有内容都运行得非常快，对吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编写基准测试总是很困难，因为您可以将完全不同的数据发送到输入，并以许多不同的方式进行更改-不仅长度</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，还受这些行的内部内容的影响（这可能会大大影响某些算法）。在实践中，始终值得检查与您实际任务中的数据最相似的输入数据（这是我们在项目中所做的）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了简化本文，我仅使用了两种输入。其中一个旨在反映实际情况：</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小约为1.5 KB（内部带有人类可读文本）</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-9个字节，而不是</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按此顺序排列（这是强制算法执行完整扫描所必需的）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要另一种类型的输入来获得二次算法的最坏情况。它比本文开头的数据短得多：否则，我们将不得不等待一整分钟，还记得吗？数组</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置为以下格式</font></font><code>"AA...AAB"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（与第一种数据类型相同的长度），以及</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-64字节（尤其是二进制子字符串搜索算法要处理的字节）相同类型的数组（匹配仅在最后</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里可以找到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用JMH框架编写的基准</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您对此处的测量方法和方法还有其他想法，可以克隆此存储库，更改某些内容并发表评论。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弗拉基米尔·西特尼科夫</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Vladimir Sitnikov）</font></a><font style="vertical-align: inherit;">的建议下</font><font style="vertical-align: inherit;">，我添加了基准测试结果</font></font><code>java.util.regex.Pattern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；他在后台使用了Boyer-Moore算法。</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（译者注：顺便说一句，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弗拉基米尔·西特尼科夫</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Vladimir Sitnikov）</font></a><font style="vertical-align: inherit;">是JUG Ru Group几个计划委员会的成员，他本人也做了有趣的报告。例如，</font><font style="vertical-align: inherit;">他的JPoint 2019报告题为``Java放慢了速度：CodeCache版本'' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的视频可在链接上获得</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准结果</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果以毫秒为单位，越少越好：</font><font style="vertical-align: inherit;">
这里的一切都与预期的一样：</font></font><br>
<br>
<code># JMH version: 1.21<br>
# VM version: JDK 13.0.1, OpenJDK 64-Bit Server VM, 13.0.1+9<br>
Benchmark (searchInput) Mode Cnt Score Error Units<br>
javaIndexOf REGULAR avgt 5 0.622 ± 0.002 us/op<br>
shiftingBitMask REGULAR avgt 5 1.982 ± 0.017 us/op<br>
regexPattern REGULAR avgt 5 2.184 ± 0.006 us/op<br>
kmp REGULAR avgt 5 2.635 ± 0.016 us/op<br>
scalaIndexOfSlice REGULAR avgt 5 3.202 ± 0.009 us/op<br>
guavaIndexOf REGULAR avgt 5 3.696 ± 0.095 us/op<br>
ahoCorasic REGULAR avgt 5 7.063 ± 0.040 us/op<br>
shiftingBitMask WORST_CASE avgt 5 1.986 ± 0.010 us/op<br>
kmp WORST_CASE avgt 5 5.120 ± 0.006 us/op<br>
ahoCorasic WORST_CASE avgt 5 6.892 ± 0.025 us/op<br>
scalaIndexOfSlice WORST_CASE avgt 5 8.765 ± 0.007 us/op<br>
regexPattern WORST_CASE avgt 5 11.566 ± 0.086 us/op<br>
javaIndexOf WORST_CASE avgt 5 23.029 ± 0.124 us/op<br>
guavaIndexOf WORST_CASE avgt 5 52.927 ± 0.275 us/op<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于普通数据，它占主导地位</font></font><code>javaIndexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它在内部使用了高性能内在函数，因此常量部分很小；</font></font></li>
<li>     ,  :     ,     (<code>O(nm)</code>)   <code>javaIndexOf</code>,           —      ,  <code>shiftingBitMask</code> (  )   .</li>
<li><code>guavaIndexOf</code>      ,    <code>javaIndexOf</code>;  ,        2  ,    <code>shiftingBitMask</code>;</li>
<li><code>scalaIndexOfSlice</code>  -  ,  <code>knuthMorrisPratt</code>,   ,      —   ,  ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能并不是最强大的功能</font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或至少</font><font style="vertical-align: inherit;">不是</font><font style="vertical-align: inherit;">其实现的功能；我必须承认，我并没有真正尝试对其进行微优化，因为我之所以添加它仅仅是因为它的独特功能：一次可以跨几行搜索的能力，并且类似于另一篇文章的主题）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入数据（和长度</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）不影响性能</font></font><code>shiftingBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在不同情况下，基准可以以不同方式工作。</font><font style="vertical-align: inherit;">尽管上述结果似乎很有指示性，但您仍应始终自己进行测量并使用反映您实际任务的数据进行测量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据提供的数据，我得出以下结论：</font></font><br>
<br>
<ul>
<li>    <code>String</code>-   ,           ,   <code>String.indexOf</code> ( <code>java.util.regex.Pattern</code> —      );</li>
<li>,   <code>needle</code>   64 ,    ;</li>
<li> ,   --;</li>
<li>   Scala        - (     ),   <code>indexOfSlice</code>    —    ;</li>
<li>    ,  -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样！</font><font style="vertical-align: inherit;">如果您喜欢阅读有关算法，性能等的文章（以及有关Scala，JVM和Java的一般文章），请订阅本文的作者Linas Medziunas（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包含本文中所有代码的github存储库在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<hr><br>
<img src="https://habrastorage.org/webt/_f/ku/xn/_fkuxncdimo0rsaeealkeqpe8f0.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在JUG Ru Group和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPoint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conference的支持下发表文章的翻译</font><font style="vertical-align: inherit;">。</font></font><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491740/index.html">Yandex.Cloud中的物联网：Yandex IoT Core和Yandex Cloud Functions服务的安排方式</a></li>
<li><a href="../zh-CN491742/index.html">冰冻果子露：人体工学游戏键盘</a></li>
<li><a href="../zh-CN491744/index.html">伊朗黑客利用VPN中的漏洞</a></li>
<li><a href="../zh-CN491746/index.html">语音合成的历史：电气解决方案的时代</a></li>
<li><a href="../zh-CN491748/index.html">帮助盲人学习英语的技术</a></li>
<li><a href="../zh-CN491760/index.html">电报。出租车的200行代码</a></li>
<li><a href="../zh-CN491780/index.html">GitLab 12.8与日志浏览器，NuGet和合规性仪表板一起发布</a></li>
<li><a href="../zh-CN491782/index.html">LANIT在莫斯科，奔萨，索契和新罗西斯克开设测试学校</a></li>
<li><a href="../zh-CN491788/index.html">我对Angular的承诺教会了我什么</a></li>
<li><a href="../zh-CN491792/index.html">无线HiFiMan作为等动力耳机发展的一个阶段</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>