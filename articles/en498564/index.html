<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ üéå üë®‚Äçüè≠ Rendering optimization for Mobile, part 2. The main families of modern mobile GPUs üí´ ‚ôêÔ∏è üòæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, dear lovers and professionals, graphics programmers! Let's start the second part of our series of articles about rendering optimization for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rendering optimization for Mobile, part 2. The main families of modern mobile GPUs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/498564/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greetings, dear lovers and professionals, graphics programmers! </font><font style="vertical-align: inherit;">Let's start the second part of our series of articles about rendering optimization for Mobile. </font><font style="vertical-align: inherit;">In this part, we will consider the main families of GPUs presented by players on Mobile.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/cf7/711/36dcf7711d7ce68544c97bb8dc69ee32.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin, consider a number of criteria by which mobile GPUs can be classified. </font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unified or specialized shader kernels</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the era of early mobile video cards, before the spread of complex effects, there was a point of view that for fragment shaders, support for calculations with reduced accuracy is sufficient. Indeed, in a typical display mode, 8 or even fewer bits are used for each color channel. This view has led to the use of specialized shader cores. For the vertices, we used kernels optimized for matrix transformations with increased accuracy FP24 / FP32 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). For pixels, cores that work more efficiently with reduced accuracy FP16 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). With this </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they were not supported. </font><font style="vertical-align: inherit;">At first glance, this specialization allows us to achieve a more rational distribution of transistors on the chip. </font><font style="vertical-align: inherit;">However, in practice, this leads to difficulties in developing complex effects, as well as when using high-resolution textures. </font><font style="vertical-align: inherit;">In addition, core specialization can lead to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertex / fragment bottleneck</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This term refers to the situation when, due to the asymmetric load on the vertex and pixel cores, some of the cores were ‚Äúidle‚Äù.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/144/547/30714454751e34703835ce904cf5f40a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, modern architectures use unified cores. </font><font style="vertical-align: inherit;">Such kernels can take on vertex, pixel and other computational tasks depending on the load.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/d7c/363/ffed7c363ebecf0d390a0271c1a8b014.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector (SIMD) or scalar instruction set</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the spirit of the desire to save on transistors described above, specializing in cores, the design of a set of shader instructions took place. Most typical transformations for three-dimensional graphics operate with 4 component vectors. Therefore, early GPUs worked specifically with such operands. If the shader code contained heterogeneous scalar operations that could not be packaged into vector operations by the optimizer, some of the computing power was not used. This phenomenon can be illustrated as follows:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b7/3dd/34a/6b73dd34a79eb4376ed816a37de4a4ae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a shader that implements the common Multiply Add operation: multiply 2 operands, and then add the third. When compiling on a conditional vector architecture (Vector ISA = Vector Instruction Set Architecture) we get one vector instruction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vMADD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which runs for 1 clock. On conditional scalar architecture, we get 4 scalar instructions, which, thanks to an improved pipeline, also execute in 1 clock cycle. Now consider a sophisticated shader that performs 2 operations, but on 2 component operands.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/333/539/b2f/333539b2fb573f8f93ff518ca25f6e5c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of vector architecture, we already get 2 instructions that require 2 clock cycles to execute. However, no </font><font style="vertical-align: inherit;">action is taken </font><font style="vertical-align: inherit;">on the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.zw</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> components </font><font style="vertical-align: inherit;">, and the processing power is idle. In the case of scalar architecture, these same operations can be packaged in 4 scalar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sMADDs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that run in the same 1 clock cycle. Thus, on scalar architecture due to the improvement of the pipeline, a higher density of calculations is achieved. However, as will be shown below, the vector </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is still relevant. So, it makes sense to apply vectorization techniques for shader code. They allow you to achieve increased performance on video cards with vector </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At the same time, as a rule, this does not harm the performance on more modern scalar</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on the above characteristics, we will consider the families of mobile GPUs that are common in our time. </font><font style="vertical-align: inherit;">Let's start with the most common family. </font><font style="vertical-align: inherit;">Many people know that we are talking about </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> graphics cards </font><font style="vertical-align: inherit;">from the British company </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ARM is not directly involved in chip production, offering intellectual property instead. </font><font style="vertical-align: inherit;">Like other mobile video cards, Mali is part of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System on Chip (SoC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. </font><font style="vertical-align: inherit;">works with shared </font><font style="vertical-align: inherit;">memory </font><font style="vertical-align: inherit;">for the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and bus.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali utgard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 2008, the first representatives of the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> architecture were </font><strong><font style="vertical-align: inherit;">born</font></strong><font style="vertical-align: inherit;"> , relevant up to the present day. </font><font style="vertical-align: inherit;">These video cards are named according to the Mali-4 scheme </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MP </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the model number and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the number of fragment cores. </font><font style="vertical-align: inherit;">In </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader core specialty, and all models come with a vertex only 1 core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Other features of the Mali Utgard architecture:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lack of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> support </font><font style="vertical-align: inherit;">in fragmented kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector instruction set (it makes sense to vectorize calculations)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specification </font><font style="vertical-align: inherit;">, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> video card </font><strong><font style="vertical-align: inherit;">drivers</font></strong><font style="vertical-align: inherit;"> successfully compile fragment shaders that use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precision </font><font style="vertical-align: inherit;">(for example, accuracy is set by default using </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precision highp float</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). But the accuracy of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actually used </font><font style="vertical-align: inherit;">. Therefore, it is advisable to additionally test all shaders for mobile games on such video cards. According to data collected by </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , at the end of 2019, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> worked on devices for about 10% of players. And if you set the appropriate filters on </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">market.yandex.ru</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you can see that in 2019 more than 10 new phones with video cards of this architecture were announced.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/5a9/8ae/7795a98ae2da31ecf49131939087c21e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are ready to abandon this audience, it is enough to set the requirement for OpenGL ES 3.0 support in AndroidManifest.xml: </font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">uses-feature</span> <span class="hljs-attr">android:glEsVersion</span>=<span class="hljs-string">"0x00030000"</span> <span class="hljs-attr">android:required</span>=<span class="hljs-string">"true"</span>‚ÅÑ&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , there are currently no widespread mobile GPUs without support for OpenGL ES 3.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of particular note is the use of high resolution textures on the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ten bits of the mantissa with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> accuracy </font><strong><font style="vertical-align: inherit;">are</font></strong><font style="vertical-align: inherit;"> not enough for high-quality texturing with a texture resolution of more than 1024 on one side. </font><font style="vertical-align: inherit;">However, despite supporting only </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precision in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fragment cores </font><font style="vertical-align: inherit;">, you can get </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fp24</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texture coordinate accuracy when using </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varying</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> directly.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// vertex shader</span><font></font>
varying highp vec2 v_texc;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    v_texc = ‚Ä¶;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  fragment shader</span><font></font>
...<font></font>
varying highp vec2 v_texc;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    gl_FragColor = texture2D(u_sampler, v_texc); <span class="hljs-comment">//  v_texc </span>
                                                 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a bonus on some architectures, this approach allows you to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prefetch</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texture content before running a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragment shader</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which minimizes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stalls</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> while waiting for texture sampling results.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali midgard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard has been</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> replaced by the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> architecture </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There are several generations of this architecture with the names of the species </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-6xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-7xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-8xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Despite the 8-year-old age, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be called modern architecture that provides support for most of the new features:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unified shader kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.2 (compute &amp; geometry shaders, tesselation ...)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the Mali Midgard retains the vector </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Given the widespread use of Mali Midgard (about 25% of our audience), vectorization of computing becomes appropriate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another feature of Mali Midgard is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forward Pixel Kill</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> technology </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Each pixel is calculated in a separate stream of the fragment core. </font><font style="vertical-align: inherit;">If during the execution of the stream it becomes known that the resulting pixel will be blocked by an opaque pixel of another primitive, the stream terminates prematurely and the freed resources are used for other calculations.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali bifrost</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Midgard, </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bifrost</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> architecture </font><strong><font style="vertical-align: inherit;">stands</font></strong><font style="vertical-align: inherit;"> out for its transition to scalar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Compared with the previous architecture, the maximum number of cores has been increased (from 16 to 32), and an improved interface with a CPU is supported, which allows for coherent access to shared memory: changes to the contents of the CPU / GPU memory immediately become ‚Äúvisible‚Äù to each other despite the caches, which allows you to simplify synchronization.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From unofficial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many attempts have been made to reverse engineer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> video cards </font><font style="vertical-align: inherit;">to create </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Source</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drivers for </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The works of the dedicated people trying to do this allow you to take a look at the undocumented features of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> video cards </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">So, in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PanFrost</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">there</font></a><font style="vertical-align: inherit;"> is a disassembler for </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard / Bifrost</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , with which you can get acquainted with a set of shader instructions (there is no open official information on this topic).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f31/751/bbdf3175137a886431a23de54239900e.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second most common family of mobile </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This video card is installed on the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , known under the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snapdragon</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> brand </font><font style="vertical-align: inherit;">, from the American company </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualcomm</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Snapdragon is installed in the top-end smartphones of our time from </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samsung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and others. The </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
current </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> video cards </font><font style="vertical-align: inherit;">are the 3xx - 6xx series families. </font><font style="vertical-align: inherit;">All these series combine the following features:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unified shader kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudo TBR (large tile sizes located in a traditional dedicated GPU memory)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic switching in Immediate Mode Rendering depending on the nature of the scene ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlexRender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scalar instruction set</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starting with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 4xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , support for </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.1 is introduced</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 5xx - Vulkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno tile based rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adreno video cards have a ‚Äútraditional‚Äù GPU called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GMEM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Volumes from 128kb to 1536kb apply. This allows you to use a larger tile size compared to architectures of other developers of mobile GPUs. On Adreno, the size of tiles is dynamic and depends on the color format used, depth buffer and stencil. When working in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediate Mode,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendering occurs in the system memory. There is a GL ES extension that allows you to specify the preferred mode: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QCOM_binning_control</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . However, the latest recommendations from Qualcomm suggest relying entirely on GPU drivers, which themselves determine the most preferred mode for the application-generated command buffer.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working in </font><strong><font style="vertical-align: inherit;">TBR</font></strong><font style="vertical-align: inherit;"> mode</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adreno makes 2 vertex passes:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binning pass</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - distribution of primitives by bin ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bins</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a synonym for tiles)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertex pass</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for rendering only those primitives that fall into the current Bin</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binning pass,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adreno only calculates vertex positions. </font><font style="vertical-align: inherit;">Other attributes are not calculated, and unnecessary code is removed by the optimizer. </font><font style="vertical-align: inherit;">In the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (9.2 Optimize vertex processing), there is a recommendation to store the vertex information needed to calculate positions separately from the rest of the data. </font><font style="vertical-align: inherit;">This makes caching vertex data more efficient.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freedreno</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/83e/c3d/15d/83ec3d15dc03e81e81e7d867cae2b3a3.png" align="left" width="120"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike ARM and Imagination Technologies, Qualcomm is reluctant to share the details of the internal structure of its GPUs. </font><font style="vertical-align: inherit;">However, thanks to the efforts of the reverse engineer Rob Clark, much can be learned from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freedreno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">, the open source </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> driver </font><font style="vertical-align: inherit;">for Linux. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rob Clark by Freedreno</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR by Imagination Technologies</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagination Technologies</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a British fabless company famous for developing GPUs for Apple products. </font><font style="vertical-align: inherit;">The company performed this role until the advent of the iPhone 8 / X, which uses Apple's internal development. </font><font style="vertical-align: inherit;">Although the recommendations on optimizations for these chips, as well as on patent claims against Apple from Imagination, which remained unchanged, suggest that Apple continued to develop the PowerVR architecture, an original development from Imagination. </font><font style="vertical-align: inherit;">In early 2020, Apple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returned</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to licensing practices with Imagination Technologies. </font><font style="vertical-align: inherit;">In addition to devices with iOS / iPadOS, PowerVR video cards are installed in a large number of Android smartphones and tablets.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/86d/b66/a9d86db66b2293beaf3b01d3d809573f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the family of PowerVR graphics cards that can still be found among users.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SGX</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first PowerVR SGX graphics cards appeared back in 2009. </font><font style="vertical-align: inherit;">There are several generations of this architecture: Series5, Series5XT and Series5XE. </font><font style="vertical-align: inherit;">Apple used these GPUs right up to the iPAD 4 / iPhone 5 / iPOD Touch 5. The following SGX features can be cited:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unified shader kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector instruction set</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">support for 10-bit lowp precision in shaders</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">low performance of dependent texture reads</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us dwell on some of them in more detail.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lowp accuracy</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PowerVR SGX are the only up-to-date mobile GPUs with </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hardware support </font><font style="vertical-align: inherit;">. Newer PowerVR models, as well as all modern GPUs of other vendors, actually use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> accuracy </font><font style="vertical-align: inherit;">. Using </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the PowerVR SXG allows you to achieve a higher computation density (more operations per cycle). At the same time, the swizzle operation (permutation of the vector components) for </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , unlike other precision, is not free. This feature, as well as the narrow range of values ‚Äã‚Äãthat lowp provides ([-2,2]), limits its scope. At the same time, the poorly set </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resulting in artifacts on the SGX family will not be seen on all other graphics cards where </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precision will actually be used </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For this reason, you should consider refusing to use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in shaders.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependent texture reads</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you know, texture sampling operations are the slowest due to the need to wait for memory read results. In the case of mobile SoC, we are talking about shared system memory with a CPU. To reduce the number of accesses to slow memory, texture caches are used. To avoid downtime at the beginning of rasterization using a texture, it makes sense to cache the used areas in advance. If the fragment shader uses the texture coordinate passed from the vertex shader without changes, then the texture section necessary for caching can be determined before the fragment shader is executed. If the fragment shader changes the texture coordinate or calculates it using data from another texture, then this is not always possible. As a result, the execution of the fragment shader may slow down.PowerVR SGX graphics cards are particularly painful in this scenario. Moreover, even the use of a permutation of the components of the texture coordinate (swizzle) leads to</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependent texture read</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Here is an example shader program without </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependent texture read</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertex program</font></font></strong><br>
<br>
<pre><code class="cpp hljs">attribute highp vec2 a_texc;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_Position = ‚Ä¶<font></font>
	v_texc = a_texc;<font></font>
}<font></font>
<font></font>
</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragment program</font></font></strong><br>
<br>
<pre><code class="cpp hljs">precision mediump <span class="hljs-keyword">float</span>;<font></font>
uniform sampler u_sampler;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_FragColor = texture2D( u_sampler, v_texc ); <span class="hljs-comment">//  dependent texture read</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case: </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragment program</font></font></strong><br>
<br>
<pre><code class="cpp hljs">precision mediump <span class="hljs-keyword">float</span>;<font></font>
uniform sampler u_sampler;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_FragColor = texture2D( u_sampler, v_texc.yx ); <span class="hljs-comment">// dependent texture read!</span><font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR Rogue</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PowerVR video cards were further developed in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> architecture </font><font style="vertical-align: inherit;">. There are several generations of this architecture: from Series6 to Series9. </font><font style="vertical-align: inherit;">All </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR Rogue</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have these features:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unified shader kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scalar instruction architecture</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">support for OpenGL ES 3.0+ (up to 3.2, as well as the Vulkan API for fresh rulers)&nbsp;</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR TBDR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like all common mobile GPUs, PowerVR uses a tile pipeline. But unlike its competitors, Imagination went further and implemented </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deferred</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rasterization of primitives, which allows skipping shading of invisible pixels regardless of the rendering order. This approach is called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tile Based Deferred Rendering</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the process of eliminating invisible pixels is </font><font style="vertical-align: inherit;">called </font><font style="vertical-align: inherit;">Hidden Surface Removal (HSR).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff2/2db/1dd/ff22db1dd631bb54e964aa24c96b437f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden Surface Removal</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
It is recommended to draw opaque geometry to transparent and not use Z Prepass, which in the case of PowerVR video cards in most scenarios will lead to unnecessary work. </font><font style="vertical-align: inherit;">However, several consecutive transparent pixels overlapping each other are completely shaded to obtain the correct color, taking into account mixing. </font><font style="vertical-align: inherit;">The last transparent pixel can be discarded if it is followed by an opaque pixel.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Openness Imagination Technologies</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The creators of PowerVR have provided open access more documentation than other GPU developers. </font><font style="vertical-align: inherit;">The architecture of the graphics pipeline is described in detail, as well as a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set of instructions for the Rogue architecture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There is a convenient tool </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVRShaderEditor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows you to </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">instantly</font></a><font style="vertical-align: inherit;"> receive profiling information on the shader, as well as its disassembled listing for Rogue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aba/b9a/19e/abab9a19e78e6ff40638d5cdf971615a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the limited presence of PowerVR video cards in the environment of devices based on Android, it makes sense to study their architecture for the competent programming of graphics for iOS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediate mode mobile GPUs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We examined the most common families of mobile video cards. </font><font style="vertical-align: inherit;">All of these families used tile rendering architecture. </font><font style="vertical-align: inherit;">However, there are mobile video cards that use the traditional </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediate mode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> approach. </font><font style="vertical-align: inherit;">Here are some of them:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nVIdia (Tegra SoC)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All Intel family except recent Gen 11</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vivante GCxxxx (+ Arcturus GC8000)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A feature of mobile video cards operating in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediate mode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the expensive FBO cleaning operation. </font><font style="vertical-align: inherit;">Recall that on the tile architecture, full-screen cleaning speeds up the rendering, allowing the driver not to add the Load operation of the old contents to the tile memory. </font><font style="vertical-align: inherit;">On mobile </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediate mode GPUs,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> full-screen cleaning is a time-consuming operation that allows, among other things, such GPUs to ‚Äúcalculate‚Äù. </font><font style="vertical-align: inherit;">If adding cleanup does not speed up, but slows down the rendering, then most likely we are working with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediate mode GPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Well, of course, let's not forget to mention that on </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediate mode GPUs,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> changing a target is a ‚Äúconditionally free‚Äù procedure.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribution of different families of mobile GPUs among our players</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here are the statistics on mobile GPUs collected from our players at the end of 2019:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/184/634/e7f1846345e5e8bf798bbf207a11885d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Below we open the ‚ÄúOthers‚Äù segment</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/f61/604/8a3f61604361a8c8e426ae0ae8920f05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on these data, we look at the distribution of the GPU in terms of their main features.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/b97/3d5/b41b973d5d8d01e817a558d838396d63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vector ALUs (arithmetic logic unit) become obsolete and replaced with scalar ones. Today, the bulk of mobile GPUs with a vector instruction set is the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which can be considered average in performance. Because vectorization, as a rule, does not slow down execution on scalar ALUs; it is worth considering vectorization as an actual technique for optimizing shaders for mobile.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Specialized shader kernels are deprecated and are replaced by unified ones. The Vertex Bottleneck on the skeletal mesh is no longer scary. Specialized kernels are used only on the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-4xx (Utgard) family</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Recall that these GPUs only support </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Our audience has about 3.5% of them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, the vast majority of mobile GPUs use the tile approach. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediate Mode has</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> become marginalized and is quickly being squeezed out along with the video cards that use it. </font><font style="vertical-align: inherit;">The share of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediate mode GPUs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in our players is about 0.7%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Useful links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.arm.com/solutions/graphics</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.qualcomm.com/software/adreno-gpu-sdk/tools</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.imgtec.com/developers/powervr-sdk-tools/documentation/</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for the attention! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next article from the series, we will consider techniques for optimizing shaders for Mobile.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en498548/index.html">Creating Your Own Package for Laravel Nova: OptimalImage</a></li>
<li><a href="../en498552/index.html">What mistakes do managers on a remote site</a></li>
<li><a href="../en498556/index.html">Hans Peter Lun and the birth of the hash algorithm</a></li>
<li><a href="../en498560/index.html">Web components in a real project</a></li>
<li><a href="../en498562/index.html">Contrary to quarantine: how we transferred our internships to a remote format</a></li>
<li><a href="../en498566/index.html">Resilience Engineering: Notes from the REDeploy Conference</a></li>
<li><a href="../en498568/index.html">Inside AMD's 1970s Am2901 multi-chip sectional microprocessor</a></li>
<li><a href="../en498572/index.html">Freaky discounts? Shares of CRM vendors on the occasion of the transition to udalenka</a></li>
<li><a href="../en498574/index.html">Why did I decide to develop games, or a nostalgic trip for zero</a></li>
<li><a href="../en498576/index.html">How we developed the field for entering new messages in our messenger (Gem4me)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>