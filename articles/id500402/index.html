<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍✈️ 🧕 🛌🏿 [Bagian 1/2] Panduan untuk FFmpeg dan SDL atau Cara menulis pemutar video dalam waktu kurang dari 1000 baris 👩🏼‍🤝‍👨🏻 👨🏾‍🌾 🧗🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meskipun informasi ini sudah usang, materi asli masih menjadi sumber inspirasi populer untuk berbagai konten yang berguna pada topik FFmpeg. Namun, ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[Bagian 1/2] Panduan untuk FFmpeg dan SDL atau Cara menulis pemutar video dalam waktu kurang dari 1000 baris</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/500402/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/8g/lm/9b/8glm9bxivqkvscmah31ojdjmzci.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun informasi ini sudah usang, materi asli masih menjadi sumber inspirasi populer untuk berbagai konten yang berguna pada topik FFmpeg. </font><font style="vertical-align: inherit;">Namun, masih belum ada terjemahan lengkap dari aslinya ke dalam bahasa Rusia. </font><font style="vertical-align: inherit;">Kami memperbaiki kelalaian yang mengganggu, karena itu lebih baik terlambat daripada tidak sama sekali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan meskipun kami sudah mencoba, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kesulitan penerjemahan tidak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat dihindari dalam teks yang begitu banyak </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Laporkan bug (lebih disukai dalam pesan pribadi) - bersama-sama kami akan melakukan yang lebih baik.</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Isi</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata Pengantar </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 1: Membuat Screencaps </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 2: Menampilkan </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 3: Memutar Suara </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 4: Banyak Utas </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 5: Menyinkronkan Video</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 6:  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 7: </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 1.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 2.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><a name="preamble"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a><br clear="right">
     EDISON.<br>
<br>
        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a>,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">      C  C++</a>.<br>
<br>
     ! ;-)</blockquote><br>
<h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Ke daftar isi">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 1: Membuat Screencapses">→</a></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD: Panduan ini telah diperbarui pada Februari 2015. </font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah perpustakaan yang hebat untuk membuat aplikasi video serta utilitas untuk keperluan umum. FFmpeg menangani seluruh rutin pemrosesan video, melakukan semua decoding, encoding, multiplexing dan demultiplexing. Yang sangat menyederhanakan pembuatan aplikasi media. Semuanya cukup sederhana dan cepat, ditulis dalam C, Anda dapat mendekode hampir semua codec yang tersedia saat ini, serta menyandikan ke beberapa format lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu-satunya tangkapan adalah bahwa sebagian besar dokumentasi hilang. Ada satu tutorial ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam bahasa aslinya, ini adalah tautan ke halaman web yang sudah tidak ada - penerjemah catatan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), yang mencakup dasar-dasar FFmpeg dan generasi otomatis dok dok. Dan tidak ada lagi. Oleh karena itu, saya memutuskan untuk mencari tahu cara menggunakan FFmpeg secara mandiri untuk membuat aplikasi video dan audio digital yang berfungsi, dan pada saat yang sama mendokumentasikan proses dan menyajikannya dalam bentuk buku teks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada program FFplay yang dilengkapi dengan FFmpeg. Ini sederhana, ditulis dalam C, mengimplementasikan pemutar video lengkap menggunakan FFmpeg. Pelajaran pertama saya adalah versi terbaru dari pelajaran asli oleh Martin Boehme ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam aslinya, tautan ke halaman web yang sudah tidak ada - catatan penerjemah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - Saya menyeret beberapa bagian dari sana. Dan juga dalam serangkaian pelajaran saya, saya akan menunjukkan proses membuat pemutar video yang berfungsi berdasarkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ffplay.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabrice Bellard. Setiap pelajaran akan menyajikan ide baru (atau bahkan dua) dengan penjelasan penerapannya. Setiap bab dilengkapi dengan daftar C, yang dapat Anda kompilasi dan jalankan sendiri. File sumber akan menunjukkan bagaimana program ini bekerja, bagaimana bagian-bagiannya bekerja, dan juga menunjukkan detail teknis kecil yang tidak tercakup dalam panduan ini. Ketika kita selesai, kita akan memiliki pemutar video yang berfungsi ditulis dalam kurang dari 1000 baris kode!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membuat pemutar, kami akan menggunakan SDL untuk mengeluarkan file media audio dan video. SDL adalah perpustakaan multimedia lintas platform luar biasa yang digunakan dalam program pemutaran MPEG, emulator, dan banyak video game. Anda perlu mengunduh dan menginstal perpustakaan SDL di sistem Anda untuk mengkompilasi program dari panduan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tutorial ini untuk orang-orang dengan pengalaman pemrograman yang baik. Paling tidak, Anda perlu tahu C, dan juga memiliki pemahaman konsep-konsep seperti antrian, mutex, dll. Harus ada pemahaman tentang multimedia; misalnya, hal-hal seperti bentuk gelombang dan sejenisnya. Namun, menjadi guru dalam hal-hal ini tidak perlu, karena banyak konsep akan dijelaskan dalam pelajaran.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Silakan mengirimi saya pesan kesalahan, pertanyaan, komentar, ide, fitur, apa pun, di Dranger Doggy Gmail dot Com.</font></font><a name="screencaps"></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca juga di blog </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
perusahaan EDISON:</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manual libav FFmpeg</font></font></b></a><br>
<hr><hr><hr><hr><hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 1: Membuat Screencaps </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Kata pengantar"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Ke daftar isi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 2: Tampilan"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar lengkap: tutorial01.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial01.c</span>
<span class="hljs-comment">// Code based on a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101 </span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span><font></font>
<font></font>
<span class="hljs-comment">// A small sample program that shows how to use libavformat and libavcodec to</span>
<span class="hljs-comment">// read video from a file.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lswscale -lz</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed</span>
<span class="hljs-comment">// your system).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// tutorial01 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to write the first five frames from "myvideofile.mpg" to disk in PPM</span>
<span class="hljs-comment">// format.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
  <span class="hljs-comment">// Initalizing these to NULL prevents segfaults!</span>
  AVFormatContext   *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>               i, videoStream;<font></font>
  AVCodecContext    *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext    *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec           *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrameRGB = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket          packet;<font></font>
  <span class="hljs-keyword">int</span>               frameFinished;
  <span class="hljs-keyword">int</span>               numBytes;
  <span class="hljs-keyword">uint8_t</span>           *buffer = <span class="hljs-literal">NULL</span>;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please provide a movie file\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
  pFrameRGB=av_frame_alloc();<font></font>
  <span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
  numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
			      pCodecCtx-&gt;height);<font></font>
  buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));<font></font>
  <font></font>
  <span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
  <span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
  <span class="hljs-comment">// of AVPicture</span><font></font>
  avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
		 pCodecCtx-&gt;width, pCodecCtx-&gt;height);<font></font>
  <font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_RGB24,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {
	<span class="hljs-comment">// Convert the image from its native format to RGB</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
	<span class="hljs-comment">// Save the frame to disk</span>
	<span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
	  SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <font></font>
		    i);<font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the RGB image</span><font></font>
  av_free(buffer);<font></font>
  av_frame_free(&amp;pFrameRGB);<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambaran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File film memiliki beberapa komponen utama. Pertama, file itu sendiri disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wadah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan jenis wadah menentukan bagaimana data diwakili dalam file. Contoh wadah adalah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quicktime</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selanjutnya, ada beberapa utas dalam file; khususnya, biasanya ada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ("Stream" adalah kata yang lucu untuk "urutan item data yang tersedia sesuai dengan timeline.") Item data dalam aliran disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setiap aliran dikodekan oleh satu atau lain jenis </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Codec menentukan bagaimana data aktual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diruyutsya dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desember</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diaudit - oleh karena itu nama codec. </font><font style="vertical-align: inherit;">Contoh codec adalah DivX dan MP3. </font><font style="vertical-align: inherit;">Paket kemudian dibaca dari aliran. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah potongan data yang dapat berisi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang diterjemahkan ke dalam bingkai mentah, yang akhirnya dapat kita manipulasi dalam aplikasi kita. </font><font style="vertical-align: inherit;">Untuk keperluan kami, setiap paket berisi frame penuh (atau beberapa frame jika itu audio). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bekerja dengan stream video dan audio sangat sederhana bahkan pada tingkat paling dasar:</font></font><br>
<br>
<pre><code class="vbscript hljs"><span class="hljs-number">10</span> OPEN video_stream FROM video.avi
<span class="hljs-number">20</span> READ packet FROM video_stream INTO frame
<span class="hljs-number">30</span> <span class="hljs-keyword">IF</span> frame <span class="hljs-keyword">NOT</span> COMPLETE <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span>
<span class="hljs-number">40</span> <span class="hljs-keyword">DO</span> SOMETHING <span class="hljs-keyword">WITH</span> frame
<span class="hljs-number">50</span> <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bekerja dengan multimedia menggunakan FFmpeg hampir sesederhana dalam program ini, meskipun dalam beberapa program langkah "MAKE [...]" bisa sangat sulit. </font><font style="vertical-align: inherit;">Dalam tutorial ini, kita akan membuka file, menghitung aliran video di dalamnya, dan "MAKE [...]" kami akan menulis bingkai ke file PPM.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuka file</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang pertama, mari kita lihat apa yang terjadi pertama kali ketika Anda membuka file. </font><font style="vertical-align: inherit;">Menggunakan FFmpeg, kami pertama-tama menginisialisasi perpustakaan yang diinginkan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ffmpeg/swscale.h&gt;</span></span><font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, charg *argv[])</span> </span>{<font></font>
av_register_all();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mencatat semua format file dan codec yang tersedia di perpustakaan, sehingga mereka akan digunakan secara otomatis saat membuka file dengan format / codec yang sesuai. </font><font style="vertical-align: inherit;">Perhatikan bahwa Anda perlu memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_register_all</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () hanya sekali, jadi kami melakukannya di sini di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Jika mau, Anda hanya dapat mendaftarkan format file dan codec selektif, tetapi biasanya tidak ada alasan khusus untuk melakukannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang buka file:</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Open video file</span>
<span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dapatkan nama file dari argumen pertama. </font><font style="vertical-align: inherit;">Fungsi ini membaca header file dan menyimpan informasi format file dalam struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang kami lewati. </font><font style="vertical-align: inherit;">Tiga argumen terakhir digunakan untuk menentukan format file, ukuran buffer, dan parameter format. </font><font style="vertical-align: inherit;">Dengan mengaturnya ke NULL atau 0, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libavformat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan mendeteksi semuanya secara otomatis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi ini hanya melihat header, jadi sekarang kita perlu memeriksa informasi aliran di file:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Retrieve stream information</span>
<span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi ini meneruskan </font><font style="vertical-align: inherit;">data yang valid </font><font style="vertical-align: inherit;">ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kami berkenalan dengan fungsi debugging yang nyaman, menunjukkan kepada kami apa yang ada di dalamnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Dump information about file onto standard error</span>
av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanyalah sebuah array pointer ukuran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kami akan melewatinya sampai kami menemukan aliran video:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i;<font></font>
AVCodecContext *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
AVCodecContext *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
    videoStream=i;<font></font>
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
<font></font>
<span class="hljs-comment">// Get a pointer to the codec context for the video stream</span>
pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informasi tentang codec dalam aliran terletak di tempat yang disebut " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konteks codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Ini berisi semua informasi tentang codec yang digunakan stream, dan sekarang kami memiliki pointer ke sana. </font><font style="vertical-align: inherit;">Tetapi kita masih harus menemukan codec asli dan membukanya:</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">// Open codec</span>
<span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa Anda tidak dapat langsung menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari aliran video! </font><font style="vertical-align: inherit;">Oleh karena itu, Anda harus menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vcodec_copy_context</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () untuk menyalin konteks ke lokasi baru (tentu saja, setelah memori dialokasikan untuk itu).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyimpanan data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita membutuhkan tempat untuk menyimpan bingkai:</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Allocate video frame</span>
pFrame=av_frame_alloc();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kami berencana untuk menghasilkan file PPM yang disimpan dalam RGB 24-bit, kami perlu mengubah frame kami dari formatnya sendiri ke RGB. </font><font style="vertical-align: inherit;">FFmpeg akan melakukannya untuk kita. </font><font style="vertical-align: inherit;">Untuk sebagian besar proyek (termasuk yang ini), Anda perlu mengonversi kerangka awal ke format tertentu. </font><font style="vertical-align: inherit;">Pilih bingkai untuk bingkai yang dikonversi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
pFrameRGB=av_frame_alloc();<font></font>
<span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa kami memilih bingkai, kami masih membutuhkan tempat untuk menampung data mentah saat mengonversinya. </font><font style="vertical-align: inherit;">Kami menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_get_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mendapatkan ukuran yang tepat dan mengalokasikan ruang yang diperlukan secara manual:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint8_t</span> *buffer = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">int</span> numBytes;
<span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
                            pCodecCtx-&gt;height);<font></font>
buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah analog dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-function </font><font style="vertical-align: inherit;">dari FFmpeg, yang merupakan pembungkus sederhana di sekitar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menyediakan perataan alamat memori, dll. </font><font style="vertical-align: inherit;">Omong-omong, ini tidak melindungi terhadap kebocoran memori, pembebasan ganda atau masalah lain yang terjadi dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_fill</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mengaitkan frame dengan buffer yang baru dialokasikan. </font><font style="vertical-align: inherit;">Mengenai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah bagian dari struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - awal dari struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> identik dengan struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
<span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
<span class="hljs-comment">// of AVPicture</span><font></font>
avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
                pCodecCtx-&gt;width, pCodecCtx-&gt;height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sudah berada di garis finish! </font><font style="vertical-align: inherit;">Sekarang kita siap membaca dari aliran!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membaca data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, untuk membaca seluruh aliran video, kita membaca paket berikutnya, mendekripsi dalam bingkai kita, dan segera setelah dekripsi selesai, konversi bingkai dan simpan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span>
<span class="hljs-keyword">int</span> frameFinished;<font></font>
AVPacket packet;<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    pCodecCtx-&gt;pix_fmt,<font></font>
    pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    PIX_FMT_RGB24,<font></font>
    SWS_BILINEAR,<font></font>
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span><font></font>
    );<font></font>
<font></font>
i=<span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
	<span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
    <font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">// Convert the image from its native format to RGB</span>
        sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
        <span class="hljs-comment">// Save the frame to disk</span>
        <span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
          SaveFrame(pFrameRGB, pCodecCtx-&gt;width, <font></font>
                    pCodecCtx-&gt;height, i);<font></font>
    }<font></font>
  }<font></font>
    <font></font>
  <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
  av_free_packet(&amp;packet);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada yang rumit: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () membaca paket dan menyimpannya dalam struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Harap dicatat bahwa kami hanya mendistribusikan struktur paket - FFmpeg memberi kami data internal yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunjukkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh </font><b><font style="vertical-align: inherit;">packet.data</font></b><font style="vertical-align: inherit;"> . Ini membebaskan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free_packet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">sedikit kemudian </font><font style="vertical-align: inherit;">. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () mengubah paket menjadi bingkai. Namun, kami mungkin tidak memiliki semua informasi yang kami butuhkan untuk frame setelah mendekode paket, oleh karena itu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () menetapkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ketika kami memiliki frame berikutnya. Akhirnya, kami menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () untuk mengkonversi dari format kami sendiri ( </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pCodecCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) di RGB. Ingatlah bahwa Anda dapat melemparkan</font><font style="vertical-align: inherit;">penunjuk</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke penunjuk</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Akhirnya, kami meneruskan informasi tentang bingkai, tinggi dan lebar fungsi</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami</font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berbicara tentang paket. Secara teknis, sebuah paket hanya dapat berisi bagian dari sebuah frame, serta bit data lainnya. Namun, parser FFmpeg menjamin bahwa paket yang kami terima mengandung frame penuh atau bahkan beberapa frame.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang yang masih harus dilakukan adalah menggunakan fungsi</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menulis informasi RGB ke file PPM. Meskipun kami secara dangkal berurusan dengan format PPM itu sendiri; percayalah, semuanya bekerja di sini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melakukan file standar terbuka, dll., Dan kemudian merekam data RGB. File ini ditulis baris demi baris. File PPM hanyalah sebuah file di mana informasi RGB disajikan sebagai garis panjang. Jika Anda tahu warna HTML, itu akan seperti menandai warna setiap piksel dari ujung pertama ke terakhir, sesuatu seperti </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># ff0000 # ff0000 ....</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti untuk layar merah. (Sebenarnya, ini disimpan dalam format biner dan tanpa pemisah, tapi saya harap Anda menangkap idenya.) Judul menunjukkan seberapa lebar dan tinggi gambar, serta ukuran maksimum nilai RGB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kembali ke fungsi </font><font style="vertical-align: inherit;">() </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">. Segera setelah kami selesai membaca dari streaming video, kami hanya perlu menghapus semuanya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Free the RGB image</span><font></font>
av_free(buffer);<font></font>
av_free(pFrameRGB);<font></font>
<font></font>
<span class="hljs-comment">// Free the YUV frame</span><font></font>
av_free(pFrame);<font></font>
<font></font>
<span class="hljs-comment">// Close the codecs</span><font></font>
avcodec_close(pCodecCtx);<font></font>
avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
<span class="hljs-comment">// Close the video file</span><font></font>
avformat_close_input(&amp;pFormatCtx);<font></font>
<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, kami menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memori yang dialokasikan menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcode_alloc_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja kodenya! </font><font style="vertical-align: inherit;">Sekarang, jika Anda menggunakan Linux atau platform serupa, jalankan:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavutil -lavformat -lavcodec -lz -lavutil -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memiliki versi FFmpeg yang lebih lama, Anda mungkin perlu menghapus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-lavutil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lz -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar program grafis harus membuka format PPM. </font><font style="vertical-align: inherit;">Lihatlah beberapa file film yang skreencaps-nya dibuat menggunakan program kami.</font></font><a name="outputting"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 2: Menampilkan layar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 1: Membuat Screencapses"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Ke daftar isi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 3: Mainkan Suara"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar lengkap: tutorial02.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial02.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial02 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-keyword">float</span>           aspect_ratio;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
      <font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codec</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL dan video</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggambar di layar kita akan menggunakan SDL. SDL singkatan dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple Direct Layer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini adalah perpustakaan multimedia lintas platform yang sangat baik yang digunakan dalam banyak proyek. Anda bisa mendapatkan perpustakaan di situs web resmi atau mengunduh paket pengembang untuk sistem operasi Anda, jika ada. Anda akan memerlukan perpustakaan untuk mengkompilasi kode dari pelajaran ini (semua pelajaran lain, omong-omong, ini juga berlaku) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL memiliki banyak metode untuk menggambar di layar. Salah satu cara untuk menampilkan film adalah apa yang disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overlay YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara formal, bahkan YUV, tetapi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YCbCr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ngomong-ngomong, beberapa orang menjadi sangat terbakar ketika "YCbCr" disebut sebagai "YUV". Secara umum, YUV adalah format analog, dan YCbCr adalah format digital. FFmpeg dan SDL dalam kode mereka dan di makro menunjuk YCbCr sebagai YUV, tapi itu. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah metode penyimpanan data gambar mentah seperti RGB. Secara kasar, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah komponen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecerahan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah komponen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warna</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Ini lebih rumit daripada RGB karena bagian dari informasi warna dibuang, dan Anda hanya dapat memiliki 1 pengukuran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk setiap 2 pengukuran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hamparan YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di SDL menerima dataset YUV mentah dan menampilkannya. Ia menerima 4 jenis format YUV yang berbeda, tetapi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah yang tercepat. Ada format YUV lain yang disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang cocok dengan YV12, kecuali bahwa array </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditukar. 420 berarti sampel diambil pada rasio 4: 2: 0, yaitu, untuk setiap 4 pengukuran kecerahan terdapat 1 pengukuran warna, sehingga informasi warna didistribusikan dalam kuartal. Ini adalah cara yang baik untuk menghemat bandwidth karena mata manusia masih tidak melihat perubahan ini. Huruf Latin "P" dalam nama menunjukkan bahwa formatnya adalah "planar", yang berarti bahwa komponennya adalah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berada dalam array yang terpisah. </font><font style="vertical-align: inherit;">FFmpeg dapat mengonversi gambar ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang sangat membantu, karena banyak aliran video sudah disimpan dalam format ini atau mudah dikonversi ke dalamnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, rencana kami saat ini adalah untuk menggantikan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () dari pelajaran sebelumnya dan menampilkan bingkai kami sebagai gantinya. </font><font style="vertical-align: inherit;">Tetapi pertama-tama Anda harus berkenalan dengan fitur-fitur dasar perpustakaan SDL. </font><font style="vertical-align: inherit;">Untuk memulai, hubungkan perpustakaan dan inisialisasi SDL:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () pada dasarnya memberi tahu perpustakaan fungsi mana yang akan kita gunakan. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_GetError</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), tentu saja, ini adalah fungsi nyaman kami untuk debugging.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan tampilan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita membutuhkan tempat di layar untuk mengatur elemen. </font><font style="vertical-align: inherit;">Area utama untuk menampilkan gambar dengan SDL disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permukaan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface *screen;<font></font>
<font></font>
screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span>(!screen) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kami mengatur layar dengan lebar dan tinggi yang diberikan. </font><font style="vertical-align: inherit;">Opsi berikutnya adalah kedalaman bit layar - 0 - ini adalah nilai khusus yang berarti "sama dengan tampilan saat ini." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami membuat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overlay YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada layar ini sehingga kami dapat menampilkan video, dan mengkonfigurasi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWSContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">untuk mengonversi data gambar ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay     *bmp = <span class="hljs-literal">NULL</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SWSContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,<font></font>
                           SDL_YV12_OVERLAY, screen);<font></font>
<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
                         pCodecCtx-&gt;height,<font></font>
			 pCodecCtx-&gt;pix_fmt,<font></font>
			 pCodecCtx-&gt;width,<font></font>
			 pCodecCtx-&gt;height,<font></font>
			 PIX_FMT_YUV420P,<font></font>
			 SWS_BILINEAR,<font></font>
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>
			 );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang disebutkan, kami menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menampilkan gambar dan mendapatkan data </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari FFmpeg.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilan gambar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, itu cukup mudah! Sekarang kita hanya perlu menunjukkan gambarnya. Mari kita pergi ke tempat di mana kita memiliki tembakan selesai. Kami dapat menyingkirkan semua yang kami miliki untuk bingkai RGB dan kami akan mengganti </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () dengan kode tampilan kami. Untuk menampilkan gambar, kita akan membuat struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengatur pointer data dan ukuran garis untuknya untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overlay YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
    SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
    AVPicture pict;<font></font>
    pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
    pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya, kami memblokir overlay, karena kami berencana untuk menulisnya. Ini adalah kebiasaan yang baik sehingga nantinya tidak ada masalah. Struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti yang ditunjukkan di atas, memiliki pointer data, yang merupakan array dari 4 pointer. Karena di sini kita berurusan dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kita hanya memiliki 3 saluran dan karenanya hanya 3 set data. Format lain mungkin memiliki pointer keempat untuk saluran alpha atau yang lainnya. Ukuran garis seperti apa. Struktur serupa dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hamparan YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">adalah variabel untuk piksel dan tinggi. (Pitch, pitches - jika dinyatakan dalam SDL untuk menunjukkan lebar dari suatu baris data yang diberikan.) Jadi, kami menunjukkan tiga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array pict.data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada overlay kami, jadi ketika kami menulis dalam</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami sebenarnya merekam dalam overlay kami, yang, tentu saja, sudah memiliki ruang yang diperlukan dialokasikan khusus untuk itu. </font><font style="vertical-align: inherit;">Dengan cara yang sama, kami mendapatkan informasi ukuran garis langsung dari hamparan kami. </font><font style="vertical-align: inherit;">Kami mengubah format konversi ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIX_FMT_YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seperti sebelumnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar gambar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi kami masih perlu menentukan untuk SDL sehingga benar-benar menunjukkan data yang kami berikan kepadanya. </font><font style="vertical-align: inherit;">Kami juga meneruskan persegi panjang ke fungsi ini, yang menunjukkan ke mana film harus pergi, dengan lebar dan tinggi apa yang harus diskalakan. </font><font style="vertical-align: inherit;">Dengan demikian, SDL berskala untuk kami, dan ini dapat membantu GPU Anda untuk skala lebih cepat:</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect rect;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">/* ... code ... */</span>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
              pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang video kami ditampilkan! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita tunjukkan satu lagi fitur SDL: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistem acara</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . SDL dikonfigurasi sedemikian rupa sehingga ketika Anda memasukkan atau memindahkan mouse dalam aplikasi SDL atau mengirim sinyal ke sana, suatu peristiwa dihasilkan. Program Anda kemudian memeriksa peristiwa ini jika dimaksudkan untuk memproses input pengguna. Program Anda juga dapat membuat acara untuk mengirim acara SDL ke sistem. Ini sangat berguna untuk pemrograman multi-berulir dengan SDL, yang akan kita lihat dalam pelajaran nomor 4. Dalam program kami, kami akan memeriksa acara segera setelah pemrosesan paket. Saat ini, kami akan menangani acara </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_QUIT sehingga</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami dapat keluar:</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event       event;<font></font>
<font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kita hidup! Kami membuang semua sampah lama dan kami siap untuk dikompilasi. Jika Anda menggunakan Linux atau sesuatu seperti Linux, cara terbaik untuk mengompilasi menggunakan perpustakaan SDL adalah:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdl-config</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya menampilkan flag yang diperlukan untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agar dapat mengaktifkan pustaka SDL dengan benar. </font><font style="vertical-align: inherit;">Anda mungkin harus melakukan sesuatu yang lain untuk membuat kompilasi ini di sistem Anda; </font><font style="vertical-align: inherit;">silakan periksa dokumentasi SDL untuk sistem Anda untuk petugas pemadam kebakaran. </font><font style="vertical-align: inherit;">Setelah dikompilasi, lanjutkan dan jalankan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi ketika Anda menjalankan program ini? </font><font style="vertical-align: inherit;">Video itu sepertinya menjadi gila! </font><font style="vertical-align: inherit;">Bahkan, kami cukup menampilkan semua frame video secepat kami dapat mengekstraknya dari file film. </font><font style="vertical-align: inherit;">Kami tidak memiliki kode sekarang untuk mencari tahu kapan kami perlu menampilkan video. </font><font style="vertical-align: inherit;">Pada akhirnya (dalam pelajaran nomor 5) kita akan mulai menyinkronkan video. </font><font style="vertical-align: inherit;">Tetapi saat ini kita kehilangan sesuatu yang sama pentingnya: suara!</font></font><a name="sound"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 3: Mainkan Suara </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 2: Tampilan"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Ke daftar isi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 4: Banyak Utas"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar lengkap: tutorial03.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial03.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial03 tutorial03.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial03 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
PacketQueue audioq;<font></font>
<font></font>
<span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf, <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>; <span class="hljs-comment">// arbitrary?</span>
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream, audioStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
  <font></font>
  AVCodecContext  *aCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *aCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *aCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
  SDL_AudioSpec   wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
    <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;<font></font>
  audioStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
      videoStream=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
      audioStream=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
  <span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
   <font></font>
  aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;<font></font>
  aCodec = avcodec_find_decoder(aCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!aCodec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
  wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
  wanted_spec.format = AUDIO_S16SYS;<font></font>
  wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
  wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
  wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
  wanted_spec.callback = audio_callback;<font></font>
  wanted_spec.userdata = aCodecCtx;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  <span class="hljs-comment">// audio_st = pFormatCtx-&gt;streams[index]</span><font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);<font></font>
<font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses	</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
	<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
	av_free_packet(&amp;packet);<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
      packet_queue_put(&amp;audioq, &amp;packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(&amp;packet);<font></font>
    }<font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(aCodecCtxOrig);<font></font>
  avcodec_close(aCodecCtx);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami ingin suara diputar di aplikasi. </font><font style="vertical-align: inherit;">SDL juga memberi kami metode untuk memutar suara. </font><font style="vertical-align: inherit;">Fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () digunakan untuk membuka perangkat audio itu sendiri. </font><font style="vertical-align: inherit;">Dibutuhkan argumen struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang berisi semua informasi tentang audio yang akan kita putar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kami menunjukkan cara mengkonfigurasi ini, kami terlebih dahulu menjelaskan bagaimana komputer memproses audio secara umum. </font><font style="vertical-align: inherit;">Audio digital terdiri dari aliran </font><b><font style="vertical-align: inherit;">sampel yang</font></b><font style="vertical-align: inherit;"> panjang</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang masing-masing mewakili makna spesifik dari gelombang suara. Suara direkam pada laju sampling tertentu, yang hanya menunjukkan seberapa cepat setiap sampel dimainkan, dan diukur dengan jumlah sampel per detik. Frekuensi pengambilan sampel perkiraan adalah </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22.050</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44.100</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sampel per detik, yang merupakan kecepatan yang digunakan untuk radio dan CD. Selain itu, sebagian besar audio dapat memiliki lebih dari satu saluran untuk stereo atau surround sound, jadi, misalnya, jika sampel dalam stereo, sampel akan datang dua sekaligus. Ketika kami mendapatkan data dari file film, kami tidak tahu berapa banyak sampel yang akan kami dapatkan, tetapi FFmpeg tidak menghasilkan sampel yang rusak - ini juga berarti bahwa itu tidak akan memisahkan sampel stereo juga.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode untuk memutar audio di SDL adalah sebagai berikut. </font><font style="vertical-align: inherit;">Parameter suara dikonfigurasikan: frekuensi pengambilan sampel, jumlah saluran, dll. </font><font style="vertical-align: inherit;">Dan juga mengatur fungsi panggilan balik dan data pengguna. </font><font style="vertical-align: inherit;">Ketika kita mulai memutar suara, SDL akan terus memanggil fungsi panggilan balik ini dan memintanya untuk mengisi buffer audio dengan sejumlah byte. </font><font style="vertical-align: inherit;">Setelah kami memasukkan informasi ini ke dalam struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), yang akan membuka perangkat audio dan mengembalikan kami struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lainnya </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah karakteristik yang benar-benar akan kita gunakan - tidak ada jaminan bahwa kita akan mendapatkan apa yang kita minta!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengaturan audio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingatlah itu untuk saat ini, karena kami belum memiliki informasi tentang stream audio! </font><font style="vertical-align: inherit;">Mari kita kembali ke tempat dalam kode kita di mana kita menemukan aliran video dan mencari tahu aliran mana yang merupakan aliran audio:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;<font></font>
audioStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) {
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO<font></font>
     &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
    videoStream=i;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
     audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
    audioStream=i;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
<span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita bisa mendapatkan semua informasi yang kita inginkan dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari stream, sama seperti yang kita lakukan dengan streaming video:</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodecContext *aCodecCtxOrig;<font></font>
AVCodecContext *aCodecCtx;<font></font>
<font></font>
aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda ingat, dalam pelajaran sebelumnya, kami masih harus membuka codec audio itu sendiri. </font><font style="vertical-align: inherit;">Itu mudah:</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec         *aCodec;<font></font>
<font></font>
aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(!aCodec) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">/* set up SDL Audio here */</span><font></font>
<font></font>
avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam konteks codec berisi semua informasi yang diperlukan untuk mengonfigurasi audio kami:</font></font><br>
<br>
<pre><code class="cpp hljs">wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
wanted_spec.format = AUDIO_S16SYS;<font></font>
wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
wanted_spec.callback = audio_callback;<font></font>
wanted_spec.userdata = aCodecCtx;<font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita membahas setiap item:</font></font><br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (frekuensi): laju sampling, seperti yang dijelaskan sebelumnya.</font></font></li>
<li><b>format</b> ():  SDL ,      . «<b>S</b>»  «<b>S16SYS</b>»  «», <b>16</b> ,      16 ,  «<b>SYS</b>» ,       ,    .  ,   <b>avcodec_decode_audio2</b>   .</li>
<li><b>channels</b> ():  .</li>
<li><b>silence</b> ():  ,  .   0.</li>
<li><b>samples</b> ():    ,    ,  SDL  ,     .    -  512  8192; FFplay,  ,  1024.</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (panggilan balik): di sini kita melewati fungsi panggilan balik yang sebenarnya. </font><font style="vertical-align: inherit;">Kami akan berbicara lebih banyak tentang fungsi panggilan balik nanti.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : SDL akan memberikan callback kita sebuah pointer nol ke semua data pengguna yang kita inginkan. </font><font style="vertical-align: inherit;">Kami ingin memberi tahu dia tentang konteks codec kami; </font><font style="vertical-align: inherit;">sedikit lebih rendah akan jelas mengapa.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terakhir, buka audio dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antrian</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu perlu! Sekarang kami siap untuk mengekstrak informasi audio dari aliran. Tetapi apa yang harus dilakukan dengan informasi ini? Kami akan terus menerima paket dari file film, tetapi pada saat yang sama, SDL akan memanggil fungsi panggilan balik! Solusinya adalah dengan membuat semacam struktur global di mana kita dapat memasukkan paket audio sehingga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita </font><font style="vertical-align: inherit;">memiliki sesuatu untuk menerima data audio! Jadi, inilah yang akan kita lakukan untuk membuat antrian paket. FFmpeg bahkan memiliki struktur untuk membantu dengan ini: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang hanya daftar yang ditautkan untuk paket. Berikut adalah struktur antrian kami:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, kita harus mengindikasikan bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_packets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berbeda dalam ukuran - ukurannya mengacu pada ukuran byte yang kita dapatkan dari </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran paket-&gt;</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Perhatikan bahwa kita memiliki variabel mutex dan kondisi. </font><font style="vertical-align: inherit;">Ini karena SDL melakukan proses audio sebagai aliran terpisah. </font><font style="vertical-align: inherit;">Jika kami tidak memblokir antrian dengan benar, kami dapat merusak data kami. </font><font style="vertical-align: inherit;">Mari kita lihat bagaimana antrian diimplementasikan. </font><font style="vertical-align: inherit;">Setiap programmer yang menghargai diri sendiri harus tahu cara membuat antrian, tetapi kami juga akan menunjukkan cara melakukannya sehingga lebih mudah bagi Anda untuk mempelajari fungsi-fungsi SDL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, kami membuat fungsi untuk menginisialisasi antrian:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian buat fungsi untuk menempatkan objek dalam antrian kami:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_LockMutex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () memblokir mutex dalam antrian sehingga kami dapat menambahkan sesuatu, dan kemudian </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () mengirimkan sinyal ke fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">(jika mengharapkannya) melalui variabel kondisional kami untuk memberi tahu bahwa ada data dan dapat dilanjutkan, untuk selanjutnya membuka kunci mutex. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sesuai </font><font style="vertical-align: inherit;">. Perhatikan bagaimana </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () membuat blok fungsi (mis. Berhenti sampai kami mendapatkan data) jika kami </font><b><font style="vertical-align: inherit;">memintanya</font></b><font style="vertical-align: inherit;"> untuk melakukan ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span> </span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, kami membungkus fungsi dalam siklus abadi, jadi kami pasti akan mendapatkan beberapa data jika kami ingin memblokirnya. </font><font style="vertical-align: inherit;">Kami menghindari perulangan selamanya menggunakan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Intinya, semua yang dilakukan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah menunggu sinyal dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () (atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondBroadcast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ()) dan kemudian melanjutkan. </font><font style="vertical-align: inherit;">Namun, sepertinya kami menangkapnya dalam sebuah mutex - jika kami memegang kunci, fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">tidak dapat mengantri apa pun! </font><font style="vertical-align: inherit;">Namun, apa yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () juga lakukan untuk kita adalah membuka blokir mutex yang kita berikan, dan kemudian mencoba lagi untuk menguncinya segera setelah kami menerima sinyal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk setiap pemadam kebakaran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda juga melihat bahwa kami memiliki variabel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berhenti</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> global </font><font style="vertical-align: inherit;">yang kami periksa untuk memastikan bahwa kami tidak menetapkan sinyal keluaran dalam program (SDL secara otomatis memproses sinyal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TERM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dll.). </font><font style="vertical-align: inherit;">Jika tidak, utas akan berlanjut selamanya, dan kita harus mematikan program dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kill -9</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  SDL_PollEvent(&amp;event);
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
    quit = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan mengatur bendera keluar ke 1.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memberi makan paket</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetap hanya untuk mengkonfigurasi antrian kami:</font></font><br>
<br>
<pre><code class="cpp hljs">PacketQueue audioq;<font></font>
main() {<font></font>
...<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () akhirnya memulai unit audio. </font><font style="vertical-align: inherit;">Ini mereproduksi keheningan jika tidak menerima data; </font><font style="vertical-align: inherit;">tetapi ini tidak terjadi segera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kita memiliki antrian yang dikonfigurasi, sekarang kita siap untuk mengirim paket kepadanya. </font><font style="vertical-align: inherit;">Kami beralih ke siklus pembacaan paket kami:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
    <span class="hljs-comment">// Decode video frame</span><font></font>
    ....<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
    packet_queue_put(&amp;audioq, &amp;packet);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    av_free_packet(&amp;packet);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa kami tidak merilis paket setelah mengantri. </font><font style="vertical-align: inherit;">Kami akan merilisnya nanti ketika kami mendekripsi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengambil paket</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fungsi </font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;"> untuk mengambil paket dari antrian. </font><font style="vertical-align: inherit;">Callback akan terlihat seperti:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span></span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , adalah pointer yang kami berikan SDL, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah buffer di mana kami akan menulis data audio, dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah ukuran buffer ini. </font><font style="vertical-align: inherit;">Ini kodenya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span><font></font>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf,<font></font>
                                      <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, ini adalah loop sederhana yang mengekstraksi data dari fungsi lain yang kami tulis, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), menyimpan hasilnya dalam buffer perantara, mencoba menulis </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes ke stream dan menerima lebih banyak data jika kami masih belum memiliki cukup atau menyimpannya untuk nanti, jika kita memiliki sesuatu yang tersisa. </font><font style="vertical-align: inherit;">Ukuran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah 1,5 kali ukuran bingkai audio terbesar yang FFmpeg akan berikan kepada kami, yang memberi kami margin yang baik.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekripsi Audio Akhir</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagian dalam decoder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf,
                       <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seluruh proses sebenarnya dimulai di dekat akhir fungsi, tempat kami memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). Kami mengambil paket dari antrian dan menyimpan informasi darinya. Kemudian, ketika kita memiliki paket untuk berfungsi, kita memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_audio4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), yang sangat mirip dengan fungsi saudaranya </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), kecuali bahwa dalam kasus ini paket dapat memiliki lebih dari satu bingkai. Karena itu, Anda mungkin perlu memanggilnya beberapa kali untuk mendapatkan semua data dari paket. Setelah menerima bingkai, kami cukup menyalinnya ke buffer audio kami, memastikan bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih kecil dari buffer audio kami. Juga, ingat tentang casting </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke tipe yang benar, karena SDL memberikan buffer int 8-bit, dan FFmpeg memberi kita data dalam buffer int 16-bit. Anda juga harus mempertimbangkan perbedaan antara </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah ukuran paket yang kami gunakan, dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah jumlah data mentah yang dikembalikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami memiliki beberapa data, kami segera kembali untuk mencari tahu apakah kami perlu mendapatkan lebih banyak data dari antrian atau kami selesai. Jika kita masih perlu memproses paket, maka patuhi itu. Jika Anda telah menyelesaikan paket, maka akhirnya lepaskan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu semua! Kami memiliki audio yang ditransfer dari loop baca utama ke antrian, yang kemudian dibaca oleh fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mentransfer data ini ke SDL, dan SDL mentransfer ke kartu suara Anda. Silakan dan kompilasi:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial03 tutorial03.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gip-gip-hore! </font><font style="vertical-align: inherit;">Video masih dibawa pada kecepatan maksimum, tetapi suara sudah diputar sebagaimana mestinya. </font><font style="vertical-align: inherit;">Mengapa demikian? </font><font style="vertical-align: inherit;">Ya, karena informasi audio memiliki frekuensi pengambilan sampel - kami memompa informasi audio secepatnya, tetapi audio hanya diputar dalam aliran ini sesuai dengan frekuensi pengambilan sampelnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami hampir matang untuk sinkronisasi video dan audio, tetapi pertama-tama kita perlu melakukan reorganisasi kecil program. </font><font style="vertical-align: inherit;">Metode antrian suara dan memainkannya menggunakan aliran terpisah bekerja sangat baik: itu membuat kode lebih mudah dikelola dan lebih modular. </font><font style="vertical-align: inherit;">Sebelum kita mulai menyinkronkan video dengan audio, kita perlu menyederhanakan kodenya. </font><font style="vertical-align: inherit;">Dalam seri berikutnya kami akan menghasilkan aliran kontrol!</font></font><a name="threads"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 4: Banyak Utas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 3: Mainkan Suara"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Ke daftar isi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 5: Sinkronisasi Video"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar lengkap tutorial04.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial04.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can,</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial04 tutorial04.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Now, normally here goes a ton of code
	 about timing, etc. we're just going to
	 guess at a delay for now. You can
	 increase and decrease this value and hard code
	 the timing - but I don't suggest that ;)
	 We'll learn how to do it for real later.
      */</span>
      schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }      <font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambaran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terakhir kali, kami menambahkan dukungan audio menggunakan fitur audio SDL. </font><font style="vertical-align: inherit;">SDL meluncurkan utas membuat panggilan balik untuk fungsi yang kami tentukan setiap kali diperlukan suara. </font><font style="vertical-align: inherit;">Sekarang kita akan melakukan hal yang sama dengan tampilan video. </font><font style="vertical-align: inherit;">Ini membuat kode lebih modular dan lebih mudah digunakan - terutama jika Anda ingin menambahkan sinkronisasi. </font><font style="vertical-align: inherit;">Jadi dari mana kita mulai?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa fungsi utama kami banyak menangani: ia melewati perulangan acara, membaca paket dan menerjemahkan video. Apa yang akan kita lakukan adalah membagi semuanya menjadi beberapa bagian: kita akan memiliki aliran yang bertanggung jawab atas penguraian paket; kemudian paket-paket ini ditambahkan ke antrian dan dibaca oleh aliran audio dan video yang sesuai. Kami telah menyetel streaming audio sesuai kebutuhan; dengan streaming video akan sedikit lebih sulit, karena kami harus memastikan bahwa video ditampilkan sendiri. Kami akan menambahkan kode tampilan aktual ke loop utama. Tetapi alih-alih menampilkan video setiap kali kami menjalankan loop, kami mengintegrasikan tampilan video ke dalam loop acara. Idenya adalah untuk memecahkan kode video, simpan bingkai yang diterima dalam antrian lain, lalu buat acara Anda sendiri ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), yang kita tambahkan ke sistem acara, maka ketika loop acara kami melihat acara ini, itu akan menampilkan bingkai berikutnya dalam antrian. Berikut adalah ilustrasi ASCII yang nyaman tentang apa yang terjadi:</font></font><br>
<br>
<div style="text-align:center;"><img width="335" height="221" src="https://habrastorage.org/webt/nf/ej/gq/nfejgqoqpypds3quordh_x2qgwa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasan utama untuk memindahkan kontrol tampilan video melalui loop acara adalah bahwa dengan aliran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita dapat mengontrol dengan tepat kapan bingkai video berikutnya muncul di layar. </font><font style="vertical-align: inherit;">Ketika kami akhirnya menyinkronkan video dalam pelajaran berikutnya, cukup tambahkan kode yang akan menjadwalkan pembaruan video berikutnya sehingga gambar yang benar muncul di layar pada waktu yang tepat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhanakan kodenya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita hapus kodenya sedikit. Kami memiliki semua informasi ini tentang codec audio dan video, dan kami akan menambahkan antrian, buffer, dan Tuhan tahu apa lagi. Semua hal ini adalah untuk unit logis tertentu, yaitu - untuk film. Jadi, kami bermaksud membuat struktur besar yang berisi semua informasi ini yang disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita melihat petunjuk tentang apa yang akan kita dapatkan pada akhirnya. Pertama, kita melihat informasi dasar - konteks format dan indeks aliran audio dan video, serta objek </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sesuai </font><font style="vertical-align: inherit;">. Kemudian kita melihat bahwa beberapa buffer audio ini dipindahkan ke struktur ini. Mereka ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dll.) Dimaksudkan untuk informasi tentang audio yang masih ada (atau hilang). Kami menambahkan antrian lain untuk video dan buffer (yang akan digunakan sebagai antrian; untuk ini kami tidak memerlukan antrian yang berlebihan) untuk frame yang diterjemahkan (disimpan sebagai overlay). </font><b><font style="vertical-align: inherit;">VideoPicture</font></b><font style="vertical-align: inherit;"> Struktur</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ini adalah ciptaan kita sendiri (kita akan melihat apa yang akan ada di dalamnya ketika kita sampai di sana). Anda juga dapat melihat bahwa kami telah mengalokasikan pointer untuk dua aliran tambahan yang akan kami buat, serta bendera keluar dan nama file film. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, sekarang kita kembali ke fungsi utama untuk melihat bagaimana ini mengubah program kita. Mari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siapkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> struktur </font><b><font style="vertical-align: inherit;">VideoState</font></b><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_mallocz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () adalah fungsi yang baik yang akan mengalokasikan memori untuk kita dan nol itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kami menginisialisasi kunci kami untuk buffer tampilan ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), karena sejak loop acara memanggil fungsi tampilan kami - ingat, fungsi tampilan akan mengambil frame yang telah didekodekan dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada saat yang sama, decoder video kami akan memasukkan informasi ke dalamnya - kami tidak tahu siapa yang lebih dulu ke sana. Saya harap Anda mengerti bahwa ini adalah kondisi balapan klasik. Karena itu, kami mendistribusikannya sekarang sebelum memulai topik apa pun. Mari juga menyalin nama film kami ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
is-&gt;pictq_cond = SDL_CreateCond();</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_strlcpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah fungsi dari FFmpeg yang melakukan beberapa pemeriksaan perbatasan tambahan selain </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strncpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utas pertama kami</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari jalankan utas kami dan lakukan sesuatu yang nyata:</font></font><br>
<br>
<pre><code class="cpp hljs">schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
<span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
  av_free(is);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah fungsi yang akan kita definisikan nanti. Apa yang dia lakukan adalah memberi tahu sistem untuk menghasilkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setelah jumlah milidetik yang ditentukan. Ini, pada gilirannya, akan memanggil fungsi pembaruan video ketika kita melihatnya dalam antrian acara. Tapi sekarang mari kita lihat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () tidak hanya itu - ia memunculkan thread baru yang memiliki akses penuh ke semua memori dari proses asli, dan memulai utas yang dieksekusi oleh fungsi yang kami berikan. Fungsi ini juga akan mengirimkan data yang ditentukan pengguna. Dalam hal ini, kami memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () dan melampirkan struktur </font><b><font style="vertical-align: inherit;">VideoState</font></b><font style="vertical-align: inherit;"> kami</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tidak ada yang baru di paruh pertama fungsi; itu hanya melakukan pekerjaan membuka file dan menemukan indeks stream audio dan video. Satu-satunya hal yang kami lakukan secara berbeda adalah menjaga konteks format dalam struktur besar kami. Setelah kami menemukan indeks aliran kami, kami memanggil fungsi lain yang kami tentukan, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). Ini adalah cara yang cukup alami untuk memisahkan, dan karena kami melakukan banyak hal serupa untuk mengatur video dan audio codec, kami menggunakan kembali beberapa kode, menjadikannya fungsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">() Adalah tempat di mana kami menemukan decoder codec kami, mengonfigurasi parameter suara, menyimpan informasi penting dalam struktur besar kami dan meluncurkan stream audio dan video kami. Di sini kami juga menyisipkan parameter lain, seperti penggunaan codec secara paksa alih-alih deteksi otomatisnya, dll. Seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx;<font></font>
  AVCodec *codec;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    <span class="hljs-comment">/* ...etc... */</span><font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;pix_fmt, is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini hampir sama dengan kode yang kita miliki sebelumnya, kecuali sekarang kode ini digeneralisasi untuk audio dan video. Perhatikan bahwa alih-alih </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aCodecCtx,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami telah mengonfigurasi struktur besar kami sebagai data pengguna untuk panggilan balik audio kami. Kami juga menyimpan streaming sendiri sebagai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami juga menambahkan antrean video kami dan mengaturnya seperti antrian audio kami. Intinya adalah untuk menjalankan streaming video dan audio. Bit-bit ini melakukan ini:</font></font><br>
<br>
<pre><code class="cpp hljs">    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
<span class="hljs-comment">/* ...... */</span><font></font>
<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () dari pelajaran terakhir. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () digunakan dengan cara yang sama. Kembali ke fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum itu, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mari kita</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kembali ke bagian kedua dari fungsi </font><b><font style="vertical-align: inherit;">decode_thread</font></b><font style="vertical-align: inherit;"> () kami. Pada dasarnya, ini hanya untuk loop yang membaca paket dan meletakkannya di antrian yang tepat:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>((is-&gt;pFormatCtx-&gt;pb-&gt;error) == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada yang benar-benar baru di sini, kecuali bahwa kami sekarang memiliki ukuran maksimum untuk antrian audio dan video kami, dan kami telah menambahkan pemeriksaan kesalahan baca. Konteks format memiliki struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di dalam yang </font><font style="vertical-align: inherit;">disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah struktur yang pada dasarnya menyimpan semua informasi tentang file tingkat rendah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah loop for kami, kami memiliki semua kode untuk menunggu sisa program untuk menyelesaikan atau menginformasikannya. Kode ini bersifat instruktif karena menunjukkan bagaimana kita mendorong acara - sesuatu yang nanti kita perlukan untuk menampilkan video:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mendapatkan nilai untuk acara khusus menggunakan konstanta SDL </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Acara pengguna pertama harus disetel ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berikutnya </font><font style="vertical-align: inherit;">, dll. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_QUIT_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> didefinisikan dalam program kami sebagai </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami juga dapat meneruskan data pengguna jika perlu, dan di sini kami meneruskan pointer kami ke struktur besar. Akhirnya, kami memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PushEvent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). Di sakelar perulangan acara kami, kami hanya meletakkan ini di bagian </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_QUIT_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang kita miliki sebelumnya. </font><font style="vertical-align: inherit;">Kami akan melihat siklus acara kami secara lebih rinci; </font><font style="vertical-align: inherit;">untuk saat ini, pastikan saja ketika kita </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menekan FF_QUIT_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita menangkapnya nanti dan mengganti flag keluar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima bingkai: video_thread</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menyiapkan codec, Anda dapat memulai streaming video. </font><font style="vertical-align: inherit;">Aliran ini membaca paket dari antrian video, menerjemahkan video ke dalam bingkai, dan kemudian memanggil fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menempatkan bingkai yang diproses dalam antrian gambar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_free(pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar fungsi ini harus dipahami sekarang. </font><font style="vertical-align: inherit;">Kami baru saja menyalin fungsi avcodec_decode_video2 di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cukup mengganti beberapa argumen; </font><font style="vertical-align: inherit;">misalnya, kami memiliki </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tersimpan di struktur besar kami, jadi kami mendapatkan codec kami dari sana. </font><font style="vertical-align: inherit;">Kami hanya terus menerima paket dari antrean video kami sampai seseorang memberitahu kami untuk keluar atau kami menemukan kesalahan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bingkai antrian</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat fungsi yang menyimpan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFrame yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di- </font><font style="vertical-align: inherit;">decode </font><font style="vertical-align: inherit;">dalam antrian gambar kita. Karena antrian gambar kita adalah overlay SDL (mungkin untuk memungkinkan fungsi tampilan video untuk melakukan komputasi sesedikit mungkin), kita perlu mengkonversi frame kita ke dalamnya. Data yang kami simpan di antrian gambar adalah struktur yang kami buat:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur besar kami berisi buffer file-file ini, tempat kami dapat menyimpannya. </font><font style="vertical-align: inherit;">Namun, kami perlu mendistribusikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sendiri (perhatikan flag yang diberikan, yang menunjukkan apakah kami melakukannya atau tidak). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggunakan antrian ini, kami memiliki dua petunjuk - indeks tulis dan indeks baca. </font><font style="vertical-align: inherit;">Kami juga melacak berapa banyak gambar aktual di buffer. </font><font style="vertical-align: inherit;">Untuk menulis ke antrean, pertama-tama kita tunggu hingga buffer kita dihapus, sehingga kita punya tempat untuk menyimpan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lalu kami memeriksa untuk melihat apakah kami menetapkan overlay dalam indeks rekaman kami? </font><font style="vertical-align: inherit;">Jika tidak, Anda perlu mengalokasikan memori. </font><font style="vertical-align: inherit;">Kami juga harus merealokasi buffer jika ukuran jendela telah berubah!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_st-&gt;codec-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_st-&gt;codec-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alokasi_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ():</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
  vp-&gt;width = is-&gt;video_st-&gt;codec-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_st-&gt;codec-&gt;height;  <font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda harus mengenali fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateYUVOverlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang telah kami pindahkan dari loop utama kami ke bagian ini. Kode ini seharusnya sudah cukup jelas sekarang. Namun, sekarang kami memiliki kunci mutex, karena dua utas tidak dapat secara bersamaan menulis informasi ke layar! Ini tidak akan mengizinkan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alokasi_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">mengganggu fungsi lain yang akan menampilkan gambar. (Kami membuat kunci ini sebagai variabel global dan menginisialisasi di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (); lihat kode.) Ingatlah bahwa kami menjaga lebar dan tinggi dalam struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena kami perlu memastikan bahwa ukuran video kami tidak berubah karena alasan tertentu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oke, kami sudah menyelesaikannya, dan kami memiliki </font><b><font style="vertical-align: inherit;">YUV</font></b><font style="vertical-align: inherit;"> overlay kami</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, berdedikasi dan siap menerima gambar. Mari kita kembali ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan melihat kode untuk menyalin bingkai ke overlay. Bagian ini harus familier bagi Anda:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* Allocate a frame if we need it... */</span>
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, sebagian besar hanya kode yang kami gunakan sebelumnya untuk mengisi overlay </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font><font style="vertical-align: inherit;">bingkai kami. </font><font style="vertical-align: inherit;">Bit terakhir hanya "menambahkan" nilai kami ke antrian. </font><font style="vertical-align: inherit;">Antrian berfungsi, nilai ditambahkan ke dalamnya sampai penuh, dan pembacaan dari itu terjadi saat setidaknya ada sesuatu di dalamnya. </font><font style="vertical-align: inherit;">Karena itu, semuanya tergantung pada nilai </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq_size</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang mengharuskan kita untuk memblokirnya. </font><font style="vertical-align: inherit;">Jadi, apa yang kita lakukan di sini: tingkatkan penunjuk catatan (dan jika perlu, mulai lagi dari awal), lalu blokir antrean dan tambah ukurannya. </font><font style="vertical-align: inherit;">Sekarang pembaca kita akan tahu bahwa ada lebih banyak informasi tentang antrian, dan jika ini membuat antrian kita penuh, dan perekam kita akan mengetahuinya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilan video</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu semua untuk utas video kami! Sekarang kita telah menyelesaikan semua utas gratis, kecuali satu - ingat bagaimana kita memanggil fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">dulu </font><font style="vertical-align: inherit;">? Lihatlah apa yang sebenarnya terjadi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AddTimer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () adalah fungsi SDL yang hanya melakukan panggilan balik ke fungsi yang ditentukan pengguna setelah beberapa milidetik (dan, jika perlu, mentransfer beberapa data yang ditentukan pengguna). Kami akan menggunakan fungsi ini untuk menjadwalkan pembaruan video - setiap kali kami menyebutnya, ia menetapkan timer yang akan memicu suatu peristiwa, yang, pada gilirannya, akan menyebabkan </font><font style="vertical-align: inherit;">fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">() memanggil fungsi yang mengekstrak bingkai dari gambar antrian kami dan menampilkan nya! Fiuh! Tiga "yang / mana / yang" dalam satu kalimat! Jadi, mari kita lakukan hal pertama yang harus dilakukan - jalankan acara ini. Ini mengirim kami ke:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acara ini diluncurkan oleh teman lama kami. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> didefinisikan di sini sebagai </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Perlu dicatat bahwa ketika kita mengembalikan 0, SDL menghentikan timer, sehingga panggilan balik tidak dieksekusi lagi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami telah memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lagi </font><font style="vertical-align: inherit;">, kami perlu memprosesnya dalam loop acara kami:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
  SDL_WaitEvent(&amp;event);<font></font>
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
    video_refresh_timer(event.user.data1);<font></font>
    <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
apa yang mengirim kami ke sini ke fungsi ini, yang sebenarnya mengekstrak data dari antrian gambar kami:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Timing code goes here */</span><font></font>
<font></font>
      schedule_refresh(is, <span class="hljs-number">80</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, fungsi ini cukup sederhana: ia memproses antrian sementara kami memiliki sesuatu, mengatur timer untuk menampilkan bingkai video berikutnya, memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk benar-benar menampilkan video di layar, kemudian meningkatkan penghitung pada antrian, sambil mengurangi ukurannya. Anda mungkin memperhatikan bahwa kami tidak benar-benar melakukan apa pun dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam fungsi ini, dan inilah alasannya: ini ada di depan. Tetapi sedikit kemudian. Kami akan menggunakannya untuk mengakses informasi waktu ketika kami mulai menyinkronkan video dengan audio. Di sini, lihat tempat di kode di mana komentar "Kode waktu di sini" ditulis. Di bagian ini kita akan mengetahui seberapa cepat kita harus menunjukkan bingkai video berikutnya, dan kemudian masukkan nilai ini dalam fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(). Saat ini, kami hanya memasukkan nilai fiktif 80. Secara teknis, Anda dapat menebak dan memeriksa nilai ini dan mengkompilasi ulang untuk setiap film, tetapi: 1) itu akan mulai melambat setelah beberapa saat dan 2) itu cukup bodoh. Meskipun, di masa depan kami akan kembali ke titik ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami hampir selesai. Hanya ada satu hal yang harus dilakukan: tampilkan videonya! Inilah fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_st-&gt;codec-&gt;width / is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena layar dapat memiliki ukuran berapa pun (kami memasang 640x480, dan ada beberapa cara untuk menyesuaikannya sehingga pengguna dapat mengubah ukuran), Anda perlu secara dinamis menentukan seberapa besar area persegi panjang seharusnya untuk film kami. Jadi, pertama-tama Anda perlu mengetahui aspek rasio film kami, hanya lebarnya dibagi dengan tinggi. Beberapa codec akan memiliki rasio aspek yang aneh dari sampel, yang hanya lebar / tinggi satu piksel atau sampel. Karena nilai tinggi dan lebar dalam konteks codec kami diukur dalam piksel, rasio aspek aktual sama dengan rasio aspek dikalikan dengan rasio aspek untuk sampel. Beberapa codec akan menampilkan rasio aspek 0, yang berarti bahwa setiap piksel hanya memiliki ukuran 1x1. Lalu kami membuat skala film sedemikian rupasehingga pas di layar sebanyak mungkin. Pembalikan bit</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp; -3</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya membulatkan nilainya ke kelipatan empat terdekat. </font><font style="vertical-align: inherit;">Kemudian</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pusatkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> film dan panggil</font><b><font style="vertical-align: inherit;"> SDL_DisplayYUVOverlay</font></b><font style="vertical-align: inherit;"> () untuk memastikan bahwa mutex layar digunakan untuk mengaksesnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu semua? </font><font style="vertical-align: inherit;">Sudahkah kita selesai? </font><font style="vertical-align: inherit;">Anda masih perlu menulis ulang</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> audio untuk menggunakan</font><b><font style="vertical-align: inherit;"> VideoStruct</font></b><font style="vertical-align: inherit;"> baru</font><font style="vertical-align: inherit;">, tetapi ini adalah perubahan sepele yang dapat dilihat pada kode sampel. </font><font style="vertical-align: inherit;">Hal terakhir yang perlu kita lakukan adalah mengubah panggilan balik kita untuk fungsi panggilan balik keluar internal di FFmpeg:</font></font><br>
<br>
<pre><code class="cpp hljs">VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_interrupt_cb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">return</span> (global_video_state &amp;&amp; global_video_state-&gt;quit);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Set </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global_video_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke struktur besar di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi begitu! </font><font style="vertical-align: inherit;">Kami mengkompilasi:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial04 tutorial04.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan nikmati filmnya tanpa sinkronisasi! </font><font style="vertical-align: inherit;">Pada langkah selanjutnya, kita akhirnya akan membuat </font><font style="vertical-align: inherit;">pemutar video yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><i><font style="vertical-align: inherit;">benar berfungsi</font></i><font style="vertical-align: inherit;"> !</font></font><a name="video"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran 5: Sinkronisasi Video </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 4: Banyak Utas"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Ke daftar isi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Pelajaran 5: Sinkronisasi Audio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar lengkap tutorial05.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;  
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PERINGATAN</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika saya baru saja menulis panduan ini, semua kode sinkronisasi saya diambil dari versi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ffplay.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hari ini adalah program yang sama sekali berbeda, dan pembaruan di perpustakaan FFmpeg (dan di ffplay.c sendiri) telah menyebabkan perubahan mendasar. </font><font style="vertical-align: inherit;">Meskipun kode ini masih berfungsi, sudah usang, dan ada banyak perbaikan lain yang bisa digunakan dalam panduan ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana video disinkronkan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sampai sekarang, kami memiliki pemutar film yang hampir tidak berguna. </font><font style="vertical-align: inherit;">Ya, itu memutar video, dan ya, itu memutar audio, tapi itu tidak cukup seperti yang kita sebut film. </font><font style="vertical-align: inherit;">Jadi apa yang kita lakukan?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS dan DTS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, streaming audio dan video berisi informasi tentang seberapa cepat dan pada titik kapan mereka harus diputar. Streaming audio memiliki laju pengambilan sampel, dan streaming video memiliki bingkai per detik. Namun, jika kami hanya menyinkronkan video dengan menghitung jumlah frame dan mengalikannya dengan frame rate, ada kemungkinan besar video itu tidak disinkronkan dengan suara. Karena itu, kita akan pergi ke arah lain. Paket dari sungai dapat memiliki apa yang disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decoding waktu </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">cap</font></i><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dari </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ecoding </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ime </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memadatkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waktu presentasi </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">cap</font></i><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dari </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resentation </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ime </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Untuk memahami kedua arti ini, Anda perlu tahu bagaimana film disimpan. Beberapa format, seperti MPEG, menggunakan apa yang mereka sebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bed dan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dua arah, Inggris. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidirectional</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dua jenis lain dari frame disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I-frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P-frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internal yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berarti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diprediksi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redicted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I-frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi gambar penuh. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bingkai P.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tergantung pada I-dan P-frame sebelumnya dan berbeda dari frame sebelumnya, atau Anda juga dapat memberi nama - delta. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mirip dengan P-frame, tetapi tergantung pada informasi yang terkandung dalam frame sebelumnya dan berikutnya! Fakta bahwa suatu bingkai mungkin tidak mengandung gambar itu sendiri, tetapi perbedaan dengan bingkai lainnya - menjelaskan mengapa kita mungkin tidak memiliki bingkai yang selesai setelah memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah kita memiliki film di mana 4 frame dalam urutan ini: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IBBP</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kemudian kita perlu mencari tahu informasi dari frame-P terakhir sebelum kita dapat menampilkan salah satu dari dua frame-B sebelumnya. Karena itu, frame dapat disimpan dalam urutan yang tidak sesuai dengan urutan tampilan aktual: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPBB</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Itulah tujuan cap waktu pengodean dan waktu presentasi untuk setiap frame. Cap waktu pengodean memberi tahu kami kapan kami harus memecahkan kode sesuatu, dan cap waktu presentasi memberitahu kami kapan kami perlu menampilkan sesuatu. Jadi, dalam hal ini, streaming kami mungkin terlihat seperti ini: </font></font><br>
<br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 4 2 3 </font></font><br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 2 3 4 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPBB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai aturan, PTS dan DTS hanya berbeda ketika streaming yang dimainkan mengandung B-frame. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami menerima paket dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), itu berisi nilai PTS dan DTS untuk informasi yang ada di dalam paket. Tetapi yang benar-benar kita butuhkan adalah PTS dari kerangka mentah yang baru diterjemahkan, dalam hal ini kita tahu kapan itu perlu ditampilkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, FFmpeg memberi kita "cap waktu terbaik" yang bisa kita peroleh dengan menggunakan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_frame_get_best_effort_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ().</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinkronisasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar frame ditampilkan pada gilirannya, alangkah baiknya jika tahu kapan harus menampilkan frame video tertentu. </font><font style="vertical-align: inherit;">Tetapi bagaimana tepatnya kita melakukannya? </font><font style="vertical-align: inherit;">Idenya adalah ini: setelah kami menunjukkan bingkai, kami mencari tahu kapan bingkai berikutnya harus ditampilkan. </font><font style="vertical-align: inherit;">Kemudian cukup jeda, setelah itu kami memperbarui video setelah periode waktu ini. </font><font style="vertical-align: inherit;">Seperti yang diharapkan, kami memeriksa nilai PTS dari frame berikutnya pada jam sistem untuk melihat berapa lama waktu tunggu kami. </font><font style="vertical-align: inherit;">Pendekatan ini berhasil, tetapi ada dua masalah yang perlu diatasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, pertanyaannya adalah, kapan PTS berikutnya? Anda akan mengatakan bahwa Anda cukup menambahkan frekuensi video ke PTS saat ini - dan pada prinsipnya Anda akan benar. Namun, beberapa jenis video akan membutuhkan bingkai berulang. Ini berarti Anda harus mengulang bingkai saat ini beberapa kali. Ini dapat menyebabkan program untuk menampilkan frame berikutnya terlalu cepat. Ini harus diperhitungkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah kedua adalah bahwa, dalam program yang kami tulis saat ini, video dan audio dengan senang hati bergerak maju sampai mereka bersusah payah menyinkronkan sama sekali. </font><font style="vertical-align: inherit;">Kita tidak perlu khawatir tentang itu jika semuanya dengan sendirinya bekerja dengan sempurna. </font><font style="vertical-align: inherit;">Tetapi komputer Anda tidak sempurna, seperti banyak file video. </font><font style="vertical-align: inherit;">Jadi, kami memiliki tiga opsi: menyinkronkan audio dengan video, menyinkronkan video dengan audio atau menyinkronkan audio dan video dengan jam eksternal (misalnya, dengan komputer Anda). </font><font style="vertical-align: inherit;">Sekarang kita akan menyinkronkan video dengan audio.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengodean: menerima bingkai PTS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita menulis sesuatu secara langsung. Kita perlu menambahkan beberapa bagian lagi ke struktur besar kita, dan kita akan melakukannya dengan cara yang kita butuhkan. Pertama, mari kita lihat utas video kami. Ingat bahwa di sini kami mengumpulkan paket-paket yang telah diantri oleh aliran decoding kami? Di bagian kode ini, kita perlu mendapatkan PTS untuk kerangka yang diberikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kepada </font><b><font style="vertical-align: inherit;">kita</font></b><font style="vertical-align: inherit;"> . Cara pertama yang kita bicarakan adalah mendapatkan DTS dari paket yang diproses terakhir, yang cukup sederhana:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// Decode video frame</span><font></font>
    len1 = avcodec_decode_video2(is-&gt;video_st-&gt;codec,<font></font>
                                pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-keyword">if</span>(packet-&gt;dts != AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menetapkan PTS ke nol jika kami tidak dapat menentukan nilainya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, itu mudah. Catatan teknis: seperti yang Anda lihat, kami menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk PTS. Ini karena PTS disimpan sebagai integer. Nilai ini adalah cap waktu yang sesuai dengan dimensi waktu di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timebb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Misalnya, jika streaming memiliki 24 frame per detik, PTS dari 42 akan menunjukkan bahwa frame harus digunakan di mana frame 42 seharusnya, asalkan kita memiliki frame diganti setiap 1/24 detik (tentu saja, ini tidak akan selalu begitu faktanya). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami dapat mengonversi nilai ini ke detik dengan membaginya dengan frame rate. Nilai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">streaming akan sama dengan 1 dibagi dengan frame rate (untuk konten dengan frame rate tetap), oleh karena itu, untuk mendapatkan PTS dalam hitungan detik, kami mengalikannya dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode selanjutnya: sinkronisasi dan penggunaan PTS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi sekarang kita memiliki semua PTS yang sudah jadi. </font><font style="vertical-align: inherit;">Sekarang kita akan menangani dua masalah sinkronisasi yang dibahas sedikit lebih tinggi. </font><font style="vertical-align: inherit;">Kami akan mendefinisikan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syncize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang akan memperbarui PTS untuk disinkronkan dengan semuanya. </font><font style="vertical-align: inherit;">Fungsi ini, akhirnya, juga akan menangani kasus-kasus di mana kita tidak mendapatkan nilai PTS untuk bingkai kita. </font><font style="vertical-align: inherit;">Pada saat yang sama, kita perlu melacak kapan frame berikutnya diharapkan sehingga kita dapat mengatur kecepatan refresh dengan benar. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini menggunakan nilai jam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> internal </font><font style="vertical-align: inherit;">, yang melacak berapa banyak waktu yang telah berlalu untuk video. </font><font style="vertical-align: inherit;">Kami menambahkan nilai ini ke struktur besar kami:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span>
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">// pts of last decoded frame / predicted pts of next decoded frame</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syncize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang cukup jelas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, kami memperhitungkan frame berulang dalam fungsi ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, mari kita dapatkan PTS kita yang benar dan antri bingkai menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan menambahkan argumen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu-satunya hal yang berubah dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah bahwa kami menyimpan nilai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">dalam struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang kami antri. </font><font style="vertical-align: inherit;">Jadi, kita harus menambahkan variabel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke struktur dan menambahkan baris kode ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  ...<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
  ... stuff ...<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
    ... convert picture ...<font></font>
    vp-&gt;pts = pts;<font></font>
    ... alert <span class="hljs-built_in">queue</span> ...<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi sekarang kita memiliki gambar yang di-antri dengan nilai PTS yang benar, jadi mari kita lihat fitur pembaruan video kami. Anda dapat mengingat dari pelajaran terakhir bahwa kami hanya memalsukannya dan menginstal pembaruan 80 ms. Nah, sekarang kita akan mencari tahu apa yang seharusnya ada di sana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strategi kami adalah untuk memprediksi waktu PTS berikutnya dengan hanya mengukur waktu antara </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat ini </font><font style="vertical-align: inherit;">dan yang sebelumnya. Pada saat yang sama, kita perlu menyinkronkan video dengan audio. Kami akan membuat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jam audio.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Nilai internal yang melacak posisi audio yang kami putar. Ini seperti pembacaan digital pada pemutar mp3 mana pun. Karena kami menyinkronkan video dengan suara, aliran video menggunakan nilai ini untuk mencari tahu apakah itu terlalu jauh di depan atau terlalu jauh di belakang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan kembali ke implementasi nanti; Sekarang mari kita asumsikan bahwa kita memiliki fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang akan memberi kita waktu pada jam audio. Segera setelah kami mendapatkan nilai ini, apa yang perlu dilakukan jika video dan audio tidak disinkronkan? Akan bodoh jika mencoba melompat ke paket yang tepat melalui pencarian atau sesuatu yang lain. Sebagai gantinya, kami hanya menyesuaikan nilai yang kami hitung untuk pembaruan berikutnya: jika PTS terlalu jauh di belakang waktu audio, kami menggandakan perkiraan keterlambatan kami. Jika PTS terlalu jauh dari waktu bermain, kami hanya memperbarui secepat mungkin. Sekarang kita memiliki pembaruan atau waktu tunda yang terkonfigurasi, kita akan membandingkannya dengan jam komputer kita, membiarkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berjalan </font><font style="vertical-align: inherit;">. Pengatur waktu bingkai ini merangkum semua perkiraan keterlambatan kami selama pemutaran film. Dengan kata lain, </font><b><font style="vertical-align: inherit;">frame_timer</font></b><font style="vertical-align: inherit;"> ini</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah waktu yang menunjukkan kapan akan menampilkan bingkai berikutnya. Kami cukup menambahkan penundaan baru ke pengatur waktu bingkai, membandingkannya dengan waktu pada jam komputer kami, dan menggunakan nilai ini untuk merencanakan pembaruan berikutnya. Ini bisa sedikit membingungkan, jadi baca kodenya dengan cermat:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melakukan beberapa pemeriksaan: pertama, kami memastikan bahwa penundaan antara PTS saat ini dan PTS sebelumnya masuk akal. Jika tidak perlu menunda, maka audio dan video hanya bertepatan pada titik ini dan cukup gunakan penundaan terakhir. Kemudian kami memastikan bahwa ambang sinkronisasi dipenuhi, karena sinkronisasi sempurna tidak pernah terjadi. FFplay menggunakan nilai 0,01 untuk ambang. Kami juga memastikan bahwa ambang sinkronisasi tidak pernah kurang dari interval antara nilai PTS. Akhirnya, tetapkan nilai pembaruan minimum menjadi 10 milidetik (memang, sepertinya mereka harus melewatkan frame di sini, tapi jangan khawatir tentang itu).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menambahkan banyak variabel ke struktur besar, jadi jangan lupa untuk memeriksa kode. </font><font style="vertical-align: inherit;">Juga, jangan lupa untuk menginisialisasi timer bingkai dan penundaan awal dari frame sebelumnya di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinkronkan: jam audio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Waktunya telah tiba untuk mewujudkan jam audio. </font><font style="vertical-align: inherit;">Kami dapat memperbarui waktu dalam fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">, tempat kami mendekode audio. </font><font style="vertical-align: inherit;">Sekarang ingat bahwa kami tidak selalu memproses paket baru setiap kali kami memanggil fungsi ini, jadi ada dua area di mana Anda perlu memperbarui jam. </font><font style="vertical-align: inherit;">Tempat pertama adalah tempat kami mendapatkan paket baru: cukup instal jam suara pada paket PTS. </font><font style="vertical-align: inherit;">Kemudian, jika paket memiliki beberapa bingkai, kami menghemat waktu pemutaran audio dengan menghitung jumlah sampel dan mengalikannya dengan frekuensi sampling yang diberikan per detik. </font><font style="vertical-align: inherit;">Jadi, ketika kita memiliki paket:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan segera setelah kami memproses paket:</font></font><br>
<br>
<pre><code class="cpp hljs">      <span class="hljs-comment">/* Keep audio_clock up-to-date */</span><font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_st-&gt;codec-&gt;sample_rate);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa nuansa minor: templat fungsi telah diubah dan sekarang menyertakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jadi pastikan untuk mengubahnya. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah pointer yang kami gunakan untuk memberi tahu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> paket audio </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan digunakan lain kali untuk menyinkronkan audio dengan video. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akhirnya dapat mengimplementasikan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hal ini tidak sesederhana mendapatkan nilai </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_clock</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jika Anda berpikir tentang hal itu. </font><font style="vertical-align: inherit;">Harap perhatikan bahwa kami mengatur audio PTS setiap kali kami memprosesnya, tetapi jika Anda melihat fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, akan butuh waktu untuk memindahkan semua data dari paket audio kami ke buffer output kami. </font><font style="vertical-align: inherit;">Ini berarti bahwa nilai dalam jam audio kami mungkin terlalu jauh ke depan. </font><font style="vertical-align: inherit;">Karena itu, kita perlu memeriksa seberapa banyak kita harus menulis. </font><font style="vertical-align: inherit;">Ini kode lengkapnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_st-&gt;codec-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_st-&gt;codec-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda sekarang harus mengerti mengapa fungsi ini bekerja;) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, itu dia! </font><font style="vertical-align: inherit;">Kami mengkompilasi:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial05 tutorial05.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terjadi! </font><font style="vertical-align: inherit;">Anda dapat menonton film di pemutar buatan sendiri. </font><font style="vertical-align: inherit;">Dalam pelajaran berikutnya, kita akan melihat sinkronisasi audio, dan kemudian belajar cara mencari.</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panduan FFmpeg dan SDL atau Cara Menulis Video Player dalam Kurang dari 1000 Baris - Bagian 2</font></font></a></h3><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terjemahan di Blog Edison:</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/fr/yz/q7/fryzq72v0ik0irt2q4orchflxvs.jpeg"></a></td>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/jv/3k/-f/jv3k-f5vi9drztohsh-e0t-puru.jpeg"></a></td>
</tr>
<tr>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50 waralaba game terbaik </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dengan lebih dari satu miliar pendapatan</font></font></a></th>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akankah Airbnb selamat dari coronavirus? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[spoiler: ya]</font></font></a></th>
</tr>
</tbody></table></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id500386/index.html">Mengadaptasi solusi bisnis Anda yang sudah ada untuk SwiftUI. Bagian 2</a></li>
<li><a href="../id500390/index.html">Model aktualisasi lokalisasi bahasa di bidang IT dan komunikasi digital. Bagian 1</a></li>
<li><a href="../id500396/index.html">Masalah sistem kontrol akses otonom - Di mana mereka tidak mengharapkan</a></li>
<li><a href="../id500398/index.html">Remote Marathon Week 3: Proses Tidak Aktif</a></li>
<li><a href="../id500400/index.html">Trimming Threads: Bermigrasi dari Puppet Enterprise ke Ansible Tower. Bagian 1</a></li>
<li><a href="../id500404/index.html">Cara berteman dengan Electron dan Webix. Bagian 2. Buat aplikasi dengan Tampilan Anda</a></li>
<li><a href="../id500406/index.html">Kisah Paralisis Pertama Internet: Kutukan dari Sinyal Sibuk</a></li>
<li><a href="../id500408/index.html">Kebahagiaan dalam kemiskinan</a></li>
<li><a href="../id500410/index.html">Menciptakan serangan balik *</a></li>
<li><a href="../id500414/index.html">Mesin 3D CNC atau semuanya sudah dilakukan sebelum kita</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>