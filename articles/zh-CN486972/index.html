<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👡 💃🏿 👨🏼‍🔧 使用查找派生示例的C＃中的表达式树（表达式树访问者与模式匹配） 👨‍👨‍👧 💦 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="美好的一天。表达式树，尤其是与Visitor模式结合使用时，一直是一个令人困惑的话题。因此，有关此主题的信息越丰富，示例越多，那些有兴趣的人将更容易找到对他们而言清晰而有用的内容。
 
 
 
 这篇文章照常构建-从概念框架和定义开始，以示例和使用方式结束。目录如下。
 
 表达式树的基本知识表达式...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用查找派生示例的C＃中的表达式树（表达式树访问者与模式匹配）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486972/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">美好的一天。</font><font style="vertical-align: inherit;">表达式树，尤其是与Visitor模式结合使用时，一直是一个令人困惑的话题。</font><font style="vertical-align: inherit;">因此，有关此主题的信息越丰富，示例越多，那些有兴趣的人将更容易找到对他们而言清晰而有用的内容。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/6c/bf/xt6cbf1-gfkv4-64zs250n_-7pa.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章照常构建-从概念框架和定义开始，以示例和使用方式结束。</font><font style="vertical-align: inherit;">目录如下。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式树的基本知识表达式树的</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法表达式</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式匹配</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天真的来访者</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经典来访者</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
嗯，目标不是强加特定的解决方案，也不是说一种解决方案比另一种更好。</font><font style="vertical-align: inherit;">考虑到您案件中的所有细微差别，我建议自己得出结论。</font><font style="vertical-align: inherit;">我将以我的榜样发表意见。</font></font><br>
<br>
<a name="basic"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达树</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，您需要处理表达式树。它们表示Expression的类型或其任何继承人（稍后将讨论它们）。在通常情况下，表达式/算法以可执行代码/指令的形式呈现，而用户可能没有太多要做（主要是执行）。 Expression类型允许您将表达式/算法（通常为lambda，但不是必需的）表示为以用户可以访问的树结构组织的数据。以树状方式组织有关算法和类名称的信息的方式为我们提供了“表达式树”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了清楚起见，我们将分析一个简单的示例。假设我们有lambda </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x）=&gt; Console.WriteLine（x + 5）</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这可以表示为以下树</font></font><br>
<br>
<div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/yv/wy/sq/yvwysqugbtttw-gvz07tipuq-oy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
树的根是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodCall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的顶部，</font><font style="vertical-align: inherit;">方法的参数也是表达式，因此它可以具有任意数量的子代。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的例子中，只有一个后代-“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArithmeticOperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">的峰值</font><font style="vertical-align: inherit;">。它包含有关它是哪种操作的信息，左右操作数也是表达式。这样的顶点将始终具有2个后代。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操作数由常量（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和参数（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）表示。这样的表达没有后代。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些是非常简化的示例，但充分体现了本质。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表达式树的主要特征是可以对其进行解析，并读取有关算法应执行的所有必要信息。从某些角度来看，这与属性相反。属性是对行为进行声明式描述的一种手段（非常有条件，但最终目标大致相同）。而表达式树正在使用函数/算法来描述数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，它们在</font><font style="vertical-align: inherit;">实体框架</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供程序中使用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该应用程序很明显-解析表达式树，了解在那里应该执行的操作，并根据此描述制作</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。鲜为人知的例子是用于moking的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">。表达式树也用于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DLR。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（动态语言运行时）。</font><font style="vertical-align: inherit;">编译器开发人员使用它们来确保动态特性和dotnet之间的兼容性，而不是生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSIL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还值得一提的是，表达式树是不可变的。</font></font><br>
<a name="syn"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">句法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来值得讨论的是语法。</font><font style="vertical-align: inherit;">有两种主要方法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过Expression类的静态方法创建表达式树</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用在Expression中编译的Lambda表达式</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式类的静态方法</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过Expression类的静态方法创建表达式树的使用较少（尤其是从用户的角度来看）。这很麻烦，但很简单，我们有</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多基本的积木可供使用，您可以用它们来构建相当复杂的</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
东西。创建是通过静态方法进行的，因为表达式构造器有一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修饰符</font><font style="vertical-align: inherit;">。但这并不意味着您需要发现反射。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我将从上面的示例创建一个表达式：</font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x）=&gt; Console.WriteLine（x + 5）</font></font></i></b><br>
<br>
<pre><code class="cs hljs">ParameterExpression parameter = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
ConstantExpression constant = Expression.Constant(<span class="hljs-number">5</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
BinaryExpression <span class="hljs-keyword">add</span> = Expression.Add(parameter, constant);<font></font>
MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });<font></font>
MethodCallExpression methodCall = Expression.Call(<span class="hljs-literal">null</span>, writeLine, <span class="hljs-keyword">add</span>);<font></font>
Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; expressionlambda = Expression.Lambda&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt;(methodCall, parameter);<font></font>
Action&lt;<span class="hljs-keyword">double</span>&gt; delegateLambda = expressionlambda.Compile();<font></font>
delegateLambda(<span class="hljs-number">123321</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这可能不是很方便的方法，但是它完全反映了表达式树的内部结构。</font><font style="vertical-align: inherit;">另外，此方法提供了更多的功能和可在表达式树中使用的功能：从循环，条件，try-catch，goto，赋值，以故障块结尾，调试信息，断点，动态等。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lambda表达式</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用lambda作为表达式是一种更常见的方法。</font><font style="vertical-align: inherit;">它的工作非常简单-编译阶段的智能编译器查看lambda的用途。</font><font style="vertical-align: inherit;">并将其编译为委托或表达式。</font><font style="vertical-align: inherit;">在一个已经掌握的示例中，它看起来如下</font></font><br>
<br>
<pre><code class="cs hljs">Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; write =  =&gt; Console.WriteLine( + <span class="hljs-number">5</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得澄清这样的事情-表达式是详尽的描述。</font><font style="vertical-align: inherit;">这足以</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
获得结果。</font><font style="vertical-align: inherit;">诸如LambdaExpression或其后代之类的表达式树可以</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转换为可执行IL。</font><font style="vertical-align: inherit;">其余类型不能直接转换为可执行代码（但这没有多大意义）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，如果有人批评快速编译表达式，可以看看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三方项目。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相反，在一般情况下是不正确的。</font><font style="vertical-align: inherit;">代表不能只是拿起它并以表达方式介绍自己（但这仍然是可能的）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并非所有的lambda都可以转换为表达式树。</font><font style="vertical-align: inherit;">这些包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含赋值运算符</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态贡献</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带身体（大括号）</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">double</span> variable;
<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">dynamic</span>;<font></font>
Expression&lt;Action&gt; assignment = () =&gt; variable = <span class="hljs-number">5</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain an assignment operator</span>
Expression&lt;Func&lt;<span class="hljs-keyword">double</span>&gt;&gt; dynamically = () =&gt; <span class="hljs-keyword">dynamic</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain a dynamic operation</span>
Expression&lt;Func&lt;Task&gt;&gt; asynchon = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> Task.CompletedTask; <span class="hljs-comment">//Compiler error: Async lambda cannot be converted to expresiion trees</span>
Expression&lt;Action&gt; body = () =&gt; { }; <span class="hljs-comment">//Compiler error: A lambda expression with a statement body cannot be converted to an expression tree</span>
</code></pre> <br>
<a name="types"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式类型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我建议快速浏览可用的类型，以表示我们拥有的机会。</font><font style="vertical-align: inherit;">所有这些都位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Linq.Expressions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命名空间中，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我建议您先熟悉一些真正有趣且不寻常的功能。</font><font style="vertical-align: inherit;">我将在平板电脑中放在一起的简单类型的表达式进行简要说明。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用DynamicExpression，可以在表达式树中使用动态及其所有功能。</font><font style="vertical-align: inherit;">有一个相当混乱的API，我在本示例中使用的时间比在所有其他示例中使用的时间更长。</font><font style="vertical-align: inherit;">所有的困惑都是由一堆各种各样的标志提供的。</font><font style="vertical-align: inherit;">其中一些与您要寻找的类似，但不一定。</font><font style="vertical-align: inherit;">当使用动态表达式树时，很难说出一个错误。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> parameter1 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name1"</span>);
<span class="hljs-keyword">var</span> parameter2 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name2"</span>); 
<span class="hljs-keyword">var</span> dynamicParam1 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);
<span class="hljs-keyword">var</span> dynamicParam2 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);<font></font>
CallSiteBinder csb = Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Add, <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-keyword">new</span>[] { dynamicParam1, dynamicParam2 });
<span class="hljs-keyword">var</span> dyno = Expression.Dynamic(csb, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), parameter1, parameter2);<font></font>
Expression&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt;(dyno, <span class="hljs-keyword">new</span>[] { parameter1, parameter2 });<font></font>
Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt; action = expr.Compile();
<span class="hljs-keyword">var</span> res = action(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//12</span>
res = action(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//3</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我明确指出了活页夹的来源，以避免与System.Reflection中的活页夹混淆。</font><font style="vertical-align: inherit;">有趣的是，我们可以执行ref和out参数，命名参数，一元运算，并且原则上可以通过动态完成所有操作，但这需要一些技巧。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常捕获块</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我要注意的第二件事是try / catch / finally / fault功能，或者说，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以访问Fault块。</font><font style="vertical-align: inherit;">它在C＃中不可用，但在MSIL中可用，这是一种</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终模拟，将在发生任何异常的情况下执行。</font><font style="vertical-align: inherit;">在下面的示例中，将引发异常，此后将显示“ Hi”，程序将等待输入。</font><font style="vertical-align: inherit;">只有这样，它才会完全掉落。</font><font style="vertical-align: inherit;">我不建议您使用这种做法。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> throwSmth = Expression.Throw(Expression.Constant(<span class="hljs-keyword">new</span> Exception(), <span class="hljs-keyword">typeof</span>(Exception)));
<span class="hljs-keyword">var</span> log = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>) }), Expression.Constant(<span class="hljs-string">"Hi"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>)));
<span class="hljs-keyword">var</span> read = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.ReadLine)));
<span class="hljs-keyword">var</span> fault = Expression.TryFault(throwSmth, Expression.Block(<span class="hljs-keyword">new</span>[] { log, read }));<font></font>
Expression&lt;Action&gt; expr = Expression.Lambda&lt;Action&gt;(fault);<font></font>
Action compiledExpression = expr.Compile();<font></font>
compiledExpression();<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用的表达式树类型的简要说明</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简短的介绍</font></font></th>
</tr>
<tr>
<td colspan="2" align="center"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主要的</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达</font></font></td>
<td> ,      .     ,      </td>
</tr>
<tr>
<td>Expression&lt;TDelegate&gt;</td>
<td>    </td>
</tr>
<tr>
<td colspan="2" align="center"><b> </b></td>
</tr>
<tr>
<td>BinaryExpression</td>
<td>     (+, —  )</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td> (+, -),    throw</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td> —   </td>
</tr>
<tr>
<td>ParameterExpression</td>
<td> </td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>  ,  MethodInfo</td>
</tr>
<tr>
<td>IndexExpression</td>
<td></td>
</tr>
<tr>
<td>BlockExpression</td>
<td>,   .      </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  </b></td>
</tr>
<tr>
<td>ConditionalExpression </td>
<td>   — if-else</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>   goto</td>
</tr>
<tr>
<td>LabelExpression</td>
<td> ,            .    LabelTarget.    ,    GotoExpression,    —   .    void,    .</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>  .    . ( .. «break»)</td>
</tr>
<tr>
<td>LoopExpression</td>
<td> ,    «break»</td>
</tr>
<tr>
<td>SwitchCase</td>
<td>    SwitchExpression</td>
</tr>
<tr>
<td>SwitchExpression</td>
<td>  switch/case</td>
</tr>
<tr>
<td>TryExpression</td>
<td>    try/catch/finally/fault </td>
</tr>
<tr>
<td>CatchBlock</td>
<td>,   ,    </td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>ElementInit</td>
<td>    IEnumerable.   ListInitExpression</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>  +   </td>
</tr>
<tr>
<td>DefaultExpression</td>
<td>       </td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>   +  </td>
</tr>
<tr>
<td>NewExpression</td>
<td> </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  /</b></td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>    </td>
</tr>
<tr>
<td>MemberBinding</td>
<td>  ,    ,  ,        </td>
</tr>
<tr>
<td>MemberExpression</td>
<td>  /</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>      </td>
</tr>
<tr>
<td>MemberListBinding</td>
<td> /  </td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td> / ,    /</td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>LambdaExpression</td>
<td></td>
</tr>
<tr>
<td>InvocationExpression</td>
<td>   -    </td>
</tr>
<tr>
<td>DebugInfoExpression</td>
<td>       .         </td>
</tr>
<tr>
<td>SymbolDocumentInfo</td>
<td>       ,        .</td>
</tr>
<tr>
<td>DynamicExpression</td>
<td>   ( )</td>
</tr>
<tr>
<td>RuntimeVariablesExpression</td>
<td>   /    </td>
</tr>
<tr>
<td>TypeBinaryExpression</td>
<td>,      (is)</td>
</tr>
</tbody></table></div><br>
      <br>
<br>
<ul>
<li>ExpressionVisitor —     .  .</li>
<li>DynamicExpressionVisitor —      DynamicExpression ( VisitDynamic)</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此信息足以开始比较使用表达式树的方法。</font><font style="vertical-align: inherit;">我决定以找到导数的例子来解析所有这一切。</font><font style="vertical-align: inherit;">我没有预见所有可能的选择，只有基本的选择。</font><font style="vertical-align: inherit;">但是，如果由于某种原因有人决定修改和使用它，我将很高兴通过对我的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的请求分享改进</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="pm"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式匹配</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，任务是对微分进行演算。</font><font style="vertical-align: inherit;">您可以估算以下内容：对于不同类型的运算-乘法，除法等，有一些规则可以找到导数。</font><font style="vertical-align: inherit;">根据操作，您必须选择一个特定的公式。</font><font style="vertical-align: inherit;">在这种平庸的表述中，理想地将任务放在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关/盒上</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在最新版本的语言中，我们看到了switch / case 2.0或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式匹配</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里很难讨论一些事情。</font><font style="vertical-align: inherit;">在集线器上，如此大量的代码看起来很繁琐且阅读效果很差，所以我建议您看一下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用一个导数的例子，结果像这样</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatterntMatchingDerivative</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
		<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; ParseDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(ParseDerivative(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Expression <span class="hljs-title">ParseDerivative</span>(<span class="hljs-params">Expression function</span>)</span> =&gt; function <span class="hljs-keyword">switch</span><font></font>
        {<font></font>
            BinaryExpression binaryExpr =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            },<font></font>
            MethodCallExpression methodCall <span class="hljs-keyword">when</span> methodCall.Method == _pow =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(ParseDerivative(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
             },<font></font>
             _ =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; _zero,<font></font>
                ExpressionType.Parameter =&gt; _one,<font></font>
                _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">"Bitmap best practice"</span>)<font></font>
             }<font></font>
        };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来有点不寻常，但很有趣。</font><font style="vertical-align: inherit;">很高兴写这篇文章-所有条件有机地结合在一起。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该示例说明了一切，您无法用文字更好地描述它。</font></font><br>
<a name="nv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天真的访客</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这样的任务中，表情树访客立即浮现在脑海，这</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在粉丝</font><font style="vertical-align: inherit;">中引起了很大的轰动，</font><font style="vertical-align: inherit;">并引起了粉丝的恐慌，他们在厨房里讨论敏捷问题。</font><font style="vertical-align: inherit;">“不要惧怕无知，而要知道虚假的知识。</font><font style="vertical-align: inherit;">最好什么都不知道，而不是考虑真相，那是不正确的。” </font><font style="vertical-align: inherit;">记住托尔斯泰的这个美妙短语，承认无知并争取Google的支持，您可以找到以下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指南</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我拥有的链接是查询“表达式树访问者”的第一个链接（在1949年西伯利亚之后）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乍一看，这正是我们所需要的。</font><font style="vertical-align: inherit;">本文的标题符合我们的意愿，示例中的类均以后缀</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命名</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在回顾了文章并进行了类推之后，通过类比我们的派生示例，我们得到：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomDerivativeExpressionTreeVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; Visit(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visitor.CreateFromExpression(function.Body).Visit(), function.Parameters);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression Zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression One = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Visitor <span class="hljs-title">CreateFromExpression</span>(<span class="hljs-params">Expression node</span>)</span>
            =&gt; node <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                BinaryExpression be =&gt; <span class="hljs-keyword">new</span> BinaryVisitor(be),<font></font>
                MethodCallExpression mce <span class="hljs-keyword">when</span> mce.Method == Pow =&gt; <span class="hljs-keyword">new</span> PowMethodCallVisitor(mce),<font></font>
                _ =&gt; <span class="hljs-keyword">new</span> SimpleVisitor(node),<font></font>
            };<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BinaryExpression _node;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryVisitor</span>(<span class="hljs-params">BinaryExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowMethodCallVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodCallExpression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PowMethodCallVisitor</span>(<span class="hljs-params">MethodCallExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; (_node.Arguments[<span class="hljs-number">0</span>], _node.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(_node, Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, Pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(CreateFromExpression(expression).Visit(), _node), Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Expression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleVisitor</span>(<span class="hljs-params">Expression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; Zero,<font></font>
                ExpressionType.Parameter =&gt; One,<font></font>
            };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上-我们将开关案例分散到不同的类别。</font><font style="vertical-align: inherit;">他们不少，魔法没有出现。</font><font style="vertical-align: inherit;">所有相同的情况，更多行。</font><font style="vertical-align: inherit;">承诺的双重派遣在哪里？</font></font><br>
<a name="cv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经典访客和双重调度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，有必要介绍</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板本身</font><font style="vertical-align: inherit;">，它也是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expression tree visitor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的基础</font><font style="vertical-align: inherit;">。让我们仅以表达式树为例进行分析。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二，假设我们设计了表达式树。我们希望使用户能够遍历表达式树，并根据节点的类型（表达式类型）执行某些操作。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一种选择</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是什么也不做。也就是说，强迫用户使用开关/外壳。这不是一个坏选择。但是这里有一个细微差别：我们散布负责特定类型的逻辑。简而言之，多态性和虚拟挑战（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也称为后期绑定）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），可以将类型定义移至运行时，并从我们的代码中删除这些检查。对于我们而言，具有创建所需类型的实例的逻辑就足够了，然后一切将由运行时为我们完成。</font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种选择。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显而易见的解决方案是将逻辑引入虚拟方法。通过覆盖每个后继对象中的虚拟方法，我们可以忽略开关/大小写。多态调用的机制将为我们决定。方法表将在此处工作，方法将通过其中的偏移量进行调用。但这是整篇文章的主题，所以我们不要着迷。虚拟方法似乎可以解决我们的问题。但是不幸的是，他们创造了另一个。对于我们的任务，我们可以添加GetDeriviative（）方法。但是现在表达式类本身看起来很奇怪。我们可以在所有场合添加此类方法，但它们不适合该类的一般逻辑。而且，我们仍然没有提供进行类似于用户的操作的机会（当然是通过适当的方式）。我们需要让用户为每种特定类型定义逻辑，但保留多态性（我们可以使用）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅用户为此付出的努力不会成功。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这才是真正的访客所在。</font><font style="vertical-align: inherit;">在层次结构的基本类型（本例中为Expression）中，我们定义了以下形式的方法</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在继承人中，此方法将被覆盖。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExpressionVisitor本身是一个基类，其中包含</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对每种层次结构类型都</font><font style="vertical-align: inherit;">具有相同签名的虚拟方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以ExpressionVisitor类为例，VisitBinary（...），VisitMethodCall（...），VisitConstant（...），VisitParameter（...）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些方法在层次结构的相应类中调用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些。</font><font style="vertical-align: inherit;">BinaryExpression类中的Accept方法将如下所示：</font></font><br>
<br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span><font></font>
{<font></font>
        <span class="hljs-keyword">return</span> visitor.VisitBinary(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，为了定义新的行为，用户只需要创建ExpressionVisitor类的继承人，即可在其中重新定义用于解决一个问题的相应方法。在我们的例子中，创建了DerivativeExpressionVisitor。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我们有一些Expression的后继对象，但哪些是未知的，但不是必需的。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用所需的ExpressionVisitor实现调用虚拟的Accept方法，即与DerivativeExpressionVisitor一起使用。由于采用了动态调度，因此调用了Accept的重写实现，例如运行时，例如BinaryExpression。在此方法的主体中，我们完全理解我们处于BinaryExpression中，但是我们不知道遇到了哪个ExpressionVisitor继承者。但是由于VisitBinary也是虚拟的，我们不需要知道。同样，我们只是通过引用基类来调用，该调用是动态（在运行时）调度的，并且调用了运行时类型的重写VisitBinary实现。对于双重派遣而言，如此之多-乒乓球的风格就是“你做”-“不，你”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它给我们带来了什么。实际上，这使得可以从外部“添加”虚拟方法，而不是</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
换课。</font><font style="vertical-align: inherit;">听起来不错，但也有缺点：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以“接受”方法的形式出现的一些左派分子，它同时负责所有事务</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个好的哈希函数的连锁反应是，当您仅向层次结构中添加一个继承人时，在最坏的情况下，每个人都必须完成访问者的操作</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是由于使用表达式的特殊性，表达式树的性质允许这些成本，因为这种解决方法是其主要功能之一。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以看到所有可用于重载的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，让我们看看它的外观。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到github。</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildinExpressionTreeVisitor</span> : <span class="hljs-title">ExpressionVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; GetDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visit(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitBinary</span>(<span class="hljs-params">BinaryExpression binaryExpr</span>)</span>
            =&gt; binaryExpr.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; binaryExpr.Left,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; binaryExpr.Right,<font></font>
                ExpressionType.Multiply =&gt; Expression.Add(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))),<font></font>
<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; Expression.Divide(binaryExpr.Left, Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; Expression.Divide(_one, binaryExpr.Right),<font></font>
                ExpressionType.Divide =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitMethodCall</span>(<span class="hljs-params">MethodCallExpression methodCall</span>)</span>
            =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(Visit(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitConstant</span>(<span class="hljs-params">ConstantExpression _</span>)</span> =&gt; _zero;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitParameter</span>(<span class="hljs-params">ParameterExpression b</span>)</span> =&gt; _one;<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许像大多数编程任务一样，不能给出明确的答案。</font><font style="vertical-align: inherit;">一如既往，一切都取决于具体情况。</font><font style="vertical-align: inherit;">我喜欢本例中的常规模式匹配，因为 </font><font style="vertical-align: inherit;">我没有将其开发到工业发展的规模。</font><font style="vertical-align: inherit;">如果此表达式将不受控制地增加，则值得考虑访客。</font><font style="vertical-align: inherit;">甚至是天真的访问者都享有生命权-毕竟，如果层次结构本身没有提供支持，这也是将大量代码分散到类中的一种好方法。</font><font style="vertical-align: inherit;">即使在这里也有例外。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，访问者对层次结构的支持也引起了很大争议。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我希望这里提供的信息足以做出正确的选择。</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN486972/">https://habr.com/ru/post/zh-CN486972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN486948/index.html">如何选择编辑器，为什么选择NeoVim？</a></li>
<li><a href="../zh-CN486950/index.html">上古：无情升级386电脑</a></li>
<li><a href="../zh-CN486962/index.html">HSE游戏开发评论</a></li>
<li><a href="../zh-CN486964/index.html">多任务处理和好奇。Java冠军Mitya Alexandrov论IT社区的创建，“远程”和生活</a></li>
<li><a href="../zh-CN486966/index.html">为什么便利与安全不是折衷的选择</a></li>
<li><a href="../zh-CN486974/index.html">在俄罗斯批量生产电子产品。测试自动化</a></li>
<li><a href="../zh-CN486976/index.html">俄罗斯信息教育的问题及其可能的解决方案</a></li>
<li><a href="../zh-CN486978/index.html">现场记录：最大的开源会议之一FOSDEM 2020</a></li>
<li><a href="../zh-CN486980/index.html">Kim Dotcom：抓住了，网上最通缉的人。第1部分</a></li>
<li><a href="../zh-CN486982/index.html">如何学习前端开发，找到第一份工作而不会遇到困难</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>