<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíº üåñ üò™ Automated recursive computing üòä üëÜüèø üëºüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction
 The impact of subroutines (English subroutine) on programming without exaggeration is enormous. Introduced at the dawn of programming...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Automated recursive computing</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492958/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The impact of subroutines (English subroutine) on programming without exaggeration is enormous. Introduced at the dawn of programming, they do not lose their relevance to this day. Without them, practical programming is simply impossible to imagine. Although from a formal point of view, they are not so necessary, because Pure theory is more interested in the properties of the algorithm than in its size. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the theory of automata, the concept of nested automata, on the basis of which the practice of automaton subprograms (AMP) would be based, is rarely discussed. A similar (nested) hierarchical organization of automata, if considered, is very superficial. One of the reasons for this relationship may be the complexity of implementing a nested hierarchy at the hardware level [1, 2].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programming is more flexible and provides more features than the practice of designing digital circuits. </font><font style="vertical-align: inherit;">We have to make sure of this, considering further the software implementation of nested automata, and then the concept of automaton recursive algorithms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For all the particular problems of forming a nested automaton model, its formal definition does not cause any problems. </font><font style="vertical-align: inherit;">But, on the other hand, the choice of building a model hierarchy will certainly have a significant impact on its software implementation.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Automated recursive algorithms</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the previous article [3], only a formal definition of the control model of automatic programs (AP) was given without considering its implementation and specific examples of use. The possibility of implementing recursive algorithms was also mentioned. Next, using the factorial calculation example, firstly, we will consider the software implementation of the mechanisms for creating automatic routines within the framework of the object automaton C ++ paradigm, and secondly, since we will consider a recursive algorithm, we will essentially define a general principle for implementing any such algorithms in the framework of automatic programming.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using recursive functions in an API can be quite simple. </font><font style="vertical-align: inherit;">This demonstrates the code for listing 1 of the object machine program. </font><font style="vertical-align: inherit;">Here the FSimpleFactorial automaton class is not a process, but an automaton routine, because </font><font style="vertical-align: inherit;">contains the final state ‚Äú00‚Äù (for more details on subprograms see [3]). </font><font style="vertical-align: inherit;">At the level of behavior, the created automaton object corresponds to an automaton with one unconditional transition from the initial state ‚Äúf0‚Äù to the final state ‚Äú00‚Äù and a call to this transition within the framework of action y1 of the usual factorial factorial function (factorial (...)).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Calling the factorial function from the AMS</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSimpleFactorial</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">double</span> dF{<span class="hljs-number">1</span>};		<span class="hljs-comment">//	 </span>
    FSimpleFactorial(<span class="hljs-keyword">int</span> n);
    <span class="hljs-keyword">virtual</span> ~FSimpleFactorial() {};
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> nN{<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSimpleFactorial.h"</span></span><font></font>
<font></font>
LArc TT_SimpleFactorial[] = {<font></font>
    LArc(<span class="hljs-string">"f0"</span>, <span class="hljs-string">"00"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Construction/Destruction</span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
FSimpleFactorial::FSimpleFactorial(<span class="hljs-keyword">int</span> n)<font></font>
    :LFsaAppl(TT_SimpleFactorial, <span class="hljs-string">"FSimpleFactorial"</span>)<font></font>
{<font></font>
    nN = n;<font></font>
}<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSimpleFactorial::y1</span><span class="hljs-params">()</span> </span>{ dF = factorial(nN); }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">FSimpleFactorial::factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*factorial(n<span class="hljs-number">-1</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the FSimpleFactorial object is a nested automaton (subroutine), there must be a ‚Äúwrapper‚Äù for it - the process that calls it. </font><font style="vertical-align: inherit;">His example is a process spawned from an object named FTskSimple, whose code is shown in Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. The process for creating a nested automaton</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTskSimple</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTskSimple(nameFsa); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTskSimple(<span class="hljs-built_in">string</span> strNam);
    <span class="hljs-keyword">virtual</span> ~FTskSimple();<font></font>
<font></font>
    CVar    *pVarF;<font></font>
    CVar    *pVarN;<font></font>
    CVar    *pVarStart;<font></font>
<font></font>
    LFsaAppl *pFCall{<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y3</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTskSimple.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSimpleFactorial.h"</span></span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Construction/Destruction</span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><font></font>
LArc TT_Task[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>, <span class="hljs-string">"t1"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"t1"</span>, <span class="hljs-string">"t2"</span>, <span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y3"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"t2"</span>, <span class="hljs-string">"t1"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y2"</span>),	<span class="hljs-comment">//</span><font></font>
    };<font></font>
<font></font>
FTskSimple::FTskSimple(<span class="hljs-built_in">string</span> strNam)<font></font>
    :LFsaAppl(TT_Task, strNam)<font></font>
{<font></font>
}<font></font>
<font></font>
FTskSimple::~FTskSimple() { <span class="hljs-keyword">if</span> (pFCall) <span class="hljs-keyword">delete</span> pFCall; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTskSimple::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarF = CreateLocVar(<span class="hljs-string">"dF"</span>, CLocVar::vtDouble, <span class="hljs-string">"factorial value"</span>);<font></font>
    pVarN = CreateLocVar(<span class="hljs-string">"nN"</span>, CLocVar::vtInteger, <span class="hljs-string">"input value"</span>);<font></font>
    pVarStart = CreateLocVar(<span class="hljs-string">"bStart"</span>, CLocVar::vtBool, <span class="hljs-string">"start?"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTskSimple::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarStart-&gt;GetDataSrc(); }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTskSimple::y1</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// reset flag start</span>
    pVarStart-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, <span class="hljs-number">0.0</span>);
    <span class="hljs-comment">// creating and calling a subroutine</span>
    pFCall = <span class="hljs-keyword">new</span> FSimpleFactorial(pVarN-&gt;GetDataSrc());<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTskSimple::y2</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// display factorial value</span>
    pVarF-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">static_cast</span>&lt;FSimpleFactorial*&gt;(pFCall)-&gt;dF);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTskSimple::y3</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// reset flag start</span>
    pVarStart-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, <span class="hljs-number">0.0</span>);
    <span class="hljs-keyword">static_cast</span>&lt;FSimpleFactorial*&gt;(pFCall)-&gt;nN = pVarN-&gt;GetDataSrc();
    <span class="hljs-comment">// creating and calling a subroutine</span>
    pFCall-&gt;FCall(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This process at the transition from the initial state "st" to the state "t1" creates an object of type FSimpleFactorial, which will be the basis for creating a nested automaton (in the usual sense, calling a subprogram). </font><font style="vertical-align: inherit;">Further, based on the current state of the local variable of the Boolean type bStart (see also the predicate code x1), it causes a transition from the state ‚Äút1‚Äù to ‚Äút2‚Äù. </font><font style="vertical-align: inherit;">On this transition, the action of y1, firstly, resets the value of this local variable (to prevent false restart) and, secondly, calls the FCall procedure, which creates a nested automaton.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The interpreter of the automata of the VKPA environment organizes the transition to the initial state ‚Äúf0‚Äù of the embedded automaton and the states of the latter become the current states of the process. The transition of the nested automaton to the final state ‚Äú00‚Äù returns the calculation to the previous level of nesting, and in our case, to the completion of the transition of the top level automaton to the state t2. Then the process, on an unconditional transition from the state ‚Äút2‚Äù to the state ‚Äút1‚Äù, performs the action y2, which sets the result of calculating the factorial of the local variable of the process dF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note, and it is very important that the result of a nested automaton will be available only after completion of its work and transition to the next state of a top-level automaton. It will be possible to get it (result) through a pointer to an object of a nested automaton.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And everything would be fine if it weren't for the recursive function runtime. In comparison with the usual subroutine, due to nesting, as a rule, it is much larger and therefore can violate the conditional atomicity of the actions of automatic processes, the total execution time of which should fit into the value of a discrete clock cycle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the calculation of the factorial is quite small and up to the maximum value of a double result for n = 170 fits into 1 microsecond. To calculate large values, one needs to switch to long arithmetic (see, for example, [4, 5]). At the same time, factorial computation time will increase even more and will almost guaranteed to go beyond the discrete clock cycle, affecting the speed of the remaining network machines operating in the non-preemptive multitasking mode and the reactivity of the response of the application as a whole, which will manifest itself in its ‚Äúbrakes‚Äù.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can keep within a discrete clock cycle and get rid of the ‚Äúbrakes‚Äù defect by expanding the calculation into steps. For these purposes, it is convenient to translate the usual factorial algorithm into automatic form. True, due to the interpretation mode of automata, the calculation time will increase, but the temporal properties of the application will return to normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3 shows the calculation of the factorial in its usual form and in the form prepared for subsequent conversion to an automaton form. The latter explicitly represents atomic steps that are hidden in the source code of the program. In this case, we are talking about operators of the form y = f (...), where f is an ordinary or recursive program function. Such a record masks the operating time of the function and creates a false impression of the ‚Äúinstantaneous‚Äù assignment of the value of the variable y. In reality, there is neither one nor the other.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Software functions for calculating factorial</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*factorial(n<span class="hljs-number">-1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">double</span> dF = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> dF;
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">double</span> dPrev = Factorial(n<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">double</span> dF = n*dPrev;
        <span class="hljs-keyword">return</span> dF;<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the framework of the concept of automatic programming, atomic actions (methods) of software automatic objects are considered conditionally instantaneous. </font><font style="vertical-align: inherit;">And if only the total operating time of actions fits into a single cycle of discrete time of automaton space, then the software implementation corresponds to its formal model. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remark 1. The total real time of operation of actions on one or another discrete clock cycle can vary quite strongly. </font><font style="vertical-align: inherit;">In case of exceeding the cycle time, the VKPA environment tries to compensate for it at subsequent cycles of the automaton space operation, reducing, if possible, the discrete time of subsequent cycles.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fig. Figure 1 shows a block diagram that includes markup that reflects the states of an equivalent finite state machine and the names of its predicates and actions. The automaton model itself in the form of a graph of the automaton is shown in Fig. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y9/su/vd/y9suvdw86fiu4pz4tokaamqpmai.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1. Block diagram of the recursive algorithm factorial </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/bg/vg/qr/bgvgqrab0jdiesuscmbzrsvr9fq.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 2. An automaton model of a recursive factorial algorithm</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code for the automatic routine for calculating the factorial is shown in Listing 4. The comments in the transition table (TP) reflect the time of calculating the factorial in ms and the number of discrete steps spent on the calculation procedure for n = 170. And if the calculation time depends on the speed of the computing platform and / or on the type of project (debug / release), then the number of discrete steps (clock cycles) is determined only by the properties of the algorithm and can serve as an objective assessment of the speed of the algorithm, regardless of the form of its presentation and implementation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of an automaton model, the number of discrete ticks can be calculated quite simply and, having collected certain statistics, derive an analytical formula for the speed of the algorithm. </font><font style="vertical-align: inherit;">In the meantime, such estimates are very approximate and are based on conclusions, often obtained as a result of rather complex reasoning.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. Automated factorial routine</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FFactRec</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FFactRec(<span class="hljs-keyword">int</span> n);
    <span class="hljs-keyword">virtual</span> ~FFactRec() { <span class="hljs-keyword">if</span> (pFFactRec) <span class="hljs-keyword">delete</span> pFFactRec; };
    <span class="hljs-keyword">int</span> nN;		<span class="hljs-comment">//	n</span>
    <span class="hljs-keyword">double</span> dF;	<span class="hljs-comment">//	n!</span>
<span class="hljs-keyword">private</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y3</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CallFactorial</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">double</span>  <span class="hljs-title">PrevFactorial</span><span class="hljs-params">()</span></span>;<font></font>
    FFactRec *pFFactRec{<span class="hljs-literal">nullptr</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FFactRec.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QT_NO_DEBUG_OUTPUT</span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TT_FactRec[];
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Construction/Destruction</span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">//	   </span>
FFactRec::FFactRec(<span class="hljs-keyword">int</span> n)<font></font>
    :LFsaAppl(TT_FactRec, <span class="hljs-string">"FFactRec"</span>)<font></font>
{<font></font>
    nN=n; dF=<span class="hljs-number">1</span>;<font></font>
}<font></font>
<font></font>
LArc TT_FactRec[] = {<font></font>
<span class="hljs-comment">//        Debug    Release     Steps</span>
<span class="hljs-comment">//msec: 120-129   98-101        340</span>
    LArc(<span class="hljs-string">"f1"</span>, <span class="hljs-string">"00"</span>, <span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y3"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"f1"</span>, <span class="hljs-string">"f2"</span>, <span class="hljs-string">"^x1"</span>,	<span class="hljs-string">"y1"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"f2"</span>, <span class="hljs-string">"00"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y2"</span>),	<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FFactRec::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> nN==<span class="hljs-number">0</span>; }
<span class="hljs-comment">//   </span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::y1</span><span class="hljs-params">()</span> </span>{ CallFactorial(); }
<span class="hljs-comment">//	1.      </span>
<span class="hljs-comment">//	2.    </span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::y2</span><span class="hljs-params">()</span> </span>{ dF = PrevFactorial()*nN; }
<span class="hljs-comment">// 0!</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::y3</span><span class="hljs-params">()</span> </span>{ dF = <span class="hljs-number">1</span>; }
<span class="hljs-comment">//   (  )</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::CallFactorial</span><span class="hljs-params">()</span>	</span>{
    <span class="hljs-comment">//	     </span>
    pFFactRec = <span class="hljs-keyword">new</span> FFactRec(nN<span class="hljs-number">-1</span>);<font></font>
    pFFactRec-&gt;FCall(<span class="hljs-keyword">this</span>);<font></font>
};<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-function"><span class="hljs-keyword">double</span>  <span class="hljs-title">FFactRec::PrevFactorial</span><span class="hljs-params">()</span>	</span>{ <span class="hljs-keyword">return</span> pFFactRec-&gt;dF; };
</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Conclusions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I admit, due to the specifics of the tasks to be solved, I actually did not have to use, and develop recursive algorithms in real projects, except for training purposes and for testing the kernel for the implementation of nesting. </font><font style="vertical-align: inherit;">Automated routines - almost constantly and in large numbers. </font><font style="vertical-align: inherit;">Among them, the subroutines called inertial are especially interesting (for more details, see [3]). </font><font style="vertical-align: inherit;">But they are supposed to devote a separate article to their consideration.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recursive algorithms are an important part of program theory [6]. Without the implementation of routines and recursion, it is difficult to imagine an efficient and convenient computational model from all points of view. And to implement recursion, given the possibilities of object programming (see examples of the article), after creating a model of subprograms, it is not so difficult. You can, of course, using certain methods of converting recursion into a regular form, bypassing it using the same cycles. But it is preferable not to get rid of it stupidly, but to have direct mechanisms for its implementation. Of course, it will be slower, of course, more expensive in terms of resources (expenses of the same stack memory), but with the existing hardware capabilities this will not be so critical.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But recursive algorithms are also interesting as tests for evaluating the capabilities, universality, and effectiveness of algorithmic models. In this sense, the automaton model not only implements recursion quite effectively, but also adds ‚Äúautomaton chips‚Äù as a bonus - the ability to control the internal state of the recursive algorithm, count steps to evaluate performance, control the execution time of the algorithm, etc. etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fighting recursion is pointless enough. It must be able to use. I‚Äôll quote with which I completely agree: ‚ÄúAt first glance, recursion may seem complicated. But in some cases, the recursive method is incredibly effective if everything is done correctly. However, it is sometimes better to use loops. Understanding both methods and the ability to use them effectively will help you in your work and will be an advantage in the interview ‚Äù[7]. I can only add on my own that automatic models of recursive algorithms make it possible, using the "automatic properties" of a computational model, to understand recursion, debug and refine such an algorithm much faster.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last one. </font><font style="vertical-align: inherit;">Nevertheless, I would like to get an answer to the question - how are things going with coroutine recursion? </font><font style="vertical-align: inherit;">I already asked it, but I haven‚Äôt received an answer ... After all, it‚Äôs one thing to create a million coroutine (see [8] for examples) and another to implement a recursive algorithm that has a nesting level that is not the same but high enough. </font><font style="vertical-align: inherit;">And, it seems, the answer to this question interests not only me alone ... [9]</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literature</font></font></b><div class="spoiler_text">1.  ..,  ..       . I, .  ., 1981,  2, 135-144. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">mi.mathnet.ru/at5725</a> . . . (  10.03.2020).<br>
2.  ..,  ..       . II, .  ., 1981,  3, 112-121. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">mi.mathnet.ru/at5743</a> . . . (  10.03.2020).<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">habr.com/ru/post/484588</a> . . . (  10.03.2020).<br>
4.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">habr.com/ru/post/255761</a> . . . (  10.03.2020).<br>
5.     C++. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">habr.com/ru/post/172285</a> . . . (  10.03.2020).<br>
6.  . .     : .  . ‚Äì .: , 1983. ‚Äì 256 .<br>
7.   ,   ?   Python.   Ethan Jarrell. Recursion vs. Looping in Python [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">nuancesprog.ru/p/3325</a> . . . (  15.03.2020).<br>
8. Your first coroutine with Kotlin. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html</a> . . . (  18.03.2020).<br>
9.  .   CyberForum.ru. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">www.cyberforum.ru/unity/thread2479923.html</a> . . . (  18.03.2020).<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492942/index.html">Ontol (= most useful) about remote work [compilation of 100+ articles]</a></li>
<li><a href="../en492946/index.html">Coronavirus: how we deceive ourselves</a></li>
<li><a href="../en492948/index.html">Meet defer</a></li>
<li><a href="../en492952/index.html">Back to the Future with the Java Developer Course</a></li>
<li><a href="../en492956/index.html">Gamers are never ex. Fond memories and forbidden pleasures - in a survey by DataArt</a></li>
<li><a href="../en492962/index.html">My quarantine autonomous survival kit</a></li>
<li><a href="../en492964/index.html">Processing millions of events per day with cascading queues</a></li>
<li><a href="../en492966/index.html">For the first time a photon was teleported from one chip to another</a></li>
<li><a href="../en492968/index.html">In memory of Freeman Dyson, the genius of mathematics, turned into a technological visionary</a></li>
<li><a href="../en492970/index.html">How TeamViewer stores passwords</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>