<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèø ü§µüèº üë®üèø‚Äç‚öïÔ∏è Maschinelles Lernen: Wo soll ich anfangen oder wie erstelle ich das erste Modell? üë®üèæ‚Äçüîß ü¶Ö üßö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als erste Aufgabe f√ºr maschinelles Lernen nehmen wir etwas Klares und Einfaches, zum Beispiel eine Prognose der Wohnkosten. Der fertige Datensatz ist ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen: Wo soll ich anfangen oder wie erstelle ich das erste Modell?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505516/"><img src="https://habrastorage.org/webt/cn/mg/fr/cnmgfrvs-ej5ldlqz9cmmdjdcrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als erste Aufgabe f√ºr maschinelles Lernen nehmen wir etwas Klares und Einfaches, zum Beispiel eine Prognose der Wohnkosten. Der fertige Datensatz ist auf der Kaggle-Website zu finden. In den ersten Schritten des Trainings sollten Sie keine Datens√§tze mit einer gro√üen Anzahl von Variablen verwenden, z. B. "Hauspreise: Fortgeschrittene Regressionstechniken" besteht aus 80 Variablen und fortgeschrittener Regression. Wir werden bei "Hausverk√§ufe in King County, USA" mit 21 Parametern anhalten. Laden Sie die Daten herunter und analysieren Sie die bereitgestellte Beschreibung. Verf√ºgbares Datum, Preis, Anzahl der Schlafzimmer, Badezimmer, Gesamt- und Wohnfl√§che, Anzahl der Stockwerke, Ansichtsbewertung, Meerblick, Bewertung des Allgemeinzustands, Grad (Bewertung von Bau und Design), Fl√§che √ºber und unter dem Boden, Baujahr, Baujahr Reparatur, Vorwahl, Koordinaten (L√§ngen- und Breitengrad), Daten zum Bereich der H√§user von 15 Nachbarn.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also eine Aufgabe ausgew√§hlt und sind bereit, sie zu l√∂sen. Die L√∂sung umfasst zwei Phasen: Datenanalyse und Modellbildung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Arbeiten Sie mit Daten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns abschweifen und die Bedeutung der Datenanalyse separat betrachten. Derzeit sind alle mehr oder weniger popul√§ren Algorithmen bereits in Form von Bibliotheken geschrieben, und die direkte Konstruktion des Modells wird auf mehrere Codezeilen reduziert, z. B. k-n√§chste Nachbarn von sklearn in Python:</font></font><a name="habracut"></a><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn .neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<font></font>
clf_KNN = KNeighborsClassifier()       <span class="hljs-comment"># </span>
clf_KNN.fit(X_train, Y_train)          <span class="hljs-comment"># </span>
Y_KNN = clf_KNN.predict(X_test)        <span class="hljs-comment">#    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur vier Codezeilen, um das Ergebnis zu erhalten. Was ist die Schwierigkeit? Die Schwierigkeit besteht darin, genau den X_train zu erhalten - die Daten, die der Eingabe des Modells zugef√ºhrt werden. Das bekannte Prinzip ‚ÄûGarbage In‚Äú = ‚ÄûGarbage In‚Äú (englischer Garbage In - Garbage Out (GIGO)) bei der Modellierung funktioniert zu mehr als 100%, und die Qualit√§t der erhaltenen L√∂sung f√ºr das Problem des maschinellen Lernens h√§ngt weitgehend von der Arbeit mit Daten ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt - zur Schlacht! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die Datenanalyse werden wir Pandas verwenden, f√ºr das Verst√§ndnis und die Bewertung "mit dem Auge" verwenden wir einfache Grafiken von Seegeborenen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir importieren die Bibliotheken, lesen die Daten, leiten mehrere Datens√§tze aus dem Datenarray ab, untersuchen die Datentypen und Auslassungen in ihnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code und Out</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<font></font>
df = pd.read_csv(<span class="hljs-string">'‚Ä¶/train.csv'</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/1q/cy/og/1qcyogx0fmdgtibrhx1l2b5mdty.png"><br>
<br>
<pre><code class="python hljs">df.info()</code></pre><br>
<pre><code class="plaintext hljs">RangeIndex: 21613 entries, 0 to 21612<font></font>
Data columns (total 21 columns):<font></font>
id 21613 non-null int64<font></font>
date 21613 non-null object<font></font>
price 21613 non-null float64<font></font>
bedrooms 21613 non-null int64<font></font>
bathrooms 21613 non-null float64<font></font>
sqft_living 21613 non-null int64<font></font>
sqft_lot 21613 non-null int64<font></font>
floors 21613 non-null float64<font></font>
waterfront 21613 non-null int64<font></font>
view 21613 non-null int64<font></font>
condition 21613 non-null int64<font></font>
grade 21613 non-null int64<font></font>
sqft_above 21613 non-null int64<font></font>
sqft_basement 21613 non-null int64<font></font>
yr_built 21613 non-null int64<font></font>
yr_renovated 21613 non-null int64<font></font>
zipcode 21613 non-null int64<font></font>
lat 21613 non-null float64<font></font>
long 21613 non-null float64<font></font>
sqft_living15 21613 non-null int64<font></font>
sqft_lot15 21613 non-null int64<font></font>
dtypes: float64(5), int64(15), object(1)<font></font>
memory usage: 3.5+ MB</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Datenarray besteht aus 21613 Datens√§tzen ohne L√ºcken in den Daten und enth√§lt nur 1 Textfelddatum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden mit jedem Zeichen detaillierter arbeiten und mit dem einfachsten beginnen: Wegwerf-ID (enth√§lt keine n√ºtzlichen Informationen), Postleitzahl (Code des Gebiets, in dem sich das Haus befindet) und Koordinaten (lat &amp; long), da wir uns nur mit maschinellem Lernen und der korrekten Umrechnung von geografischen Merkmalen vertraut machen Die Daten sind f√ºr einen Anf√§nger zu spezifisch.</font></font><br>
<br>
<pre><code class="python hljs">df=df.drop([<span class="hljs-string">'id'</span>,<span class="hljs-string">'zipcode'</span>,<span class="hljs-string">'lat'</span>,<span class="hljs-string">'long'</span>], axis=<span class="hljs-number">1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun das Datum der Ank√ºndigung an. Das Datumsformat ist auf JJJJMMTTT000000 festgelegt. Im Allgemeinen kann es auch aus dem Datensatz entfernt werden. Wir haben jedoch die Felder f√ºr das Baujahr (yr_built) und das letzte Reparaturjahr (yr_renovated), die im Jahresformat (JJJJ) angegeben sind, was nicht sehr informativ ist. Mit dem Datum der Ank√ºndigung k√∂nnen Sie das Jahr durch Subtraktion (Jahr der Ank√ºndigung - Baujahr / Reparaturjahr) in Alter umwandeln. Wir stellen fest, dass das Reparaturjahr f√ºr einige H√§user 0 ist. Unter der Annahme, dass dies keine Reparatur des Geb√§udes bedeutet, ersetzen wir die Nullen im Reparaturjahr durch das Baujahr und stellen zun√§chst sicher, dass die Daten keine falschen Aufzeichnungen enthalten, wenn das Reparaturjahr unter dem Baujahr liegt:</font></font><br>
<br>
<pre><code class="python hljs">df[(df[<span class="hljs-string">'yr_renovated'</span>]&lt;df[<span class="hljs-string">'yr_built'</span>])&amp;df[<span class="hljs-string">'yr_renovated'</span>]!=<span class="hljs-number">0</span>]</code></pre><br>
<img src="https://habrastorage.org/webt/l7/wo/ii/l7woii1rk3buxzexbab2i4uokmq.png"><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'yr_renovated'</span>]==<span class="hljs-number">0</span>, [<span class="hljs-string">'yr_renovated'</span>]]=df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_built'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_renovated'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_renovated'</span>]<font></font>
df=df.drop(<span class="hljs-string">'date'</span>, axis=<span class="hljs-number">1</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/4z/za/uw/4zzauwyidq18e0lq_8x5-up5e88.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden den Preis mit dem n√§chsten Parameter analysieren und daf√ºr das ‚ÄûBox-Diagramm‚Äú verwenden. Eine Schnurrbartbox ist ein einfaches und praktisches Diagramm, das eine eindimensionale Wahrscheinlichkeitsverteilung oder einfacher die Konzentration von Daten zeigt. Zeichnet den Median (Linie in der Mitte), das obere und untere Quartil (Seiten des Kastens), die Kanten der statistisch signifikanten Stichprobe ("Schnurrbart") und Ausrei√üer (Punkte hinter dem "Schnurrbart"). Aus dem Bild auf der Normalverteilung (rechts) ist es leicht zu verstehen. In der Grafik k√∂nnen Sie schnell beurteilen, wo sich die meisten Daten befinden (50% befinden sich innerhalb der Box), ihre Symmetrie (mittlere Verschiebung zu einer Seite der Box und / oder die L√§nge des "Schnurrbartes") und den Grad der Streuung - Varianz (Boxgr√∂√üe, Schnurrbartgr√∂√üe und Anzahl der Punkte) Emissionen).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bi/bh/uw/bibhuwyeeexpszcl7sahfpdo8le.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist m√∂glich, nur eine Verteilung dieses Merkmals √ºber das gesamte Array zu erstellen. Es ist jedoch informativer, zwei Achsen zu verwenden - zum Beispiel den Preis und die Anzahl der Schlafzimmer, die wiederum auch das Vorhandensein einer Verbindung zwischen den Zeichen anzeigen:</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'price'</span>, data=df)			<span class="hljs-comment"># price</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)	<span class="hljs-comment">#price &amp; bedrooms</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Out Preis &amp; Schlafzimmer: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/za/oh/ta/zaohtajsfsedoz8lagkzjto-oa0.png"><br>
<br>
<img src="https://habrastorage.org/webt/fn/em/4g/fnem4gwwbubwzkrhi25i4ly3j4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grafik zeigt sofort das Vorhandensein von extremen Werten von Preis und Schlafzimmer (stellen Sie sich ein Haus mit 33 Schlafzimmern vor! J). Das Vorhandensein solcher Werte (auch als Ausrei√üer bezeichnet) im Kursziel f√ºhrt h√§ufig zu einer Umschulung des Modells, da sie einen gro√üen Fehler verursachen, den die Algorithmen zu minimieren versuchen. Die Grafik zeigt, dass die Mehrheit (wenn berechnet - 93,22%) im Bereich von 0 bis 1 Mio. und √ºber 2 Mio. - nur 198 Werte (0,92%) liegt. Sie k√∂nnen 1% des Datensatzes fast schmerzlos entfernen. Wenn Sie also eine einfache Anzeige von 217 Datens√§tzen aufgerufen und diese zuvor nach Preis sortiert haben, sehen wir das gew√ºnschte Preiszeichen von 1 965 000 und l√∂schen alles, was √ºber diesem Preis liegt.</font></font><br>
<br>
<pre><code class="python hljs">df.sort_values (by=<span class="hljs-string">'price'</span>, ascending=<span class="hljs-literal">False</span>).head(<span class="hljs-number">217</span>) <font></font>
df=df[df[<span class="hljs-string">'price'</span>]&lt;=<span class="hljs-number">1965000</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns ein wenig √ºber das Zeichen der Schlafzimmer nachdenken. </font><font style="vertical-align: inherit;">Wir sehen 13 H√§user mit Schlafzimmern = 0 sowie eine seltsame Aufzeichnung eines Hauses mit 33 Schlafzimmern. </font><font style="vertical-align: inherit;">Wir werden das Gleiche tun wie beim Preis, indem wir Nullen aus den Schlafzimmern (und gleichzeitig den Badezimmern) entfernen:</font></font><br>
<br>
<pre><code class="python hljs">df=df[(df[<span class="hljs-string">'bedrooms'</span>]!=<span class="hljs-number">0</span>)&amp;(df[<span class="hljs-string">'bathrooms'</span>]!=<span class="hljs-number">0</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf das Haus mit 33 Schlafzimmern - angesichts des Preises k√∂nnen wir davon ausgehen, dass dies ein Tippfehler ist und die Schlafzimmer tats√§chlich 3 sind. Vergleichen wir den Wohnbereich dieses Hauses (1620) mit dem durchschnittlichen Wohnbereich von H√§usern mit 3 Schlafzimmern (1798,2), was wahrscheinlich unsere Vermutung ist. √Ñndern Sie diesen Wert daher einfach in 3 und erstellen Sie das vorherige Box-Diagramm erneut:</font></font><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'bedrooms'</span>]==<span class="hljs-number">33</span>,[<span class="hljs-string">'bedrooms'</span>]]=<span class="hljs-number">3</span> 
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/qi/wd/fs/qiwdfscthapolbucfyjqy-uoggc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, viel besser. </font><font style="vertical-align: inherit;">Ebenso sehen Schlafzimmer Badezimmer. </font><font style="vertical-align: inherit;">Wir haben Nullwerte gel√∂scht, es gibt keine anderen Extremwerte im Feld:</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'bathrooms'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Feldern sqft_living, Etagen, Ufergegend, Ansicht, Zustand, Grad, sqft_living15 sind auch alle Werte mehr oder weniger real, wir werden sie nicht ber√ºhren:</font></font><br>
<br>
<pre><code class="python hljs">plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">2</span>,<span class="hljs-number">3</span> 			<span class="hljs-comment"># </span>
sns.boxplot(y=<span class="hljs-string">'sqft_living'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'floors'</span>,color=<span class="hljs-string">'#2ecc71'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'sqft_living15'</span>,color=<span class="hljs-string">'#9b59b6'</span>, data=df) <font></font>
plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">4</span>,<span class="hljs-number">4</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'waterfront'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'view'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'condition'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'grade'</span> , data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/oq/uw/h8/oquwh8x-cln4tbaz9xrzqyk9szs.png"><br>
<br>
<img src="https://habrastorage.org/webt/yl/ns/bz/ylnsbzq_kx2dtvrvjy8iytxudve.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber mit sqft_lot und sqft_lot15 m√ºssen Sie sich etwas einfallen lassen, und aufgrund der gro√üen Werte ist der Logarithmus durchaus geeignet:</font></font><br>
<br>
<pre><code class="python hljs">df[<span class="hljs-string">'sqft_lot'</span>]=np.log(df[<span class="hljs-string">'sqft_lot'</span>])<font></font>
df[<span class="hljs-string">'sqft_lot15'</span>]=np.log(df[<span class="hljs-string">'sqft_lot15'</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_lot vorher und nachher: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yr/up/g2/yrupg24jwmfsptci9hf8uaq6wmu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_above und sqft_basement sind die Komponenten von sqft_living, daher werden wir sie auch nicht ber√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit schlie√üen wir mit einer vorl√§ufigen Analyse ab und betrachten die W√§rmekarte der Korrelationen:</font></font><br>
<br>
<pre><code class="python hljs">sns.heatmap(df.corr(),  cmap = <span class="hljs-string">'viridis'</span>,annot = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/ny/yi/uq/nyyiuqa9zbilc9l6gqzljfe35xu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Korrelationskarte untersucht haben, stellen wir fest, dass die Attribute manchmal stark miteinander korreliert sind. Daher l√∂schen wir einige der Attribute mit hoher Korrelation - sqft_lot15 (verlassen Sie sqft_lot), yr_built (lassen Sie yr_renovated), sqft_above (sqft_living). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist die Arbeit mit den Daten abgeschlossen und mit der Erstellung des Modells fortgefahren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Modellierung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Teil werden zwei Modelle erstellt: lineare Regression und Entscheidungsbaum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Modelle, die wir ben√∂tigen, sind in der sklearn-Bibliothek enthalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst trennen wir die Zielvariable von den restlichen Daten f√ºr das Training und teilen die Stichproben in Training (70%) und Test (30%, an denen wir √ºberpr√ºfen, wie das Modell funktioniert) auf:</font></font><br>
<br>
<pre><code class="python hljs">Y=df[<span class="hljs-string">'price'</span>]<font></font>
X=df.drop (<span class="hljs-string">'price'</span>,axis=<span class="hljs-number">1</span>) 
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<font></font>
X_train, X_test, Y_train, Y_test  = train_test_split(X, Y, test_size = <span class="hljs-number">0.3</span>, shuffle = <span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Modell zu bewerten, laden wir von sklearn drei Metriken hoch: mean_absolute_error (mittlerer absoluter Fehler), mean_squared_error (Standardabweichung), r2_score (Bestimmungskoeffizient):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der linearen Regression:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<font></font>
LR = LinearRegression() 				<span class="hljs-comment"># </span>
LR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_LR = LR.predict(X_test)				<span class="hljs-comment">#       </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_LR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'‚àöMSE:'</span>, round (mean_squared_error(Y_test, Y_LR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_LR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE: 124477.452 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚àöMSE 175205.645 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score: 0.627 Entscheidungsbaum </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<font></font>
TR = DecisionTreeRegressor()				<span class="hljs-comment"># </span>
TR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_TR=TR.predict(X_test)  				<span class="hljs-comment">#   </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_TR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'‚àöMSE:'</span>, round (mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_TR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE: 151734.906 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚àöMSE 220856.721 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score: 0.407 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den Metriken k√∂nnen wir den Schluss ziehen, dass die lineare Regression das beste Ergebnis </font><font style="vertical-align: inherit;">erzielt hat. </font><font style="vertical-align: inherit;">Daher ist es logischer, sie auszuw√§hlen. Wir haben jedoch nicht gefragt, woraus der Modellfehler besteht, ob das Modell umgeschult wird usw. Es ist sehr wahrscheinlich, dass eine Umschulung zu einer Verschlechterung des DecisionTreeRegressor-Ergebnisses gef√ºhrt hat, da wir die Tiefe des Baums in den Modellparametern nicht einmal begrenzt haben. Wir k√∂nnen dies leicht √ºberpr√ºfen, indem wir in einem kurzen Zyklus die Tiefe der B√§ume sortieren:</font></font><br>
<br>
<pre><code class="python hljs">dep,score=[],[]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>):<font></font>
    TR = DecisionTreeRegressor(max_depth=i)<font></font>
    TR.fit(X_train, Y_train)<font></font>
    Y_TR=TR.predict(X_test)<font></font>
    dep.append(i)<font></font>
    score.append(mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))	<span class="hljs-comment">#  ‚àöMSE</span>
		plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">6</span>,<span class="hljs-number">3</span>
		plt.plot(dep, score)</code></pre><br>
<img src="https://habrastorage.org/webt/ar/fn/yt/arfnytm068lhpknk_ifnpshupgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich liegt der beste Indikator bei max_depth = 7, und wenn man sich die Metriken ansieht (MAE: 124861.441, ‚àöMSE 175322.737, R2_score: 0.626), wird klar, dass ein Modell mit einer solchen Einschr√§nkung der linearen Regression in der Qualit√§t √§hnlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen auch versuchen zu bewerten, welche Attribute f√ºr das Modell f√ºr die Kostenprognose am wichtigsten waren: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/x1/qx/qw/x1qxqwlhqbfotpp45hhyr4nz0uc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus der Grafik geht hervor, dass die Note die Kosten am meisten beeinflusst - eine allgemeine subjektive Bewertung des Hauses durch das Immobilienunternehmen (die √ºbrigens die Kompetenz der Bewertung angibt :-))), an zweiter Stelle steht der Bereich des Hauses und an dritter Stelle das Jahr der letzten Reparatur. Die Indikatoren ber√ºcksichtigten die Anzahl der Schlafzimmer, Badezimmer und B√∂den, die das Modell f√ºr die Prognose als unbedeutend erachtete.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Ergebnisse besser zu verstehen, berechnen wir den durchschnittlichen Fehler in%. Gem√§√ü der linearen Regression betr√§gt der durchschnittliche Fehler 27,5%, dh das Modell macht etwas mehr Fehler als ein Viertel, wenn die Kosten eines Hauses prognostiziert werden, was ziemlich viel ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K√∂nnen die Ergebnisse verbessert werden? </font><font style="vertical-align: inherit;">Ja, nat√ºrlich haben wir zum gegenw√§rtigen Zeitpunkt nur eine grundlegende L√∂sung erhalten - ein Ausgangspunkt f√ºr den Vergleich sind bessere oder schlechtere Modelle, die wir mit komplexeren Methoden oder mit komplexerer Datenverarbeitung erstellen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das Thema Umschulung nur geringf√ºgig angesprochen und √ºberhaupt nicht angesprochen, woraus der Modellfehler und viele andere Aspekte der Modellerstellung bestehen. </font><font style="vertical-align: inherit;">In der Regel werden verschiedene Methoden zur Modellvalidierung verwendet, um diese Fragen zu beantworten und die optimale L√∂sung zu finden. Wir werden dies jedoch in den folgenden Artikeln beschreiben.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505498/index.html">Wie wir das Problem des nicht initialisierten Stapelspeichers in Windows l√∂sen</a></li>
<li><a href="../de505502/index.html">Omnichannel im Kundenservice: Worauf muss man achten und wie kann man alles richtig machen?</a></li>
<li><a href="../de505506/index.html">Er bei√üt nicht: wie man Industrieroboter f√ºr Arbeiter sicher macht</a></li>
<li><a href="../de505508/index.html">Nicht nur unbemannte Technologie: Die Zukunft der Automobilindustrie</a></li>
<li><a href="../de505510/index.html">Optimierung der Check Point-API mit dem Python SDK</a></li>
<li><a href="../de505522/index.html">Monetarisierung in Online-Spielen: Wie Sie die Erfahrung eines anderen f√ºr Ihre eigenen Bed√ºrfnisse nutzen k√∂nnen</a></li>
<li><a href="../de505528/index.html">Das Wichtigste in Wi-Fi 6. Nein, im Ernst</a></li>
<li><a href="../de505530/index.html">Google stellt seinen Prozessor her und AMD bereitet sich darauf vor, Qualcomm zu zerst√∂ren</a></li>
<li><a href="../de505532/index.html">Telegrammkan√§le zur Spieleentwicklung: Teil 2</a></li>
<li><a href="../de505536/index.html">So kochen Sie Anrufverfolgung: Cyan Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>