<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏿 🤵🏼 👨🏿‍⚕️ Maschinelles Lernen: Wo soll ich anfangen oder wie erstelle ich das erste Modell? 👨🏾‍🔧 🦅 🧚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als erste Aufgabe für maschinelles Lernen nehmen wir etwas Klares und Einfaches, zum Beispiel eine Prognose der Wohnkosten. Der fertige Datensatz ist ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen: Wo soll ich anfangen oder wie erstelle ich das erste Modell?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505516/"><img src="https://habrastorage.org/webt/cn/mg/fr/cnmgfrvs-ej5ldlqz9cmmdjdcrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als erste Aufgabe für maschinelles Lernen nehmen wir etwas Klares und Einfaches, zum Beispiel eine Prognose der Wohnkosten. Der fertige Datensatz ist auf der Kaggle-Website zu finden. In den ersten Schritten des Trainings sollten Sie keine Datensätze mit einer großen Anzahl von Variablen verwenden, z. B. "Hauspreise: Fortgeschrittene Regressionstechniken" besteht aus 80 Variablen und fortgeschrittener Regression. Wir werden bei "Hausverkäufe in King County, USA" mit 21 Parametern anhalten. Laden Sie die Daten herunter und analysieren Sie die bereitgestellte Beschreibung. Verfügbares Datum, Preis, Anzahl der Schlafzimmer, Badezimmer, Gesamt- und Wohnfläche, Anzahl der Stockwerke, Ansichtsbewertung, Meerblick, Bewertung des Allgemeinzustands, Grad (Bewertung von Bau und Design), Fläche über und unter dem Boden, Baujahr, Baujahr Reparatur, Vorwahl, Koordinaten (Längen- und Breitengrad), Daten zum Bereich der Häuser von 15 Nachbarn.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also eine Aufgabe ausgewählt und sind bereit, sie zu lösen. Die Lösung umfasst zwei Phasen: Datenanalyse und Modellbildung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Arbeiten Sie mit Daten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns abschweifen und die Bedeutung der Datenanalyse separat betrachten. Derzeit sind alle mehr oder weniger populären Algorithmen bereits in Form von Bibliotheken geschrieben, und die direkte Konstruktion des Modells wird auf mehrere Codezeilen reduziert, z. B. k-nächste Nachbarn von sklearn in Python:</font></font><a name="habracut"></a><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn .neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<font></font>
clf_KNN = KNeighborsClassifier()       <span class="hljs-comment"># </span>
clf_KNN.fit(X_train, Y_train)          <span class="hljs-comment"># </span>
Y_KNN = clf_KNN.predict(X_test)        <span class="hljs-comment">#    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur vier Codezeilen, um das Ergebnis zu erhalten. Was ist die Schwierigkeit? Die Schwierigkeit besteht darin, genau den X_train zu erhalten - die Daten, die der Eingabe des Modells zugeführt werden. Das bekannte Prinzip „Garbage In“ = „Garbage In“ (englischer Garbage In - Garbage Out (GIGO)) bei der Modellierung funktioniert zu mehr als 100%, und die Qualität der erhaltenen Lösung für das Problem des maschinellen Lernens hängt weitgehend von der Arbeit mit Daten ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt - zur Schlacht! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Datenanalyse werden wir Pandas verwenden, für das Verständnis und die Bewertung "mit dem Auge" verwenden wir einfache Grafiken von Seegeborenen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir importieren die Bibliotheken, lesen die Daten, leiten mehrere Datensätze aus dem Datenarray ab, untersuchen die Datentypen und Auslassungen in ihnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code und Out</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<font></font>
df = pd.read_csv(<span class="hljs-string">'…/train.csv'</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/1q/cy/og/1qcyogx0fmdgtibrhx1l2b5mdty.png"><br>
<br>
<pre><code class="python hljs">df.info()</code></pre><br>
<pre><code class="plaintext hljs">RangeIndex: 21613 entries, 0 to 21612<font></font>
Data columns (total 21 columns):<font></font>
id 21613 non-null int64<font></font>
date 21613 non-null object<font></font>
price 21613 non-null float64<font></font>
bedrooms 21613 non-null int64<font></font>
bathrooms 21613 non-null float64<font></font>
sqft_living 21613 non-null int64<font></font>
sqft_lot 21613 non-null int64<font></font>
floors 21613 non-null float64<font></font>
waterfront 21613 non-null int64<font></font>
view 21613 non-null int64<font></font>
condition 21613 non-null int64<font></font>
grade 21613 non-null int64<font></font>
sqft_above 21613 non-null int64<font></font>
sqft_basement 21613 non-null int64<font></font>
yr_built 21613 non-null int64<font></font>
yr_renovated 21613 non-null int64<font></font>
zipcode 21613 non-null int64<font></font>
lat 21613 non-null float64<font></font>
long 21613 non-null float64<font></font>
sqft_living15 21613 non-null int64<font></font>
sqft_lot15 21613 non-null int64<font></font>
dtypes: float64(5), int64(15), object(1)<font></font>
memory usage: 3.5+ MB</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Datenarray besteht aus 21613 Datensätzen ohne Lücken in den Daten und enthält nur 1 Textfelddatum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden mit jedem Zeichen detaillierter arbeiten und mit dem einfachsten beginnen: Wegwerf-ID (enthält keine nützlichen Informationen), Postleitzahl (Code des Gebiets, in dem sich das Haus befindet) und Koordinaten (lat &amp; long), da wir uns nur mit maschinellem Lernen und der korrekten Umrechnung von geografischen Merkmalen vertraut machen Die Daten sind für einen Anfänger zu spezifisch.</font></font><br>
<br>
<pre><code class="python hljs">df=df.drop([<span class="hljs-string">'id'</span>,<span class="hljs-string">'zipcode'</span>,<span class="hljs-string">'lat'</span>,<span class="hljs-string">'long'</span>], axis=<span class="hljs-number">1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun das Datum der Ankündigung an. Das Datumsformat ist auf JJJJMMTTT000000 festgelegt. Im Allgemeinen kann es auch aus dem Datensatz entfernt werden. Wir haben jedoch die Felder für das Baujahr (yr_built) und das letzte Reparaturjahr (yr_renovated), die im Jahresformat (JJJJ) angegeben sind, was nicht sehr informativ ist. Mit dem Datum der Ankündigung können Sie das Jahr durch Subtraktion (Jahr der Ankündigung - Baujahr / Reparaturjahr) in Alter umwandeln. Wir stellen fest, dass das Reparaturjahr für einige Häuser 0 ist. Unter der Annahme, dass dies keine Reparatur des Gebäudes bedeutet, ersetzen wir die Nullen im Reparaturjahr durch das Baujahr und stellen zunächst sicher, dass die Daten keine falschen Aufzeichnungen enthalten, wenn das Reparaturjahr unter dem Baujahr liegt:</font></font><br>
<br>
<pre><code class="python hljs">df[(df[<span class="hljs-string">'yr_renovated'</span>]&lt;df[<span class="hljs-string">'yr_built'</span>])&amp;df[<span class="hljs-string">'yr_renovated'</span>]!=<span class="hljs-number">0</span>]</code></pre><br>
<img src="https://habrastorage.org/webt/l7/wo/ii/l7woii1rk3buxzexbab2i4uokmq.png"><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'yr_renovated'</span>]==<span class="hljs-number">0</span>, [<span class="hljs-string">'yr_renovated'</span>]]=df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_built'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_renovated'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_renovated'</span>]<font></font>
df=df.drop(<span class="hljs-string">'date'</span>, axis=<span class="hljs-number">1</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/4z/za/uw/4zzauwyidq18e0lq_8x5-up5e88.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden den Preis mit dem nächsten Parameter analysieren und dafür das „Box-Diagramm“ verwenden. Eine Schnurrbartbox ist ein einfaches und praktisches Diagramm, das eine eindimensionale Wahrscheinlichkeitsverteilung oder einfacher die Konzentration von Daten zeigt. Zeichnet den Median (Linie in der Mitte), das obere und untere Quartil (Seiten des Kastens), die Kanten der statistisch signifikanten Stichprobe ("Schnurrbart") und Ausreißer (Punkte hinter dem "Schnurrbart"). Aus dem Bild auf der Normalverteilung (rechts) ist es leicht zu verstehen. In der Grafik können Sie schnell beurteilen, wo sich die meisten Daten befinden (50% befinden sich innerhalb der Box), ihre Symmetrie (mittlere Verschiebung zu einer Seite der Box und / oder die Länge des "Schnurrbartes") und den Grad der Streuung - Varianz (Boxgröße, Schnurrbartgröße und Anzahl der Punkte) Emissionen).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bi/bh/uw/bibhuwyeeexpszcl7sahfpdo8le.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist möglich, nur eine Verteilung dieses Merkmals über das gesamte Array zu erstellen. Es ist jedoch informativer, zwei Achsen zu verwenden - zum Beispiel den Preis und die Anzahl der Schlafzimmer, die wiederum auch das Vorhandensein einer Verbindung zwischen den Zeichen anzeigen:</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'price'</span>, data=df)			<span class="hljs-comment"># price</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)	<span class="hljs-comment">#price &amp; bedrooms</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Out Preis &amp; Schlafzimmer: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/za/oh/ta/zaohtajsfsedoz8lagkzjto-oa0.png"><br>
<br>
<img src="https://habrastorage.org/webt/fn/em/4g/fnem4gwwbubwzkrhi25i4ly3j4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grafik zeigt sofort das Vorhandensein von extremen Werten von Preis und Schlafzimmer (stellen Sie sich ein Haus mit 33 Schlafzimmern vor! J). Das Vorhandensein solcher Werte (auch als Ausreißer bezeichnet) im Kursziel führt häufig zu einer Umschulung des Modells, da sie einen großen Fehler verursachen, den die Algorithmen zu minimieren versuchen. Die Grafik zeigt, dass die Mehrheit (wenn berechnet - 93,22%) im Bereich von 0 bis 1 Mio. und über 2 Mio. - nur 198 Werte (0,92%) liegt. Sie können 1% des Datensatzes fast schmerzlos entfernen. Wenn Sie also eine einfache Anzeige von 217 Datensätzen aufgerufen und diese zuvor nach Preis sortiert haben, sehen wir das gewünschte Preiszeichen von 1 965 000 und löschen alles, was über diesem Preis liegt.</font></font><br>
<br>
<pre><code class="python hljs">df.sort_values (by=<span class="hljs-string">'price'</span>, ascending=<span class="hljs-literal">False</span>).head(<span class="hljs-number">217</span>) <font></font>
df=df[df[<span class="hljs-string">'price'</span>]&lt;=<span class="hljs-number">1965000</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns ein wenig über das Zeichen der Schlafzimmer nachdenken. </font><font style="vertical-align: inherit;">Wir sehen 13 Häuser mit Schlafzimmern = 0 sowie eine seltsame Aufzeichnung eines Hauses mit 33 Schlafzimmern. </font><font style="vertical-align: inherit;">Wir werden das Gleiche tun wie beim Preis, indem wir Nullen aus den Schlafzimmern (und gleichzeitig den Badezimmern) entfernen:</font></font><br>
<br>
<pre><code class="python hljs">df=df[(df[<span class="hljs-string">'bedrooms'</span>]!=<span class="hljs-number">0</span>)&amp;(df[<span class="hljs-string">'bathrooms'</span>]!=<span class="hljs-number">0</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf das Haus mit 33 Schlafzimmern - angesichts des Preises können wir davon ausgehen, dass dies ein Tippfehler ist und die Schlafzimmer tatsächlich 3 sind. Vergleichen wir den Wohnbereich dieses Hauses (1620) mit dem durchschnittlichen Wohnbereich von Häusern mit 3 Schlafzimmern (1798,2), was wahrscheinlich unsere Vermutung ist. Ändern Sie diesen Wert daher einfach in 3 und erstellen Sie das vorherige Box-Diagramm erneut:</font></font><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'bedrooms'</span>]==<span class="hljs-number">33</span>,[<span class="hljs-string">'bedrooms'</span>]]=<span class="hljs-number">3</span> 
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/qi/wd/fs/qiwdfscthapolbucfyjqy-uoggc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, viel besser. </font><font style="vertical-align: inherit;">Ebenso sehen Schlafzimmer Badezimmer. </font><font style="vertical-align: inherit;">Wir haben Nullwerte gelöscht, es gibt keine anderen Extremwerte im Feld:</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'bathrooms'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Feldern sqft_living, Etagen, Ufergegend, Ansicht, Zustand, Grad, sqft_living15 sind auch alle Werte mehr oder weniger real, wir werden sie nicht berühren:</font></font><br>
<br>
<pre><code class="python hljs">plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">2</span>,<span class="hljs-number">3</span> 			<span class="hljs-comment"># </span>
sns.boxplot(y=<span class="hljs-string">'sqft_living'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'floors'</span>,color=<span class="hljs-string">'#2ecc71'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'sqft_living15'</span>,color=<span class="hljs-string">'#9b59b6'</span>, data=df) <font></font>
plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">4</span>,<span class="hljs-number">4</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'waterfront'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'view'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'condition'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'grade'</span> , data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/oq/uw/h8/oquwh8x-cln4tbaz9xrzqyk9szs.png"><br>
<br>
<img src="https://habrastorage.org/webt/yl/ns/bz/ylnsbzq_kx2dtvrvjy8iytxudve.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber mit sqft_lot und sqft_lot15 müssen Sie sich etwas einfallen lassen, und aufgrund der großen Werte ist der Logarithmus durchaus geeignet:</font></font><br>
<br>
<pre><code class="python hljs">df[<span class="hljs-string">'sqft_lot'</span>]=np.log(df[<span class="hljs-string">'sqft_lot'</span>])<font></font>
df[<span class="hljs-string">'sqft_lot15'</span>]=np.log(df[<span class="hljs-string">'sqft_lot15'</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_lot vorher und nachher: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yr/up/g2/yrupg24jwmfsptci9hf8uaq6wmu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_above und sqft_basement sind die Komponenten von sqft_living, daher werden wir sie auch nicht berühren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit schließen wir mit einer vorläufigen Analyse ab und betrachten die Wärmekarte der Korrelationen:</font></font><br>
<br>
<pre><code class="python hljs">sns.heatmap(df.corr(),  cmap = <span class="hljs-string">'viridis'</span>,annot = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/ny/yi/uq/nyyiuqa9zbilc9l6gqzljfe35xu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Korrelationskarte untersucht haben, stellen wir fest, dass die Attribute manchmal stark miteinander korreliert sind. Daher löschen wir einige der Attribute mit hoher Korrelation - sqft_lot15 (verlassen Sie sqft_lot), yr_built (lassen Sie yr_renovated), sqft_above (sqft_living). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist die Arbeit mit den Daten abgeschlossen und mit der Erstellung des Modells fortgefahren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Modellierung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Teil werden zwei Modelle erstellt: lineare Regression und Entscheidungsbaum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Modelle, die wir benötigen, sind in der sklearn-Bibliothek enthalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst trennen wir die Zielvariable von den restlichen Daten für das Training und teilen die Stichproben in Training (70%) und Test (30%, an denen wir überprüfen, wie das Modell funktioniert) auf:</font></font><br>
<br>
<pre><code class="python hljs">Y=df[<span class="hljs-string">'price'</span>]<font></font>
X=df.drop (<span class="hljs-string">'price'</span>,axis=<span class="hljs-number">1</span>) 
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<font></font>
X_train, X_test, Y_train, Y_test  = train_test_split(X, Y, test_size = <span class="hljs-number">0.3</span>, shuffle = <span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Modell zu bewerten, laden wir von sklearn drei Metriken hoch: mean_absolute_error (mittlerer absoluter Fehler), mean_squared_error (Standardabweichung), r2_score (Bestimmungskoeffizient):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der linearen Regression:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<font></font>
LR = LinearRegression() 				<span class="hljs-comment"># </span>
LR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_LR = LR.predict(X_test)				<span class="hljs-comment">#       </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_LR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'√MSE:'</span>, round (mean_squared_error(Y_test, Y_LR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_LR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE: 124477.452 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√MSE 175205.645 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score: 0.627 Entscheidungsbaum </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<font></font>
TR = DecisionTreeRegressor()				<span class="hljs-comment"># </span>
TR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_TR=TR.predict(X_test)  				<span class="hljs-comment">#   </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_TR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'√MSE:'</span>, round (mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_TR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE: 151734.906 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√MSE 220856.721 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score: 0.407 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den Metriken können wir den Schluss ziehen, dass die lineare Regression das beste Ergebnis </font><font style="vertical-align: inherit;">erzielt hat. </font><font style="vertical-align: inherit;">Daher ist es logischer, sie auszuwählen. Wir haben jedoch nicht gefragt, woraus der Modellfehler besteht, ob das Modell umgeschult wird usw. Es ist sehr wahrscheinlich, dass eine Umschulung zu einer Verschlechterung des DecisionTreeRegressor-Ergebnisses geführt hat, da wir die Tiefe des Baums in den Modellparametern nicht einmal begrenzt haben. Wir können dies leicht überprüfen, indem wir in einem kurzen Zyklus die Tiefe der Bäume sortieren:</font></font><br>
<br>
<pre><code class="python hljs">dep,score=[],[]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>):<font></font>
    TR = DecisionTreeRegressor(max_depth=i)<font></font>
    TR.fit(X_train, Y_train)<font></font>
    Y_TR=TR.predict(X_test)<font></font>
    dep.append(i)<font></font>
    score.append(mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))	<span class="hljs-comment">#  √MSE</span>
		plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">6</span>,<span class="hljs-number">3</span>
		plt.plot(dep, score)</code></pre><br>
<img src="https://habrastorage.org/webt/ar/fn/yt/arfnytm068lhpknk_ifnpshupgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich liegt der beste Indikator bei max_depth = 7, und wenn man sich die Metriken ansieht (MAE: 124861.441, √MSE 175322.737, R2_score: 0.626), wird klar, dass ein Modell mit einer solchen Einschränkung der linearen Regression in der Qualität ähnlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können auch versuchen zu bewerten, welche Attribute für das Modell für die Kostenprognose am wichtigsten waren: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/x1/qx/qw/x1qxqwlhqbfotpp45hhyr4nz0uc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus der Grafik geht hervor, dass die Note die Kosten am meisten beeinflusst - eine allgemeine subjektive Bewertung des Hauses durch das Immobilienunternehmen (die übrigens die Kompetenz der Bewertung angibt :-))), an zweiter Stelle steht der Bereich des Hauses und an dritter Stelle das Jahr der letzten Reparatur. Die Indikatoren berücksichtigten die Anzahl der Schlafzimmer, Badezimmer und Böden, die das Modell für die Prognose als unbedeutend erachtete.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Ergebnisse besser zu verstehen, berechnen wir den durchschnittlichen Fehler in%. Gemäß der linearen Regression beträgt der durchschnittliche Fehler 27,5%, dh das Modell macht etwas mehr Fehler als ein Viertel, wenn die Kosten eines Hauses prognostiziert werden, was ziemlich viel ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Können die Ergebnisse verbessert werden? </font><font style="vertical-align: inherit;">Ja, natürlich haben wir zum gegenwärtigen Zeitpunkt nur eine grundlegende Lösung erhalten - ein Ausgangspunkt für den Vergleich sind bessere oder schlechtere Modelle, die wir mit komplexeren Methoden oder mit komplexerer Datenverarbeitung erstellen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das Thema Umschulung nur geringfügig angesprochen und überhaupt nicht angesprochen, woraus der Modellfehler und viele andere Aspekte der Modellerstellung bestehen. </font><font style="vertical-align: inherit;">In der Regel werden verschiedene Methoden zur Modellvalidierung verwendet, um diese Fragen zu beantworten und die optimale Lösung zu finden. Wir werden dies jedoch in den folgenden Artikeln beschreiben.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505498/index.html">Wie wir das Problem des nicht initialisierten Stapelspeichers in Windows lösen</a></li>
<li><a href="../de505502/index.html">Omnichannel im Kundenservice: Worauf muss man achten und wie kann man alles richtig machen?</a></li>
<li><a href="../de505506/index.html">Er beißt nicht: wie man Industrieroboter für Arbeiter sicher macht</a></li>
<li><a href="../de505508/index.html">Nicht nur unbemannte Technologie: Die Zukunft der Automobilindustrie</a></li>
<li><a href="../de505510/index.html">Optimierung der Check Point-API mit dem Python SDK</a></li>
<li><a href="../de505522/index.html">Monetarisierung in Online-Spielen: Wie Sie die Erfahrung eines anderen für Ihre eigenen Bedürfnisse nutzen können</a></li>
<li><a href="../de505528/index.html">Das Wichtigste in Wi-Fi 6. Nein, im Ernst</a></li>
<li><a href="../de505530/index.html">Google stellt seinen Prozessor her und AMD bereitet sich darauf vor, Qualcomm zu zerstören</a></li>
<li><a href="../de505532/index.html">Telegrammkanäle zur Spieleentwicklung: Teil 2</a></li>
<li><a href="../de505536/index.html">So kochen Sie Anrufverfolgung: Cyan Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>