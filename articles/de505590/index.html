<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö°Ô∏è üë®‚Äçüè´ üè¨ Wie GPU-Computing mich bei der Arbeit buchst√§blich gerettet hat. Python-Beispiel ü¶è ‚ò™Ô∏è üêá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Heute ber√ºhren wir das relevanteste Thema - Python f√ºr die Arbeit mit der GPU. Der Autor betrachtet ein Beispiel als trivial in seiner...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie GPU-Computing mich bei der Arbeit buchst√§blich gerettet hat. Python-Beispiel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/505590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute ber√ºhren wir das relevanteste Thema - Python f√ºr die Arbeit mit der GPU. </font><font style="vertical-align: inherit;">Der Autor betrachtet ein Beispiel als trivial in seiner Monstrosit√§t und demonstriert die L√∂sung, begleitet von umfangreichen Auflistungen. </font><font style="vertical-align: inherit;">Viel Spa√ü beim Lesen!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/mv/xr/xbmvxrrximpm1_fchk6fsi9v5fg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keiner von uns hat in der einen oder anderen Form den j√ºngsten Hype um GPU-Computing umgangen. Bevor Sie weiterlesen, erkl√§re ich: Ich bin kein GPU-Experte. Meine Reise in die GPU-Welt f√§ngt gerade erst an. Aber heute hat diese Technologie eine solche Leistung erreicht, dass Sie mit ihr eine ganze Reihe von Problemen l√∂sen k√∂nnen. Mir wurde eine Aufgabe bei der Arbeit zugewiesen, die Maschine verbrachte Stunden damit und es war kein Fortschritt sichtbar. Aber sobald ich die GPU aufnahm - und das Problem begann sich in Sekunden zu l√∂sen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufgabe, die ungef√§hr 2 Tage dauerte, konnte ich in nur 20 Sekunden l√∂sen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den folgenden Abschnitten werde ich diese Aufgabe ausf√ºhrlich beschreiben. </font><font style="vertical-align: inherit;">Wir werden auch diskutieren, wie und wann die GPU zur L√∂sung solcher Probleme verwendet werden muss. </font><font style="vertical-align: inherit;">Also lesen wir sorgf√§ltig - glauben Sie mir, Sie werden es nicht bereuen. </font><font style="vertical-align: inherit;">Zuerst werden wir uns mit den Details der Aufgabe befassen, uns dann mit der GPU vertraut machen und schlie√ülich die GPU verwenden, um dieses Problem zu l√∂sen. </font><font style="vertical-align: inherit;">Ich werde die Python </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numba-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">und die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia Volta V100 16 GB GPU-GPU verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Detaillierte Beschreibung der Aufgabe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Einzelhandel m√ºssen Sie h√§ufig nach √§hnlichen oder n√§chstgelegenen Objekten suchen. </font><font style="vertical-align: inherit;">Ich erhielt eine Liste von Positionen, von denen jede durch k latente Attribute dargestellt wurde. </font><font style="vertical-align: inherit;">Daher wurde ich angewiesen, die drei √§hnlichsten Positionen zu jeder der Positionen in der Liste zu finden. </font><font style="vertical-align: inherit;">Die √Ñhnlichkeitsmetrik in diesem Problem wurde als Kosinus√§hnlichkeit gew√§hlt. </font><font style="vertical-align: inherit;">So sahen meine Daten aus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s1/02/if/s102ifuqgnhoe_pv81htzopsye4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Liste der Datenelemente mit 64 latenten Merkmalen </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabenkomplexit√§t</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erhielt eine Liste mit ungef√§hr 10‚Åµ Positionen. </font><font style="vertical-align: inherit;">Um nach den drei √§hnlichsten Positionen f√ºr jede von ihnen zu suchen, m√ºsste die Kosinus√§hnlichkeit mit jedem einzelnen Element in der Liste √ºberpr√ºft werden. </font><font style="vertical-align: inherit;">Es w√ºrde sich zu n * k Operationen herausstellen, wobei n die Anzahl der Positionen und k die Attribute f√ºr jede Position sind. </font><font style="vertical-align: inherit;">Es w√§re notwendig, das Skalarprodukt dieser Position von jeder der verbleibenden Positionen in der Liste zu erhalten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_items</span>(<span class="hljs-params">X,mindex</span>):</span> <span class="hljs-comment"># X   ,    -3 ,       'mindex'</span>
    SMALL = <span class="hljs-number">-9999.0</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_val = SMALL <span class="hljs-comment">#         </span>
    first_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    second_best_val = SMALL <span class="hljs-comment">#        </span>
    second_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    third_best_val = SMALL <span class="hljs-comment">#        </span>
    third_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n): <span class="hljs-comment">#  n-  </span>
            <span class="hljs-keyword">if</span>(mindex==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[mindex],X[j])/(np.sqrt(np.sum(np.square(X[mindex]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = first_best_val<font></font>
                second_best_index = first_best_index<font></font>
                first_best_val = tmp<font></font>
                first_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = tmp<font></font>
                second_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val):<font></font>
                third_best_val = tmp<font></font>
                third_best_index = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code zum Finden von drei Positionen, die dem</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jetzt </font><i><font style="vertical-align: inherit;">so √§hnlich wie m√∂glich</font></i><font style="vertical-align: inherit;"> sind. Wenn Sie die Top 3 f√ºr alle Positionen in der Liste √§hnlich finden, wird die Komplexit√§t mit einem anderen n multipliziert. </font><font style="vertical-align: inherit;">Die endg√ºltige Komplexit√§t ist O (n * n * k) = O (n¬≤k).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_all_items</span>(<span class="hljs-params">X</span>):</span> <span class="hljs-comment"># X   ,      3     </span>
    SMALL = <span class="hljs-number">-9999.99</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    first_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    second_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    second_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    third_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    third_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-comment"># Initialisation</span><font></font>
        first_best_val[i] = SMALL<font></font>
        first_best_index[i] = <span class="hljs-number">-1</span><font></font>
        second_best_val[i] = SMALL<font></font>
        second_best_index[i] = <span class="hljs-number">-1</span><font></font>
        third_best_val[i] = SMALL<font></font>
        third_best_index[i] = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span>(i==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[i],X[j])/(np.sqrt(np.sum(np.square(X[i]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = first_best_val[i]<font></font>
                second_best_index[i] = first_best_index[i]<font></font>
                first_best_val[i] = tmp<font></font>
                first_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = tmp<font></font>
                second_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[i]):<font></font>
                third_best_val[i] = tmp<font></font>
                third_best_index[i] = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code zum Finden der drei √§hnlichsten Positionen f√ºr jede Position in der </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testlauf- und Zeitbewertungsliste</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ich habe den Code ausgef√ºhrt und versucht, die 3 √§hnlichsten Positionen aus einer Teilmenge mit n = 10¬≥ Positionen mit k = 64 zu finden. Es dauerte ungef√§hr 17, um diese Aufgabe mit Python abzuschlie√üen Sekunden bei einer Durchschnittsgeschwindigkeit von 3,7 * 10‚Å∂ Operationen pro Sekunde. </font><font style="vertical-align: inherit;">Der Code wurde mithilfe von Numpy-Operationen und -Arrays gut optimiert. </font><font style="vertical-align: inherit;">Ich stelle fest, dass alle diese Operationen nacheinander auf der CPU ausgef√ºhrt werden.</font></font><br>
<br>
<pre><code class="python hljs">%time first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index = top_3_similar_all_items(X)</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lauf f√ºr n = 10¬≥ Positionen</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/z7/fr/p9/z7frp96r6jga71hy_eh5kqc6soo.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Schlussfolgerung: Die Zeit, die f√ºr n = 10¬≥ Positionen ben√∂tigt wurde </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes habe ich die </font><font style="vertical-align: inherit;">Testuntermenge auf n = 10¬≥ Positionen </font><font style="vertical-align: inherit;">erh√∂ht. Da die Komplexit√§t O (n¬≤k) ist, hat sich die Ausf√ºhrungszeit um das 100-fache erh√∂ht (da sich n um das 10-fache erh√∂ht hat). Es dauerte 1700 Sekunden, um den Code zu vervollst√§ndigen = 28,33 Minuten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/hz/we/1thzweestkdve12ggxihgenaisu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fazit: Die Zeit, die f√ºr die Verarbeitung von n = 10‚Å¥ Positionen ben√∂tigt wurde </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes kommen wir zu der wichtigsten: Sch√§tzung der Zeit, die f√ºr die Verarbeitung einer vollst√§ndigen Liste von 10‚Åµ Positionen ben√∂tigt wird. Wenn wir z√§hlen, sehen wir, dass die Zeitkomplexit√§t erneut um das 100-fache zunimmt, da die Zeitkomplexit√§t des Algorithmus O (n¬≤k) ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gesch√§tzte Zeit = 1700 * 100 Sekunden = 2834 Minuten = 47,2 Stunden ~ 2 Tage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh mein Gott! So lange!!!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie wissen wahrscheinlich schon, dass ich es tats√§chlich geschafft habe, alles sehr schnell mit der Leistung der GPU zu erledigen. </font><font style="vertical-align: inherit;">Tats√§chlich ist der Zeitgewinn bei Verwendung einer GPU einfach schockierend. </font><font style="vertical-align: inherit;">Ich werde die Zahlen f√ºr einen Snack hinterlassen, aber ich schlage vor, dass Sie sich mit der Welt der GPU vertraut machen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Vergleich von CPU und GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Central Processing Unit (CPU) ist im Wesentlichen das Gehirn eines jeden Computerger√§ts: Sie f√ºhrt die im Programm geschriebenen Anweisungen aus und f√ºhrt Steuerungs-, logische Operationen sowie Eingabe- / Ausgabeoperationen aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwar haben moderne CPUs immer noch nicht viele Kerne, und die grundlegende Struktur und der Zweck der CPU - die Verarbeitung komplexer Berechnungen - haben sich im Wesentlichen nicht ge√§ndert. </font><font style="vertical-align: inherit;">Tats√§chlich ist die CPU am besten geeignet, um Probleme zu l√∂sen, bei denen die im Code enthaltene komplexe Logik analysiert oder interpretiert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grafikprozessor (GPU) verf√ºgt wiederum √ºber kleinere logische Kerne, die jedoch viel gr√∂√üer sind (es handelt sich um arithmetische Logikbausteine ‚Äã‚Äã(ALU), Steuerelemente und Cache-Speicher), die mit der Erwartung einer Parallelverarbeitung als Ganzes ausgelegt sind identische und relativ einfache Operationen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dv/rj/_r/dvrj_rfbqkiabwugkvilkoka3oo.png"><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die GPU verf√ºgt √ºber mehr arithmetische Logikeinheiten (ALUs) als eine typische CPU, sodass die F√§higkeit zur einfachen Verarbeitung einfacher Operationen verbessert wurde</font></font></blockquote><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung: Vergleichen Sie CPU und GPU ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image Source</font></font></a></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Wann wird GPU-Computing verwendet? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die CPU eignet sich besser f√ºr komplexe lineare Aufgaben. Trotz der Tatsache, dass die CPU-Kerne leistungsf√§higer sind, k√∂nnen Sie mit GPUs Aufgaben im Zusammenhang mit KI, maschinellem Lernen und Deep Learning effizienter und schneller verarbeiten. Die GPU verarbeitet Workloads durch Parallelisierung √§hnlicher Vorg√§nge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee von Operationen aus Sicht der GPU: Nehmen wir zum Beispiel die Operation, ein Wort in einem Dokument zu finden. Dies kann nacheinander erfolgen, indem alle W√∂rter im Dokument einzeln sortiert werden, entweder parallel, dh zeilenweise oder mit der Suche nach einem bestimmten Wort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee von Operationen aus Sicht der CPU - es gibt solche Operationen, zum Beispiel die Berechnung der Fibonacci-Reihe, die nicht parallelisiert werden k√∂nnen. Schlie√ülich k√∂nnen Sie die n√§chste Zahl erst finden, nachdem Sie die beiden vorherigen berechnet haben. Solche Operationen sind am besten f√ºr die CPU geeignet.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operationen wie Matrixaddition und -multiplikation k√∂nnen wiederum leicht unter Verwendung der GPU ausgef√ºhrt werden, da die meisten dieser Operationen in Matrixzellen unabh√§ngig voneinander sind, √§hnlicher Natur sind und daher parallelisiert werden k√∂nnen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Kurz √ºber CUDA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA ist eine von Nvidia erstellte Parallel-Computing-Plattform und ein API-Modell. Mit dieser API k√∂nnen Sie einen Prozessor verwenden, der CUDA-Grafiken f√ºr eine Vielzahl von Berechnungen unterst√ºtzt. Dieser Ansatz wird als GPGPU (Non-Specialized Computing auf GPUs) bezeichnet. Hier werden sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√§her beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMBA</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Numba ist ein Freeware-JIT-Compiler, der eine Teilmenge von Python und NumPy mithilfe von LLVM in schnellen Maschinencode √ºbersetzt. Dies erfolgt mithilfe des llvmlite-Pakets in Python. Dieses Paket bietet eine Reihe von Optionen zum Parallelisieren von Python-Code f√ºr CPU und GPU, w√§hrend minimale √Ñnderungen im Code selbst h√§ufig ausreichen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arbeiten mit dem Prozessor</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia Volta V100 16 GB GPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ich habe die Numba-Bibliothek verwendet. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architekturdetails ~ Streams, Bl√∂cke und Gitter</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
CUDA organisiert paralleles Rechnen mithilfe von Abstraktionen wie Streams, Bl√∂cken und Gittern. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ein CUDA-Stream ist eine zugewiesene Befehlskette, die zum CUDA-Kern kommt / aktuell ist (tats√§chlich ist es nur eine Pipeline). Im laufenden Betrieb k√∂nnen bis zu 32 Threads auf demselben CUDA-Kern vorhanden sein (in diesem Fall sind alle Links dieser Pipeline gef√ºllt). Dies ist die Ausf√ºhrung des Kernels mit dem angegebenen Index. Jeder Thread verwendet seinen Index, um auf die Elemente im Array so zuzugreifen, dass der gesamte Satz verf√ºgbarer Threads den gesamten Datensatz zusammen verarbeitet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Dies ist eine Thread-Gruppe. √úber die Ausf√ºhrung von Threads innerhalb eines Blocks kann nicht viel gesagt werden: Sie k√∂nnen entweder sequentiell oder parallel oder ohne bestimmte Reihenfolge ausgef√ºhrt werden. Sie k√∂nnen Threads beispielsweise mithilfe einer Funktion koordinieren, </font></font><code>_syncthreads()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die einen Thread zwingt, an einem bestimmten Punkt im Kernel anzuhalten und zu warten, bis alle anderen Threads im selben Block ebenfalls denselben Punkt erreichen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raster</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies ist eine Gruppe von Bl√∂cken. Es gibt keine Synchronisation zwischen den Bl√∂cken. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/q_/rm/fuq_rmemxkfpo8o9wkx4es362s8.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA: Threads, Bl√∂cke, Gitter ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aber wo genau werden Threads, Bl√∂cke und Gitter ausgef√ºhrt? Bei der G80-GPU-Architektur von Nvidia sind die Berechnungen anscheinend wie folgt verteilt: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid ‚Üí GPU: Das gesamte Grid wird von einem einzelnen GPU-Prozessor verarbeitet.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Block ‚Üí MP: Der GPU-Prozessor ist als Sammlung von Multiprozessoren organisiert, wobei jeder Multiprozessor f√ºr die Verarbeitung eines oder mehrerer Bl√∂cke im Raster verantwortlich ist. </font><font style="vertical-align: inherit;">Ein Block wird niemals auf mehrere Abgeordnete aufgeteilt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stream ‚Üí PP: Jeder MP ist weiter in Stream-Prozessoren (PP) unterteilt, und jeder PP verarbeitet einen oder mehrere Threads in einem Block. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mir Material aus diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hervorragend geschriebenen Artikel ausgeliehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich empfehle es sorgf√§ltig zu lesen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Ein einfaches Programm zum Hinzuf√ºgen von Arrays in Python mithilfe der GPU</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich eingangs sagte, besteht der Kern dieses Artikels darin, einem breiten Publikum zu helfen, die Leistungsf√§higkeit der GPU zu verstehen und ein intuitives Verst√§ndnis f√ºr die Verwendung der GPU zur L√∂sung allt√§glicher Aufgaben zu erlangen. Bevor Sie mit dem Schreiben von Code f√ºr die GPU beginnen, m√ºssen Sie m√∂glicherweise einige Voruntersuchungen durchf√ºhren. Nehmen wir dazu ein Beispiel f√ºr ein Programm zum Hinzuf√ºgen von Arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben zwei Arrays, 'a' und 'b' der Gr√∂√üe 'n'. Wir wollen ein Array 'c' so generieren, dass jedes Element von Array c die Summe von Elementen mit den gleichen Indizes aus den Arrays 'a' und 'b' ist. In diesem Fall verwenden wir zur L√∂sung des Problems keine sequentiellen Berechnungen, sondern parallele Berechnungen, die mit der GPU durchgef√ºhrt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden n Threads / Kerne starten. Der Index, unter dem jeder bestimmte Thread arbeitet, kann aus der folgenden Formel abgeleitet werden: </font></font><br>
<br>
<code>index = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall einer zweidimensionalen Matrix enth√§lt der Index zwei Komponenten, die eine Zeile und eine Spalte bedeuten, die wie folgt angezeigt werden k√∂nnen: </font><font style="vertical-align: inherit;">
Wir m√ºssen auch die Anzahl der Threads pro Block bestimmen, z. B. tpb und Bl√∂cke pro Gitter, sagen wir bpg. Wir werden Standardnummern f√ºr sie verwenden. </font><font style="vertical-align: inherit;">
Hierbei ist ein weiteres wichtiges Konzept zu beachten: Wenn Berechnungen auf der GPU durchgef√ºhrt werden m√ºssen, m√ºssen die entsprechenden Daten in den globalen Speicher der GPU √ºbertragen werden, und die Ergebnisse der Berechnungen k√∂nnen dann zur√ºck auf den Host √ºbertragen werden. Diese Vorg√§nge werden mit den Funktionen </font><font style="vertical-align: inherit;">und ausgef√ºhrt </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">die in der Python Numba-Bibliothek bereitgestellt werden.</font></font><br>
<br>
<code>row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x<br>
col = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>cuda.to_device()</code><font style="vertical-align: inherit;"></font><code>copy_to_host()</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachfolgend finden Sie die Implementierungen dieser L√∂sung f√ºr die CPU und die GPU. </font><font style="vertical-align: inherit;">Siehe beide Auflistungen f√ºr den Unterschied.</font></font><br>
<br>
<pre><code class="python hljs">c = np.zeroes(n)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):<font></font>
    c[i] = a[i] + b[i]<font></font>
<span class="hljs-keyword">return</span> c</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequentielle Implementierung f√ºr die CPU.</font></font></i><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment">#  Nvidia    GPU </span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <font></font>
<font></font>
<span class="hljs-meta">@cuda.jit('void(float32[:], float32[:], float32[:])') #  Cuda </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_addition</span>(<span class="hljs-params">a,b,c</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    i = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x <span class="hljs-comment">#     </span>
    <span class="hljs-keyword">if</span> i &gt; c.size:
        <span class="hljs-keyword">return</span>
    c[i] = a[i]+b[i] <span class="hljs-comment">#Perform the addition</span><font></font>
 <font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
<span class="hljs-comment">#     </span>
d_a = cuda.to_device(a)  <span class="hljs-comment">#      GPU</span>
d_b = cuda.to_device(b)  <span class="hljs-comment">#      GPU</span><font></font>
d_c = cuda.device_array_like(a)<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment">#blocksize     ,   = 32</span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
cuda_addition[bpg, tpb](d_a, d_b, d_c) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
c = d_c.copy_to_host()<font></font>
print(c)<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallele Implementierung f√ºr GPU </font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Ermitteln der 3 √§hnlichsten Positionen f√ºr jede Position in der Liste mithilfe der GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir Theorie und Praxis gr√ºndlich studiert haben, kehren wir zur urspr√ºnglichen Aufgabe zur√ºck: mithilfe von GPU-Berechnungen die drei besten Positionen f√ºr jede Position in der Liste zu finden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall besteht die Hauptidee darin, dass wir n Positionen haben und n Threads starten. </font><font style="vertical-align: inherit;">Jeder Thread arbeitet parallel und unabh√§ngig von ihnen und berechnet die 3 √§hnlichsten Positionen f√ºr jede Position in der Liste. </font><font style="vertical-align: inherit;">Jede Position ist f√ºr einen Thread verantwortlich.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment"># Nvidia's GPU Library</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-keyword">import</span> math <span class="hljs-comment">#  , ,   , Numpy    GPU</span>
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-comment">#                   </span>
<span class="hljs-meta">@cuda.jit('void(float32[:,:],float32[:],int32[:],float32[:],int32[:],float32[:],int32[:])') # CUDA Just-in-time Compiler</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_dist</span>(<span class="hljs-params">X,first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    <span class="hljs-comment">#    </span><font></font>
    row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x;<font></font>
    <span class="hljs-keyword">if</span> ((row &gt;= n)): <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">return</span>
    first_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    first_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    second_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    second_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    third_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    third_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">if</span>(i==row): <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">continue</span>
        <span class="hljs-comment">#     ,        numpy   GPU</span>
        tmp = <span class="hljs-number">0.0</span>
        magnitude1 = <span class="hljs-number">0.0</span>
        magnitude2 = <span class="hljs-number">0.0</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):<font></font>
            tmp += X[row,j] * X[i,j]<font></font>
            magnitude1 += (X[row,j]* X[row,j])<font></font>
            magnitude2 += (X[i,j]* X[i,j])<font></font>
        tmp /= (math.sqrt(magnitude1)*math.sqrt(magnitude2)) <span class="hljs-comment">#    Dot_product(a,b) = a.b/(|a|*|b|)</span>
        <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = first_best_val[row]<font></font>
            second_best_index[row] = first_best_index[row]<font></font>
            first_best_val[row] = tmp<font></font>
            first_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = tmp<font></font>
            second_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[row]):<font></font>
            third_best_val[row] = tmp<font></font>
            third_best_index[row] = i<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
d_x = cuda.to_device(X)<font></font>
d_first_val = cuda.device_array_like(first_val)<font></font>
d_first_index = cuda.device_array_like(first_index)<font></font>
d_second_val = cuda.device_array_like(second_val)<font></font>
d_second_index = cuda.device_array_like(second_index)<font></font>
d_third_val = cuda.device_array_like(third_val)<font></font>
d_third_index = cuda.device_array_like(third_index)<font></font>
<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment"># blocksize     </span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
%time cuda_dist[bpg,tpb](d_x,d_first_val,d_first_index,d_second_val,d_second_index,d_third_val,d_third_index) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
first_val = d_first_val.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_val[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
<span class="hljs-comment">#      </span><font></font>
first_index = d_first_index.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_index[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung des GPU ~ -Codes zum Auffinden der 3 Positionen, die der angegebenen </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">am √§hnlichsten sind</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die Gesamtzeit, die die GPU zum Auffinden der drei besten Positionen f√ºr jede Position in der Liste aufgewendet hat, betrug 481 ms (0,5 Sekunden). </font><font style="vertical-align: inherit;">Das Kopieren von Daten vom Ger√§t auf den Host und vom Host auf das Ger√§t dauerte weitere 20 Sekunden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fazit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe, deren L√∂sung auf der CPU etwa 2 Tage dauern w√ºrde, auf der GPU wurde in 20,5 Sekunden gel√∂st. </font><font style="vertical-align: inherit;">Dies war nur aufgrund der Art der Aufgabe m√∂glich. </font><font style="vertical-align: inherit;">Die Suche nach den 3 √§hnlichsten Positionen f√ºr 'A' h√§ngt nicht von der Suche nach den 3 √§hnlichsten Positionen f√ºr 'B' ab. </font><font style="vertical-align: inherit;">Wir haben diese Tatsache ausgenutzt und die von der GPU bereitgestellte Parallelit√§t angewendet, um den Prozess zu beschleunigen. </font><font style="vertical-align: inherit;">Das Beispiel zeigt auch, welche Arten von Aufgaben mit Hilfe einer leistungsstarken GPU am bequemsten gel√∂st werden k√∂nnen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Danksagung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Studie wurde mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walmart Labs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MLP (Machine Learning Platform) durchgef√ºhrt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vielen Dank an Ayush Kumar f√ºr die Unterst√ºtzung bei der Optimierung des Workflows.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505558/index.html">Amazon DeepLens Deep Learning Kamera. Ein Projekt entpacken, verbinden und bereitstellen</a></li>
<li><a href="../de505560/index.html">Der zweite Satz f√ºr ein Produktmanagementprogramm im CS-Center: Was die Sch√ºler sagen</a></li>
<li><a href="../de505568/index.html">√úbertragen von Dateien mit Pipes und anderen kleinen Dingen auf Delphi</a></li>
<li><a href="../de505574/index.html">Verst√§rktes Lernen durch wettbewerbsf√§hige neuronale Netze</a></li>
<li><a href="../de505580/index.html">Verwenden von Tabellenkalkulationen und Computersoftware f√ºr die Newsvendor-Modellierung</a></li>
<li><a href="../de505592/index.html">Programmierung f√ºr BK0010 mit Android</a></li>
<li><a href="../de505594/index.html">So verwandeln Sie einen Website-Besucher in einen Kunden: Eine Anleitung zum Erstellen von Lead-Formularen</a></li>
<li><a href="../de505604/index.html">Suchtanf√§lligkeit</a></li>
<li><a href="../de505608/index.html">Vuex - l√∂sen Sie einen alten Streit mit neuen Methoden</a></li>
<li><a href="../de505612/index.html">MK-61: Verlauf, Emulation, Ger√§t</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>