<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏽 📿 👩🏼‍🤝‍👨🏽 Volver a comprobar Newton Game Dynamics con el analizador estático PVS-Studio 👩🏿‍🔬 👨🏾‍🌾 🐋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, en Internet, descubrí el motor de física Newton Game Dynamics. Sabiendo que tales proyectos generalmente tienen una gran cantidad de có...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Volver a comprobar Newton Game Dynamics con el analizador estático PVS-Studio</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/498180/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/uy/ni/sz/uynisz7isgxhs8jv2xqvrxxlyyg.png" alt="Foto 1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente, en Internet, descubrí el motor de física Newton Game Dynamics. </font><font style="vertical-align: inherit;">Sabiendo que tales proyectos generalmente tienen una gran cantidad de código complejo, pensé que sería interesante verificarlo con el analizador estático PVS-Studio. </font><font style="vertical-align: inherit;">Mi entusiasmo fue estimulado aún más por el hecho de que mi colega Andrei Karpov ya probó este proyecto en 2014, lo que significa que también es una buena oportunidad para demostrar el desarrollo de nuestro analizador en los últimos seis años. </font><font style="vertical-align: inherit;">También vale la pena señalar que en el momento de escribir este artículo, la última versión de Newton Game Dynamics está fechada el 27 de febrero de 2020, es decir, este proyecto también se está desarrollando activamente durante los últimos 6 años. </font><font style="vertical-align: inherit;">Por lo tanto, espero que, además de nuestro equipo, este artículo sea de interés para los desarrolladores del motor, que podrán eliminar algunos errores y corregir su código.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salida del analizador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En 2014, PVS-Studio emitió:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48 alertas de primer nivel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79 segundo nivel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">261 tercer nivel.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para 2020, sin embargo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">124 advertencias de primer nivel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">272 segundo nivel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">787 del tercer nivel (entre los cuales también hay otros interesantes).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay advertencias mucho más interesantes que en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el artículo de Andrey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero las </font><font style="vertical-align: inherit;">estudiaremos con más detalle.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripción de advertencias</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia N1</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
V519 A la variable 'tmp [i] [2]' se le asignan valores dos veces seguidas. </font><font style="vertical-align: inherit;">Quizás esto sea un error. </font><font style="vertical-align: inherit;">Verifique las líneas: 468, 469. dgCollisionConvexHull.cpp 469</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dgCollisionConvexHull::Create</span> <span class="hljs-params">(dgInt32 count,....)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-function">dgStack&lt;dgVector&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-number">3</span> * count)</span></span>;
  <span class="hljs-keyword">for</span> (dgInt32 i = <span class="hljs-number">0</span>; i &lt; count; i ++) <font></font>
  {<font></font>
    tmp[i][<span class="hljs-number">0</span>] = dgFloat32 (buffer[i*<span class="hljs-number">3</span> + <span class="hljs-number">0</span>]);<font></font>
    tmp[i][<span class="hljs-number">1</span>] = dgFloat32 (buffer[i*<span class="hljs-number">3</span> + <span class="hljs-number">1</span>]);<font></font>
    tmp[i][<span class="hljs-number">2</span>] = dgFloat32 (buffer[i*<span class="hljs-number">3</span> + <span class="hljs-number">2</span>]);<font></font>
    tmp[i][<span class="hljs-number">2</span>] = dgFloat32 (<span class="hljs-number">0.0f</span>);<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El elemento de matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp [i] [2] se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicializa dos veces seguidas. Muy a menudo, dicho código habla de copiar y pegar. Puede solucionar esto eliminando la inicialización innecesaria si no es necesaria, o reemplazando el índice de matriz por uno posterior; esto ya depende del valor de la variable de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conteo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Además, me gustaría describir otra advertencia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que Andrei no tiene en el artículo, pero tiene nuestra </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base de datos de errores</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V519 Al objeto 'húmedo' se le asignan valores dos veces sucesivamente. Quizás esto sea un error. física dgbody.cpp 404</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dgBody::AddBuoyancyForce</span> <span class="hljs-params">(....)</span>
</span>{<font></font>
  ....<font></font>
  damp = (m_omega % m_omega) * dgFloat32 (<span class="hljs-number">10.0f</span>) *<font></font>
        fluidAngularViscousity; <font></font>
  damp = GetMax (GetMin ((m_omega % m_omega) * <font></font>
       dgFloat32 (<span class="hljs-number">1000.0f</span>) * <font></font>
       fluidAngularViscousity, dgFloat32(<span class="hljs-number">0.25f</span>)), <font></font>
       dgFloat32(<span class="hljs-number">2.0f</span>));<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo admito, no encontré este error en el registro del analizador. Además, no he encontrado el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddBuoyancyForce</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> función </font><font style="vertical-align: inherit;">en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dgbody.cpp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto es normal: si los nuevos ejemplos de errores encontrados utilizando las advertencias de nuestro analizador son un indicador del desarrollo de PVS-Studio, entonces la ausencia de errores encontrados anteriormente en el proyecto es un indicador del desarrollo del proyecto. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un pequeño tema</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
no creo que diga que los siguientes fragmentos de código contienen errores o no funcionan según lo esperado por el programador, pero se comportan de manera bastante sospechosa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El analizador emitió dos advertencias para este fragmento de código: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V621 Considere inspeccionar el operador 'para'. Es posible que el bucle se ejecute incorrectamente o no se ejecute en absoluto. MultiBodyCar.cpp 942</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V654 La condición 'i &lt;count' del bucle siempre es falsa. </font><font style="vertical-align: inherit;">MultiBodyCar.cpp 942</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MultibodyBodyCar</span><span class="hljs-params">(DemoEntityManager* <span class="hljs-keyword">const</span> scene)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<font></font>
  count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) <font></font>
  {<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; count; j++) <font></font>
    {<font></font>
      <span class="hljs-function">dMatrix <span class="hljs-title">offset</span><span class="hljs-params">(location)</span></span>;<font></font>
      offset.m_posit += dVector (j * <span class="hljs-number">5.0f</span> + <span class="hljs-number">4.0f</span>, <span class="hljs-number">0.0f</span>, i * <span class="hljs-number">5.0f</span>, <span class="hljs-number">0.0f</span>);
      <span class="hljs-comment">//manager-&gt;CreateSportCar(offset, viperModel.GetData());</span><font></font>
      manager-&gt;CreateOffRoadCar(offset, monsterTruck.GetData());<font></font>
    }<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quizás este código se usa para depurar, luego apagar el bucle parece un movimiento normal. </font><font style="vertical-align: inherit;">También se descubrieron otros puntos similares: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V519 A la variable 'ret' se le asignan valores dos veces seguidas. </font><font style="vertical-align: inherit;">Quizás esto sea un error. Verifique las líneas: 325, 326. dString.cpp 326</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dString::LoadFile</span> <span class="hljs-params">(FILE* <span class="hljs-keyword">const</span> file)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">size_t</span> ret = fread(m_string, <span class="hljs-number">1</span>, size, file);<font></font>
  ret = <span class="hljs-number">0</span>;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V519 A la variable 'ret' se le asignan valores dos veces seguidas. Quizás sea un error. </font><font style="vertical-align: inherit;">Líneas de verificación: 1222, 1223. DemoEntityManager.cpp 1223</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DemoEntityManager::DeserializeFile</span> <span class="hljs-params">(....)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">size_t</span> ret = fread(buffer, size, <span class="hljs-number">1</span>, (FILE*) serializeHandle);<font></font>
  ret = <span class="hljs-number">0</span>;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V560 Una parte de la expresión condicional siempre es verdadera: (cuenta &lt;10). </font><font style="vertical-align: inherit;">dMathDefines.h 726</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dCholeskyWithRegularizer</span><span class="hljs-params">(....)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (!pass &amp;&amp; (count &lt; <span class="hljs-number">10</span>))<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
} </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V654 La condición 'ptr! = Edge' del bucle siempre es falsa. </font><font style="vertical-align: inherit;">dgPolyhedra.cpp 1571</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dgPolyhedra::Triangulate</span> <span class="hljs-params">(....)</span>
</span>{<font></font>
  ....<font></font>
  ptr = edge;<font></font>
  ....<font></font>
  <span class="hljs-keyword">while</span> (ptr != edge);<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El parámetro 'count' V763 siempre se reescribe en el cuerpo de la función antes de usarse. </font><font style="vertical-align: inherit;">ConvexCast.cpp 31</font></font><br>
<br>
<pre><code class="cpp hljs">StupidComplexOfConvexShapes (...., <span class="hljs-keyword">int</span> count)<font></font>
{<font></font>
  count = <span class="hljs-number">40</span>;
  <span class="hljs-comment">//count = 1;</span><font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V547 La expresión 'axisCount' siempre es falsa. </font><font style="vertical-align: inherit;">MultiBodyCar.cpp 650</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateDriverInput</span><span class="hljs-params">(dVehicle* <span class="hljs-keyword">const</span> vehicle, dFloat timestep)</span> 
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">int</span> axisCount = scene-&gt;GetJoystickAxis(axis);<font></font>
  axisCount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (axisCount)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente, muchos dirán que al hacer un cambio en el código almacenado en el dominio público, al menos debe escribir un comentario. </font><font style="vertical-align: inherit;">Bueno, estoy de acuerdo. </font><font style="vertical-align: inherit;">Algunas cosas que podrían usarse sin dolor en un proyecto de mascotas, en mi opinión, son inaceptables en el código que utilizará una gran cantidad de personas. </font><font style="vertical-align: inherit;">Sin embargo, la elección depende de los autores. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia N2</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
V769 El puntero 'resultado' en la expresión 'resultado + i' es igual a nullptr. </font><font style="vertical-align: inherit;">El valor resultante no tiene sentido y no debe usarse. </font><font style="vertical-align: inherit;">win32_monitor.c 286</font></font><br>
<br>
<pre><code class="cpp hljs">GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, <span class="hljs-keyword">int</span>* count)<font></font>
{<font></font>
  GLFWvidmode* result = <span class="hljs-literal">NULL</span>;<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;  i &lt; *count;  i++)<font></font>
    {<font></font>
    <span class="hljs-keyword">if</span> (_glfwCompareVideoModes(result + i, &amp;mode) == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema es que el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><i><font style="vertical-align: inherit;">ha</font></i><font style="vertical-align: inherit;"> cambiado desde la inicialización. </font><font style="vertical-align: inherit;">El puntero resultante no tendrá sentido, no se puede usar. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia N3, N4, N5</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
V778 Se encontraron dos fragmentos de código similares. </font><font style="vertical-align: inherit;">Quizás, este es un error tipográfico y se debe usar la variable 'm_colorChannel' en lugar de 'm_binormalChannel'. </font><font style="vertical-align: inherit;">dgMeshEffect1.cpp 1887</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dgMeshEffect::EndBuildFace</span> <span class="hljs-params">()</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">if</span> (m_attrib.m_binormalChannel.m_count) &lt;=<font></font>
  {<font></font>
    attibutes.m_binormalChannel.<font></font>
      PushBack(m_attrib.m_binormalChannel[m_constructionIndex + i]);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span> (m_attrib.m_binormalChannel.m_count) &lt;= <font></font>
  {<font></font>
    attibutes.m_colorChannel.<font></font>
      PushBack(m_attrib.m_colorChannel[m_constructionIndex + i]);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que el programador ha copiado dos condiciones. </font><font style="vertical-align: inherit;">El segundo debería verse así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (m_attrib.m_colorChannel.m_count) &lt;= <font></font>
{<font></font>
  attibutes.m_colorChannel.<font></font>
  PushBack(m_attrib.m_colorChannel[m_constructionIndex + i]);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También se encontró otro error muy similar: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V524 Es extraño que el cuerpo de la función 'EnabledAxis1' sea completamente equivalente al cuerpo de la función 'EnabledAxis0'. </font><font style="vertical-align: inherit;">dCustomDoubleHingeActuator.cpp 88</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dCustomDoubleHingeActuator::EnabledAxis0</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> state)</span>
</span>{<font></font>
  m_axis0Enable = state;  &lt;=<font></font>
}<font></font>
<span class="hljs-keyword">void</span> dCustomDoubleHingeActuator::EnabledAxis1(<span class="hljs-keyword">bool</span> state)<font></font>
{<font></font>
  m_axis0Enable = state;  &lt;=<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí el código debe arreglarse así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dCustomDoubleHingeActuator::EnabledAxis1</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> state)</span>
</span>{<font></font>
  m_axis1Enable = state;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra copia y pega: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V525 El código contiene la colección de bloques similares. </font><font style="vertical-align: inherit;">Verifique los elementos 'm_x', 'm_y', 'm_y' en las líneas 73, 74, 75. dWoodFracture.cpp 73</font></font><br>
<br>
<pre><code class="cpp hljs">WoodVoronoidEffect(....)<font></font>
{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i ++) <font></font>
  {<font></font>
    dFloat x = dGaussianRandom(size.m_x * <span class="hljs-number">0.1f</span>);<font></font>
    dFloat y = dGaussianRandom(size.m_y * <span class="hljs-number">0.1f</span>);  &lt;=<font></font>
    dFloat z = dGaussianRandom(size.m_y * <span class="hljs-number">0.1f</span>);  &lt;=<font></font>
  ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo más probable es que la inicialización de la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se vea así:</font></font><br>
<br>
<pre><code class="cpp hljs">dFloat z = dGaussianRandom(size.m_z * <span class="hljs-number">0.1f</span>); </code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencias N6, N7</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En Newton Game Dynamics, como en casi cualquier proyecto grande de C o C ++, hubo algunas advertencias sobre el trabajo inseguro con punteros. </font><font style="vertical-align: inherit;">Tales errores son a menudo muy difíciles de encontrar y depurar; causan bloqueos del programa; en general, son muy peligrosos e impredecibles. </font><font style="vertical-align: inherit;">Afortunadamente, nuestro analizador puede detectar muchos de estos errores. </font><font style="vertical-align: inherit;">Parece obvio que es mejor escribir un cheque una vez y no tomar un baño de vapor, que pasar mucho tiempo reproduciendo el problema, encontrando el lugar del problema en el código y depurándolo. </font><font style="vertical-align: inherit;">Estas son algunas de las advertencias: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V522 Puede haber una desreferenciación de una 'cara' de puntero nulo potencial. </font><font style="vertical-align: inherit;">dgContactSolver.cpp 351</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">DG_INLINE dgMinkFace* <span class="hljs-title">dgContactSolver::AddFace</span><span class="hljs-params">(dgInt32 v0,dgInt32 v1,
                                               dgInt32 v2)</span>
</span>{<font></font>
  dgMinkFace* <span class="hljs-keyword">const</span> face = NewFace();<font></font>
  face-&gt;m_mark = <span class="hljs-number">0</span>; <font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La definición de la función NewFace es pequeña, así que la daré completa:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">DG_INLINE dgMinkFace* <span class="hljs-title">dgContactSolver::NewFace</span><span class="hljs-params">()</span>
</span>{<font></font>
  dgMinkFace* face = (dgMinkFace*)m_freeFace;<font></font>
  <span class="hljs-keyword">if</span> (m_freeFace) <font></font>
  {<font></font>
    m_freeFace = m_freeFace-&gt;m_next;<font></font>
  } <span class="hljs-keyword">else</span> <font></font>
  {<font></font>
    face = &amp;m_facePool[m_faceIndex];<font></font>
    m_faceIndex++;<font></font>
    <span class="hljs-keyword">if</span> (m_faceIndex &gt;= DG_CONVEX_MINK_MAX_FACES) <font></font>
    {<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
  }<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _DEBUG</span>
    <span class="hljs-built_in">memset</span>(face, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (dgMinkFace));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">return</span> face;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las funciones de los puntos de salida </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewFace</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , si se produce una desreferencia de puntero nulo devuelto y habrá un comportamiento indefinido del programa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También hay una advertencia similar a una pieza de código más peligrosa: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V522 Puede haber una desreferenciación de un 'perímetro' de puntero nulo potencial. </font><font style="vertical-align: inherit;">dgPolyhedra.cpp 2541</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dgPolyhedra::PolygonizeFace</span><span class="hljs-params">(....)</span>
</span>{<font></font>
  ....<font></font>
  dgEdge* <span class="hljs-keyword">const</span> perimeter = flatFace.AddHalfEdge<font></font>
                           (edge1-&gt;m_next-&gt;m_incidentVertex,<font></font>
                            edge1-&gt;m_incidentVertex);<font></font>
  perimeter-&gt;m_twin = edge1;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está la definición de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddHalfEdge</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">dgEdge* <span class="hljs-title">dgPolyhedra::AddHalfEdge</span> <span class="hljs-params">(dgInt32 v0, dgInt32 v1)</span>
</span>{
  <span class="hljs-keyword">if</span> (v0 != v1) <font></font>
  {<font></font>
    <span class="hljs-function">dgPairKey <span class="hljs-title">pairKey</span> <span class="hljs-params">(v0, v1)</span></span>;
    <span class="hljs-function">dgEdge <span class="hljs-title">tmpEdge</span> <span class="hljs-params">(v0, <span class="hljs-number">-1</span>)</span></span>;<font></font>
    dgTreeNode* node = Insert (tmpEdge, pairKey.GetVal()); <font></font>
    <span class="hljs-keyword">return</span> node ? &amp;node-&gt;GetInfo() : <span class="hljs-literal">NULL</span>;<font></font>
  } <span class="hljs-keyword">else</span> <font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el valor de retorno en dos puntos de los tres posibles puntos de salida de la función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En total, recibí 48 advertencias </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V522</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En su mayor parte, son del mismo tipo, por lo que no veo ninguna razón para describir más en el marco de este artículo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia N8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
V668 No tiene sentido probar el puntero 'pBits' contra nulo, ya que la memoria se asignó utilizando el operador 'nuevo'. La excepción se generará en caso de error de asignación de memoria. TargaToOpenGl.cpp 166</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> pBits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [width * height * <span class="hljs-number">4</span>];
<span class="hljs-keyword">if</span>(pBits == <span class="hljs-literal">NULL</span>) <font></font>
{<font></font>
  fclose(pFile);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El analizador detectó una situación en la que el valor del puntero devuelto por el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador </font><font style="vertical-align: inherit;">se compara con cero. </font><font style="vertical-align: inherit;">Como regla, esto significa que el programa, si es imposible asignar memoria, se comportará de manera diferente a lo que el programador espera. </font><font style="vertical-align: inherit;">Si el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador </font><font style="vertical-align: inherit;">no pudo asignar memoria, entonces, de acuerdo con el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estándar del</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lenguaje </font><i><font style="vertical-align: inherit;">C ++</font></i><font style="vertical-align: inherit;"> , se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">produce</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> una excepción </font><i><font style="vertical-align: inherit;">std :: bad_alloc (). </font></i><font style="vertical-align: inherit;">Por lo tanto, la condición nunca se cumplirá. </font><font style="vertical-align: inherit;">Claramente, este no es el comportamiento con el que contaba el programador. </font><font style="vertical-align: inherit;">Planeaba cerrar el archivo en caso de un error de asignación de memoria. </font><font style="vertical-align: inherit;">Esto no sucederá y se producirá una fuga de recursos. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencias N9, N10, N11</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V764 Posible orden incorrecto de argumentos pasados ​​a la función 'CreateWheel': 'altura' y 'radio'. </font><font style="vertical-align: inherit;">StandardJoints.cpp 791</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V764 Posible orden incorrecto de argumentos pasados ​​a la función 'CreateWheel': 'altura' y 'radio'. </font><font style="vertical-align: inherit;">StandardJoints.cpp 833</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V764 Posible orden incorrecto de argumentos pasados ​​a la función 'CreateWheel': 'altura' y 'radio'. </font><font style="vertical-align: inherit;">StandardJoints.cpp 884</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ven las llamadas a funciones:</font></font><br>
<br>
<pre><code class="cpp hljs">NewtonBody* <span class="hljs-keyword">const</span> wheel = CreateWheel (scene, origin, height, radius);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ve la declaración de función:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> NewtonBody* <span class="hljs-title">CreateWheel</span> <span class="hljs-params">(DemoEntityManager* <span class="hljs-keyword">const</span> scene,
  <span class="hljs-keyword">const</span> dVector&amp; location, dFloat radius, dFloat height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este diagnóstico sugiere que al llamar a funciones, quizás los argumentos se confundieron. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencias N12, N13</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El analizador emitió advertencias para dos métodos similares con nombres diferentes: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V621 Considere la posibilidad de inspeccionar el operador 'para'. Es posible que el bucle se ejecute incorrectamente o no se ejecute en absoluto. dgCollisionUserMesh.cpp 161 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V621 Considere inspeccionar el operador 'for'. Es posible que el bucle se ejecute incorrectamente o no se ejecute en absoluto. dgCollisionUserMesh.cpp 236</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dgCollisionUserMesh::GetCollidingFacesContinue</span>
    <span class="hljs-params">(dgPolygonMeshDesc* <span class="hljs-keyword">const</span> data)</span> <span class="hljs-keyword">const</span>
</span>{<font></font>
  ....<font></font>
  data-&gt;m_faceCount = <span class="hljs-number">0</span>; &lt;=<font></font>
  data-&gt;m_userData = m_userData;<font></font>
  data-&gt;m_separationDistance = dgFloat32(<span class="hljs-number">0.0f</span>);<font></font>
  m_collideCallback(&amp;data-&gt;m_p0, <span class="hljs-literal">NULL</span>);<font></font>
  dgInt32 faceCount0 = <span class="hljs-number">0</span>;<font></font>
  dgInt32 faceIndexCount0 = <span class="hljs-number">0</span>;<font></font>
  dgInt32 faceIndexCount1 = <span class="hljs-number">0</span>;<font></font>
  dgInt32 stride = data-&gt;m_vertexStrideInBytes / <span class="hljs-keyword">sizeof</span>(dgFloat32);<font></font>
  dgFloat32* <span class="hljs-keyword">const</span> vertex = data-&gt;m_vertex;<font></font>
  dgInt32* <span class="hljs-keyword">const</span> address = data-&gt;m_meshData.m_globalFaceIndexStart;<font></font>
  dgFloat32* <span class="hljs-keyword">const</span> hitDistance = data-&gt;m_meshData.m_globalHitDistance;
  <span class="hljs-keyword">const</span> dgInt32* <span class="hljs-keyword">const</span> srcIndices = data-&gt;m_faceVertexIndex;<font></font>
  dgInt32* <span class="hljs-keyword">const</span> dstIndices = data-&gt;m_globalFaceVertexIndex;<font></font>
  dgInt32* <span class="hljs-keyword">const</span> faceIndexCountArray = data-&gt;m_faceIndexCount;
  <span class="hljs-keyword">for</span> (dgInt32 i = <span class="hljs-number">0</span>; (i &lt; data-&gt;m_faceCount)&amp;&amp;<font></font>
       (faceIndexCount0 &lt; (DG_MAX_COLLIDING_INDICES - <span class="hljs-number">32</span>));<font></font>
       i++)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dgCollisionUserMesh::GetCollidingFacesDescrete</span>
    <span class="hljs-params">(dgPolygonMeshDesc* <span class="hljs-keyword">const</span> data)</span> <span class="hljs-keyword">const</span>
</span>{<font></font>
  ....<font></font>
  data-&gt;m_faceCount = <span class="hljs-number">0</span>; &lt;=  <font></font>
  data-&gt;m_userData = m_userData;<font></font>
  data-&gt;m_separationDistance = dgFloat32(<span class="hljs-number">0.0f</span>);<font></font>
  m_collideCallback(&amp;data-&gt;m_p0, <span class="hljs-literal">NULL</span>);<font></font>
  dgInt32 faceCount0 = <span class="hljs-number">0</span>;<font></font>
  dgInt32 faceIndexCount0 = <span class="hljs-number">0</span>;<font></font>
  dgInt32 faceIndexCount1 = <span class="hljs-number">0</span>;<font></font>
  dgInt32 stride = data-&gt;m_vertexStrideInBytes / <span class="hljs-keyword">sizeof</span>(dgFloat32);<font></font>
  dgFloat32* <span class="hljs-keyword">const</span> vertex = data-&gt;m_vertex;<font></font>
  dgInt32* <span class="hljs-keyword">const</span> address = data-&gt;m_meshData.m_globalFaceIndexStart;<font></font>
  dgFloat32* <span class="hljs-keyword">const</span> hitDistance = data-&gt;m_meshData.m_globalHitDistance;
  <span class="hljs-keyword">const</span> dgInt32* <span class="hljs-keyword">const</span> srcIndices = data-&gt;m_faceVertexIndex;<font></font>
  dgInt32* <span class="hljs-keyword">const</span> dstIndices = data-&gt;m_globalFaceVertexIndex;<font></font>
  dgInt32* <span class="hljs-keyword">const</span> faceIndexCountArray = data-&gt;m_faceIndexCount;
  <span class="hljs-keyword">for</span> (dgInt32 i = <span class="hljs-number">0</span>; (i &lt; data-&gt;m_faceCount)&amp;&amp;<font></font>
       (faceIndexCount0 &lt; (DG_MAX_COLLIDING_INDICES - <span class="hljs-number">32</span>));<font></font>
       i++)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema en esta parte de la condición es: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i &lt;data-&gt; m_faceCount.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data-&gt; m_faceCount tiene</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignado 0, este bucle no se ejecutará ni una sola vez. Probablemente, al escribir este código, el programador olvidó reiniciar el campo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_faceCount</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y luego simplemente copió el cuerpo del método. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advertencia N14, N15</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El analizador emitió dos advertencias para líneas de código similares en sucesión: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V630 La función '_alloca' se usa para asignar memoria a una matriz de objetos que son clases que contienen constructores. dgSkeletonContainer.cpp 1341 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V630 La función '_alloca' se usa para asignar memoria a una matriz de objetos que son clases que contienen constructores. dgSkeletonContainer.cpp 1342</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> alloca _alloca</span><font></font>
....<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dAlloca(type,size) (type*) alloca ((size) * sizeof (type))</span><font></font>
....<font></font>
dgSpatialMatrix::dgSpatialMatrix();<font></font>
dgSpatialMatrix::dgSpatialMatrix(dgFloat32 val);<font></font>
....<font></font>
dgSpatialMatrix* <span class="hljs-keyword">const</span> bodyMassArray = dgAlloca(dgSpatialMatrix,<font></font>
                                                m_nodeCount);<font></font>
dgSpatialMatrix* <span class="hljs-keyword">const</span> jointMassArray = dgAlloca(dgSpatialMatrix,<font></font>
                                                 m_nodeCount); </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema con este fragmento de código es que funcionan con memoria asignada como una matriz de objetos que tienen un constructor o destructor. Con esta asignación de memoria para la clase, no se llamará al constructor. Al liberar memoria, no se llamará al destructor. Esto es extremadamente sospechoso. Tal código puede llevar a trabajar con variables no inicializadas y otros errores. Además, en comparación con el enfoque que usa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dicho código es malo ya que si intenta asignar más memoria de la que puede proporcionar la máquina, no recibirá un mensaje de error claro. En su lugar, obtiene un error de segmentación cuando intenta acceder a esta memoria. Aquí hay algunos mensajes más del analizador:</font></font><br>
<ul>
<li>V630 The '_alloca' function is used to allocate memory for an array of objects which are classes containing constructors. dVehicleSolver.cpp 498</li>
<li>V630 The '_alloca' function is used to allocate memory for an array of objects which are classes containing constructors. dVehicleSolver.cpp 499</li>
<li>V630 The '_alloca' function is used to allocate memory for an array of objects which are classes containing constructors. dVehicleSolver.cpp 1144</li>
<li>   10  .</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, PVS-Studio falló nuevamente, durante la verificación, se descubrieron nuevos errores interesantes. </font><font style="vertical-align: inherit;">Y esto significa que el analizador hace bien su trabajo, permitiéndonos hacer que el mundo que nos rodea sea un poco más perfecto. </font><font style="vertical-align: inherit;">Para probar el analizador estático PVS-Studio en su proyecto, puede hacer clic en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/eb2/f9c/3bb/eb2f9c3bb5f32f39239298d36431961c.png"></a></div><p></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si desea compartir este artículo con una audiencia de habla inglesa, utilice el enlace a la traducción: Vladislav Stolyarov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una segunda comprobación de la dinámica de juego de Newton con PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es498164/index.html">Estrategias de producto para costos de transición</a></li>
<li><a href="../es498168/index.html">Nuevas arquitecturas de redes neuronales</a></li>
<li><a href="../es498172/index.html">Java Digest para el 21 de abril</a></li>
<li><a href="../es498174/index.html">Cómo dejar de preocuparte y comenzar a creer en las pruebas A / B</a></li>
<li><a href="../es498178/index.html">Trabajamos desde casa: difusión de fotos</a></li>
<li><a href="../es498186/index.html">Servicios basados ​​en redes neuronales para diseñadores.</a></li>
<li><a href="../es498188/index.html">Teorías de probabilidad: preparación para una entrevista y resolución de "paradojas"</a></li>
<li><a href="../es498192/index.html">Bolsa de cosméticos con esteroides: XD Design Urban Bumbag Review</a></li>
<li><a href="../es498194/index.html">Localizador de servicios - Disipando mitos</a></li>
<li><a href="../es498196/index.html">FunCorp está buscando ingenieros de control de calidad: realice una entrevista y reciba una oferta el mismo día</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>