<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐛 ⛵️ 🕡 Accélérez votre recherche dans Have I Been Pwned à 49 microsecondes (C ++) 🧓🏾 👩🏿‍🏫 💗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je connais depuis longtemps le site Have I Been Pwned (HIBP) . Certes, jusqu'à récemment, il n'y était jamais allé. J'ai toujours eu deux mots de pass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Accélérez votre recherche dans Have I Been Pwned à 49 microsecondes (C ++)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/rg/hn/furghncw9u08teobuskqawx2y7u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je connais depuis longtemps le site </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have I Been Pwned (HIBP)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Certes, jusqu'à récemment, il n'y était jamais allé. J'ai toujours eu deux mots de passe. L'un d'eux a été utilisé à plusieurs reprises pour le courrier poubelle et quelques comptes sur des sites étranges. Mais j'ai dû refuser, car le courrier a été piraté. Et pour être honnête, je suis reconnaissant au pirate informatique parce que cet événement m'a fait revoir mes mots de passe - la façon dont je les utilise et les stocke. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, j'ai changé de mot de passe sur tous les comptes où il y avait un mot de passe compromis. Ensuite, je me suis demandé si le mot de passe divulgué se trouvait dans la base de données HIBP. Je ne voulais pas entrer le mot de passe sur le site, j'ai donc téléchargé la base de données (</font></font><code>pwned-passwords-sha1-ordered-by-count-v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">La base est très impressionnante. </font><font style="vertical-align: inherit;">Il s'agit d'un fichier texte de 22,8 Go avec un ensemble de hachages SHA-1, un dans chaque ligne avec un compteur, combien de fois le mot de passe avec ce hachage s'est produit dans les fuites. </font><font style="vertical-align: inherit;">J'ai trouvé le SHA-1 de mon mot de passe fissuré et j'ai essayé de le trouver.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[G] représentant</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure de Trie</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche binaire</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi revenir en arrière?</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallélisme</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne sois pas un salaud égoïste</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B3</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri par insertion</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Séparé ou non?</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriétés de l'arborescence HIBP</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fichier de sortie</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repères</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">okon - bibliothèque et CLI</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens et discussion</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci d'avoir lu</font></font></a></li>
</ul><br>
<a name="1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[G] représentant</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons un fichier texte avec un hachage dans chaque ligne. </font><font style="vertical-align: inherit;">Le meilleur endroit où aller est probablement grep. </font></font><br>
<br>
<code>grep -m 1 '^XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' pwned-passwords-sha1-ordered-by-count-v5.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon mot de passe était en haut de la liste avec une fréquence de plus de 1500 fois, donc ça craint vraiment. </font><font style="vertical-align: inherit;">En conséquence, les résultats de la recherche sont revenus presque instantanément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais tout le monde n'a pas des mots de passe faibles. </font><font style="vertical-align: inherit;">Je voulais vérifier combien de temps il faudrait pour trouver le pire des cas - le dernier hachage du fichier: </font></font><br>
<br>
<code>time grep -m 1 '^4541A1E4605EEBF3F4C166329C18502DF75D348A' pwned-passwords-sha1-ordered-by-count-v5.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Résultat: </font></font><code>33,35s user 23,39s system 41% cpu 2:15,35 total</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c'est triste. </font><font style="vertical-align: inherit;">Après tout, comme mon courrier a été piraté, je voulais vérifier la présence de tous mes anciens et nouveaux mots de passe dans la base de données. </font><font style="vertical-align: inherit;">Mais un grep de deux minutes ne vous permet tout simplement pas de le faire confortablement. </font><font style="vertical-align: inherit;">Bien sûr, je pourrais écrire un script, l'exécuter et faire une promenade, mais ce n'est pas une option. </font><font style="vertical-align: inherit;">Je voulais trouver une meilleure solution et apprendre quelque chose.</font></font><br>
<br>
<a name="2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure de Trie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première idée était d'utiliser une structure de données trie. La structure semble idéale pour stocker les hachages SHA-1. L'alphabet est petit, donc les nœuds seront également petits, tout comme le fichier résultant. Peut-être qu'il tient même dans la RAM? La recherche de clés doit être très rapide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai donc mis en place cette structure. Il a ensuite pris les 1 000 000 premiers hachages de la base de données source pour créer le fichier résultant et vérifier si tout se trouve dans le fichier créé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, je pouvais tout trouver dans le fichier, donc la structure fonctionnait bien. Le problème était différent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier résultant a été publié au format 2283686592B (2,2 Go). Ce n'est pas bien. Comptons et voyons ce qui se passe. Un nœud est une structure simple de seize valeurs 32 bits. Les valeurs sont des "pointeurs" vers les nœuds suivants avec le symbole de hachage SHA-1 spécifié. Ainsi, un nœud prend 16 * 4 octets = 64 octets. Ça semble un peu? Mais si vous y réfléchissez, un nœud représente un caractère dans un hachage. Ainsi, dans le pire des cas, le hachage SHA-1 prendra 40 * 64 octets = 2560 octets. C'est bien pire, par exemple, une représentation textuelle d'un hachage qui ne prend que 40 octets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure trie a l'avantage de réutiliser les nœuds. Si vous avez deux mots </font></font><code>aaa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>abb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le nœud des premiers caractères est réutilisé, car les caractères sont les mêmes - </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons à notre problème. </font><font style="vertical-align: inherit;">Calculons le nombre de nœuds stockés dans le fichier résultant: </font></font><code>file_size / node_size = 2283686592 / 64 = 35682603</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant combien de nœuds seront créés dans le pire des cas à partir d'un million de hachages: </font></font><code>1000000 * 40 = 40000000</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la structure du trie ne réutilise que des </font></font><code>40000000 - 35682603 = 4317397</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nœuds, ce qui représente 10,8% du pire des scénarios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec de tels indicateurs, le fichier résultant pour l'ensemble de la base de données HIBP prendrait 1421513361920 octets (1,02 To). </font><font style="vertical-align: inherit;">Je n'ai même pas assez de disque dur pour vérifier la vitesse de recherche des clés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce jour-là, j'ai découvert que la structure du trie ne convient pas aux données relativement aléatoires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cherchons une autre solution.</font></font><br>
<br>
<a name="3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche binaire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les hachages SHA-1 ont deux fonctionnalités intéressantes: ils sont comparables les uns aux autres et ils sont tous de la même taille. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce à cela, nous pouvons traiter la base de données HIBP d'origine et créer un fichier à partir des valeurs SHA-1 triées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comment trier un fichier de 22 Go? </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi trier le fichier source? </font><font style="vertical-align: inherit;">HIBP renvoie un fichier avec des chaînes déjà triées par hachage. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réponse. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'y ai tout simplement pas pensé. </font><font style="vertical-align: inherit;">À ce moment, je ne connaissais pas le fichier trié.</font></font></i> <br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trier tous les hachages en RAM n'est pas une option, je n'ai pas beaucoup de RAM. </font><font style="vertical-align: inherit;">La solution était la suivante:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divisez un gros fichier en plus petits qui tiennent dans la RAM.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez des données à partir de petits fichiers, triez-les en RAM et réécrivez-les dans des fichiers.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinez tous les petits fichiers triés en un seul grand.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec un gros fichier trié, vous pouvez rechercher notre hachage en utilisant une recherche binaire. </font><font style="vertical-align: inherit;">L'accès au disque dur est important. </font><font style="vertical-align: inherit;">Calculons le nombre de hits nécessaires dans une recherche binaire: </font></font><code>log2(555278657) = 29.0486367039</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 hits. </font><font style="vertical-align: inherit;">Pas si mal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au premier stade, l'optimisation peut être effectuée. </font><font style="vertical-align: inherit;">Convertissez les hachages de texte en données binaires. </font><font style="vertical-align: inherit;">Cela réduira de moitié la taille des données obtenues: de 22 à 11 Go. </font><font style="vertical-align: inherit;">Bien.</font></font><br>
<br>
<a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi revenir en arrière?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce moment, j'ai réalisé que vous pouvez faire plus intelligemment. </font><font style="vertical-align: inherit;">Que faire si vous ne combinez pas de petits fichiers en un seul grand, mais effectuez une recherche binaire dans de petits fichiers triés en RAM? </font><font style="vertical-align: inherit;">Le problème est de savoir comment trouver le fichier souhaité dans lequel rechercher la clé. </font><font style="vertical-align: inherit;">La solution est très simple. </font><font style="vertical-align: inherit;">Nouvelle approche:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez 256 fichiers avec les noms "00" ... "FF".</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous lisez des hachages à partir d'un fichier volumineux, écrivez des hachages commençant par «00 ..» dans un fichier appelé «00», des hachages commençant par «01 ..» - dans un fichier «01» et ainsi de suite.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez des données à partir de petits fichiers, triez-les en RAM et réécrivez-les dans des fichiers.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est très simple. </font><font style="vertical-align: inherit;">De plus, une autre option d'optimisation apparaît. </font><font style="vertical-align: inherit;">Si le hachage est stocké dans le fichier "00", alors nous savons qu'il commence par "00". </font><font style="vertical-align: inherit;">Si le hachage est stocké dans le fichier "F2", il commence par "F2". </font><font style="vertical-align: inherit;">Ainsi, lors de l'écriture de hachages dans de petits fichiers, nous pouvons omettre le premier octet de chaque hachage! </font><font style="vertical-align: inherit;">Cela représente 5% de toutes les données. </font><font style="vertical-align: inherit;">555 Mo sont enregistrés au total.</font></font><br>
<br>
<a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallélisme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La séparation en fichiers plus petits offre une autre opportunité d'optimisation. </font><font style="vertical-align: inherit;">Les fichiers sont indépendants les uns des autres, nous pouvons donc les trier en parallèle. </font><font style="vertical-align: inherit;">Nous nous souvenons que tous vos processeurs aiment transpirer en même temps;)</font></font><br>
<br>
<a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne sois pas un salaud égoïste</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque j'ai implémenté la solution ci-dessus, j'ai réalisé que d'autres personnes avaient probablement un problème similaire. Beaucoup d'autres téléchargent et recherchent également la base de données HIBP. J'ai donc décidé de partager mon travail. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant cela, j'ai à nouveau révisé mon approche et trouvé quelques problèmes que je voudrais résoudre avant de publier le code et les outils sur Github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement, en tant qu'utilisateur final, je ne voudrais pas utiliser un outil qui crée beaucoup de fichiers étranges avec des noms étranges, dans lesquels on ne sait pas ce qui est stocké, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, cela peut être résolu en combinant les fichiers "00" .. "FF" dans un gros fichier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, avoir un seul gros fichier pour le tri pose un nouveau problème. </font><font style="vertical-align: inherit;">Et si je veux insérer un hachage dans ce fichier? </font><font style="vertical-align: inherit;">Un seul hachage. </font><font style="vertical-align: inherit;">Ce n'est que 20 octets. </font><font style="vertical-align: inherit;">Oh, le hachage commence par "000000000 ..". </font><font style="vertical-align: inherit;">D'accord. </font><font style="vertical-align: inherit;">Libérons de l'espace pour cela en déplaçant 11 Go d'autres hachages ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous comprenez quel est le problème. </font><font style="vertical-align: inherit;">L'insertion de données au milieu d'un fichier n'est pas l'opération la plus rapide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre inconvénient de cette approche est que vous devez à nouveau stocker les premiers octets - il s'agit de 555 Mo de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, la recherche binaire sur les données stockées sur votre disque dur est beaucoup plus lente que l'accès à la RAM. </font><font style="vertical-align: inherit;">Je veux dire, c'est 30 lectures de disque contre 0 lecture de disque.</font></font><br>
<br>
<a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B3</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore. </font><font style="vertical-align: inherit;">Ce que nous avons et ce que nous voulons réaliser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons 11 Go de valeurs binaires. </font><font style="vertical-align: inherit;">Toutes les valeurs sont comparables et ont la même taille. </font><font style="vertical-align: inherit;">Nous voulons savoir si une clé particulière est présente dans les données stockées, et voulons également changer la base de données. </font><font style="vertical-align: inherit;">Et pour que tout fonctionne rapidement. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/18c/851/d23/18c851d23c6bbe290fcccb763c6f09eb.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B-arbre? </font><font style="vertical-align: inherit;">Droite </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'arbre B vous permet de minimiser l'accès au disque lors de la recherche, de la modification, etc. Il a beaucoup plus de fonctionnalités, mais nous avons besoin de ces deux.</font></font><br>
<br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri par insertion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première étape consiste à convertir les données du fichier source HIBP en B-tree. Cela signifie que vous devez extraire tous les hachages tour à tour et les insérer dans la structure. L'algorithme d'insertion habituel convient pour cela. Mais dans notre cas, vous pouvez faire mieux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'insertion d'un grand nombre de données brutes dans un arbre B est un scénario bien connu. Les sages ont inventé une meilleure approche pour cela que l'insert habituel. Tout d'abord, vous devez trier les données. Cela peut être fait comme décrit ci-dessus (divisez le fichier en plus petits et triez-les dans la RAM). Insérez ensuite les données dans l'arborescence.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'algorithme habituel, si vous trouvez le nœud feuille où vous souhaitez insérer la valeur et qu'il est rempli, vous créez un nouveau nœud (à droite) et répartissez uniformément les valeurs entre les deux nœuds, à gauche et à droite (plus une valeur va au nœud parent mais ce n'est pas important ici). En bref, les valeurs du nœud gauche sont toujours inférieures aux valeurs de droite. Le fait est que lorsque vous insérez les données triées, vous savez que les petites valeurs ne seront plus insérées dans l'arborescence, donc plus aucune valeur n'ira au nœud de gauche. Le nœud gauche reste à moitié vide tout le temps. De plus, si vous insérez suffisamment de valeurs, vous pouvez constater que le nœud droit est plein, vous devez donc déplacer la moitié des valeurs vers le nouveau nœud droit. Le nœud divisé reste à moitié vide, comme dans le cas précédent. Etc…</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, après toutes les insertions, vous obtenez un arbre dans lequel presque tous les nœuds sont à moitié vides. </font><font style="vertical-align: inherit;">Ce n'est pas une utilisation très efficace de l'espace. </font><font style="vertical-align: inherit;">On peut faire mieux.</font></font><br>
<br>
<a name="10"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Séparé ou non?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de l'insertion de données triées, vous pouvez apporter une petite modification à l'algorithme d'insertion. </font><font style="vertical-align: inherit;">Si le nœud dans lequel vous souhaitez coller la valeur est plein, ne le cassez pas. </font><font style="vertical-align: inherit;">Créez simplement un nouveau nœud vide et collez la valeur dans le nœud parent. </font><font style="vertical-align: inherit;">Ensuite, lorsque vous insérez les valeurs suivantes (qui sont plus grandes que les précédentes), vous les insérez dans un nouveau nœud vide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour conserver les propriétés de l'arbre B, après toutes les insertions, il est nécessaire de trier les nœuds les plus à droite de chaque couche de l'arbre (sauf la racine) et de diviser uniformément les valeurs de ce nœud extrême et de son voisin gauche. </font><font style="vertical-align: inherit;">Vous obtenez donc le plus petit arbre possible.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriétés de l'arborescence HIBP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la conception d'un arbre B, vous devez sélectionner son ordre. </font><font style="vertical-align: inherit;">Il montre combien de valeurs peuvent être stockées dans un nœud, ainsi que le nombre d'enfants que le nœud peut avoir. </font><font style="vertical-align: inherit;">En manipulant ce paramètre, nous pouvons manipuler la hauteur de l'arbre, la taille binaire du nœud, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans HIBP, nous avons des </font></font><code>555278657</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hachages. </font><font style="vertical-align: inherit;">Supposons que nous voulons un arbre de trois hauteurs (nous n'avons donc pas besoin de plus de trois opérations de lecture pour vérifier la présence d'un hachage). </font><font style="vertical-align: inherit;">Nous devons trouver une valeur de M telle que </font></font><code>logM(555278657) &lt; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">J'ai choisi 1024. Ce n'est pas la plus petite valeur possible, mais cela permet d'insérer plus de hachages et de conserver la hauteur de l'arbre.</font></font><br>
<br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fichier de sortie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier source HIBP a une taille de 22,8 Go. </font><font style="vertical-align: inherit;">Le fichier de sortie avec l'arborescence B est de 12,4 Go. </font><font style="vertical-align: inherit;">Il faut environ 11 minutes pour le créer sur ma machine (Intel Core i7-6700, 3,4 GHz, 16 Go de RAM), disque dur (pas SSD).</font></font><br>
<br>
<a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repères</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'option B-tree montre un assez bon résultat:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font><font style="vertical-align: inherit;">| </font><font style="vertical-align: inherit;">temps [μs] | </font><font style="vertical-align: inherit;">% |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| -----------------: | ------------: | ------------: |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">okon | </font><font style="vertical-align: inherit;">49 | </font><font style="vertical-align: inherit;">100 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">grep '^ hash' | </font><font style="vertical-align: inherit;">135'350'000 | </font><font style="vertical-align: inherit;">276'224'489 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">grep | </font><font style="vertical-align: inherit;">135'480'000 | </font><font style="vertical-align: inherit;">276'489'795 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">C ++ ligne par ligne | </font><font style="vertical-align: inherit;">135'720'201 | </font><font style="vertical-align: inherit;">276'980'002 |</font></font></pre><br>
<a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">okon - bibliothèque et CLI</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit, je voulais partager mon travail avec le monde. J'ai implémenté une bibliothèque et une interface de ligne de commande pour traiter la base de données HIBP et rechercher rapidement les hachages. La recherche est si rapide qu'elle peut, par exemple, être intégrée dans un gestionnaire de mots de passe et donner un retour à l'utilisateur à chaque pression sur une touche. Il existe de nombreuses utilisations possibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La bibliothèque a une interface C, elle peut donc être utilisée presque partout. CLI est une CLI. Vous pouvez simplement construire et exécuter (: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code est dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mon référentiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avertissement: okon ne fournit pas encore d'interface pour insérer des valeurs dans l'arbre B créé. </font><font style="vertical-align: inherit;">Il ne peut traiter que le fichier HIBP, créer un arbre B et le rechercher. </font><font style="vertical-align: inherit;">Ces fonctions fonctionnent assez bien, j'ai donc décidé de partager le code et de continuer à travailler sur l'insertion et d'autres fonctions possibles.</font></font><br>
<br>
<a name="15"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens et discussion</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure de Trie</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbre B</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site Web ai-je été pwned</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dépôt de code</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / cpp</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / sécurité</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelles des hackers</font></font></a></li>
</ul><br>
<a name="16"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci d'avoir lu</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(:</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490906/index.html">Yandex a déployé une version bêta d'un Aura - aura.top indépendant. C'est top?</a></li>
<li><a href="../fr490908/index.html">Stockage des données de zone</a></li>
<li><a href="../fr490912/index.html">Comment nous, chez Sportmaster, avons choisi un système de mise en cache. Partie 1</a></li>
<li><a href="../fr490916/index.html">Problèmes d'interaction avec des équipes externes sur de grands projets</a></li>
<li><a href="../fr490918/index.html">Andrei Zaretsky, Alexander Trukhanov (suite): "Nous n'avions pas de nom, mais il y avait de l'arrogance"</a></li>
<li><a href="../fr490924/index.html">Qu'est-ce que Windows PowerShell et que mange-t-il? Partie 2: Introduction au langage de programmation</a></li>
<li><a href="../fr490926/index.html">Trajectoire Unity Ball 2D pour les débutants</a></li>
<li><a href="../fr490932/index.html">[Prévision] Motornet - un réseau d'échange de données pour les véhicules robotisés</a></li>
<li><a href="../fr490936/index.html">Créer ML sur iOS</a></li>
<li><a href="../fr490938/index.html">Nous écrivons des milliers de fichiers journaux à la fois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>