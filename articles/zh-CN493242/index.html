<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛣️ 🙇🏼 🔤 HTTP字符串快速处理算法 👩🏽‍🎓 👨‍🌾 🌋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="标准标头的压缩出现在HTTP / 2中，但是URI，Cookie，User-Agent值的正文仍可能是数十个千字节，并且需要标记化，搜索和比较子字符串。如果HTTP解析器需要处理大量恶意流量，则该任务就变得至关重要。标准库提供了广泛的字符串处理工具，但是HTTP字符串具有其自身的特性。为此，开发了T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HTTP字符串快速处理算法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准标头的压缩出现在HTTP / 2中，但是URI，Cookie，User-Agent值的正文仍可能是数十个千字节，并且需要标记化，搜索和比较子字符串。</font><font style="vertical-align: inherit;">如果HTTP解析器需要处理大量恶意流量，则该任务就变得至关重要。</font><font style="vertical-align: inherit;">标准库提供了广泛的字符串处理工具，但是HTTP字符串具有其自身的特性。</font><font style="vertical-align: inherit;">为此，开发了Tempesta FW HTTP解析器。</font><font style="vertical-align: inherit;">与现代开放源代码解决方案相比，其性能要高出数倍，并且超过了最快的解决方案。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亚历山大·克里兹哈诺夫斯基</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克里扎诺夫斯基</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的创始人和系统架构师Tempesta Technologies，Linux / x86-64高性能计算专家。 Alexander将讨论HTTP字符串结构的特殊性，解释为什么标准库不适合处理它们，并介绍Tempesta FW解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在猫之下：HTTP Flood如何将您的HTTP解析器变成瓶颈，在典型的HTTP解析器任务上出现分支错误预测，缓存和内存不足内存的x86-64问题，将FSM与直接跳转，GCC优化，自动矢量化，strspn（）进行比较-和strcasecmp（）-类似于HTTP字符串，SSE，AVX2和使用AVX2过滤注入攻击的算法。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Tempesta Technologies，我们开发定制软件：我们专注于与高性能相关的复杂领域。</font><font style="vertical-align: inherit;">我们特别为Positive Technologies第一版WAF的核心开发感到自豪。</font><font style="vertical-align: inherit;">Web应用程序防火墙（WAF）是HTTP代理：它对HTTP流量的攻击（Web和DDoS）进行了非常深入的分析。</font><font style="vertical-align: inherit;">我们为此编写了第一个核心。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了咨询之外，我们还在开发</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是应用程序交付控制器（ADC）。</font><font style="vertical-align: inherit;">我们将谈论他。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用交付控制器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application Delivery Controller是具有增强功能的HTTP代理。</font><font style="vertical-align: inherit;">但是，我将讨论与安全性相关的功能-有关过滤DDoS和Web攻击。</font><font style="vertical-align: inherit;">我还将提到这些限制，并通过代码示例展示其工作和功能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FW内置在Linux TCP / IP Stack内核中。</font><font style="vertical-align: inherit;">借助此功能和许多其他优化，它非常快-它可以在廉价的硬件上每秒处理180万个请求。</font><font style="vertical-align: inherit;">在最高负载下，这比Nginx快3倍，并且与</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内核旁路方法</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相比也快</font><strong><font style="vertical-align: inherit;">。</font></strong></font><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在少数内核上，它与ScyllaDB（用DPDK编写）中使用的Seastar项目显示出相似的性能。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该项目诞生于我们在2013年开始进行PT AF时。</font><font style="vertical-align: inherit;">该WAF基于一种流行的开源HTTP加速器。</font><font style="vertical-align: inherit;">Nginx，HAProxy，Varnish或Apache Traffic是很好的HTTP加速器：它们可以提供内容精细，缓存，修改的功能，但是它们</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都不是为大量流量处理和过滤而设计的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们认为如果有网络级防火墙，为什么不继续这个想法并将其集成为TCP / IP堆栈作为应用程序级防火墙？</font><font style="vertical-align: inherit;">实际上，事实证明Tempesta FW </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是HTTP加速器和防火墙</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">混合体</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：Nginx将作为报告中的示例，因为它是一个简单且流行的Web服务器。</font><font style="vertical-align: inherit;">相反，可能有其他任何开放源HTTP服务器。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下我们的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP请求</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（HTTP /（1，〜2））</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以有一个非常大的URI。</font><font style="vertical-align: inherit;">在HTTP解析时重要的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分隔符</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以红色粗体突出显示</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我将重点介绍这些功能：几千字节的大字符串以及不同的定界符，例如，我们需要解析的其他“分号”或序列“ \ r \ n”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还需要讲一点有关HTTP / 2的知识。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2功能</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2是字符串和二进制数据的混合体</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这种混合更多地是关于优化连接带宽而不是节省服务器资源。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HPACK中的HTTP / 2使用动态表</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。来自客户端的第一个请求未优化，不在表中。您必须对其进行分析，以便将其添加到表中。如果使用HTTP / 2 DDoS，情况就是这样。在正常情况下，HTTP / 2是一个二进制协议，但是您仍然需要解析文本：文本标题名称，数据。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">霍夫曼编码</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一种简单的编码，但是Huffman难以快速编程以进行压缩：Huffman编码越过字节边界，您不能使用向量扩展名，而需要按字节进行编码。</font><font style="vertical-align: inherit;">您将无法快速处理32或16字节的数据。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookies，User-Agent，Referer，URI可能非常大</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先，删除Huffman，然后将其发送到与HTTP / 1中相同的常规HTTP解析器。</font><font style="vertical-align: inherit;">尽管RFC允许，但不建议压缩cookie，因为它是机密数据-您不应向攻击者提供有关其大小的信息。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP处理缓慢</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">所有HTTP服务器首先解码HTTP / 2，然后将这些行发送到HTTP / 1已经使用的HTTP / 1解析器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 1解析有什么问题？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要快速对状态机进行编程。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要快速处理连续的行。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
恶意流量的目标是过程中最慢（最弱）的部分。</font><font style="vertical-align: inherit;">因此，如果要制作过滤器，必须注意较慢的部分，以便它们也可以快速工作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx个人资料</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下HTTP泛洪下的Nginx配置文件。</font><font style="vertical-align: inherit;">禁用访问日志，以使文件系统不会变慢。</font><font style="vertical-align: inherit;">当甚至请求常规索引页时，解析器都位于顶部。</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号名称</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收录</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左-“平面轮廓”。</font><font style="vertical-align: inherit;">有趣的是，其中最热的点不比下一个重，并且轮廓之后平滑下降。</font><font style="vertical-align: inherit;">例如，这意味着两次优化第一个功能将无助于显着提高性能。</font><font style="vertical-align: inherit;">这就是为什么我们没有优化相同的Nginx，而是创建了一个新项目来改善配置文件整个尾部的性能的原因。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规HTTP解析器的编码方式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，我们有一个</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿线运行</font><font style="vertical-align: inherit;">的循环（</font><font style="vertical-align: inherit;">）和两个变量：状态（</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和当前数据（</font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们进入循环（1），然后查看当前状态（检查状态）。我们传递给接收的数据（符号</font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并实现一些逻辑。我们进入第二状态（2）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转到末尾</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）-这是相对于代码开头的第二次转换，并且可能是指令高速缓存中的第二次未命中。然后我们开始</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4），吃下一个字符</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
……，然后在里面的指令中再次查找状态</font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当一个变量已经被分配一个</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以直接转到下一条指令。</font><font style="vertical-align: inherit;">但是相反，他们又上升又下降了。</font><font style="vertical-align: inherit;">我们通过代码“切圆”，而不仅仅是走下坡路。</font><font style="vertical-align: inherit;">普通解析器不会，例如，Ragel生成具有直接转换的解析器。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP解析器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于Nginx解析器及其环境的几句话。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx使用普通的套接字API-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递到适配器的数据将复制到用户空间。</font><font style="vertical-align: inherit;">结果，我们有一个庞大的数据块，我们正在寻找所需的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx使用一种算法，该算法分两次进行：首先搜索长度，然后进行检查。</font><font style="vertical-align: inherit;">第一步，他在字符串中扫描令牌，搜索第一个令牌（“试用版”）。</font><font style="vertical-align: inherit;">在第二个令牌上，</font><font style="vertical-align: inherit;">根据令牌的大小</font><font style="vertical-align: inherit;">检查请求的结尾（</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后启动</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“获取”始终位于相同的数据块中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Tempesta FW使用零副本。</font><font style="vertical-align: inherit;">这意味着数据可以具有完全任意的大小：每个1字节或1000字节。</font><font style="vertical-align: inherit;">这种“机制”不适合我们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看它如何</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在GCC中工作。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">海湾合作委员会</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找表</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。左侧是一个典型的枚举示例：以0开头，然后是连续的标签，26个常量，然后是一些处理所有这些的代码。右边是编译器生成的代码。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，将</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EAX寄存器中</font><font style="vertical-align: inherit;">的变量</font><font style="vertical-align: inherit;">与常量进行比较。接下来，我们以8个字节的指针顺序数组（查找表）的形式显示所有标签。在此指令上，我们在此数组中传递偏移量-它是指针的双重解引用。右下角是我们从该表切换到的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，对内存进行了双重解引用：如果我们接收到秘密数据，则可以通过字节找到数组中的地址并转到该指针。重要的是要知道，生活仍然比示例中的情况更糟-对于查找表，编译器</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果是</font><font style="vertical-align: inherit;">针对Spectre攻击</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚本</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">则代码会更加复杂</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二进制搜索</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。下一种情况</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是使用顺序常量，而是使用任意常量。代码是一样的，但是现在GCC不能编译这么大的数组，并且不能使用常量作为数组的索引。他切换到二进制搜索。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在右侧，我们看到了顺序比较，到地址的转换以及比较的继续-二进制搜索是通过代码进行的。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP解析器。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看什么是状态机nginx。它具有9 KB的代码-比启动基准测试的计算机上的一级缓存（如大多数x86-64处理器）少三倍。</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx标头解析器</font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个简单的令牌生成器。</font><font style="vertical-align: inherit;">它对标头的值及其名称不执行任何操作，而只是将HTTP标头的令牌放入哈希中。</font><font style="vertical-align: inherit;">如果需要任何标题值，请扫描标题表并重复分析。</font><font style="vertical-align: inherit;">出于安全原因，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们必须</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格检查标题的名称和值</font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW：HTTP字符串的字符串验证</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的状态机功能强大了一个数量级：我们执行RFC标头验证，并立即在解析器中处理几乎所有内容。</font><font style="vertical-align: inherit;">如果nginx有80个州，那么我们有520个州，并且有更多的州。</font><font style="vertical-align: inherit;">如果我们继续行驶</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那将是10倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们拥有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零拷贝的I / O-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同大小的块可以在不同位置切割数据。</font><font style="vertical-align: inherit;">不同的块可以切割我们的数据。</font><font style="vertical-align: inherit;">例如，在零拷贝I / O中，“ GET”可能（很少）以“ GET”，“ GE”和“ T”或“ G”，“ E”和“ T”的形式出现，因此您需要在数据之间存储状态。</font><font style="vertical-align: inherit;">实际上，我们消除了I / O的成本，但是在配置文件中它却飞速发展-一切都很糟糕。</font><font style="vertical-align: inherit;">大型HTTP解析器是项目中最关键的位置之一。</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何改善这种情况？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSM直接推荐</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们要做的第一件事</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是使用循环，而是使用标签（</font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">直接转换</font></strong><font style="vertical-align: inherit;">。像Ragel这样的普通解析器生成器可以做到这一点。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用标记</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和标记C使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的名称</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对每个状态进行编码</font><font style="vertical-align: inherit;">。每次我们想去的时候，我们都会</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码中</font><font style="vertical-align: inherit;">找到一个标签</font><font style="vertical-align: inherit;">或直接访问相同的状态。第一次浏览时</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后在其中直接进入所需的标签。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：当我们要切换到下一个状态时，我们必须立即评估我们是否仍然有可用数据（因为零拷贝I / O）。条件体</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它被复制到每个状态：根据状态数，我们有500个状态，而不是常规的开关驱动FSM中的一个状态。为每个状态生成代码不是很好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大型状态机的情况下，对于</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有大</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的内部，也GTC重复的条件</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的代码内数次。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换为</font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接过渡。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个优化是我们不使用它</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">而是</font><font style="vertical-align: inherit;">切换为直接跳转到已保存的元地址。进入功能后，我们希望立即转到所需的位置。 GCC允许您执行此操作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCC具有标准扩展名，可能会有所帮助。我们取标签名称（此处为</font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后通过双“＆”号将其地址分配给某些C变量。现在我们可以做出直接跳转指令</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到此标签的地址</font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看结果如何。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接转换效果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在少数状态下，直接转换代码生成器甚至比正常速度慢一点</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是对于大型状态机，生产率提高了一倍。</font><font style="vertical-align: inherit;">如果状态机很小，则最好使用通常的状态机</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：Tempesta代码比示例更复杂。</font><font style="vertical-align: inherit;">GitHub具有所有</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准测试，</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此您可以详细了解所有内容。</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（主HTTP解析器）上</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">提供</font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;">了</font></em></a><em><font style="vertical-align: inherit;">原始解析器代码</font></em><em><font style="vertical-align: inherit;">。</font></em><em><font style="vertical-align: inherit;">除此之外，在Tempesta FW中，还有一些</font></em></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">较小的解析器</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它们更容易使用FSM。</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么直接转换可能会更慢</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在状态机中，我们需要处理大量代码，因此（预期）会有很多分支错误预测。</font><font style="vertical-align: inherit;">让我们根据分支丢失预测进行“概要分析”：</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps – up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在具有406个状态的大型状态机上，我们花费38％的时间处理中的过渡</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在具有直接转换的状态机上，热点是行解析。</font><font style="vertical-align: inherit;">在每种状态下解析字符串都包括检查字符串结尾的条件：</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态机中</font><font style="vertical-align: inherit;">的条件</font><font style="vertical-align: inherit;">on </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们通过事件L1指令高速缓存未命中来分析两种类型的状态机- </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于直接跳转而言，</font><font style="vertical-align: inherit;">将近30 KB，</font><font style="vertical-align: inherit;">对于直接跳转，则约为50 KB（比第一级指令的高速缓存还多）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎，如果我们不适合缓存，那么对于这种状态机，应该有很多缓存未命中。</font><font style="vertical-align: inherit;">但不，它们少2倍。</font><font style="vertical-align: inherit;">那是因为缓存工作得更好：我们按顺序使用代码，并设法从较早的缓存中提取数据。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器更改代码顺序</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当在上编写状态机代码时</font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们首先具有在接收到数据时首先要调用的状态：HTTP方法，URI，然后是HTTP标头。在我们遍历数据时，将代码从上到下依次加载到处理器缓存中似乎是合乎逻辑的。但这是完全错误的。如果您看一下汇编代码，您会发现很棒的事情。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左边是我们编程的内容：首先我们解析方法</font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后在不太可能的方法之下的某个地方</font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，我们希望看到解析</font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font><font style="vertical-align: inherit;">在汇编程序的开始</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是一切都恰恰相反：</font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在中间，</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后和</font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是因为编译器不了解数据是如何到达我们的。</font><font style="vertical-align: inherit;">他根据自己漂亮的代码来分配代码。</font><font style="vertical-align: inherit;">为了使他以正确的顺序排列代码，我们必须使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器barrier</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编译器屏障是一个程序集虚拟对象，通过它，编译器将不会重新排序。</font><font style="vertical-align: inherit;">通过简单地设置此类障碍，我们</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将生产率提高了4％</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用自己的方式编写代码</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于编译器没有按照我们的要求排列数据，因此我们将进行</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">探查器引导的优化</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在探查器的控制下进行优化）。</font><font style="vertical-align: inherit;">Profiler引导式优化（PGO）是样本总数，而不是调用序列。</font><font style="vertical-align: inherit;">例如，与方法分析相比，URI接收的样本更多，因此它将在处理方法之前定位URI处理代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
怎么运行的？</font><font style="vertical-align: inherit;">我们将编写代码，在上面运行基准测试，将分析结果提供给编译器，然后它将为我们的负载生成最佳代码。</font><font style="vertical-align: inherit;">但是问题在于它只是编译最热的代码部分，而没有跟踪时间依赖性。</font><font style="vertical-align: inherit;">如果负载中最大的URI，那么这将是最热门的地方。</font><font style="vertical-align: inherit;">URI将上升到函数的顶部，并且PGO不会显示方法名称始终在URI之前。</font><font style="vertical-align: inherit;">因此，PGO不起作用。</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有什么用？</font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宏</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（对于Linux内核代码，GCC内在函数在用户空间中可用</font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。他们说要靠近的代码。例如，可能报告请求主体应紧随其后</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，预取代码（预取处理器）将选择该代码，一切都会很快。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图片显示了解析方法的开始，结束和障碍。我们没想到看到障碍后面的代码。看来这不应该-我们已经设置了障碍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是现实中会发生什么呢？编译器看到了</font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件-很可能我们将输入条件的主体，然后我们将切换到无条件跳转到标签</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">事实证明，在“热路径”中未处理我们条件之后的代码。</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管有障碍，</font><font style="vertical-align: inherit;">编译器</font><font style="vertical-align: inherit;">仍将</font><font style="vertical-align: inherit;">代码移动到标签后面的标签下</font><font style="vertical-align: inherit;">，因为符合热代码条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，GCC进行了扩展：</font><font style="vertical-align: inherit;">标签</font><font style="vertical-align: inherit;">的属性</font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他们说哪个标签是热的（最有可能）和哪个标签是冷的（不太可能）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们就</font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更有可能</font><font style="vertical-align: inherit;">达成共识，</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后交给他</font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，URI处理上升，然后</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下降。</font><font style="vertical-align: inherit;">因为标签是冷的，所以最不可能的状态机的所有其他代码都保持在下面。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-昧-O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下编译器优化。</font><font style="vertical-align: inherit;">首先想到的是不使用O2，而是使用O3-应该更快。</font><font style="vertical-align: inherit;">但是事实并非如此-O3有时会生成更糟糕的代码。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3是一些优化的集合</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们将它们分别添加到O2中，则会得到不同的选择：某些优化会有所帮助，有些会产生干扰。</font><font style="vertical-align: inherit;">对于我们的特定代码，我们仅选择那些可以更好地生成代码的优化。</font><font style="vertical-align: inherit;">我们留下最好的结果-相对于1,838和1,858，这是1,820秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些选项以绿色突出显示-这是自动向量化。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动向量化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
来自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC指南</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的循环实例</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们有一些重复的变量数组，我们可以优化循环-分解为向量。</font><font style="vertical-align: inherit;">默认情况下，在优化的第三个级别-O3启用自动</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矢量化</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：GCC会在可能的情况下生成矢量代码。</font><font style="vertical-align: inherit;">但是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非所有代码</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都可以自动向量化（即使原则上也可以向量化）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以启用GCC选项</font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">选项</font><font style="vertical-align: inherit;">显示已矢量化的内容和未矢量化的内容。</font><font style="vertical-align: inherit;">我们得到的结果是，对于我们的基准，没有向量化，但是代码仍然生成得更糟。</font><font style="vertical-align: inherit;">因此，矢量化并不总是有效：有时会减慢代码速度。</font><font style="vertical-align: inherit;">但是，我们始终可以看到已矢量化的内容和未矢量化的内容，并在必要时关闭矢量化。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对齐方式：如何将字符串与GET进行比较？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们做了一个小小的修改，就像在nginx中一样：我们不按字节分析行，而是</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用它们</font><font style="vertical-align: inherit;">计算</font><font style="vertical-align: inherit;">和比较行。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们知道，如果</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未对齐，则速度会降低2-3倍。</font><font style="vertical-align: inherit;">我们写了一个小的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来证明这一点。</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后尝试对齐</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将查看地址是否</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对齐，然后用</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字节（如果不</font><font style="vertical-align: inherit;">对齐）进行比较</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但事实证明，这种方法的效果更差：</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之：隔离的，不可优化的基准测试代码与内联的解析器代码之间存在差异，由于大量的代码而失去了优化。</font><font style="vertical-align: inherit;">进行分析时不会受到任何惩罚。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：有关为什么在我们的任务中发生这种情况的详细讨论可以</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在GitHub上阅读</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么HTTP字符串对我们很重要？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，这是一个普通的URI：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您对酒店足够​​挑剔，请前往“预订”并设置一些过滤器，获取一个大于一千字节的URI。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx在</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">上有一个相当庞大的解析器</font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它不能很快地工作。</font><font style="vertical-align: inherit;">另外，在Tempesta FW的情况下，我们不仅需要解析URI，还需要检查是否有注入。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个URI：/redir_lang.jsp? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lang=foobar%0d%0aContent-Length:%200%0d% 0a％0d％0aHTTP / 1.1％20200％20OK％0d％0aContent-Type：％20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html％0d％0aContent -长度：％2019％0d％0a％0d％0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它看起来像第一个，但是有注射剂。您必须深入研究才能理解这一点。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们进行测试</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：获取第一个URI，输入wrk，将其设置为nginx，然后看解析nginx会变得非常热。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在以前的常规索引查询中清楚地知道解析器已经在顶部，那么它就更热了。</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP字符串有什么特别之处？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有不同的分隔符</font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，甚至是行尾，可以是双字节</font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或单字节</font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这在开头已经讨论过。</font><font style="vertical-align: inherit;">C线没有0端接-出于安全原因，我们希望更准确地检查要发生的事情。</font><font style="vertical-align: inherit;">我们有两个帮助解析器的标准功能。</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：检查字母（字符串中的可用字符），动态编译有效字母，尽管在程序编译阶段就知道该字母。</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">无需转换大小写以</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">进行比较</font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在大多数情况下</font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，只需遵守/不遵守，您就无需知道行中的位置。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们工作缓慢。</font><font style="vertical-align: inherit;">让我们看一下基准，了解它们的问题所在。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速解析器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有几个解析器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx是最简单的解析器，它严格检查RFC符合性。还有PicoHTTPParser（H2O）和Cloudflare解析器。它们可以更快地处理数据，但是可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跳过</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RFC不允许的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;">字符</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析器使用几种不同的方法。第一个是PCMESTRI指令，该指令在Pico解析器中使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在说明中设置范围。不幸的是，我们可以加载16个字符或8个范围。如果范围仅包含一个字符-请重复。由于此限制，Pico解析器无法完全验证RFC符合性，因为RFC在此位置具有8个以上的范围。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将字母加载到寄存器中，加载字符串，执行指令。在出口处，我们快速查看是否有巧合。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2-CloudFlare方法。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用AVX2的CloudFlare解析器一次处理32个字节的字符串，而不是使用Pico解析器处理16个字节。 CloudFlare的解析效果更好，因为它已传输到AVX2。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将所有字符检查到ASCII表中的空格，所有字符都大于128，并取其间的范围。简单的代码很快。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较PCMESTRI和AVX2。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对我们来说，当前的限制是1500。这是我们所能得到的最大包装尺寸。我们看到，大数据上的AVX2代码比Pico解析器快得多。但是，它在小数据上的运行速度较慢，因为AVX2中的指令量较大。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可比</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们决定使用</font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，情况会变得更糟，尤其是在大数据上。</font><font style="vertical-align: inherit;">在“战斗”解析器中不能使用</font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta匹配器更快，更准确</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的速度解析器就像这两个。在小数据上，它与Pico解析器一样快，在大数据上（如CloudFlare）。但是，它不会跳过无效字符。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析器如何安排？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们作为nginx定义了一个字节数组，并通过它检查输入数据-这是该函数的序言。在这里，我们只使用短期术语，我们使用</font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它是因为分支错误预测对于短行比对长行更痛苦。我们处理这段代码。由于最后一行，我们限制为4-我们必须编写一个相当强大的条件。如果我们处理4个以上的字节，则条件会更难，代码也会更慢。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主循环和大尾巴。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在主要处理周期中，我们对数据进行划分：如果数据足够长，则每个处理128、64、32或16个字节。</font><font style="vertical-align: inherit;">每个处理128个是有意义的：并行地，我们使用几个处理器通道（几个流水线）和一个超标量处理器。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾巴。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的结尾类似于开头。</font><font style="vertical-align: inherit;">如果少于16个字节，则循环处理4个字节，最后不超过3个字节。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们加载位掩码和数据-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是函数主体的主要算法。我们展示了一个16行8列的ASCII表（如图所示）。首先，我们将表行编码在BM URI的第一个寄存器中：第一行和第二行。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们允许的实际符号是</font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它们的编码如下：</font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们以相反的顺序编码：我们从0开始，不允许使用第一个服务字符，然后允许使用单位。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置ASCII位掩码。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，输入一行</font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：第一行的第一个字符为ASCII，第二行的第二个字符。我们运行shuffle语句，该语句根据输入中这些字符的顺序对编码的表行进行混洗。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入的列ID。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将ASCII表的列放在另一个寄存器中。然后我们“交叉”列和行的寄存器，并得到一个对应关系：我们的字符与否。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于列是字节后的最高4位，因此我们向左移动。 AVX的偏移量仅为2个字节，因此首先将其移位，然后再加上我们的掩码n即可得到有效位。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排列ASCII列</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行第二次混洗，将色谱柱移至所需位置。在这两种情况下，输入字节均来自最后一列，因此在第一和第二位置，我们获得同一列。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蒙版的列和行的交点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们这样做</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（将“列”与“列”交叉），并得到输入数据有效-结果</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从列和行的交点开始不为零。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算最后的零数。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从向量中收集所有数据</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其返回到输出-非常简单。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自定义字母。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用ASCII表，我们得到了一个便宜的功能：我们使用静态表，但是没有什么可以阻止我们询问用户哪些字母可用于不同标头的URI，名称和值。</font><font style="vertical-align: inherit;">HTTP URI请求和标头使用8个字母（正负）来解析一个HTTP请求。</font><font style="vertical-align: inherit;">可以将这些表加载到相同的代码中，并</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在用户指定的单个字母（</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效URI）中进行比较。</font><font style="vertical-align: inherit;">如果没有，那就不一样了。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进攻</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少数情况下可能有用。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（“ SSRF的新时代”）对</font><strong><font style="vertical-align: inherit;">SSRF的攻击</font></strong><font style="vertical-align: inherit;">：</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-一个不太可能的“＆”符号。</font><font style="vertical-align: inherit;">在某些应用程序中使用它，在某些应用程序中不使用它。</font><font style="vertical-align: inherit;">但是，如果您不使用它，则可以将其从有效字母中排除，从而阻止攻击。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE攻击：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “有效的是执行命令注入攻击，如”，BSides'16 ：</font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">User-Agent是静态标头，但是在某些情况下，</font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User-Agent带有非典型字符</font><font style="vertical-align: inherit;">时会发生RCE攻击</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们保护自己，除了美元符号。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相对路径覆盖</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最后一种情况是Google在2016年的情况。</font><font style="vertical-align: inherit;">大括号，冒号，来到了URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些不太可能的字符可以从字母表中排除。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个相当琐碎的代码。</font><font style="vertical-align: inherit;">我们还比较了32个字节的字符串，每个字符串两个。</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker’s Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> – <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> – <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker’s Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' – 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们只给寄存器一行，因为在第二行中，我们在解析器中将常量编程为小写。</font><font style="vertical-align: inherit;">由于我们进行了大量比较，因此从每个字节中减去128（这是Hacker's Delight的技巧）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还比较了一个有效字符的范围：是否可以注册该字符串，是否是字母。</font><font style="vertical-align: inherit;">在检查这一点时，我们只能使用一个比较（Hacker's Delight的技巧），而不是从a到z进行两次比较，并移至一个常数。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能strcasecmp（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta比GLIBC快得多，甚至是新版本（18或19）。</font><font style="vertical-align: inherit;">该代码</font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还使用AVX，但不使用第二个版本。</font><font style="vertical-align: inherit;">AVX2更快，因此Tempesta的代码更快。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux内核FPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矢量处理器扩展</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -它们在内核中可用。向量指令由FPU处理器模块处理。这不是主处理器模块，也不是主寄存器，但是非常庞大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，Linux中存在优化。如果我们从内核转到用户空间然后再返回，则不会保存FPU寄存器（XMM，YMM，ZMM）的上下文：我们仅更改主处理器模块的寄存器的上下文。假定OS内核不适用于处理器的矢量扩展。但是，例如，如果您需要加密，则可以做到这一点，但是需要使用</font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存和恢复FPU寄存器的上下文：</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些是本机宏，用于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存和恢复处理器模块的状态，该模块</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责向量寄存器。</font><font style="vertical-align: inherit;">这些是相当慢的资源。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX和SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在保存和恢复FPU上下文的基准测试之前，有关于向量操作的几句话。</font><font style="vertical-align: inherit;">为什么有时使用汇编程序有意义？</font><font style="vertical-align: inherit;">有时，GCC会生成次优代码。</font><font style="vertical-align: inherit;">问题在于，在较旧的处理器型号上，从SSE过渡到AVX会有很大的损失。</font><font style="vertical-align: inherit;">GCC有一个新密钥</font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-使用它不会产生此指令</font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从而清除寄存器并消除此代价。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅当您使用由某些第三方为SSE编译的旧代码时，才需要使用此说明。</font><font style="vertical-align: inherit;">这不是我们的情况，我们可以放心地删除这些说明。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们</font><font style="vertical-align: inherit;">在处理器中</font><font style="vertical-align: inherit;">具有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动矢量化功能</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这意味着在任何用户空间代码中都会有向量运算。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
系统中的任何两个进程都使用矢量处理器扩展。当您的进程进入内核并返回时，您不会浪费时间来节省和恢复处理器的向量状态。但是，如果您从一个用户空间切换到另一个用户空间（上下文切换），则除了在那里禁用了一级缓存的事实外，FPU开始/结束上的上下文切换模块也无法正常工作。该操作相当昂贵-一个微基准测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在微基准测试中，一切总是很戏剧性的，但是操作非常昂贵。</font><font style="vertical-align: inherit;">因此，在用户空间中，长时间切换上下文。</font><font style="vertical-align: inherit;">在内核中，我们没有上下文切换，因此一切都很快。</font><font style="vertical-align: inherit;">对于足够大的一组软件包，我们只保存和恢复矢量处理器一次。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">智力世界</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始时，我展示了一个用于优化开关代码的查找表选项：一个漫长的过程，枚举，将开关表编译成一个数组，然后对跳过该数组的指针进行双重解引用。这是利用推测执行的Spectre攻击的场景。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撰写了一篇</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很好的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章</font></a><font style="vertical-align: inherit;">，介绍了从2018年初开始如何安排现代编译器中的指针双重取消引用。它不能很好地工作。如果在寄存器的较早位置存储了一个地址，然后我们转到了该地址，那么现在我们有了另一个代码。</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它是如何工作的？我们在l1上“调用”该函数，过程转到该标签，然后进行破解：就好像我们从某个函数返回（不是）一样，但是我们重写了返回地址。当执行该指令时</font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">我们将</font><font style="vertical-align: inherit;">返回地址，当前地址放在堆栈上，并用寄存器的必要内容重写它，然后转到l1。但是，当处理器运行其预取器时，它会看到有一个功能，然后是一个障碍。因此，一切都会变慢-排除了预取，我们摆脱了Spectre漏洞。代码很慢，性能下降了15％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一个相对较新的攻击是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它仅特定于用户空间进程。</font><font style="vertical-align: inherit;">从用户空间读取内核内存非常痛苦。</font><font style="vertical-align: inherit;">内核主控表隔离（KPTI）阻止了该攻击，该内核默认情况下会在新内核中进行编译。</font><font style="vertical-align: inherit;">但是KPTI非常昂贵，性能下降高达30-40％（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由MariaDB衡量</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是由于您不再具有惰性TLB优化：内核和处理器的地址空间在不同的页表中完全分开（之前，惰性TLB一直将内核空间映射到每个进程的页表）。</font><font style="vertical-align: inherit;">这对于用户空间是很痛苦的，但对于Tempesta FW则不是很痛苦，后者完全在内核中工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些有用的链接：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于HTTP解析的快速有限状态机</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用C，SSE4.2和AVX2的HTTP字符串处理</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黑客的喜悦</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">崩溃和幽灵攻击文档</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP Russia</a>: 13   ,  .       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TechLead Conf</a> —     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493226/index.html">如何每周阅读和修复100,000行代码</a></li>
<li><a href="../zh-CN493230/index.html">由Lighthouse 6（测试版）支持的新Google PageSpeed见解：检查您网站的性能</a></li>
<li><a href="../zh-CN493232/index.html">我在Open Product LLC工作的历史</a></li>
<li><a href="../zh-CN493234/index.html">ING推出Lion：高效，负担得起的灵活Web组件库</a></li>
<li><a href="../zh-CN493236/index.html">星号：外部中继处于“请求发送”状态</a></li>
<li><a href="../zh-CN493244/index.html">量子计算机能做什么</a></li>
<li><a href="../zh-CN493248/index.html">网络研讨会“ Winnum工业分析机会”</a></li>
<li><a href="../zh-CN493250/index.html">现在出行发生了什么事-以及如何在运输中保护自己</a></li>
<li><a href="../zh-CN493252/index.html">在开发学校的教学经验，或者为什么需要在大学毕业后上学</a></li>
<li><a href="../zh-CN493254/index.html">人口大规模窃听系统实际上对联邦调查局毫无用处</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>