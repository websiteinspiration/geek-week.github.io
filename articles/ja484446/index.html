<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏽 👎🏿 👐🏻 Python 3.5 asyncioを使用した同時実行性の実装 💷 ✏️ 🐑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="「エキスパートPythonプログラミング」の第13章の同時実行、
 第2版​​、
 ミハウヤウォルスキー＆タレクジアデ、2016年
 
 非同期プログラミング 
 近年、非同期プログラミングが人気を博しています。 Python 3.5には、非同期ソリューションの概念を強化するいくつかの構文関数がつい...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Python 3.5 asyncioを使用した同時実行性の実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484446/"><i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「エキスパートPythonプログラミング」</font><font style="vertical-align: inherit;">の第13章の同時実行</font><font style="vertical-align: inherit;">、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2版​​、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミハウヤウォルスキー＆タレクジアデ、2016年</font></font><br>
</i><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期プログラミング </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近年、非同期プログラミングが人気を博しています。 Python 3.5には、非同期ソリューションの概念を強化するいくつかの構文関数がついに登場しました。しかし、これは非同期プログラミングがPython 3.5以降でのみ可能になったという意味ではありません。多くのライブラリとフレームワークはずっと以前に提供されており、そのほとんどは古いバージョンのPython 2に由来していました。Stacklessと呼ばれるPythonの完全な代替実装さえあります（第1章「Pythonの現在のステータス」を参照）。この単一のプログラミングアプローチに焦点を当てています。以下のようないくつかの解決策については</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツイスト、トルネード</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventlet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、まだ活発なコミュニティがあり、彼らは本当に知る価値があります。いずれにせよ、Python 3.5以降、非同期プログラミングはかつてないほど簡単になりました。したがって、その組み込み非同期関数が古いツールのほとんどを置き換えるか、外部プロジェクトが組み込みPythonに基づく一種の高レベルのフレームワークに徐々に変わることが期待されます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期プログラミングとは何かを説明しようとするとき、このアプローチをスレッドに似ていると考えるのが最も簡単ですが、システムスケジューラはありません。</font><font style="vertical-align: inherit;">つまり、非同期プログラムはタスクを同時に処理できますが、そのコンテキストはシステムスケジューラではなく内部で切り替えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、もちろん、非同期プログラムでのタスクの並列処理にはスレッドを使用しません。</font><font style="vertical-align: inherit;">ほとんどのソリューションは異なる概念を使用しており、実装に応じて異なる方法で呼び出されます。</font><font style="vertical-align: inherit;">このような並列プログラムオブジェクトを説明するために使用される名前の例を以下に示します。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">緑のスレッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -緑のスレッド（greenlet、gevent、またはeventletプロジェクト）</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチン</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -コルーチン（Python 3.5の純粋な非同期プログラミング）</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクレット（Stackless Python）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらは基本的に同じ概念ですが、多くの場合、わずかに異なる方法で実装されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかな理由により、このセクションでは、バージョン3.5以降のPythonで最初にサポートされるコルーチンにのみ焦点を当てます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共同マルチタスクと非同期I / O</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
協調的マルチタスキングは、非同期プログラミングの中核です。</font><font style="vertical-align: inherit;">この意味で、オペレーティングシステムでのマルチタスクは、（別のプロセスまたはスレッドへの）コンテキストスイッチを開始する必要はありませんが、代わりに、各プロセスがスタンバイモードのときに自発的に制御を解放して、複数のプログラムの同時実行を保証します。</font><font style="vertical-align: inherit;">それがコラボレーティブと呼ばれる理由です。</font><font style="vertical-align: inherit;">マルチタスクを確実に成功させるには、すべてのプロセスが連携する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチタスクモデルはオペレーティングシステムで使用されることもありましたが、システムレベルのソリューションとしてはほとんど見つかりません。これは、不適切に設計されたサービスがシステム全体の安定性を簡単に混乱させるリスクがあるためです。オペレーティングシステムによって直接制御されるコンテキストスイッチを使用してスレッドとプロセスをスケジュールすることは、現在、システムレベルでの同時実行の主要なアプローチです。しかし、共同マルチタスクは依然として優れたアプリケーションレベルの同時実行ツールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションレベルでの共同マルチタスクといえば、すべての実行が1つのプロセスとスレッドに含まれているため、制御を解放する必要のあるスレッドやプロセスは扱っていません。代わりに、タスクの調整を制御する単一の関数に制御を移すいくつかのタスク（コルーチン、タスクレット、およびグリーンスレッド）があります。この関数は通常、一種のイベントループです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（Pythonの用語による）混乱を避けるために、このような並列タスクをコルーチンと呼びます。コラボレーティブマルチタスクで最も重要な問題は、制御を移すタイミングです。ほとんどの非同期アプリケーションでは、I / O操作中に制御がスケジューラまたはイベントループに渡されます。プログラムがファイルシステムからデータを読み取るか、ソケットを介して通信するかに関係なく、このようなI / O操作は、プロセスが非アクティブになると常に待機時間と関連付けられます。レイテンシは外部リソースに依存するため、他のコルーチンがこのアプローチの動作がPythonで実装される方法と多少似ているのを待つ必要があるまで、他のコルーチンが自分の仕事を行えるように、制御を解放する良い機会です。 GILはPythonスレッドをシリアライズすることを知っています。ただし、I / O操作のたびに解放されます。主な違いは、Pythonのスレッドはシステムレベルのスレッドとして実装されているため、オペレーティングシステムは現在実行中のスレッドをいつでもアンロードして、別のスレッドに制御を移すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期プログラミングでは、タスクがメインイベントループによって中断されることはありません。</font><font style="vertical-align: inherit;">このため、このマルチタスクスタイルは非優先マルチタスクとも呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、すべてのPythonアプリケーションは、リソースをめぐって競合する他のプロセスがあるオペレーティングシステム上で実行されます。</font><font style="vertical-align: inherit;">つまり、オペレーティングシステムは常に、プロセス全体の負荷を軽減し、制御を別のプロセスに移すことができます。</font><font style="vertical-align: inherit;">しかし、非同期アプリケーションが開始すると、システムスケジューラが介入したときに一時停止されていたところから続行されます。</font><font style="vertical-align: inherit;">これが、このコンテキストのコルーチンが非混雑と見なされる理由です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python asyncおよびawaitキーワード</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、非同期Pythonプログラミングの主な構成要素です。</font><i><font style="vertical-align: inherit;">非同期キーワード</font></i><font style="vertical-align: inherit;">の前に使用</font><i><font style="vertical-align: inherit;">DEF</font></i><font style="vertical-align: inherit;">文は</font><font style="vertical-align: inherit;">新しいコルーチンを定義します。厳密に定義された状況下では、コルーチン関数を一時停止および再開できます。その構文と動作はジェネレーターに非常に似ています（クラスレベルの下の第2章「構文の推奨事項」を参照）。実際、コルーチンを実装するには、Pythonの古いバージョンでジェネレーターを使用する必要があります。以下は、</font><i><font style="vertical-align: inherit;">asyncキーワード</font></i><font style="vertical-align: inherit;">を使用する関数の宣言例</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">async_hello</span>():</span>
       print(<span class="hljs-string">"hello, world!"</span>)
</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncキーワード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用して定義された関数</font><font style="vertical-align: inherit;">は特別です。</font><font style="vertical-align: inherit;">呼び出されると、内部でコードを実行せず、代わりにコルーチンオブジェクトを返します。</font></font><br>
<br>
<b><pre><code class="plaintext hljs">&gt;&gt;&gt;&gt; async def async_hello():<font></font>
...     print("hello, world!")<font></font>
...<font></font>
&gt;&gt;&gt; async_hello()<font></font>
&lt;coroutine object async_hello at 0x1014129e8&gt;<font></font>
</code></pre></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンオブジェクトは、その実行がイベントループでスケジュールされるまで何もしません。</font><font style="vertical-align: inherit;">asyncioモジュールは、イベントループの基本的な実装、および他の多くの非同期ユーティリティを提供するために使用できます。</font></font><br>
<br>
<b><pre><code class="plaintext hljs">&gt;&gt;&gt; import asyncio<font></font>
&gt;&gt;&gt; async def async_hello():<font></font>
...     print("hello, world!")<font></font>
...<font></font>
&gt;&gt;&gt; loop = asyncio.get_event_loop()<font></font>
&gt;&gt;&gt; loop.run_until_complete(async_hello())<font></font>
hello, world!<font></font>
&gt;&gt;&gt; loop.close()<font></font>
</code></pre></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、単純なコルーチンを1つだけ作成します。このプログラムでは、並列処理を実装していません。真にパラレルなものを見るには、イベントループによって実行されるタスクをさらに作成する必要があります。</font><i><font style="vertical-align: inherit;">loop.create_task（）</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドを呼び出す</font><font style="vertical-align: inherit;">か、</font><i><font style="vertical-align: inherit;">asyncio.wait（）</font></i><font style="vertical-align: inherit;">関数の使用を待機する別のオブジェクトを提供すること</font><font style="vertical-align: inherit;">により、新しいタスクをループに追加できます</font><font style="vertical-align: inherit;">。後者のアプローチを使用して、</font><i><font style="vertical-align: inherit;">range（）</font></i><font style="vertical-align: inherit;">関数によって生成された一連の数値を非同期で出力しようとします</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> asyncio<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_number</span>(<span class="hljs-params">number</span>):</span><font></font>
       print(number)<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<font></font>
       loop = asyncio.get_event_loop()<font></font>
       loop.run_until_complete(<font></font>
           asyncio.wait([<font></font>
               print_number(number)<font></font>
               <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)<font></font>
           ])<font></font>
       )<font></font>
       loop.close()<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio.wait（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数</font><font style="vertical-align: inherit;">は、コルーチンオブジェクトのリストを受け入れ、すぐに戻ります。結果は、将来の結果（将来）を表すオブジェクトを生成するジェネレーターです。名前が示すように、指定されたすべてのコルーチンが完了するまで待機するために使用されます。コルーチンオブジェクトの代わりにジェネレータを返すのは、後で説明する以前のバージョンのPythonと下位互換性があるためです。このスクリプトを実行すると、次のような結果になる場合があります。</font></font><br>
<br>
<b><pre><code class="plaintext hljs">$ python asyncprint.py<font></font>
0<font></font>
7<font></font>
8<font></font>
3 9 4 1 5 2 6 <font></font>
</code></pre></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、数値はコルーチンを作成した順序では印刷されていません。</font><font style="vertical-align: inherit;">しかし、これはまさに私たちが達成したかったことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python 3.5で追加された2番目の重要なキーワードは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">コルーチンまたは将来のイベント（後で説明）の結果を待機し、イベントループの実行に対する制御を解放するために使用されます。</font><font style="vertical-align: inherit;">これがどのように機能するかをよりよく理解するには、より複雑なコード例を検討する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループでいくつかの単純なタスクを実行する2つのコルーチンを作成するとします。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秒のランダムな数を待ちます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数として提供されたテキストと、待機に費やされた時間を印刷します。</font><font style="vertical-align: inherit;">いくつかの並行性の問題がある単純な実装から始めましょう。これは、awaitをさらに使用して後で改善しようとします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> asyncio<font></font>
 <font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waiter</span>(<span class="hljs-params">name</span>):</span>
       <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<font></font>
            time_to_sleep = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) / <span class="hljs-number">4</span><font></font>
           time.sleep(time_to_sleep)<font></font>
           print(<font></font>
                <span class="hljs-string">"{} waited {} seconds"</span>
                <span class="hljs-string">""</span>.format(name, time_to_sleep)<font></font>
           )<font></font>
    <font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
       <span class="hljs-keyword">await</span> asyncio.wait([waiter(<span class="hljs-string">"foo"</span>), waiter(<span class="hljs-string">"bar"</span>)])<font></font>
    <font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<font></font>
       loop = asyncio.get_event_loop()<font></font>
       loop.run_until_complete(main())<font></font>
       loop.close()<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターミナルで実行すると（timeコマンドを使用して時間を測定）、次のように表示されます。</font></font><br>
<br>
<b><pre><code class="plaintext hljs">$ time python corowait.py<font></font>
bar waited 0.25 seconds<font></font>
bar waited 0.25 seconds<font></font>
bar waited 0.5 seconds<font></font>
bar waited 0.5 seconds<font></font>
foo waited 0.75 seconds<font></font>
foo waited 0.75 seconds<font></font>
foo waited 0.25 seconds<font></font>
foo waited 0.25 seconds<font></font>
real 0m3.734s user 0m0.153s sys 0m0.028s <font></font>
</code></pre></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、両方のコルーチンは実行を完了しましたが、非同期ではありませんでした。その理由は、どちらも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time.sleep（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用するためです</font><font style="vertical-align: inherit;">。これは、イベントループ内でコントロールをブロックしますが、解放しません。これはマルチスレッドインストールでうまく機能しますが、現時点ではストリームを使用したくありません。どうすればこれを修正できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答えは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time.sleep（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の非同期バージョンであるasyncio.sleep（）を使用し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワードを使用した結果を期待すること</font><font style="vertical-align: inherit;">です。このステートメントは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の最初のバージョンですでに使用されています</font><font style="vertical-align: inherit;">が、これはコードをより明確にするためだけのものでした。これは明らかに私たちの実装をより並列にしませんでした。コルーチンの改良版を見てみましょう</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waiter（）は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、await asyncio.sleep（）を使用します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waiter</span>(<span class="hljs-params">name</span>):</span>
       <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<font></font>
           time_to_sleep = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) / <span class="hljs-number">4</span>
           <span class="hljs-keyword">await</span> asyncio.sleep(time_to_sleep)<font></font>
           print(<font></font>
               <span class="hljs-string">"{} waited {} seconds"</span>
               <span class="hljs-string">""</span>.format(name, time_to_sleep)<font></font>
           )<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新されたスクリプトを実行すると、2つの関数の出力が相互にどのように変化するかがわかります。</font></font><br>
<br>
<b><pre><code class="plaintext hljs">$ time python corowait_improved.py<font></font>
bar waited 0.25 seconds<font></font>
foo waited 0.25 seconds<font></font>
bar waited 0.25 seconds<font></font>
foo waited 0.5 seconds<font></font>
foo waited 0.25 seconds<font></font>
bar waited 0.75 seconds<font></font>
foo waited 0.25 seconds<font></font>
bar waited 0.5 seconds<font></font>
real  0m1.953s<font></font>
user  0m0.149s<font></font>
sys   0m0.026s<font></font>
</code></pre></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純な改善の追加の利点は、コードがより速く実行されることです。</font><font style="vertical-align: inherit;">コルーチンが1つずつ制御を取得したため、合計実行時間はすべてのスリープ時間の合計よりも短くなりました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前のバージョンのPythonのAsyncio</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
asyncioモジュールはPython 3.4で登場しました。</font><font style="vertical-align: inherit;">したがって、これはPython 3.5より前の非同期プログラミングを本格的にサポートしている唯一のバージョンのPythonです。</font><font style="vertical-align: inherit;">残念ながら、これら2つの後続バージョンは互換性の問題を示すのに十分であるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とにかく、Pythonの非同期プログラミングコアは、このテンプレートをサポートする構文要素よりも前に導入されました。</font><font style="vertical-align: inherit;">遅くなることはありませんが、コルーチンを操作するための構文が2つある状況が発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python 3.5以降では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaitを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span> ():</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0</span>)
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Python 3.4では、asyncio.coroutineデコレーターを追加で適用し、コルーチンテキストを生成する必要があります。 </font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@asyncio.couroutine</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
       <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(<span class="hljs-number">0</span>)
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の有用な事実は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yield fromステートメント</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がPython 3.3で導入され、PyPIに非同期バックポートがあることです。</font><font style="vertical-align: inherit;">つまり、Python 3.3との協調マルチタスクのこの実装を使用することもできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期プログラミングの実際的な例</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この章で何度も述べたように、非同期プログラミングはI / Oを処理するための優れたツールです。シーケンスの印刷や非同期待機よりも実用的なものを作成するときがきました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性を確保するために、マルチスレッドとマルチプロセッシングの助けを借りて解決したのと同じ問題を解決しようとします。したがって、ネットワーク接続を介して外部リソースから一部のデータを非同期で抽出しようとします。</font><font style="vertical-align: inherit;">前のセクション</font><font style="vertical-align: inherit;">と同じ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python-gmaps</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できればすばらしい</font><i><font style="vertical-align: inherit;">と思い</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。残念ながらできません。</font><i><font style="vertical-align: inherit;">python-gmaps</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の作成者</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し怠惰で、名前だけを取った。開発を簡素化するために、彼はHTTPクライアントライブラリとしてリクエストパッケージを選択しました。残念ながら、リクエストは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による非同期I / Oをサポートしていません</font><font style="vertical-align: inherit;">。クエリプロジェクトにいくつかの並列処理を提供することを目的とする他​​のいくつかのプロジェクトがありますが、それらは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gevent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grequests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https：//github.com/ kennethreitz / grequestsを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">依存するか</font><font style="vertical-align: inherit;">、スレッド/プロセスプール（query-futuresを実行する）に</font><font style="vertical-align: inherit;">依存してい</font><font style="vertical-align: inherit;">ます</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/ross/requests-futuresを</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照して</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ください</font></a></i><font style="vertical-align: inherit;">）。それらのどれも私たちの問題を解決しません。</font></font><br>
<br>
<blockquote><i>  ,         , . ,    <i>python-gmaps</i>,  .         .         .      ,   <i>python-gmaps</i>     (0.3.1     )        - Python.   ,     ,    .</i><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の例では非常に使いやすかったライブラリの制限を知っているので、このギャップを埋める何かを作成する必要があります。 Google MapsAPIは本当に使いやすいので、説明のために非同期ユーティリティを作成します。 Python 3.5の標準ライブラリには、非同期のHTTPリクエストを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urllib.urlopen（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出すのと</font><i><font style="vertical-align: inherit;">同じくらい</font></i><font style="vertical-align: inherit;">簡単に</font><i><font style="vertical-align: inherit;">する</font></i><font style="vertical-align: inherit;">ライブラリがまだありません</font><font style="vertical-align: inherit;">。完全なプロトコルサポートを最初から作成することは絶対に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避けたい</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font><font style="vertical-align: inherit;">、PyPIで利用可能な</font><i><font style="vertical-align: inherit;">aiohttp</font></i><font style="vertical-align: inherit;">パッケージの小さな助けを</font><font style="vertical-align: inherit;">使用します。これは、非同期HTTPのクライアントとサーバーの両方の実装を追加する本当に有望なライブラリです。これは</font><i><font style="vertical-align: inherit;">aiohttpの</font></i><font style="vertical-align: inherit;">上に構築された小さなモジュールです</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、1つのヘルパー関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geocode（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成</font><font style="vertical-align: inherit;">し、Google Maps APIサービスへのジオコーディングリクエストを実行します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> aiohttp<font></font>
<font></font>
session = aiohttp.ClientSession()<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">geocode</span>(<span class="hljs-params">place</span>):</span><font></font>
       params = {<font></font>
           <span class="hljs-string">'sensor'</span>: <span class="hljs-string">'false'</span>,
           <span class="hljs-string">'address'</span>: place<font></font>
       }<font></font>
<font></font>
       <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(
           <span class="hljs-string">'https://maps.googleapis.com/maps/api/geocode/json'</span>,<font></font>
           params=params<font></font>
       ) <span class="hljs-keyword">as</span> response:<font></font>
           result = <span class="hljs-keyword">await</span> response.json()
           <span class="hljs-keyword">return</span> result[<span class="hljs-string">'results'</span>]
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは</font><font style="vertical-align: inherit;">、後で使用する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncgmaps</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という名前のモジュールに格納されていると仮定します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これで、マルチスレッドとマルチプロセッシングの説明で使用した例を書き直す準備ができました。</font><font style="vertical-align: inherit;">以前は、操作全体を2つの別々のステージに分割するために使用していました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fetch_place（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用して、外部サービスへのすべてのリクエストを並行して</font><i><font style="vertical-align: inherit;">実行し</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">present_result（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用して、ループ内のすべての結果を表示します</font><font style="vertical-align: inherit;">。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、コラボレーティブマルチタスクは、複数のプロセスやスレッドを使用する場合とはまったく異なるため、アプローチを少し変更することができます。要素ごとにシングルスレッドを使用するで発生した問題のほとんどは、もはや私たちの関心事ではありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンはプリエンプティブではないため、HTTP応答を受け取った直後に結果を簡単に表示できます。これにより、コードが簡略化され、理解しやすくなります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-comment"># note: local module introduced earlier</span>
<span class="hljs-keyword">from</span> asyncgmaps <span class="hljs-keyword">import</span> geocode, session<font></font>
<font></font>
PLACES = (<font></font>
       <span class="hljs-string">'Reykjavik'</span>, <span class="hljs-string">'Vien'</span>, <span class="hljs-string">'Zadar'</span>, <span class="hljs-string">'Venice'</span>,
       <span class="hljs-string">'Wrocław'</span>, <span class="hljs-string">'Bolognia'</span>, <span class="hljs-string">'Berlin'</span>, <span class="hljs-string">'Słubice'</span>,
       <span class="hljs-string">'New York'</span>, <span class="hljs-string">'Dehli'</span>,<font></font>
) <font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch_place</span>(<span class="hljs-params">place</span>):</span>
       <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> geocode(place))[<span class="hljs-number">0</span>]<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">present_result</span>(<span class="hljs-params">result</span>):</span>
       geocoded = <span class="hljs-keyword">await</span> result<font></font>
       print(<span class="hljs-string">"{:&gt;25s}, {:6.2f}, {:6.2f}"</span>.format(<font></font>
           geocoded[<span class="hljs-string">'formatted_address'</span>],<font></font>
           geocoded[<span class="hljs-string">'geometry'</span>][<span class="hljs-string">'location'</span>][<span class="hljs-string">'lat'</span>],<font></font>
           geocoded[<span class="hljs-string">'geometry'</span>][<span class="hljs-string">'location'</span>][<span class="hljs-string">'lng'</span>],<font></font>
       )) <font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
       <span class="hljs-keyword">await</span> asyncio.wait([<font></font>
           present_result(fetch_place(place))<font></font>
           <span class="hljs-keyword">for</span> place <span class="hljs-keyword">in</span> PLACES<font></font>
       ])<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<font></font>
       loop = asyncio.get_event_loop()<font></font>
       loop.run_until_complete(main())<font></font>
       <span class="hljs-comment"># aiohttp will raise issue about unclosed</span>
       <span class="hljs-comment"># ClientSession so we perform cleanup manually</span><font></font>
       loop.run_until_complete(session.close())<font></font>
       loop.close()<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期プログラミングは、スケーラブルなアプリケーションの作成に関心のあるバックエンド開発者に最適です。</font><font style="vertical-align: inherit;">実際には、これは非常に競争力のあるサーバーを作成するための最も重要なツールの1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、現実は悲しいです。</font><font style="vertical-align: inherit;">I / Oの問題を処理する一般的なパッケージの多くは、非同期コードでの使用を意図していません。</font><font style="vertical-align: inherit;">これの主な理由は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3およびその高度な機能のいくつかの実装はまだ低い</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonを学ぶための初心者の間でのさまざまな同時実行概念の理解不足 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、既存の同期マルチスレッドアプリケーションおよびパッケージの移行が（アーキテクチャ上の制限により）不可能であるか、非常に高額であることを意味します。多くのプロジェクトは非同期マルチタスクスタイルの実装から大きな利益を得ることができますが、最終的にそうするプロジェクトはごくわずかです。つまり、現在、最初から非同期アプリケーションを作成しようとすると、多くの困難が生じます。ほとんどの場合、これは「非同期プログラミングの実際的な例」セクションで述べた問題と互換性があります-互換性のないインターフェイスとI / O操作の非同期ブロッキング。もちろん、そのような非互換性が発生したときに待機をあきらめて、必要なリソースを同期的に取得することもできます。しかし、これは結果を待つ間、他のコルーチンがそのコードを実行するのをブロックします。技術的には、これは機能しますが、非同期プログラミングのすべての利点を破壊します。したがって、結局、非同期I / Oと同期I / Oを組み合わせることはオプションではありません。これはオール・オア・ナッシングのゲームです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの問題は、プロセッサにバインドされた長時間の操作です。</font><font style="vertical-align: inherit;">I / O操作を実行する場合、コルーチンから制御を解放する問題はありません。</font><font style="vertical-align: inherit;">ファイルシステムまたはソケットから書き込み/読み取りを行う場合、最終的に待機するため、awaitを使用した呼び出しが最善の方法です。</font><font style="vertical-align: inherit;">しかし、何かを計算する必要があり、時間がかかることがわかっている場合はどうでしょうか。</font><font style="vertical-align: inherit;">もちろん、少しずつ作業を進めるたびに、問題を部分に分けてコントロールをキャンセルすることもできます。</font><font style="vertical-align: inherit;">しかし、すぐにこれはあまり良いモデルではないことがわかります。</font><font style="vertical-align: inherit;">そのようなことはコードを乱雑にする可能性があり、また良い結果を保証するものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一時的なバインディングは、インタープリターまたはオペレーティングシステムの責任です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期コードと非同期フューチャーの組み合わせ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、書き換えができない、または書き換えたくない、長い同期I / O操作を実行するコードがある場合はどうすればよいでしょうか。または、主に非同期I / O用に設計されたアプリケーションで重いプロセッサ操作を実行する必要がある場合はどうすればよいですか？まあ...あなたは回避策を見つける必要があります。つまり、マルチスレッドまたはマルチプロセッシングを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはあまり良くないように聞こえるかもしれませんが、最善の解決策は、私たちが避けようとしたものかもしれません。 Pythonのリソース集約型タスクの並列処理は、マルチプロセッシングにより常により適切に実行されます。また、マルチスレッドはI / O操作を同等に（迅速かつ大量のリソースなしで）同等に処理できます。適切に構成および処理されれば、非同期で待機します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、非同期アプリケーションに適合しない場合の対処方法がわからない場合は、別のスレッドまたはプロセスに配置するコードを使用してください。</font><font style="vertical-align: inherit;">コルーチンであるかのように見せかけ、イベントループの制御を解放し、最終的に準備ができたら結果を処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いにも私たちのために、Pythonの標準ライブラリが提供</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concurrent.futuresの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール</font><font style="vertical-align: inherit;">もと統合され、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールを</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの2つのモジュールを一緒に使用すると、スレッドまたは追加のプロセスで実行されるブロック関数を、非同期の非ブロックコルーチンであるかのように計画できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">執行者と先物</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期イベントループにスレッドまたはプロセスを埋め込む方法を確認する前に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concurrent.futures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールを詳しく見</font><font style="vertical-align: inherit;">ていき</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。この</font><font style="vertical-align: inherit;">モジュールは</font><font style="vertical-align: inherit;">、後でいわゆる回避策の主要コンポーネントになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中で最も重要なクラス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concurrent.futures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールが</font><font style="vertical-align: inherit;">ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エグゼキュータ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未来</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エグゼキューター</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、作業項目を並行して処理できるリソースのプールです。</font><font style="vertical-align: inherit;">これは、マルチプロセッサモジュールのクラスと目的が非常に似ているように見えるかもしれません- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プール</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">ダミー。</font></i><i><font style="vertical-align: inherit;">プール</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-しかし、完全に異なるインターフェースとセマンティクスを持っています。</font><font style="vertical-align: inherit;">これは、実装を目的としていない基本クラスであり、2つの特定の実装があります。</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPoolExecutor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：スレッドプールを表します</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessPoolExecutor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プロセスプールを表します</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エグゼキューター</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は3つのメソッドを表します。</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">submit（fn、* args、** kwargs）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：fn関数をリソースプールで実行するようにスケジュールし、呼び出されたオブジェクトの実行を表すFutureオブジェクトを返します</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">map（func、* iterables、timeout = None、chunksize = 1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">func</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は、マルチプロセッシングと同様に反復で実行されます。</font><i><font style="vertical-align: inherit;">Pool.map（）</font></i><font style="vertical-align: inherit;">メソッド</font></font><i><font style="vertical-align: inherit;"></font></i></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shutdown（wait = True）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これにより、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executorが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャットダウンされ、</font><font style="vertical-align: inherit;">そのすべてのリソースが解放されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も興味深いメソッドは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">submit（）です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、Futureオブジェクトが返すためです。これは、呼び出されたオブジェクトの非同期実行を表し、その結果を間接的にのみ表します。ディスパッチされた呼び出されたオブジェクトの実際の戻り値を取得するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Future.result（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを呼び出す必要があります</font><font style="vertical-align: inherit;">。呼び出されたオブジェクトが既に完了している場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">result（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">はそれをブロックせず、関数の出力を返します。そうでない場合は、結果が出るまでブロックします。結果の約束と考えてください（実際にはJavaScriptの約束と同じ概念です）。受け取った直後に（</font><i><font style="vertical-align: inherit;">result（）</font></i><font style="vertical-align: inherit;">メソッドを使用して</font><i><font style="vertical-align: inherit;">）</font></i><font style="vertical-align: inherit;">解凍する必要はありません。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、しかしこれを行おうとすると、最終的に何かを返すことが保証されています：</font></font><br>
<br>
<b><pre><code class="plaintext hljs">&gt;&gt;&gt; def loudy_return():<font></font>
		...      print("processing")<font></font>
		 <font></font>
		...      return 42<font></font>
		...<font></font>
		&gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor<font></font>
		&gt;&gt;&gt; with ThreadPoolExecutor(1) as executor:<font></font>
		 <font></font>
...     future = executor.submit(loudy_return)<font></font>
...<font></font>
processing<font></font>
&gt;&gt;&gt; future<font></font>
&lt;Future at 0x33cbf98 state=finished returned int&gt;<font></font>
&gt;&gt;&gt; future.result()<font></font>
42<font></font>
</code></pre></b><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executor.map（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドを使用する場合でも</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">マルチプロセッサモジュールの</font><i><font style="vertical-align: inherit;">Pool</font></i><font style="vertical-align: inherit;">クラスの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool.map（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">は変わりません</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
       <span class="hljs-keyword">with</span> ThreadPoolExecutor(POOL_SIZE) <span class="hljs-keyword">as</span> pool:<font></font>
           results = pool.map(fetch_place, PLACES)<font></font>
       <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<font></font>
           present_result(result)<font></font>
</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループでのエグゼキューターの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></h4><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executor.submit（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドによって返されるFutureクラスのインスタンスは、</font><font style="vertical-align: inherit;">概念的には、非同期プログラミングで使用されるコルーチンに非常に近いものです。</font><font style="vertical-align: inherit;">そのため、アーティストを使用して、コラボレーティブマルチタスクとマルチプロセッシングまたはマルチスレッドのハイブリッドを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この回避策の中核は、</font><i><font style="vertical-align: inherit;">BaseEventLoop.run_in_executor（executor、func、* args）</font></i><font style="vertical-align: inherit;">メソッドです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントループクラス。これにより、executor引数で表されるプロセスまたはスレッドプールでfunc関数の実行をスケジュールできます。このメソッドの最も重要な点は、新しい予期されるオブジェクト（await演算子を使用して予期できるオブジェクト）を返すことです。したがって、これのおかげで、コルーチンとまったく同じコルーチンではないブロッキング機能を実行でき、完了までに時間がかかってもブロックされません。そのような呼び出しからの結果を期待する関数のみを停止しますが、イベントのサイクル全体が継続します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利なのは、独自のエグゼキューターインスタンスを作成する必要さえないことです。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">None</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を引数として</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">executor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">渡す</font><font style="vertical-align: inherit;">と、クラス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPoolExecutor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はデフォルトのスレッド数で使用されます（Python 3.5の場合、これはプロセッサーの数に5を掛けたものです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、頭痛の原因となっているpython-gmapsパッケージの問題のある部分を書き直したくないと仮定しましょう。私たちは、呼び出すことで、別のスレッドに簡単に延期ブロック呼び出すことができます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop.run_in_executorを（） </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">予想コルーチンとしてfetch_place（）関数を残したまま、</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch_place</span>(<span class="hljs-params">place</span>):</span>
       coro = loop.run_in_executor(<span class="hljs-literal">None</span>, api.geocode, place)<font></font>
       result = <span class="hljs-keyword">await</span> coro
       <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>]
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような解決策は、完全に非同期のライブラリを使用して作業を行うよりも悪いですが、少なくとも何かが何もないよりはましであることがわかっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並行性とは何かを説明した後、私たちは行動を起こし、マルチスレッドを使用した典型的な並列問題の1つを分析しました。コードの主な欠点を特定して修正した後、マルチプロセッシングを使用して、コードがどのように機能するかを確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、マルチプロセッサモジュールでは、複数のプロセスを使用する方が、マルチスレッドを使用する基本的なスレッドよりもはるかに簡単であることがわかりました。しかしその後になって初めて、</font><i><font style="vertical-align: inherit;">multiprocessing.dummyの</font></i><font style="vertical-align: inherit;">おかげで、スレッドで同じAPIを使用できることがわかりました。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、マルチプロセッシングとマルチスレッドのどちらを選択するかは、どのソリューションが問題に最も適しているかにのみ依存し、どのソリューションが最良のインターフェースを備えているかに依存しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の調整といえば、ついに非同期プログラミングを試してみました。非同期プログラミングは、I / O関連のアプリケーションにとって最良のソリューションであるはずですが、スレッドとプロセスを完全に忘れることはできないことを理解するためだけです。それで、私たちは最初の場所に戻って円を作りました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これがこの章の最終的な結論につながります。</font><font style="vertical-align: inherit;">みんなに合う解決策はありません。</font><font style="vertical-align: inherit;">あなたがより好むかもしれないまたは好むかもしれないいくつかのアプローチがあります。</font><font style="vertical-align: inherit;">この一連の問題により適したいくつかのアプローチがありますが、成功するにはすべてを知る必要があります。</font><font style="vertical-align: inherit;">現実的なシナリオでは、1つのアプリケーションですべてのツールと並列処理スタイルを使用できますが、これは珍しいことではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の結論は、次の章、第14章「便利なデザインパターン」のトピックへの優れた導入です。</font><font style="vertical-align: inherit;">すべての問題を解決する単一のテンプレートがないので。</font><font style="vertical-align: inherit;">最終的には毎日使用するため、できるだけ多くのことを知っておく必要があります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484436/index.html">Неблагодарный opensource: разработчик самого быстрого веб сервера удалил его репозиторий</a></li>
<li><a href="../ja484438/index.html">有名な流体方程式が漏れました</a></li>
<li><a href="../ja484440/index.html">標準のWindowsツールを使用した完全バックアップ</a></li>
<li><a href="../ja484442/index.html">SNMPv3の例</a></li>
<li><a href="../ja484444/index.html">動作条件がバッテリーに与える影響、または奇跡的な復活の物語</a></li>
<li><a href="../ja484448/index.html">DEFCON会議27.警察をハッキングする。パート1</a></li>
<li><a href="../ja484454/index.html">ハブラ探偵：あなたの写真は失われます</a></li>
<li><a href="../ja484456/index.html">ReactJS、サーバー側レンダリング、およびページメタタグの処理の微妙な点</a></li>
<li><a href="../ja484458/index.html">このフリーランサーは壊れています-次のフリーランサーをください</a></li>
<li><a href="../ja484462/index.html">Githubのスクレイピング：開発する「シークレット」の検索</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>