<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👿 👨🏾‍🍳 🧑🏼 Votre premier réseau neuronal sur une unité de traitement graphique (GPU). Guide du débutant 🐲 🤷🏿 👧🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais vous expliquer comment configurer un environnement d'apprentissage automatique en 30 minutes, créer un réseau neuronal pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Votre premier réseau neuronal sur une unité de traitement graphique (GPU). Guide du débutant</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488564/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/wg/sv/g2/wgsvg24lytktztdczee_4rteb28.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, je vais vous expliquer comment configurer un environnement d'apprentissage automatique en 30 minutes, créer un réseau neuronal pour la reconnaissance d'images, puis exécuter le même réseau sur un processeur graphique (GPU). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définissons d'abord ce qu'est un réseau neuronal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, il s'agit d'un modèle mathématique, ainsi que de sa mise en œuvre logicielle ou matérielle, construit sur le principe d'organisation et de fonctionnement des réseaux neuronaux biologiques - réseaux de cellules nerveuses d'un organisme vivant. Ce concept est apparu dans l'étude des processus se produisant dans le cerveau et dans une tentative de simuler ces processus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les réseaux de neurones ne sont pas programmés au sens habituel du terme, ils sont formés. </font><font style="vertical-align: inherit;">La capacité d'apprentissage est l'un des principaux avantages des réseaux de neurones par rapport aux algorithmes traditionnels. </font><font style="vertical-align: inherit;">Techniquement, l'entraînement consiste à trouver les coefficients de connexions entre les neurones. </font><font style="vertical-align: inherit;">Dans le processus d'apprentissage, le réseau neuronal est capable d'identifier des relations complexes entre l'entrée et la sortie, ainsi que d'effectuer une généralisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Du point de vue de l'apprentissage automatique, un réseau neuronal est un cas particulier des méthodes de reconnaissance de formes, d'analyse discriminante, de méthodes de clustering et d'autres méthodes.</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Équipement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons d'abord par l'équipement. Nous avons besoin d'un serveur sur lequel le système d'exploitation Linux est installé. Les équipements pour le fonctionnement des systèmes d'apprentissage automatique nécessitent un appareil suffisamment puissant et, par conséquent, coûteux. Pour ceux qui n'ont pas une bonne voiture à portée de main, je recommande de prêter attention à l'offre des fournisseurs de cloud. Le serveur nécessaire peut être loué rapidement et ne payer que pour le temps d'utilisation.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les projets où il est nécessaire de créer des réseaux de neurones, j'utilise les serveurs d'un des fournisseurs de cloud russes. </font><font style="vertical-align: inherit;">La société propose des serveurs cloud de location spécifiquement pour l'apprentissage automatique avec les puissantes unités de traitement graphique (GPU) Tesla V100 de NVIDIA. </font><font style="vertical-align: inherit;">En bref: l'utilisation d'un serveur avec un GPU peut être des dizaines de fois plus efficace (rapide) par rapport à un serveur de même coût, où un CPU (un processeur central bien connu) est utilisé pour les calculs. </font><font style="vertical-align: inherit;">Cela est dû aux spécificités de l'architecture GPU, qui gère les calculs plus rapidement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour effectuer les exemples décrits ci-dessous, nous avons acheté le serveur suivant pendant plusieurs jours:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD 150 Go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM 32 Go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processeur Tesla V100 16 Go avec 4 cœurs</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ubuntu 18.04 a été installé sur la machine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définissez l'environnement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, installez sur le serveur tout ce dont vous avez besoin pour travailler. </font><font style="vertical-align: inherit;">Étant donné que notre article s'adresse principalement aux débutants, j'y parlerai de quelques points qui leur seront utiles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup de travail lors de la configuration de l'environnement se fait via la ligne de commande. </font><font style="vertical-align: inherit;">La plupart des utilisateurs utilisent Windows comme système d'exploitation fonctionnel. </font><font style="vertical-align: inherit;">La console standard de cet OS laisse beaucoup à désirer. </font><font style="vertical-align: inherit;">Par conséquent, nous utiliserons l'outil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ Cmder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pratique </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Téléchargez la version mini et exécutez Cmder.exe. </font><font style="vertical-align: inherit;">Ensuite, vous devez vous connecter au serveur via SSH:</font></font><br>
<br>
<pre><code class="bash hljs">ssh root@server-ip-or-hostname</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de server-ip-or-hostname, spécifiez l'adresse IP ou le nom DNS de votre serveur. </font><font style="vertical-align: inherit;">Ensuite, entrez le mot de passe et après une connexion réussie, nous devrions obtenir quelque chose comme ça.</font></font><br>
<br>
<pre><code class="bash hljs">Welcome to Ubuntu 18.04.3 LTS (GNU/Linux 4.15.0-74-generic x86_64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le langage principal pour développer des modèles ML est Python. </font><font style="vertical-align: inherit;">Et la plate-forme la plus populaire pour l'utiliser sur Linux est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anaconda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installez-le sur notre serveur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons par mettre à jour le gestionnaire de paquets local:</font></font><br>
<br>
<pre><code class="bash hljs">sudo apt-get update</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installez curl (utilitaire de ligne de commande):</font></font><br>
<br>
<pre><code class="bash hljs">sudo apt-get install curl</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Téléchargez la dernière version d'Anaconda Distribution:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">cd</span> /tmp<font></font>
curl –O https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons l'installation:</font></font><br>
<br>
<pre><code class="bash hljs">bash Anaconda3-2019.10-Linux-x86_64.sh</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant le processus d'installation, vous devrez confirmer l'accord de licence. </font><font style="vertical-align: inherit;">En cas d'installation réussie, vous devriez voir ceci:</font></font><br>
<br>
<pre><code class="bash hljs">Thank you <span class="hljs-keyword">for</span> installing Anaconda3!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour développer des modèles ML, de nombreux frameworks sont maintenant créés, nous travaillons avec les plus populaires: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyTorch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensorflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation du framework vous permet d'augmenter la vitesse de développement et d'utiliser des outils prêts à l'emploi pour les tâches standard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, nous travaillerons avec PyTorch. </font><font style="vertical-align: inherit;">Installez-le:</font></font><br>
<br>
<pre><code class="bash hljs">conda install pytorch torchvision cudatoolkit=10.1 -c pytorch</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons maintenant lancer Jupyter Notebook - un outil de développement populaire parmi les spécialistes ML. </font><font style="vertical-align: inherit;">Il vous permet d'écrire du code et de voir immédiatement les résultats de son exécution. </font><font style="vertical-align: inherit;">Jupyter Notebook fait partie d'Anaconda et est déjà installé sur notre serveur. </font><font style="vertical-align: inherit;">Vous devez vous y connecter depuis notre système de bureau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, nous exécutons d'abord Jupyter sur le serveur en spécifiant le port 8080:</font></font><br>
<br>
<pre><code class="bash hljs">jupyter notebook --no-browser --port=8080 --allow-root</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, en ouvrant un autre onglet dans notre console Cmder (le menu supérieur est la boîte de dialogue Nouvelle console), connectez-vous sur le port 8080 au serveur via SSH:</font></font><br>
<br>
<pre><code class="plaintext hljs">ssh -L 8080:localhost:8080 root@server-ip-or-hostname</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous entrez la première commande, des liens nous seront proposés pour ouvrir Jupyter dans notre navigateur:</font></font><br>
<br>
<pre><code class="bash hljs">To access the notebook, open this file <span class="hljs-keyword">in</span> a browser:<font></font>
        file:///root/.<span class="hljs-built_in">local</span>/share/jupyter/runtime/nbserver-18788-open.html<font></font>
    Or copy and paste one of these URLs:<font></font>
        http://localhost:8080/?token=cca0bd0b30857821194b9018a5394a4ed2322236f116d311<font></font>
     or http://127.0.0.1:8080/?token=cca0bd0b30857821194b9018a5394a4ed2322236f116d311<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisez le lien pour localhost: 8080. </font><font style="vertical-align: inherit;">Copiez le chemin complet et collez-le dans la barre d'adresse du navigateur local de votre PC. </font><font style="vertical-align: inherit;">Le bloc-notes Jupyter s'ouvre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons un nouvel ordinateur portable: Nouveau - Notebook - Python 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifiez le bon fonctionnement de tous les composants que nous avons installés. </font><font style="vertical-align: inherit;">Nous introduisons un exemple de code PyTorch dans Jupyter et commençons l'exécution (bouton Exécuter):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function
<span class="hljs-keyword">import</span> torch<font></font>
x = torch.rand(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<font></font>
print(x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat devrait être quelque chose comme ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ps/o8/su/pso8sugii4txi_beqrbx13nsry8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si vous avez un résultat similaire, alors nous nous sommes tous installés correctement et pouvons commencer à développer un réseau de neurones!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créer un réseau de neurones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons créer un réseau neuronal pour la reconnaissance d'images. </font><font style="vertical-align: inherit;">Nous prenons ce </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guide comme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> base </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour former le réseau, nous utiliserons l'ensemble de données CIFAR10 accessible au public. </font><font style="vertical-align: inherit;">Il a des cours: "avion", "voiture", "oiseau", "chat", "cerf", "chien", "grenouille", "cheval", "bateau", "camion". </font><font style="vertical-align: inherit;">Les images dans CIFAR10 ont une taille de 3x32x32, c'est-à-dire des images couleur à 3 canaux de 32x32 pixels.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wg/sv/g2/wgsvg24lytktztdczee_4rteb28.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le travail, nous utiliserons le package PyTorch créé pour travailler avec des images - torchvision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous prendrons les mesures suivantes dans l'ordre:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez et normalisez les ensembles de données de formation et de test</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définition du réseau neuronal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formation réseau sur les données de formation</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test du réseau avec des données de test</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Répéter la formation et les tests GPU</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le code ci-dessous sera exécuté dans le bloc-notes Jupyter.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez et normalisez CIFAR10</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copiez et exécutez le code suivant dans Jupyter:</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torchvision
<span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<font></font>
<font></font>
transform = transforms.Compose(<font></font>
    [transforms.ToTensor(),<font></font>
     transforms.Normalize((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>))])<font></font>
<font></font>
trainset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">True</span>,<font></font>
                                        download=<span class="hljs-literal">True</span>, transform=transform)<font></font>
trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="hljs-number">4</span>,<font></font>
                                          shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">2</span>)<font></font>
<font></font>
testset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">False</span>,<font></font>
                                       download=<span class="hljs-literal">True</span>, transform=transform)<font></font>
testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="hljs-number">4</span>,<font></font>
                                         shuffle=<span class="hljs-literal">False</span>, num_workers=<span class="hljs-number">2</span>)<font></font>
<font></font>
classes = (<span class="hljs-string">'plane'</span>, <span class="hljs-string">'car'</span>, <span class="hljs-string">'bird'</span>, <span class="hljs-string">'cat'</span>,
           <span class="hljs-string">'deer'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'frog'</span>, <span class="hljs-string">'horse'</span>, <span class="hljs-string">'ship'</span>, <span class="hljs-string">'truck'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La réponse devrait être comme ceci:</font></font><br>
<br>
<pre><code class="python hljs">Downloading https://www.cs.toronto.edu/~kriz/cifar<span class="hljs-number">-10</span>-python.tar.gz to ./data/cifar<span class="hljs-number">-10</span>-python.tar.gz<font></font>
Extracting ./data/cifar<span class="hljs-number">-10</span>-python.tar.gz to ./data<font></font>
Files already downloaded <span class="hljs-keyword">and</span> verified</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons dériver plusieurs images de formation pour vérifier:</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
<font></font>
<span class="hljs-comment"># functions to show an image</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imshow</span>(<span class="hljs-params">img</span>):</span>
    img = img / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>     <span class="hljs-comment"># unnormalize</span><font></font>
    npimg = img.numpy()<font></font>
    plt.imshow(np.transpose(npimg, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))<font></font>
    plt.show()<font></font>
<font></font>
<span class="hljs-comment"># get some random training images</span><font></font>
dataiter = iter(trainloader)<font></font>
images, labels = dataiter.next()<font></font>
<font></font>
<span class="hljs-comment"># show images</span><font></font>
imshow(torchvision.utils.make_grid(images))<font></font>
<span class="hljs-comment"># print labels</span>
print(<span class="hljs-string">' '</span>.join(<span class="hljs-string">'%5s'</span> % classes[labels[j]] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)))
</code></pre><br>
<img src="https://habrastorage.org/webt/yy/w4/xw/yyw4xwjhaa6kfy41fvnylvz6qdy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définition du réseau neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons d'abord le fonctionnement d'un réseau de neurones pour la reconnaissance d'images. </font><font style="vertical-align: inherit;">Il s'agit d'un simple réseau de connexion directe. </font><font style="vertical-align: inherit;">Il prend une entrée, la passe à travers plusieurs couches une par une, puis donne finalement la sortie. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t8/4m/yg/t84mygi1sjuzssoezguistupmeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons un réseau similaire dans notre environnement:</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Net</span>(<span class="hljs-params">nn.Module</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><font></font>
        super(Net, self).__init__()<font></font>
        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)<font></font>
        self.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<font></font>
        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)<font></font>
        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)<font></font>
        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<font></font>
        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><font></font>
        x = self.pool(F.relu(self.conv1(x)))<font></font>
        x = self.pool(F.relu(self.conv2(x)))<font></font>
        x = x.view(<span class="hljs-number">-1</span>, <span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>)<font></font>
        x = F.relu(self.fc1(x))<font></font>
        x = F.relu(self.fc2(x))<font></font>
        x = self.fc3(x)<font></font>
        <span class="hljs-keyword">return</span> x<font></font>
<font></font>
net = Net()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous définissons également la fonction de perte et l'optimiseur </font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<font></font>
<font></font>
criterion = nn.CrossEntropyLoss()<font></font>
optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formation réseau sur les données de formation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons à former notre réseau neuronal. </font><font style="vertical-align: inherit;">J'attire votre attention sur le fait qu'après cela, pendant que vous exécutez ce code, vous devrez attendre un certain temps jusqu'à ce que le travail soit terminé. </font><font style="vertical-align: inherit;">Cela m'a pris 5 minutes. </font><font style="vertical-align: inherit;">Le réseautage prend du temps.</font></font><br>
<br>
<pre><code class="python hljs"> <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):  <span class="hljs-comment"># loop over the dataset multiple times</span><font></font>
<font></font>
    running_loss = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> enumerate(trainloader, <span class="hljs-number">0</span>):
        <span class="hljs-comment"># get the inputs; data is a list of [inputs, labels]</span><font></font>
        inputs, labels = data<font></font>
<font></font>
        <span class="hljs-comment"># zero the parameter gradients</span><font></font>
        optimizer.zero_grad()<font></font>
<font></font>
        <span class="hljs-comment"># forward + backward + optimize</span><font></font>
        outputs = net(inputs)<font></font>
        loss = criterion(outputs, labels)<font></font>
        loss.backward()<font></font>
        optimizer.step()<font></font>
<font></font>
        <span class="hljs-comment"># print statistics</span><font></font>
        running_loss += loss.item()<font></font>
        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:    <span class="hljs-comment"># print every 2000 mini-batches</span>
            print(<span class="hljs-string">'[%d, %5d] loss: %.3f'</span> %<font></font>
                  (epoch + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, running_loss / <span class="hljs-number">2000</span>))<font></font>
            running_loss = <span class="hljs-number">0.0</span><font></font>
<font></font>
print(<span class="hljs-string">'Finished Training'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous obtenons le résultat suivant: Nous </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sw/05/k2/sw05k2ewk-gu9fiyrv3xncxjaki.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sauvegardons notre modèle formé:</font></font><br>
<br>
<pre><code class="python hljs">PATH = <span class="hljs-string">'./cifar_net.pth'</span>
torch.save(net.state_dict(), PATH)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test du réseau avec des données de test</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons formé le réseau à l'aide d'un ensemble de données de formation. </font><font style="vertical-align: inherit;">Mais nous devons vérifier si le réseau a appris quoi que ce soit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons vérifier cela en prédisant l'étiquette de classe que le réseau neuronal produit et en vérifiant la vérité. </font><font style="vertical-align: inherit;">Si la prévision est correcte, nous ajoutons l'échantillon à la liste des prévisions correctes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Montrons l'image de la suite de tests:</font></font><br>
<br>
<pre><code class="python hljs">dataiter = iter(testloader)<font></font>
images, labels = dataiter.next()<font></font>
<font></font>
<span class="hljs-comment"># print images</span><font></font>
imshow(torchvision.utils.make_grid(images))<font></font>
print(<span class="hljs-string">'GroundTruth: '</span>, <span class="hljs-string">' '</span>.join(<span class="hljs-string">'%5s'</span> % classes[labels[j]] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)))</code></pre><br>
<img src="https://habrastorage.org/webt/hp/ph/zm/hpphzma6rus04gw-edxsowf1ifu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, demandez au réseau neuronal de nous dire ce qu'il y a dans ces images:</font></font><br>
<br>
<pre><code class="python hljs"><font></font>
net = Net()<font></font>
net.load_state_dict(torch.load(PATH))<font></font>
<font></font>
outputs = net(images)<font></font>
<font></font>
_, predicted = torch.max(outputs, <span class="hljs-number">1</span>)<font></font>
<font></font>
print(<span class="hljs-string">'Predicted: '</span>, <span class="hljs-string">' '</span>.join(<span class="hljs-string">'%5s'</span> % classes[predicted[j]]
                              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)))
</code></pre><br>
<img src="https://habrastorage.org/webt/j2/vp/uc/j2vpucdaps0fuci2yg38ip2fbdo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats semblent plutôt bons: le réseau a correctement identifié trois des quatre images. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment fonctionne le réseau dans l'ensemble des données.</font></font><br>
<br>
<pre><code class="python hljs">
correct = <span class="hljs-number">0</span>
total = <span class="hljs-number">0</span>
<span class="hljs-keyword">with</span> torch.no_grad():
    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<font></font>
        images, labels = data<font></font>
        outputs = net(images)<font></font>
        _, predicted = torch.max(outputs.data, <span class="hljs-number">1</span>)<font></font>
        total += labels.size(<span class="hljs-number">0</span>)<font></font>
        correct += (predicted == labels).sum().item()<font></font>
<font></font>
print(<span class="hljs-string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (
    <span class="hljs-number">100</span> * correct / total))</code></pre><br>
<img src="https://habrastorage.org/webt/fy/i4/cn/fyi4cnkjgimshkhhbsva4udixhw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semble que le réseau connaisse et fonctionne. </font><font style="vertical-align: inherit;">S'il définissait des classes au hasard, la précision serait de 10%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant quelles classes le réseau définit mieux:</font></font><br>
<br>
<pre><code class="python hljs">class_correct = list(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))<font></font>
class_total = list(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))
<span class="hljs-keyword">with</span> torch.no_grad():
    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<font></font>
        images, labels = data<font></font>
        outputs = net(images)<font></font>
        _, predicted = torch.max(outputs, <span class="hljs-number">1</span>)<font></font>
        c = (predicted == labels).squeeze()<font></font>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<font></font>
            label = labels[i]<font></font>
            class_correct[label] += c[i].item()<font></font>
            class_total[label] += <span class="hljs-number">1</span><font></font>
<font></font>
<font></font>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<font></font>
    print(<span class="hljs-string">'Accuracy of %5s : %2d %%'</span> % (<font></font>
        classes[i], <span class="hljs-number">100</span> * class_correct[i] / class_total[i]))</code></pre><br>
<img src="https://habrastorage.org/webt/l9/s9/qu/l9s9quxd-lzx2kh7wphxe9-2qzs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semble que le réseau détermine le mieux les voitures et les navires: précision de 71%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, le réseau fonctionne. </font><font style="vertical-align: inherit;">Essayons maintenant de transférer son travail sur le processeur graphique (GPU) et de voir quels changements.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formation au réseau neuronal GPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, je vais expliquer brièvement ce qu'est CUDA. </font><font style="vertical-align: inherit;">CUDA (Compute Unified Device Architecture) est une plate-forme informatique parallèle développée par NVIDIA pour le calcul général sur GPU. </font><font style="vertical-align: inherit;">Avec CUDA, les développeurs peuvent accélérer considérablement les applications informatiques en utilisant les capacités des GPU. </font><font style="vertical-align: inherit;">Sur notre serveur que nous avons acheté, cette plateforme est déjà installée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définissons d'abord notre GPU comme le premier appareil cuda visible.</font></font><br>
<br>
<pre><code class="python hljs">device = torch . device ( <span class="hljs-string">"cuda:0"</span> <span class="hljs-keyword">if</span> torch . cuda . is_available () <span class="hljs-keyword">else</span> <span class="hljs-string">"cpu"</span> )
<span class="hljs-comment"># Assuming that we are on a CUDA machine, this should print a CUDA device:</span>
<span class="hljs-keyword">print</span> ( device )</code></pre><br>
<img src="https://habrastorage.org/webt/n2/2k/bf/n22kbfvilr6kn30eel6dfhaose4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envoyez le réseau au GPU:</font></font><br>
 <br>
<pre><code class="python hljs">net.to(device)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devrons également envoyer des entrées et des objectifs à chaque étape et au GPU:</font></font><br>
<br>
<pre><code class="python hljs">inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exécutez le recyclage du réseau déjà sur le GPU: </font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<font></font>
<font></font>
criterion = nn.CrossEntropyLoss()<font></font>
optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):  <span class="hljs-comment"># loop over the dataset multiple times</span><font></font>
<font></font>
    running_loss = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> enumerate(trainloader, <span class="hljs-number">0</span>):
        <span class="hljs-comment"># get the inputs; data is a list of [inputs, labels]</span>
    inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)<font></font>
<font></font>
        <span class="hljs-comment"># zero the parameter gradients</span><font></font>
        optimizer.zero_grad()<font></font>
<font></font>
        <span class="hljs-comment"># forward + backward + optimize</span><font></font>
        outputs = net(inputs)<font></font>
        loss = criterion(outputs, labels)<font></font>
        loss.backward()<font></font>
        optimizer.step()<font></font>
<font></font>
        <span class="hljs-comment"># print statistics</span><font></font>
        running_loss += loss.item()<font></font>
        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:    <span class="hljs-comment"># print every 2000 mini-batches</span>
            print(<span class="hljs-string">'[%d, %5d] loss: %.3f'</span> %<font></font>
                  (epoch + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, running_loss / <span class="hljs-number">2000</span>))<font></font>
            running_loss = <span class="hljs-number">0.0</span><font></font>
<font></font>
print(<span class="hljs-string">'Finished Training'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, la formation réseau a duré environ 3 minutes. </font><font style="vertical-align: inherit;">Rappelons que la même étape sur un processeur régulier a duré 5 minutes. </font><font style="vertical-align: inherit;">La différence n'est pas significative, c'est parce que notre réseau n'est pas si grand. </font><font style="vertical-align: inherit;">Lorsque vous utilisez de grandes baies pour la formation, la différence entre la vitesse du GPU et le processeur traditionnel augmentera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela semble être tout. </font><font style="vertical-align: inherit;">Ce que nous avons réussi à faire:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons examiné ce qu'est le GPU et choisi le serveur sur lequel il est installé;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons mis en place un environnement logiciel pour créer un réseau neuronal;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons créé un réseau de neurones pour la reconnaissance d'images et l'avons formé;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons répété la formation du réseau à l'aide du GPU et avons reçu une augmentation de vitesse.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je me ferai un plaisir de répondre aux questions dans les commentaires.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr488548/index.html">Expérience: comment apprendre à créer des textes populaires en anglais (et pourquoi les Habristes anglophones lisent si peu)</a></li>
<li><a href="../fr488550/index.html">Qui veut faire des coopératives des géants de l'informatique</a></li>
<li><a href="../fr488552/index.html">Développeurs Apple FAS et contrôle parental</a></li>
<li><a href="../fr488558/index.html">Assurer une haute disponibilité des applications avec Kafka Streams</a></li>
<li><a href="../fr488560/index.html">Hébergement gratuit de bots Telegram sur Google Cloud Platform</a></li>
<li><a href="../fr488566/index.html">Comment un ingénieur QA a sauvé une journée entière en liant les tests automatiques dans Visual Studio et Test IT</a></li>
<li><a href="../fr488568/index.html">Les réseaux de neurones rêvent-ils d'argent électrique?</a></li>
<li><a href="../fr488570/index.html">Comment les services secrets américains ont confondu le RPG cyberpunk avec un manuel pour les pirates</a></li>
<li><a href="../fr488572/index.html">Les analyseurs Unity sont désormais open-source</a></li>
<li><a href="../fr488574/index.html">Les élèves écrivent le pilote Uart pour STM32F411</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>