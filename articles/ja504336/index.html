<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 👓 🧗🏽 Witcher 3レンダリングのリバースエンジニアリング：天の川、ポータル、カラーグレーディング 👨🏽‍💻 🔍 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[分析の前の部分：最初と2番目、3番目と4番目。]
 
 パート1：天の川
 前回の投稿で、私は流れ星がウィッチャー3でどのように実装されるかについて話しました。ブラッドアンドワインにはそのような影響はありません。投稿では、このDLCにのみ存在する効果について説明します：The Milky Way。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Witcher 3レンダリングのリバースエンジニアリング：天の川、ポータル、カラーグレーディング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504336/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[分析の前の部分：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。]</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1：天の川</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の投稿で、私は流れ星がウィッチャー3でどのように実装されるかについて話しました。</font><font style="vertical-align: inherit;">ブラッドアンドワインにはそのような影響はありません。</font><font style="vertical-align: inherit;">投稿では、このDLCにのみ存在する効果について説明します：The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Milky Way</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
天の川を紹介する動画です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/c8iURjd03vE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしていくつかのスクリーンショット：（1）空のドームを描くための呼び出しの前、（2）天の川の色だけで、（3）呼び出しの後：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリーンショット</font></font></b>
                        <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/903/ccd/842903ccd1787d3a1c5ea8280162cc7a.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/206/cd8/8cf/206cd88cfed00e5934a531a5c496abc5.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26d/31a/317/26d31a3176c9e696c7f09d67ca428b3a.png"></div></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
天の川が1つだけある（空と星の色がない）完成したフレームは、次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb7/7ea/807/eb77ea807cadc8affeb5c475bcf51f36.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2015年版のゲームとの最も大きな違いの1つとなった天の川の効果について</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、「愚かな空のトリック」のセクションで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に説明</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">してい</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">実装方法を見てみましょう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概要はおなじみでしょう。最初に、ジオメトリに関連するすべてを簡単に説明してから、ピクセルシェーダーについて説明します。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.ジオメトリ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、スカイドームメッシュを使用します。</font><font style="vertical-align: inherit;">2015ドーム（メインゲーム+ DLC「ストーンハーツ」、通常「2015ゲーム」と呼びます）とブラッドアンドワインDLC（2016）のドームには2つの重大な違いがあります。a </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
）「血液とワイン」 ”メッシュははるかに高密度です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。b）法線ベクトルベクトルは、KiVスカイドームのメッシュで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こちらが2015年のスカイドームメッシュです-DrawIndexed（720）</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/844/600/53e/84460053ed9f2d004e069dba60356360.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2015年のウィッチャー3の空のドームのメッシュは720インデックス</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ですが、KiVのメッシュはDrawIndexed（2640）です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a83/196/697/a83196697ccf581e35aa507c9b5706f6.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スカイドームDLC「The Witcher 3：Blood and Wine」</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
-2640 </font><i><font style="vertical-align: inherit;">インデックスの</font></i><font style="vertical-align: inherit;">メッシュこれが「KiV」からの別のメッシュです。法線がどのように分布しているかを描きました-法線はメッシュの「中心」に向けられています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e28/db1/186/e28db11861d59198636fc7d80093cc81.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノーマル付きメッシュオブスカイドームDLC「Blood and Wine」</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.頂点シェーダー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スカイドームのトップシェーダーは非常にシンプルです。</font><font style="vertical-align: inherit;">これは対応するアセンブラコードです。</font><font style="vertical-align: inherit;">簡単にするために、SV_Positionの計算は省略しました。</font></font><br>
<br>
<pre><code class="cpp hljs"> vs_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">4</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">6</span>], immediateIndexed  <font></font>
    dcl_input v0.xyz  <font></font>
    dcl_input v1.xy  <font></font>
    dcl_input v2.xyz  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_output o1.xyzw  <font></font>
    dcl_output_siv o2.xyzw, position  <font></font>
    dcl_temps <span class="hljs-number">3</span>  
   <span class="hljs-number">0</span>: mov o0.xy, v1.xyxx  
   <span class="hljs-number">1</span>: mad r0.xyz, v0.xyzx, cb2[<span class="hljs-number">4</span>].xyzx, cb2[<span class="hljs-number">5</span>].xyzx  
   <span class="hljs-number">2</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
   <span class="hljs-number">3</span>: dp4 o0.z, r0.xyzw, cb2[<span class="hljs-number">0</span>].xyzw  
   <span class="hljs-number">4</span>: dp4 o0.w, r0.xyzw, cb2[<span class="hljs-number">1</span>].xyzw  
   <span class="hljs-number">5</span>: mad r1.xyz, v2.xyzx, l(<span class="hljs-number">2.000000</span>, <span class="hljs-number">2.000000</span>, <span class="hljs-number">2.000000</span>, <span class="hljs-number">0.000000</span>), l(<span class="hljs-number">-1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)  
   <span class="hljs-number">6</span>: dp3 r2.x, r1.xyzx, cb2[<span class="hljs-number">0</span>].xyzx  
   <span class="hljs-number">7</span>: dp3 r2.y, r1.xyzx, cb2[<span class="hljs-number">1</span>].xyzx  
   <span class="hljs-number">8</span>: dp3 r2.z, r1.xyzx, cb2[<span class="hljs-number">2</span>].xyzx  
   <span class="hljs-number">9</span>: dp3 r1.x, r2.xyzx, r2.xyzx  
  <span class="hljs-number">10</span>: rsq r1.x, r1.x  
  <span class="hljs-number">11</span>: mul o1.xyz, r1.xxxx, r2.xyzx  
  <span class="hljs-number">12</span>: dp4 o1.w, r0.xyzw, cb2[<span class="hljs-number">2</span>].xyzw  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点バッファーからの入力は次のとおりです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1）ローカル空間での位置[0-1]-v0.xyz、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）Texcoords-v1.xy、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）法線ベクトル[0-1]-v2.xyz cbuffer </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
からの受信データ：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 ）ワールドマトリックス（0-3）-古典的なアプローチ：カメラの位置に応じた均一なスケーリングと変換、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）頂点のスケールとオフセット（4-5）-ローカル空間[0-1]からspace [-1; 1]、およびメッシュの「平坦化」の可能性があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/356/b61/5d3/356b615d3f35e29bb22a7de3df88114e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これがシェーダーで何が起こるかについての簡単な説明です：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーは単純なtexcoords転送から始まります（行0）。</font><font style="vertical-align: inherit;">スケールとオフセットは、ワールド内の頂点の位置に適用され（ライン1）、結果はワールドマトリックスで乗算されます（ライン3〜4、12）。</font><font style="vertical-align: inherit;">法線ベクトルは、間隔[0-1]から[-1; 1]（5行目）に転送する必要があり、次に、ワールドマトリックス（6〜8行目）を掛け、最後に正規化（9〜11行目）します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完成した出力には次のスキームがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/670/219/ded/670219ded77f24df4185ca70360ca6a4.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.ピクセルシェーダー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
天の川の計算は、スカイシェーダーの一部にすぎません。</font><font style="vertical-align: inherit;">KiVでは、2015バージョンよりもはるかに長くなります。</font><font style="vertical-align: inherit;">アセンブラは385行、2015年版は267行で構成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
天の川の原因となるアセンブラーコードの断片を見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">175</span>: sample_indexable(texturecube)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r4.xyz, r2.xyzx, t0.xyzw, s0  
  <span class="hljs-number">176</span>: mul r4.xyz, r4.xyzx, r4.xyzx  
  <span class="hljs-number">177</span>: sample_indexable(texturecube)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r0.w, r2.xyzx, t1.yzwx, s0  
  <span class="hljs-number">178</span>: dp3 r1.w, v1.xyzx, v1.xyzx  
  <span class="hljs-number">179</span>: rsq r1.w, r1.w  
  <span class="hljs-number">180</span>: mul r2.xyz, r1.wwww, v1.xyzx  
  <span class="hljs-number">181</span>: dp3 r1.w, cb12[<span class="hljs-number">204</span>].yzwy, cb12[<span class="hljs-number">204</span>].yzwy  
  <span class="hljs-number">182</span>: rsq r1.w, r1.w  
  <span class="hljs-number">183</span>: mul r5.xyz, r1.wwww, cb12[<span class="hljs-number">204</span>].yzwy  
  <span class="hljs-number">184</span>: dp3 r1.w, r2.xyzx, r5.xyzx  
  <span class="hljs-number">185</span>: mad_sat r0.w, r0.w, l(<span class="hljs-number">0.200000</span>), r1.w  
  <span class="hljs-number">186</span>: ge r1.w, l(<span class="hljs-number">0.497925</span>), r0.w  
  <span class="hljs-number">187</span>: if_nz r1.w  
  <span class="hljs-number">188</span>:  ge r1.w, l(<span class="hljs-number">0.184939</span>), r0.w  
  <span class="hljs-number">189</span>:  mul r2.y, r0.w, l(<span class="hljs-number">5.407188</span>)  
  <span class="hljs-number">190</span>:  min r2.z, r2.y, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">191</span>:  mad r2.w, r2.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">192</span>:  mul r2.z, r2.z, r2.z  
  <span class="hljs-number">193</span>:  mul r2.z, r2.z, r2.w  
  <span class="hljs-number">194</span>:  mul r5.xyz, r2.zzzz, l(<span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">195</span>:  mov r2.x, l(<span class="hljs-number">0.949254</span>)  
  <span class="hljs-number">196</span>:  movc r2.xw, r1.wwww, r2.xxxy, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">197</span>:  <span class="hljs-keyword">not</span> r4.w, r1.w  
  <span class="hljs-number">198</span>:  if_z r1.w  
  <span class="hljs-number">199</span>:   ge r1.w, l(<span class="hljs-number">0.239752</span>), r0.w  
  <span class="hljs-number">200</span>:   add r5.w, r0.w, l(<span class="hljs-number">-0.184939</span>)  
  <span class="hljs-number">201</span>:   mul r6.y, r5.w, l(<span class="hljs-number">18.243849</span>)  
  <span class="hljs-number">202</span>:   mov_sat r5.w, r6.y  
  <span class="hljs-number">203</span>:   mad r6.z, r5.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">204</span>:   mul r5.w, r5.w, r5.w  
  <span class="hljs-number">205</span>:   mul r5.w, r5.w, r6.z  
  <span class="hljs-number">206</span>:   mad r5.w, r5.w, l(<span class="hljs-number">-0.113726</span>), l(<span class="hljs-number">0.949254</span>)  
  <span class="hljs-number">207</span>:   movc r5.xyz, r1.wwww, r5.wwww, r5.zzzz  
  <span class="hljs-number">208</span>:   <span class="hljs-keyword">and</span> r7.xyz, r1.wwww, l(<span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">209</span>:   mov r6.x, l(<span class="hljs-number">0.835528</span>)  
  <span class="hljs-number">210</span>:   movc r2.xw, r1.wwww, r6.xxxy, r2.xxxw  
  <span class="hljs-number">211</span>:   mov r2.xyzw, r2.xxxw  
  <span class="hljs-number">212</span>:  <span class="hljs-keyword">else</span>  
  <span class="hljs-number">213</span>:   mov r7.xyz, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">214</span>:   mov r2.xyzw, r2.xxxw  
  <span class="hljs-number">215</span>:   mov r1.w, l(<span class="hljs-number">-1</span>)  
  <span class="hljs-number">216</span>:  endif  
  <span class="hljs-number">217</span>:  <span class="hljs-keyword">not</span> r5.w, r1.w  
  <span class="hljs-number">218</span>:  <span class="hljs-keyword">and</span> r4.w, r4.w, r5.w  
  <span class="hljs-number">219</span>:  if_nz r4.w  
  <span class="hljs-number">220</span>:   ge r5.w, r0.w, l(<span class="hljs-number">0.239752</span>)  
  <span class="hljs-number">221</span>:   ge r6.x, l(<span class="hljs-number">0.294564</span>), r0.w  
  <span class="hljs-number">222</span>:   <span class="hljs-keyword">and</span> r1.w, r5.w, r6.x  
  <span class="hljs-number">223</span>:   add r5.w, r0.w, l(<span class="hljs-number">-0.239752</span>)  
  <span class="hljs-number">224</span>:   mul r6.w, r5.w, l(<span class="hljs-number">18.244175</span>)  
  <span class="hljs-number">225</span>:   mov_sat r5.w, r6.w  
  <span class="hljs-number">226</span>:   mad r7.w, r5.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">227</span>:   mul r5.w, r5.w, r5.w  
  <span class="hljs-number">228</span>:   mul r5.w, r5.w, r7.w  
  <span class="hljs-number">229</span>:   mad r5.w, r5.w, l(<span class="hljs-number">0.015873</span>), l(<span class="hljs-number">0.835528</span>)  
  <span class="hljs-number">230</span>:   movc r5.xyz, r1.wwww, r5.wwww, r5.xyzx  
  <span class="hljs-number">231</span>:   movc r7.xyz, r1.wwww, l(<span class="hljs-number">0.835528</span>, <span class="hljs-number">0.835528</span>, <span class="hljs-number">0.835528</span>, <span class="hljs-number">0.000000</span>), r7.xyzx  
  <span class="hljs-number">232</span>:   mov r6.xyz, l(<span class="hljs-number">0.851401</span>, <span class="hljs-number">0.851401</span>, <span class="hljs-number">0.851401</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">233</span>:   movc r2.xyzw, r1.wwww, r6.xyzw, r2.xyzw  
  <span class="hljs-number">234</span>:  endif  
  <span class="hljs-number">235</span>:  <span class="hljs-keyword">not</span> r5.w, r1.w  
  <span class="hljs-number">236</span>:  <span class="hljs-keyword">and</span> r4.w, r4.w, r5.w  
  <span class="hljs-number">237</span>:  if_nz r4.w  
  <span class="hljs-number">238</span>:   ge r1.w, r0.w, l(<span class="hljs-number">0.294564</span>)  
  <span class="hljs-number">239</span>:   add r0.w, r0.w, l(<span class="hljs-number">-0.294564</span>)  
  <span class="hljs-number">240</span>:   mul r6.w, r0.w, l(<span class="hljs-number">4.917364</span>)  
  <span class="hljs-number">241</span>:   mov_sat r0.w, r6.w  
  <span class="hljs-number">242</span>:   mad r4.w, r0.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">243</span>:   mul r0.w, r0.w, r0.w  
  <span class="hljs-number">244</span>:   mul r0.w, r0.w, r4.w  
  <span class="hljs-number">245</span>:   mad r0.w, r0.w, l(<span class="hljs-number">-0.851401</span>), l(<span class="hljs-number">0.851401</span>)  
  <span class="hljs-number">246</span>:   movc r5.xyz, r1.wwww, r0.wwww, r5.xyzx  
  <span class="hljs-number">247</span>:   movc r7.xyz, r1.wwww, l(<span class="hljs-number">0.851401</span>, <span class="hljs-number">0.851401</span>, <span class="hljs-number">0.851401</span>, <span class="hljs-number">0.000000</span>), r7.xyzx  
  <span class="hljs-number">248</span>:   mov r6.xyz, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">249</span>:   movc r2.xyzw, r1.wwww, r6.xyzw, r2.xyzw  
  <span class="hljs-number">250</span>:  endif  
  <span class="hljs-number">251</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">252</span>:  mov r7.xyz, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">253</span>:  mov r2.xyzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">254</span>:  mov r1.w, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">255</span>: endif  
  <span class="hljs-number">256</span>: mov_sat r2.w, r2.w  
  <span class="hljs-number">257</span>: mad r0.w, r2.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">258</span>: mul r2.w, r2.w, r2.w  
  <span class="hljs-number">259</span>: mul r0.w, r0.w, r2.w  
  <span class="hljs-number">260</span>: add r2.xyz, -r7.xyzx, r2.xyzx  
  <span class="hljs-number">261</span>: mad r2.xyz, r0.wwww, r2.xyzx, r7.xyzx  
  <span class="hljs-number">262</span>: movc r2.xyz, r1.wwww, r5.xyzx, r2.xyzx  
  <span class="hljs-number">263</span>: mul r2.xyz, r2.xyzx, l(<span class="hljs-number">0.150000</span>, <span class="hljs-number">0.200000</span>, <span class="hljs-number">0.250000</span>, <span class="hljs-number">0.000000</span>)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かなり怖いですね。初めて彼に会ったとき（これは流れ星のシェーダーを見る前でした）、私はこう思いました。このコードを元に戻すことはできません！」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、1つの側面があります。流星に関する投稿を読むと、このパターンを簡単に認識できます。コードは隕石のレンダリングと非常によく似ています！すぐにカーブについて話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントは、星の3次マップのサンプリング（行175）で始まり、サンプリングの方向はr2.xyzに格納されています。ご覧のとおり、行177には別の3次マップをサンプリングするための指示があります。 2015シェーダーとは異なり、KiVシェーダーには「キュービックノイズマップ」と呼ばれる別のテクスチャがあり、そのエッジは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/fe8/3a4/50efe83a4cb977aa1497c9a6addf7931.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
曲線に到達する前に、その入力を見つけましょう。</font><font style="vertical-align: inherit;">まず、スカイドームの正規化された法線ベクトル（ライン178〜180）と月の光ベクトル（ライン181-183）の間でスカラー積（ライン184）が計算されます。実際、これはN * Lです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、スカラー積（線形空間内）の可視化です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/597/f45/3c6597f453f7c751ab60c985fcc6f937.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
天の川曲線関数の入力として使用される値は、行185で取得されます</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。x =飽和（ノイズ* 0.2 + Ndot）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これも線形空間でのそのような歪んだN * Lの可視化です：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fb/570/61c/5fb57061c7387ed9853c855351b1ba8a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、天の川機能に移りましょう！</font><font style="vertical-align: inherit;">流れ星の機能より少し複雑です。</font><font style="vertical-align: inherit;">前の投稿で述べたように、x軸に沿った制御点のリストから始めます。</font><font style="vertical-align: inherit;">アセンブラコードを見て、すぐにそれらを見るでしょう：</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Control points (x-axis)  </span>
   <span class="hljs-keyword">float</span> controlPoint0 = <span class="hljs-number">0.0</span>;  
   <span class="hljs-keyword">float</span> controlPoint1 = <span class="hljs-number">0.184939</span>;  
   <span class="hljs-keyword">float</span> controlPoint2 = <span class="hljs-number">0.239752</span>;  
   <span class="hljs-keyword">float</span> controlPoint3 = <span class="hljs-number">0.294564</span>;  
   <span class="hljs-keyword">float</span> controlPoint4 = <span class="hljs-number">0.497925</span>;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の制御点がゼロであることをどのように知ることができますか？</font><font style="vertical-align: inherit;">これは非常に簡単です。189行目にはaddステートメントがありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流れ星に関する投稿によると、コントロールポイントはセグメントの数を決定し、次にそれらの重みを見つける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のセグメントは非常に単純です。</font><font style="vertical-align: inherit;">重量は0.949254です。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">194</span>: mul r5.xyz, r2.zzzz, l(<span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.000000</span>)   
  <span class="hljs-number">195</span>: mov r2.x, l(<span class="hljs-number">0.949254</span>)   </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目と3番目のセグメントでそれらを見つけてみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">206</span>:  mad r5.w, r5.w, l(<span class="hljs-number">-0.113726</span>), l(<span class="hljs-number">0.949254</span>)   
  <span class="hljs-number">207</span>:  movc r5.xyz, r1.wwww, r5.wwww, r5.zzzz   
  <span class="hljs-number">208</span>:  <span class="hljs-keyword">and</span> r7.xyz, r1.wwww, l(<span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.949254</span>, <span class="hljs-number">0.000000</span>)   
  <span class="hljs-number">209</span>:  mov r6.x, l(<span class="hljs-number">0.835528</span>)   <font></font>
  ...  <font></font>
  <span class="hljs-number">229</span>:  mad r5.w, r5.w, l(<span class="hljs-number">0.015873</span>), l(<span class="hljs-number">0.835528</span>)   
  <span class="hljs-number">230</span>:  movc r5.xyz, r1.wwww, r5.wwww, r5.xyzx   
  <span class="hljs-number">231</span>:  movc r7.xyz, r1.wwww, l(<span class="hljs-number">0.835528</span>, <span class="hljs-number">0.835528</span>, <span class="hljs-number">0.835528</span>, <span class="hljs-number">0.000000</span>), r7.xyzx   
  <span class="hljs-number">232</span>:  mov r6.xyz, l(<span class="hljs-number">0.851401</span>, <span class="hljs-number">0.851401</span>, <span class="hljs-number">0.851401</span>, <span class="hljs-number">0.000000</span>)   </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何か問題があったため、記事の作成をやめたのはこのときでした（「うーん」と思う瞬間の1つ）。</font><font style="vertical-align: inherit;">ほら、すべてが1つの重みによる単純な乗算ほど簡単ではありません。</font><font style="vertical-align: inherit;">また、-0.113726や0.015873のような値はどこから来たのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、これらの値は単に各セグメントの最大可能値の差であることがわかりました（0.835528-0.949254 = -0.113726および0.851401-0.835528 = 0.015873）！</font><font style="vertical-align: inherit;">かなり明白です（「エウレカ！」と思う瞬間の1つ）。</font><font style="vertical-align: inherit;">結局のところ、これらの値は重みではなく、単に曲線を形成する点のy座標です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、多くの変更と簡素化が行われます。</font><font style="vertical-align: inherit;">最初に、前の投稿で使用された関数の重みを取り除くことができます</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getSmoothTransition</span><span class="hljs-params">(<span class="hljs-keyword">float</span> cpLeft, <span class="hljs-keyword">float</span> cpRight, <span class="hljs-keyword">float</span> x)</span>  
 </span>{  
   <span class="hljs-keyword">return</span> smoothstep( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, linstep(cpLeft, cpRight, x) );  <font></font>
 }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちは次のように天の川の関数を書くことができます：</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">milkyway_curve</span><span class="hljs-params">( <span class="hljs-keyword">float</span> x )</span>  
 </span>{  
   <span class="hljs-comment">// Define a set of 2D points which form the curve</span>
   <span class="hljs-comment">// Of course, you can use a Point2D-like struct here</span><font></font>
 <font></font>
   <span class="hljs-comment">// Control points (x-axis)</span>
   <span class="hljs-keyword">float</span> controlPoint0 = <span class="hljs-number">0.0</span>;  
   <span class="hljs-keyword">float</span> controlPoint1 = <span class="hljs-number">0.184939</span>;  
   <span class="hljs-keyword">float</span> controlPoint2 = <span class="hljs-number">0.239752</span>;  
   <span class="hljs-keyword">float</span> controlPoint3 = <span class="hljs-number">0.294564</span>;  
   <span class="hljs-keyword">float</span> controlPoint4 = <span class="hljs-number">0.497925</span>;  <font></font>
     <font></font>
   <span class="hljs-comment">// Values at points (y-axis)  </span>
   <span class="hljs-keyword">float</span> value0 = <span class="hljs-number">0.0</span>;  
   <span class="hljs-keyword">float</span> value1 = <span class="hljs-number">0.949254</span>;  
   <span class="hljs-keyword">float</span> value2 = <span class="hljs-number">0.835528</span>;  
   <span class="hljs-keyword">float</span> value3 = <span class="hljs-number">0.851401</span>;  
   <span class="hljs-keyword">float</span> value4 = <span class="hljs-number">0.0</span>;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> function_value = <span class="hljs-number">0.0</span>;  <font></font>
     <font></font>
   [branch] <span class="hljs-keyword">if</span> (x &lt;= controlPoint4)  <font></font>
   {  <font></font>
     [branch] <span class="hljs-keyword">if</span> (x &lt;= controlPoint1)  <font></font>
     {  <font></font>
       <span class="hljs-keyword">float</span> t = getSmoothTransition(controlPoint0, controlPoint1, x);  <font></font>
       function_value = lerp(value0, value1, t);  <font></font>
     }  <font></font>
       <font></font>
     [branch] <span class="hljs-keyword">if</span> (x &gt;= controlPoint1 &amp;&amp; x &lt;= controlPoint2)  <font></font>
     {  <font></font>
       <span class="hljs-keyword">float</span> t = getSmoothTransition(controlPoint1, controlPoint2, x);  <font></font>
       function_value = lerp(value1, value2, t);  <font></font>
     }  <font></font>
       <font></font>
     [branch] <span class="hljs-keyword">if</span> (x &gt;= controlPoint2 &amp;&amp; x &lt;= controlPoint3)  <font></font>
     {  <font></font>
       <span class="hljs-keyword">float</span> t = getSmoothTransition(controlPoint2, controlPoint3, x);  <font></font>
       function_value = lerp(value2, value3, t);  <font></font>
     }  <font></font>
       <font></font>
     [branch] <span class="hljs-keyword">if</span> (x &gt;= controlPoint3)  <font></font>
     {  <font></font>
       <span class="hljs-keyword">float</span> t = getSmoothTransition(controlPoint3, controlPoint4, x);  <font></font>
       function_value = lerp(value3, value4, t);       <font></font>
     }      <font></font>
   }  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> function_value;  <font></font>
 }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、滑らかな曲線を形成する任意の数のポイントに対する一般化されたソリューションです。</font><font style="vertical-align: inherit;">さらに、それは制御点の「奇妙な」値の起源を説明しています-おそらく開発者はある種のビジュアルエディターを使用して点を設定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、同じ原理が流れ星のコードにも当てはまります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが関数グラフです：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/1b7/6fe/e7d1b76fe163d6dca4341619cba73e28.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天の川関数のグラフ。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤は関数の値、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
緑はx </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
座標、青はy座標、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
黄色の点はコントロールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、次はどうでしょうか。</font><font style="vertical-align: inherit;">263行目で、関数の値に青みがかった色を掛けています。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-number">263</span>: mul r2.xyz, r2.xyzx, l(<span class="hljs-number">0.150000</span>, <span class="hljs-number">0.200000</span>, <span class="hljs-number">0.250000</span>, <span class="hljs-number">0.000000</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これで終わりではありません！</font><font style="vertical-align: inherit;">ガンマ補正を実行するだけです：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">263</span>: mul r2.xyz, r2.xyzx, l(<span class="hljs-number">0.150000</span>, <span class="hljs-number">0.200000</span>, <span class="hljs-number">0.250000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">264</span>: mad r2.xyz, r4.xyzx, l(<span class="hljs-number">3.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">0.000000</span>), r2.xyzx  <font></font>
  ...  <font></font>
  <span class="hljs-number">269</span>: <span class="hljs-built_in">log</span> r2.xyz, r2.xyzx  
  <span class="hljs-number">270</span>: mul r2.xyz, r2.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">271</span>: <span class="hljs-built_in">exp</span> r2.xyz, r2.xyzx </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで興味深いのは、x軸に沿ってコントロールポイントに異なる色を割り当てたことです。</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 gradient0 = float3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <font></font>
   float3 gradient1 = float3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <font></font>
   float3 gradient2 = float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <font></font>
   float3 gradient3 = float3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <font></font>
   float3 gradient4 = float3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここに私が得たものがあります：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/62b/ac8/f6062bac8e1920787172e0653e9075c5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、天の川のためにほとんどすべてが行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Line 264にはr4.xyzと...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Tussentの星（ボーナス）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事のこの部分が天の川と呼ばれていることは知っていますが、Tussentのスターがどのようにして作成されたかを簡単に説明することはできませんでした。</font><font style="vertical-align: inherit;">それらはノヴィグラード、スケリグ、またはヴェレンよりもはるかに明るいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、前のポスト、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は2015年の星の話しました。</font><font style="vertical-align: inherit;">2016年のスターについてお話ししましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、アセンブラーコードの大部分は次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">175</span>: sample_indexable(texturecube)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r4.xyz, r2.xyzx, t0.xyzw, s0   
  <span class="hljs-number">176</span>: mul r4.xyz, r4.xyzx, r4.xyzx   <font></font>
  ...  <font></font>
  <span class="hljs-number">264</span>: mad r2.xyz, r4.xyzx, l(<span class="hljs-number">3.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">0.000000</span>), r2.xyzx   <font></font>
  ...   <font></font>
  <span class="hljs-number">269</span>: <span class="hljs-built_in">log</span> r2.xyz, r2.xyzx   
  <span class="hljs-number">270</span>: mul r2.xyz, r2.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)   
  <span class="hljs-number">271</span>: <span class="hljs-built_in">exp</span> r2.xyz, r2.xyzx   <font></font>
  ...  <font></font>
  <span class="hljs-number">302</span>: add r0.z, -cb0[<span class="hljs-number">9</span>].w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">303</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">304</span>: add r2.xyz, r2.xyzx, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSLでは、次のように記述できます。</font></font><br>
<br>
<pre><code class="cpp hljs"> float3 stars = texStars.Sample(sampler, starsDir).rgb;  <font></font>
 stars *= stars;  <font></font>
   <font></font>
 float3 milkyway = milkyway_func(noisePerturbed) * float3(<span class="hljs-number">0.15</span>, <span class="hljs-number">0.20</span>, <span class="hljs-number">0.25</span>);  <font></font>
 float3 skyContribution = milkyway + <span class="hljs-number">3.0</span> * stars;  <font></font>
   <font></font>
 <span class="hljs-comment">// gamma correction  </span>
 skyContribution = <span class="hljs-built_in">pow</span>(skyContribution, <span class="hljs-number">2.2</span>);  <font></font>
   <font></font>
 <span class="hljs-comment">// starsOpacity - 0.0 during the day (so stars and the Milky Way are not visible then), 1.0 during the night  </span>
 <span class="hljs-keyword">float</span> starsOpacity = <span class="hljs-number">1.0</span> - cb0_v9.w;  <font></font>
 skyContribution *= starsOpacity;  <font></font>
<font></font>
 skyContribution *= <span class="hljs-number">2</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、星自体は単純に3倍され（264行目）、次に天の川の影響に2倍されます（304行目）-昔ながらの方法ですが、うまく機能します！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、後で何か他のことが起こります（たとえば、整数ノイズで星がちらつくなど）が、これは記事のトピックには適用されません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この部分では、 『ウィッチャー3：ブラッドアンドワイン』、天の川、そして星々がどのように実装されているかを理解しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のシェーダーを先ほど書いたコードに置き換えましょう。</font><font style="vertical-align: inherit;">完成したフレームは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/121/db2/b0c/121db2b0c6dc42db8671e920246123ab.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のシェーダーでは、フレームは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09b/a5b/ca8/09ba5bca883343c1c198d095310b9016.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪くない。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2：カラーグレーディング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Witcher 3のほぼすべてに見られる後処理の効果の1つは、カラーグレーディングです。</font><font style="vertical-align: inherit;">その原理は、ルックアップテーブルテクスチャ（LUT）を使用して、ある色のセットを別の色のセットに変換することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、プロセスは次のようになります。AdobePhotoshopなどのツールで編集されるニュートラル（出力カラー=入力カラー）ルックアップテーブルがあり、コントラスト/明るさ/彩度/色相などが強化されています。リアルタイムで計算するとき。</font><font style="vertical-align: inherit;">LUTのおかげで、これらの操作はテクスチャ内のより安価な検索に置き換えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が知っているLUTカラーテーブルは少なくとも3つあります。3次元、「長い」2次元、および「正方形」の2次元です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c42/22f/103/c4222f1037010c3662fd73c94e7c8a36.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュートラルな「長い」2次元LUT</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/497/c99/85c/497c9985c332d18cdea9023c3b33a5c4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュートラル「四角」の二次元LUT</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我々はウィッチャー3で色補正の実装に移る前に、ここではこの技術上のいくつかの有用なリンクです：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オンラインデモとの良好なOpenGLの実装</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カラー補正</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタルギアソリッドVグラフィックスを学ぶ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一般的には良い記事は、セクションがあります色補正について）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Habréの翻訳] </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索テクスチャ（LUT）を使用した色補正</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gamedev.netフォーラムのトピック</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本「GPU Gems 2」の記事</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">-3 </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">次元テクスチャを使用した色補正</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カラーLUTの作成と使用に関するUE4のドキュメント</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
LUTの例を見てみましょうゲームの初め頃に使用されたホワイトオーチャード-緑のほとんどが黄色に置き換えられました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/840/f54/814/840f54814faa5f6ae11cfa9890fcc42d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Witcher 3は、サイズが512x512の2次元テクスチャを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、色補正はLDR空間で実行されることが予想されます。したがって、256の</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つの</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な入力値が</font><font style="vertical-align: inherit;">取得され</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">-1600 </font><font style="vertical-align: inherit;">万以上の組み合わせ、合計512 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 262 144の値</font><font style="vertical-align: inherit;">に変換され</font><font style="vertical-align: inherit;">ます。入力値の全範囲をカバーするために、バイリニアサンプリングが使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較のためのスクリーンショットを次に示します。カラーグレーディングの通過前後。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/318/e4b/20d/318e4b20d4828bdba7f58759ba399bf0.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df6/77c/268/df677c268bbf640a0561048116b679be.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、違いはわずかですが、目立ちます。空はオレンジ色がかっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Witcher 3の実装に関しては、入力レンダーターゲットと出力レンダーターゲットの両方がフルスクリーンの浮動小数点テクスチャー（R11G11B10）です。特にこのシーンでは、最も明るいピクセル（太陽の近く）のチャネルの値が1.0fを超える-ほぼ2.0fであるのは興味深いことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルシェーダーのアセンブラーコードは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb3[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_sampler s0, mode_default  <font></font>
    dcl_sampler s1, <span class="hljs-function">mode_default  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    dcl_input_ps linear v1.xy  
    dcl_output o0.xyzw  
    dcl_temps 5  
   0: max r0.xy, v1.xyxx, cb3[0].xyxx  
   1: min r0.xy, r0.xyxx, cb3[0].zwzz  
   2: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r0.xyzw, r0.xyxx, t0.xyzw, s0  
   3: <span class="hljs-built_in">log</span> r1.xyz, <span class="hljs-title">abs</span><span class="hljs-params">(r0.xyzx)</span>  
   4: mul r1.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.454545</span>, <span class="hljs-number">0.454545</span>, <span class="hljs-number">0.454545</span>, <span class="hljs-number">0.000000</span>)</span>  
   5: <span class="hljs-built_in">exp</span> r1.xyz, r1.xyzx  
   6: mad r2.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.996094</span>, <span class="hljs-number">0.000000</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.015625</span>, <span class="hljs-number">0.000000</span>)</span>  
   7: min r2.xyz, r2.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
   8: min r2.z, r2.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.999990</span>)</span>  
   9: add r2.xy, r2.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.007813</span>, <span class="hljs-number">0.007813</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  10: mul r2.xyzw, r2.xyzz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.996094</span>, <span class="hljs-number">0.996094</span>, <span class="hljs-number">64.000000</span>, <span class="hljs-number">8.000000</span>)</span>  
  11: max r2.xy, r2.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.015625</span>, <span class="hljs-number">0.015625</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  12: min r2.xy, r2.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.984375</span>, <span class="hljs-number">0.984375</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  13: round_ni r3.xz, r2.wwww  
  14: mad r2.z, -r3.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">8.000000</span>)</span>, r2.z  
  15: round_ni r3.y, r2.z  
  16: mul r2.zw, r3.yyyz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>)</span>  
  17: mad r2.xy, r2.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>, r2.zwzz  
  18: <span class="hljs-title">sample_l</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r2.xyz, r2.xyxx, t1.xyzw, s1, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  19: mul r2.w, r1.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">63.750000</span>)</span>  
  20: round_ni r2.w, r2.w  
  21: mul r1.w, r2.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.015625</span>)</span>  
  22: mad r1.z, r1.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">63.750000</span>)</span>, -r2.w  
  23: min r1.xyw, r1.xyxw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  24: min r1.w, r1.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.999990</span>)</span>  
  25: add r1.xy, r1.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.007813</span>, <span class="hljs-number">0.007813</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  26: mul r1.xy, r1.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.996094</span>, <span class="hljs-number">0.996094</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  27: max r1.xy, r1.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.015625</span>, <span class="hljs-number">0.015625</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  28: min r1.xy, r1.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.984375</span>, <span class="hljs-number">0.984375</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  29: mul r3.xy, r1.wwww, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">64.000000</span>, <span class="hljs-number">8.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  30: round_ni r4.xz, r3.yyyy  
  31: mad r1.w, -r4.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">8.000000</span>)</span>, r3.x  
  32: round_ni r4.y, r1.w  
  33: mul r3.xy, r4.yzyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  34: mad r1.xy, r1.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>, r3.xyxx  
  35: <span class="hljs-title">sample_l</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.xyw, r1.xyxx, t1.xywz, s1, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  36: add r2.xyz, -r1.xywx, r2.xyzx  
  37: mad r1.xyz, r1.zzzz, r2.xyzx, r1.xywx  
  38: <span class="hljs-built_in">log</span> r1.xyz, <span class="hljs-title">abs</span><span class="hljs-params">(r1.xyzx)</span>  
  39: mul r1.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)</span>  
  40: <span class="hljs-built_in">exp</span> r1.xyz, r1.xyzx  
  41: mad r1.xyz, cb3[1].zzzz, r1.xyzx, -r0.xyzx  
  42: mad o0.xyz, cb3[1].yyyy, r1.xyzx, r0.xyzx  
  43: mov o0.w, r0.w  
  44: ret  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、The Witcher 3の開発者は、ホイールを再発明せず、多くの「信頼できる」コードを使用しました。これは、テクスチャの座標に非常に注意する必要があるエフェクトの1つであるため、これは論理的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、LUTへの2つの要求が必要です。これは、2Dテクスチャを使用した結果です-青チャネルのバイリニアサンプリングをシミュレートする必要があります。上記のリンクで提供されているOpenGL実装では、これら2つの要求のマージは、青チャネルの小数部分に依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私にとって興味深いのは、アセンブラー・コードに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ceil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">round_pi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frac</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">命令がないこと</font><font style="vertical-align: inherit;">でした。ただし、その中にはかなりの数の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">floor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">round_ni</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">命令があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーは、最初に着信カラーテクスチャを取得し、そこからガンマ空間で色を抽出します。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-function">float3 <span class="hljs-title">LinearToGamma</span><span class="hljs-params">(float3 c)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(c, <span class="hljs-number">1.0</span>/<span class="hljs-number">2.2</span>); }
   <span class="hljs-function">float3 <span class="hljs-title">GammaToLinear</span><span class="hljs-params">(float3 c)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(c, <span class="hljs-number">2.2</span>); }<font></font>
<font></font>
   ...   <font></font>
<font></font>
   <span class="hljs-comment">// Set range of allowed texcoords  </span><font></font>
   float2 minAllowedUV = cb3_v0.xy;  <font></font>
   float2 maxAllowedUV = cb3_v0.zw;  <font></font>
   float2 samplingUV = clamp( Input.Texcoords, minAllowedUV, maxAllowedUV );  <font></font>
   <font></font>
   <span class="hljs-comment">// Get color in *linear* space  </span><font></font>
   float4 inputColorLinear = texture0.Sample( samplerPointClamp, samplingUV );<font></font>
<font></font>
   <span class="hljs-comment">// Calculate color in *gamma* space for RGB</span>
   float3 inputColorGamma = LinearToGamma( inputColorLinear.rgb ); </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有効なサンプリング座標の最小値と最大値はcbufferから取得されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/7b7/829/2237b7829985f28e80d5acab4969cc3f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特定のフレームは1920x1080の解像度でキャプチャされました-最大値は次のとおりです：（1919 / 1920、1079 / 1080）シェーダーのアセンブラー</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードに2つの非常によく似たブロックが含まれ、それに続いてLUTからデータを取得することは簡単にわかります。</font><font style="vertical-align: inherit;">そこで、LUTのUVを計算するヘルパー関数を作成しました。</font><font style="vertical-align: inherit;">最初に、対応するアセンブラコードを見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">7</span>: min r2.xyz, r2.xyzx, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>)  
   <span class="hljs-number">8</span>: min r2.z, r2.z, l(<span class="hljs-number">0.999990</span>)  
   <span class="hljs-number">9</span>: add r2.xy, r2.xyxx, l(<span class="hljs-number">0.007813</span>, <span class="hljs-number">0.007813</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">10</span>: mul r2.xyzw, r2.xyzz, l(<span class="hljs-number">0.996094</span>, <span class="hljs-number">0.996094</span>, <span class="hljs-number">64.000000</span>, <span class="hljs-number">8.000000</span>)  
  <span class="hljs-number">11</span>: max r2.xy, r2.xyxx, l(<span class="hljs-number">0.015625</span>, <span class="hljs-number">0.015625</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">12</span>: min r2.xy, r2.xyxx, l(<span class="hljs-number">0.984375</span>, <span class="hljs-number">0.984375</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">13</span>: round_ni r3.xz, r2.wwww  
  <span class="hljs-number">14</span>: mad r2.z, -r3.x, l(<span class="hljs-number">8.000000</span>), r2.z  
  <span class="hljs-number">15</span>: round_ni r3.y, r2.z  
  <span class="hljs-number">16</span>: mul r2.zw, r3.yyyz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>)  
  <span class="hljs-number">17</span>: mad r2.xy, r2.xyxx, l(<span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>), r2.zwzz  
  <span class="hljs-number">18</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r2.xyz, r2.xyxx, t1.xyzw, s1, l(<span class="hljs-number">0</span>)  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、r2.xyzは入力色です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に発生するのは、着信データが間隔[0-1]にあるかどうかを確認することです。 （7行目）。これは、たとえば、前述の太陽のピクセルのように、コンポーネントが1.0より大きいピクセルに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、青のチャネルに0.99999（8行目）を掛けて、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">floor（color.b）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が[0-7]の間隔で値を返すようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LUT座標を計算するために、シェーダーは最初に赤と緑のチャネルを左上のセグメントから「スクイーズ」に変換します。青チャネル[0-1]は、検索テクスチャ内のすべての64セグメントに対応する64のフラグメントにカットされます。青チャネルの現在の値に基づいて、対応するセグメントが選択され、そのオフセットが計算されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、（0.75、0.5、1.0）を選択してみましょう。赤と緑のチャネルは左上のセグメントに変換され、次のようになります</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。float2 rgOffset =（0.75、0.5）/ 8 =（0.09375、0.0625）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、64のセグメントのどれに青の値（1.0）があるかを確認します。もちろん、私たちの場合、これは最後のセグメント</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-64です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">オフセットはセグメント（rowOffset、columnOffset）で表され</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。float blue_rowOffset = 7.0; </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">float blue_columnOffset = 7.0; </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">float2 blueOffset = float2（blue_rowOffset、blue_columnOffset）/ 8.0 =（0.875、0.875）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最後に、オフセットを要約します</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。float2 finalUV = rgOffset + blueOffset; </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalUV =&nbsp; </font></font></i><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></i><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.09375、0.0625 </font></font></i><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+&nbsp; </font></font></i><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（0.875、0.875）=（0.96875、0.9375）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはほんの一例です。次に、実装の詳細を調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤と緑のチャネル（r2.xy）の場合、ライン9は0.5ピクセルのオフセット（0.5 / 64）を追加します。次に、それらに0.996094を掛けて（行10）、それらを特別な間隔（行11〜12）に制限します（クランプ）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハーフピクセルオフセットの必要性はかなり明白です。ピクセルの中心からサンプリングする必要があります。はるかに神秘的な側面は、10行目からのスケーリング係数です-63.75 / 64.0です。すぐにその詳細をお伝えします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、座標は間隔[1/64-63/64]に制限されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜ私たちはこれが必要なのですか？確かではありませんが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイリニアサンプリング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がセグメントの外のサンプルを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">取得し</font></a><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">ように行われているようです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、このクランプ操作がどのように機能するかを示す6x6セグメントのサンプル画像です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/6d8/4b7/d926d84b74f64e3d9e72df7d9be882e1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはクランプを適用していないシーンです-太陽の周りのかなり深刻な変色に注意してください：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/533/ee6/38c533ee6220117ab9bba3d37c622998.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較を簡単にするために、ゲームの結果をもう一度示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df6/77c/268/df677c268bbf640a0561048116b679be.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この部分のコードスニペットは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// * Calculate red/green offset  </span><font></font>
        <font></font>
   <span class="hljs-comment">// half-pixel offset to always sample within centre of a pixel  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> halfOffset = <span class="hljs-number">0.5</span> / <span class="hljs-number">64.0</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> scale = <span class="hljs-number">63.75</span>/<span class="hljs-number">64.0</span>;  <font></font>
      <font></font>
   float2 rgOffset;  <font></font>
   rgOffset = halfOffset + color.rg;  <font></font>
   rgOffset *= scale;  <font></font>
   <font></font>
   rgOffset.xy = clamp(rgOffset.xy, float2(<span class="hljs-number">1.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">64.0</span>), float2(<span class="hljs-number">63.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">63.0</span>/<span class="hljs-number">64.0</span>) );  <font></font>
   <font></font>
   <span class="hljs-comment">// place within the top left slice  </span>
   rgOffset.xy /= <span class="hljs-number">8.0</span>;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、青チャネルのオフセットを見つけます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラインオフセットを見つけるために、青のチャネルは8つの部分に分割され、それぞれがサーチテクスチャの1つのラインを正確にカバーします。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// rows  </span>
   bOffset.y = <span class="hljs-built_in">floor</span>(color.b * <span class="hljs-number">8</span>);  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列のオフセットを見つけるには、結果の値を行の8つのセグメントすべてに対応する8つの小さな部分に再度分割する必要があります。</font><font style="vertical-align: inherit;">シェーダーの方程式はかなり混乱しています。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// columns  </span>
   bOffset.x = <span class="hljs-built_in">floor</span>(color.b * <span class="hljs-number">64</span> - <span class="hljs-number">8</span>*bOffset.y );      </code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階では、注目に値します</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。frac（x）= x-floor（x）</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
したがって、方程式は次のように書き直すことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"> bOffset.x = <span class="hljs-built_in">floor</span>(<span class="hljs-number">8</span> * frac(color.b * <span class="hljs-number">8</span>) );  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これはこのためのコードスニペットです：</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// * Calculate blue offset  </span><font></font>
   float2 bOffset;  <font></font>
     <font></font>
   <span class="hljs-comment">// rows  </span>
   bOffset.y = <span class="hljs-built_in">floor</span>(color.b * <span class="hljs-number">8</span>);  <font></font>
     <font></font>
   <span class="hljs-comment">// columns  </span>
   bOffset.x = <span class="hljs-built_in">floor</span>(color.b * <span class="hljs-number">64</span> - <span class="hljs-number">8</span>*bOffset.y );      
   <span class="hljs-comment">// or: </span>
   <span class="hljs-comment">// bOffset.x = floor(8 * frac(color.b * 8) );  </span><font></font>
     <font></font>
   <span class="hljs-comment">// at this moment bOffset stores values in [0-7] range, we have to divide it by 8.0.  </span>
   bOffset /= <span class="hljs-number">8.0</span>;  <font></font>
     <font></font>
   float2 lutPos = rgOffset + bOffset;  <font></font>
   <span class="hljs-keyword">return</span> lutPos;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、LUTテクスチャをサンプリングするためのテクスチャ座標を返す関数を得ました。</font><font style="vertical-align: inherit;">この関数を「getUV」と呼びましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function">float2 <span class="hljs-title">getUV</span><span class="hljs-params">(in float3 color)</span>  
 </span>{  <font></font>
  ...  <font></font>
 }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーのメイン機能に戻ります。</font><font style="vertical-align: inherit;">上記のように、2次元LUTを使用して青チャネルのバイリニアサンプリングをシミュレートするため、LUTへの2つの要求（互いに隣接する2つのセグメントから）が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のHLSLスニペットを検討してください。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Part 1  </span>
   <span class="hljs-keyword">float</span> scale_1 = <span class="hljs-number">63.75</span>/<span class="hljs-number">64.0</span>;  
   <span class="hljs-keyword">float</span> offset_1 = <span class="hljs-number">1.0</span>/<span class="hljs-number">64.0</span>;   <span class="hljs-comment">// 0.015625  </span><font></font>
   float3 inputColor1 = inputColorGamma;    <font></font>
   inputColor1.b = inputColor1.b * scale_1 + offset_1;  <font></font>
     <font></font>
   float2 uv1 = getUV(inputColor1);  <font></font>
   float3 color1 = texLUT.SampleLevel( sampler1, uv1, <span class="hljs-number">0</span> ).rgb;  <font></font>
     <font></font>
   <span class="hljs-comment">// Part 2  </span><font></font>
   float3 inputColor2 = inputColorGamma;  <font></font>
   inputColor2.b = <span class="hljs-built_in">floor</span>(inputColorGamma.b * <span class="hljs-number">63.75</span>) / <span class="hljs-number">64</span>;  <font></font>
     <font></font>
   float2 uv2 = getUV(inputColor2);  <font></font>
   float3 color2 = texLUT.SampleLevel( sampler1, uv2, <span class="hljs-number">0</span> ).rgb;  <font></font>
<font></font>
   <span class="hljs-comment">// frac(x) = x - floor(x);</span>
   <span class="hljs-comment">//float blueInterp = inputColorGamma.b*63.75 - floor(inputColorGamma.b * 63.75);</span>
   <span class="hljs-keyword">float</span> blueInterp = frac(inputColorGamma.b * <span class="hljs-number">63.75</span>);<font></font>
    <font></font>
   <span class="hljs-comment">// Final LUT-corrected color</span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedMult = cb3_v1.z;<font></font>
    <font></font>
   float3 finalLUT = lerp(color2, color1, blueInterp);<font></font>
   finalLUT = lutCorrectedMult * GammaToLinear(finalLUT);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則は、隣接する2つのセグメントから色を取得し、それらを補間することです。補間の量は、入ってくる青の端数部分に依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パート1は、明確に設定された青のオフセット（+ 1.0 / 64）により、「遠い」セグメントから色を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補間の結果は変数「finalLUT」に保存されます。この後、結果は再び線形空間に戻り、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lutCorrectedMult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が乗算されることに</font><i><font style="vertical-align: inherit;">注意してください</font></i><font style="vertical-align: inherit;">。この特定のフレームでは、その値は1.00916です。これにより、LUTカラーの明るさを変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、最も興味深い部分は63.75と63.75 / 64です。どこから来たのかよくわかりません。私が見つけた唯一の説明：63.75 / 64.0 = 510.0 / 512.0。上記のように、.rgチャネルにはクランプがあります。つまり、青のオフセットを追加する場合、これは基本的に、最も外側の行とLUT列が直接使用されないことを意味します。私は、510x510の検索テクスチャ領域の中心に色が明示的に「圧迫」されていると思います。</font><i><font style="vertical-align: inherit;">inputColorGamma.b</font></i><font style="vertical-align: inherit;"> &nbsp;= 0.75 / 64.0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
としましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
仕組みは次のとおりです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/437/1be/637/4371be6372754803fb505b7ee8d6985e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには、青のチャネルを[0-4/64]でカバーする最初の4つのセグメント（1〜4）があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルの位置から判断すると、赤と緑のチャンネルはおよそ0.75と0.5に等しいようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LUTをダブルクエリします。「パート1」はセグメント2を指し、「パート2」は最初のセグメントを指します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、補間は色の小数部、つまり0.75に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、最終結果は、最初のセグメントから75％の色と2番目のセグメントから25％の色になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あと少しで完了です。最後に行うことは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Calculate the final color  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedInfluence = cb3_v1.y; <span class="hljs-comment">// 0.20 in this frame  </span><font></font>
   float3 finalColor = lerp(inputColorLinear.rgb, finalLUT, lutCorrectedInfluence);  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4( finalColor, inputColorLinear.a );  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハ！</font><font style="vertical-align: inherit;">この場合、最終的な色は、入力色の80％とLUT色の20％で構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像をもう一度簡単に比較してみましょう。入力色（つまり、実際には0％の色補正）、最終フレーム（20％）、完全に処理された画像（色補正効果の100％）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/318/e4b/20d/318e4b20d4828bdba7f58759ba399bf0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0％カラーグレーディング</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df6/77c/268/df677c268bbf640a0561048116b679be.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20％カラーグレーディング（真のシェーダー）</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/2cd/be6/1172cdbe64c841af91b529ae5a02ea05.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100％カラーグレーディング</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のLUT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、Witcher 3はいくつかのLUTを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのLUTを使用するシーンは次のとおりです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10c/98f/b01/10c98fb01ded1426075b104454034f13.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カラーグレーディング前</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/79a/a81/99f/79aa8199f82eba7378cc4c774e0b227c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色補正パス後</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
使用LUT：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/02e/f89/2d602ef89d4ff07635c684d6321456e7.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUT 1（テクスチャ1）</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fc/a62/1fd/6fca621fd829c6137ebd35636fe1920d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUT 2（texture2）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このバージョンのシェーダーの</font><i><font style="vertical-align: inherit;">アセンブラー</font></i><font style="vertical-align: inherit;">フラグメントを調べてみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">18</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r3.xyz, r2.xyxx, t2.xyzw, s2, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">19</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r2.xyz, r2.xyxx, t1.xyzw, s1, l(<span class="hljs-number">0</span>)  <font></font>
   ...  <font></font>
  <span class="hljs-number">36</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r4.xyz, r1.xyxx, t2.xyzw, s2, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">37</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyw, r1.xyxx, t1.xywz, s1, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">38</span>: add r3.xyz, r3.xyzx, -r4.xyzx  
  <span class="hljs-number">39</span>: mad r3.xyz, r1.zzzz, r3.xyzx, r4.xyzx  
  <span class="hljs-number">40</span>: <span class="hljs-built_in">log</span> r3.xyz, <span class="hljs-built_in">abs</span>(r3.xyzx)  
  <span class="hljs-number">41</span>: mul r3.xyz, r3.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">42</span>: <span class="hljs-built_in">exp</span> r3.xyz, r3.xyzx  
  <span class="hljs-number">43</span>: add r2.xyz, -r1.xywx, r2.xyzx  
  <span class="hljs-number">44</span>: mad r1.xyz, r1.zzzz, r2.xyzx, r1.xywx  
  <span class="hljs-number">45</span>: <span class="hljs-built_in">log</span> r1.xyz, <span class="hljs-built_in">abs</span>(r1.xyzx)  
  <span class="hljs-number">46</span>: mul r1.xyz, r1.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">47</span>: <span class="hljs-built_in">exp</span> r1.xyz, r1.xyzx  
  <span class="hljs-number">48</span>: add r2.xyz, -r1.xyzx, r3.xyzx  
  <span class="hljs-number">49</span>: mad r1.xyz, cb3[<span class="hljs-number">1</span>].xxxx, r2.xyzx, r1.xyzx  
  <span class="hljs-number">50</span>: mad r1.xyz, cb3[<span class="hljs-number">1</span>].zzzz, r1.xyzx, -r0.xyzx  
  <span class="hljs-number">51</span>: mad o0.xyz, cb3[<span class="hljs-number">1</span>].yyyy, r1.xyzx, r0.xyzx  
  <span class="hljs-number">52</span>: mov o0.w, r0.w  
  <span class="hljs-number">53</span>: ret  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、すべてが非常に単純です。</font><font style="vertical-align: inherit;">アセンブラーコードに従って、以下を取得します。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Part 1  </span>
   <span class="hljs-comment">// ...  </span><font></font>
   float2 uv1 = getUV(inputColor1);  <font></font>
   float3 lut2_color1 = texture2.SampleLevel( sampler2, uv1, <span class="hljs-number">0</span> ).rgb;  <font></font>
   float3 lut1_color1 = texture1.SampleLevel( sampler1, uv1, <span class="hljs-number">0</span> ).rgb;  <font></font>
     <font></font>
   <span class="hljs-comment">// Part 2  </span>
   <span class="hljs-comment">// ...  </span><font></font>
   float2 uv2 = getUV(inputColor2);  <font></font>
   float3 lut2_color2 = texture2.SampleLevel( sampler2, uv2, <span class="hljs-number">0</span> ).rgb;  <font></font>
   float3 lut1_color2 = texture1.SampleLevel( sampler1, uv2, <span class="hljs-number">0</span> ).rgb;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> blueInterp = frac(inputColorGamma.b * <span class="hljs-number">63.75</span>);  <font></font>
    <font></font>
   float3 lut2_finalLUT = lerp(lut2_color2, lut2_color1, blueInterp);  <font></font>
   lut2_finalLUT = GammaToLinear(lut2_finalLUT);  <font></font>
        <font></font>
   float3 lut1_finalLUT = lerp(lut1_color2, lut1_color1, blueInterp);  <font></font>
   lut1_finalLUT = GammaToLinear(lut1_finalLUT);  <font></font>
        <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lut_Interp = cb3_v1.x;  <font></font>
   float3 finalLUT = lerp(lut1_finalLUT, lut2_finalLUT, lut_Interp);  <font></font>
        <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedMult = cb3_v1.z;  <font></font>
   finalLUT *= lutCorrectedMult;  <font></font>
     <font></font>
   <span class="hljs-comment">// Calculate the final color  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedInfluence = cb3_v1.y;  <font></font>
   float3 finalColor = lerp(inputColorLinear.rgb, finalLUT, lutCorrectedInfluence);  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4( finalColor, inputColorLinear.a );  <font></font>
 }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LUTから2つの色を受け取った後、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lut_Interp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でそれらの間で補間が実行されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それ以外は、LUTが1つだけのバージョンとほぼ同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、追加の変数は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lut_interp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけ</font><i><font style="vertical-align: inherit;">です</font></i><font style="vertical-align: inherit;">。これは、2つのLUTの混合方法を示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/339/052/77a/33905277a643b710c3b0c93a1727d553.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特定のフレームでの値は約0.96です。つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalLUTに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はLUT2からの色の96％とLUT1からの色の4％が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これで終わりではありません！</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォグセクションで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調べたシーンでは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、</font></a></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つの</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LUTを</font><font style="vertical-align: inherit;">使用しています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
見てみよう！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bf8/180/409bf818084dbe05f0dee341f88ff16d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カラーグレーディング前</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/a83/4fc/64fa834fc2a5866d3f9e4be584dd2186.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色補正後</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/02e/f89/2d602ef89d4ff07635c684d6321456e7.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUT1（テクスチャ1）</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fc/a62/1fd/6fca621fd829c6137ebd35636fe1920d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUT2（テクスチャ2）</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50f/b99/806/50fb99806ff70451f2870632244f4991.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUT3（texture3）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
そして</font><i><font style="vertical-align: inherit;">アセンブラー</font></i><font style="vertical-align: inherit;">フラグメント：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">23</span>: mad r2.yz, r2.yyzy, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.000000</span>), r3.xxyx  
  <span class="hljs-number">24</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r3.xyz, r2.yzyy, t2.xyzw, s2, l(<span class="hljs-number">0</span>)  <font></font>
  ...  <font></font>
  <span class="hljs-number">34</span>: mad r1.xy, r1.xyxx, l(<span class="hljs-number">0.125000</span>, <span class="hljs-number">0.125000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>), r1.zwzz  
  <span class="hljs-number">35</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r4.xyz, r1.xyxx, t2.xyzw, s2, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">36</span>: add r4.xyz, -r3.xyzx, r4.xyzx  
  <span class="hljs-number">37</span>: mad r3.xyz, r2.xxxx, r4.xyzx, r3.xyzx  
  <span class="hljs-number">38</span>: <span class="hljs-built_in">log</span> r3.xyz, <span class="hljs-built_in">abs</span>(r3.xyzx)  
  <span class="hljs-number">39</span>: mul r3.xyz, r3.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">40</span>: <span class="hljs-built_in">exp</span> r3.xyz, r3.xyzx  
  <span class="hljs-number">41</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r4.xyz, r1.xyxx, t1.xyzw, s1, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">42</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyz, r1.xyxx, t3.xyzw, s3, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">43</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r5.xyz, r2.yzyy, t1.xyzw, s1, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">44</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r2.yzw, r2.yzyy, t3.wxyz, s3, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">45</span>: add r4.xyz, r4.xyzx, -r5.xyzx  
  <span class="hljs-number">46</span>: mad r4.xyz, r2.xxxx, r4.xyzx, r5.xyzx  
  <span class="hljs-number">47</span>: <span class="hljs-built_in">log</span> r4.xyz, <span class="hljs-built_in">abs</span>(r4.xyzx)  
  <span class="hljs-number">48</span>: mul r4.xyz, r4.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">49</span>: <span class="hljs-built_in">exp</span> r4.xyz, r4.xyzx  
  <span class="hljs-number">50</span>: add r3.xyz, r3.xyzx, -r4.xyzx  
  <span class="hljs-number">51</span>: mad r3.xyz, cb3[<span class="hljs-number">1</span>].xxxx, r3.xyzx, r4.xyzx  
  <span class="hljs-number">52</span>: mad r3.xyz, cb3[<span class="hljs-number">1</span>].zzzz, r3.xyzx, -r0.xyzx  
  <span class="hljs-number">53</span>: mad r3.xyz, cb3[<span class="hljs-number">1</span>].yyyy, r3.xyzx, r0.xyzx  
  <span class="hljs-number">54</span>: add r1.xyz, r1.xyzx, -r2.yzwy  
  <span class="hljs-number">55</span>: mad r1.xyz, r2.xxxx, r1.xyzx, r2.yzwy  
  <span class="hljs-number">56</span>: <span class="hljs-built_in">log</span> r1.xyz, <span class="hljs-built_in">abs</span>(r1.xyzx)  
  <span class="hljs-number">57</span>: mul r1.xyz, r1.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">58</span>: <span class="hljs-built_in">exp</span> r1.xyz, r1.xyzx  
  <span class="hljs-number">59</span>: mad r1.xyz, cb3[<span class="hljs-number">2</span>].zzzz, r1.xyzx, -r0.xyzx  
  <span class="hljs-number">60</span>: mad r0.xyz, cb3[<span class="hljs-number">2</span>].yyyy, r1.xyzx, r0.xyzx  
  <span class="hljs-number">61</span>: mov o0.w, r0.w  
  <span class="hljs-number">62</span>: add r0.xyz, -r3.xyzx, r0.xyzx  
  <span class="hljs-number">63</span>: mad o0.xyz, cb3[<span class="hljs-number">2</span>].wwww, r0.xyzx, r3.xyzx  
  <span class="hljs-number">64</span>: ret  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、このバージョンのシェーダーは、前の2つよりもはるかに混乱しています。たとえば、「uv1」と呼ばれるUVは、「uv2」の前のアセンブリコードで使用されていました（1つのLUTとシェーダーのアセンブラコードを比較してください）。しかし、ここではそうではありません-「パート1」のUVは34行目で計算され、「パート2」のUVは23行目で計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何が起こっているのかを調査し、なぜPart2が場所を入れ替えたように思われるのかと思って予想以上の時間を費やしています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Part1を使用して、3つのLUT用のHLSLコードを作成しました。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Part 1   </span>
   <span class="hljs-comment">// ...   </span><font></font>
   float2 uv1 = getUV(inputColor1);   <font></font>
   float3 lut3_color1 = texture3.SampleLevel( sampler3, uv1, <span class="hljs-number">0</span> ).rgb;  <font></font>
   float3 lut2_color1 = texture2.SampleLevel( sampler2, uv1, <span class="hljs-number">0</span> ).rgb;   <font></font>
   float3 lut1_color1 = texture1.SampleLevel( sampler1, uv1, <span class="hljs-number">0</span> ).rgb;   <font></font>
      <font></font>
   <span class="hljs-comment">// Part 2   </span>
   <span class="hljs-comment">// ...   </span><font></font>
   float2 uv2 = getUV(inputColor2);   <font></font>
   float3 lut3_color2 = texture3.SampleLevel( sampler3, uv2, <span class="hljs-number">0</span> ).rgb;  <font></font>
   float3 lut2_color2 = texture2.SampleLevel( sampler2, uv2, <span class="hljs-number">0</span> ).rgb;   <font></font>
   float3 lut1_color2 = texture1.SampleLevel( sampler1, uv2, <span class="hljs-number">0</span> ).rgb;   <font></font>
      <font></font>
   <span class="hljs-keyword">float</span> blueInterp = frac(inputColorGamma.b * <span class="hljs-number">63.75</span>);   <font></font>
     <font></font>
   <span class="hljs-comment">// At first compute linear color for LUT 2 [assembly lines 36-40]  </span><font></font>
   float3 lut2_finalLUT = lerp(lut2_color2, lut2_color1, blueInterp);   <font></font>
   lut2_finalLUT = GammaToLinear(lut2_finalLUT);   <font></font>
   <font></font>
   <span class="hljs-comment">// Compute linear color for LUT 1 [assembly: 45-49]      </span><font></font>
   float3 lut1_finalLUT = lerp(lut1_color2, lut1_color1, blueInterp);   <font></font>
   lut1_finalLUT = GammaToLinear(lut1_finalLUT);   <font></font>
     <font></font>
   <span class="hljs-comment">// Interpolate between LUT 1 and LUT 2 [assembly: 50-51]  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lut12_Interp = cb3_v1.x;   <font></font>
   float3 lut12_finalLUT = lerp(lut1_finalLUT, lut2_finalLUT, lut12_Interp);   <font></font>
    <font></font>
   <span class="hljs-comment">// Multiply the LUT1-2 intermediate result with scale factor [assembly: 52]  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedMult_LUT1_2 = cb3_v1.z;   <font></font>
   lut12_finalLUT *= lutCorrectedMult;   <font></font>
      <font></font>
   <span class="hljs-comment">// Mix LUT1-2 intermediate result with the scene color [assembly: 52-53]  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedInfluence_12 = cb3_v1.y;   <font></font>
   lut12_finalLUT = lerp(inputColorLinear.rgb, lut12_finalLUT, lutCorrectedInfluence_12);   <font></font>
   <font></font>
   <span class="hljs-comment">// Compute linear color for LUT3 [assembly: 54-58]  </span><font></font>
   float3 lut3_finalLUT = lerp(lut3_color2, lut3_color1, blueInterp);  <font></font>
   lut3_finalLUT = GammaToLinear(lut3_finalLUT);  <font></font>
   <font></font>
   <span class="hljs-comment">// Multiply the LUT3 intermediate result with the scale factor [assembly: 59]  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedMult_LUT3 = cb3_v2.z;  <font></font>
   lut3_finalLUT *= lutCorrectedMult_LUT3;  <font></font>
   <font></font>
   <span class="hljs-comment">// Mix LUT3 intermediate result with the scene color [assembly: 59-60]  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> lutCorrectedInfluence3 = cb3_v2.y;  <font></font>
   lut3_finalLUT = lerp(inputColorLinear.rgb, lut3_finalLUT, lutCorrectedInfluence3);  <font></font>
   <font></font>
   <span class="hljs-comment">// The final mix between LUT1+2 and LUT3 influence [assembly: 62-63]  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> finalInfluence = cb3_v2.w;  <font></font>
   float3 finalColor = lerp(lut12_finalLUT, lut3_finalLUT, finalInfluence);  <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> float4( finalColor, inputColorLinear.a );   <font></font>
}   </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのテクスチャクエリが完了すると、LUT1とLUT2の結果が最初に補間され、次にそれらにスケーリング係数が乗算されてから、メインシーンの線形カラーと組み合わされます。</font><font style="vertical-align: inherit;">結果を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lut12_finalLUT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUT3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">についてもほぼ同じことが起こります。別のスケーリングファクターを掛けて、それをメインシーンのカラーと組み合わせると、</font><i><font style="vertical-align: inherit;">lut3_finalLUT</font></i><font style="vertical-align: inherit;">が得</font><i><font style="vertical-align: inherit;">られ</font></i><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、両方の中間結果が再び補間されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがcbufferからの値です：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9a/694/355/b9a694355db98f0141524e4e7e27012c.png"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート3：ポータル</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/eca/7c8/878eca7c897abff8139c6d04f5a1a960.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィッチャー3を長期間プレイしたことがあるなら、ジェラルトはポータルの大ファンではないことをご存じでしょう。</font><font style="vertical-align: inherit;">彼らが本当にとても怖いかどうか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームには2種類のポータルがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18f/f0c/282/18ff0c282e1999b5e938797d298ed7b6.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">青いポータル</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/50e/8f5/afb50e8f5f52f0f94ca89c5f684b9e48.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FieryポータルFieryポータルの</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
作成方法を説明します。</font><font style="vertical-align: inherit;">そのコードは青のコードよりも単純であるためです:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ゲームでのファイアポータルの外観です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ol0rxFPBQgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、最も重要な部分は中心に向かって回転する火ですが、効果自体は目に見える部分だけで構成されているわけではありません。</font><font style="vertical-align: inherit;">これについては後で詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパーツのプランはかなり標準的です。最初のジオメトリ、次に頂点とピクセルシェーダーです。</font><font style="vertical-align: inherit;">かなりの数のスクリーンショットとビデオがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングに関しては、ポータルは、ブレンドがオンになっているダイレクトパスで描画されます。これは、ゲームではかなり一般的な手法です。</font><font style="vertical-align: inherit;">詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流れ星</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する部分を参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、始めましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.ジオメトリ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータルメッシュは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e8/fd5/7e4/4e8fd57e430a06f4c5d25ee397dfed09.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルスペース-正面図</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a3e/299/707a3e299d75286e74eb556fcc22ca05.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッシュの</font><i><font style="vertical-align: inherit;">ローカルスペース側のビューは、</font></i></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガブリエル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">角に</font></a><font style="vertical-align: inherit;">似てい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">頂点シェーダーは1つの軸に沿ってそれを圧縮します。これは、（ワールド空間での）側面ビューでの圧縮後の同じメッシュです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dc/a37/be6/9dca37be6f7255173e179f7a5c77d4e5.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点シェーダー後のポータルメッシュ（側面図）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
位置に加えて、各頂点には追加のデータがあります。次のことが重要です（この段階では、RenderDocからの視覚化を示し、後で詳しく説明します）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texcoords（float2）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/df6/71b/90cdf671b220eafe85c66a70ebcc04b6.jpg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接線（float3）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/d86/7bc/8ddd867bcf25841227db1282edf3bf90.jpg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
色（float3）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40d/d37/72b/40dd3772bbfdf2dde2ea508614f7697f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータはすべて後で使用されますが、この段階ではすでに.objファイルに対してデータが多すぎるため、このメッシュをエクスポートすると問題が発生する可能性があります。</font><font style="vertical-align: inherit;">各チャネルを個別の.csvファイルとしてエクスポートし、すべての.csvファイルをC ++アプリケーションにアップロードしました。実行時に、収集されたこのデータに基づいてメッシュが組み立てられます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.頂点シェーダー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点シェーダーは特に興味深いものではありませんが、とにかく対応するフラグメントを見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"> vs_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">7</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">6</span>], immediateIndexed  <font></font>
    dcl_input v0.xyz  <font></font>
    dcl_input v1.xy  <font></font>
    dcl_input v3.xyz  <font></font>
    dcl_input v4.xyzw  <font></font>
    dcl_input v6.xyzw  <font></font>
    dcl_input v7.xyzw  <font></font>
    dcl_input v8.xyzw  <font></font>
    dcl_output o0.xyz  <font></font>
    dcl_output o1.xyzw  <font></font>
    dcl_output o2.xyz  <font></font>
    dcl_output o3.xyz  <font></font>
    dcl_output_siv o4.xyzw, position  <font></font>
    dcl_temps <span class="hljs-number">3</span>  
   <span class="hljs-number">0</span>: mov o0.xy, v1.xyxx  
   <span class="hljs-number">1</span>: mul r0.xyzw, v7.xyzw, cb1[<span class="hljs-number">6</span>].yyyy  
   <span class="hljs-number">2</span>: mad r0.xyzw, v6.xyzw, cb1[<span class="hljs-number">6</span>].xxxx, r0.xyzw  
   <span class="hljs-number">3</span>: mad r0.xyzw, v8.xyzw, cb1[<span class="hljs-number">6</span>].zzzz, r0.xyzw  
   <span class="hljs-number">4</span>: mad r0.xyzw, cb1[<span class="hljs-number">6</span>].wwww, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>), r0.xyzw  
   <span class="hljs-number">5</span>: mad r1.xyz, v0.xyzx, cb2[<span class="hljs-number">4</span>].xyzx, cb2[<span class="hljs-number">5</span>].xyzx  
   <span class="hljs-number">6</span>: mov r1.w, l(<span class="hljs-number">1.000000</span>)  
   <span class="hljs-number">7</span>: dp4 o0.z, r1.xyzw, r0.xyzw  
   <span class="hljs-number">8</span>: mov o1.xyzw, v4.xyzw  
   <span class="hljs-number">9</span>: dp4 o2.x, r1.xyzw, v6.xyzw  
  <span class="hljs-number">10</span>: dp4 o2.y, r1.xyzw, v7.xyzw  
  <span class="hljs-number">11</span>: dp4 o2.z, r1.xyzw, v8.xyzw  
  <span class="hljs-number">12</span>: mad r0.xyz, v3.xyzx, l(<span class="hljs-number">2.000000</span>, <span class="hljs-number">2.000000</span>, <span class="hljs-number">2.000000</span>, <span class="hljs-number">0.000000</span>), l(<span class="hljs-number">-1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">13</span>: dp3 r2.x, r0.xyzx, v6.xyzx  
  <span class="hljs-number">14</span>: dp3 r2.y, r0.xyzx, v7.xyzx  
  <span class="hljs-number">15</span>: dp3 r2.z, r0.xyzx, v8.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.x, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.x, r0.x  
  <span class="hljs-number">18</span>: mul o3.xyz, r0.xxxx, r2.xyzx  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点シェーダーは、以前に出会った他のシェーダーと非常によく似ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力データスキームの簡単な分析と比較の結果、出力構造体は次のように記述できることがわかりました。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VS_OUTPUT</span>  
 {</span>  <font></font>
      float3 TexcoordAndViewSpaceDepth : TEXCOORD0;  <font></font>
      float3 Color : TEXCOORD1;  <font></font>
      float3 WorldSpacePosition : TEXCOORD2;  <font></font>
      float3 Tangent : TEXCOORD3;  <font></font>
      float4 PositionH : SV_Position;  <font></font>
 };  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーが表示スペース（o0.z）で深度を取得する方法の1つの側面を示したかったのです。これは、SV_Position変数の.wコンポーネントにすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font><font style="vertical-align: inherit;">についてもう少し詳しく説明</font><font style="vertical-align: inherit;">しているgamedev.netの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.ピクセルシェーダー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、ポータルをレンダリングする直前のシーンの例です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/541/c18/970541c1809af189d1196949d68b282d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...そしてレンダリング後：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/95c/995/9fe95c9956d4552e575a4aa0a7700330.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、RenderDocテクスチャビューアには、描画前に描画を消去するオーバーレイオプションがあり、レンダリングされたポータルを正確に表示できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/5f4/753/3915f4753bdab1c35ea205f852fe8918.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の興味深い側面は、炎のレイヤー自体がメッシュの中央領域にのみ描画されることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルシェーダーは186行で構成されてい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">便宜上、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ここ</font></a><font style="vertical-align: inherit;">に投稿し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">いつものように、説明ではアセンブラーの対応するフラグメントを引用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、186行のうち100行が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">霧の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算に関連していることにも注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、4つのテクスチャが入力に供給されます：火（t0）、ノイズ/煙（t1）、シーンの色（t6）、シーンの深度（t15）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbf/f96/898/bbff96898cfca0776613f7ac044d1e88.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">火の質感</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18f/a01/732/18fa01732e339615225c970ea0affb40.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノイズ/煙のテクスチャ</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/541/c18/970541c1809af189d1196949d68b282d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーンカラー</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/462/8a5/28f/4628a528f96d8c2324b348bf65ca6282.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーン深度</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
エフェクトを制御する14個のパラメーターを持つ個別の定数バッファーもあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98d/c00/682/98dc006828372c155b88c06f26613497.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力データ：位置、接線、テクスコードはかなり明確な概念ですが、カラーチャネルを詳しく見てみましょう。</font><font style="vertical-align: inherit;">いくつかの実験の後、これはそれ自体は色ではないようですが、シェーダーが別々のレイヤーを区別し、さまざまな効果を適用する場所を理解するために使用する3つの異なるマスクです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Color.r-ヒートヘイズのマスク。</font><font style="vertical-align: inherit;">名前が示すように、空気の熱変形の影響に使用されます（詳細は後で説明します）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/050/61e/5a205061e0ee45e3e90d1590e8e93fe9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Color.g-内部マスク。</font><font style="vertical-align: inherit;">主に火の効果に使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/8b7/c37/cc28b7c37631d0ee957ecb65cede07b5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Color.b-バックマスク。</font><font style="vertical-align: inherit;">ポータルの「戻る」場所を決定するために使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/610/258/e25/610258e2504bd9f6011437c339fbb76c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような影響の場合は、以前のようにアセンブラーのコードを最初から最後まで分析するのではなく、個々のレイヤーを記述する方が良いと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
じゃ、行こう：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1。</font><font style="vertical-align: inherit;">火の層</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、最も重要な部分である火の層について見ていきましょう。</font><font style="vertical-align: inherit;">ここに彼のビデオがあります：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/vG7LLh857OQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この効果を実装するための主な原則は、各頂点のデータから静的texcoordを使用し、定数バッファーからの経過時間変数を使用してそれらをアニメーション化することです。</font><font style="vertical-align: inherit;">このようなアニメーション化されたtexcoordsのおかげで、ディストーション/リピートサンプラーを使用してテクスチャ（この場合は火）をサンプリングします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、この特定の効果では、火の.rテクスチャチャネルのみがサンプリングされます。</font><font style="vertical-align: inherit;">効果をより信頼できるものにするために、上記の方法で2層の火が得られ、それらが互いに組み合わされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、最後にコードを見てみましょう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texcoordsがメッシュの中心に到達したときに、より動的にすることから始めます。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> float2 texcoords = Input.TextureUV;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> uvSquash = cb4_v4.x; <span class="hljs-comment">// 2.50  </span><font></font>
   ...      <font></font>
 <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> y_cutoff = <span class="hljs-number">0.2</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> y_offset = <span class="hljs-built_in">pow</span>(texcoords.y - y_cutoff, uvSquash);  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは同じですが、アセンブラでは：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">21</span>: add r1.z, v0.y, l(<span class="hljs-number">-0.200000</span>)  
  <span class="hljs-number">22</span>: <span class="hljs-built_in">log</span> r1.z, r1.z  
  <span class="hljs-number">23</span>: mul r1.z, r1.z, cb4[<span class="hljs-number">4</span>].x  
  <span class="hljs-number">24</span>: <span class="hljs-built_in">exp</span> r1.z, r1.z  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、シェーダーは最初の火のレイヤーのtexcoordsを受け取り、火のテクスチャをサンプリングします。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> elapsedTimeSeconds = cb0_v0.x;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> uvScaleGlobal1 = cb4_v2.x; <span class="hljs-comment">// 1.00  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> uvScale1 = cb4_v3.x;    <span class="hljs-comment">// 0.15  </span><font></font>
   ...  <font></font>
<font></font>
   <span class="hljs-comment">// Sample fire1 - the first fire layer  </span>
   <span class="hljs-keyword">float</span> fire1; <span class="hljs-comment">// r1.w  </span><font></font>
   {<font></font>
     float2 fire1Uv;  <font></font>
     fire1Uv.x = texcoords.x;  <font></font>
     fire1Uv.y = uvScale1 * elapsedTimeSeconds + y_offset;  <font></font>
        <font></font>
     <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> scaleGlobal = <span class="hljs-built_in">floor</span>(uvScaleGlobal1); <span class="hljs-comment">// 1.0</span><font></font>
     fire1Uv *= scaleGlobal;  <font></font>
       <font></font>
     fire1 = texFire.Sample(samplerLinearWrap, fire1Uv).x;  <font></font>
   }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブラーの対応するスニペットは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">25</span>: round_ni r1.w, cb4[<span class="hljs-number">2</span>].x  
  <span class="hljs-number">26</span>: mad r2.y, cb4[<span class="hljs-number">3</span>].x, cb0[<span class="hljs-number">0</span>].x, r1.z  
  <span class="hljs-number">27</span>: mov r2.x, v0.x  
  <span class="hljs-number">28</span>: mul r2.xy, r1.wwww, r2.xyxx  
  <span class="hljs-number">29</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.w, r2.xyxx, t0.yzwx, s0  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elapsedTimeSeconds</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;= 50.0の</font><font style="vertical-align: inherit;">場合の最初のレイヤーの外観です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd5/654/da3/dd5654da3ed894e65008972da8ab057b.jpg"></div><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y_cutoffの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
機能</font><font style="vertical-align: inherit;">を示すために、同じシーンを示しますが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y_cutoff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;= 0.5を使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4de/71e/3e6/4de71e3e66f4cbb5e5a3ff671df0033a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで最初のレイヤーができました。</font><font style="vertical-align: inherit;">次に、シェーダーは2番目を取得します。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> uvScale2 = cb4_v6.x;       <span class="hljs-comment">// 0.06  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> uvScaleGlobal2 = cb4_v7.x; <span class="hljs-comment">// 1.00  </span><font></font>
   ...  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample fire2 - the second fire layer  </span>
   <span class="hljs-keyword">float</span> fire2; <span class="hljs-comment">// r1.z  </span><font></font>
   {            <font></font>
     float2 fire2Uv;  <font></font>
     fire2Uv.x = texcoords.x - uvScale2 * elapsedTimeSeconds;  <font></font>
     fire2Uv.y = uvScale2 * elapsedTimeSeconds + y_offset;  <font></font>
     <font></font>
     <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> fire2_scale = <span class="hljs-built_in">floor</span>(uvScaleGlobal2);  <font></font>
     fire2Uv *= fire2_scale;  <font></font>
     <font></font>
     fire2 = texFire.Sample(samplerLinearWrap, fire2Uv).x;  <font></font>
   }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは対応するアセンブラーフラグメントです：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">144</span>: mad r2.x, -cb0[<span class="hljs-number">0</span>].x, cb4[<span class="hljs-number">6</span>].x, v0.x  
  <span class="hljs-number">145</span>: mad r2.y, cb0[<span class="hljs-number">0</span>].x, cb4[<span class="hljs-number">6</span>].x, r1.z  
  <span class="hljs-number">146</span>: round_ni r1.z, cb4[<span class="hljs-number">7</span>].x  
  <span class="hljs-number">147</span>: mul r2.xy, r1.zzzz, r2.xyxx  
  <span class="hljs-number">148</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.z, r2.xyxx, t0.yzxw, s0  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、ご覧のとおり、唯一の違いはUVです。Xもアニメーション化されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のレイヤーは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/151/bf2/3bb151bf2c7cbbcef904cca60903d3fc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2層の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内側の火</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を受けたので</font><font style="vertical-align: inherit;">、それらを組み合わせることができます。</font><font style="vertical-align: inherit;">ただし、内部マスクが含まれているため、このプロセスは通常の乗算​​よりも少し複雑です。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> innerMask = Input.Color.y;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> portalInnerColorSqueeze = cb4_v8.x; <span class="hljs-comment">// 3.00  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> portalInnerColorBoost = cb4_v9.x; <span class="hljs-comment">// 188.00  </span><font></font>
   ...  <font></font>
        <font></font>
   <span class="hljs-comment">// Calculate inner fire influence  </span>
   <span class="hljs-keyword">float</span> inner_influence;  <span class="hljs-comment">// r1.z</span><font></font>
   {  <font></font>
     <span class="hljs-comment">// innerMask and "-1.0" are used here to control where the inner part of a portal is.  </span><font></font>
     inner_influence = fire1 * fire2 + innerMask;  <font></font>
     inner_influence = saturate(inner_influence - <span class="hljs-number">1.0</span>);  <font></font>
       <font></font>
     <span class="hljs-comment">// Exponentation to hide less luminous elements of inner portal  </span>
     inner_influence = <span class="hljs-built_in">pow</span>(inner_influence, portalInnerColorSqueeze);  <font></font>
       <font></font>
     <span class="hljs-comment">// Boost the intensity  </span><font></font>
     inner_influence *= portalInnerColorBoost;  <font></font>
   }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、対応するアセンブラーコードです。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">149</span>: mad r1.z, r1.w, r1.z, v1.y  
  <span class="hljs-number">150</span>: add_sat r1.z, r1.z, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">151</span>: <span class="hljs-built_in">log</span> r1.z, r1.z  
  <span class="hljs-number">152</span>: mul r1.z, r1.z, cb4[<span class="hljs-number">8</span>].x  
  <span class="hljs-number">153</span>: <span class="hljs-built_in">exp</span> r1.z, r1.z  
  <span class="hljs-number">154</span>: mul r1.z, r1.z, cb4[<span class="hljs-number">9</span>].x  </code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inner_influence</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を受け取った</font><i><font style="vertical-align: inherit;">ので</font></i><font style="vertical-align: inherit;">、これは内部の火のマスクに過ぎず、単純にマスクに内部の火の色を掛けることができます。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Calculate portal color  </span>
   <span class="hljs-keyword">const</span> float3 colorPortalInner = cb4_v5.rgb; <span class="hljs-comment">// (1.00, 0.60, 0.21961)  </span><font></font>
   ...  <font></font>
   <font></font>
   <span class="hljs-keyword">const</span> float3 portal_inner_final = <span class="hljs-built_in">pow</span>(colorPortalInner, <span class="hljs-number">2.2</span>) * inner_influence;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブラコード：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">155</span>: <span class="hljs-built_in">log</span> r2.xyz, cb4[<span class="hljs-number">5</span>].xyzx  
  <span class="hljs-number">156</span>: mul r2.xyz, r2.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">157</span>: <span class="hljs-built_in">exp</span> r2.xyz, r2.xyzx  <font></font>
  ...  <font></font>
  <span class="hljs-number">170</span>: mad r2.xyz, r2.xyzx, r1.zzzz, r3.xyzx  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、内部の火の個々の層を示すビデオです。</font><font style="vertical-align: inherit;">順序：最初のレイヤー、2番目のレイヤー、内部の影響、最終的な内部の色：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/NtuMFD-Vyeo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2。</font><font style="vertical-align: inherit;">グロー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内側の火を作成したので、2番目のレイヤーであるグローに進みます。</font><font style="vertical-align: inherit;">これは、最初は内部の火だけ、次にグローだけ、そしてそれらの合計を示すビデオです-火の完成した効果：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/bVVqQR911zI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、シェーダーがグローを計算する方法です。</font><font style="vertical-align: inherit;">内部の火を作成するように、マスクが最初に生成され、次に定数バッファーからのグローの色が乗算されます。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> portalOuterGlowAttenuation = cb4_v10.x; <span class="hljs-comment">// 0.30  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> portalOuterColorBoost = cb4_v11.x; <span class="hljs-comment">// 1.50</span>
   <span class="hljs-keyword">const</span> float3 colorPortalOuterGlow = cb4_v12.rgb; <span class="hljs-comment">// (1.00, 0.61961, 0.30196)  </span><font></font>
   ...  <font></font>
  <font></font>
   <span class="hljs-comment">// Calculate outer portal glow  </span>
   <span class="hljs-keyword">float</span> outer_glow_influence;  <font></font>
   {    <font></font>
     <span class="hljs-keyword">float</span> outer_mask = (<span class="hljs-number">1.0</span> - backMask) * innerMask;  <font></font>
       <font></font>
     <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> perturbParam = fire1*fire1;  
     <span class="hljs-keyword">float</span> outer_mask_perturb = lerp( <span class="hljs-number">1.0</span> - portalOuterGlowAttenuation, <span class="hljs-number">1.0</span>, perturbParam );  <font></font>
       <font></font>
     outer_mask *= outer_mask_perturb;  <font></font>
     outer_glow_influence = outer_mask * portalOuterColorBoost;  <font></font>
   }  <font></font>
     <font></font>
   <span class="hljs-comment">// the final glow color  </span>
   <span class="hljs-keyword">const</span> float3 portal_outer_final = <span class="hljs-built_in">pow</span>(colorPortalOuterGlow, <span class="hljs-number">2.2</span>) * outer_glow_influence; <font></font>
 <font></font>
   <span class="hljs-comment">// and the portal color, the sum of fire and glow</span>
   float3 portal_final = portal_inner_final + portal_outer_final;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはouter_maskがどのように見えるかです：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（1.0-backMask）* innerMask</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/8c5/934/e6b8c5934ffb97d3ca461fb6b434333d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローの色は一定ではありません。</font><font style="vertical-align: inherit;">より面白く見せるために、アニメーション化された最初の火の層（四角）が使用されているため、中央に向かう振動が目立ちます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b35/44c/5b5/b3544c5b5390fd33ad96bc1fdda7fe6b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにグローを担当するアセンブラコードがあります：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">158</span>: add r2.w, -v1.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">159</span>: mul r2.w, r2.w, v1.y  
  <span class="hljs-number">160</span>: mul r1.w, r1.w, r1.w  
  <span class="hljs-number">161</span>: add r3.x, l(<span class="hljs-number">1.000000</span>), -cb4[<span class="hljs-number">10</span>].x  
  <span class="hljs-number">162</span>: add r3.y, -r3.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">163</span>: mad r1.w, r1.w, r3.y, r3.x  
  <span class="hljs-number">164</span>: mul r1.w, r1.w, r2.w  
  <span class="hljs-number">165</span>: mul r1.w, r1.w, cb4[<span class="hljs-number">11</span>].x  
  <span class="hljs-number">166</span>: <span class="hljs-built_in">log</span> r3.xyz, cb4[<span class="hljs-number">12</span>].xyzx  
  <span class="hljs-number">167</span>: mul r3.xyz, r3.xyzx, l(<span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">2.200000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">168</span>: <span class="hljs-built_in">exp</span> r3.xyz, r3.xyzx  
  <span class="hljs-number">169</span>: mul r3.xyz, r1.wwww, r3.xyzx  
  <span class="hljs-number">170</span>: mad r2.xyz, r2.xyzx, r1.zzzz, r3.xyzx  </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3。</font><font style="vertical-align: inherit;">もや</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータルシェーダーの実装を分析し始めたとき、ポータルのないシーンの色が入力テクスチャの1つとして使用された理由がはっきりしませんでした。</font><font style="vertical-align: inherit;">「ここではブレンディングを使用しているので、背景色を保持するには、アルファ値がゼロのピクセルを返すだけで十分です。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーには、小さいが美しい霞の効果（空気の熱変形）があります。熱とエネルギーがポータルから放出されるため、背景が歪んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則は、ピクセルtexcoordsをオフセットし、新しい色で背景色のテクスチャをサンプリングすることです。このような操作は単純な混合では実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように機能するかを示すビデオです。</font><font style="vertical-align: inherit;">順序：最初に完全なエフェクト、次にシェーダーからのヘイズ、そして最後にオフセットを10倍してエフェクトを強化します。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oywjEYe-msI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オフセットの計算方法を見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> ViewSpaceDepth = Input.ViewSpaceDepth;  
   <span class="hljs-keyword">const</span> float3 Tangent = Input.Tangent;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> backgroundDistortionStrength = cb4_v1.x; <span class="hljs-comment">// 0.40  </span><font></font>
<font></font>
   <span class="hljs-comment">// Fades smoothly from the outer edges to the back of a portal</span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> heatHazeMask = Input.Color.x;<font></font>
   ...  <font></font>
     <font></font>
   <span class="hljs-comment">// The heat haze effect is view dependent thanks to tangent vectors in view space.  </span><font></font>
   float2 heatHazeOffset = mul( normalize(Tangent), (float3x4)g_mtxView);  <font></font>
   heatHazeOffset *= float2(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);  <font></font>
     <font></font>
   <span class="hljs-comment">// Fade the effect as camera is further from a portal  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> heatHazeDistanceFade = backgroundDistortionStrength / ViewSpaceDepth;  <font></font>
   heatHazeOffset *= heatHazeDistanceFade;  <font></font>
        <font></font>
   heatHazeOffset *= heatHazeMask;  <font></font>
   <font></font>
   <span class="hljs-comment">// this is what animates the heat haze effect  </span>
   heatHazeOffset *= <span class="hljs-built_in">pow</span>(fire1, <span class="hljs-number">0.2</span>);  <font></font>
        <font></font>
   <span class="hljs-comment">// Actually I don't know what's this :)  </span>
   <span class="hljs-comment">// It was 1.0 usually so I won't bother discussing this.  </span>
   heatHazeOffset *= vsDepth2;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対応するアセンブラはコード全体に散在しています。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: dp3 r1.x, v3.xyzx, v3.xyzx  
  <span class="hljs-number">12</span>: rsq r1.x, r1.x  
  <span class="hljs-number">13</span>: mul r1.xyz, r1.xxxx, v3.xyzx  
  <span class="hljs-number">14</span>: mul r1.yw, r1.yyyy, cb12[<span class="hljs-number">2</span>].xxxy  
  <span class="hljs-number">15</span>: mad r1.xy, cb12[<span class="hljs-number">1</span>].xyxx, r1.xxxx, r1.ywyy  
  <span class="hljs-number">16</span>: mad r1.xy, cb12[<span class="hljs-number">3</span>].xyxx, r1.zzzz, r1.xyxx  
  <span class="hljs-number">17</span>: mul r1.xy, r1.xyxx, l(<span class="hljs-number">-1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">18</span>: div r1.z, cb4[<span class="hljs-number">1</span>].x, v0.z  
  <span class="hljs-number">19</span>: mul r1.xy, r1.zzzz, r1.xyxx  
  <span class="hljs-number">20</span>: mul r1.xy, r1.xyxx, v1.xxxx  <font></font>
  ...  <font></font>
  <span class="hljs-number">33</span>: mul r1.xy, r1.xyxx, r2.xxxx  
  <span class="hljs-number">34</span>: mul r1.xy, r0.zzzz, r1.xyxx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オフセットを計算したので、使ってみましょう！</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> float2 backgroundSceneMaxUv = cb0_v2.zw; <span class="hljs-comment">// (1.0, 1.0)  </span>
   <span class="hljs-keyword">const</span> float2 invViewportSize = cb0_v1.zw; <span class="hljs-comment">// (1.0 / 1920.0, 1.0 / 1080.0 )</span><font></font>
        <font></font>
   <span class="hljs-comment">// Obtain background scene color - we need to obtain it from texture  </span>
   <span class="hljs-comment">// for distortion effect  </span><font></font>
   float3 sceneColor;  <font></font>
   {  <font></font>
     <span class="hljs-keyword">const</span> float2 sceneUv_0 = pixelUv + backgroundSceneMaxUv*heatHazeOffset;  
     <span class="hljs-keyword">const</span> float2 sceneUv_1 = backgroundSceneMaxUv - <span class="hljs-number">0.5</span>*invViewportSize;  <font></font>
             <font></font>
     <span class="hljs-keyword">const</span> float2 sceneUv = min(sceneUv_0, sceneUv_1);  <font></font>
       <font></font>
     sceneColor = texScene.SampleLevel(sampler6, sceneUv, <span class="hljs-number">0</span>).rgb;  <font></font>
   }  </code></pre><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">175</span>: mad r0.xy, cb0[<span class="hljs-number">2</span>].zwzz, r1.xyxx, r0.xyxx  
  <span class="hljs-number">176</span>: mad r1.xy, -cb0[<span class="hljs-number">1</span>].zwzz, l(<span class="hljs-number">0.500000</span>, <span class="hljs-number">0.500000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>), cb0[<span class="hljs-number">2</span>].zwzz  
  <span class="hljs-number">177</span>: min r0.xy, r0.xyxx, r1.xyxx  
  <span class="hljs-number">178</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyz, r0.xyxx, t6.xyzw, s6, l(<span class="hljs-number">0</span>)  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、最終的に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sceneColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が取得され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4。</font><font style="vertical-align: inherit;">ポータルターゲットの色</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「目標」の色とは、ポータルの中央部分を意味します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/3fc/99a/5473fc99a829899381bbf459e71a9830.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、彼はすべて黒人です。</font><font style="vertical-align: inherit;">そして、その理由は霧です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">この記事で</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、フォグの実装方法についてすでに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ポータルシェーダーでは、フォグの計算はソースアセンブラコードの行[35-135]にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSL：</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FogResult</span>  
 {</span>  <font></font>
   float4 paramsFog;  <font></font>
   float4 paramsAerial;  <font></font>
 };  <font></font>
   <font></font>
 ...  <font></font>
   <font></font>
 FogResult fog;  <font></font>
 {  <font></font>
   <span class="hljs-keyword">const</span> float3 CameraPosition = cb12_v0.xyz;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> fogStart = cb12_v22.z; <span class="hljs-comment">// near plane  </span><font></font>
     <font></font>
   fog = CalculateFog( WSPosition, CameraPosition, fogStart, <span class="hljs-literal">false</span> );   <font></font>
 }  <font></font>
   <font></font>
 ...  <font></font>
   <font></font>
 <span class="hljs-keyword">const</span> float3 destination_color = fog.paramsFog.a * fog.paramsFog.rgb;  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、完成したシーンを取得します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/95c/995/9fe95c9956d4552e575a4aa0a7700330.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレーム内のカメラがポータルに非常に接近しているため、計算された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destination_color</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は0です。つまり、ポータルの黒い中心は実際には霧です（厳密には、存在しない）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RenderDocを使用すると、ゲームにシェーダーを挿入できるので、手動でカメラを動かしてみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">const</span> float3 CameraPosition = cb12_v0.xyz + float3(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>);  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてここに結果があります：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1c/831/ab3/c1c831ab3b3e9c3a4fb04a642af9219c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハ！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この特定のケースではフォグ計算を使用することはほとんど意味がありませんが、理論的には</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destination_color</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><i><font style="vertical-align: inherit;">destination</font></i><font style="vertical-align: inherit;">として使用することを妨げるものはありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、別の世界の風景（追加のtexcoordが必要になる場合がありますが、これは非常に実現可能です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォグの使用は、プレイヤーが遠くから見ることができる巨大なポータルの場合に役立ちます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5。</font><font style="vertical-align: inherit;">シーンの色（ヘイズを重ねたもの）と「ターゲット」の混合</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションをどこに配置するかを考えていました。「「目標」の色」または「すべてをまとめる」のいずれかでしたが、新しいサブセクションを作成することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この段階では3.3 </font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">説明した</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sceneColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、ヘイズ効果（熱変形）がすでに含まれています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、</font><font style="vertical-align: inherit;">3.4の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destination_color</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も含まれてい</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらは以下を使用して補間されます：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">178</span>: sample_l(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyz, r0.xyxx, t6.xyzw, s6, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">179</span>: mad r3.xyz, r4.wwww, r4.xyzx, -r1.xyzx  
  <span class="hljs-number">180</span>: mad r0.xyw, r0.wwww, r3.xyxz, r1.xyxz  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらを補間する値は何ですか（r0.w）？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノイズ/煙テクスチャがここに適用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ポータルターゲットマスク」と呼ばれるものを作成するために使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb0/c6d/b2c/fb0c6db2c0df02caf68e95046393a0e1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがビデオです（最初に完全なエフェクト、次にターゲットマスク、次に補間されたシーンカラーとターゲットカラー）。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/WnIk4nHVPKw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSLで次のスニペットをご覧ください。</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Determines the back part of a portal  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> backMask = Input.Color.z;  <font></font>
   <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> ViewSpaceDepth = Input.TexcoordAndViewSpaceDepth.z;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> viewSpaceDepthScale = cb4_v0.x; <span class="hljs-comment">// 0.50    </span><font></font>
   ...  <font></font>
   <font></font>
   <span class="hljs-comment">// Load depth from texture  </span>
   <span class="hljs-keyword">float</span> hardwareDepth = texDepth.SampleLevel(sampler15, pixelUv, <span class="hljs-number">0</span>).x;  
   <span class="hljs-keyword">float</span> linearDepth = getDepth(hardwareDepth);  <font></font>
     <font></font>
   <span class="hljs-comment">// cb4_v0.x = 0.5  </span>
   <span class="hljs-keyword">float</span> vsDepthScale = saturate( (linearDepth - ViewSpaceDepth) * viewSpaceDepthScale );  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> vsDepth1 = <span class="hljs-number">2</span>*vsDepthScale;<font></font>
   <font></font>
   ....  <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate 'portal destination' mask - maybe we would like see a glimpse of where a portal leads  </span>
   <span class="hljs-comment">// like landscape from another planet - the shader allows for it.  </span>
   <span class="hljs-keyword">float</span> portal_destination_mask;  <font></font>
   {    <font></font>
     <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> region_mask = dot(backMask.xx, vsDepth1.xx);  <font></font>
     <font></font>
     <span class="hljs-keyword">const</span> float2 _UVScale = float2(<span class="hljs-number">4.0</span>, <span class="hljs-number">1.0</span>);  
     <span class="hljs-keyword">const</span> float2 _TimeScale = float2(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.2</span>);  
     <span class="hljs-keyword">const</span> float2 _UV = texcoords * _UVScale + elapsedTime * _TimeScale;  <font></font>
       <font></font>
     portal_destination_mask = texNoise.Sample(sampler0, _UV).x;  <font></font>
     portal_destination_mask = saturate(portal_destination_mask + region_mask - <span class="hljs-number">1.0</span>);  <font></font>
     portal_destination_mask *= portal_destination_mask; <span class="hljs-comment">// line 143, r0.w  </span>
   }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータル全体のゴールマスクは、火と同じように、アニメーション化されたテクスチャ座標を使用して取得されます。</font><font style="vertical-align: inherit;">エフェクトの場所を設定するには、変数「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">region_mask</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を</font><font style="vertical-align: inherit;">使用します</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">region_mask</font></i><font style="vertical-align: inherit;">と呼ばれる別の変数を使用</font><i><font style="vertical-align: inherit;">vsDepth1を</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次のセクションで詳しく説明します。</font><font style="vertical-align: inherit;">ただし、ターゲットマスクへの影響はごくわずかです。</font><font style="vertical-align: inherit;">
ターゲットマスクのアセンブリコードは次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">137</span>: dp2 r0.w, v1.zzzz, r0.zzzz  
  <span class="hljs-number">138</span>: mul r2.xy, cb0[<span class="hljs-number">0</span>].xxxx, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.200000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">139</span>: mad r2.xy, v0.xyxx, l(<span class="hljs-number">4.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>), r2.xyxx  
  <span class="hljs-number">140</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r2.x, r2.xyxx, t1.xyzw, s0  
  <span class="hljs-number">141</span>: add r0.w, r0.w, r2.x  
  <span class="hljs-number">142</span>: add_sat r0.w, r0.w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">143</span>: mul r0.w, r0.w, r0.w  </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6。</font><font style="vertical-align: inherit;">すべてを一緒に入れて</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ふう、ほぼ完成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にポータルの色を取得しましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-comment">// Calculate portal color  </span><font></font>
 float3 portal_final;  <font></font>
 {  <font></font>
   <span class="hljs-keyword">const</span> float3 portal_inner_color = <span class="hljs-built_in">pow</span>(colorPortalInner, <span class="hljs-number">2.2</span>) * inner_influence;  
   <span class="hljs-keyword">const</span> float3 portal_outer_color = <span class="hljs-built_in">pow</span>(colorPortalOuterGlow, <span class="hljs-number">2.2</span>) * outer_glow_influence;  <font></font>
     <font></font>
   portal_final = portal_inner_color + portal_outer_color;  <font></font>
   portal_final *= vsDepth1; <span class="hljs-comment">// fade the effect to avoid harsh artifacts due to depth test  </span>
   portal_final *= portalFinalColorFilter; <span class="hljs-comment">// this was (1,1,1) - so not relevant  </span>
 }  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで説明したいのは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vsDepth1だけ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このマスクは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50d/32b/2a9/50d32b2a91308b9e356bf5cda0353d39.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のサブセクションでは、それがどのようになるかを示しました。</font><font style="vertical-align: inherit;">実際、これはポータルの色を減らすために使用される「線形深度バッファー」であり、深度テストにより境界がはっきりしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vsDepth1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による乗算の</font><i><font style="vertical-align: inherit;">有無にかかわら</font></i><font style="vertical-align: inherit;">ず、完成したシーンを検討してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/95c/995/9fe95c9956d4552e575a4aa0a7700330.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/8d5/7d7/ff38d57d70ee357d6a43c5ccd45deb6b.jpg"></div><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">portal_finalを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
作成した後</font><font style="vertical-align: inherit;">、完成した色を取得するのは簡単です：</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> finalPortalAmount = cb2_v0.x; <span class="hljs-comment">// 0.99443  </span>
   <span class="hljs-keyword">const</span> float3 finalColorFilter = cb2_v2.rgb; <span class="hljs-comment">// (1.0, 1.0, 1.0)  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> finalOpacityFilter = cb2_v2.a; <span class="hljs-comment">// 1.0  </span><font></font>
   ...  <font></font>
   <font></font>
   <span class="hljs-comment">// Alpha component for blending  </span>
   <span class="hljs-keyword">float</span> opacity = saturate( lerp(cb2_v0.x, <span class="hljs-number">1</span>, cb4_v13.x) );  <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate the final color  </span><font></font>
   float3 finalColor;  <font></font>
   {  <font></font>
     <span class="hljs-comment">// Mix the scene color (with heat haze effect) with the 'destination color'.  </span>
     <span class="hljs-comment">// In this particular example fog is used as destination (which is black where camera is nearby)  </span>
     <span class="hljs-comment">// but in theory there is nothing which stops us from putting here a landscape from another world.  </span>
     <span class="hljs-keyword">const</span> float3 destination_color = fog.paramsFog.a * fog.paramsFog.rgb;      <font></font>
     finalColor = lerp( sceneColor, destination_color, portal_destination_mask );  <font></font>
       <font></font>
     <span class="hljs-comment">// Add the portal color  </span><font></font>
     finalColor += portal_final * finalPortalAmount;  <font></font>
       <font></font>
     <span class="hljs-comment">// Final filter  </span><font></font>
     finalColor *= finalColorFilter;  <font></font>
   }  <font></font>
        <font></font>
   opacity *= finalOpacityFilter;  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4(finalColor * opacity, opacity);  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">プレーヤーが見る炎の量を決定する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalPortalAmount</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数がもう1つ</font><i><font style="vertical-align: inherit;">あり</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細にはテストしませんでしたが、ポータルが表示されたり消えたりするときに使用されていると思います-短時間、プレイヤーには火が見えませんが、他のすべて-グロー、ターゲットの色などが見えます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.まとめる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSL用の既製のシェーダーは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入手でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">元のコードと同じアセンブラーコードを取得するには、いくつかの行を入れ替える必要がありましたが、これによって実行の全体的な流れが妨げられることはありません。</font><font style="vertical-align: inherit;">シェーダーはRenderDocで使用する準備ができており、すべてのcbufferが存在しているなどので、それを注入して自分で試すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
お読みいただきありがとうございます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504324/index.html">Zabbix 5.0の新機能</a></li>
<li><a href="../ja504326/index.html">エフゲニー・ディキ：「ローカルでは、南極大陸はほとんど汚れていませんが、ここでは地球の汚染が非常に目立ちます」</a></li>
<li><a href="../ja504328/index.html">2019年モスクワ市下院での電子投票レッスン</a></li>
<li><a href="../ja504332/index.html">役立つ投稿：最も関連性の高いすべてのコース、放送、技術ストリーム</a></li>
<li><a href="../ja504334/index.html">JavaScriptをどの程度知っていますか？</a></li>
<li><a href="../ja504338/index.html">自宅でのUSB over IP</a></li>
<li><a href="../ja504340/index.html">遮断器は道徳（および電気技師）を夢見ていますか？</a></li>
<li><a href="../ja504342/index.html">あなたが与えないフィードバックはあなたが与えるものと同じくらい重要です</a></li>
<li><a href="../ja504344/index.html">認証-カスタムセットアップ/ AWS Amplify + React Native</a></li>
<li><a href="../ja504348/index.html">Monowheel：トレーニング中に何が起こり、このプロセスを加速する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>