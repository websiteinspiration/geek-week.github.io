<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💣 👨🏽‍✈️ 👨‍🏭 Scalaでのマイクロサービスの統合テスト 🍏 ⌛️ 🤦🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="単体テストは素晴らしいですが、1つでは不十分です。実行中のアプリケーションが機能することを確認したい場合がよくあります。統合テストが役に立ちます。サービスのテストにますます使用されており、Dockerを使用すると、テスト環境を簡単に管理できます。しかし、いつものように、はるかに多くのマイクロサービス...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Scalaでのマイクロサービスの統合テスト</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単体テストは素晴らしいですが、1つでは不十分です。実行中のアプリケーションが機能することを確認したい場合がよくあります。統合テストが役に立ちます。サービスのテストにますます使用されており、Dockerを使用すると、テスト環境を簡単に管理できます。しかし、いつものように、はるかに多くのマイクロサービスと依存関係がある場合、物事はそれほど単純ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RIT ++のYuri Badalyantsは、2GISで多数のサービスとテクノロジーズー全体をテストしている様子を語りました。カットの下で、このレポートのバージョンは、スピーカーの注意深い監督の下で補足および更新されます。どのオプションを試したか、何をしたか、今解決する必要のない問題は何か。それはDocker、Testcontainers、そしてScalaについてです。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">講演者について：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yuri Badalyants（@ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LMnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、2011年にWeb開発者としてキャリアをスタートさせ、PHP、JavaScript、Javaを使用しました。</font><font style="vertical-align: inherit;">現在、彼は2GISでScalaについて書いています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カジノ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2GISは20年間、便利な市内地図と会社名簿を提供してきました。最近では、</font><font style="vertical-align: inherit;">ロシアの地図が無制限の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいバージョン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ができました。</font><font style="vertical-align: inherit;">私がカジノチームで働いていた間に得た経験についてお話します。</font><font style="vertical-align: inherit;">このチームは、主に3つの領域に焦点を当てています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">広告表示-どの広告主を表示し、どの広告主を非表示にし、どの広告を上げ、どのように評価を下げるか。</font></font></li>
</ul><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigDataは、広告とそのパーソナライゼーション、および分析とメトリックの構築に関連しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クローラーは、インターネット上で組織を検索して自動的にデータベースに追加するプログラムです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら3つの領域はメインタスクであり、メインタスクには多数のサブタスクがあります。現在、Scalaで記述された25を超えるマイクロサービスがあります。これは私たちのコードのみですが、PostgreSQL、Cassandra、Kafkaなどのサードパーティシステムも使用しています。データはHadoopに保存され、Sparkで処理されます。さらに、データサイエンスチームが提供する機械学習手法を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、多数のサービスとマイクロサービス、多数の依存関係があり、もちろんこれらすべてを何らかの方法でテストする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、単体テストを作成します。ただし、すべてのテストが成功したとしても、すべてが機能するわけではありません。コンポーネントまたはマイクロサービスの統合フェーズ中に問題が発生する可能性があります。したがって、統合テストを作成します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合テスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カジノチームが開発した各マイクロサービスは、ビジネス上の問題を解決し、GitLabの個別のリポジトリに配置されます。</font><font style="vertical-align: inherit;">この記事では、依存関係がロックされた1つのリポジトリ（マイクロサービス）内での統合テストに焦点を当てます。これは、開発者自身の責任です。</font><font style="vertical-align: inherit;">QAチームはマイクロサービスの相互作用をテストしています。このトピックについては触れません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が最初にチームに参加したとき、2016年の終わりには、およそ次の統合テストスキームがありました。</font></font><br>
<img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者は自分のコードをGITにプッシュし、その後マイクロサービスコードがTeamCityに入ります。</font><font style="vertical-align: inherit;">TeamCityはコードの作成とテストの実行を開始します。</font></font></li>
<li>TeamCity    (config)  Chef (  ,   Ansible,    Ruby). Chef     .     100 ,           SSH  ,   ,  Chef   .</li>
<li>TeamCity  jar- (     Scala, ,   ,  jar),      CI .    ,   - .          .      ,   Chef,          .</li>
<li> TeamCity  <strong>SBT</strong> (   ,      )    .     unit-,       :   http   ,  -   ,   ;   - ,   ,   ,  .</li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような計画について何が言えるでしょうか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も重要なのは、それが機能することです。すべてがセットアップされると、単体テストのように見えるため、テストの実行は簡単です。しかし、プラスはそこで終わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、短所が始まります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CI環境は常にオン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、これはリソースの余分な無駄です。 Chefは静的構成であるため、すべての依存関係が構成され、アプリケーションが個別にデプロイされる、ある種のマシンが常に必要です。テストは時々実行されるため、このようなマシンは余分なリソースを消費し、マシンは常に準備ができている必要があります。さらに、CI環境はすべての依存関係に含まれています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのブランチで同時にテストを実行することはできません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは前の段落の後に続きます。1つの環境があるため、それらを並行して実行することはできません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起動、停止、再起動をテストすることはできません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これが必要な理由を説明します。すべてのアプリケーションは、いわゆる</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graceful shutdown</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のロジックに従います</font><font style="vertical-align: inherit;">。つまり、SIGTERMを取得したときに、プロセスを途中で停止することはありませんが、このシグナルを傍受し、プログラムをオフにする必要があることを理解しています。この時点で、特定のロジックがオンになります。たとえば、「処理中」のHTTPリクエストが処理されます。または、Kafkaで作業する場合は、すべてオフにコミットします。つまり、作業を安全に完了できるように特定のアクションを実行します。その後、すべてが完了したら、電源を切ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このロジックは常に単純であるとは限りません。テストからはアプリケーションのライフサイクルを制御できないため、このようなスキームを使用して手動でのみテストできます。テストは別の段階にあり、アプリケーションがどのようにデプロイされているかはわからないが、TeamCityは何らかの方法でChefを介して何かをデプロイしたことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のマイナス点は、</font><strong><font style="vertical-align: inherit;">これらすべてをローカルで構成</font></strong><font style="vertical-align: inherit;">することが非常に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">難しいことです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、多くの依存関係があり、独自の構成があり、ローカルマシンで発生させる必要があります。</font><font style="vertical-align: inherit;">アプリケーション自体にも独自の構成ファイルがあり、そこには多くの値があります。</font><font style="vertical-align: inherit;">テスト自体には、アプリケーション構成と一致する必要のある構成があり、複数の構成値が存在する場合もあります。</font><font style="vertical-align: inherit;">「3か所で構成を修正する」のように、これはそれほど恐ろしく聞こえないようですが、実際には、新入社員がこれを行うのに数時間かかる場合があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitLab CI + Docker</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに、このスキームは別のものに変わりました：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitLab CI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、前のスキームが理想的ではなかったために起こったのではなく、会社が管理組織の点で方向を少し変えたために起こりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、各チーム、そして私たちには、私たちが望むように、またはどのようにできるか、それらの多くがあり、その作業を開発しました。たとえば、TeamCityやChefがあり、他のチームはJenkinsやAnsibleを使用できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、ローカルクラウドとKubernetesに移行しています。GitLabCIとKubernetesの両方で、これらすべてを管理する別のチームがあります。他のチームはこれをサービスとして使用します。これをすべて手動で管理する必要がないため、これははるかに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesを使用して、次のスキームをデプロイしました。</font></font><br>
<img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TeamCityの代わりに、Gitlab CIが使用されるようになりました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitLab CIは、Dockerイメージを構築してKubernetesにデプロイします。</font><font style="vertical-align: inherit;">構成は、Chefでは個別にではなく、リポジトリに直接格納されるようになったため、デプロイメントのためにサードパーティの構成サービスを使用する必要はありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetesでも、事前に依存関係が引き上げられています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、GitLab CIはSBTを起動し、別のステップでテストします。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが前のスキームと非常によく似ており、基本的には違いません。つまり、長所と短所はまったく同じですが、Dockerが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dockerを使用すると、さまざまな楽しいことができ、その1つがdocker-composeです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker-compose</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Dockerの一種の「オーバーレイ」であり、複数のdocker-imageを単一のエンティティーとして実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker-composeが本当に役立つ良い例がKafkaです。</font><font style="vertical-align: inherit;">実行するにはZooKeeperが必要です。</font><font style="vertical-align: inherit;">docker-composeを使用せずにKafkaとZooKeeperを持ち上げる場合は、Dockerで個別にZooKeeperを引き上げる必要があります-Kafkaと、これら2つのDockerコンテナーの整合性を保つ必要があります。</font><font style="vertical-align: inherit;">これはあまり便利ではありません。docker-composeを使用すると、両方のコンテナーを同じdocker-compose.ymlファイルに記述</font></font><code>docker-compose run Kafka</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font><font style="vertical-align: inherit;">簡単なコマンド</font><font style="vertical-align: inherit;">でKafkaとZooKeeperを生成</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker-composeでは、統合テストを構築できます。</font><font style="vertical-align: inherit;">それがどのように見えるか見てみましょう。</font></font><br>
<img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう一度、GitLabにすべてをプッシュします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitLab CIがdocker-composeを起動します。</font></font></li>
<li> docker-compose  ,     SBT,  SBT      —    docker-compose.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスキームのおかげで、すべてがGitLab CIランナーに直接送られるため、dockerとdocker-composeを配置するだけで、個別の環境と依存関係を維持する必要はありません。開始時に、彼は必要なイメージをポンプアップして実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、すべてがランナーで発生するため、さまざまなブランチを同時にテストできます。</font><strong><font style="vertical-align: inherit;">ローカル</font></strong><font style="vertical-align: inherit;">で</font><strong><font style="vertical-align: inherit;">の</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
環境</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設定が簡単になりました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、いくつかの場所を調整する必要があります。ローカル構成を行うときに、すべてをローカルマシンに配置する必要はありません。すべてがdocker-compose.ymlファイルに書き込まれます。したがって、2つの異なる場所で構成する必要があります-これはdocker-compose.ymlとテストの構成です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所については、</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBTから、テストから、アプリケーションのライフサイクルを制御しないため</font><strong><font style="vertical-align: inherit;">、テストの開始、停止、再起動はまだ不可能</font></strong><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これはdocker-composeによって実行され、SBTを実行し、テストはSBT内で実行されます。</font><font style="vertical-align: inherit;">したがって、アプリケーションの本格的なライフサイクル管理はありません。</font><font style="vertical-align: inherit;">打ち上げにも問題がありますので、もう少しお話ししたいと思います。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docker-compose 2</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker-compose 2の時代、docker-compose.ymlファイルは次のようになりました。</font></font><br>
<br>
<pre><code class="bash hljs">version: <span class="hljs-string">'2.1'</span><font></font>
services:<font></font>
  web:<font></font>
    build: .<font></font>
    depends_on:<font></font>
      db:<font></font>
        condition: service_healthy<font></font>
      redis:<font></font>
        condition: service_started<font></font>
  redis:<font></font>
    image: redis<font></font>
  db:<font></font>
    image: db<font></font>
    healthcheck:<font></font>
      <span class="hljs-built_in">test</span>: <span class="hljs-string">"some test here"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにサービスが登録されています。つまり、このdocker-composeの一部として調達するサービスです。この場合、私はdocker-composeのドキュメントの例を取り上げました。 3つのサービスがあります：web、redis、db（データベース）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのアプリケーションはWebであり、redisとdbは何らかの依存関係です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webブロックには、というアイテムがあります</font></font><code>depends_on</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、Webアプリケーションが他のいくつかのコンテナに依存していることを示唆しており、以下で説明されています：データベースとredisから。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、商品もございます</font></font><code>condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Redisにはこれ</font></font><code>service_started</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。つまり、redisが開始するまで、コンテナーはWebアプリケーションを開始しようとしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースに関しては、条件があります-</font></font><code>service_healthy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびhealthcheckについては以下で説明します。</font><font style="vertical-align: inherit;">つまり、Dockerコンテナーを起動するだけでなく、特定のヘルスチェックを実行する必要があります。</font><font style="vertical-align: inherit;">任意のカスタムロジックを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、PostGIS拡張機能を使用するPostgreSQLを使用しているため、初期化には時間がかかります。</font><font style="vertical-align: inherit;">Dockerコンテナーを起動すると、postgis拡張機能をすぐに操作できません。拡張機能が初期化されるのを待つ必要があります。</font><font style="vertical-align: inherit;">したがって、私たちはただヘルメットのリクエスト</font></font><code>SELECT PostGIS_Version();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">拡張機能が初期化されるまで、リクエストはエラーをスローし、拡張機能が初期化されると、バージョンを返し始めます。</font><font style="vertical-align: inherit;">これは非常に便利で論理的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><strong><font style="vertical-align: inherit;">最初にすべての依存関係を発生させ、次にアプリケーションを発生させます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docker-compose 3</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker-compose 3がリリースされたとき、私たちはそれを使い始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのドキュメントでは、depends_onロジックの変更に関する項目が表示されました。</font><font style="vertical-align: inherit;">Docker開発者は、依存関係グラフの記述で十分であると判断しました。</font><font style="vertical-align: inherit;">つまり、チームが起動する</font></font><code>docker-compose run web</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、アプリケーション自体と、それが依存するデータベースの両方が同時に起動します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメンテーションの次の段落では、condition_onはもはや状態ではないことを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、2番目のバージョンで使用されていた機能を引き続き使用したい場合は、すべてを自分の手に渡さなければなりません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">起動順序</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページ</font><font style="vertical-align: inherit;">は、いくつかのソリューションを提供します。</font><font style="vertical-align: inherit;">最初のオプションは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait-for-it.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用すること</font><strong><font style="vertical-align: inherit;">です</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでdocker-compose.ymlは少し違って見えます：</font></font><br>
<br>
<pre><code class="bash hljs">version: <span class="hljs-string">'3'</span><font></font>
services:<font></font>
  web:<font></font>
    build: .<font></font>
    depends_on: [ db, redis ]<font></font>
  redis:<font></font>
    image: redis<font></font>
    <span class="hljs-built_in">command</span>: [ <span class="hljs-string">"./wait-for-it.sh"</span>, ... ]<font></font>
  db:<font></font>
    image: redis<font></font>
    <span class="hljs-built_in">command</span>: [ <span class="hljs-string">"./wait-for-db.sh"</span>, ... ]</code></pre><br>
<code>depends_on</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-単なる配列であり、条件はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係では、コマンドを再定義します。つまり、docker-composeでは、Dockerコンテナーを開始するコマンドをアタッチできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、wait-for-it.shなどを記述します。上記の例の3つのドットの代わりに、待機する必要があるものと、Dockerコンテナーを起動する元のコマンドを記述する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、Dockerファイルを見つけ、そこからredisのコマンドをコピーして貼り付ける必要があります。データベースの場合も同様です。大きなマイナス点は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化が機能</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しないことです。Dockerコンテナーを起動するコマンドを知りたくありません。これらのコマンドは簡単ではなく、かなり複雑になる可能性がありますが、気にしたくはありません</font></font><code>docker run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コマンドを入力したいだけです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は個人的にはこのソリューションがあまり好きではありませんが、このように機能するいくつかのサービスがありました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docker-compose上のスクリプト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、「自転車の製造」の時期がきたと判断し、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docker-compose-run.shを作成しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="bash hljs">version: <span class="hljs-string">'3'</span><font></font>
services:<font></font>
  postgres:<font></font>
    ...<font></font>
<font></font>
  my_service:<font></font>
    depends_on: [ postgres ] <font></font>
    ...<font></font>
<font></font>
  sbt:<font></font>
    depends_on: [ my_service ]<font></font>
    ...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
半現実的な例を挙げます。docker-compose.ymlにpostgresがあり、postgresに依存するmy_serviceアプリケーションがあり、テストが実行され、サービスに依存するSBTがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムを実行するのではなく</font></font><code>docker run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、docker-compose-run.shスクリプトを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、最も深い依存関係を最初に開始します。私の場合は、postgresです。</font><font style="vertical-align: inherit;">スクリプトは依存関係を「デーモン」モードで開始します。つまり、端末をブロックしません。</font></font><br>
<br>
<pre><code class="bash hljs">docker-compose up -d postgres</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、wait_until関数によって条件が満たされるのを待ちます。</font><font style="vertical-align: inherit;">これはwait-for-it.shとほとんど同じですが、いわば命令型です。</font><font style="vertical-align: inherit;">PostGISが初期化している間、ターミナルはブロックされます。つまり、プログラムも待機し、待機しない場合はエラーがスローされ、テストが機能しなくなります。</font></font><br>
<br>
<pre><code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in">exec</span> -T postgres psql</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostGISが初期化されたら、次のステップに進み、サービスに対して同じことを行います。</font><font style="vertical-align: inherit;">彼にとっては、テストは少し単純です。ポート80をバインドする必要があります。</font></font><br>
<br>
<pre><code class="bash hljs">docker-compose up -d my_service<font></font>
wait_until 10 2 docker-compose <span class="hljs-built_in">exec</span> -T \<font></font>
  my_service sh -c <span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、テストが実行されるrunコマンドを介してSBTを実行することです。</font></font><br>
<br>
<pre><code class="bash hljs">docker-compose run sbt<font></font>
down $?</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべてが正しい順序で、ただし手動で発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後</font></font><code>down</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、前のコマンドの結果を受け入れる</font><font style="vertical-align: inherit;">関数が呼び出さ</font><font style="vertical-align: inherit;">れます。</font><font style="vertical-align: inherit;">「0」の場合、テストは成功し、Docker-composeをオフにするだけです。</font><font style="vertical-align: inherit;">それ以外の場合は、まずログを「吐き出して」問題の原因を突き止め、次にdocker-composeをオフにします。</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-keyword">function</span> down {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Exiting with code <span class="hljs-variable">$1</span>"</span>
    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$1</span> -eq 0 ]]; <span class="hljs-keyword">then</span><font></font>
        docker-compose down<font></font>
        <span class="hljs-built_in">exit</span> <span class="hljs-variable">$1</span>
    <span class="hljs-keyword">else</span><font></font>
        docker-compose logs -t postgres my_service<font></font>
        docker-compose down<font></font>
        <span class="hljs-built_in">exit</span> <span class="hljs-variable">$1</span>
    <span class="hljs-keyword">fi</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなスキームは機能しますが、うまく拡張できません。</font><font style="vertical-align: inherit;">各サービスは、独自のロジックでdocker-compose-run.shを記述する必要があります。</font><font style="vertical-align: inherit;">さらに、起動設定はdocker-compose-run.shとdocker-compose.ymlの間で拡張されます。</font><font style="vertical-align: inherit;">まあ、一般的に、私たちはdocker-composeを使用していないように見えますが、その欠点に苦労しています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードからドッカーを実行する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のスキームが作成されたとき、私は考えました。Dockerにすべてがすでにある場合は、コードから実行しないでください。私は解決策を探し始め、いくつかのオプションを見つけました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のオプションは、単に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerクライアントを使用することです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 JVMの世界には、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docker-java</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spotify docker-clientの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの主要なdockerクライアントがあり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dockerクライアントを使用すると、APIを使用してコードから直接Dockerコマンドを実行できます。つまり、文字列を連結してタイプコマンドを作成する代わり</font></font><code>`docker run ...`</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、コードでそのようなコマンドを作成して実行するだけです。それははるかに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法はうまく機能し、確かに彼らはすべてを行うことができますが、これは非常に低いレベルです。私は独自のdocker-composeを作成する必要がありますが、これは非常に大きな作業です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のオプションは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docker-it-scalaライブラリーで</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これらのクライアントの両方をラップし、使用するバックエンドを選択できます。</font><font style="vertical-align: inherit;">彼女はあなたが必要とするコンテナを起動することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このライブラリの欠点は、非常に柔軟なAPIがなく、ライフサイクル制御がないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私もこのオプションが気に入らなかったので、検索を続けて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testcontainers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見つけ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これについてもっとお話ししたいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストコンテナ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Dockerコンテナを起動してテストするための一種のJavaライブラリです。</font><font style="vertical-align: inherit;">Scalaファサード、testcontainers-scalaがあります。</font><font style="vertical-align: inherit;">箱から出してすぐに、PostgreSQL、MySQL、Nginx、Kafka、Seleniumなどの人気のあるサービスがいくつかあります。</font><font style="vertical-align: inherit;">他のコンテナを実行できます。</font><font style="vertical-align: inherit;">ライブラリにはかなりシンプルで柔軟なAPIが含まれています。これについては後で詳しく説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義済みのコンテナ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ライブラリ内にある事前定義されたコンテナーを操作する方法：コンテナーはオブジェクトとして表されるため、実際にはすべてが非常に単純です。</font></font><br>
<br>
<pre><code class="bash hljs">val pgContainer: PostgreSQLContainer = <font></font>
  PostgreSQLContainer(<span class="hljs-string">"postgres:9.6"</span>)<font></font>
<font></font>
pgContainer.start()<font></font>
<font></font>
val pgUrl: String = pgContainer.jdbcUrl<font></font>
val pgPort: Int = pgContainer.mappedPort(5432)<font></font>
<font></font>
pgContainer.stop()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、を作成し</font></font><code>PostgreSQLContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それを起動して作業を開始できます。</font><font style="vertical-align: inherit;">次に</font></font><code>jbdcUrl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PostgreSQLに接続する方法について説明します。</font><font style="vertical-align: inherit;">その後、それを取得し</font></font><code>mappedPort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、PostgreSQLがdockerポート5432から突き出し、Testcontainersがこのポートを認識して、ランダムなポートに自動的に割り当てることを意味します。</font><font style="vertical-align: inherit;">つまり、たとえば32422などのテストから、割り当ては自動的に行われます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムコンテナ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のビュー、いわゆるカスタムコンテナーも非常に単純です。</font></font><br>
<br>
<pre><code class="bash hljs">class GenericContainer(<font></font>
  imageName: String,<font></font>
  exposedPorts: Seq[Int] = Seq(),<font></font>
  env: Map[String, String] = Map(),<font></font>
  <span class="hljs-built_in">command</span>: Seq[String] = Seq(),<font></font>
  classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(),<font></font>
  waitStrategy: Option[WaitStrategy] = None<font></font>
) ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこ</font></font><code>GenericContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から、いくつかのフィールドを継承して再定義する必要があります。必ず指定してください。</font></font><code>imageName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、作成するコンテナの名前です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定することが可能です</font></font><code>exposedPorts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：コンテナが「突き出す」ポート。 envでは、環境変数を設定でき</font></font><code>command</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。実行するように</font><font style="vertical-align: inherit;">設定</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">こともでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<code>classpathResourceMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerコンテナー内のクラスパスからリソースをスローできます。これは、たとえば、アプリケーション構成がテストリソースに直接ある場合に非常に便利です。あなたは単に内部にマッピングし、Docker内部のアプリケーションがこの設定にアクセスします。</font></font><br>
<br>
<code>waitStrategy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-docker-compose 3で欠けていた非常に便利なもので、実際にはHealthCheckです。いくつかの事前定義があります</font></font><code>waitStrategy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、ポートバインディングが発生するまで待つことも、特定のhttpメソッドが200を返すこともできます。ただし、任意のHealthCheckを書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HealthCheckはコードで簡単に記述できるため、最初に、bashではなく通常の言語を使用できます。次に、コードから使用できるライブラリを使用できます。CassandraでカスタムHealthCheckを作成する場合は、ドライバーを取得して記述します。 HealthCheck。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストを実行する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、テストの実行方法について少し説明します。</font></font><br>
<br>
<pre><code class="bash hljs">class PostgresqlSpec extends FlatSpec <font></font>
  with ForAllTestContainer {<font></font>
<font></font>
  override val container = PostgreSQLContainer()<font></font>
<font></font>
    <span class="hljs-string">"PostgreSQL container"</span> should <span class="hljs-string">"be started"</span> <span class="hljs-keyword">in</span> {<font></font>
    Class.forName(container.driverClassName)<font></font>
    val connection = DriverManager<font></font>
      .getConnection(container.jdbcUrl, container.username, container.password)<font></font>
    // <span class="hljs-built_in">test</span> some stuff<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scalaの世界でのテストの事実上の標準である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaTest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
について</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">お話し</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Postgresのテストを記述したいとします。テスト</font></font><code>PostgresqlSpec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成し、</font><font style="vertical-align: inherit;">それを継承し</font></font><code>ForAllTestContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、ライブラリによって提供される特性です。すべてのテストの前に必要なコンテナーを開始し、すべてのテストの後で停止します。または</font></font><code>ForeachTestContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それ</font><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">、各テストの前にコンテナを開始し、各テストの後に停止</font><font style="vertical-align: inherit;">することもでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、コンテナを再定義する必要があります。これを行うには、プロパティをオーバーライドします</font></font><code>container</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私の場合、を使用します</font></font><code>PostgreSQLContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、テストを記述します。この例では、接続を作成し、jdbcUrl、ユーザー名、パスワードを取得し、特定のテストを作成し、リクエストを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、統合テストにはいくつかのコンテナが必要です。</font><font style="vertical-align: inherit;">私はそれらを作成できます</font></font><code>MultipleContainers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="bash hljs">val pgContainer = PostgreSQLContainer()<font></font>
val myContainer = MyContainer()<font></font>
<font></font>
override val container = <font></font>
  MultipleContainers(pgContainer, myContainer)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、私はコンテナを作成してに追加し</font></font><code>MultipleContainers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それをとして使用します</font></font><code>container</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testcontainersでテストを実行するためのスキームは次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitLaでコードをプッシュします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitLab CIランナーがSBTを発売します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBTはテストを実行します。</font><font style="vertical-align: inherit;">テスト内で、アプリケーションと依存関係が起動されます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスキームの利点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個別の環境と依存関係を維持する必要はありません。すべてがランナーで行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるブランチを同時にテストできます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのライフサイクルを制御できるので、テストを開始、停止、再開できます（すべてテストコードで正しく開始されます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に欠けていた柔軟なHealthCheckがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリには* .shファイルがありません。アプリケーションでテストを好きなように柔軟に設定できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classpathResourceマッピングのおかげで、テストとアプリケーションの両方で同じ設定を使用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードからテストを構成できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらはすべてCIとローカルの両方で同じように簡単に実行されます。これらは単体テストとして表示および実行される単なるテストであるため、Dockerコンテナーですべてが実行されるだけです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが疑わしいほどスムーズで良いことがわかりましたが、これは一見しただけで、実際にはいくつかの問題が発生しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存コンテナ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが遭遇した最初の問題は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存コンテナ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ある種のテストがあるとしましょう：</font></font><br>
<br>
<pre><code class="bash hljs">class MySpec extends FlatSpec <font></font>
  with ForAllTestContainer {<font></font>
<font></font>
  val pgCont = PostgreSQLContainer()<font></font>
    val appCont = <font></font>
    AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password)<font></font>
<font></font>
  override val container = MultipleContainers(appCont, pgCont)<font></font>
<font></font>
  // tests here<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
postgresとAppContainerを実行します。</font><font style="vertical-align: inherit;">postgresのappContainerには、接続用のユーザー名とパスワードであるjdbcUrlが渡されます。</font><font style="vertical-align: inherit;">次に、MultipleContainersが作成され、テスト自体が記述されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムを実行するとエラーが表示されます。</font></font><br>
<br>
<pre><code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイントは、コンテナが起動するまで割り当てられたポートを取得できないことです。なんでこんなことが起こっているの？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事実は、彼らである</font></font><code>ForAllTestContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いずれかの</font></font><code>ForEachTestContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は、コンテナのインスタンスを作成した瞬間に発射コンテナはすぐにテストの前に、そしてません。 AppContainerを作成した時点ではまだオンにしていないことがわかりました。つまり、</font></font><code>PostgreSQLContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当てられたポートを彼から取得することはできませんが、それを形成するために必要</font></font><code>jdbcUrl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、コンテナの本質が変更可能であるということです。いくつかの状態があります。たとえば、オフとオンを切り替えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには？私が「怠惰」と呼ぶ最初の方法。</font></font><br>
<br>
<pre><code class="bash hljs">class MyTest extends FreeSpec <font></font>
  with BeforeAndAfterAll {<font></font>
<font></font>
  lazy val pgCont = PostgreSQLContainer()<font></font>
  lazy val appCont = <font></font>
    AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password)<font></font>
<font></font>
  override def beforeAll(): Unit = {<font></font>
    super.beforeAll()<font></font>
    pgCont.start()<font></font>
    appCont.start()<font></font>
  }<font></font>
<font></font>
  override def afterAll(): Unit = {<font></font>
    super.afterAll()<font></font>
    appCont.stop()<font></font>
    pgCont.stop()<font></font>
  }<font></font>
<font></font>
  // tests here<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なアイデアは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイジーval</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してコンテナーを作成すること</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">その後、テストコンストラクタですぐに初期化されませんが、最初の呼び出しを待ちます。</font><font style="vertical-align: inherit;">私たちは、メソッドで初期化を行います</font></font><code>beforeAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>afterAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特性という</font></font><code>BeforeAndAfterAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaTestからは提供されます。</font><font style="vertical-align: inherit;">それらは</font></font><code>beforeAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナで始まり</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">コンテナで</font></font><code>afterAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフ</font><font style="vertical-align: inherit;">になり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">コンテナーは遅延宣言されているため、beforeAllでstartメソッドが呼び出されると、コンテナーが作成、初期化、および開始されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、localhost：32787に参加できないというエラーが引き続き発生します。</font></font><br>
<br>
<pre><code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
jdbcUrlを使用したようですが、なぜlocalhostが表示されるのですか？</font><font style="vertical-align: inherit;">jdbcUrlの仕組みを見てみましょう。</font></font><br>
<br>
<pre><code class="bash hljs">@Override<font></font>
public String <span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span>() {
    <span class="hljs-built_in">return</span> <span class="hljs-string">"jdbc:postgresql://"</span> + <font></font>
        getContainerIpAddress() + <font></font>
        <span class="hljs-string">":"</span> + <font></font>
        getMappedPort(POSTGRESQL_PORT) + <font></font>
        <span class="hljs-string">"/"</span> + <font></font>
        databaseName;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは単なる文字列連結です。すべては定数で明確であり、壊れることはありません。</font></font><code>getMappedPort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに修正済みなので、これも機能するはずです。</font></font><code>databaseName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードコードされた定数です。しかし、</font></font><code>getContainerIpAddress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もっと面白い。名前からすると、コンテナのIPアドレスを返すと想定できます。しかし、このコードを実行すると、常にlocalhostを返すことがわかります。結局のところ、このメソッドはコンテナー間の相互作用を目的としていません</font><font style="vertical-align: inherit;">。</font></font><code>getContainerIpAddress</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナー内のテストからの相互作用を提供します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testcontainers開発者の推奨事項：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナー間通信用のカスタムネットワークを作成します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Docker-composeは次のように機能します。ネットワークを作成し、すべてを独自に解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ネットワークを作成する必要があります。</font></font><br>
<br>
<pre><code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll {<font></font>
<font></font>
  val network: Network = Network.newNetwork()<font></font>
  val dbName = <span class="hljs-string">"some_db"</span>
  val pgContainerAlias = <span class="hljs-string">"postgres"</span>
  val jdbcUrl = s<span class="hljs-string">"jdbc:postgresql://<span class="hljs-variable">$pgContainerAlias</span>:5432/<span class="hljs-variable">$dbName</span>"</span><font></font>
<font></font>
  lazy val pgCont = {<font></font>
    val c = PostgreSQLContainer(<span class="hljs-string">"postgres:9.6"</span>)<font></font>
    c.container.withNetwork(network)<font></font>
    c.container.withNetworkAliases(pgContainerAlias)<font></font>
    c.container.withDatabaseName(dbName)<font></font>
    c<font></font>
  }<font></font>
  lazy val appCont = {<font></font>
    val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password)<font></font>
    c.container.withNetwork(network)<font></font>
    c<font></font>
  }<font></font>
<font></font>
  override def beforeAll(): Unit = {<font></font>
    super.beforeAll()<font></font>
    pgCont.start()<font></font>
    appCont.start()<font></font>
  }<font></font>
<font></font>
  override def afterAll(): Unit = {<font></font>
    super.afterAll()<font></font>
    appCont.stop()<font></font>
    pgCont.stop()<font></font>
    network.close()<font></font>
  }<font></font>
<font></font>
  // tests here<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、jdbcUrlを手動で構成する必要があります。</font><font style="vertical-align: inherit;">また、ネットワーク内のコンテナーを有効にし、PostgreSQLContainerのエイリアスを設定して、ネットワーク内のドメイン名からアクセスできるようにする必要もあります。</font><font style="vertical-align: inherit;">最後に、ネットワークを「強制終了」することを忘れないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、そのようなプログラムは機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
testcontainers-scalaの最近のバージョンでは、レイジーコンテナーの初期化がそのままサポートされています。</font></font><br>
<br>
<pre><code class="bash hljs">class MyTest extends FreeSpec <font></font>
  with ForAllTestContainer <font></font>
  with BeforeAndAfterAll {<font></font>
<font></font>
  val network: Network = Network.newNetwork()<font></font>
  val dbName = <span class="hljs-string">"some_db"</span>
  val pgContainerAlias = <span class="hljs-string">"postgres"</span>
  val jdbcUrl = s<span class="hljs-string">"jdbc:postgresql://<span class="hljs-variable">$pgContainerAlias</span>:5432/<span class="hljs-variable">$dbName</span>"</span><font></font>
<font></font>
  lazy val pgCont = {<font></font>
    val c = PostgreSQLContainer(<span class="hljs-string">"postgres:9.6"</span>)<font></font>
    c.container.withNetwork(network)<font></font>
    c.container.withNetworkAliases(pgContainerAlias)<font></font>
    c.container.withDatabaseName(dbName)<font></font>
    c<font></font>
  }<font></font>
  lazy val appCont = {<font></font>
    val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password)<font></font>
    c.container.withNetwork(network)<font></font>
    c<font></font>
  }<font></font>
<font></font>
  override val container = MultipleContainers(pgCont, appCont)<font></font>
<font></font>
  override def afterAll(): Unit = {<font></font>
    super.afterAll()<font></font>
    network.close()<font></font>
  }<font></font>
<font></font>
  // tests here<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは使用することができます</font></font><code>ForAllTestContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font><font style="vertical-align: inherit;">再び</font></font><code>MultipleContainers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなた</font></font><code>beforeAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手動で起動順序を設定するには、不要になりました。</font><font style="vertical-align: inherit;">これで</font></font><code>MultipleContainers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、遅延valを使用して正しい順序で実行できるようになり、作成直後に厳密な初期化が行われなくなりました。</font><font style="vertical-align: inherit;">同時に、カスタムネットワークとjdbcUrlを使用した操作も手動で行う必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、まだ問題があります。たとえばmoki。場合によっては、Dockerコンテナにある種の依存関係を作成するのはあまり便利ではありません。 Spark JobServerを使用して、Sparkジョブを作成し、Sparkでのライフサイクルを制御します。 「作成」と「ステータスを与える」という2つの方法を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Docker内でSpark JobServerを実行します。 Sparkを上げる必要があり、最近まで、Dockerコンテナーはまったくなく、自分で組み立てる必要がありました。さらに、Spark JobServerはPostgreSQLを使用して状態を保存します。その結果、単純なAPIで2つのメソッドだけが本当に必要な場合、多くの複雑な作業を行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Spark JobServer実装を覗いて、同じように動作するモックを作成できますが、元のSpark JobServerの依存関係は必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは次のようになります（この例では、単純化された疑似コード）。</font></font><br>
<br>
<pre><code class="bash hljs">val hostIp = ???<font></font>
<font></font>
AppContainer(sparkJobServerMockHost = hostIp)<font></font>
<font></font>
val sparkJobServerMock = new SparkJobServerMock()<font></font>
<font></font>
sparkJobServerMock.init(someData)<font></font>
<font></font>
val apiResult = appApi.callMethod()<font></font>
<font></font>
assert(apiResult == someData)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストでは、HTTPサーバーが作成され、Spark JobServerと同じAPIで起動されます。</font><font style="vertical-align: inherit;">これはいくつかのデータで初期化され、アプリケーションを実際のサーバーではなくこのサーバーに転送します。</font><font style="vertical-align: inherit;">メソッドが返すものは、モックに入力したものと一致する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、どういうわけか、このmokに接続する方法をコンテナーに伝える必要があります。</font><font style="vertical-align: inherit;">このポートを使用すると、すべてがほぼ明確になります。「縫い合わせる」か、構成に含めることができます。</font><font style="vertical-align: inherit;">問題は、どのホストが必要かということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当社</font></font><code>SparkJobServerMock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">での試験から直接実行するには、それがホストマシン上で実行され、そして、今度は、私たちのカスタムドッキングウィンドウネットワークの一つで動作するドッキングウィンドウコンテナ内のアプリケーションを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアドレスを取得する方法？ Dockerネットワークデバイスをよく知っている場合は、Dockerコンテナーが配置されているネットワークのゲートウェイを使用する必要があることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、TestcontainersにそのようなAPIがないことです。ただし、Testcontainersは通常のdocker-javaクライアント上で実行されるため、そのレベルまで下げることができます。つまり、ベアDockerクライアントを使用します。</font></font><br>
<br>
<pre><code class="bash hljs">val client: com.github.dockerjava.api.DockerClient =<font></font>
  DockerClientFactory<font></font>
    .instance<font></font>
    .client<font></font>
val networkInfo: com.github.dockerjava.api.model.Network =<font></font>
  client<font></font>
    .inspectNetworkCmd()<font></font>
    .withNetworkId(network.getId)<font></font>
    .<span class="hljs-built_in">exec</span>()<font></font>
val hostIp: String = <font></font>
  networkInfo<font></font>
    .getIpam<font></font>
    .getConfig<font></font>
    .get(0)<font></font>
    .getGateway</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、それを取る必要があります</font></font><code>DockerClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Testcontainersは</font></font><code>DockerClientFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このために</font><font style="vertical-align: inherit;">持っ</font><font style="vertical-align: inherit;">ています。次に、チームを編成し</font></font><code>inspectNetworkCmd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。そして最後に、情報から、ゲートウェイを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見複雑に見えるかもしれませんが、一度やってみるとすべてがわかりやすくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このソリューションには問題があります-それはどこでも機能するわけではありません。 Dockerはさまざまな環境で動作します。Windows、Macはリモートにすることができます。ただし、このプログラムはLinuxでのみ動作します。これは私たちにとって問題ではありません。私たちは皆、Linuxで作成してテストも実行しているからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さいわい、Testcontainersの新しいバージョンでは、この問題は解決されました。これで、ポートをホストマシンから転送して、Dockerネットワークでアクセスできるようになります。これは次のように行われます。</font></font><br>
<br>
<pre><code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code></pre><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナが開始する前に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このメソッドを呼び出すことが重要です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">呼び出し後、ホストポートはDockerコンテナー内で使用可能になります。</font><font style="vertical-align: inherit;">そして、それをホストとして使用する必要があります</font></font><code>`host.testcontainers.internal`</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コードは大幅に簡略化されます。</font></font><br>
<br>
<pre><code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string">"host.testcontainers.internal"</span><font></font>
<font></font>
val sparkJobServerMockPort = 33333<font></font>
<font></font>
Testcontainers.exposeHostPorts(sparkJobServerPort)<font></font>
<font></font>
AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発テストコンテナ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例からわかるように、近年、ライブラリユーザーの生活を大幅に簡素化する多くの改善がTestcontainersに現れました。</font><font style="vertical-align: inherit;">JavaライブラリーとScalaファサードの両方が開発されています。</font><font style="vertical-align: inherit;">主な開発分野は次のとおりです。</font></font><br>
<br>
<ul>
<li>         . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> Scala </a>.      .    ,    .  ,   predefined         Java-.        ,      .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  API</a>.        API,          . ,      .    ,       ,   .</li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優れた統合テストを作成することは困難です。</font><font style="vertical-align: inherit;">Dockerは役立ちますが、多くの機能を提供します。ネットワークゲートウェイが必要であることを最終的に理解するには、十分に理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testcontainersは、多くの問題を解決する非常に優れたライブラリです。</font><font style="vertical-align: inherit;">APIはまだ完全ではありませんが、毎年改善されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaの世界から来ていない場合は、いずれにしても、アプローチ自体は非常に優れています。</font><font style="vertical-align: inherit;">オブジェクトとしてのコンテナの表現は、当面の勝利戦略です。</font><font style="vertical-align: inherit;">彼との交流はとても便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の言語やシステム用の同様のライブラリがあり、同様のプロジェクトを実装できるDockerクライアントが常に存在します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">報告後の質疑応答</font></font></b><div class="spoiler_text"><strong><em> —       ,       , ,     . .?</em></strong><br>
<br>
,    .<br>
<br>
<strong><em> —   -     ?</em></strong><br>
<br>
    Kubernetes,     .      end-to-end ,    ,    ,   ,   .<br>
<br>
     ,   ,       unit-,            .<br>
<br>
<strong><em> —         Kubernetes    ?</em></strong><br>
<br>
-,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       .<br>
<br>
,       ,      unit-,   , ,  break point  ,       ,    .<br>
<br>
,   ,  ,   CI  ,      .<br>
<br>
 ,       minicube —     Mac, .       ,      ,   ,   ,  .<br>
<br>
<strong><em> —     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong><br>
<br>
   ImageName,   Postgres 9.6.<br>
<br>
<pre><code class="bash hljs">val pgContainer: PostgreSQLContainer = <font></font>
    PostgreSQLContainer(<span class="hljs-string">"postgres:9.6"</span>)</code></pre><br>
   9.6,     10.    [ ],     .<br>
<br>
     Image tag —   , —       ,        .    ,    latest   .<br>
<br>
<strong><em> — ,           ?</em></strong><br>
<br>
,  CI    ,  GitLab CI , ,  Branch Name.<br>
<br>
<strong><em> —  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong><br>
<br>
-,       ,        .      ,      ,  ,  ,     ,  .<br>
<br>
-      ,    ,    full-time ,   ,      ,  .<br>
<br>
     commit’,       , ,      ,    Android, iOS  . .    ,       ,  ,   , —   .<br>
<br>
    ,  ,      -: -  , - . , -    .<br>
</div></div><br>
<blockquote>          Scala –    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">ScalaConf</a>     .         –   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">HighLoad++</a> 7-8 .<br>
<br>
  ,  ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>,            . </blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464293/index.html">React Reduxでフックは置き換えられますか？</a></li>
<li><a href="../ja464295/index.html">いくつかの新しいJavaScript機能の使用例</a></li>
<li><a href="../ja464299/index.html">0、0、1、0、2、0、2、2、1、6、0、5、0、2、6、5、4、0、5、3、0、3、2、9、0、 4、9、3、6、14、0、6、3、5、15、0、5、3、5 ...</a></li>
<li><a href="../ja464303/index.html">リレーショナルDBMSの時系列データ。TimescaleDBおよびPipelineDB for PostgreSQLの拡張機能</a></li>
<li><a href="../ja464305/index.html">小さい、はい。Firecrackerマイクロ仮想の開梱</a></li>
<li><a href="../ja464309/index.html">DIY呼び出しボタン。Raspberry Pi、MajorDoMo、Freeswitch、Linphonec</a></li>
<li><a href="../ja464315/index.html">土の入ったフィルム。Yandexの研究と意味による検索の簡単な歴史</a></li>
<li><a href="../ja464317/index.html">こんばんわプロジェクト</a></li>
<li><a href="../ja464327/index.html">さまざまなツールキットGUIのメモリ使用量の比較</a></li>
<li><a href="../ja464331/index.html">役に立たない利点：カシューナッツからの紫外線吸収化学物質の合成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>