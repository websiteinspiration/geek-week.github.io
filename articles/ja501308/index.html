<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 🐄 🔛 StateFlowを試して理解する 💉 💃🏿 🥟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは。
 
 数日前、JetBrains はCorutin-1.3.6の新しいバージョンをリリースしました。その革新の1つは、ConflatedBroadcastChannelに代わるFlowの新しい亜種であるStateFlowでした。私はStateFlowを実際に試し、内部構造を研...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>StateFlowを試して理解する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501308/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数日前、JetBrains </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はCorutin-1.3.6の新しいバージョンを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リリースしました。</font><font style="vertical-align: inherit;">その革新の1つは、ConflatedBroadcastChannelに代わるFlowの新しい亜種であるStateFlowでした。</font><font style="vertical-align: inherit;">私はStateFlowを実際に試し、内部構造を研究することにしました。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AndroidやMPPでの開発時にKotlinを使用する人の多くは、これらの用語に精通していると思いますが、そうではありません。これらのエンティティは、RxJavaのBehaviorProcessor / BehaviorSubjectとJetpackのLiveData / MutableLiveDataの類似物です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StateFlow自体は、Flowインターフェースの単純な拡張であり、2つの形式があります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StateFlow</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">T</span>&gt; </span>{
    <span class="hljs-comment">/**
     * The current value of this state flow.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> value: T<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MutableStateFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">StateFlow</span>&lt;<span class="hljs-type">T</span>&gt; </span>{
    <span class="hljs-comment">/**
     * The current value of this state flow.
     *
     * Setting a value that is [equal][Any.equals] to the previous one does nothing.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考え方は、LiveData / MutableLiveDataと同じです。1つのインターフェースでは現在の状態のみを読み取ることができ、もう1つのインターフェースではインストールすることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StateFlowは、ConflatedBroadcastChannelと比較して何を提供してくれますか。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> よりシンプルでガベージフリーの内部実装。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのアイテムの必要性。</font><font style="vertical-align: inherit;">ヌルも可能です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 読み取り専用インターフェースと読み取り/書き込みインターフェースへの分離。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> リンク比較の代わりに等価性を介して要素を比較します。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、StateFlowの簡単な使用法を実装してみましょう。</font><font style="vertical-align: inherit;">これを行うために、デフォルトでnull要素を持つ任意の型を設定する機能を備えた基本ラッパーを作成しました。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateFlowRepository</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: T? = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> stateFlow = MutableStateFlow(initialValue)<font></font>
<font></font>
    <span class="hljs-keyword">var</span> value: T?
        <span class="hljs-keyword">get</span>() = stateFlow.value
        <span class="hljs-keyword">set</span>(value) {<font></font>
            stateFlow.value = value<font></font>
        }<font></font>
<font></font>
    <span class="hljs-keyword">val</span> stream: Flow&lt;T?&gt; = stateFlow<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを取得します。</font></font><br>
<br>
<pre><code class="kotlin hljs">lifecycleScope.launch {<font></font>
            simpleRepo.stream.collect {<font></font>
                addData(it.toString())<font></font>
            }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、テスト用の最も単純なインターフェイスで画面に表示します。問題は発生せず、すべてが時計</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/cv/_c/pncv_c41cwncgwkfc3hd3wxzfh0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のように機能します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、内部を見て、それがどのように実装されているかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
驚いたことに、実装は非常にシンプルで、現在316行しかありません。そのうち25％はjavadokiです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、メインの実装クラスはStateFlowImplクラスです。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateFlowImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: Any) : SynchronizedObject(), MutableStateFlow&lt;T&gt;, FusibleFlow&lt;T&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = atomic(initialValue) <span class="hljs-comment">// T | NULL</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sequence = <span class="hljs-number">0</span> <span class="hljs-comment">// serializes updates, value update is in process when sequence is odd</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> slots = arrayOfNulls&lt;StateFlowSlot?&gt;(INITIAL_SIZE)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nSlots = <span class="hljs-number">0</span> <span class="hljs-comment">// number of allocated (!free) slots</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nextIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// oracle for the next free slot index</span><font></font>
<font></font>
. . .<font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_state-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態を格納するアトミックリンク。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -パリティ/ </font><font style="vertical-align: inherit;">奇数に応じて</font><font style="vertical-align: inherit;">、状態</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スロット</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を更新する現在のプロセスを報告する補助インジケーター</font><font style="vertical-align: inherit;">-アレイ/プールStateFlowSlot。 StateFlowSlot-StateFlowへの各「接続」の補助的な抽象化。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nSlots、nextIndex-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張可能な配列スロットを操作するためのヘルパー変数</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StateFlowSlotを事前に検討してみましょう。彼はただ代表します：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = atomic&lt;Any?&gt;(<span class="hljs-literal">null</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、スロットの状態を変更するためのメソッド。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各スロットは、のいずれかの状態にあることができる：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヌル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -作成したが、使用しないれる</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NONEを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -中古コレクタ</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留状態</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -コレクタに新しい値を送信するのを見越して</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellableContinuationImpl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -宛先ペンディング状態にsaspended状態近い、コレクタ懸濁するのStateflowに新しい状態まで来ないであろう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい値を設定するとどうなるかを考えます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T
        <span class="hljs-keyword">get</span>() = NULL.unbox(_state.value)
        <span class="hljs-keyword">set</span>(value) {
            <span class="hljs-keyword">var</span> curSequence = <span class="hljs-number">0</span>
            <span class="hljs-keyword">var</span> curSlots: Array&lt;StateFlowSlot?&gt; = <span class="hljs-keyword">this</span>.slots <span class="hljs-comment">// benign race, we will not use it</span>
            <span class="hljs-keyword">val</span> newState = value ?: NULL<font></font>
            synchronized(<span class="hljs-keyword">this</span>) {
                <span class="hljs-keyword">val</span> oldState = _state.value
                <span class="hljs-keyword">if</span> (oldState == newState) <span class="hljs-keyword">return</span> <span class="hljs-comment">// Don't do anything if value is not changing</span><font></font>
                _state.value = newState<font></font>
                curSequence = sequence<font></font>
                <span class="hljs-keyword">if</span> (curSequence and <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) { <span class="hljs-comment">// even sequence means quiescent state flow (no ongoing update)</span>
                    curSequence++ <span class="hljs-comment">// make it odd</span><font></font>
                    sequence = curSequence<font></font>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// update is already in process, notify it, and return</span>
                    sequence = curSequence + <span class="hljs-number">2</span> <span class="hljs-comment">// change sequence to notify, keep it odd</span>
                    <span class="hljs-keyword">return</span><font></font>
                }<font></font>
                curSlots = slots <span class="hljs-comment">// read current reference to collectors under lock</span><font></font>
            }<font></font>
            <span class="hljs-comment">/*
               Fire value updates outside of the lock to avoid deadlocks with unconfined coroutines
               Loop until we're done firing all the changes. This is sort of simple flat combining that
               ensures sequential firing of concurrent updates and avoids the storm of collector resumes
               when updates happen concurrently from many threads.
             */</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">// Benign race on element read from array</span>
                <span class="hljs-keyword">for</span> (col <span class="hljs-keyword">in</span> curSlots) {<font></font>
                    col?.makePending()<font></font>
                }<font></font>
                <span class="hljs-comment">// check if the value was updated again while we were updating the old one</span>
                synchronized(<span class="hljs-keyword">this</span>) {
                    <span class="hljs-keyword">if</span> (sequence == curSequence) { <span class="hljs-comment">// nothing changed, we are done</span>
                        sequence = curSequence + <span class="hljs-number">1</span> <span class="hljs-comment">// make sequence even again</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-comment">// done</span><font></font>
                    }<font></font>
                    <span class="hljs-comment">// reread everything for the next loop under the lock</span><font></font>
                    curSequence = sequence<font></font>
                    curSlots = slots<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの主なタスクは、FlowCollectorへの連続した呼び出しのために、異なるフローからのStateFlow状態変化を修正することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのステップを区別できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい値を設定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンスマーカーを奇数の値に設定するということは、既に更新処理中であることを意味します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">makePending（）-すべてのスロット状態（つまり、すべての接続）をPENDINGに設定します-すぐに新しい値を送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループは、すべてのタスクが完了したシーケンス== curSequenceをチェックし、シーケンスを偶数に設定します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">collect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドで何が起こるか</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-keyword">val</span> slot = allocateSlot()
        <span class="hljs-keyword">var</span> prevState: Any? = <span class="hljs-literal">null</span> <span class="hljs-comment">// previously emitted T!! | NULL (null -- nothing emitted yet)</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// The loop is arranged so that it starts delivering current value without waiting first</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">// Here the coroutine could have waited for a while to be dispatched,</span>
                <span class="hljs-comment">// so we use the most recent state here to ensure the best possible conflation of stale values</span>
                <span class="hljs-keyword">val</span> newState = _state.value
                <span class="hljs-comment">// Conflate value emissions using equality</span>
                <span class="hljs-keyword">if</span> (prevState == <span class="hljs-literal">null</span> || newState != prevState) {<font></font>
                    collector.emit(NULL.unbox(newState))<font></font>
                    prevState = newState<font></font>
                }<font></font>
                <span class="hljs-comment">// Note: if awaitPending is cancelled, then it bails out of this loop and calls freeSlot</span>
                <span class="hljs-keyword">if</span> (!slot.takePending()) { <span class="hljs-comment">// try fast-path without suspending first</span>
                    slot.awaitPending() <span class="hljs-comment">// only suspend for new values when needed</span><font></font>
                }<font></font>
            }<font></font>
        } <span class="hljs-keyword">finally</span> {<font></font>
            freeSlot(slot)<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なタスクは、初期デフォルト値を送信し、新しい値を待つことです。 </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい接続用のスロットを作成または再利用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態をnullまたは状態変更についてチェックします。</font><font style="vertical-align: inherit;">Emittimは新しい意味です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新の準備ができているスロットがある（PENDING状態）かどうかを確認し、ない場合は、新しい値を見越してスロットを一時停止します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的には、これですべてです。</font><font style="vertical-align: inherit;">スロットの割り当てとその状態の変化がどのように発生するかについては考慮しませんでしたが、これはStateFlowの全体像にとって重要ではないと考えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感謝。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501296/index.html">ビジネス上の問題を解決せずにプログラマーとしてキャリアを築く方法</a></li>
<li><a href="../ja501298/index.html">独自のQGISプラグインリポジトリを作成する</a></li>
<li><a href="../ja501300/index.html">AtlassianサーバーとデータセンタープラグインのReactとAtlaskit</a></li>
<li><a href="../ja501302/index.html">音を立てないでください</a></li>
<li><a href="../ja501306/index.html">Graal Native Imageをエンドユーザーに提供するパイプラインを構築する</a></li>
<li><a href="../ja501310/index.html">過酸化水素とロケットバグについて</a></li>
<li><a href="../ja501312/index.html">Alpine.js-便利な構文を持つ軽量フレームワーク</a></li>
<li><a href="../ja501316/index.html">マイクロソフトの調査：従業員のトレーニングは、ビジネスに人工知能を導入する際の重要な要素の1つです</a></li>
<li><a href="../ja501318/index.html">jsとgoogleシートを使用してビルゲイツのゴルフクラブの隣人になる方法</a></li>
<li><a href="../ja501320/index.html">BOMコストが1ドル未満のLEDドライバー。出来ますか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>