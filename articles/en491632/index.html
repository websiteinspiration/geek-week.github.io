<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò§ ‚ôãÔ∏è ‚õ∏Ô∏è Digital Immortality - Synchronous Internet üëÉ üëçüèΩ ü§¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I propose to continue the topic that began in the previous article (https://habr.com/en/post/489068/). If, in essence, she indulged in dreams of the t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Digital Immortality - Synchronous Internet</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I propose to continue the topic that began in the previous article (https://habr.com/en/post/489068/). If, in essence, she indulged in dreams of the type of how everything will be fine (or badly depends on the type of person) when technological singularity and digital immortality come in the year 20XX, then in this and subsequent articles I will try to do everything possible to ensure a happy future (singularity) came faster, namely to create a computational paradigm for the fifth generation processor (remember there were a couple of lines about this). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will use ‚Äúcopyright‚Äù and name the created computing paradigm ‚ÄúRutel‚Äù.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let‚Äôs try to figure it out: is there really a need for something radically new, or can old man von Neumann be ‚Äúshamanized‚Äù and enough? </font><font style="vertical-align: inherit;">The Japanese were just on fire: while they were trying to make a new architecture and a parallel processor, the production technologies of conventional serial processors improved. </font><font style="vertical-align: inherit;">They have improved so much that all the expected parameters for a parallel processor on a regular serial have been achieved. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The likelihood of repeating such a scenario</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is currently low for many reasons:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The existing architectural backlogs have already been exhausted (works by Lebedev and others);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sizes of transistors are already comparable to molecules;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heat dissipation practically does not drop with a decrease in technological standards;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increasing the processor frequency does not improve performance.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The developers of computer technology have no ideas, except for a banal increase in the number of cores in a computer system. </font><font style="vertical-align: inherit;">I think this approach is not productive for systems that are not based on the concept of "parallel computing." </font><font style="vertical-align: inherit;">And the logical (sequential) thinking of a person (programmer) also does not shine with parallelism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Given the identified problems, let's define the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requirements</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> currently being put forward for promising computing systems:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelism</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribution</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solving the problem of complexity.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fault tolerance.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The creation of any device is made in response to any need. Modern computer technology was created in response to the need for large amounts of scientific and engineering computing. Currently, the main use of computer technology is ‚Äúcomputation‚Äù, ‚Äúrevitalization‚Äù of various virtual models, some of them are simplified models of objects from the real physical world, others are generally completely virtual and at the same time interact with the outside world through various interfaces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The transfer of a person‚Äôs personality to such a system is also a modern need.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von Neumann's computational paradigm is inherently an advanced and powerful enough, but still a calculator. The basis of modern computing technology is "imitation" of the logical thinking of a person (note: only logical thinking, and not the structure of the brain as a whole), but it is not intended to simulate the surrounding world. The logical thinking of a person is a high-level mental process and is fundamentally consistent. Think about the phrase: a programming language. The programming language, the basis of interaction with a computer system is logically connected with a part of the human body and inherits many of its features. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As an example, try to say two phrases at the same time. Yes, and fully listening to two people at the same time (especially with similar voices) does not work.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main task</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , one should take the task of maintaining or ‚Äúrevitalizing‚Äù the objects of the virtual world. </font><font style="vertical-align: inherit;">The virtual world, which contains both models of objects from the real world coupled with connections (through various sensors and manipulators), and models that have no analogues in it. </font><font style="vertical-align: inherit;">In the limit, the ‚Äúnew computational paradigm‚Äù should not be considered as another tool for solving immediate problems, but as a set of additional dimensions for our physical world. </font><font style="vertical-align: inherit;">I want to note that a person (as a whole) is a biological system that solves exactly the same problem; accordingly, to transfer a person‚Äôs personality, a system with the same or greater functionality will be required.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where to begin?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturally, you need to start with the postulation of the properties of virtual space. </font><font style="vertical-align: inherit;">Today's computing technology is represented by one-dimensional space (infinite address space). </font><font style="vertical-align: inherit;">But this is not enough to model a three-dimensional (+ time) world, which constantly gives rise to problems requiring ‚Äúcrutches‚Äù for their solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will give examples of the problems inherent in the modern computing paradigm:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the location of the object in memory, it is impossible to change its size without re-creating. </font><font style="vertical-align: inherit;">You have to use indirect addressing, solve problems with defragmentation and memory allocation. </font><font style="vertical-align: inherit;">Problems with stack overflows and various buffers.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no concept of lack of data in the data presentation system, any garbage in the physical memory is legitimate data, which causes errors.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no concept of another computing system (object), there is only one ‚Äútape‚Äù of memory and one automaton that modifies it. </font><font style="vertical-align: inherit;">This approach gives rise to problems with the interaction of tasks even within the same processor (tasks are performed sequentially), and if more than one computer system needs to interact, then ‚Äúcrutches‚Äù reach epic proportions.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These examples are only for understanding that most of the big problems are at the very core of the computational paradigm, in the simplest "brick" elements. </font><font style="vertical-align: inherit;">These "bricks" at some point do not want to form a single structure and the entire "building" collapses. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postulates</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (they will be replenished, and then reduced to several basic ones):</font></font><br>
<br>
<ol>
<li>     ¬´¬ª,          ¬´¬ª   .</li>
<li>   ¬´¬ª  .    ¬´¬ª    (  )   ¬´¬ª      ¬´¬ª    ¬´¬ª.  ,                  ¬´¬ª  .</li>
<li>      .</li>
<li>      ,          ¬´¬ª ¬´ ¬ª  ¬´¬ª,   .</li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly, virtual space is a multidimensional foam of bubbles in contact with each other.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
These postulates will allow you to create any system (sets of interacting objects) from the real (physical) or virtual world. Example: access to an address through the ‚Äúmemory‚Äù object using the ‚Äúaddress‚Äù dimension and there can be any number of such address spaces. Addressed objects have additional dimensions corresponding to different address spaces. Objects ‚Äúmemory‚Äù in the form of physical objects may not exist (purely virtual model). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important point</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: the postulates do not indicate the location of objects, the presence and storage device, even the concept of address space is not (much less a single one). All that can be said is the potential presence of space (a ‚Äúbubble‚Äù); one can be convinced of the presence of the bubble itself only by the presence of a ‚Äúcontact‚Äù. Inside the ‚Äúbubble‚Äù, all that can be ‚Äúnumbered‚Äù is the contact point. If there are no contacts, then these are completely independent and theoretically in no way affecting each other systems, but at the same time they are all in the original ‚Äúbubble‚Äù and can begin to interact in the future.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the task of personality transfer, the digital brain will look like one common bubble, including 100 billion bubbles, which contain an object that emulates a neuron or an object of communication with the biological brain. </font><font style="vertical-align: inherit;">Visually, one can even imagine stretching (deformation of the projection of the "bubble" in three-dimensional space) of threads (axons of dendrites) to the contact points.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of the communication system in the created paradigm</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caution</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
All ideas and algorithms described in this article are the result of my independent and completely independent intellectual activity. </font><font style="vertical-align: inherit;">As an author, I authorize you to freely use, modify, supplement all ideas and algorithms to any person or organization in any type of project with the obligatory indication of my authorship.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the modern paradigm, realizing space as a one-dimensional ring is quite simple: address, data for ‚Äúwriting‚Äù - ‚Äúreading‚Äù and signals ‚Äúreading‚Äù - ‚Äúwriting‚Äù. For a paradigm with a multidimensional ‚Äúbubble‚Äù, it is required to create a communication system for ‚Äúeveryone with everyone‚Äù (in the limit), of course, in reality this is impossible. Most objects will be connected through intermediary nodes. The distribution of the ‚Äúcommunication range‚Äù will have a ‚Äúnormal type‚Äù, the smaller the distance between the nodes, the greater the number of such connections (logic and common sense dictate the need to mark interacting objects as close as possible to each other). The basis of a communication system with intermediary nodes is an algorithm for multiplexing (dividing) a communication channel between several sources.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first, it is better to give a simplified explanation of the principle of operation of the multiplexing algorithm of the physical communication channel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The transmitted data can be represented as a "scattering" of beads (each bead is unique and the sequence cannot be changed), which must be transmitted through a tube with a diameter equal to the diameter of the bead. </font><font style="vertical-align: inherit;">If there is one source of beads, then there is no problem of access to the ‚Äútelecommunication pipe‚Äù, it is in the exclusive possession. </font><font style="vertical-align: inherit;">If there are a lot of bead sources, then they can collide at the entrance to the ‚Äútube‚Äù, and even at the exit of the beads you need to separate into separate bins. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The proposed algorithm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (for example, bus) looks like this:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">string the beads from various sources on elastic threads and fix (a separate thread for each source)</font></font></li>
<li>  ,     ,          (   ).        ,    .</li>
<li>     ,        .</li>
<li>       (  )</li>
<li>       (        )</li>
<li>        :   ,         (        ).</li>
<li> ,           (,    ),    ,        . </li>
<li>          ,       ( ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If at the time when it was necessary to put the bead in the tube, the bead had not yet been transferred through the incoming tube and the hopper was empty, then to ensure the uniqueness of the sorting algorithm, you need to place a special ‚Äúempty‚Äù bead instead. On the receiving side, an empty bead will not be placed in the hopper, but simply discarded. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next will be a text targeted at telecommunications professionals. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because of the desire to cover all aspects of the telecommunication paradigm, the text turned out to be somewhat messy and bloated. What requires a thoughtful reading, there may be inaccurate terms and logical errors (I will be grateful for the corrections).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a problem with the difficulty of perceiving the text, I want to supplement the description with pictures, but I do not have the ability to draw beautifully. </font><font style="vertical-align: inherit;">If someone wants to shoulder such a burden, I will be very grateful. </font><font style="vertical-align: inherit;">In response, I can only offer a note of authorship in each figure.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next for those who are not afraid</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Current state of data transmission networks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modern data transmission networks are designed for a relatively low connection intensity (the number of channels or individual messages) and at the same time weakened simultaneous requirements are imposed on the stability of time, delivery speed, creation time of a virtual channel, the time it takes to use a backup data transfer path and the maximum percentage of utilization of the physical channel bandwidth . A data network built on such principles critically does not meet the requirements put forward by the new computing paradigm. To understand the scale of the expected increase in traffic and speed requirements, you can take the amount and speed of data transmitted through the processor stack and associated data in memory (pointers are most often passed through the stack) and multiply by the number of computing cores of a typical supercomputer.These requirements will be the lower bar of requirements for the data network.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A distributed computing system is a large number of interconnected (participating in joint calculations) computing modules (blocks) that generate, in the general case, a large number of short-term connections. </font><font style="vertical-align: inherit;">Connections require higher transmission speeds combined with low, stable latency and guaranteed delivery. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The requirements put forward to the data transmission network from the perspective of a distributed (distributed) computer system, the performance of the entire system ultimately depends on the implementation of which.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extremely short virtual channel creation time. </font><font style="vertical-align: inherit;">The virtual channel creation time should be comparable with the time of filling the local buffer of the transmitter (router).</font></font></li>
<li>                    .</li>
<li>                      .  ,                 ,     .</li>
<li>           .</li>
<li>  ,              .        ()    .</li>
<li>            (90%  ). </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ideally, a communication system requires the direct connection of each component of the system with each, but in reality this is impossible and you have to transmit data through intermediate nodes. In each node of such a network there is a switch connected to several of the same nodes using shared communication lines (into virtual channels). The basis of such a communication system are algorithms for multiplexing (dividing) a physical channel into a large number of virtual channels and transferring data between virtual channels in various physical channels. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The currently used (main) algorithms (synchronous hierarchy and packet data transmission system) of such separation (multiplexing) of the physical channel critically do not satisfy the requirements put forward.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Channels created by the methods of synchronous hierarchy (SDH) have excellent performance in terms of stability of transmission speed, lack of collisions, and the effect of channel utilization on these parameters. At the same time, the transmission delay leaves much to be desired (it operates with containers large enough in size) and there is no flexibility in the parameters of the created channels. For optimal operation of the computer network, delay times (i.e., data transfer times) are required, which must be determined by two parameters: physical distance (cable length) and be proportional to the requested data transfer rate. Switches must be able to simultaneously support a large number of virtual channels (up to millions at the same time) with a constant switching time. In addition, channels (SHD) do not have sufficient flexibility in the speed of created channels,and the time it takes to create a virtual channel is generally a sad picture (we need times comparable to the transmission delay time).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using packet switching does not make sense at all (when used in canonical form), not a single requirement is fulfilled at all (for a sufficiently large computing system). The channel creation time is partially executed only on the transmitter side, work with a large number of possible routes in real time is not provided, you can‚Äôt build a table for all connection options (too much size and administration costs). Guaranteed delay for packet data transmission is impossible in principle. Regulation of data transfer speed and guaranteed access are possible only through reserve bandwidth, which is not possible with a large number of virtual channels. Data losses (collisions) are fundamentally present in packet transmission (for real values ‚Äã‚Äãof buffers in the switch).All problems of packet data transmission are significantly exacerbated when approaching the maximum physical channel capacity.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : For the optimal operation of a distributed computing system, a new paradigm of building a data transfer system is needed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The basis of the data transmission system is a method (algorithm) for dividing one physical channel into the required number of virtual and maximally synchronous ones for building an end-to-end virtual channel between the receiver and transmitter. According to the results of a preliminary analysis of the situation, the most optimal is the SDH algorithm. To overcome the disadvantages inherent in SDH, it is necessary to ‚Äúredesign‚Äù this system. The SDH algorithm is largely a continuation of the ideas embodied in PDH, which grew out of landline telephony systems. For a distributed computing system, the presence of a frame with a duration of 125 Œºs, as well as splitting into many channels of the same performance (and the hierarchy with end-to-end synchronization, too), is an absolutely senseless restriction (for telephony all this was the basis of the basics).For the computing system "TK" for the lowest level of the data transfer system will be as follows:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Split the source stream into a given number of virtual data channels, with a given bit rate for each channel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To ensure the transfer of the payload from the incoming channel to the outgoing channel, using a data buffer with a size tending to one character.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is no explicit requirement for the presence of a frame of constant or variable size and it is advisable not to introduce it, even as a means of determining the period of time within which the list of virtual channels (into which the physical channel is divided) is constant. If you introduce the concept of a frame, then the creation of an additional channel will require time, determined by the size of the frame. If no additional actions are taken, the delay in creating a new channel will be on average half the frame time times the number of transit switches, which will drastically increase the time for creating new virtual channels (and deleting old ones).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to divide a single physical channel into an arbitrary number of separate virtual channels with an arbitrary transmission rate, subject to the rule of the sum of speeds (the sum of the speeds of virtual channels plus the cost of administering the channels should not exceed the speed of the primary channel)?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the requirement for synchronism, equal time between the individual transmitted pieces of data, is put forward to the channels being created, which ensures the minimum size of the buffers. The requirement of a minimum buffer size stems from the inability to organize a buffer outside the switch crystal in the switch. Try to buffer a stream of 100G (400G) or more, and if there are ten or a hundred such flows, even minimal unevenness will overflow the memory of any reasonable size, and the throughput of a typical RAM is less than the speed of even one such stream. If you want to create one virtual channel (or several channels with the same transfer rate), then there is no problem (SDH), but when creating two or more channels with different data transfer rates, conflicts can occur,at the same time, it is necessary to transmit data belonging to various virtual channels. To satisfy the requirements for a data transmission system, we will modify the SDH multiplexing algorithm.</font></font><br>
<br>
<h3>   </h3><br>
<ol>
<li>              .</li>
<li>    ‚Äî .       ,           (    ),     .      :  ,      (). <br>
<br>
            .                        (   ).           (,  ,    ,     ).      (  )  ,      ,      ,      .         .         .    100     ,          .         (   )     (),             .          (     ),             . </li>
<li>   (   )      ¬´¬ª,       .      ,           .      .           ,    .</li>
<li>   ¬´¬ª  (   )           .        (   )          .</li>
<li>            .            .</li>
<li>        ,      (   )          (   ).</li>
<li>      .   (  )       ¬´¬ª.      ,     (      ), ,    FIFO   .       ,     ,          ( ).              ¬´¬ª (    ),     FIFO       . <br>
<br>
 ,      (      ),    .    ¬´¬ª    -    .         ,    ¬´ ¬ª.    ¬´ ¬ª,    ¬´¬ª              FIFO   .           ,      (  ).     ,   ,       ‚Äî    ,          ,      (   ). (         )</li>
<li>        32 (24)     64 /,      E1(T1). ,    PHD        .</li>
<li>       .         ( 100)    ( ).     106    .      120 .          2.5  (    )   (  ).. (                .)</li>
<li>  (   )  ,    ( )    ¬´¬ª  ¬´ ¬ª,       (   ).                 .       ¬´¬ª  ¬´ ¬ª,      .</li>
<li>        ,     ¬´ ¬ª               (          ),        ¬´ ¬ª.         ¬´ ¬ª,               .            .</li>
<li>      (    )        (         ).          .   ¬´ ¬ª         ,                () .     ¬´ ¬ª      ,       .   ,           (  ).        ,      ()   .       ,     ,         .   ,     ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After transmission through a physical channel, the total stream must be disassembled not only because of the rearrangement of virtual channels between physical channels, but also because of the potential need to add or remove ‚Äúno data‚Äù characters (it is possible only at the moment of writing or reading characters to the buffer). Partial ‚Äúediting‚Äù or replacing data does not make much sense. You can add the ability to create a total stream that is not understood in intermediate switches - a tunnel (it will not understand the components in intermediate switches). Creating a virtual ‚Äútunnel‚Äù is possible if you create a summary stream using alternative service symbols (the algorithm remains the same, each tunnel level requires its own set of service symbols) and then transfer the resulting summary stream as a regular virtual channel.On the receiving side, an additional procedure is required to disassemble such a channel into its components (the number of analyzes is equal to the level of the ‚Äútunnel‚Äù). Creating ‚Äútunnels‚Äù is beneficial due to the decrease in the number of virtual channels and, accordingly, the required buffers in the intermediate switches (and the switching delay proportional to the speed of the virtual channel will be less). The number of buffers limits the number of virtual channels passing through the switch simultaneously. Any physical channel (for reception or transmission) can use any buffer (buffers are a common resource), which increases the coefficient of their use.Physically, the buffer is a small FIFO for several characters to be stored (up to 10 and is determined by the time to create a new virtual channel and the maximum unevenness of the data transfer time) with the number of read and write interfaces equal to the number of modules collecting or disassembling the total channel in this switch (all physical and virtual channels), while there is a guarantee of no more than one call per clock cycle. The period of the clock synchronization of the buffers coincides with the frequency of reception and transmission of characters. If you have one broadband channel and a large number of smaller ones, you can assign large characters to a fast channel and write several pieces of data to buffers at once (or another option). The described architecture is very well cascaded.There are many configuration options and it is necessary to seek the optimal compromise.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When building a communication network within a single chip, the transmitter modules will turn into two registers (one on the transmitter side and one on the receiver side), the algorithm itself will not change. If the speeds and composition of the created channels are constant, then the size of the switch hardware can be greatly optimized.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In total, the data transmission network consists of switches and communication cables between their ports. The purpose of the network is to deliver customer data with the highest possible quality. The client connects to the network through a device similar to a regular switch, the distinguishing feature of which is the ability to access the data buffers by the hardware of the computing system itself and their larger size. As soon as the received data of the created virtual channel is written into the buffer of the switch connected to the computer system (for reception), then the mechanism (similar to interruption in the usual computer system) should be turned on, waiting for the information to appear enough to determine the called service and the corresponding software will be connected to maintain this buffer.The difference from the modern "network card" is the ability to create a large number of parallel channels (parallel access to the data network), which removes the internal queue of packets from (to) the network to (from) a large number of computing cores (threads). Automation of the launch of "data handlers".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creating a channel can be divided into two stages: administration (route search, speed assignment, access permission, etc.) and the direct creation of a virtual channel (when data transfer is necessary). The first stage is performed relatively rarely (the network is relatively static) and this can be done in advance at the application launch stage. The second stage is required to be performed as quickly as possible, it is this stage that determines the performance of the data network and the performance of the entire distributed computing system. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Directly creating and deleting a virtual channel (all the necessary data is prepared at the first stage) should occur at the highest possible speed. It is more correct to say that the creation of the channel and the transmission of data must occur simultaneously.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The algorithm should look something like this: at the initial moment of time, the virtual channel does not yet exist (the first portion of the data is written to the buffer associated with the data source), the multiplexer has not allocated part of the physical channel bandwidth for it, there are only service channels and you need to decide which a new virtual channel will be created from the physical channels. When a sufficient amount of data appears in the buffer in order to create a virtual channel (direction and required speed, they are selected from the list of alternatives), it is necessary to form and send (using the service channel) a data packet with a request to create a virtual channel in the desired physical channel. Package with the request and parameters of the created virtual channel,passing through the synthesis device of the total channel of the transmitter and parsing the total channel of the receiver of the selected physical channel, changes the composition of the table of virtual channels of the receiver and transmitter. The package with the parameters should contain the ‚Äúadd channel‚Äù service symbol, after which the controller starts transmitting the total stream with the new virtual channel added to it. At the moment of adding a new virtual channel, data sampling from the buffer begins and the characters of the created virtual channel are sent to the side of the selected router. A new channel is created without notifying the remote switch, based only on the free bandwidth of the local physical channel. The performance of the created channel is always less than the initial performance of the service channel (free part of the physical channel),a new channel is created by separating part of the resource from the service channel. When processing (receiving from a physical channel) a packet with a request to create a new virtual channel, it is necessary to determine in which of the available (free) buffers to start saving the data of the new channel in the time remaining before receiving the ‚Äúadd channel‚Äù symbol. It is impossible to save the request in memory and process it later, the composition of the total stream will change immediately after receiving the ‚Äúcreate a channel‚Äù symbol (or with a known delay) and the total stream containing the symbols of the created virtual channel will begin to be received, which will destroy the decoding process of the total stream (if the list of channels in the receiver Will not change). The time to calculate the number of the outgoing physical channel to which it is necessary to start sending data from the allocated buffer,should be minimal (determined by the size of the buffer), which means that speed and route data should already be in the packet header with a request to create a new virtual channel (there is essentially no time to access the table in external memory).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The formation of a packet with a request is possible only after receiving all the necessary data about the direction of switching and the speed of the created channel. The virtual channel buffers in the switch must be small in size, which means that this data (speed and port number in the next switch) should be at the very beginning of the transmitted data, but the size of the current buffer would allow all subsequent data to be saved until the formation of a new total channel without overflow. After the packet with the request is formed, you need to delete the symbol with data on the number of the physical channel leading to the next switch (if the route is specified by specifying the sequence of switch ports). To close the virtual channel, there is no need to forward the packet using the service channel,it is enough to put the ‚Äúdelete channel‚Äù service symbol in the transmitted data of the deleted channel. At the moment of receiving the ‚Äúdelete channel‚Äù symbol by the multiplex channel synthesis module, the corresponding virtual channel is deleted and then the generated updated summary channel no longer contains the remote virtual channel. For automatic removal (cleaning), prevention of ‚Äúleakage‚Äù of the performance of a physical channel, it is necessary to integrate into the hardware buffers of virtual channels, a counter of the number of transmitted characters (any) and upon reaching a certain value (timeout) automatically transmit the ‚Äúclose channel‚Äù symbol. To extend the lifetime of the virtual channel, you can enter the "reset counter" symbol added to the data. The local switch may ignore channel lifetime extension,which will be the answer to the lack of bandwidth of the physical channel. If during the creation of a virtual channel, it must be switched to a physical channel with a lack of free bandwidth, the service channel speed is not enough to create a new virtual channel or there are no free buffers or another reason, then the request packet must be destroyed. More correctly, it is redirected to the stub module, which will receive all the characters of the failed virtual channel and generate all the necessary messages for the transmitting side (these messages are transmitted using the service channel). I do not consider the option with buffering due to the complexity of the implementation. This approach is optimal for channels with a short length,for them, the delivery timeout is minimal and will not greatly affect the overall performance due to repetitions of creating a virtual channel. If the channel was successfully created, then all that can happen is data distortion due to interference in the equipment. In contrast to the existing network (Ethernet), it is necessary not only to send a packet, but also to make sure that it is successfully built all the way to the addressee, already at the lowest level of service. Sending data "to nowhere" generally does not satisfy anyone, and checking the delivery of data by waiting for a response message is very "unpleasant" due to the unknown time required. Sending a notification about building a channel using a service channel, an operation that does not require particularly large resources.You can implement another option - immediately create a ring combining the source and receiver of the transmitted data (the packet will immediately run in a circle in its entirety or a response packet will be formed by the switch on the receiving side). You can generate such a notification (if there was a failure in the creation of the channel) on each intermediate switch so that the transmitter would know as soon as possible about the impossibility of creating the channel. If you really do not want to retransmit data when it is impossible to create a virtual channel with the required speed, this is optimal for routes with a very long delivery time (to the other side of the globe via satellite), then you can try to use the partial delivery algorithm.You can generate such a notification (if there was a failure in the creation of the channel) on each intermediate switch so that the transmitter would know as soon as possible about the impossibility of creating the channel. If you really do not want to retransmit data when it is impossible to create a virtual channel with the required speed, this is optimal for routes with a very long delivery time (to the other side of the globe via satellite), then you can try to use the partial delivery algorithm.You can generate such a notification (if there was a failure in the creation of the channel) on each intermediate switch so that the transmitter would know as soon as possible about the impossibility of creating the channel. If you really do not want to retransmit data when it is impossible to create a virtual channel with the required speed, this is optimal for routes with a very long delivery time (to the other side of the globe via satellite), then you can try to use the partial delivery algorithm.then you can try using the partial delivery algorithm.then you can try using the partial delivery algorithm.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When it is impossible to create a channel with the required speed, a channel with a lower speed is created (then a channel is created with this speed) and at the time of the switch buffer overflow, the buffer is cleared and a symbol indicating buffer overflow and the number of discarded characters is placed in it. Accepting such a character, the recipient forms a list of such speed reductions and sends it to the transmitter. The transmitter lowers the speed of the primary channel, calculates what data was skipped (the skipped data can be determined simply from the list of speed reductions and the size of the buffer) and sends them in the most optimal way (albeit an alternative route).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Routing in existing packet-switched networks is based on the address in the packet header, route tables, and other rules in intermediate routers. This approach works well for a relatively small number of route definitions and the possibility of buffering the received data of a single packet; it takes a relatively long time to determine the port number to which the packet should be sent. For high-speed systems with a short virtual channel lifetime, there will not be enough access speed to the memory of the switching tables (and the table itself will have a size in megabytes for each physical channel - you need to allocate RAM equal to the maximum possible number of virtual channels) and it is more advantageous to describe the route using the direct method enumeration of physical channels,through which a virtual channel should be built. The size of the address information will not be too large, the number of intermediate switches is relatively small, and if 8 bits are allocated for each switch (physical port or tunnel number), then an analogue of the IP6 address will allow you to build a route of 16 switches.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the proposed method, the table is turned into one byte for each buffer (namely, the existing, and not potentially possible virtual channel). In addition, it is necessary to take into account that the address is transmitted only at the time of creating the channel (it is gradually erased as it moves to the receiver), and the use of a virtual tunnel significantly reduces routing costs. To build chains of physical channels, you can use an analog of conventional search engines or DNS from modern networks, set destination parameters (any set of parameters: IP address is also a normal parameter) and we get a set of chains with alternative routes. Relative addressing has increased protection against unauthorized access, there is full control over the route. For the network to work,there is no need for the mandatory presence (operation) of high-level components, the route can be set in advance (for networks with a permanent communication system, as an example, wiring on a printed circuit board - the connections do not change).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direct traffic control, allocation (planning) of bandwidth, etc. is impossible due to the high speed of creating a channel and the potentially large size of the network. To balance the load of channels, it is necessary to use indirect methods, such as planning various routes, assigning transmission rates taking into account the accumulated statistics on the use of a virtual channel. When the physical channel is overloaded, data from already existing virtual channels is not discarded, it is impossible to only create a new channel. If we take into account the nature of the traffic (mainly short and frequent messages), the availability of backup routes and the very fast procedure for creating (deleting) a virtual channel, then refusing to create a channel will not lead to a catastrophic drop in performance,there will be just a slight subsidence in the speed of calculations (the re-creation of the channel will occur at the time of the message about the connection error or the expiration of a predetermined time). When negative statistics are accumulated (namely statistics, and not a reaction to an individual event), the switch management software monitors the frequency of connection errors and schedules the channel parameters taking into account this data. With a high probability, the congestion itself will stop in a time of hundreds of nanoseconds, and the router software should deal with strategic planning issues. Such planning may include the ability to edit already created routes (data is stored in the multiplexer), otherwise it is not possible to reliably rebuild the route network (when the software still asks for re-creation of the route).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Communication programs (threads of the computing process) with the sources (receivers) of the transmitted data is constructed according to the same scheme as in the switches. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A computing system is a large number of different executive modules integrated by a communication network. A communication network replaces all local buses and interfaces from access to memory to connecting a keyboard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This architecture of the computing system fundamentally changes the whole computing paradigm (this issue will later be considered in an article describing the structure of the operating system and software). </font><font style="vertical-align: inherit;">The role of network equipment in computing architecture is changing significantly. </font><font style="vertical-align: inherit;">If earlier the network was a way to connect separate computers and applications running on them, now the concept of a separate computer is essentially absent and the application can be ‚Äúspread out‚Äù over various network hardware resources. </font><font style="vertical-align: inherit;">The issue of administration (resource management by access parameters of a computer system) completely goes into the plane of network management connecting individual executive modules (there is no more central processor).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Response to transmission errors</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The lowest level of error control can be considered encoding of transmitted characters with the possibility of recovery when one or more errors occur (the number depends on the data transmission channel). If, despite coding, an erroneous symbol (or a group of symbols) nevertheless appears, then the synchronization of the list of virtual channels of the transmitter and receiver will have the most unpleasant effect. Accordingly, requests to change the table (create or delete a channel) should have the maximum possibility of recovery. If the request was nevertheless lost, then the data of all virtual channels having a speed lower than the speed in the request will be distorted. Further, there are two options for responding, completely breaking all virtual channels or only virtual channels with distorted data (with a lower transfer rate than the lost channel),in the data subjected to distortion add the symbol "error" (this symbol is processed by the receiver). If a desync is detected, it is necessary to restore the identity of the tables as quickly as possible, and the recovery time of the channels should be determined by the length of the cable (connecting the two switches). Complete transmission of the table from the transmitter to the receiver is the easiest option, but it is better to add a circular request number to each table editing request. By the request number, determine the moment of desync (the numbers do not go sequentially) and generate a request for re-sending the lost changes.and the channel recovery time should be determined by the length of the cable (connecting the two switches). Complete transmission of the table from the transmitter to the receiver is the easiest option, but it is better to add a circular request number to each table editing request. By the request number, determine the moment of desync (the numbers do not go sequentially) and generate a request for re-sending the lost changes.and the channel recovery time should be determined by the length of the cable (connecting the two switches). Complete transmission of the table from the transmitter to the receiver is the easiest option, but it is better to add a circular request number to each table editing request. By the request number, determine the moment of desync (the numbers do not go sequentially) and generate a request for re-sending the lost changes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The proposed communication paradigm can be used not only to build the next generation computing system, but also to improve the existing network. The synchronism and high quality of service of the created virtual communication channels will optimally solve all the problems of transmission, voice, video (without fading). For real-time systems or high-reliability systems, among other things, the ability to create many alternative routes, tight control over the time of creating the channel and data delivery are very useful. Packet switching can be transparently emulated by a new paradigm, packet transmission is just a temporary channel creation, data transfer and closure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reverse emulation of a new network by packet switching is not possible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope you enjoyed the article on the communications system. If during the reading process errors were found and no docking, please indicate them. I hope that this text will serve as the basis for new projects and startups that will be bought out by large organizations. If there is a desire to implement such a system as an HDL model in communities such as OpenCores.org, I will be very happy (do not forget to point to the source). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following articles will describe other aspects (parts) of the computational paradigm. An article is planned on the mechanical principles of designing an ‚Äúavatar‚Äù.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The described algorithm for constructing a communication system can become part of a large whole, or even an international standard (I really hope). </font><font style="vertical-align: inherit;">If you have questions, I‚Äôm always ready to answer, advise and check "for compliance with the general line of the party" with a specific physical implementation.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491620/index.html">What makes Cypress great for automation beginners?</a></li>
<li><a href="../en491622/index.html">Predict financial crises with Python</a></li>
<li><a href="../en491624/index.html">Creating an Outline Effect in Unity Universal Render Pipeline</a></li>
<li><a href="../en491628/index.html">Spelunky as an example of good game design</a></li>
<li><a href="../en491630/index.html">Firefox Browser Extensions App (WebExtensions)</a></li>
<li><a href="../en491634/index.html">Protecting and Hacking the Xbox 360 (Part 1)</a></li>
<li><a href="../en491636/index.html">GRASP Templates: Information Expert</a></li>
<li><a href="../en491638/index.html">Cloud 1C. Everything is cloudless</a></li>
<li><a href="../en491640/index.html">Will Big Data Keep Their Promises?</a></li>
<li><a href="../en491642/index.html">How we make videos at Alconost and how the client participates in this</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>