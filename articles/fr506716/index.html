<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘 🛢️ 👩🏼‍⚖️ Liste linéaire multithread: problème d'existence d'élément, amélioration de la productivité et relation STL 💝 👨🏻‍🚀 🏂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers visiteurs de Habr! 
 
 Cet article se concentrera sur une liste liée, le multithreading et C ++. Je note tout de suite qu'il y avait to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Liste linéaire multithread: problème d'existence d'élément, amélioration de la productivité et relation STL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, chers visiteurs de Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article se concentrera sur une liste liée, le multithreading et C ++. Je note tout de suite qu'il y avait toutes les chances de mettre ce travail sur l'étagère et de l'utiliser dans un petit nombre de projets personnels. Au lieu de cela, j'ai quand même décidé de le mettre sur le court du public - tout d'un coup, cela semble vraiment utile ou intéressant pour quelqu'un. De plus, s'il s'avère que quelqu'un a déjà réussi à faire quelque chose comme ça, veuillez me l'indiquer, s'il vous plaît. Cependant, peu importe comment j'ai essayé de google sur ce sujet, toutes les tentatives ont échoué.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je note également qu'il ne s'agira pas de la liste chaînée classique, mais de ma réflexion créative sur l'utilisation de cette structure de données dans un environnement multithread. J'envisageais un scénario d'accès intensif à une liste multithread non ordonné. Cela signifie que n'importe quel thread à tout moment, indépendamment des autres, peut accéder à la liste et effectuer les opérations requises. S'il ajoute ou modifie uniquement des éléments, ce n'est pas si mal. S'il supprime également les éléments, diverses caractéristiques intéressantes peuvent apparaître.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce projet, dans lequel je me suis engagé comme passe-temps et développement personnel, a duré très longtemps pour plusieurs raisons. </font><font style="vertical-align: inherit;">De plus, pendant que j'y travaillais, j'ai étudié intensivement: le projet a commencé sans la connaissance et la compréhension de STL et a été conçu en conséquence, en utilisant uniquement les moyens internes du langage C ++ lui-même. </font><font style="vertical-align: inherit;">Cependant, je l'ai très sérieusement modifié en prenant en compte STL et même sous STL. </font><font style="vertical-align: inherit;">Ce que j'ai retiré de cela, jugez-vous, chers lecteurs.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une compréhension la plus complète du matériel décrit ici, vous devrez lire les livres suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - «Design moderne en C ++».</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - «Windows via C / C ++, programmation Visual C ++».</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - «Bibliothèque standard C ++. </font><font style="vertical-align: inherit;">Guide de référence. </font><font style="vertical-align: inherit;">Second Edition ”ou un livre similaire sur STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste des lignes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une liste linéaire est une structure de données bien connue qui a été utilisée depuis l'époque du langage C et plus tôt. Son élément est un certain objet en mémoire qui a des connexions avec un ou deux éléments similaires voisins - voici un exemple de liste doublement liée:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;…   …&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, la liste elle-même est un certain (sous) programme qui effectue des manipulations avec ces éléments. </font><font style="vertical-align: inherit;">En règle générale, un pointeur vers le début et, éventuellement, vers la fin de la liste est connu: cela suffit pour, à partir du premier élément, parcourir tous ses éléments jusqu'à la fin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, je décris des informations déjà bien étudiées et bien connues: c'était un programme éducatif pour ceux qui étaient complètement ignorants. </font><font style="vertical-align: inherit;">Pour plus de détails, par exemple, vous pouvez contacter ici: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste linéaire (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La bibliothèque STL a un merveilleux conteneur std :: list (liste doublement liée), ainsi que son twin - std :: forward_list (liste liée individuellement). </font><font style="vertical-align: inherit;">Autrement dit, si vous n'êtes pas intéressé par la façon dont la liste est organisée et fonctionne à l'intérieur, et que vous souhaitez simplement l'utiliser pour vos tâches, les conteneurs proposés sont votre option.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a une chose mais ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problèmes de multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je répète que lorsque j'ai commencé à analyser ce sujet, j'allais tout faire, en ne comptant que sur les outils internes C ++ sans support STL. </font><font style="vertical-align: inherit;">La valeur de ce qui se passerait serait plus faible si je décidais quand même d'en parler ici. </font><font style="vertical-align: inherit;">Mais d'un autre côté, j'étais complètement libre de tout concept ou limitation de la bibliothèque, et donc je n'étais lié par rien et recherchais des approches avec un esprit ouvert et indépendant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, dans un passé lointain et lointain, la grande majorité des ordinateurs étaient à cœur unique et à processeur unique. La liste linéaire était une structure de données relativement simple et transparente, et travailler avec elle n'a pas posé de difficultés particulières. Désormais, même les smartphones sont devenus multicœurs. Dans des conditions de multithreading, même une structure aussi simple qu'une liste chaînée est sérieusement compliquée. Assurer le bon fonctionnement en mode multi-thread complique généralement sérieusement n'importe quel programme, c'est un fait connu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenez un scénario abstrait de travail intensif avec une liste de différents threads: chacun d'eux peut ajouter, supprimer, modifier des éléments, etc. à un moment complètement arbitraire. D'une part, le travail avec la liste dans ce cas doit être principalement sûr: s'il y a des violations de données et un comportement indéfini du programme, ce sera une solution complètement inappropriée. Par contre, j'aimerais beaucoup travailler avec lui le plus rapidement possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre le premier problème, la liste devra évidemment être bloquée d'une manière ou d'une autre, ainsi que synchroniser l'accès à celle-ci. Le deuxième problème - les performances - est différé pour l'instant.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article ne considère que le blocage de la liste entière par un flux pour un accès exclusif à ce flux. D'autres options semblaient douteuses, par exemple, pour les raisons suivantes. Supposons que nous ayons une liste doublement liée et que nous ayons décidé d'en supprimer l'élément. Pour ce faire, vous devez bloquer le nœud lui-même, ainsi que le précédent et le suivant. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce moment précis, avant le début de l'opération, un autre thread supprime uniquement, par exemple, le nœud précédent. Nous bloquons celui qui a été supprimé et arrêtons d'attendre la libération du nœud précédent bloqué par un autre thread. Et il est bloqué en attendant le prochain pour lui, c'est-à-dire notre nœud supprimé. C'est ça, c'est une impasse. Cette méthode n'est donc pas fiable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vos threads ne stockent aucun pointeur (ou itérateur) vers des nœuds spécifiques, la tâche est extrêmement simplifiée. En fait, vous ne pouvez le faire qu'avec des outils STL. Le flux bloque la liste, fait référence à n'importe quel élément de celle-ci (par exemple, depuis le début, depuis la fin ou en la recherchant selon certains critères), traite ou supprime cet élément, en ajoute de nouveaux sans enregistrer de liens vers eux, puis complète la liste. Tout cela - bloquer exclusivement l'accès à la liste dans un seul thread, le posséder pendant la durée des opérations requises. Dans ce cas, il est parfaitement logique d'utiliser les fonctions de verrouillage de std :: list et de bibliothèque. Pour tout cela, il convient de noter que tandis que votre thread fait tout le travail requis, d'autres threads cesseront d'attendre, c'est-à-dire le travail avec la liste sera effectué en mode monothread.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai considéré un autre scénario, plus complexe, lorsqu'un thread stocke un pointeur ou un itérateur sur l'élément dont il a besoin. </font><font style="vertical-align: inherit;">Par exemple, votre programme travaille sur certains calculs complexes, en prenant les données initiales de l'élément de liste, puis, après traitement, met à jour sa valeur, en y ajoutant les résultats des calculs. </font><font style="vertical-align: inherit;">Cependant, d'autres threads ont également accès à la même liste. </font><font style="vertical-align: inherit;">Je n'ai fait aucune hypothèse sur la nature de l'application: un autre thread peut facilement supprimer cet élément pour une raison quelconque. </font><font style="vertical-align: inherit;">Ou déplacez-le vers un autre endroit. </font><font style="vertical-align: inherit;">Ainsi, travailler avec une liste devient problématique non seulement pour les raisons habituelles de multithreading et de synchronisation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le problème de l'existence d'un élément</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la différence fondamentale entre une liste et, disons, un tableau? Dans un </font><font style="vertical-align: inherit;">arrangement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distribué</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d'éléments de liste. Tous les éléments du tableau sont situés dans une seule zone de mémoire. Même si vous stockez un pointeur sur certains de ses éléments, vous êtes sûr que l'accès à son adresse sera correct (bien sûr, si le tableau n'a pas été déplacé en mémoire vers un autre emplacement avec une extension de sa taille, par exemple). Si l'élément dont vous avez besoin est supprimé ou déplacé vers un autre fil, vous allez simplement à l'adresse précédente, vous comprendrez par certains signes que l'élément dont vous avez besoin n'est pas ici, puis essayez de le rechercher, etc. Bien sûr, le programme doit soutenir une telle opportunité à l'avance. Mais, dans tous les cas, son fonctionnement restera correct tant que vous êtes dans les limites de mémoire correctes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une situation complètement différente est dans le cas d'une liste (ainsi que dans le cas d'un arbre, d'un graphe - toute structure de données avec des éléments distribués). Si un élément en fonction de votre pointeur a été supprimé dans un autre fil, vous ne le savez même pas et si vous essayez d'accéder à son adresse, vous recevrez une violation d'accès (au mieux). Même s'il n'est pas réellement supprimé de la mémoire (par exemple, si des pointeurs intelligents sont utilisés), il sera supprimé de la liste, c'est-à-dire n'en fera pas partie. Vous ne le saurez pas non plus. Le travail correct avec la liste est interrompu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le même temps, un travail intensif multi-thread avec la liste crée des scénarios absolument fantastiques. Vous pouvez même être sûr que tout va bien avec votre élément et un pointeur vers celui-ci - jusqu'à accéder à une fonction de liste pour travailler avec lui.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemple. Soit une partie de la liste, et un pointeur vers le nœud, que nous désignons par (#), est passé à une méthode de liste de fonctions, tandis que les nœuds qui lui sont associés seront désignés par des nombres relatifs par rapport à lui. Au moment où la fonction est appelée, il est connu que cet élément existe et que le pointeur vers celui-ci est correct, c'est-à-dire que l'état de la liste dans cette zone est: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, laissez le nœud (#) être passé en paramètre à une fonction de liste. Cette fonction, comme d'habitude, est bloquée en attendant d'y accéder. Pendant qu'elle attendait, trois threads ont travaillé avant elle, supprimant le nœud (#) avec les adjacents pour que cela se produise: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, 5 autres threads ont inséré 5 autres éléments dans la liste, en commençant par (-2). Nous désignons les nouveaux éléments par (nN), où N est le nombre relatif parmi les cinq, à partir de zéro:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, notre flux est appelé, qui a été appelé avec (#). La question est: que doit-il faire dans ce cas, après tout (#) a disparu depuis longtemps? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réponse: tout dépend de l'opération, ainsi que du scénario d'utilisation de la liste. Cependant, étant donné que nous considérons le cas le plus général sans aucune restriction, certaines hypothèses générales peuvent être faites.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il s'agit d'une opération de suppression, il suffit de simplement vérifier si l'élément spécifié est présent dans la liste. Sinon, il a déjà été supprimé et rien d'autre ne doit être fait. Si oui, supprimez. De même, pour l'opération de lecture / modification du contenu du nœud: si le nœud est supprimé, alors il n'y a déjà rien à lire / modifier. Mais les plus gros problèmes surviennent avec les opérations d'insertion d'un nouveau nœud, ainsi que lors du passage au suivant / précédent. D'une part, le nœud spécifié n'est plus là et une panne peut être renvoyée. D'un autre côté, le nœud doit être inséré, et une telle situation peut se produire à tout moment.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque la priorité (pour le cas général) est toujours la sécurité et la fiabilité, et seulement ensuite la vitesse, alors, évidemment, lorsque le thread a finalement obtenu le temps de fonctionnement à l'intérieur de la fonction, vous devez établir le fait de la présence d'un élément dans la liste: existe-t-il même là ou pas déjà? Cela résout un problème: au moins, nous ne perturberons pas la liste entière s'il n'y a pas de nœud demandé et nous éviterons les erreurs d'accès à la mémoire à cet égard. Mais cela ne résout pas le problème de l'insertion et des transitions: il n'est pas clair où insérer un nouveau nœud et passer d'un nœud déjà supprimé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution au problème de l'existence de l'élément sera discutée en détail ci-dessous. </font><font style="vertical-align: inherit;">La question de savoir quoi faire lorsque nous constatons que l'élément n'est plus là, mais qu'il est vraiment nécessaire, dépasse le cadre de cet article, car il dépend entièrement de l'algorithme du travail utilisant le programme de liste. </font><font style="vertical-align: inherit;">Bien sûr, il doit inclure de tels scénarios et les réactions correspondantes à ceux-ci: par exemple, s'il n'y a aucun élément, alors allez en haut de la liste ou effectuez une autre opération. </font><font style="vertical-align: inherit;">La principale chose qui doit être assurée dans cette situation est le fonctionnement correct et sûr de la liste, ainsi que la notification de ces situations.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche directe d'articles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche la plus simple et la plus directe consiste à vérifier la présence d'un élément dans la liste en le parcourant séquentiellement à la recherche d'un élément donné. Ceux. juste à la recherche de l'élément donné. S'il est sur la liste, nous travaillons avec lui. Si ce n'est pas le cas, selon la fonction, nous quittons avec succès ou échec, et laissons le programme appelant décider quoi faire dans cette situation. L'essentiel est que le travail avec la liste soit en tout cas correct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette méthode est sûre et entièrement fonctionnelle, mais, surtout pour les grandes listes, elle entraîne une baisse catastrophique des performances. En fait, travailler avec une liste s'avère être monothread: la liste est bloquée pendant la durée de recherche d'un élément donné, et les autres threads ne peuvent pas y accéder. Deuxièmement, les frais généraux augmentent fortement - dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les opérations avec la liste doivent vérifier si un élément est nécessaire au moment de l'opération, et une grande partie du temps n'est pas consacrée à un travail utile, mais à la vérification de la présence d'un élément. </font><font style="vertical-align: inherit;">Néanmoins, cette approche simple et directe convient tout à fait aux listes de petits volumes et aux opérations pas trop intensives avec elle, ainsi qu'à une première approximation pour résoudre le problème de l'existence d'un élément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que se passe-t-il si nous avons une liste avec un grand nombre d'éléments, et que travailler avec elle est très intensif: de nombreux threads en ajoutent, modifient et suppriment constamment des éléments? </font><font style="vertical-align: inherit;">Existe-t-il un moyen de l'accélérer d'une manière ou d'une autre?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mémoire ou performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est bien connu qu'une augmentation de la mémoire utilisée par le programme peut augmenter la vitesse du programme. Par exemple, un programme fait un usage intensif des résultats de certains calculs. Au lieu de les exécuter à nouveau, vous pouvez tout calculer à l'avance et enregistrer leurs résultats dans une table ou un tableau. Ensuite, le programme accède simplement à la cellule souhaitée dans le tableau et reçoit immédiatement la valeur souhaitée, ce qui accélère considérablement son travail.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est cette approche que j'ai utilisée dans le cas de la liste. Créez un bitmap. Ajoutez aux informations de service de chacun de ses éléments, en plus du pointeur requis vers l'élément suivant et, éventuellement, l'élément précédent, deux autres nouveaux champs: le premier est son numéro unique dans cette liste, et le second est un pointeur vers la liste elle-même. Désormais, lorsqu'un élément est créé, un numéro unique lui est attribué et définit l'unité dans le bitmap à l'index correspondant. Lorsqu'un élément est supprimé, ce bit est réinitialisé. Le nombre de l'élément créé augmente constamment chaque fois qu'un nouvel élément est créé - les bits mis à zéro déjà utilisés ne sont pas réutilisés.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, lorsqu'il est nécessaire de vérifier la présence d'un élément donné, au lieu de le rechercher linéairement dans la liste entière, un bitmap est simplement accessible par l'index de cet élément en lui, et le fait de sa présence est immédiatement établi, et pour un temps constant, quelle que soit la taille de la liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette méthode vous permet d'obtenir des performances maximales, mais elle a ses graves inconvénients. Tout d'abord, vous devrez allouer de la mémoire à l'ensemble du tableau à la fois, dont une partie des bits peut ne pas être nécessaire du tout pendant le programme, mais cette mémoire peut être utilisée pour d'autres besoins. Ce problème et un moyen de lisser les dépassements de mémoire seront discutés ci-dessous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième inconvénient est plus grave et intéressant - chaque nouvel élément de liste est créé par un nombre croissant de façon monotone. Cela signifie que tôt ou tard les bits libres de la matrice seront épuisés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce stade, malheureusement, vous devez vous arrêter, bloquer la liste et commencer à la servir. Ceux. compresser les bits de ce tableau, en supprimant tous les bits zéro des éléments de liste intermédiaires précédemment supprimés, en ne laissant que des bits pour les éléments qui existent réellement à l'heure actuelle, en déplaçant tous ces bits au début du tableau. Nous devrons parcourir à nouveau la liste entière, et en mode simple thread, réécrire tous les indices pour chaque élément. L'avantage évident de cela par rapport à l'approche précédente est que dans ce cas, </font><b><font style="vertical-align: inherit;">un</font></b><font style="vertical-align: inherit;"> seul sera fait.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois sur une longue période de temps. </font><font style="vertical-align: inherit;">De plus, la liste peut continuer à fonctionner comme auparavant en mode extrêmement rapide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, je ne veux pas dire que les nœuds ont seulement été ajoutés à la liste, car </font><font style="vertical-align: inherit;">dans ce cas, tous les bits du tableau seront simples. </font><font style="vertical-align: inherit;">J'envisage un scénario où les éléments sont supprimés et ajoutés de manière intensive et arbitraire. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">le nombre total d'éléments de liste depuis le début de son travail peut légèrement changer. </font><font style="vertical-align: inherit;">Naturellement, la question du choix de la taille du tableau dépend de la nature du programme. </font><font style="vertical-align: inherit;">Vous pouvez également toujours créer un nouveau tableau d'un volume plus important si la taille du volume actuel n'est pas suffisante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de zéro bit à partir d'éléments précédemment supprimés</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez faire autre chose: lors de la création d'un élément, recherchez le premier bit zéro depuis le début du bitmap. Cela optimise la consommation de mémoire, mais entraînera une baisse des performances: à nouveau chaque fois que vous créez un nouvel élément, vous devrez effectuer un travail supplémentaire - parcourez le tableau à la recherche d'un bit gratuit. Mais par rapport à la vérification de la présence d'un élément en visualisant directement la liste, le gain est évident: on va regarder le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">éléments adjacents, et chaque élément d'un tel tableau contient de nombreux bits, c'est-à-dire </font><font style="vertical-align: inherit;">nous traitons plusieurs nœuds de liste à la fois (64 bits pour les systèmes modernes ou même 128/256/512 si vous utilisez SSE / AVX). </font><font style="vertical-align: inherit;">Nous recherchons le premier mot qui n'est pas égal au mot avec tous les bits unitaires, puis nous recherchons le premier bit zéro dans ce mot. </font><font style="vertical-align: inherit;">En fait, cette méthode est intermédiaire en vitesse entre la précédente et la méthode de visualisation directe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisation de la consommation de mémoire pour les bits de tableau inoccupés</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous supposions un travail long et intensif avec la liste, en lui allouant un énorme tableau de bits. Mais il se trouve que le programme fonctionne en fait différemment: il accède rarement à la liste, effectue d'autres opérations qui nécessitent également de la mémoire. En conséquence, nous obtenons un tableau presque inutilisé de bits d'énormes problèmes de volume et de mémoire dans d'autres parties du programme. Un simple inconvénient! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux, pour autant que je sache, résout automatiquement ce problème (bien que les développeurs Linux expérimentés me laissent le résoudre, si cela). Vous allouez de la mémoire à la baie, mais en fait, le système </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne transfère pas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette mémoire à la baie </font><font style="vertical-align: inherit;">tant qu'elle n'est pas vraiment nécessaire. Il existe une optimisation de l'utilisation de la mémoire. Windows ne le permet pas. Au contraire, cela le permet, mais vous devez le faire vous-même.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui ne sont pas du tout à jour, je vais vous expliquer: votre application (plus précisément, le processus qui lui correspond), le système alloue un </font><font style="vertical-align: inherit;">grand </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espace d'adressage virtuel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jusqu'à 8 To pour Windows 64 bits. La mémoire physique du système peut être bien inférieure - 8 ou 16 Go pour le moment pour les ordinateurs de masse. </font><b><font style="vertical-align: inherit;">Affichages du</font></b><font style="vertical-align: inherit;"> système d'exploitation</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des adresses de votre espace de processus virtuel aux adresses de mémoire physique, en le faisant de manière transparente sans votre implication directe. Naturellement, la plupart de la mémoire virtuelle libre d'un processus est généralement inoccupée. Ainsi, lorsque vous demandez à Windows d'allouer de la mémoire par des moyens conventionnels, il alloue simultanément cette mémoire à la fois dans votre espace virtuel et dans la mémoire physique. Si vous allouez un bitmap de grand volume, vous courez le risque d'occuper immédiatement toute la mémoire disponible sur votre ordinateur sans garantir que cette mémoire puisse être nécessaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, on peut agir différemment: baliser une énorme partie de la mémoire dans l'espace virtuel du processus, mais y transférer du physique uniquement lorsque cela est vraiment nécessaire. </font><font style="vertical-align: inherit;">Cela peut être fait via la gestion des exceptions structurelles dans Windows; pour plus de détails, veuillez vous référer au livre de Richter D., Nazar K. - «Windows via C / C ++, Visual C ++ Programming».</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la mise en oeuvre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce ne serait qu'une idée et une théorie, si je n'avais pas mis toutes ces idées en pratique, et non sous la forme d'un simple programme expérimental: je l'ai fait le plus soigneusement possible pour la production, avec l'intention de l'utiliser dans mes projets réels, donc c'est sous cette forme que vous en avez besoin et imaginez. </font><font style="vertical-align: inherit;">J'ai pensé qu'il serait injuste et trop égoïste d'appliquer ce qui a été fait dans mon nombre limité de projets si cela pouvait être utile ou tout au moins intéressant pour un large cercle de développeurs. </font><font style="vertical-align: inherit;">D'un autre côté, les créateurs de la bibliothèque Boost et d'autres bibliothèques plus spécialisées offrent leur travail à tout le monde gratuitement. </font><font style="vertical-align: inherit;">Pourquoi ne puis-je pas faire de même?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraction - une liste sans données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai divisé la liste en deux niveaux logiques. Le premier niveau est une liste, dont chaque élément ne contient pas de données utiles, mais ne contient que des informations auxiliaires: des pointeurs vers des éléments voisins et, éventuellement, ces deux champs supplémentaires pour accélérer la vérification de la présence d'un élément dans la liste. Cependant, déjà à ce niveau, il est possible d'effectuer toutes les opérations de base sur une liste: ajout et suppression d'éléments, fractionnement et fusion de listes, etc. En fait, je me suis concentré principalement sur ce niveau. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième niveau consiste à ajouter des données réelles à l'élément de liste, ainsi qu'à ajouter de nouvelles opérations à la liste pour travailler avec ces données. Tout cela est fourni en C ++ par héritage. Mais les détails seront discutés ci-dessous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une telle décomposition de l'implémentation en deux niveaux était logique: pourquoi prendre en compte la disponibilité de données spécifiques si un certain nombre d'opérations sont totalement indépendantes de ces données? Pour tout élément de liste donné, vous devez toujours les supprimer et en ajouter de nouveaux à la liste, ainsi que réaliser d'autres opérations typiques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai commencé avec un concept extrêmement simple et simple, tiré de la construction du langage C au début de l'article. Les pointeurs internes C et C ++ sont utilisés à la fois à l'intérieur et à l'extérieur de la liste. La seule différence est que l'ajout de données, comme indiqué ci-dessus, a été reporté à une date ultérieure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit un élément de la liste sans données, contenant uniquement un pointeur (ou des pointeurs) vers le ou les éléments voisins. Le code correspondant peut alors être schématiquement représenté comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;…m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un élément pour une liste liée individuellement contient en lui-même un pointeur sur l'élément suivant, et rien de plus. La classe de liste est paramétrée par le type de cet élément, ce qui implique que ce type sera modifié au stade de l'ajout de données. Il contient des pointeurs vers le premier et le dernier élément à l'intérieur. Puisque j'ai initialement ciblé ce projet pour Windows uniquement, une section critique comme SRWLock est également incluse pour bloquer la liste. Ensuite, les constructeurs, le destructeur, ainsi que toutes les fonctions nécessaires pour travailler avec la liste sont définis. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette implémentation contient deux problèmes à la fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier est l'accès libre au contenu des informations de service de l'élément. Cela signifie que, après avoir accédé à un nœud, c'est-à-dire ayant un pointeur sur ce nœud, on peut se référer directement à l'élément suivant ou précédent.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est inacceptable principalement parce que cette transition contourne le verrou et protège donc la liste. En fait, supposons qu'en ayant un pointeur sur un élément pCurr, nous avons enregistré la valeur de l'élément suivant par rapport à lui dans le pointeur pNext comme suit: pNext = pCurr-&gt; pNext. Après cela, nous effectuons une opération longue sur ce nœud pCurr. Dans le même temps, d'autres threads ont supprimé les éléments de liste suivants concernant pCurr. Ayant terminé de travailler avec pCurr, le thread en cours passe à l'élément suivant en utilisant l'ancienne valeur stockée dans le pNext local et reçoit une erreur d'accès ou un comportement non défini, car l'élément à l'adresse pNext locale n'existe plus et vous devez accéder à la valeur mise à jour pCurr-&gt; pNext, si l'élément actuel à pCurr, à son tour,existe également toujours.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux conclusions peuvent être tirées de cet exemple pour éviter cette situation:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depuis l'extérieur de la liste, allez au nœud suivant / précédent et travaillez généralement avec les éléments de la liste uniquement via les fonctions (méthodes) de la classe list qui verrouillent la liste et sécurisent l'accès à la liste;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accéder aux éléments dès que possible immédiatement avant d'y accéder (par exemple, obtenir un pointeur vers l'élément suivant pNext = list.GetNext (pCurr) pas à l'avance, mais immédiatement avant que la nécessité de passer au nœud suivant n'apparaisse).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est pourquoi, pour mettre en œuvre la conclusion du premier paragraphe, l'accès aux pointeurs vers des éléments adjacents de l'extérieur doit être interdit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième problème est un peu plus délicat. Pour le comprendre, la structure des classes doit être décrite plus en détail. La classe de liste est définie en tant que modèle et ne fonctionne pas avec les éléments du type ListElement_OneLinked, mais avec le type ListElement, transmis en tant que paramètre de modèle. Ceci est fait afin de pouvoir créer de nouveaux nœuds avec des données à l'intérieur de la classe. Pour ce faire, vous devez connaître le type exact de nœud en cours de création. Le type exact du nœud de liste n'est pas encore connu: il sera déterminé ultérieurement avec les données. La fonction de création d'élément lui alloue de la mémoire, initialise des pointeurs, puis renvoie un pointeur sur l'élément créé dans la fonction appelante. Ainsi, dans la fonction appelante de la classe dérivée, il sera possible d'initialiser d'autres propriétés de l'élément spécifiques à cette classe et définies ultérieurement. En d'autres termes,une définition exacte du type du nœud de liste est laissée pour l'avenir, et pour que la liste fonctionne correctement, il est seulement important que ses éléments contiennent le pointeur pNext, le reste n'a pas d'importance jusqu'à présent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, en fonction de ListElement_OneLinked, par héritage par la suite, une nouvelle classe sera créée pour l'élément avec des données spécifiques et transmise à la classe List_OneLinked via le paramètre de modèle. Dans le même temps, une nouvelle classe dérivée sera créée sur la base de List_OneLinked qui définit davantage les opérations avec ces nouvelles données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, même cette option n'est pas entièrement correcte. Dans les versions antérieures de la classe list, une opération de conversion explicite du type reinterpret_cast &lt;ListElement *&gt; (...) était utilisée plusieurs fois. Le fait est que la classe de modèle fonctionne avec le type de paramètre de modèle ListElement, qui est dérivé de ListElement_OneLinked / ListElement_TwoLinked. Et dans les fonctions de classe, les variables sont créées dans des expressions de type: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pCurr-&gt; pNext est ici un pointeur vers ListElement_OneLinked / ListElement_TwoLinked, en tant que membres des classes de base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sortie: déclarez une variable indiquant le type de base explicite ListElement_OneLinked / ListElement_TwoLinked ou convertissez-la explicitement en type dérivé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, même une définition explicite du type de base n'est pas correcte, par exemple, dans la fonction de suppression de liste (nettoyage):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous modifiez le type de pointeurs:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cela signifie qu'ils seront supprimés par l'opération</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
seules les parties de base de chaque nœud de la liste, ce qui est faux. </font><font style="vertical-align: inherit;">Ou, en option, le pointeur pCurr devra être converti en son type dérivé:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, dans tous les cas, on ne peut pas se débarrasser de la transformation explicite reinterpret_cast avec une telle structure de classe, ce qui n'est pas la meilleure solution (plus précisément, ce qui est vraiment mauvais). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cette raison, afin de se débarrasser de ces transformations explicites, il a été décidé de changer la classe de base de l'élément (pour une liste doublement liée - de même):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En bref, cela peut être décrit comme suit: l'élément de base de la liste contient un pointeur vers un autre élément, mais le type de ce pointeur n'est pas encore connu, car il est transmis par le paramètre de modèle (une définition exacte de ce type est laissée pour l'avenir). En d'autres termes: à ce stade, le type de nœud de liste (c'est-à-dire ce qu'il sera à la fin) n'a pas encore été déterminé, il le sera plus tard. Mais maintenant, nous gardons un pointeur sur un élément du type futur, pas encore connu. Le type résultant du nœud de liste est passé ici en tant que paramètre de modèle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Désormais, aucune conversion n'est nécessaire, car des pointeurs du même type ListElement sont utilisés partout - à la fois dans la classe de liste et dans la classe des nœuds. Le ListElement ici et dans la classe de liste est la classe finale pour l'élément avec des données spécifiques.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que maintenant la classe de liste est devenue aussi abstraite que possible de son contenu spécifique: on sait seulement que ses nœuds contiennent des pointeurs vers d'autres nœuds de ce type, et en utilisant ces informations, toutes les opérations de base sur eux avec le verrou multithread correspondant sont effectuées dans la classe de liste.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résoudre le problème de l'existence d'un élément - une recherche simple (version 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première version était extrêmement simple et directe et ne dépassait pas le cadre décrit ci-dessus. </font><font style="vertical-align: inherit;">Des pointeurs internes C ++ ont été utilisés, la mémoire pour les éléments a été allouée à l'aide de la nouvelle opération et supprimée à l'aide de la suppression, la liste a été bloquée sur la section critique qu'elle contient. </font><font style="vertical-align: inherit;">Je ne connaissais pas ou ne soupçonnais pas les moyens de la bibliothèque STL, ni le niveau auquel ils apportent la programmation en C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déjà à ce stade, dans la pratique, je suis tombé sur le problème de l'existence d'un élément décrit précédemment et j'ai réalisé que le simple verrouillage de la liste ne suffisait pas. </font><font style="vertical-align: inherit;">J'ai parcouru la liste en utilisant les fonctions appropriées avec toutes les précautions, la liste a été correctement bloquée, mais le programme a quand même réussi à planter à différents intervalles. </font><font style="vertical-align: inherit;">C'est alors que j'ai découvert que la présence d'un élément devait être vérifiée, ce qui a entraîné un changement dans la logique des fonctions clés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de donner un exemple de la fonction d'ajouter un élément après un élément donné:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit qu'avant de créer un nouvel élément, il vérifie si l'élément spécifié est présent dans la liste en appelant la fonction FindElement (...):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complication supplémentaire des classes de liste multithread - classes de stratégie (version 18.02.2019, 11.27.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, le projet visait strictement Windows. Mais à un moment donné, j'ai pensé, pourquoi ne pas y ajouter de la flexibilité? Pourquoi seulement des fenêtres? Après tout, la liste a été essentiellement implémentée en C ++ pur, à partir de Windows, elle n'avait qu'une seule chose: la section critique de SRWLock. À cette époque, je m'étais déjà familiarisé avec le concept de cours de stratégie. Vous pouvez lire à ce sujet en détail dans le livre Alexandrescu A. - "Design moderne en C ++". Il décrit de nombreuses choses inhabituelles et étonnantes qui peuvent être utiles même maintenant, malgré le fait que le livre a déjà 12 ans. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un d'eux est les classes de stratégies. Les classes de stratégies, en fait, sont des changements dans le comportement d'une classe à travers des modèles, comme B. Straustrup l'a mentionné dans son célèbre livre. Seulement dans le livre d'Alexandrescu, ce sujet est largement divulgué.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que votre classe effectue une action spécifique. </font><font style="vertical-align: inherit;">Vous pouvez prendre la définition de cette action en dehors de la classe, créer une classe distincte basée sur cette action et la transmettre à votre classe source en tant que paramètre de modèle. </font><font style="vertical-align: inherit;">Cela complique le code, sa lecture et sa compréhension, mais il ajoute considérablement de la flexibilité à votre classe: pour remplacer cette action particulière par une autre, similaire, il vous suffit d'écrire une autre stratégie similaire et de la transmettre à votre classe en tant que paramètre de modèle. </font><font style="vertical-align: inherit;">Le reste du travail sera effectué par le compilateur.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratégie de verrouillage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En appliquant cela à la liste décrite, j'ai pris le verrou via SRWLock dans une stratégie distincte, puis j'ai écrit plusieurs autres stratégies: via la section critique habituelle de Windows, via les mutex C ++ STL, etc. </font><font style="vertical-align: inherit;">Il sera alors possible d'ajouter des méthodes purement spécifiques à Linux. </font><font style="vertical-align: inherit;">Ainsi, la classe est devenue appropriée non seulement pour Windows, mais je peux toujours la reconfigurer très rapidement pour Windows de manière optimale, simplement en spécifiant la stratégie souhaitée.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratégie de mémoire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autour de ce point, j'ai également sérieusement commencé à étudier le STL et parmi les premiers outils de cette bibliothèque, j'ai fait la connaissance des pointeurs intelligents. </font><font style="vertical-align: inherit;">Et puis j'ai pensé: pourquoi ne puis-je pas ajouter la prise en charge du pointeur intelligent à ma liste? </font><font style="vertical-align: inherit;">Ensuite, j'ai retiré le type de pointeur, ainsi que la création et la suppression des données de l'élément de liste dans une stratégie distincte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une stratégie similaire pour les pointeurs intelligents:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La stratégie de mémoire prend trois paramètres: le type de l'objet Type, ainsi qu'un allocateur et un suppresseur de mémoire. En fonction du type de l'objet, la stratégie crée un type de pointeur vers ce type - Type * ou std :: shared_ptr, selon la stratégie, et propose également les fonctions correspondantes pour créer et supprimer l'objet. Ces fonctions, si nous parlons de distributeurs et de suppresseurs par défaut, créent un objet soit via la nouvelle opération Type, soit via la fonction std :: make_shared (...). Tout cela fonctionne du fait que le déréférencement du pointeur est le même pour le pointeur intégré C ++ et le smart std :: shared_ptr. Bien sûr, dans le cas d'une liste doublement liée et de pointeurs intelligents, pour éviter la caractéristique désagréable des pointeurs en boucle, std :: faible_ptr est utilisé pour les pointeurs vers l'élément précédent,et au moment de la compilation pour une liste doublement liée, selon la stratégie de mémoire sélectionnée, vous choisissez comment la déréférencer (il s'agit d'une nouvelle fonctionnalité de C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, maintenant la liste ne crée pas ses propres éléments: elle redirige l'appel vers la stratégie correspondante.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratégie de disponibilité des articles</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, j'ai mis la solution au problème de l'existence de l'élément dans une stratégie distincte: si la liste doit vérifier la présence de certains de ses éléments, elle redirige simplement l'appel vers la stratégie correspondante. La toute première approche, simple et maladroite, est devenue une stratégie de recherche directe DirectSearch. Ensuite, j'ai développé deux autres stratégies basées sur les deux approches décrites précédemment avec un bitmap dans l'ordre de leur description: SearchByIndex_BitArray et SearchByIndex_BitArray2. Pour Windows, pour la possibilité d'occuper progressivement la mémoire avec une image bitmap au fur et à mesure qu'elle se remplit, il a également ajouté deux autres stratégies: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal et SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme indiqué précédemment, pour que ces stratégies avancées fonctionnent, l'élément de liste doit contenir un index dans le bitmap et un pointeur vers la classe de base de la liste (voir ci-dessous), c'est-à-dire </font><font style="vertical-align: inherit;">a été défini comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrélation entre les stratégies de mémoire et les stratégies de vérification des éléments</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après un examen détaillé, il s'est avéré qu'il existe un piège dans la relation entre les stratégies de mémoire et les stratégies de vérification de la présence d'un élément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que vous utilisez des pointeurs intelligents comme stratégie de mémoire, ainsi qu'une stratégie utilisant un bitmap pour rechercher rapidement un élément dans une liste. Vous supprimez un élément, la stratégie de mémoire réinitialise son pointeur. Cependant, cet élément n'est pas réellement supprimé de la mémoire, car vous disposez d'un autre pointeur intelligent dans votre programme appelant. À l'avenir, vous vous tournerez vers la liste avec cet élément, et il effectuera la vérification correctement, en se référant à ses données - l'index dans le bitmap et le pointeur vers la liste. Un élément n'est réellement supprimé de la mémoire que lorsqu'il n'y a plus de lien vers celui-ci.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas le cas lors de l'utilisation de pointeurs intégrés C ++. Dans ce cas, la stratégie de mémoire </font><font style="vertical-align: inherit;">supprimera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réellement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cet élément de la mémoire à l'aide de l'opération de suppression. À l'avenir, vous, comme dans le cas précédent, vous référerez à la liste avec cet élément, et il essaiera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'accéder à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'élément à cette adresse afin de lire l'index du bitmap et un pointeur vers la liste. Mais vous ne pouvez pas faire cela: un élément a déjà été supprimé de la mémoire! Dans le meilleur des cas, vous recevrez une violation d'accès, dans le pire des cas, un comportement non défini lorsque la bibliothèque C ++, la bibliothèque d'exécution ou simplement le système d'exploitation y écrit une valeur complètement arbitraire que la liste considère et essaie d'établir à partir d'eux le fait de la présence d'un élément dans la liste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, il s'avère que les pointeurs internes ne sont compatibles qu'avec la stratégie de vérification directe DirectSearch, et les pointeurs intelligents dans ce cas offrent non seulement leur sécurité inhérente, mais également une augmentation des performances: ce n'est qu'avec leur utilisation que des tableaux de bits peuvent être utilisés qui augmentent considérablement le travail de la liste dans mode multithread! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour garantir la cohérence et éliminer les configurations de stratégie incompatibles, j'ai inclus la vérification suivante dans chaque classe de liste:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il compare les classes de stratégie passées à la liste et, si elles sont incompatibles, arrête la compilation avec la sortie de message d'erreur correspondante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions ou retours d'erreur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, la gestion des erreurs de liste a été effectuée uniquement par le biais d'exceptions. </font><font style="vertical-align: inherit;">Mais d'une manière ou d'une autre, sur un forum dont je ne me souviens pas, j'ai lu que les exceptions ralentissaient le programme, et pour des performances maximales, vous devriez utiliser le retour d'erreur traditionnel. </font><font style="vertical-align: inherit;">Il l'a fait en créant deux nouvelles classes basées sur les classes originales, en les réécrivant uniquement pour renvoyer des erreurs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste de classe de base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mise en œuvre des stratégies ci-dessus pour vérifier la présence d'éléments a révélé un problème important. L'élément de liste, comme nous nous en souvenons, contient, en plus du numéro unique dans cette liste, également un pointeur vers cette liste: après tout, nous pouvons avoir deux ou plusieurs listes dans le programme, chacune contenant son propre tableau de bits de drapeaux pour la présence de l'élément. Comment s'assurer que cet élément appartient à cette liste particulière et non à une autre? Uniquement en stockant un pointeur sur la liste entière à l'intérieur de chaque élément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème est que maintenant, en ajoutant une variété de stratégies à notre classe de liste, nous avons considérablement compliqué son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Supposons que nous ayons deux listes différentes avec le même type d'élément et les mêmes stratégies de mémoire, mais avec des stratégies différentes pour verrouiller et vérifier la présence d'éléments en elles. Pour le compilateur, il s'agira de deux </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> listes différents. Pointeur vers quel type stocker dans l'élément? De plus, la classe de l'élément ne sait pas à l'avance quelle stratégie sera appliquée, elle doit les prendre en compte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelons également que la stratégie de blocage, la stratégie de vérification de la présence d'un élément, et même la connectivité (simplement connectée ou doublement connectée) de la liste se réfèrent uniquement au comportement de la liste elle-même, mais ne se rapportent en aucun cas aux </font><b><font style="vertical-align: inherit;">données</font></b><font style="vertical-align: inherit;"> qu'elle stocke</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais nous, en tant qu'utilisateurs finaux de cette classe, nous intéressons aux données! </font><font style="vertical-align: inherit;">Donc, d'une part, en utilisant les classes de stratégies, nous nous sommes ajoutés de la flexibilité, et d'autre part, nous avons compliqué notre vie et ajouté des problèmes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est-il possible de rendre les loups rassasiés et les moutons en sécurité? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pouvez. </font><font style="vertical-align: inherit;">Vous pouvez déduire des pointeurs vers des données d'une classe (c'est-à-dire d'un type) d'une liste. </font><font style="vertical-align: inherit;">En plus des deux niveaux d'organisation de la liste indiqués ci-dessus, un autre est apparu - zéro:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, parce que </font><font style="vertical-align: inherit;">de vraies classes de listes en sont héritées, si nous voulons accéder aux données de la liste quel que soit son type réel, nous devons nous référer à sa classe de base ListBase. </font><font style="vertical-align: inherit;">Nous avons accès au début et à la fin de la liste, puis travaillons avec ses données comme nous le souhaitons. </font><font style="vertical-align: inherit;">Le type spécifique de liste, ainsi que la combinaison de stratégies utilisées, n'a pas d'importance.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itérateurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déjà en plein essor en travaillant étroitement avec STL dans un vrai projet (pas le mien :)), tout en continuant à l'étudier dans les livres, j'ai attiré l'attention sur la boucle for de la collection. </font><font style="vertical-align: inherit;">Après tout, ce cycle ne fait pas seulement partie de la STL, il est déjà devenu une partie interne de la langue. </font><font style="vertical-align: inherit;">J'ai pensé que je pourrais également ajouter un support pour cela dans mon projet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, vous devez ajouter la prise en charge des itérateurs, en faisant abstraction de la manière spécifique de travailler avec des pointeurs et de parcourir la liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple d'itérateur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, il est devenu possible d'écrire comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(…)<font></font>
{<font></font>
      …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue a un type de pointeur sur un élément de liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, j'ai inclus la prise en charge des itérateurs uniquement sur les listes prises en charge par les exceptions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison était simple: puisque le code à l'intérieur de la boucle n'est pas disponible, il n'est pas possible de gérer correctement les erreurs. </font><font style="vertical-align: inherit;">Il ne reste plus qu'à gérer les exceptions en encapsulant la boucle dans un bloc try. </font><font style="vertical-align: inherit;">En général, parcourir la liste de cette manière lorsque d'autres threads travaillent intensivement avec elle n'est pas une bonne idée: il est préférable de bloquer la liste vous-même, puis de la parcourir calmement en mode monotrame. </font><font style="vertical-align: inherit;">Mais encore, si pour une raison quelconque vous voulez faire exactement la même chose que dans l'exemple ci-dessus, alors il y a maintenant une opportunité pour cela.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une généralisation de la stratégie de vérification de la présence d'un élément sur un conteneur arbitraire; </font><font style="vertical-align: inherit;">itérateurs pour les listes sans exception</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, j'avais initialement prévu (et je prévois toujours) de créer non seulement une liste multi-thread, mais aussi un arbre. Pour certains de leurs besoins. Le graphique est également possible, mais d'une part, je n'en avais pas besoin, et d'autre part, le graphique est une chose compliquée avec des algorithmes très non triviaux, et je ne voulais pas m'y plonger sans besoin particulier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la version initiale, la stratégie de vérification de la présence d'un élément n'était orientée que vers la liste, et ses fonctions acceptaient un pointeur vers un élément et un pointeur vers la classe de base de la liste (ListBase *). Par la suite, j'ai pensé: mais dans le cas d'un arbre, il faut faire exactement la même chose! Faites une stratégie distincte, mais essentiellement la même?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution était simple: ignorer la liste. </font><font style="vertical-align: inherit;">Cela signifiait que maintenant l'entrée serait reçue non pas par des pointeurs vers des éléments, mais par des itérateurs. </font><font style="vertical-align: inherit;">Et les fonctions deviendront passe-partout pour accepter des pointeurs vers un conteneur de tout type approprié. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors maintenant, la fonction d'origine, par exemple l'enregistrement d'une liste dans un bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transformé en une fonction d'enregistrement de conteneur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La transition à travers la liste par des pointeurs a été transformée en transition à travers un conteneur abstrait utilisant des itérateurs. </font><font style="vertical-align: inherit;">Maintenant, il suffira que l'arbre implémente ses itérateurs, et son soutien avec ces stratégies sera déjà fourni. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela a nécessité le retour des itérateurs dans les listes sans exception, mais en les rendant inaccessibles de l'extérieur et destinés uniquement à un usage interne.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptateur de données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant travaillé de manière assez intensive avec STL, ainsi qu'en tapant, en lançant et en étudiant des programmes de formation à partir de livres, j'ai attiré l'attention sur la simplicité de travailler avec des conteneurs STL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, faites attention au code suivant:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je crée un vecteur en lui passant le type dont j'ai besoin, et c'est tout! Le conteneur est immédiatement prêt à fonctionner, si je n'ai pas besoin de modifier certains paramètres supplémentaires définis par défaut, ce qui n'arrive le plus souvent pas! Pour moi, en partant de l'organisation à trois niveaux de la liste, dans chaque cas, je devrais d'abord créer une nouvelle classe pour l'élément, puis écrire une classe pour la liste avec des données, en mettant en œuvre des opérations spécifiques à la liste finale. Imaginez combien de travail! Et si vous avez besoin de créer une autre liste pour d'autres données, vous devez tout recommencer ou, dans les cas extrêmes, copier le code précédent, en le modifiant légèrement. Cela ressemble déjà au même problème avec le langage C et l'API Windows, où pour chaque action élémentaire, vous devez remplir toutes les données nécessaires pour la structure, puis appeler la fonction souhaitée. Et soit gardez tout cela à l'espritOu lisez également en permanence MSDN, en étudiant les arguments de chaque nouvelle fonction! Routine et terriblement inconfortable!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai commencé à chercher des moyens d'avoir l'opportunité de créer ma liste par analogie avec les conteneurs STL afin de ne pas avoir à faire la même tâche à chaque fois: créer une classe distincte pour tout nouvel élément, puis une classe distincte pour travailler avec des éléments de cette type. </font><font style="vertical-align: inherit;">Il y avait donc un adaptateur pour une liste de données. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un adaptateur pour une liste avec des données est une classe, dans les paramètres de modèle dont vous transmettez immédiatement le type de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données dont</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous avez besoin </font><font style="vertical-align: inherit;">, et non l'élément. </font><font style="vertical-align: inherit;">Le type d'élément, que j'ai appelé le type composite de l'élément, sur la base de ces données qu'il crée de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lui-même</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre point qui mérite d'être mentionné est l'accès aux données de l'article. </font><font style="vertical-align: inherit;">Le type d'élément contient l'opération "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que s'il y a un pointeur vers l'élément pElement, alors pour accéder aux données qui y sont stockées, il doit être déréférencé deux fois:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois - pour accéder à un objet de type ListElementCompound_OneLinked par son pointeur: ListElementCompound_OneLinked &amp; le = * pCurrElement, et une deuxième fois - pour accéder aux données via l'opération '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela semble très étrange et atypique, mais on suppose que vous ne travaillerez pas à l'aide de pointeurs (pour cela, vous disposiez déjà d'une version initiale prête à l'emploi), mais à travers des itérateurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, lorsque vous créez une liste basée sur l'adaptateur, vous spécifiez les stratégies dont vous avez besoin, comme c'était le cas auparavant. </font><font style="vertical-align: inherit;">En fonction de tous vos paramètres, l'adaptateur crée automatiquement les types nécessaires et les transmet à la liste interne de base, dont il est hérité. </font><font style="vertical-align: inherit;">Définition générale de la classe:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spécialisation pour la liste avec exceptions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il a l'air très volumineux, à plusieurs étages et laid. Je connais. Mais alors cette définition fait automatiquement tout ce qui est nécessaire, sans la participation directe du programmeur qui prévoit de l'utiliser. À l'aide de std :: conditional_t ​​et std :: is_same_v, la stratégie de vérification de la présence d'un élément que vous avez transmis est comparée aux stratégies de recherche directe et, selon le résultat, le type correspondant de l'élément de liste est sélectionné: avec un index dans le bitmap et un pointeur vers la liste ou sans . Cela vous fera économiser de la mémoire en raison de données supplémentaires inutiles à l'intérieur de chaque nœud si vous utilisez une stratégie de recherche directe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'intérieur de la classe, seuls les itérateurs qui lui sont spécifiques sont implémentés, ainsi que les fonctions push_back () / push_front () requises par analogie avec STL, qui redirigent les appels vers la liste multi-thread de base. </font><font style="vertical-align: inherit;">Vous pouvez ajouter d'autres fonctions plus tard, de sorte que la liste devienne très similaire aux STL. </font><font style="vertical-align: inherit;">Mais en même temps, ce sera avec toutes les protections et options nécessaires pour augmenter la productivité dans un environnement multi-thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Travailler avec un adaptateur de données a commencé à ressembler à ceci. </font><font style="vertical-align: inherit;">Création d'objets de liste:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous êtes satisfait de toutes les stratégies et paramètres par défaut, la création d'une liste devient très brève:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, extérieurement, il n'y a absolument aucune différence par rapport à STL, sauf que le nom de la classe de liste est différent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez maintenant travailler avec lui comme à l'ancienne, via les fonctions de la classe de base:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, les nombres de 0 à 3 sont ajoutés séquentiellement à la fin de la liste. Pour accéder à l'argument transmis au constructeur du type créé lors de sa création, vous devez explicitement noter les valeurs des trois premiers arguments.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, il y a un certain inconvénient à indiquer explicitement le type, mais cela est la conséquence d'une tentative d'accéder à nouveau à la liste via la fonction précédente pour travailler avec des pointeurs. </font><font style="vertical-align: inherit;">Si vous ajoutez la fonction back () à l'adaptateur, qui retourne un itérateur, alors son utilisation n'aura pas un tel problème:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir ajusté les itérateurs aux exigences de STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
il devient possible d'utiliser la liste dans les algorithmes de bibliothèque:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
…<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, vous devrez organiser l'interception et la gestion des exceptions: tous les exemples ci-dessus sont destinés à travailler dans un seul thread afin de tester la compatibilité avec STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation d'algorithmes STL rend un point intéressant possible: vous pouvez utiliser plusieurs algorithmes à la fois, en les exécutant dans plusieurs threads en parallèle. Cela ne peut pas être fait par des moyens conventionnels (par exemple, en utilisant std :: list et des moyens de blocage) sans avoir accès au contenu interne de la classe list. Il n'a été possible de bloquer la liste entière que pour la durée de l'algorithme entier. Bien sûr, cela accélérera le travail du thread exécutant l'algorithme, mais rendra la liste inaccessible aux autres threads. Cependant, si vous appliquez le même verrou SRWLock «fin», vous pouvez exécuter plusieurs algorithmes sur la liste en même temps, s'ils ne modifient pas cette liste. Mais le premier thread à écrire restera debout en attendant la fin de l'opération de lecture de la liste par tous les autres threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'option de liste proposée vous permet d'organiser le travail avec elle de manière plus flexible. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez organiser le travail avec la liste de sorte que les algorithmes non modificateurs de la première moitié de la liste soient exécutés par plusieurs threads en même temps, tandis qu'un certain nombre d'autres threads peuvent ajouter ou modifier quelque chose dans la seconde moitié de la liste. </font><font style="vertical-align: inherit;">Le fait que la liste soit bloquée pendant la durée d' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opération, et non l'ensemble de l'algorithme, permettra l '"écriture" des opérations d'écriture à travers la séquence d'opérations de lecture de la liste, ce qui rendra le travail avec elle plus flexible, productif et efficace.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinaison de deux variantes de classes de liste avec et sans support d'exception en une seule avec un paramètre booléen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, les listes ne comportaient que des exceptions. </font><font style="vertical-align: inherit;">Ensuite, j'en ai ajouté de nouvelles - aucune exception avec retour d'erreur, et j'ai renommé les anciennes avec l'ajout de la lettre «E» dans le nom de la classe: List_OneLinked_E et List_TwoLinked_E. </font><font style="vertical-align: inherit;">Cela nécessitait d'indiquer quatre déclarations de la classe de liste partout. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai alors décidé que cela ne convenait pas pour de nombreuses raisons. </font><font style="vertical-align: inherit;">Pourquoi avons-nous besoin de deux classes complètement différentes si c'est la même liste avec ou sans support d'exception? </font><font style="vertical-align: inherit;">J'ai combiné les deux listes de chaque type dans une seule classe avec un paramètre booléen supplémentaire, et leur implémentation spécifique avec et sans exceptions sont deux spécialisations d'une classe unique pour le paramètre booléen spécifié.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opération de fusion de liste de modèles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'opération de modèle consistant à combiner des listes ne fonctionnait auparavant qu'avec des listes du même type. Il ne combinait que des listes connectées individuellement ou uniquement des listes connectées deux fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si vous y réfléchissez, peu importe le type de listes impliquées dans l'opération: simplement connectées ou doublement connectées. Leurs stratégies de blocage sont également sans importance, quelle est leur stratégie pour vérifier l'existence d'éléments, et si elles prennent en charge la gestion des exceptions ou non. Tout cela ne s'applique qu'à l'organisation de la liste, mais pas aux données qu'elle contient. Il est important que seuls le type de données et la stratégie de mémoire des éléments correspondent. En conséquence, maintenant, après avoir combiné des listes avec un paramètre booléen concernant les exceptions, l'opération d'entrée accepte des listes de tout type avec toutes les variantes de leurs paramètres:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, en raison du type de liste, le compilateur sélectionne, en fonction du réglage du paramètre externe ce_bGetMinLinksList, une liste avec une connectivité minimale ou maximale et, selon cette solution, ses paramètres correspondants sont utilisés:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base des paramètres sélectionnés, une liste de résultats est créée:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, sur cette liste, les pointeurs sont définis au début de la première et à la fin de la deuxième liste:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, les listes précédentes sont effacées et la fonction se ferme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le point faible de cette fonction est le double verrouillage des listes avec des blocages potentiels:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez introduire une fonction pour verrouiller simultanément deux listes en une seule opération atomique comme std :: lock (mutex1, mutex2), cependant, toutes les stratégies de verrouillage ne prennent pas en charge le verrouillage simultané de deux objets de synchronisation, comme std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, deux listes peuvent avoir des stratégies de verrouillage différentes. </font><font style="vertical-align: inherit;">La solution à ce problème (s'il existe) est laissée à l'avenir.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilation Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compilation a été vérifiée via le projet ListDataAdapterTest, écrit à l'origine en C ++ pur sans fonctionnalités spécifiques à Windows, sur Linux Ubuntu 16.04 LTS, le compilateur g ++ 8.2.0. La plupart des nuances mineures ont été faciles à corriger et le projet a été compilé avec succès, et la sortie du programme a coïncidé avec la même sortie sous Windows. Cependant, c'est le cas si vous commentez la ligne de combinaison des listes via l'opération "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le laissez tel quel, une erreur de compilation se produira dans l'opération «+» décrite ci-dessus, comme si elle n'avait pas été déclarée privilégiée dans la classe de l'élément composite de la liste. Une erreur similaire se produit dans la classe de stratégie de vérification directe pour l'élément DirectSearch. Dans Visual C ++, tout va bien ici, cependant, ces mêmes erreurs apparaissent si dans la classe d'élément composite et dans la classe list le commentaire sur la déclaration de l'opération de combinaison des listes et de DirectSearch en tant que privilégié est mis en commentaire. Il semble que g ++ ignore simplement ces déclarations et se plaint des membres privés / protégés des classes correspondantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Dans g ++ version 9 (Ubuntu 20.04), les mêmes erreurs.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi les annonces de privilèges sont ignorées et comment y remédier, je n'ai pas compris. </font><font style="vertical-align: inherit;">Je ne suis pas bon dans les fonctionnalités du compilateur GCC. </font><font style="vertical-align: inherit;">A laissé ce moment aussi pour l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hormis cette nuance, il n'y a pas d'autre grave erreur de compilation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description de la structure du fichier d'en-tête</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chers lecteurs, j'ai publié le projet à part entière sous licence LGPL 3.0 sur GitHub à: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il s'agit d'une solution composée de plusieurs projets de test. </font><font style="vertical-align: inherit;">Le code principal d'une liste multithread, de par sa mise en œuvre via des modèles, se trouve dans plusieurs fichiers d'en-tête:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - la classe de base d'une liste sans données, qui implémente toutes les opérations de base avec une liste, possible sans définir de données spécifiques, ainsi que des adaptateurs STL similaires pour les données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - versions de la liste avec prise en charge des exceptions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - définition des classes de base pour un élément de liste.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - définition des codes et des classes d'erreur pour les exceptions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus des fichiers principaux répertoriés, les éléments suivants sont également implémentés:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - stratégies pour travailler avec la mémoire;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - stratégies de blocage.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - stratégies de vérification de la présence d'un élément dans la liste, décrites de manière abstraite pour tout conteneur avec itérateurs.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus du projet final, j'ai également ajouté trois anciennes versions dans le dossier «Anciennes versions», afin que vous puissiez évaluer brièvement comment le projet a changé au fur et à mesure de son développement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essai</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet principal, appelé List, est un programme avec une interface pour Windows qui est implémentée de manière hardcore via l'API Windows (je ne sais pas comment faire autrement). Dans ce programme, vous sélectionnez le type de liste (simplement connecté ou doublement connecté), et indiquez également le nombre initial d'éléments et le nombre souhaité de threads. Les éléments de liste contiennent une seule valeur 64 bits. Après avoir créé une liste, le programme de chaque thread de la boucle passe en avant ou en arrière dans la liste à un nombre aléatoire d'éléments, puis ajoute ou supprime un élément. Aucun véritable travail utile n'est effectué à travers cette liste, et toute l'énergie est dépensée pour chauffer l'atmosphère, mais ce n'est pas nécessaire: il suffit d'évaluer l'opérabilité et les performances de la liste dans un environnement multi-thread intensif.La mesure des performances est le nombre d'itérations du cycle ci-dessus par seconde, effectuées par tous les threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste est établie en indiquant les stratégies appropriées dans le code du programme, puis en recompilant. Toutes les stratégies du programme principal sont spécifiées dans le module principal ListMain.cpp, la stratégie de mémoire est sélectionnée dans ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'une manière générale, j'ai expérimenté un peu avec des expériences. J'avoue honnêtement. Principalement parce que dans certains cas, la liste des articles change considérablement. Pour que la pureté de l'expérience mesure les performances, il serait nécessaire de mettre un test de telle sorte que le nombre d'éléments en moyenne ne change pas au cours de la période d'étude ou change de manière extrêmement insignifiante. Ce n'est que dans ces conditions qu'il serait juste d'évaluer la valeur de la productivité sur la base de la valeur moyenne. Si quelqu'un est intéressé, je propose d'organiser de telles expériences par lui-même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas corrigé l'organisation initiale des tests pour les raisons suivantes. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, j'étais juste paresseux.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tout d'abord, à mon avis, personne ne s'intéresse aux valeurs quantitatives exactes de la performance</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec erreur calculée</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : il est important d'évaluer les performances et les performances de la liste de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manière qualitative</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deuxièmement, cela vous permet d'évaluer l'évolution de la performance de la liste avec la croissance de son volume, ce qui est également une information assez importante et intéressante. </font><font style="vertical-align: inherit;">Pour ces raisons, je n'ai pas changé les expériences originales. </font><font style="vertical-align: inherit;">Troisièmement, le même code de test est effectué sur toutes les variantes de la liste, ce qui les place en ce sens dans les mêmes conditions: le fait qu'elles se comportent différemment dans ce cas permet de juger de la qualité des changements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour activer la mesure des performances, définissez l'indicateur ce_bPerformanceMeasure dans le module ListMain.cpp sur true. </font><font style="vertical-align: inherit;">Le programme créera un fichier «PerformanceMeasure.txt» avec des paires «nombre d'éléments - nombre de cycles / sec», séparés par un symbole «:».</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultats de la mesure du rendement</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, je n'ai pas effectué de tests pour toutes les configurations possibles de la liste, car il y en a beaucoup. </font><font style="vertical-align: inherit;">Je me suis concentré uniquement sur les principaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des tests ont été effectués sur ma commande de la configuration Intel Core i7-3930K, DDR3-1333, contrôleur de mémoire à 4 canaux déjà obsolète mais toujours très dynamique. </font><font style="vertical-align: inherit;">La compilation a été effectuée via Visual Studio 2019 pour le mode Release x64, le système d'exploitation Windows 7 x64. </font><font style="vertical-align: inherit;">Je n'ai pas joué avec le nombre de threads, donc dans tous les tests, le maximum de 12 threads disponibles dans ce système ont toujours été utilisés. </font><font style="vertical-align: inherit;">Une liste a toujours été créée avec 10 000 éléments sélectionnés au hasard, à l'exception du dernier test.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test de stratégie de mémoire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant des pointeurs intégrés, comme je l'ai mentionné précédemment, seule une stratégie de recherche directe peut être utilisée pour vérifier la présence d'un élément dans la liste. Par conséquent, pour que la comparaison soit correcte et pour les pointeurs intelligents, seule cette stratégie sera appliquée dans ce test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que stratégie de verrouillage, une section critique avec un verrou fin a été sélectionnée comme la plus productive de Windows (voir ci-dessous): ThreadLockingWin_SRWLock. La gestion des erreurs est effectuée en renvoyant un code d'erreur, c'est-à-dire option sans exception. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce graphique montre le nombre de cycles effectués par tous les threads au total par seconde, en fonction de la durée du test (en secondes). De toute évidence, les performances sont incohérentes en raison de la nature aléatoire des threads accédant à la liste.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième graphique montre comment le nombre d'éléments de liste change pendant le test. Je ne ferai aucune déclaration réfléchie sur ce calendrier, sauf pour l'évidence: il est clair qu'ils fonctionnent de manière légèrement différente, et la connectivité de la liste avec la stratégie de mémoire a un effet. Une liste doublement liée avec des pointeurs internes est la seule qui, de façon inattendue, ne change pas de taille moyenne sur toute la durée du test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Productivité moyenne (cycles / s) pour la période mesurée:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut au moins affirmer que l'option de liste avec des pointeurs intelligents est plus lente que la version avec des pointeurs intégrés, ce qui est normal. </font><font style="vertical-align: inherit;">Dans les deux cas, il s'avère en quelque sorte qu'un seul connecté est plus rapide qu'un double connecté, ce qui montre une fois de plus qu'en mode multithread, de nombreuses choses familières peuvent changer.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test des stratégies de disponibilité des articles</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus intéressant est de tester des stratégies pour vérifier la présence d'un élément. En tant que stratégie de mémoire, les pointeurs intelligents sont naturellement indiqués pour les raisons précédemment décrites. Le reste est le même: verrouillage avec ThreadLockingWin_SRWLock et gestion des erreurs en renvoyant un code d'erreur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons affirmer avec certitude que toutes les stratégies fonctionnent à peu près de la même manière. Cela est compréhensible: dans une liste liée individuellement, lorsque vous supprimez son élément, vous devez à chaque fois consulter la liste jusqu'à l'élément qui indique l'élément à supprimer. Cela annule tous les efforts pour optimiser l'accès à la liste et accélérer la vérification de la présence d'un élément dans celle-ci. Par conséquent, une liste liée individuellement n'est pas le meilleur choix pour un travail multithread désordonné intensif avec elle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne donnerai pas de graphique sur le nombre d'éléments: il n'y a rien d'intéressant là-bas. Je note seulement que maintenant le nombre d'éléments dans toutes les listes augmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une situation complètement différente se pose pour une liste doublement chaînée. Pour que les graphiques soient beaux, j'en ai même exclu la stratégie de visualisation directe de la liste DirectSearch, car par les résultats, elle «tombe» clairement du reste. De plus, j'ai augmenté le nombre limite d'éléments de 4 fois, atteignant lequel, le test s'arrête.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, les performances d'accès à la liste (ainsi que la charge du processeur, devenant de 99 à 100%) ont augmenté de manière spectaculaire et significative! Deuxièmement, une paire de stratégies avec remplissage séquentiel de bits de matrice a approximativement les mêmes performances qui ne changent pas pendant le test. La vitesse de la deuxième paire de stratégies diminue de façon non linéaire. Pourquoi il en est ainsi, il deviendra clair à partir du graphique pour le nombre de nœuds dans la liste.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les listes avec la première paire de stratégies augmentent en nombre d'éléments, et de façon linéaire. La deuxième paire donne une croissance significativement non linéaire, et plus le nombre d'éléments a une liste, plus elle se développe lentement. C'est compréhensible puisque avec une augmentation du nombre d'éléments lors de la création d'un nouvel élément, il est en moyenne nécessaire de parcourir un plus grand nombre de bits du tableau à la recherche de free. La première paire de stratégies ne traite pas cela, elle utilise un nouveau bit pour chaque nouvel élément. Ainsi, une liste avec une telle stratégie a des performances d'accès maximales et est la plus proche de la liste classique: à la fois la création et la suppression d'éléments sont effectuées en un temps constant, indépendamment du nombre d'éléments. Cependant, il offre certaines garanties d'intégrité et de sécurité dans un environnement multi-thread, bien qu'au prix d'une certaine quantité de mémoire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste avec la deuxième paire de stratégies est bien sûr beaucoup plus lente. Cependant, il est encore beaucoup plus rapide que les options de vérification directe. Vous pouvez donc vraiment le recommander comme un intermédiaire dans les performances, mais plus optimal en termes de consommation de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, les listes avec une stratégie de recherche directe fonctionneront également plus lentement avec une augmentation du nombre d'éléments en elles: un plus grand nombre d'éléments devra être visualisé à chaque fois. C'est juste que pendant le test, la liste n'arrive pas à s'allonger tellement qu'elle devient perceptible malgré les fluctuations chaotiques des performances.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs de performance moyennes montrent que les stratégies avec un bitmap lors de son remplissage séquentiel ont permis d'augmenter la productivité de l'accès à la liste d'environ 200 fois, c'est-à-dire </font><font style="vertical-align: inherit;">2 ordres de grandeur par rapport aux stratégies de recherche directe. </font><font style="vertical-align: inherit;">Il s'agit d'un changement très radical. </font><font style="vertical-align: inherit;">Les performances des options avec un remplissage de bits optimal en mémoire, comme indiqué ci-dessus, sont bien sûr beaucoup plus lentes, mais toujours beaucoup plus rapides que les options avec vérification directe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient également de noter que l'utilisation d'un mécanisme de transfert de mémoire à la demande ralentit quelque peu l'accès à la liste. </font><font style="vertical-align: inherit;">Pas trop critique, mais l'effet est présent et perceptible, surtout - dans la variante avec l'utilisation économique de la mémoire (ligne jaune sur les graphiques).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test de stratégie de blocage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment les performances de la liste changeront lors du choix de différentes stratégies de verrouillage. </font><font style="vertical-align: inherit;">J'ai utilisé trois types de verrous: le verrou «mince» SRWLock, la section critique Windows standard et le mutex STL. </font><font style="vertical-align: inherit;">Pour le reste des paramètres, la version la plus rapide de la liste a été utilisée: biconnectés, pointeurs intelligents, la stratégie de vérification de la présence d'un élément - SearchByIndex_BitArray, une variante sans exception. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous vous en doutez, un verrou «fin» augmente les performances de près de 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vitesse de travail avec la section critique de Windows et le mutex STL est à peu près la même.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour évaluer l'impact des exceptions sur les performances, j'ai effectué trois tests. </font><font style="vertical-align: inherit;">Les deux premiers ont utilisé une liste doublement liée, des pointeurs intelligents, une stratégie de vérification de présence d'élément - SearchByIndex_BitArray, une section critique de SRWLock. </font><font style="vertical-align: inherit;">Le même test a été utilisé pour le dernier test, seul le verrou a été remplacé par la section critique habituelle pour comparaison. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut voir que la prise en charge des exceptions peut vraiment réduire la vitesse de travail, surtout si vous utilisez une option de blocage plus «grossière». </font><font style="vertical-align: inherit;">Cependant, n'oubliez pas que dans ce cas, la prise en charge de STL et des boucles de la collection ne sera pas disponible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce fut une expérience à très grande échelle pour moi. Je ne parle pas des tests ci-dessus, mais de l'ensemble du projet. Il ne s'attendait pas à ce qu'il soit ainsi entraîné. Néanmoins, je l'ai réalisé complètement et dans la mesure où je l'avais prévu. Bien sûr, au final, ce n'est toujours pas la version finale, mais seulement un prototype fonctionnel, la mise en œuvre des idées décrites au début de l'article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon les résultats du test, il est clair que sous Windows, il s'est avéré être la liste doublement liée la plus rapide avec des pointeurs intelligents, une stratégie pour vérifier la présence de l'élément SearchByIndex_BitArray, une section critique de SRWLock et aucune exception. Dans cette configuration, la liste fournit des performances maximales avec un accès chaotique intensif à partir de divers threads et le comportement est le plus proche de la liste classique avec des garanties de sécurité en mode multithread. L'option avec une consommation de mémoire plus économique est également très productive (par rapport à la vérification directe DirectSearch), mais elle est toujours sensiblement plus lente que la précédente, et ses performances diminuent avec une augmentation du nombre d'éléments.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous pensez que je vais faire campagne ici pour ce que j'ai fait de cool et à quel point c'est génial de l'utiliser, alors non: en fait, je vais commencer par vous décourager. </font><font style="vertical-align: inherit;">En effet:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réfléchissez s'il est possible d'utiliser un conteneur avec une disposition différente des éléments: par exemple, un tableau. </font><font style="vertical-align: inherit;">Il n'a pas de problèmes comme une liste.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    –       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   –     .    . ,   –          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les stratégies de transfert de mémoire sur un tableau de bits à la demande rapproche également au moins partiellement une liste multithread à la liste classique: au moins jusqu'à ce que le tableau de mémoire soit complètement plein, il en faudra exactement autant que nécessaire. </font><font style="vertical-align: inherit;">Cependant, cela entraîne une réduction des performances.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Inconvénients du projet:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La possibilité précédemment notée de blocage mutuel dans l'opération de combinaison de listes.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère que c'était intéressant. Les débutants peuvent être utiles, car tout est considéré du simple au complexe. Je demande aux professionnels de dire dans quelle mesure, à votre avis, les idées décrites ici sont applicables en pratique dans des projets réels? Y a-t-il eu un cas dans votre activité où, en termes de signification, vous aviez besoin d'une liste ou d'un arbre, et non d'un autre conteneur, mais qui est devenu un goulot d'étranglement dans votre programme en raison des problèmes décrits ici? Ou vous avez dû modifier ou compliquer considérablement le programme. Si vous l'avez déjà rencontré, comment avez-vous résolu cela?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, par essence, ce projet n'est que la réalisation de ma propre vision de la solution de ce problème. </font><font style="vertical-align: inherit;">Il est probable qu'il existe une meilleure option. </font><font style="vertical-align: inherit;">Je répète la pensée depuis le début que je l'ai fait initialement pour moi-même et que je n'avais pas l'intention de le mettre en exposition publique. </font><font style="vertical-align: inherit;">Mais quand même, je l'ai fait pour les raisons qui y sont décrites, je serai donc ravi des critiques constructives. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avec un examen attentif du code, vous pouvez rencontrer une telle conception:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette magie noire mérite un article séparé. </font><font style="vertical-align: inherit;">Certes, c'est une chose encore moins pratique que la liste multithread décrite ici, mais elle a ses propres caractéristiques curieuses. </font><font style="vertical-align: inherit;">Si vous êtes intéressé par d'où il vient et pourquoi il est apparu, et que vous voulez que j'en parle plus tard en détail, écrivez dans les commentaires.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr506702/index.html">Les disques durs les plus fiables selon Backblaze Q1 2020</a></li>
<li><a href="../fr506704/index.html">Pourquoi écrire en PHP en 2020? Holivarim est un podcast interactif sur Youtube ce jeudi</a></li>
<li><a href="../fr506706/index.html">Les performances de Java moderne lorsque vous travaillez avec de grandes quantités de données, partie 1</a></li>
<li><a href="../fr506708/index.html">Authentification à deux facteurs VPN / Mikrotik - simple et évolutive</a></li>
<li><a href="../fr506710/index.html">Gérez plusieurs carnets d'adresses dans Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../fr506726/index.html">Expérience dans l'utilisation de la technologie Rutoken pour l'enregistrement et l'autorisation des utilisateurs dans le système (partie 2)</a></li>
<li><a href="../fr506730/index.html">Snort ou Suricata. Partie 1: choisissez un IDS / IPS gratuit pour protéger le réseau d'entreprise</a></li>
<li><a href="../fr506732/index.html">Réutilisation à l'échelle de l'organisation des composants de l'interface utilisateur</a></li>
<li><a href="../fr506734/index.html">Calculs transitoires dans les réseaux électriques</a></li>
<li><a href="../fr506736/index.html">Combien de méthodes devraient être dans une classe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>