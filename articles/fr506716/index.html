<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ò üõ¢Ô∏è üë©üèº‚Äç‚öñÔ∏è Liste lin√©aire multithread: probl√®me d'existence d'√©l√©ment, am√©lioration de la productivit√© et relation STL üíù üë®üèª‚ÄçüöÄ üèÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers visiteurs de Habr! 
 
 Cet article se concentrera sur une liste li√©e, le multithreading et C ++. Je note tout de suite qu'il y avait to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Liste lin√©aire multithread: probl√®me d'existence d'√©l√©ment, am√©lioration de la productivit√© et relation STL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, chers visiteurs de Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article se concentrera sur une liste li√©e, le multithreading et C ++. Je note tout de suite qu'il y avait toutes les chances de mettre ce travail sur l'√©tag√®re et de l'utiliser dans un petit nombre de projets personnels. Au lieu de cela, j'ai quand m√™me d√©cid√© de le mettre sur le court du public - tout d'un coup, cela semble vraiment utile ou int√©ressant pour quelqu'un. De plus, s'il s'av√®re que quelqu'un a d√©j√† r√©ussi √† faire quelque chose comme √ßa, veuillez me l'indiquer, s'il vous pla√Æt. Cependant, peu importe comment j'ai essay√© de google sur ce sujet, toutes les tentatives ont √©chou√©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je note √©galement qu'il ne s'agira pas de la liste cha√Æn√©e classique, mais de ma r√©flexion cr√©ative sur l'utilisation de cette structure de donn√©es dans un environnement multithread. J'envisageais un sc√©nario d'acc√®s intensif √† une liste multithread non ordonn√©. Cela signifie que n'importe quel thread √† tout moment, ind√©pendamment des autres, peut acc√©der √† la liste et effectuer les op√©rations requises. S'il ajoute ou modifie uniquement des √©l√©ments, ce n'est pas si mal. S'il supprime √©galement les √©l√©ments, diverses caract√©ristiques int√©ressantes peuvent appara√Ætre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce projet, dans lequel je me suis engag√© comme passe-temps et d√©veloppement personnel, a dur√© tr√®s longtemps pour plusieurs raisons. </font><font style="vertical-align: inherit;">De plus, pendant que j'y travaillais, j'ai √©tudi√© intensivement: le projet a commenc√© sans la connaissance et la compr√©hension de STL et a √©t√© con√ßu en cons√©quence, en utilisant uniquement les moyens internes du langage C ++ lui-m√™me. </font><font style="vertical-align: inherit;">Cependant, je l'ai tr√®s s√©rieusement modifi√© en prenant en compte STL et m√™me sous STL. </font><font style="vertical-align: inherit;">Ce que j'ai retir√© de cela, jugez-vous, chers lecteurs.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une compr√©hension la plus compl√®te du mat√©riel d√©crit ici, vous devrez lire les livres suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - ¬´Design moderne en C ++¬ª.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - ¬´Windows via C / C ++, programmation Visual C ++¬ª.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - ¬´Biblioth√®que standard C ++. </font><font style="vertical-align: inherit;">Guide de r√©f√©rence. </font><font style="vertical-align: inherit;">Second Edition ‚Äùou un livre similaire sur STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste des lignes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une liste lin√©aire est une structure de donn√©es bien connue qui a √©t√© utilis√©e depuis l'√©poque du langage C et plus t√¥t. Son √©l√©ment est un certain objet en m√©moire qui a des connexions avec un ou deux √©l√©ments similaires voisins - voici un exemple de liste doublement li√©e:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;‚Ä¶   ‚Ä¶&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cons√©quence, la liste elle-m√™me est un certain (sous) programme qui effectue des manipulations avec ces √©l√©ments. </font><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, un pointeur vers le d√©but et, √©ventuellement, vers la fin de la liste est connu: cela suffit pour, √† partir du premier √©l√©ment, parcourir tous ses √©l√©ments jusqu'√† la fin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, je d√©cris des informations d√©j√† bien √©tudi√©es et bien connues: c'√©tait un programme √©ducatif pour ceux qui √©taient compl√®tement ignorants. </font><font style="vertical-align: inherit;">Pour plus de d√©tails, par exemple, vous pouvez contacter ici: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste lin√©aire (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La biblioth√®que STL a un merveilleux conteneur std :: list (liste doublement li√©e), ainsi que son twin - std :: forward_list (liste li√©e individuellement). </font><font style="vertical-align: inherit;">Autrement dit, si vous n'√™tes pas int√©ress√© par la fa√ßon dont la liste est organis√©e et fonctionne √† l'int√©rieur, et que vous souhaitez simplement l'utiliser pour vos t√¢ches, les conteneurs propos√©s sont votre option.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a une chose mais ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probl√®mes de multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je r√©p√®te que lorsque j'ai commenc√© √† analyser ce sujet, j'allais tout faire, en ne comptant que sur les outils internes C ++ sans support STL. </font><font style="vertical-align: inherit;">La valeur de ce qui se passerait serait plus faible si je d√©cidais quand m√™me d'en parler ici. </font><font style="vertical-align: inherit;">Mais d'un autre c√¥t√©, j'√©tais compl√®tement libre de tout concept ou limitation de la biblioth√®que, et donc je n'√©tais li√© par rien et recherchais des approches avec un esprit ouvert et ind√©pendant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, dans un pass√© lointain et lointain, la grande majorit√© des ordinateurs √©taient √† c≈ìur unique et √† processeur unique. La liste lin√©aire √©tait une structure de donn√©es relativement simple et transparente, et travailler avec elle n'a pas pos√© de difficult√©s particuli√®res. D√©sormais, m√™me les smartphones sont devenus multic≈ìurs. Dans des conditions de multithreading, m√™me une structure aussi simple qu'une liste cha√Æn√©e est s√©rieusement compliqu√©e. Assurer le bon fonctionnement en mode multi-thread complique g√©n√©ralement s√©rieusement n'importe quel programme, c'est un fait connu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenez un sc√©nario abstrait de travail intensif avec une liste de diff√©rents threads: chacun d'eux peut ajouter, supprimer, modifier des √©l√©ments, etc. √† un moment compl√®tement arbitraire. D'une part, le travail avec la liste dans ce cas doit √™tre principalement s√ªr: s'il y a des violations de donn√©es et un comportement ind√©fini du programme, ce sera une solution compl√®tement inappropri√©e. Par contre, j'aimerais beaucoup travailler avec lui le plus rapidement possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©soudre le premier probl√®me, la liste devra √©videmment √™tre bloqu√©e d'une mani√®re ou d'une autre, ainsi que synchroniser l'acc√®s √† celle-ci. Le deuxi√®me probl√®me - les performances - est diff√©r√© pour l'instant.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article ne consid√®re que le blocage de la liste enti√®re par un flux pour un acc√®s exclusif √† ce flux. D'autres options semblaient douteuses, par exemple, pour les raisons suivantes. Supposons que nous ayons une liste doublement li√©e et que nous ayons d√©cid√© d'en supprimer l'√©l√©ment. Pour ce faire, vous devez bloquer le n≈ìud lui-m√™me, ainsi que le pr√©c√©dent et le suivant. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä ce moment pr√©cis, avant le d√©but de l'op√©ration, un autre thread supprime uniquement, par exemple, le n≈ìud pr√©c√©dent. Nous bloquons celui qui a √©t√© supprim√© et arr√™tons d'attendre la lib√©ration du n≈ìud pr√©c√©dent bloqu√© par un autre thread. Et il est bloqu√© en attendant le prochain pour lui, c'est-√†-dire notre n≈ìud supprim√©. C'est √ßa, c'est une impasse. Cette m√©thode n'est donc pas fiable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vos threads ne stockent aucun pointeur (ou it√©rateur) vers des n≈ìuds sp√©cifiques, la t√¢che est extr√™mement simplifi√©e. En fait, vous ne pouvez le faire qu'avec des outils STL. Le flux bloque la liste, fait r√©f√©rence √† n'importe quel √©l√©ment de celle-ci (par exemple, depuis le d√©but, depuis la fin ou en la recherchant selon certains crit√®res), traite ou supprime cet √©l√©ment, en ajoute de nouveaux sans enregistrer de liens vers eux, puis compl√®te la liste. Tout cela - bloquer exclusivement l'acc√®s √† la liste dans un seul thread, le poss√©der pendant la dur√©e des op√©rations requises. Dans ce cas, il est parfaitement logique d'utiliser les fonctions de verrouillage de std :: list et de biblioth√®que. Pour tout cela, il convient de noter que tandis que votre thread fait tout le travail requis, d'autres threads cesseront d'attendre, c'est-√†-dire le travail avec la liste sera effectu√© en mode monothread.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai consid√©r√© un autre sc√©nario, plus complexe, lorsqu'un thread stocke un pointeur ou un it√©rateur sur l'√©l√©ment dont il a besoin. </font><font style="vertical-align: inherit;">Par exemple, votre programme travaille sur certains calculs complexes, en prenant les donn√©es initiales de l'√©l√©ment de liste, puis, apr√®s traitement, met √† jour sa valeur, en y ajoutant les r√©sultats des calculs. </font><font style="vertical-align: inherit;">Cependant, d'autres threads ont √©galement acc√®s √† la m√™me liste. </font><font style="vertical-align: inherit;">Je n'ai fait aucune hypoth√®se sur la nature de l'application: un autre thread peut facilement supprimer cet √©l√©ment pour une raison quelconque. </font><font style="vertical-align: inherit;">Ou d√©placez-le vers un autre endroit. </font><font style="vertical-align: inherit;">Ainsi, travailler avec une liste devient probl√©matique non seulement pour les raisons habituelles de multithreading et de synchronisation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me de l'existence d'un √©l√©ment</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la diff√©rence fondamentale entre une liste et, disons, un tableau? Dans un </font><font style="vertical-align: inherit;">arrangement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distribu√©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d'√©l√©ments de liste. Tous les √©l√©ments du tableau sont situ√©s dans une seule zone de m√©moire. M√™me si vous stockez un pointeur sur certains de ses √©l√©ments, vous √™tes s√ªr que l'acc√®s √† son adresse sera correct (bien s√ªr, si le tableau n'a pas √©t√© d√©plac√© en m√©moire vers un autre emplacement avec une extension de sa taille, par exemple). Si l'√©l√©ment dont vous avez besoin est supprim√© ou d√©plac√© vers un autre fil, vous allez simplement √† l'adresse pr√©c√©dente, vous comprendrez par certains signes que l'√©l√©ment dont vous avez besoin n'est pas ici, puis essayez de le rechercher, etc. Bien s√ªr, le programme doit soutenir une telle opportunit√© √† l'avance. Mais, dans tous les cas, son fonctionnement restera correct tant que vous √™tes dans les limites de m√©moire correctes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une situation compl√®tement diff√©rente est dans le cas d'une liste (ainsi que dans le cas d'un arbre, d'un graphe - toute structure de donn√©es avec des √©l√©ments distribu√©s). Si un √©l√©ment en fonction de votre pointeur a √©t√© supprim√© dans un autre fil, vous ne le savez m√™me pas et si vous essayez d'acc√©der √† son adresse, vous recevrez une violation d'acc√®s (au mieux). M√™me s'il n'est pas r√©ellement supprim√© de la m√©moire (par exemple, si des pointeurs intelligents sont utilis√©s), il sera supprim√© de la liste, c'est-√†-dire n'en fera pas partie. Vous ne le saurez pas non plus. Le travail correct avec la liste est interrompu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le m√™me temps, un travail intensif multi-thread avec la liste cr√©e des sc√©narios absolument fantastiques. Vous pouvez m√™me √™tre s√ªr que tout va bien avec votre √©l√©ment et un pointeur vers celui-ci - jusqu'√† acc√©der √† une fonction de liste pour travailler avec lui.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemple. Soit une partie de la liste, et un pointeur vers le n≈ìud, que nous d√©signons par (#), est pass√© √† une m√©thode de liste de fonctions, tandis que les n≈ìuds qui lui sont associ√©s seront d√©sign√©s par des nombres relatifs par rapport √† lui. Au moment o√π la fonction est appel√©e, il est connu que cet √©l√©ment existe et que le pointeur vers celui-ci est correct, c'est-√†-dire que l'√©tat de la liste dans cette zone est: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, laissez le n≈ìud (#) √™tre pass√© en param√®tre √† une fonction de liste. Cette fonction, comme d'habitude, est bloqu√©e en attendant d'y acc√©der. Pendant qu'elle attendait, trois threads ont travaill√© avant elle, supprimant le n≈ìud (#) avec les adjacents pour que cela se produise: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, 5 autres threads ont ins√©r√© 5 autres √©l√©ments dans la liste, en commen√ßant par (-2). Nous d√©signons les nouveaux √©l√©ments par (nN), o√π N est le nombre relatif parmi les cinq, √† partir de z√©ro:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, notre flux est appel√©, qui a √©t√© appel√© avec (#). La question est: que doit-il faire dans ce cas, apr√®s tout (#) a disparu depuis longtemps? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R√©ponse: tout d√©pend de l'op√©ration, ainsi que du sc√©nario d'utilisation de la liste. Cependant, √©tant donn√© que nous consid√©rons le cas le plus g√©n√©ral sans aucune restriction, certaines hypoth√®ses g√©n√©rales peuvent √™tre faites.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il s'agit d'une op√©ration de suppression, il suffit de simplement v√©rifier si l'√©l√©ment sp√©cifi√© est pr√©sent dans la liste. Sinon, il a d√©j√† √©t√© supprim√© et rien d'autre ne doit √™tre fait. Si oui, supprimez. De m√™me, pour l'op√©ration de lecture / modification du contenu du n≈ìud: si le n≈ìud est supprim√©, alors il n'y a d√©j√† rien √† lire / modifier. Mais les plus gros probl√®mes surviennent avec les op√©rations d'insertion d'un nouveau n≈ìud, ainsi que lors du passage au suivant / pr√©c√©dent. D'une part, le n≈ìud sp√©cifi√© n'est plus l√† et une panne peut √™tre renvoy√©e. D'un autre c√¥t√©, le n≈ìud doit √™tre ins√©r√©, et une telle situation peut se produire √† tout moment.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque la priorit√© (pour le cas g√©n√©ral) est toujours la s√©curit√© et la fiabilit√©, et seulement ensuite la vitesse, alors, √©videmment, lorsque le thread a finalement obtenu le temps de fonctionnement √† l'int√©rieur de la fonction, vous devez √©tablir le fait de la pr√©sence d'un √©l√©ment dans la liste: existe-t-il m√™me l√† ou pas d√©j√†? Cela r√©sout un probl√®me: au moins, nous ne perturberons pas la liste enti√®re s'il n'y a pas de n≈ìud demand√© et nous √©viterons les erreurs d'acc√®s √† la m√©moire √† cet √©gard. Mais cela ne r√©sout pas le probl√®me de l'insertion et des transitions: il n'est pas clair o√π ins√©rer un nouveau n≈ìud et passer d'un n≈ìud d√©j√† supprim√©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution au probl√®me de l'existence de l'√©l√©ment sera discut√©e en d√©tail ci-dessous. </font><font style="vertical-align: inherit;">La question de savoir quoi faire lorsque nous constatons que l'√©l√©ment n'est plus l√†, mais qu'il est vraiment n√©cessaire, d√©passe le cadre de cet article, car il d√©pend enti√®rement de l'algorithme du travail utilisant le programme de liste. </font><font style="vertical-align: inherit;">Bien s√ªr, il doit inclure de tels sc√©narios et les r√©actions correspondantes √† ceux-ci: par exemple, s'il n'y a aucun √©l√©ment, alors allez en haut de la liste ou effectuez une autre op√©ration. </font><font style="vertical-align: inherit;">La principale chose qui doit √™tre assur√©e dans cette situation est le fonctionnement correct et s√ªr de la liste, ainsi que la notification de ces situations.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche directe d'articles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche la plus simple et la plus directe consiste √† v√©rifier la pr√©sence d'un √©l√©ment dans la liste en le parcourant s√©quentiellement √† la recherche d'un √©l√©ment donn√©. Ceux. juste √† la recherche de l'√©l√©ment donn√©. S'il est sur la liste, nous travaillons avec lui. Si ce n'est pas le cas, selon la fonction, nous quittons avec succ√®s ou √©chec, et laissons le programme appelant d√©cider quoi faire dans cette situation. L'essentiel est que le travail avec la liste soit en tout cas correct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette m√©thode est s√ªre et enti√®rement fonctionnelle, mais, surtout pour les grandes listes, elle entra√Æne une baisse catastrophique des performances. En fait, travailler avec une liste s'av√®re √™tre monothread: la liste est bloqu√©e pendant la dur√©e de recherche d'un √©l√©ment donn√©, et les autres threads ne peuvent pas y acc√©der. Deuxi√®mement, les frais g√©n√©raux augmentent fortement - dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les op√©rations avec la liste doivent v√©rifier si un √©l√©ment est n√©cessaire au moment de l'op√©ration, et une grande partie du temps n'est pas consacr√©e √† un travail utile, mais √† la v√©rification de la pr√©sence d'un √©l√©ment. </font><font style="vertical-align: inherit;">N√©anmoins, cette approche simple et directe convient tout √† fait aux listes de petits volumes et aux op√©rations pas trop intensives avec elle, ainsi qu'√† une premi√®re approximation pour r√©soudre le probl√®me de l'existence d'un √©l√©ment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que se passe-t-il si nous avons une liste avec un grand nombre d'√©l√©ments, et que travailler avec elle est tr√®s intensif: de nombreux threads en ajoutent, modifient et suppriment constamment des √©l√©ments? </font><font style="vertical-align: inherit;">Existe-t-il un moyen de l'acc√©l√©rer d'une mani√®re ou d'une autre?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©moire ou performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est bien connu qu'une augmentation de la m√©moire utilis√©e par le programme peut augmenter la vitesse du programme. Par exemple, un programme fait un usage intensif des r√©sultats de certains calculs. Au lieu de les ex√©cuter √† nouveau, vous pouvez tout calculer √† l'avance et enregistrer leurs r√©sultats dans une table ou un tableau. Ensuite, le programme acc√®de simplement √† la cellule souhait√©e dans le tableau et re√ßoit imm√©diatement la valeur souhait√©e, ce qui acc√©l√®re consid√©rablement son travail.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est cette approche que j'ai utilis√©e dans le cas de la liste. Cr√©ez un bitmap. Ajoutez aux informations de service de chacun de ses √©l√©ments, en plus du pointeur requis vers l'√©l√©ment suivant et, √©ventuellement, l'√©l√©ment pr√©c√©dent, deux autres nouveaux champs: le premier est son num√©ro unique dans cette liste, et le second est un pointeur vers la liste elle-m√™me. D√©sormais, lorsqu'un √©l√©ment est cr√©√©, un num√©ro unique lui est attribu√© et d√©finit l'unit√© dans le bitmap √† l'index correspondant. Lorsqu'un √©l√©ment est supprim√©, ce bit est r√©initialis√©. Le nombre de l'√©l√©ment cr√©√© augmente constamment chaque fois qu'un nouvel √©l√©ment est cr√©√© - les bits mis √† z√©ro d√©j√† utilis√©s ne sont pas r√©utilis√©s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, lorsqu'il est n√©cessaire de v√©rifier la pr√©sence d'un √©l√©ment donn√©, au lieu de le rechercher lin√©airement dans la liste enti√®re, un bitmap est simplement accessible par l'index de cet √©l√©ment en lui, et le fait de sa pr√©sence est imm√©diatement √©tabli, et pour un temps constant, quelle que soit la taille de la liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette m√©thode vous permet d'obtenir des performances maximales, mais elle a ses graves inconv√©nients. Tout d'abord, vous devrez allouer de la m√©moire √† l'ensemble du tableau √† la fois, dont une partie des bits peut ne pas √™tre n√©cessaire du tout pendant le programme, mais cette m√©moire peut √™tre utilis√©e pour d'autres besoins. Ce probl√®me et un moyen de lisser les d√©passements de m√©moire seront discut√©s ci-dessous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxi√®me inconv√©nient est plus grave et int√©ressant - chaque nouvel √©l√©ment de liste est cr√©√© par un nombre croissant de fa√ßon monotone. Cela signifie que t√¥t ou tard les bits libres de la matrice seront √©puis√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä ce stade, malheureusement, vous devez vous arr√™ter, bloquer la liste et commencer √† la servir. Ceux. compresser les bits de ce tableau, en supprimant tous les bits z√©ro des √©l√©ments de liste interm√©diaires pr√©c√©demment supprim√©s, en ne laissant que des bits pour les √©l√©ments qui existent r√©ellement √† l'heure actuelle, en d√©pla√ßant tous ces bits au d√©but du tableau. Nous devrons parcourir √† nouveau la liste enti√®re, et en mode simple thread, r√©√©crire tous les indices pour chaque √©l√©ment. L'avantage √©vident de cela par rapport √† l'approche pr√©c√©dente est que dans ce cas, </font><b><font style="vertical-align: inherit;">un</font></b><font style="vertical-align: inherit;"> seul sera fait.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois sur une longue p√©riode de temps. </font><font style="vertical-align: inherit;">De plus, la liste peut continuer √† fonctionner comme auparavant en mode extr√™mement rapide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, je ne veux pas dire que les n≈ìuds ont seulement √©t√© ajout√©s √† la liste, car </font><font style="vertical-align: inherit;">dans ce cas, tous les bits du tableau seront simples. </font><font style="vertical-align: inherit;">J'envisage un sc√©nario o√π les √©l√©ments sont supprim√©s et ajout√©s de mani√®re intensive et arbitraire. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">le nombre total d'√©l√©ments de liste depuis le d√©but de son travail peut l√©g√®rement changer. </font><font style="vertical-align: inherit;">Naturellement, la question du choix de la taille du tableau d√©pend de la nature du programme. </font><font style="vertical-align: inherit;">Vous pouvez √©galement toujours cr√©er un nouveau tableau d'un volume plus important si la taille du volume actuel n'est pas suffisante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de z√©ro bit √† partir d'√©l√©ments pr√©c√©demment supprim√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez faire autre chose: lors de la cr√©ation d'un √©l√©ment, recherchez le premier bit z√©ro depuis le d√©but du bitmap. Cela optimise la consommation de m√©moire, mais entra√Ænera une baisse des performances: √† nouveau chaque fois que vous cr√©ez un nouvel √©l√©ment, vous devrez effectuer un travail suppl√©mentaire - parcourez le tableau √† la recherche d'un bit gratuit. Mais par rapport √† la v√©rification de la pr√©sence d'un √©l√©ment en visualisant directement la liste, le gain est √©vident: on va regarder le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©l√©ments adjacents, et chaque √©l√©ment d'un tel tableau contient de nombreux bits, c'est-√†-dire </font><font style="vertical-align: inherit;">nous traitons plusieurs n≈ìuds de liste √† la fois (64 bits pour les syst√®mes modernes ou m√™me 128/256/512 si vous utilisez SSE / AVX). </font><font style="vertical-align: inherit;">Nous recherchons le premier mot qui n'est pas √©gal au mot avec tous les bits unitaires, puis nous recherchons le premier bit z√©ro dans ce mot. </font><font style="vertical-align: inherit;">En fait, cette m√©thode est interm√©diaire en vitesse entre la pr√©c√©dente et la m√©thode de visualisation directe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisation de la consommation de m√©moire pour les bits de tableau inoccup√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous supposions un travail long et intensif avec la liste, en lui allouant un √©norme tableau de bits. Mais il se trouve que le programme fonctionne en fait diff√©remment: il acc√®de rarement √† la liste, effectue d'autres op√©rations qui n√©cessitent √©galement de la m√©moire. En cons√©quence, nous obtenons un tableau presque inutilis√© de bits d'√©normes probl√®mes de volume et de m√©moire dans d'autres parties du programme. Un simple inconv√©nient! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux, pour autant que je sache, r√©sout automatiquement ce probl√®me (bien que les d√©veloppeurs Linux exp√©riment√©s me laissent le r√©soudre, si cela). Vous allouez de la m√©moire √† la baie, mais en fait, le syst√®me </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne transf√®re pas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette m√©moire √† la baie </font><font style="vertical-align: inherit;">tant qu'elle n'est pas vraiment n√©cessaire. Il existe une optimisation de l'utilisation de la m√©moire. Windows ne le permet pas. Au contraire, cela le permet, mais vous devez le faire vous-m√™me.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui ne sont pas du tout √† jour, je vais vous expliquer: votre application (plus pr√©cis√©ment, le processus qui lui correspond), le syst√®me alloue un </font><font style="vertical-align: inherit;">grand </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espace d'adressage virtuel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jusqu'√† 8 To pour Windows 64 bits. La m√©moire physique du syst√®me peut √™tre bien inf√©rieure - 8 ou 16 Go pour le moment pour les ordinateurs de masse. </font><b><font style="vertical-align: inherit;">Affichages du</font></b><font style="vertical-align: inherit;"> syst√®me d'exploitation</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des adresses de votre espace de processus virtuel aux adresses de m√©moire physique, en le faisant de mani√®re transparente sans votre implication directe. Naturellement, la plupart de la m√©moire virtuelle libre d'un processus est g√©n√©ralement inoccup√©e. Ainsi, lorsque vous demandez √† Windows d'allouer de la m√©moire par des moyens conventionnels, il alloue simultan√©ment cette m√©moire √† la fois dans votre espace virtuel et dans la m√©moire physique. Si vous allouez un bitmap de grand volume, vous courez le risque d'occuper imm√©diatement toute la m√©moire disponible sur votre ordinateur sans garantir que cette m√©moire puisse √™tre n√©cessaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, on peut agir diff√©remment: baliser une √©norme partie de la m√©moire dans l'espace virtuel du processus, mais y transf√©rer du physique uniquement lorsque cela est vraiment n√©cessaire. </font><font style="vertical-align: inherit;">Cela peut √™tre fait via la gestion des exceptions structurelles dans Windows; pour plus de d√©tails, veuillez vous r√©f√©rer au livre de Richter D., Nazar K. - ¬´Windows via C / C ++, Visual C ++ Programming¬ª.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la mise en oeuvre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce ne serait qu'une id√©e et une th√©orie, si je n'avais pas mis toutes ces id√©es en pratique, et non sous la forme d'un simple programme exp√©rimental: je l'ai fait le plus soigneusement possible pour la production, avec l'intention de l'utiliser dans mes projets r√©els, donc c'est sous cette forme que vous en avez besoin et imaginez. </font><font style="vertical-align: inherit;">J'ai pens√© qu'il serait injuste et trop √©go√Øste d'appliquer ce qui a √©t√© fait dans mon nombre limit√© de projets si cela pouvait √™tre utile ou tout au moins int√©ressant pour un large cercle de d√©veloppeurs. </font><font style="vertical-align: inherit;">D'un autre c√¥t√©, les cr√©ateurs de la biblioth√®que Boost et d'autres biblioth√®ques plus sp√©cialis√©es offrent leur travail √† tout le monde gratuitement. </font><font style="vertical-align: inherit;">Pourquoi ne puis-je pas faire de m√™me?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraction - une liste sans donn√©es</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai divis√© la liste en deux niveaux logiques. Le premier niveau est une liste, dont chaque √©l√©ment ne contient pas de donn√©es utiles, mais ne contient que des informations auxiliaires: des pointeurs vers des √©l√©ments voisins et, √©ventuellement, ces deux champs suppl√©mentaires pour acc√©l√©rer la v√©rification de la pr√©sence d'un √©l√©ment dans la liste. Cependant, d√©j√† √† ce niveau, il est possible d'effectuer toutes les op√©rations de base sur une liste: ajout et suppression d'√©l√©ments, fractionnement et fusion de listes, etc. En fait, je me suis concentr√© principalement sur ce niveau. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxi√®me niveau consiste √† ajouter des donn√©es r√©elles √† l'√©l√©ment de liste, ainsi qu'√† ajouter de nouvelles op√©rations √† la liste pour travailler avec ces donn√©es. Tout cela est fourni en C ++ par h√©ritage. Mais les d√©tails seront discut√©s ci-dessous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une telle d√©composition de l'impl√©mentation en deux niveaux √©tait logique: pourquoi prendre en compte la disponibilit√© de donn√©es sp√©cifiques si un certain nombre d'op√©rations sont totalement ind√©pendantes de ces donn√©es? Pour tout √©l√©ment de liste donn√©, vous devez toujours les supprimer et en ajouter de nouveaux √† la liste, ainsi que r√©aliser d'autres op√©rations typiques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai commenc√© avec un concept extr√™mement simple et simple, tir√© de la construction du langage C au d√©but de l'article. Les pointeurs internes C et C ++ sont utilis√©s √† la fois √† l'int√©rieur et √† l'ext√©rieur de la liste. La seule diff√©rence est que l'ajout de donn√©es, comme indiqu√© ci-dessus, a √©t√© report√© √† une date ult√©rieure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit un √©l√©ment de la liste sans donn√©es, contenant uniquement un pointeur (ou des pointeurs) vers le ou les √©l√©ments voisins. Le code correspondant peut alors √™tre sch√©matiquement repr√©sent√© comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;‚Ä¶m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un √©l√©ment pour une liste li√©e individuellement contient en lui-m√™me un pointeur sur l'√©l√©ment suivant, et rien de plus. La classe de liste est param√©tr√©e par le type de cet √©l√©ment, ce qui implique que ce type sera modifi√© au stade de l'ajout de donn√©es. Il contient des pointeurs vers le premier et le dernier √©l√©ment √† l'int√©rieur. Puisque j'ai initialement cibl√© ce projet pour Windows uniquement, une section critique comme SRWLock est √©galement incluse pour bloquer la liste. Ensuite, les constructeurs, le destructeur, ainsi que toutes les fonctions n√©cessaires pour travailler avec la liste sont d√©finis. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette impl√©mentation contient deux probl√®mes √† la fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier est l'acc√®s libre au contenu des informations de service de l'√©l√©ment. Cela signifie que, apr√®s avoir acc√©d√© √† un n≈ìud, c'est-√†-dire ayant un pointeur sur ce n≈ìud, on peut se r√©f√©rer directement √† l'√©l√©ment suivant ou pr√©c√©dent.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est inacceptable principalement parce que cette transition contourne le verrou et prot√®ge donc la liste. En fait, supposons qu'en ayant un pointeur sur un √©l√©ment pCurr, nous avons enregistr√© la valeur de l'√©l√©ment suivant par rapport √† lui dans le pointeur pNext comme suit: pNext = pCurr-&gt; pNext. Apr√®s cela, nous effectuons une op√©ration longue sur ce n≈ìud pCurr. Dans le m√™me temps, d'autres threads ont supprim√© les √©l√©ments de liste suivants concernant pCurr. Ayant termin√© de travailler avec pCurr, le thread en cours passe √† l'√©l√©ment suivant en utilisant l'ancienne valeur stock√©e dans le pNext local et re√ßoit une erreur d'acc√®s ou un comportement non d√©fini, car l'√©l√©ment √† l'adresse pNext locale n'existe plus et vous devez acc√©der √† la valeur mise √† jour pCurr-&gt; pNext, si l'√©l√©ment actuel √† pCurr, √† son tour,existe √©galement toujours.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux conclusions peuvent √™tre tir√©es de cet exemple pour √©viter cette situation:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depuis l'ext√©rieur de la liste, allez au n≈ìud suivant / pr√©c√©dent et travaillez g√©n√©ralement avec les √©l√©ments de la liste uniquement via les fonctions (m√©thodes) de la classe list qui verrouillent la liste et s√©curisent l'acc√®s √† la liste;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acc√©der aux √©l√©ments d√®s que possible imm√©diatement avant d'y acc√©der (par exemple, obtenir un pointeur vers l'√©l√©ment suivant pNext = list.GetNext (pCurr) pas √† l'avance, mais imm√©diatement avant que la n√©cessit√© de passer au n≈ìud suivant n'apparaisse).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est pourquoi, pour mettre en ≈ìuvre la conclusion du premier paragraphe, l'acc√®s aux pointeurs vers des √©l√©ments adjacents de l'ext√©rieur doit √™tre interdit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxi√®me probl√®me est un peu plus d√©licat. Pour le comprendre, la structure des classes doit √™tre d√©crite plus en d√©tail. La classe de liste est d√©finie en tant que mod√®le et ne fonctionne pas avec les √©l√©ments du type ListElement_OneLinked, mais avec le type ListElement, transmis en tant que param√®tre de mod√®le. Ceci est fait afin de pouvoir cr√©er de nouveaux n≈ìuds avec des donn√©es √† l'int√©rieur de la classe. Pour ce faire, vous devez conna√Ætre le type exact de n≈ìud en cours de cr√©ation. Le type exact du n≈ìud de liste n'est pas encore connu: il sera d√©termin√© ult√©rieurement avec les donn√©es. La fonction de cr√©ation d'√©l√©ment lui alloue de la m√©moire, initialise des pointeurs, puis renvoie un pointeur sur l'√©l√©ment cr√©√© dans la fonction appelante. Ainsi, dans la fonction appelante de la classe d√©riv√©e, il sera possible d'initialiser d'autres propri√©t√©s de l'√©l√©ment sp√©cifiques √† cette classe et d√©finies ult√©rieurement. En d'autres termes,une d√©finition exacte du type du n≈ìud de liste est laiss√©e pour l'avenir, et pour que la liste fonctionne correctement, il est seulement important que ses √©l√©ments contiennent le pointeur pNext, le reste n'a pas d'importance jusqu'√† pr√©sent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, en fonction de ListElement_OneLinked, par h√©ritage par la suite, une nouvelle classe sera cr√©√©e pour l'√©l√©ment avec des donn√©es sp√©cifiques et transmise √† la classe List_OneLinked via le param√®tre de mod√®le. Dans le m√™me temps, une nouvelle classe d√©riv√©e sera cr√©√©e sur la base de List_OneLinked qui d√©finit davantage les op√©rations avec ces nouvelles donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, m√™me cette option n'est pas enti√®rement correcte. Dans les versions ant√©rieures de la classe list, une op√©ration de conversion explicite du type reinterpret_cast &lt;ListElement *&gt; (...) √©tait utilis√©e plusieurs fois. Le fait est que la classe de mod√®le fonctionne avec le type de param√®tre de mod√®le ListElement, qui est d√©riv√© de ListElement_OneLinked / ListElement_TwoLinked. Et dans les fonctions de classe, les variables sont cr√©√©es dans des expressions de type: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pCurr-&gt; pNext est ici un pointeur vers ListElement_OneLinked / ListElement_TwoLinked, en tant que membres des classes de base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sortie: d√©clarez une variable indiquant le type de base explicite ListElement_OneLinked / ListElement_TwoLinked ou convertissez-la explicitement en type d√©riv√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, m√™me une d√©finition explicite du type de base n'est pas correcte, par exemple, dans la fonction de suppression de liste (nettoyage):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous modifiez le type de pointeurs:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cela signifie qu'ils seront supprim√©s par l'op√©ration</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
seules les parties de base de chaque n≈ìud de la liste, ce qui est faux. </font><font style="vertical-align: inherit;">Ou, en option, le pointeur pCurr devra √™tre converti en son type d√©riv√©:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, dans tous les cas, on ne peut pas se d√©barrasser de la transformation explicite reinterpret_cast avec une telle structure de classe, ce qui n'est pas la meilleure solution (plus pr√©cis√©ment, ce qui est vraiment mauvais). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cette raison, afin de se d√©barrasser de ces transformations explicites, il a √©t√© d√©cid√© de changer la classe de base de l'√©l√©ment (pour une liste doublement li√©e - de m√™me):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En bref, cela peut √™tre d√©crit comme suit: l'√©l√©ment de base de la liste contient un pointeur vers un autre √©l√©ment, mais le type de ce pointeur n'est pas encore connu, car il est transmis par le param√®tre de mod√®le (une d√©finition exacte de ce type est laiss√©e pour l'avenir). En d'autres termes: √† ce stade, le type de n≈ìud de liste (c'est-√†-dire ce qu'il sera √† la fin) n'a pas encore √©t√© d√©termin√©, il le sera plus tard. Mais maintenant, nous gardons un pointeur sur un √©l√©ment du type futur, pas encore connu. Le type r√©sultant du n≈ìud de liste est pass√© ici en tant que param√®tre de mod√®le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©sormais, aucune conversion n'est n√©cessaire, car des pointeurs du m√™me type ListElement sont utilis√©s partout - √† la fois dans la classe de liste et dans la classe des n≈ìuds. Le ListElement ici et dans la classe de liste est la classe finale pour l'√©l√©ment avec des donn√©es sp√©cifiques.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que maintenant la classe de liste est devenue aussi abstraite que possible de son contenu sp√©cifique: on sait seulement que ses n≈ìuds contiennent des pointeurs vers d'autres n≈ìuds de ce type, et en utilisant ces informations, toutes les op√©rations de base sur eux avec le verrou multithread correspondant sont effectu√©es dans la classe de liste.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©soudre le probl√®me de l'existence d'un √©l√©ment - une recherche simple (version 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re version √©tait extr√™mement simple et directe et ne d√©passait pas le cadre d√©crit ci-dessus. </font><font style="vertical-align: inherit;">Des pointeurs internes C ++ ont √©t√© utilis√©s, la m√©moire pour les √©l√©ments a √©t√© allou√©e √† l'aide de la nouvelle op√©ration et supprim√©e √† l'aide de la suppression, la liste a √©t√© bloqu√©e sur la section critique qu'elle contient. </font><font style="vertical-align: inherit;">Je ne connaissais pas ou ne soup√ßonnais pas les moyens de la biblioth√®que STL, ni le niveau auquel ils apportent la programmation en C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©j√† √† ce stade, dans la pratique, je suis tomb√© sur le probl√®me de l'existence d'un √©l√©ment d√©crit pr√©c√©demment et j'ai r√©alis√© que le simple verrouillage de la liste ne suffisait pas. </font><font style="vertical-align: inherit;">J'ai parcouru la liste en utilisant les fonctions appropri√©es avec toutes les pr√©cautions, la liste a √©t√© correctement bloqu√©e, mais le programme a quand m√™me r√©ussi √† planter √† diff√©rents intervalles. </font><font style="vertical-align: inherit;">C'est alors que j'ai d√©couvert que la pr√©sence d'un √©l√©ment devait √™tre v√©rifi√©e, ce qui a entra√Æn√© un changement dans la logique des fonctions cl√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de donner un exemple de la fonction d'ajouter un √©l√©ment apr√®s un √©l√©ment donn√©:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit qu'avant de cr√©er un nouvel √©l√©ment, il v√©rifie si l'√©l√©ment sp√©cifi√© est pr√©sent dans la liste en appelant la fonction FindElement (...):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complication suppl√©mentaire des classes de liste multithread - classes de strat√©gie (version 18.02.2019, 11.27.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, le projet visait strictement Windows. Mais √† un moment donn√©, j'ai pens√©, pourquoi ne pas y ajouter de la flexibilit√©? Pourquoi seulement des fen√™tres? Apr√®s tout, la liste a √©t√© essentiellement impl√©ment√©e en C ++ pur, √† partir de Windows, elle n'avait qu'une seule chose: la section critique de SRWLock. √Ä cette √©poque, je m'√©tais d√©j√† familiaris√© avec le concept de cours de strat√©gie. Vous pouvez lire √† ce sujet en d√©tail dans le livre Alexandrescu A. - "Design moderne en C ++". Il d√©crit de nombreuses choses inhabituelles et √©tonnantes qui peuvent √™tre utiles m√™me maintenant, malgr√© le fait que le livre a d√©j√† 12 ans. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un d'eux est les classes de strat√©gies. Les classes de strat√©gies, en fait, sont des changements dans le comportement d'une classe √† travers des mod√®les, comme B. Straustrup l'a mentionn√© dans son c√©l√®bre livre. Seulement dans le livre d'Alexandrescu, ce sujet est largement divulgu√©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que votre classe effectue une action sp√©cifique. </font><font style="vertical-align: inherit;">Vous pouvez prendre la d√©finition de cette action en dehors de la classe, cr√©er une classe distincte bas√©e sur cette action et la transmettre √† votre classe source en tant que param√®tre de mod√®le. </font><font style="vertical-align: inherit;">Cela complique le code, sa lecture et sa compr√©hension, mais il ajoute consid√©rablement de la flexibilit√© √† votre classe: pour remplacer cette action particuli√®re par une autre, similaire, il vous suffit d'√©crire une autre strat√©gie similaire et de la transmettre √† votre classe en tant que param√®tre de mod√®le. </font><font style="vertical-align: inherit;">Le reste du travail sera effectu√© par le compilateur.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strat√©gie de verrouillage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En appliquant cela √† la liste d√©crite, j'ai pris le verrou via SRWLock dans une strat√©gie distincte, puis j'ai √©crit plusieurs autres strat√©gies: via la section critique habituelle de Windows, via les mutex C ++ STL, etc. </font><font style="vertical-align: inherit;">Il sera alors possible d'ajouter des m√©thodes purement sp√©cifiques √† Linux. </font><font style="vertical-align: inherit;">Ainsi, la classe est devenue appropri√©e non seulement pour Windows, mais je peux toujours la reconfigurer tr√®s rapidement pour Windows de mani√®re optimale, simplement en sp√©cifiant la strat√©gie souhait√©e.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strat√©gie de m√©moire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autour de ce point, j'ai √©galement s√©rieusement commenc√© √† √©tudier le STL et parmi les premiers outils de cette biblioth√®que, j'ai fait la connaissance des pointeurs intelligents. </font><font style="vertical-align: inherit;">Et puis j'ai pens√©: pourquoi ne puis-je pas ajouter la prise en charge du pointeur intelligent √† ma liste? </font><font style="vertical-align: inherit;">Ensuite, j'ai retir√© le type de pointeur, ainsi que la cr√©ation et la suppression des donn√©es de l'√©l√©ment de liste dans une strat√©gie distincte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une strat√©gie similaire pour les pointeurs intelligents:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La strat√©gie de m√©moire prend trois param√®tres: le type de l'objet Type, ainsi qu'un allocateur et un suppresseur de m√©moire. En fonction du type de l'objet, la strat√©gie cr√©e un type de pointeur vers ce type - Type * ou std :: shared_ptr, selon la strat√©gie, et propose √©galement les fonctions correspondantes pour cr√©er et supprimer l'objet. Ces fonctions, si nous parlons de distributeurs et de suppresseurs par d√©faut, cr√©ent un objet soit via la nouvelle op√©ration Type, soit via la fonction std :: make_shared (...). Tout cela fonctionne du fait que le d√©r√©f√©rencement du pointeur est le m√™me pour le pointeur int√©gr√© C ++ et le smart std :: shared_ptr. Bien s√ªr, dans le cas d'une liste doublement li√©e et de pointeurs intelligents, pour √©viter la caract√©ristique d√©sagr√©able des pointeurs en boucle, std :: faible_ptr est utilis√© pour les pointeurs vers l'√©l√©ment pr√©c√©dent,et au moment de la compilation pour une liste doublement li√©e, selon la strat√©gie de m√©moire s√©lectionn√©e, vous choisissez comment la d√©r√©f√©rencer (il s'agit d'une nouvelle fonctionnalit√© de C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, maintenant la liste ne cr√©e pas ses propres √©l√©ments: elle redirige l'appel vers la strat√©gie correspondante.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strat√©gie de disponibilit√© des articles</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, j'ai mis la solution au probl√®me de l'existence de l'√©l√©ment dans une strat√©gie distincte: si la liste doit v√©rifier la pr√©sence de certains de ses √©l√©ments, elle redirige simplement l'appel vers la strat√©gie correspondante. La toute premi√®re approche, simple et maladroite, est devenue une strat√©gie de recherche directe DirectSearch. Ensuite, j'ai d√©velopp√© deux autres strat√©gies bas√©es sur les deux approches d√©crites pr√©c√©demment avec un bitmap dans l'ordre de leur description: SearchByIndex_BitArray et SearchByIndex_BitArray2. Pour Windows, pour la possibilit√© d'occuper progressivement la m√©moire avec une image bitmap au fur et √† mesure qu'elle se remplit, il a √©galement ajout√© deux autres strat√©gies: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal et SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme indiqu√© pr√©c√©demment, pour que ces strat√©gies avanc√©es fonctionnent, l'√©l√©ment de liste doit contenir un index dans le bitmap et un pointeur vers la classe de base de la liste (voir ci-dessous), c'est-√†-dire </font><font style="vertical-align: inherit;">a √©t√© d√©fini comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corr√©lation entre les strat√©gies de m√©moire et les strat√©gies de v√©rification des √©l√©ments</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s un examen d√©taill√©, il s'est av√©r√© qu'il existe un pi√®ge dans la relation entre les strat√©gies de m√©moire et les strat√©gies de v√©rification de la pr√©sence d'un √©l√©ment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que vous utilisez des pointeurs intelligents comme strat√©gie de m√©moire, ainsi qu'une strat√©gie utilisant un bitmap pour rechercher rapidement un √©l√©ment dans une liste. Vous supprimez un √©l√©ment, la strat√©gie de m√©moire r√©initialise son pointeur. Cependant, cet √©l√©ment n'est pas r√©ellement supprim√© de la m√©moire, car vous disposez d'un autre pointeur intelligent dans votre programme appelant. √Ä l'avenir, vous vous tournerez vers la liste avec cet √©l√©ment, et il effectuera la v√©rification correctement, en se r√©f√©rant √† ses donn√©es - l'index dans le bitmap et le pointeur vers la liste. Un √©l√©ment n'est r√©ellement supprim√© de la m√©moire que lorsqu'il n'y a plus de lien vers celui-ci.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas le cas lors de l'utilisation de pointeurs int√©gr√©s C ++. Dans ce cas, la strat√©gie de m√©moire </font><font style="vertical-align: inherit;">supprimera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©ellement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cet √©l√©ment de la m√©moire √† l'aide de l'op√©ration de suppression. √Ä l'avenir, vous, comme dans le cas pr√©c√©dent, vous r√©f√©rerez √† la liste avec cet √©l√©ment, et il essaiera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'acc√©der √†</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'√©l√©ment √† cette adresse afin de lire l'index du bitmap et un pointeur vers la liste. Mais vous ne pouvez pas faire cela: un √©l√©ment a d√©j√† √©t√© supprim√© de la m√©moire! Dans le meilleur des cas, vous recevrez une violation d'acc√®s, dans le pire des cas, un comportement non d√©fini lorsque la biblioth√®que C ++, la biblioth√®que d'ex√©cution ou simplement le syst√®me d'exploitation y √©crit une valeur compl√®tement arbitraire que la liste consid√®re et essaie d'√©tablir √† partir d'eux le fait de la pr√©sence d'un √©l√©ment dans la liste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, il s'av√®re que les pointeurs internes ne sont compatibles qu'avec la strat√©gie de v√©rification directe DirectSearch, et les pointeurs intelligents dans ce cas offrent non seulement leur s√©curit√© inh√©rente, mais √©galement une augmentation des performances: ce n'est qu'avec leur utilisation que des tableaux de bits peuvent √™tre utilis√©s qui augmentent consid√©rablement le travail de la liste dans mode multithread! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour garantir la coh√©rence et √©liminer les configurations de strat√©gie incompatibles, j'ai inclus la v√©rification suivante dans chaque classe de liste:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il compare les classes de strat√©gie pass√©es √† la liste et, si elles sont incompatibles, arr√™te la compilation avec la sortie de message d'erreur correspondante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions ou retours d'erreur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, la gestion des erreurs de liste a √©t√© effectu√©e uniquement par le biais d'exceptions. </font><font style="vertical-align: inherit;">Mais d'une mani√®re ou d'une autre, sur un forum dont je ne me souviens pas, j'ai lu que les exceptions ralentissaient le programme, et pour des performances maximales, vous devriez utiliser le retour d'erreur traditionnel. </font><font style="vertical-align: inherit;">Il l'a fait en cr√©ant deux nouvelles classes bas√©es sur les classes originales, en les r√©√©crivant uniquement pour renvoyer des erreurs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste de classe de base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mise en ≈ìuvre des strat√©gies ci-dessus pour v√©rifier la pr√©sence d'√©l√©ments a r√©v√©l√© un probl√®me important. L'√©l√©ment de liste, comme nous nous en souvenons, contient, en plus du num√©ro unique dans cette liste, √©galement un pointeur vers cette liste: apr√®s tout, nous pouvons avoir deux ou plusieurs listes dans le programme, chacune contenant son propre tableau de bits de drapeaux pour la pr√©sence de l'√©l√©ment. Comment s'assurer que cet √©l√©ment appartient √† cette liste particuli√®re et non √† une autre? Uniquement en stockant un pointeur sur la liste enti√®re √† l'int√©rieur de chaque √©l√©ment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me est que maintenant, en ajoutant une vari√©t√© de strat√©gies √† notre classe de liste, nous avons consid√©rablement compliqu√© son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Supposons que nous ayons deux listes diff√©rentes avec le m√™me type d'√©l√©ment et les m√™mes strat√©gies de m√©moire, mais avec des strat√©gies diff√©rentes pour verrouiller et v√©rifier la pr√©sence d'√©l√©ments en elles. Pour le compilateur, il s'agira de deux </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> listes diff√©rents. Pointeur vers quel type stocker dans l'√©l√©ment? De plus, la classe de l'√©l√©ment ne sait pas √† l'avance quelle strat√©gie sera appliqu√©e, elle doit les prendre en compte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelons √©galement que la strat√©gie de blocage, la strat√©gie de v√©rification de la pr√©sence d'un √©l√©ment, et m√™me la connectivit√© (simplement connect√©e ou doublement connect√©e) de la liste se r√©f√®rent uniquement au comportement de la liste elle-m√™me, mais ne se rapportent en aucun cas aux </font><b><font style="vertical-align: inherit;">donn√©es</font></b><font style="vertical-align: inherit;"> qu'elle stocke</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais nous, en tant qu'utilisateurs finaux de cette classe, nous int√©ressons aux donn√©es! </font><font style="vertical-align: inherit;">Donc, d'une part, en utilisant les classes de strat√©gies, nous nous sommes ajout√©s de la flexibilit√©, et d'autre part, nous avons compliqu√© notre vie et ajout√© des probl√®mes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est-il possible de rendre les loups rassasi√©s et les moutons en s√©curit√©? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pouvez. </font><font style="vertical-align: inherit;">Vous pouvez d√©duire des pointeurs vers des donn√©es d'une classe (c'est-√†-dire d'un type) d'une liste. </font><font style="vertical-align: inherit;">En plus des deux niveaux d'organisation de la liste indiqu√©s ci-dessus, un autre est apparu - z√©ro:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, parce que </font><font style="vertical-align: inherit;">de vraies classes de listes en sont h√©rit√©es, si nous voulons acc√©der aux donn√©es de la liste quel que soit son type r√©el, nous devons nous r√©f√©rer √† sa classe de base ListBase. </font><font style="vertical-align: inherit;">Nous avons acc√®s au d√©but et √† la fin de la liste, puis travaillons avec ses donn√©es comme nous le souhaitons. </font><font style="vertical-align: inherit;">Le type sp√©cifique de liste, ainsi que la combinaison de strat√©gies utilis√©es, n'a pas d'importance.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It√©rateurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©j√† en plein essor en travaillant √©troitement avec STL dans un vrai projet (pas le mien :)), tout en continuant √† l'√©tudier dans les livres, j'ai attir√© l'attention sur la boucle for de la collection. </font><font style="vertical-align: inherit;">Apr√®s tout, ce cycle ne fait pas seulement partie de la STL, il est d√©j√† devenu une partie interne de la langue. </font><font style="vertical-align: inherit;">J'ai pens√© que je pourrais √©galement ajouter un support pour cela dans mon projet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, vous devez ajouter la prise en charge des it√©rateurs, en faisant abstraction de la mani√®re sp√©cifique de travailler avec des pointeurs et de parcourir la liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple d'it√©rateur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, il est devenu possible d'√©crire comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(‚Ä¶)<font></font>
{<font></font>
      ‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue a un type de pointeur sur un √©l√©ment de liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, j'ai inclus la prise en charge des it√©rateurs uniquement sur les listes prises en charge par les exceptions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison √©tait simple: puisque le code √† l'int√©rieur de la boucle n'est pas disponible, il n'est pas possible de g√©rer correctement les erreurs. </font><font style="vertical-align: inherit;">Il ne reste plus qu'√† g√©rer les exceptions en encapsulant la boucle dans un bloc try. </font><font style="vertical-align: inherit;">En g√©n√©ral, parcourir la liste de cette mani√®re lorsque d'autres threads travaillent intensivement avec elle n'est pas une bonne id√©e: il est pr√©f√©rable de bloquer la liste vous-m√™me, puis de la parcourir calmement en mode monotrame. </font><font style="vertical-align: inherit;">Mais encore, si pour une raison quelconque vous voulez faire exactement la m√™me chose que dans l'exemple ci-dessus, alors il y a maintenant une opportunit√© pour cela.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une g√©n√©ralisation de la strat√©gie de v√©rification de la pr√©sence d'un √©l√©ment sur un conteneur arbitraire; </font><font style="vertical-align: inherit;">it√©rateurs pour les listes sans exception</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, j'avais initialement pr√©vu (et je pr√©vois toujours) de cr√©er non seulement une liste multi-thread, mais aussi un arbre. Pour certains de leurs besoins. Le graphique est √©galement possible, mais d'une part, je n'en avais pas besoin, et d'autre part, le graphique est une chose compliqu√©e avec des algorithmes tr√®s non triviaux, et je ne voulais pas m'y plonger sans besoin particulier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la version initiale, la strat√©gie de v√©rification de la pr√©sence d'un √©l√©ment n'√©tait orient√©e que vers la liste, et ses fonctions acceptaient un pointeur vers un √©l√©ment et un pointeur vers la classe de base de la liste (ListBase *). Par la suite, j'ai pens√©: mais dans le cas d'un arbre, il faut faire exactement la m√™me chose! Faites une strat√©gie distincte, mais essentiellement la m√™me?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution √©tait simple: ignorer la liste. </font><font style="vertical-align: inherit;">Cela signifiait que maintenant l'entr√©e serait re√ßue non pas par des pointeurs vers des √©l√©ments, mais par des it√©rateurs. </font><font style="vertical-align: inherit;">Et les fonctions deviendront passe-partout pour accepter des pointeurs vers un conteneur de tout type appropri√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors maintenant, la fonction d'origine, par exemple l'enregistrement d'une liste dans un bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transform√© en une fonction d'enregistrement de conteneur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La transition √† travers la liste par des pointeurs a √©t√© transform√©e en transition √† travers un conteneur abstrait utilisant des it√©rateurs. </font><font style="vertical-align: inherit;">Maintenant, il suffira que l'arbre impl√©mente ses it√©rateurs, et son soutien avec ces strat√©gies sera d√©j√† fourni. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela a n√©cessit√© le retour des it√©rateurs dans les listes sans exception, mais en les rendant inaccessibles de l'ext√©rieur et destin√©s uniquement √† un usage interne.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptateur de donn√©es</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant travaill√© de mani√®re assez intensive avec STL, ainsi qu'en tapant, en lan√ßant et en √©tudiant des programmes de formation √† partir de livres, j'ai attir√© l'attention sur la simplicit√© de travailler avec des conteneurs STL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, faites attention au code suivant:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je cr√©e un vecteur en lui passant le type dont j'ai besoin, et c'est tout! Le conteneur est imm√©diatement pr√™t √† fonctionner, si je n'ai pas besoin de modifier certains param√®tres suppl√©mentaires d√©finis par d√©faut, ce qui n'arrive le plus souvent pas! Pour moi, en partant de l'organisation √† trois niveaux de la liste, dans chaque cas, je devrais d'abord cr√©er une nouvelle classe pour l'√©l√©ment, puis √©crire une classe pour la liste avec des donn√©es, en mettant en ≈ìuvre des op√©rations sp√©cifiques √† la liste finale. Imaginez combien de travail! Et si vous avez besoin de cr√©er une autre liste pour d'autres donn√©es, vous devez tout recommencer ou, dans les cas extr√™mes, copier le code pr√©c√©dent, en le modifiant l√©g√®rement. Cela ressemble d√©j√† au m√™me probl√®me avec le langage C et l'API Windows, o√π pour chaque action √©l√©mentaire, vous devez remplir toutes les donn√©es n√©cessaires pour la structure, puis appeler la fonction souhait√©e. Et soit gardez tout cela √† l'espritOu lisez √©galement en permanence MSDN, en √©tudiant les arguments de chaque nouvelle fonction! Routine et terriblement inconfortable!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai commenc√© √† chercher des moyens d'avoir l'opportunit√© de cr√©er ma liste par analogie avec les conteneurs STL afin de ne pas avoir √† faire la m√™me t√¢che √† chaque fois: cr√©er une classe distincte pour tout nouvel √©l√©ment, puis une classe distincte pour travailler avec des √©l√©ments de cette type. </font><font style="vertical-align: inherit;">Il y avait donc un adaptateur pour une liste de donn√©es. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un adaptateur pour une liste avec des donn√©es est une classe, dans les param√®tres de mod√®le dont vous transmettez imm√©diatement le type de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donn√©es dont</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous avez besoin </font><font style="vertical-align: inherit;">, et non l'√©l√©ment. </font><font style="vertical-align: inherit;">Le type d'√©l√©ment, que j'ai appel√© le type composite de l'√©l√©ment, sur la base de ces donn√©es qu'il cr√©e de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lui-m√™me</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre point qui m√©rite d'√™tre mentionn√© est l'acc√®s aux donn√©es de l'article. </font><font style="vertical-align: inherit;">Le type d'√©l√©ment contient l'op√©ration "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que s'il y a un pointeur vers l'√©l√©ment pElement, alors pour acc√©der aux donn√©es qui y sont stock√©es, il doit √™tre d√©r√©f√©renc√© deux fois:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois - pour acc√©der √† un objet de type ListElementCompound_OneLinked par son pointeur: ListElementCompound_OneLinked &amp; le = * pCurrElement, et une deuxi√®me fois - pour acc√©der aux donn√©es via l'op√©ration '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela semble tr√®s √©trange et atypique, mais on suppose que vous ne travaillerez pas √† l'aide de pointeurs (pour cela, vous disposiez d√©j√† d'une version initiale pr√™te √† l'emploi), mais √† travers des it√©rateurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, lorsque vous cr√©ez une liste bas√©e sur l'adaptateur, vous sp√©cifiez les strat√©gies dont vous avez besoin, comme c'√©tait le cas auparavant. </font><font style="vertical-align: inherit;">En fonction de tous vos param√®tres, l'adaptateur cr√©e automatiquement les types n√©cessaires et les transmet √† la liste interne de base, dont il est h√©rit√©. </font><font style="vertical-align: inherit;">D√©finition g√©n√©rale de la classe:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sp√©cialisation pour la liste avec exceptions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il a l'air tr√®s volumineux, √† plusieurs √©tages et laid. Je connais. Mais alors cette d√©finition fait automatiquement tout ce qui est n√©cessaire, sans la participation directe du programmeur qui pr√©voit de l'utiliser. √Ä l'aide de std :: conditional_t ‚Äã‚Äãet std :: is_same_v, la strat√©gie de v√©rification de la pr√©sence d'un √©l√©ment que vous avez transmis est compar√©e aux strat√©gies de recherche directe et, selon le r√©sultat, le type correspondant de l'√©l√©ment de liste est s√©lectionn√©: avec un index dans le bitmap et un pointeur vers la liste ou sans . Cela vous fera √©conomiser de la m√©moire en raison de donn√©es suppl√©mentaires inutiles √† l'int√©rieur de chaque n≈ìud si vous utilisez une strat√©gie de recherche directe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'int√©rieur de la classe, seuls les it√©rateurs qui lui sont sp√©cifiques sont impl√©ment√©s, ainsi que les fonctions push_back () / push_front () requises par analogie avec STL, qui redirigent les appels vers la liste multi-thread de base. </font><font style="vertical-align: inherit;">Vous pouvez ajouter d'autres fonctions plus tard, de sorte que la liste devienne tr√®s similaire aux STL. </font><font style="vertical-align: inherit;">Mais en m√™me temps, ce sera avec toutes les protections et options n√©cessaires pour augmenter la productivit√© dans un environnement multi-thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Travailler avec un adaptateur de donn√©es a commenc√© √† ressembler √† ceci. </font><font style="vertical-align: inherit;">Cr√©ation d'objets de liste:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous √™tes satisfait de toutes les strat√©gies et param√®tres par d√©faut, la cr√©ation d'une liste devient tr√®s br√®ve:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, ext√©rieurement, il n'y a absolument aucune diff√©rence par rapport √† STL, sauf que le nom de la classe de liste est diff√©rent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez maintenant travailler avec lui comme √† l'ancienne, via les fonctions de la classe de base:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, les nombres de 0 √† 3 sont ajout√©s s√©quentiellement √† la fin de la liste. Pour acc√©der √† l'argument transmis au constructeur du type cr√©√© lors de sa cr√©ation, vous devez explicitement noter les valeurs des trois premiers arguments.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, il y a un certain inconv√©nient √† indiquer explicitement le type, mais cela est la cons√©quence d'une tentative d'acc√©der √† nouveau √† la liste via la fonction pr√©c√©dente pour travailler avec des pointeurs. </font><font style="vertical-align: inherit;">Si vous ajoutez la fonction back () √† l'adaptateur, qui retourne un it√©rateur, alors son utilisation n'aura pas un tel probl√®me:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir ajust√© les it√©rateurs aux exigences de STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
il devient possible d'utiliser la liste dans les algorithmes de biblioth√®que:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
‚Ä¶<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, vous devrez organiser l'interception et la gestion des exceptions: tous les exemples ci-dessus sont destin√©s √† travailler dans un seul thread afin de tester la compatibilit√© avec STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation d'algorithmes STL rend un point int√©ressant possible: vous pouvez utiliser plusieurs algorithmes √† la fois, en les ex√©cutant dans plusieurs threads en parall√®le. Cela ne peut pas √™tre fait par des moyens conventionnels (par exemple, en utilisant std :: list et des moyens de blocage) sans avoir acc√®s au contenu interne de la classe list. Il n'a √©t√© possible de bloquer la liste enti√®re que pour la dur√©e de l'algorithme entier. Bien s√ªr, cela acc√©l√©rera le travail du thread ex√©cutant l'algorithme, mais rendra la liste inaccessible aux autres threads. Cependant, si vous appliquez le m√™me verrou SRWLock ¬´fin¬ª, vous pouvez ex√©cuter plusieurs algorithmes sur la liste en m√™me temps, s'ils ne modifient pas cette liste. Mais le premier thread √† √©crire restera debout en attendant la fin de l'op√©ration de lecture de la liste par tous les autres threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'option de liste propos√©e vous permet d'organiser le travail avec elle de mani√®re plus flexible. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez organiser le travail avec la liste de sorte que les algorithmes non modificateurs de la premi√®re moiti√© de la liste soient ex√©cut√©s par plusieurs threads en m√™me temps, tandis qu'un certain nombre d'autres threads peuvent ajouter ou modifier quelque chose dans la seconde moiti√© de la liste. </font><font style="vertical-align: inherit;">Le fait que la liste soit bloqu√©e pendant la dur√©e d' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op√©ration, et non l'ensemble de l'algorithme, permettra l '"√©criture" des op√©rations d'√©criture √† travers la s√©quence d'op√©rations de lecture de la liste, ce qui rendra le travail avec elle plus flexible, productif et efficace.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinaison de deux variantes de classes de liste avec et sans support d'exception en une seule avec un param√®tre bool√©en</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, les listes ne comportaient que des exceptions. </font><font style="vertical-align: inherit;">Ensuite, j'en ai ajout√© de nouvelles - aucune exception avec retour d'erreur, et j'ai renomm√© les anciennes avec l'ajout de la lettre ¬´E¬ª dans le nom de la classe: List_OneLinked_E et List_TwoLinked_E. </font><font style="vertical-align: inherit;">Cela n√©cessitait d'indiquer quatre d√©clarations de la classe de liste partout. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai alors d√©cid√© que cela ne convenait pas pour de nombreuses raisons. </font><font style="vertical-align: inherit;">Pourquoi avons-nous besoin de deux classes compl√®tement diff√©rentes si c'est la m√™me liste avec ou sans support d'exception? </font><font style="vertical-align: inherit;">J'ai combin√© les deux listes de chaque type dans une seule classe avec un param√®tre bool√©en suppl√©mentaire, et leur impl√©mentation sp√©cifique avec et sans exceptions sont deux sp√©cialisations d'une classe unique pour le param√®tre bool√©en sp√©cifi√©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op√©ration de fusion de liste de mod√®les</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'op√©ration de mod√®le consistant √† combiner des listes ne fonctionnait auparavant qu'avec des listes du m√™me type. Il ne combinait que des listes connect√©es individuellement ou uniquement des listes connect√©es deux fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si vous y r√©fl√©chissez, peu importe le type de listes impliqu√©es dans l'op√©ration: simplement connect√©es ou doublement connect√©es. Leurs strat√©gies de blocage sont √©galement sans importance, quelle est leur strat√©gie pour v√©rifier l'existence d'√©l√©ments, et si elles prennent en charge la gestion des exceptions ou non. Tout cela ne s'applique qu'√† l'organisation de la liste, mais pas aux donn√©es qu'elle contient. Il est important que seuls le type de donn√©es et la strat√©gie de m√©moire des √©l√©ments correspondent. En cons√©quence, maintenant, apr√®s avoir combin√© des listes avec un param√®tre bool√©en concernant les exceptions, l'op√©ration d'entr√©e accepte des listes de tout type avec toutes les variantes de leurs param√®tres:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, en raison du type de liste, le compilateur s√©lectionne, en fonction du r√©glage du param√®tre externe ce_bGetMinLinksList, une liste avec une connectivit√© minimale ou maximale et, selon cette solution, ses param√®tres correspondants sont utilis√©s:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base des param√®tres s√©lectionn√©s, une liste de r√©sultats est cr√©√©e:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, sur cette liste, les pointeurs sont d√©finis au d√©but de la premi√®re et √† la fin de la deuxi√®me liste:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, les listes pr√©c√©dentes sont effac√©es et la fonction se ferme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le point faible de cette fonction est le double verrouillage des listes avec des blocages potentiels:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez introduire une fonction pour verrouiller simultan√©ment deux listes en une seule op√©ration atomique comme std :: lock (mutex1, mutex2), cependant, toutes les strat√©gies de verrouillage ne prennent pas en charge le verrouillage simultan√© de deux objets de synchronisation, comme std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, deux listes peuvent avoir des strat√©gies de verrouillage diff√©rentes. </font><font style="vertical-align: inherit;">La solution √† ce probl√®me (s'il existe) est laiss√©e √† l'avenir.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilation Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compilation a √©t√© v√©rifi√©e via le projet ListDataAdapterTest, √©crit √† l'origine en C ++ pur sans fonctionnalit√©s sp√©cifiques √† Windows, sur Linux Ubuntu 16.04 LTS, le compilateur g ++ 8.2.0. La plupart des nuances mineures ont √©t√© faciles √† corriger et le projet a √©t√© compil√© avec succ√®s, et la sortie du programme a co√Øncid√© avec la m√™me sortie sous Windows. Cependant, c'est le cas si vous commentez la ligne de combinaison des listes via l'op√©ration "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le laissez tel quel, une erreur de compilation se produira dans l'op√©ration ¬´+¬ª d√©crite ci-dessus, comme si elle n'avait pas √©t√© d√©clar√©e privil√©gi√©e dans la classe de l'√©l√©ment composite de la liste. Une erreur similaire se produit dans la classe de strat√©gie de v√©rification directe pour l'√©l√©ment DirectSearch. Dans Visual C ++, tout va bien ici, cependant, ces m√™mes erreurs apparaissent si dans la classe d'√©l√©ment composite et dans la classe list le commentaire sur la d√©claration de l'op√©ration de combinaison des listes et de DirectSearch en tant que privil√©gi√© est mis en commentaire. Il semble que g ++ ignore simplement ces d√©clarations et se plaint des membres priv√©s / prot√©g√©s des classes correspondantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Dans g ++ version 9 (Ubuntu 20.04), les m√™mes erreurs.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi les annonces de privil√®ges sont ignor√©es et comment y rem√©dier, je n'ai pas compris. </font><font style="vertical-align: inherit;">Je ne suis pas bon dans les fonctionnalit√©s du compilateur GCC. </font><font style="vertical-align: inherit;">A laiss√© ce moment aussi pour l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hormis cette nuance, il n'y a pas d'autre grave erreur de compilation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description de la structure du fichier d'en-t√™te</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chers lecteurs, j'ai publi√© le projet √† part enti√®re sous licence LGPL 3.0 sur GitHub √†: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il s'agit d'une solution compos√©e de plusieurs projets de test. </font><font style="vertical-align: inherit;">Le code principal d'une liste multithread, de par sa mise en ≈ìuvre via des mod√®les, se trouve dans plusieurs fichiers d'en-t√™te:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - la classe de base d'une liste sans donn√©es, qui impl√©mente toutes les op√©rations de base avec une liste, possible sans d√©finir de donn√©es sp√©cifiques, ainsi que des adaptateurs STL similaires pour les donn√©es.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - versions de la liste avec prise en charge des exceptions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - d√©finition des classes de base pour un √©l√©ment de liste.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - d√©finition des codes et des classes d'erreur pour les exceptions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus des fichiers principaux r√©pertori√©s, les √©l√©ments suivants sont √©galement impl√©ment√©s:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - strat√©gies pour travailler avec la m√©moire;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - strat√©gies de blocage.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - strat√©gies de v√©rification de la pr√©sence d'un √©l√©ment dans la liste, d√©crites de mani√®re abstraite pour tout conteneur avec it√©rateurs.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus du projet final, j'ai √©galement ajout√© trois anciennes versions dans le dossier ¬´Anciennes versions¬ª, afin que vous puissiez √©valuer bri√®vement comment le projet a chang√© au fur et √† mesure de son d√©veloppement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essai</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet principal, appel√© List, est un programme avec une interface pour Windows qui est impl√©ment√©e de mani√®re hardcore via l'API Windows (je ne sais pas comment faire autrement). Dans ce programme, vous s√©lectionnez le type de liste (simplement connect√© ou doublement connect√©), et indiquez √©galement le nombre initial d'√©l√©ments et le nombre souhait√© de threads. Les √©l√©ments de liste contiennent une seule valeur 64 bits. Apr√®s avoir cr√©√© une liste, le programme de chaque thread de la boucle passe en avant ou en arri√®re dans la liste √† un nombre al√©atoire d'√©l√©ments, puis ajoute ou supprime un √©l√©ment. Aucun v√©ritable travail utile n'est effectu√© √† travers cette liste, et toute l'√©nergie est d√©pens√©e pour chauffer l'atmosph√®re, mais ce n'est pas n√©cessaire: il suffit d'√©valuer l'op√©rabilit√© et les performances de la liste dans un environnement multi-thread intensif.La mesure des performances est le nombre d'it√©rations du cycle ci-dessus par seconde, effectu√©es par tous les threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste est √©tablie en indiquant les strat√©gies appropri√©es dans le code du programme, puis en recompilant. Toutes les strat√©gies du programme principal sont sp√©cifi√©es dans le module principal ListMain.cpp, la strat√©gie de m√©moire est s√©lectionn√©e dans ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'une mani√®re g√©n√©rale, j'ai exp√©riment√© un peu avec des exp√©riences. J'avoue honn√™tement. Principalement parce que dans certains cas, la liste des articles change consid√©rablement. Pour que la puret√© de l'exp√©rience mesure les performances, il serait n√©cessaire de mettre un test de telle sorte que le nombre d'√©l√©ments en moyenne ne change pas au cours de la p√©riode d'√©tude ou change de mani√®re extr√™mement insignifiante. Ce n'est que dans ces conditions qu'il serait juste d'√©valuer la valeur de la productivit√© sur la base de la valeur moyenne. Si quelqu'un est int√©ress√©, je propose d'organiser de telles exp√©riences par lui-m√™me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas corrig√© l'organisation initiale des tests pour les raisons suivantes. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, j'√©tais juste paresseux.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tout d'abord, √† mon avis, personne ne s'int√©resse aux valeurs quantitatives exactes de la performance</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec erreur calcul√©e</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : il est important d'√©valuer les performances et les performances de la liste de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mani√®re qualitative</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deuxi√®mement, cela vous permet d'√©valuer l'√©volution de la performance de la liste avec la croissance de son volume, ce qui est √©galement une information assez importante et int√©ressante. </font><font style="vertical-align: inherit;">Pour ces raisons, je n'ai pas chang√© les exp√©riences originales. </font><font style="vertical-align: inherit;">Troisi√®mement, le m√™me code de test est effectu√© sur toutes les variantes de la liste, ce qui les place en ce sens dans les m√™mes conditions: le fait qu'elles se comportent diff√©remment dans ce cas permet de juger de la qualit√© des changements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour activer la mesure des performances, d√©finissez l'indicateur ce_bPerformanceMeasure dans le module ListMain.cpp sur true. </font><font style="vertical-align: inherit;">Le programme cr√©era un fichier ¬´PerformanceMeasure.txt¬ª avec des paires ¬´nombre d'√©l√©ments - nombre de cycles / sec¬ª, s√©par√©s par un symbole ¬´:¬ª.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultats de la mesure du rendement</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, je n'ai pas effectu√© de tests pour toutes les configurations possibles de la liste, car il y en a beaucoup. </font><font style="vertical-align: inherit;">Je me suis concentr√© uniquement sur les principaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des tests ont √©t√© effectu√©s sur ma commande de la configuration Intel Core i7-3930K, DDR3-1333, contr√¥leur de m√©moire √† 4 canaux d√©j√† obsol√®te mais toujours tr√®s dynamique. </font><font style="vertical-align: inherit;">La compilation a √©t√© effectu√©e via Visual Studio 2019 pour le mode Release x64, le syst√®me d'exploitation Windows 7 x64. </font><font style="vertical-align: inherit;">Je n'ai pas jou√© avec le nombre de threads, donc dans tous les tests, le maximum de 12 threads disponibles dans ce syst√®me ont toujours √©t√© utilis√©s. </font><font style="vertical-align: inherit;">Une liste a toujours √©t√© cr√©√©e avec 10 000 √©l√©ments s√©lectionn√©s au hasard, √† l'exception du dernier test.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test de strat√©gie de m√©moire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant des pointeurs int√©gr√©s, comme je l'ai mentionn√© pr√©c√©demment, seule une strat√©gie de recherche directe peut √™tre utilis√©e pour v√©rifier la pr√©sence d'un √©l√©ment dans la liste. Par cons√©quent, pour que la comparaison soit correcte et pour les pointeurs intelligents, seule cette strat√©gie sera appliqu√©e dans ce test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que strat√©gie de verrouillage, une section critique avec un verrou fin a √©t√© s√©lectionn√©e comme la plus productive de Windows (voir ci-dessous): ThreadLockingWin_SRWLock. La gestion des erreurs est effectu√©e en renvoyant un code d'erreur, c'est-√†-dire option sans exception. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce graphique montre le nombre de cycles effectu√©s par tous les threads au total par seconde, en fonction de la dur√©e du test (en secondes). De toute √©vidence, les performances sont incoh√©rentes en raison de la nature al√©atoire des threads acc√©dant √† la liste.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxi√®me graphique montre comment le nombre d'√©l√©ments de liste change pendant le test. Je ne ferai aucune d√©claration r√©fl√©chie sur ce calendrier, sauf pour l'√©vidence: il est clair qu'ils fonctionnent de mani√®re l√©g√®rement diff√©rente, et la connectivit√© de la liste avec la strat√©gie de m√©moire a un effet. Une liste doublement li√©e avec des pointeurs internes est la seule qui, de fa√ßon inattendue, ne change pas de taille moyenne sur toute la dur√©e du test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Productivit√© moyenne (cycles / s) pour la p√©riode mesur√©e:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut au moins affirmer que l'option de liste avec des pointeurs intelligents est plus lente que la version avec des pointeurs int√©gr√©s, ce qui est normal. </font><font style="vertical-align: inherit;">Dans les deux cas, il s'av√®re en quelque sorte qu'un seul connect√© est plus rapide qu'un double connect√©, ce qui montre une fois de plus qu'en mode multithread, de nombreuses choses famili√®res peuvent changer.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test des strat√©gies de disponibilit√© des articles</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus int√©ressant est de tester des strat√©gies pour v√©rifier la pr√©sence d'un √©l√©ment. En tant que strat√©gie de m√©moire, les pointeurs intelligents sont naturellement indiqu√©s pour les raisons pr√©c√©demment d√©crites. Le reste est le m√™me: verrouillage avec ThreadLockingWin_SRWLock et gestion des erreurs en renvoyant un code d'erreur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons affirmer avec certitude que toutes les strat√©gies fonctionnent √† peu pr√®s de la m√™me mani√®re. Cela est compr√©hensible: dans une liste li√©e individuellement, lorsque vous supprimez son √©l√©ment, vous devez √† chaque fois consulter la liste jusqu'√† l'√©l√©ment qui indique l'√©l√©ment √† supprimer. Cela annule tous les efforts pour optimiser l'acc√®s √† la liste et acc√©l√©rer la v√©rification de la pr√©sence d'un √©l√©ment dans celle-ci. Par cons√©quent, une liste li√©e individuellement n'est pas le meilleur choix pour un travail multithread d√©sordonn√© intensif avec elle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne donnerai pas de graphique sur le nombre d'√©l√©ments: il n'y a rien d'int√©ressant l√†-bas. Je note seulement que maintenant le nombre d'√©l√©ments dans toutes les listes augmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une situation compl√®tement diff√©rente se pose pour une liste doublement cha√Æn√©e. Pour que les graphiques soient beaux, j'en ai m√™me exclu la strat√©gie de visualisation directe de la liste DirectSearch, car par les r√©sultats, elle ¬´tombe¬ª clairement du reste. De plus, j'ai augment√© le nombre limite d'√©l√©ments de 4 fois, atteignant lequel, le test s'arr√™te.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, les performances d'acc√®s √† la liste (ainsi que la charge du processeur, devenant de 99 √† 100%) ont augment√© de mani√®re spectaculaire et significative! Deuxi√®mement, une paire de strat√©gies avec remplissage s√©quentiel de bits de matrice a approximativement les m√™mes performances qui ne changent pas pendant le test. La vitesse de la deuxi√®me paire de strat√©gies diminue de fa√ßon non lin√©aire. Pourquoi il en est ainsi, il deviendra clair √† partir du graphique pour le nombre de n≈ìuds dans la liste.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les listes avec la premi√®re paire de strat√©gies augmentent en nombre d'√©l√©ments, et de fa√ßon lin√©aire. La deuxi√®me paire donne une croissance significativement non lin√©aire, et plus le nombre d'√©l√©ments a une liste, plus elle se d√©veloppe lentement. C'est compr√©hensible puisque avec une augmentation du nombre d'√©l√©ments lors de la cr√©ation d'un nouvel √©l√©ment, il est en moyenne n√©cessaire de parcourir un plus grand nombre de bits du tableau √† la recherche de free. La premi√®re paire de strat√©gies ne traite pas cela, elle utilise un nouveau bit pour chaque nouvel √©l√©ment. Ainsi, une liste avec une telle strat√©gie a des performances d'acc√®s maximales et est la plus proche de la liste classique: √† la fois la cr√©ation et la suppression d'√©l√©ments sont effectu√©es en un temps constant, ind√©pendamment du nombre d'√©l√©ments. Cependant, il offre certaines garanties d'int√©grit√© et de s√©curit√© dans un environnement multi-thread, bien qu'au prix d'une certaine quantit√© de m√©moire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste avec la deuxi√®me paire de strat√©gies est bien s√ªr beaucoup plus lente. Cependant, il est encore beaucoup plus rapide que les options de v√©rification directe. Vous pouvez donc vraiment le recommander comme un interm√©diaire dans les performances, mais plus optimal en termes de consommation de m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, les listes avec une strat√©gie de recherche directe fonctionneront √©galement plus lentement avec une augmentation du nombre d'√©l√©ments en elles: un plus grand nombre d'√©l√©ments devra √™tre visualis√© √† chaque fois. C'est juste que pendant le test, la liste n'arrive pas √† s'allonger tellement qu'elle devient perceptible malgr√© les fluctuations chaotiques des performances.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs de performance moyennes montrent que les strat√©gies avec un bitmap lors de son remplissage s√©quentiel ont permis d'augmenter la productivit√© de l'acc√®s √† la liste d'environ 200 fois, c'est-√†-dire </font><font style="vertical-align: inherit;">2 ordres de grandeur par rapport aux strat√©gies de recherche directe. </font><font style="vertical-align: inherit;">Il s'agit d'un changement tr√®s radical. </font><font style="vertical-align: inherit;">Les performances des options avec un remplissage de bits optimal en m√©moire, comme indiqu√© ci-dessus, sont bien s√ªr beaucoup plus lentes, mais toujours beaucoup plus rapides que les options avec v√©rification directe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient √©galement de noter que l'utilisation d'un m√©canisme de transfert de m√©moire √† la demande ralentit quelque peu l'acc√®s √† la liste. </font><font style="vertical-align: inherit;">Pas trop critique, mais l'effet est pr√©sent et perceptible, surtout - dans la variante avec l'utilisation √©conomique de la m√©moire (ligne jaune sur les graphiques).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test de strat√©gie de blocage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment les performances de la liste changeront lors du choix de diff√©rentes strat√©gies de verrouillage. </font><font style="vertical-align: inherit;">J'ai utilis√© trois types de verrous: le verrou ¬´mince¬ª SRWLock, la section critique Windows standard et le mutex STL. </font><font style="vertical-align: inherit;">Pour le reste des param√®tres, la version la plus rapide de la liste a √©t√© utilis√©e: biconnect√©s, pointeurs intelligents, la strat√©gie de v√©rification de la pr√©sence d'un √©l√©ment - SearchByIndex_BitArray, une variante sans exception. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous vous en doutez, un verrou ¬´fin¬ª augmente les performances de pr√®s de 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vitesse de travail avec la section critique de Windows et le mutex STL est √† peu pr√®s la m√™me.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √©valuer l'impact des exceptions sur les performances, j'ai effectu√© trois tests. </font><font style="vertical-align: inherit;">Les deux premiers ont utilis√© une liste doublement li√©e, des pointeurs intelligents, une strat√©gie de v√©rification de pr√©sence d'√©l√©ment - SearchByIndex_BitArray, une section critique de SRWLock. </font><font style="vertical-align: inherit;">Le m√™me test a √©t√© utilis√© pour le dernier test, seul le verrou a √©t√© remplac√© par la section critique habituelle pour comparaison. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut voir que la prise en charge des exceptions peut vraiment r√©duire la vitesse de travail, surtout si vous utilisez une option de blocage plus ¬´grossi√®re¬ª. </font><font style="vertical-align: inherit;">Cependant, n'oubliez pas que dans ce cas, la prise en charge de STL et des boucles de la collection ne sera pas disponible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultats</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce fut une exp√©rience √† tr√®s grande √©chelle pour moi. Je ne parle pas des tests ci-dessus, mais de l'ensemble du projet. Il ne s'attendait pas √† ce qu'il soit ainsi entra√Æn√©. N√©anmoins, je l'ai r√©alis√© compl√®tement et dans la mesure o√π je l'avais pr√©vu. Bien s√ªr, au final, ce n'est toujours pas la version finale, mais seulement un prototype fonctionnel, la mise en ≈ìuvre des id√©es d√©crites au d√©but de l'article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon les r√©sultats du test, il est clair que sous Windows, il s'est av√©r√© √™tre la liste doublement li√©e la plus rapide avec des pointeurs intelligents, une strat√©gie pour v√©rifier la pr√©sence de l'√©l√©ment SearchByIndex_BitArray, une section critique de SRWLock et aucune exception. Dans cette configuration, la liste fournit des performances maximales avec un acc√®s chaotique intensif √† partir de divers threads et le comportement est le plus proche de la liste classique avec des garanties de s√©curit√© en mode multithread. L'option avec une consommation de m√©moire plus √©conomique est √©galement tr√®s productive (par rapport √† la v√©rification directe DirectSearch), mais elle est toujours sensiblement plus lente que la pr√©c√©dente, et ses performances diminuent avec une augmentation du nombre d'√©l√©ments.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous pensez que je vais faire campagne ici pour ce que j'ai fait de cool et √† quel point c'est g√©nial de l'utiliser, alors non: en fait, je vais commencer par vous d√©courager. </font><font style="vertical-align: inherit;">En effet:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©fl√©chissez s'il est possible d'utiliser un conteneur avec une disposition diff√©rente des √©l√©ments: par exemple, un tableau. </font><font style="vertical-align: inherit;">Il n'a pas de probl√®mes comme une liste.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    ‚Äì       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   ‚Äì     .    . ,   ‚Äì          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les strat√©gies de transfert de m√©moire sur un tableau de bits √† la demande rapproche √©galement au moins partiellement une liste multithread √† la liste classique: au moins jusqu'√† ce que le tableau de m√©moire soit compl√®tement plein, il en faudra exactement autant que n√©cessaire. </font><font style="vertical-align: inherit;">Cependant, cela entra√Æne une r√©duction des performances.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Inconv√©nients du projet:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La possibilit√© pr√©c√©demment not√©e de blocage mutuel dans l'op√©ration de combinaison de listes.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'esp√®re que c'√©tait int√©ressant. Les d√©butants peuvent √™tre utiles, car tout est consid√©r√© du simple au complexe. Je demande aux professionnels de dire dans quelle mesure, √† votre avis, les id√©es d√©crites ici sont applicables en pratique dans des projets r√©els? Y a-t-il eu un cas dans votre activit√© o√π, en termes de signification, vous aviez besoin d'une liste ou d'un arbre, et non d'un autre conteneur, mais qui est devenu un goulot d'√©tranglement dans votre programme en raison des probl√®mes d√©crits ici? Ou vous avez d√ª modifier ou compliquer consid√©rablement le programme. Si vous l'avez d√©j√† rencontr√©, comment avez-vous r√©solu cela?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, par essence, ce projet n'est que la r√©alisation de ma propre vision de la solution de ce probl√®me. </font><font style="vertical-align: inherit;">Il est probable qu'il existe une meilleure option. </font><font style="vertical-align: inherit;">Je r√©p√®te la pens√©e depuis le d√©but que je l'ai fait initialement pour moi-m√™me et que je n'avais pas l'intention de le mettre en exposition publique. </font><font style="vertical-align: inherit;">Mais quand m√™me, je l'ai fait pour les raisons qui y sont d√©crites, je serai donc ravi des critiques constructives. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avec un examen attentif du code, vous pouvez rencontrer une telle conception:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette magie noire m√©rite un article s√©par√©. </font><font style="vertical-align: inherit;">Certes, c'est une chose encore moins pratique que la liste multithread d√©crite ici, mais elle a ses propres caract√©ristiques curieuses. </font><font style="vertical-align: inherit;">Si vous √™tes int√©ress√© par d'o√π il vient et pourquoi il est apparu, et que vous voulez que j'en parle plus tard en d√©tail, √©crivez dans les commentaires.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr506702/index.html">Les disques durs les plus fiables selon Backblaze Q1 2020</a></li>
<li><a href="../fr506704/index.html">Pourquoi √©crire en PHP en 2020? Holivarim est un podcast interactif sur Youtube ce jeudi</a></li>
<li><a href="../fr506706/index.html">Les performances de Java moderne lorsque vous travaillez avec de grandes quantit√©s de donn√©es, partie 1</a></li>
<li><a href="../fr506708/index.html">Authentification √† deux facteurs VPN / Mikrotik - simple et √©volutive</a></li>
<li><a href="../fr506710/index.html">G√©rez plusieurs carnets d'adresses dans Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../fr506726/index.html">Exp√©rience dans l'utilisation de la technologie Rutoken pour l'enregistrement et l'autorisation des utilisateurs dans le syst√®me (partie 2)</a></li>
<li><a href="../fr506730/index.html">Snort ou Suricata. Partie 1: choisissez un IDS / IPS gratuit pour prot√©ger le r√©seau d'entreprise</a></li>
<li><a href="../fr506732/index.html">R√©utilisation √† l'√©chelle de l'organisation des composants de l'interface utilisateur</a></li>
<li><a href="../fr506734/index.html">Calculs transitoires dans les r√©seaux √©lectriques</a></li>
<li><a href="../fr506736/index.html">Combien de m√©thodes devraient √™tre dans une classe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>