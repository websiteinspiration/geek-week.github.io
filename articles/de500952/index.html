<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 🏮 👡 Wichtige Python-Programmiererfähigkeiten 👏🏾 🚴🏾 🎊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In unserer dynamischen Zeit muss der Programmierer auf dem Laufenden bleiben und ständig neue Fähigkeiten erlernen, um ein gefragter Spezialist zu ble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wichtige Python-Programmiererfähigkeiten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500952/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserer dynamischen Zeit muss der Programmierer auf dem Laufenden bleiben und ständig neue Fähigkeiten erlernen, um ein gefragter Spezialist zu bleiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich programmiere seit ungefähr zwei Jahren in Python und jetzt ist es an der Zeit, mich bewusst der Entwicklung neuer Fähigkeiten zu nähern. </font><font style="vertical-align: inherit;">Zu diesem Zweck habe ich mich entschlossen, die offenen Stellen zu analysieren und die erforderlichen Fähigkeiten in Form eines Diagramms darzustellen. </font><font style="vertical-align: inherit;">Ich hatte erwartet zu sehen, dass Fähigkeiten Cluster bilden, die verschiedenen Fachgebieten entsprechen: Backend-Entwicklung, Datenwissenschaft usw. Aber was ist mit der Realität? </font><font style="vertical-align: inherit;">Das wichtigste zuerst.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datensammlung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst musste man sich für die Datenquelle entscheiden. Ich habe verschiedene Optionen in Betracht gezogen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Career</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HeadHunter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und andere. HeadHunter schien am bequemsten zu sein, da hier in den offenen Stellen eine Liste der Schlüsselkompetenzen und eine bequeme offene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API vorhanden sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich die HeadHunter-API studiert hatte, entschied ich mich, zuerst die Liste der Job-IDs für ein bestimmtes Schlüsselwort (in diesem Fall „Python“) zu analysieren und dann die Liste der entsprechenden Tags für jeden Job zu analysieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Suche nach Stellenangeboten werden Stellenangebote Seite für Seite zurückgegeben, die maximale Anzahl von Stellenangeboten pro Seite beträgt 100. Zuerst habe ich die vollständigen Ergebnisse in Form einer Liste mit Seitenantworten gespeichert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierzu wurde das Anforderungsmodul verwendet. </font><font style="vertical-align: inherit;">Im Feld "Benutzeragent" wurde gemäß der API der Name des virtuellen Browsers eingegeben, damit HH verstand, dass das Skript darauf zugreift. </font><font style="vertical-align: inherit;">Er machte eine leichte Verzögerung zwischen den Anfragen, um den Server nicht zu überlasten.</font></font><br>
<br>
<pre><code class="python hljs">ses = requests.Session()<font></font>
ses.headers = {<span class="hljs-string">'HH-User-Agent'</span>: <span class="hljs-string">"Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0"</span>}<font></font>
<font></font>
phrase_to_search = <span class="hljs-string">'python'</span>
url = <span class="hljs-string">f'https://api.hh.ru/vacancies?text=<span class="hljs-subst">{phrase_to_search}</span>&amp;per_page=100'</span><font></font>
res = ses.get(url)<font></font>
<font></font>
<span class="hljs-comment"># getting a list of all pesponses</span><font></font>
res_all = []<font></font>
<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(res.json()[<span class="hljs-string">'pages'</span>]):<font></font>
    print(<span class="hljs-string">f'scraping page <span class="hljs-subst">{p}</span>'</span>)<font></font>
    url_p = url + <span class="hljs-string">f'&amp;page=<span class="hljs-subst">{p}</span>'</span><font></font>
    res = ses.get(url_p)<font></font>
    res_all.append(res.json())<font></font>
    time.sleep(<span class="hljs-number">0.2</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis erhielt ich eine Liste von Antwortwörterbüchern, wobei jedes Wörterbuch einer Seite mit Suchergebnissen entsprach. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie sich herausstellte, begrenzt die hh.ru-API die maximale Anzahl von Stellenangeboten auf zweitausend, dh bei 100 Stellenangeboten pro Seite kann die maximale Anzahl von Seiten 20 betragen. Für das Schlüsselwort Python wurden 20 Stellenangebote zurückgegeben, was bedeutet, dass echte Stellenangebote in Python wahrscheinlicher sind umso mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Liste der Tags zu erhalten, habe ich Folgendes getan:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch jede Seite der Suchergebnisse iteriert,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe jeden Job auf der Seite durchlaufen und die Job-ID erhalten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über die API angeforderte Details der Vakanz,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn in der Vakanz mindestens ein Tag angegeben wurde, wurde die Liste der Tags zur Liste hinzugefügt.</font></font></li>
</ul><br>
<pre><code class="python hljs"><span class="hljs-comment"># parcing vacancies ids, getting vacancy page and scraping tags from each vacancy</span><font></font>
tags_list = []<font></font>
<span class="hljs-keyword">for</span> page_res_json <span class="hljs-keyword">in</span> res_all:
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> page_res_json[<span class="hljs-string">'items'</span>]:<font></font>
        vac_id = item[<span class="hljs-string">'id'</span>]<font></font>
        vac_res = ses.get(<span class="hljs-string">f'https://api.hh.ru/vacancies/<span class="hljs-subst">{vac_id}</span>'</span>)
        <span class="hljs-keyword">if</span> len(vac_res.json()[<span class="hljs-string">"key_skills"</span>]) &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># at least one skill present</span><font></font>
            print(vac_id)<font></font>
            tags = [v <span class="hljs-keyword">for</span> v_dict <span class="hljs-keyword">in</span> vac_res.json()[<span class="hljs-string">"key_skills"</span>] <span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> v_dict.items()]<font></font>
            print(<span class="hljs-string">' '</span>.join(tags))<font></font>
            tags_list.append(tags)<font></font>
            print()<font></font>
        time.sleep(<span class="hljs-number">0.1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tag-Listen wurden als Wörterbuch gespeichert</font></font><br>
<br>
<pre><code class="python hljs">res = {<span class="hljs-string">'phrase'</span>: phrase_to_search, <span class="hljs-string">'items_number'</span>: len(tags_list), <span class="hljs-string">'items'</span>: tags_list}
<span class="hljs-keyword">with</span> open(<span class="hljs-string">f'./data/raw-tags_<span class="hljs-subst">{phrase_to_search}</span>.json'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># Serializing</span>
    json.dump(res, fp)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessanterweise hatten von den 2000 betrachteten Stellen nur 1579 Stellen Tags.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenformatierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie die Tags verarbeiten und in ein Format übersetzen, das für die Anzeige als Grafik geeignet ist, nämlich:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bringen Sie alle Tags in ein einziges Register, sodass „maschinelles Lernen“, „Maschinelles Lernen“ und „Maschinelles Lernen“ dasselbe bedeuten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie den Wert des Knotens als Häufigkeit des Auftretens jedes Tags.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie den Wert der Verbindung als die Häufigkeit des gemeinsamen Treffens von Tags miteinander.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Reduzieren auf ein einzelnes Register, das Berechnen der Häufigkeit des Auftretens jedes Tags und das Filtern nach der Größe des Knotens wurde wie folgt durchgeführt.</font></font><br>
<br>
<pre><code class="python hljs">tags_list[<span class="hljs-string">'items'</span>] = [[i.lower() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> line] <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> tags_list[<span class="hljs-string">'items'</span>]]<font></font>
<font></font>
<span class="hljs-comment"># counting words occurrences</span>
flattened_list = [i <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> tags_list <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> line]<font></font>
nodes_dict_all = {i: flattened_list.count(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> set(flattened_list)}<font></font>
nodes_dict = {k:v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> nodes_dict_all.items() <span class="hljs-keyword">if</span> v &gt; del_nodes_count}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das paarweise Auftreten wird wie folgt berechnet. </font><font style="vertical-align: inherit;">Zuerst habe ich ein Wörterbuch erstellt, in dem die Schlüssel alle möglichen Paare von Tags in Form von Tupeln waren und die Werte Null waren. </font><font style="vertical-align: inherit;">Dann ging es die Liste der Tags durch und erhöhte die Zähler für jedes angetroffene Paar. </font><font style="vertical-align: inherit;">Dann habe ich alle Elemente gelöscht, deren Werte Null waren.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># tags connection dict initialization</span>
formatted_tags = {(tag1, tag2): <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> tag1, tag2 <span class="hljs-keyword">in</span> itertools.permutations(set(nodes_dict.keys()), <span class="hljs-number">2</span>)}<font></font>
<font></font>
<span class="hljs-comment"># count tags connection</span>
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> tags_list:
    <span class="hljs-keyword">for</span> tag1, tag2 <span class="hljs-keyword">in</span> itertools.permutations(line, <span class="hljs-number">2</span>):
        <span class="hljs-keyword">if</span> (tag1, tag2) <span class="hljs-keyword">in</span> formatted_tags.keys():<font></font>
            formatted_tags[(tag1, tag2)] += <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-comment"># filtering pairs with zero count</span>
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> formatted_tags.copy().items():
    <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">del</span> formatted_tags[k]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ausgang habe ich ein Wörterbuch der Form gebildet</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
'phrase': phrase searched,<font></font>
'items_number': number of vacancies parced, <font></font>
'items': {<font></font>
 	<span class="hljs-attr">"nodes"</span>: [<font></font>
			{<font></font>
			<span class="hljs-attr">"id"</span>: tag name, 
		 	<span class="hljs-attr">"group"</span>: group id, 
		 	<span class="hljs-attr">"popularity"</span>: tag count<font></font>
			},<font></font>
		… <font></font>
		] <font></font>
	<span class="hljs-string">"links"</span>: [<font></font>
			{<font></font>
			<span class="hljs-attr">"source"</span>: pair[<span class="hljs-number">0</span>], 
			<span class="hljs-attr">"target"</span>: pair[<span class="hljs-number">1</span>], 
			<span class="hljs-attr">"value"</span>: pair count<font></font>
			},<font></font>
		…<font></font>
		]<font></font>
	}<font></font>
}</code></pre><br>
<pre><code class="python hljs">nodes = []<font></font>
links = []<font></font>
<span class="hljs-keyword">for</span> pair, count <span class="hljs-keyword">in</span> formatted_tags.items():<font></font>
    links.append({<span class="hljs-string">"source"</span>: pair[<span class="hljs-number">0</span>], <span class="hljs-string">"target"</span>: pair[<span class="hljs-number">1</span>], <span class="hljs-string">"value"</span>: count})<font></font>
<font></font>
max_count = max(list(nodes_dict.values()))<font></font>
count_step = max_count // <span class="hljs-number">7</span>
<span class="hljs-keyword">for</span> node, count <span class="hljs-keyword">in</span> nodes_dict.items():<font></font>
    nodes.append({<span class="hljs-string">"id"</span>: node, <span class="hljs-string">"group"</span>: count // count_step, <span class="hljs-string">"popularity"</span>: count})<font></font>
<font></font>
data_to_dump = in_json.copy()<font></font>
data_to_dump[<span class="hljs-string">'items'</span>] = {<span class="hljs-string">"nodes"</span>: nodes, <span class="hljs-string">"links"</span>: links}
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-Visualisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Visualisierung des Diagramms habe ich das networkx-Modul verwendet. Dies ist das erste Mal passiert, ohne die Knoten zu filtern. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/yp/kq/jgypkqkfuip3g6sde0gylgyvdqu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Visualisierung ähnelt eher einer Kugel aus verwickelten Fäden als einem Fertigkeitsdiagramm. Die Verbindungen sind verwirrt und dringen so dicht in den Graphen ein, dass es unmöglich ist, Knoten zu erkennen. Darüber hinaus enthält das Diagramm zu viele Knoten, von denen einige so klein sind, dass sie keine statistische Signifikanz haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher habe ich die kleinsten Knoten mit einer Größe von weniger als 5 herausgefiltert und auch graue Links erstellt. In diesem Bild habe ich die Wörter noch nicht in ein einzelnes Register gebracht, während ich versucht habe, den größten Python-Knoten zu löschen, um die Verbindung zu entladen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_6/dc/u5/_6dcu5zvmb4yblypzliyx_69ezy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist viel besser geworden. </font><font style="vertical-align: inherit;">Jetzt sind die Knoten getrennt und die Links verstopfen die Visualisierung nicht. </font><font style="vertical-align: inherit;">Es wurde möglich, die Grundfertigkeiten zu sehen, sie befinden sich in großen Kugeln in der Mitte des Diagramms und kleinen Knoten. </font><font style="vertical-align: inherit;">Aber diese Grafik hat noch viel zu verbessern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript-Visualisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich würde diesen Code wahrscheinlich weiterhin auswählen, wenn ich in diesem Moment keine Hilfe in Form eines Bruders hätte. </font><font style="vertical-align: inherit;">Er war aktiv an der Arbeit beteiligt und machte eine schöne dynamische Anzeige basierend auf dem JavaScript- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul D3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich so heraus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/94/uk/ih/94ukihcm4utgytmwbilp1pjtt-i.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine dynamische Visualisierung finden Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hier. </font><font style="vertical-align: inherit;">Beachten Sie, dass Knoten gezogen werden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisanalyse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir sehen können, erwies sich der Graph als sehr eng miteinander verbunden, und klar definierte Cluster können auf den ersten Blick nicht erkannt werden. </font><font style="vertical-align: inherit;">Sie können sofort mehrere große Knoten bemerken, die am meisten gefragt sind: Linux, SQL, Git, Postgresql und Django. </font><font style="vertical-align: inherit;">Es gibt auch Fähigkeiten mittlerer Beliebtheit und selten anzutreffende Fähigkeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können Sie darauf achten, dass Fähigkeiten nach Beruf immer noch Cluster bilden, die sich auf gegenüberliegenden Seiten des Zentrums befinden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unten links - Datenanalyse,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unten sind die Datenbanken,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unten rechts - Frontend-Entwicklung,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der rechten Seite wird getestet,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oben rechts - Webentwicklung,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oben links - maschinelles Lernen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Beschreibung der Cluster basiert auf meinem Wissen und kann Fehler enthalten, aber die Idee selbst ist hoffentlich klar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den erhaltenen Ergebnissen können die folgenden Schlussfolgerungen gezogen werden:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen Fähigkeiten beherrschen, die großen Knoten entsprechen. Sie sind immer nützlich.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen die Fähigkeiten des Clusters beherrschen, die Ihren Interessen entsprechen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe es hat Ihnen gefallen und diese Analyse wird Ihnen nützlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sich den Code ansehen oder über die folgenden Links an seiner Entwicklung teilnehmen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub-Projekt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beobachtbarer Laptop</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Visualisierung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erfolgreich bei der Beherrschung neuer Horizonte!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500934/index.html">Winnum kündigt eine neue Version der Flaggschiff-Plattform Winnum Platform 4.3 an</a></li>
<li><a href="../de500936/index.html">Einfache Integration von RabbitMQ und Spring Boot</a></li>
<li><a href="../de500942/index.html">Ultraviolett: wirksame Desinfektion und Sicherheit</a></li>
<li><a href="../de500944/index.html">WexLang Reader - wie man gerne Bücher in Fremdsprachen liest (104 Sprachen)</a></li>
<li><a href="../de500948/index.html">Rust 1.43.1 Release: Einstellfreigabe</a></li>
<li><a href="../de500956/index.html">Mobile ML: Maschinelles Lernen in der Tasche. Teil 1 - Eisen</a></li>
<li><a href="../de500958/index.html">Warum WSL 2 13x schneller ist als WSL: Insider Preview Impressions</a></li>
<li><a href="../de500962/index.html">Schritt-für-Schritt-Codes: PDF417 lesen / codieren</a></li>
<li><a href="../de500966/index.html">SLS vs STARSHIP: Warum gibt es beide Programme? Alltäglicher Astronaut</a></li>
<li><a href="../de500968/index.html">Material Python. Was ist neu in der KivyMD-Bibliothek?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>