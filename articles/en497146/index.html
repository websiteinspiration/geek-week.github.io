<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè£ üéø üçπ Applied cryptography. How we restored bitcoins for 300 thousand dollars ‚òéÔ∏è üë®üèø‚Äçüé§ üêΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I will share with you one story. About twenty years ago, I received a degree in physics, but was engaged in reverse engineering and cryptanalysis. Our...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Applied cryptography. How we restored bitcoins for 300 thousand dollars</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dcmiran/blog/497146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will share with you one story. About twenty years ago, I received a degree in physics, but was engaged in reverse engineering and cryptanalysis. Our company AccessData worked in the late 90s and early 2000s. Then the US government gradually lifted restrictions on the export of cryptography, however, password protection in most programs was still rather useless. We took office programs, I performed reverse engineering and figured out the encryption algorithm, and then broke cryptographic protection.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was an endless stream of interesting, but not particularly difficult mathematical puzzles. For all the time I wrote about forty password crackers. We sold them to home users, system administrators, and local and federal law enforcement agencies. I had to go to the federal law enforcement training center in Glinko several times to explain to the guys from the Secret Service, the FBI and </font></font><abbr title="Bureau of Alcohol, Tobacco, Firearms and Explosives"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATF the</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basics of cryptography and how to use our products.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I especially remember two projects. The first was Microsoft Word 97. Before it appeared, the files were encrypted using XOR bytes of clear text and a 16-byte string that was output from the password. The most common bytes in a Word file were usually 0x00, 0xFF, or 0x20 (space), so we just chose the most common character in each column and checked 3 to </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> options. The key recovery usually happened instantly, but so that people didn‚Äôt think that they had wasted money, we inserted a small animation similar to the Hollywood hacker scene with a lot of random characters, from which the correct password gradually emerges.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft Word 97 has changed everything. Perhaps MSDN also revealed the encryption format, but our small company could not afford a subscription. And not the fact that we would be allowed to write a program for hacking after receiving information. To understand, in SoftICE I set a breakpoint immediately after entering the password, and then slowly moved up the stack until I found an algorithm. This was before the release of IDA Pro, so I had dozens of pages of printouts with an assembler code streaked with a red marker on my wall. I was very pleased when I finally figured it out. At that time, Microsoft was allowed to export only 40-bit cryptography, so the company dutifully implemented strictly allowed cryptography: they repeatedly hashed the password in MD5 using "salt" (randomly selected bytes from the file),to get a 40-bit key, then salt was added to it and hashed again. Password checking on computers of that time took about half a second. We had to use a dictionary attack because it was almost impossible to crack a password with brute force. As a result, we wrote a password cracker for large companies and agencies. The program executed the bruteforce of a 40-bit key space using these fancy MMX Pentium instructions. I heard that once she worked for nine months before I picked up the password.The program executed the bruteforce of a 40-bit key space using these fancy MMX Pentium instructions. I heard that once she worked for nine months before I picked up the password.The program executed the bruteforce of a 40-bit key space using these fancy MMX Pentium instructions. I heard that once she worked for nine months before I picked up the password.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another really fun project is zip archives. Phil Katz, creator of PKZIP, made an unusual decision for that time to document his file format and include this documentation in the software package, which made ZIP a favorite format for developers. Roger Schlafly developed a stream cipher for encrypting archives. The zip standard quickly became the most popular under Windows, and many other formats, such as .jar java files and OpenOffice documents, were actually zip files with a specific directory structure inside. The open source version of the program was called InfoZIP, it was the basis of almost all proprietary zip archivers, such as WinZip. When I started hacking WinZip, it occupied 95% of the market.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eli Biham and Paul Kocher published a description of the attack with known plaintext (text before encryption), but in our case, the known plaintext was </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archived</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To get the Huffman codes at the beginning of a compressed file, you essentially need the whole file. The attack was practically useless for law enforcement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The zip cipher contains 96 bits of internal state, divided into three 32-bit blocks called </font></font><code>key0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>key1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>key2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The first and third are the internal state of two copies of CRC32, a linear shift register with feedback (a simple mathematical model that allows you to create pseudorandom sequences). In short, to update the state with a new byte of data, you shift everything down by one byte (discarding the lower byte), and then do XOR with a constant from the conversion table indexed by the data byte after XOR with the lower byte. </font></font><code>key1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the internal state of a truncated linear congruent generator (TLCG). To update its internal state, we add a byte of data, multiply by a constant, which we will call</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and add one. The cipher works as follows: enter the data byte in the first CRC32, then take the lower byte and enter it in TLCG, then take the upper byte from there and enter it in the second CRC32, then take the state and square (approximately), and then issue the second byte result in a stream of bytes. To initialize 96 bits of the internal state, you start with a known state and encrypt the password, and then encrypt ten bytes of salt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PKZIP gets its salt bytes, allocating memory without initializing it, so it contains bits of materials from other running programs or images, or documents, whatever. This worked fine on Windows, but on many Unix systems, memory initializes automatically when allocated. InfoZIP select salt bytes using function</font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C language. He initialized the state of the random number generator by making an XOR timestamp on the process ID, and then generated ten bytes per file. In this case, knowing the time stamp and the process identifier, it was possible, theoretically, to recover the bytes of the header, which, in turn, made it possible to carry out an attack by Biham and Kocher. It seems that InfoZIP authors knew about this attack because they went a step further - and encrypted the header using a password. Thus, the attacker had only twice the encrypted plaintext, and the attack would not have worked.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I noticed this, because the password is the same in both passes, the first byte of the stream is the same in each of them. In the same way as when the light switch is switched twice, it remains where it was at the beginning, when the byte is repeated XOR with the same stream byte, it remains untouched. This allowed me to develop a very powerful attack </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only on ciphertext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : having received five encrypted files in the archive, I could output the internal state of the function</font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without having to look at the time stamp or know the process ID. Then I could generate the original unencrypted headers. Since just a few bits in each part of the cipher affect the next part, I could also guess a few bits of status and check if decoding the next bytes twice gives the answer that I expected. As I moved forward, I had to guess less and less pieces of the key. Each additional file also allowed to exclude more potential key materials; at that time, it took several hours on one desktop. I published </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about this and got the opportunity to present it in Japan at the Fast Software Encryption 2001 conference.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soon I left AccessData, worked for a startup on neural networks for a year, spent three years studying for a master's degree in computer science at the University of Auckland with Chris Kaloud, started my doctoral studies with mathematical physicist John Baez at the University of California Riverside, worked for six years As part of the Google‚Äôs Applied Security team, he completed his doctorate and a few years later became the CTO of the new startup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
About half a year ago, I quite unexpectedly received a message on LinkedIn from a Russian guy. He read the article I wrote 19 years ago and wanted to know if the attack would work on an archive that contains only two files. A quick analysis showed that it requires a huge amount of computing power and money. Since there are only two files, at each stage of the selection there are much more false positives. The result is </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,773</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possible keys for testing, almost 10 sextillion. I calculated that a large cluster on the GPU will work for a year, and its cost will be about 100 thousand dollars. He hit me, saying that he agreed to spend so much money to restore the key.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The fact is that in January 2016, he bought bitcoins for about $ 10-15 thousand and placed the keys in an encrypted zip file. Now they cost more than $ 300 thousand, and he could not remember the password. Fortunately, he still had the original laptop, and he knew exactly the encryption time. Since InfoZip derives entropy based on a timestamp, this promised to significantly reduce the number of possible key options ‚Äúonly‚Äù to 10 quintillion - and made the attack quite feasible in a couple of months on an average GPU farm. We signed a contract and I got to work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I spent some time recovering the attack described in the article. To my chagrin, there were some tricky details that I missed in the article, but I worked them out again. And then I discovered that I had made a terrible mistake in evaluating the amount of computation!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In my original attack, I guessed the high bytes of the keys key1 ¬∑ c, key1 ¬∑ c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , key1 ¬∑ c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and key1 ¬∑ c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . By the time I guessed this fourth byte, I knew the complete state of the rest of the cipher; I just needed to convert these four bytes to the original key1, and that‚Äôs it. I would go over the 32-bit state space for key1 and check each one to see if it gives the correct high bytes. However, here would have to check quintillion keys; if you need to do 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tests on each, it would take several hundred thousand years.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I vaguely remembered that some work had been done on the TLCG cryptanalysis through reduction of the lattice basis, so I dug up the original article. So it was! It was just necessary to determine the lattice with the basis vectors given by 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the degree of constant from TLCG, and then make the reduction of the basis of the lattice. On a reduced basis, I could restore the original state from high bytes by simply multiplying the matrices.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At least that is the idea. It took five bytes to get to the only correct result, and at that time I had only four attacks. The process described in the article rarely gave the correct answer. However, I knew that the answer should be close to the correct one, so I could go over all the possible values ‚Äã‚Äãof key1 and check the difference between the real answer and the true one. The difference has always been one of 36 vectors! With this optimization, I can reduce the search to just 36 options instead of four billion. We are still in business.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, we were faced with the problem of transferring data between machines with a GPU. My business partner, Nash Foster, was involved in GPU implementation. He advised me how quickly various operations are performed, and wrote most of the supporting structures for the application with my code for crypto cracking. How to get these petabytes of candidate keys for GPU testing? They will be idle almost all the time, tossing their cores in anticipation of work. It occurred to me that at every stage of my attack a lot of bits are checked, and then only one of about 65 thousand candidates is saved. If I could find some way </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to output</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">these bits are based on the available information, and not just brute-force them, I would save a lot of work and, more importantly, a lot of network traffic. The problem here was too complicated algorithms, representing a mixture of finite fields with rings of integers, but they do not fit very well with each other.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I thought of other cryptanalytic attacks that I know of. One of them was the ‚Äúmeet-in-the-middle‚Äù attack. She seemed a promising candidate. The attack is applied to a block cipher when it uses one part of the key material to perform the first half of encryption, and the other part for the second. This applied to the zip cipher, but the key material far outweighed the number of bits in the middle. Then it occurred to me, what if we use the linearity of CRC32: if we perform the XOR operation on the two outputs of the last CRC32, then the result will be independent of key2! Instead of calculating the intermediate state of the cipher and storing it in a table, I would calculate the XOR of the two intermediate states and store it instead.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I wrote a differential meeting ‚Äúmeeting in the middle‚Äù and launched it on my laptop. The stage, which used to take several hours, now completed in just a few seconds. The next stage, which could take a week on the GPU farm, ended in a few hours on one powerful CPU. I couldn‚Äôt optimize the third stage of the attack enough to affect the overall speed, but there was no need to move the data completely: we just calculated the candidates for each GPU on the computer with these cards. Nash wrote GPU code that worked at incredible speed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The attack lasted ten days and ended in failure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My heart was broken. Are we missing one of the possible keys? We went back and looked at the maximum process identifier on his laptop and found that it was several bits more than we expected, and therefore there were a little more possible source seeds for </font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I also double-checked all our code. Maybe we missed something? Maybe the version on the CPU worked somehow differently than on the GPU? Finally, I found that the version on the GPU could not find the correct key when it was second in the candidate list, but only the first. Rummaging through the code, we found that we confused the block index with the stream index when calculating the offset in the data structure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We fixed the error, re-run the code and found the correct key within a day. </font><font style="vertical-align: inherit;">Our client was very satisfied and gave us a big bonus for finding the key so quickly and saving him so much money beyond our initial estimate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now I am looking for work. </font><font style="vertical-align: inherit;">If you have interesting problems with technical analysis or optimization, let me know.</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/dx/cq/eodxcqr_jt4-i2h7pybvhg_n7gq.jpeg"></div></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en497132/index.html">#SaveFirst Initiative to Support Socially Important Projects</a></li>
<li><a href="../en497136/index.html">‚ÄúSave Concord‚Äù or a report from the tests of the Russian radar system for searching for foreign objects on the runway</a></li>
<li><a href="../en497140/index.html">Decryption of data in the CAN bus VW Polo sedan</a></li>
<li><a href="../en497142/index.html">How we added Harmony OS support to the inDriver Android application</a></li>
<li><a href="../en497144/index.html">Wedge by wedge: use of the PIV5 virus to create a vaccine against MERS-CoV and possibly against SARS-CoV-2</a></li>
<li><a href="../en497148/index.html">Creating a desktop application using Golang and Fyne</a></li>
<li><a href="../en497152/index.html">Where Product Heart Lives: Metrics for Measuring Happiness</a></li>
<li><a href="../en497154/index.html">Videos of all reports from eight Ontico conferences</a></li>
<li><a href="../en497156/index.html">Webinar "Artificial Intelligence in Questions and Answers"</a></li>
<li><a href="../en497158/index.html">The Way to Programmers (C ++)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>