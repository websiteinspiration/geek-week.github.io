<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∂ üë©üèø‚Äçüî¨ üö£üèæ We implement Python code conversions üë©üèº‚Äçüé® üèòÔ∏è üöî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. 
 
 Today we offer you a translation of an article that touches on a topic that isn‚Äôt the most discussed: compilation of code in Python, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>We implement Python code conversions</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today we offer you a translation of an article that touches on a topic that isn‚Äôt the most discussed: compilation of code in Python, namely: work with abstract syntax tree (AST) and byte code. While Python is an interpreted language, such features in it are extremely important from an optimization point of view. We‚Äôll talk about them today.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Have you ever wondered how exactly the compiler optimizes your code so that it works faster? </font><font style="vertical-align: inherit;">Want to know what an abstract syntax tree (AST) is and what it can be used for? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This review article describes how Python code is converted to tree form (AST). </font><font style="vertical-align: inherit;">Having built the AST of your program, you can go on to the search for opportunities to optimize and transform your code. </font><font style="vertical-align: inherit;">However, keep in mind that optimizing Python programs in non-trivial ways is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extremely difficult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program code as a tree</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How can a computer make sure that it evaluates expressions from your code in the correct order? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, he first remakes your program code into a tree structure called AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working with an interpreted programming language (such as Python), it is generally accepted that the interpreter passes through your code and does everything that it encounters, right on the spot, without converting Python code into machine code in any way. However, in practice, this execution scheme provokes a lot of problems, which make it very inconvenient. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take, for example, such a simple problem as the priority of operators. In a view expression </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the part is first calculated</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and only then can 3 be added to the result of the multiplication. Perhaps you learned the priority of operators in mathematics lessons by drawing these trees under the expression: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python uses the standard rules of mathematical notation (first, multiplication, then addition). In order not to confuse anything with the priority of the operators, in Python, at first it is built such a tree as in the previous picture. The general operation is addition (at the root of the tree), and while the left side of this sum is a regular number, on the right we have the product. The resulting data structure looks like this:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means Binary Operation (Binary Operation) and indicates that in operations such as addition and multiplication - two operands. Naturally, you won‚Äôt get any addition if the right part of the expression doesn‚Äôt have the correct value - therefore, you must first multiply. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the theory of compilers and programming languages, such a tree is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract Syntax Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for short. The AST in the above example includes two nodes </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, two nodes, </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and one node </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a nice feature in Python - the ability to directly view and display AST for any particular Python program. All that is required is to import a standard module</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, parsing the program, and then displaying the result on the screen (by the way, parsing is the process of converting the program source code to the AST tree).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, you will notice that there will be additional nodes and fields in the AST generated by Python, and it will be displayed on one line, which makes it seem more complicated at first glance than it actually is. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's split it into separate nodes, like last time - and re-open the AST, already on top, as part of the whole tree: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, Python ‚Äúthinks‚Äù that the line we gave it for parsing is a whole module. The body of the module is a list of all the instructions contained in it. The only instruction in our example is an expression </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whose meaning is exactly what we discussed above. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: the node </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has an additional field </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abbreviated as ‚Äúcontext‚Äù), which has a value </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. So Python says that we use the value stored in the variable </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not (re) define or delete the name </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Now your move, try to parse something like </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font><font style="vertical-align: inherit;">yourself </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and you will see how the field </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the node </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes to </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectively. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way: if you install the module</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the AST output to the screen can be made much more beautiful, and even convert the AST back into live Python code.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The compilation process: the remainder</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having collected AST programs, it is in principle possible to complete the entire program by going through the AST and performing the operations in the order in which they are indicated. However, this approach has at least two drawbacks. Firstly, AST can occupy a relatively large amount of memory, especially if it contains redundant information. Secondly, AST traversal may take longer than necessary. In short: it can be done, but it is inefficient. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The compiler does not process the AST directly, but prepares bytecode, which is then executed on the Python virtual machine. Although discussing the details of this process is beyond the scope of this article, the basic principle is that the compiler translates the AST into reverse Polish notation (RPN). Instead of putting an operator</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">between the left and right operands, we put it after both operands. In the example </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">above, we get the sequence </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(and this notation is especially good because you can immediately see from the sequence: first you need to perform the multiplication, and only then the addition). Since each of the five elements in this sequence can in principle be represented as a single byte, such a code is called a byte code. Python then uses the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stacked virtual machine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to efficiently execute this code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In other words, the process of compiling a program written in Python takes place in two stages. </font><font style="vertical-align: inherit;">First, the program received by the input is parsed, and the result is an abstract syntax tree (AST). </font><font style="vertical-align: inherit;">The compiler then passes through AST and generates bytecode. </font><font style="vertical-align: inherit;">After that, the Python interpreter executes this bytecode. </font><font style="vertical-align: inherit;">Having taken up optimization, it can be applied either at the AST level or at the bytecode level. </font><font style="vertical-align: inherit;">Both of these options have their own advantages and disadvantages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, keep in mind that although AST is common in any Python implementation, the process of translating AST into bytecode may be different, and in some Python implementations, say, JavaScript, rather than bytecode, may be generated at the intermediate stage.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigms from other programming languages</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not all programming languages ‚Äã‚Äãuse infix notation, as in Python. </font><font style="vertical-align: inherit;">Two examples worth noting in this case are PostScript, where the program is written directly in reverse Polish notation, and Lisp, of course, where programs are usually written in Polish notation. </font><font style="vertical-align: inherit;">So, our expression of the above example, in Lisp would take the following form: </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node conversion within AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having an AST program, how to convert individual parts of this tree? With the convenient built-in features of Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we take a look at AST and, for example, find that both fields </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodes </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are numbers (nodes </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), we can perform the corresponding calculations in advance, and then replace them with a </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal node </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, you need to act very carefully so as not to change the behavior of the program, doing such transformations. For example, in </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is clear that the result is 4. But we can not replace all the expression of the number 4 because four functions </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">still have properly invoked.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again, start with a simple optimization. Wherever a name appears in the source code of a program </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, replace it with the value 3.14159265. The Python module </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already provides the data structures necessary to do this: a converter class </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that goes through all the ASTs and checks for each node whether it can be replaced. By default, the transformation method simply returns the source node for each node, so that we get the same AST from which we started. But we can easily override the method for nodes </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, say, so that it checks to </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">see if it is, and then returns the node </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead of the node with the original name ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order for the converter / optimizer to go through our tree, it is necessary to call its method </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which then will return a new, changed tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, it is impossible to compile and run the resulting AST, the reason for this is one technical detail. This is not yet visible, but (almost) all nodes in the AST also have fields </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. They indicate the exact position of a particular node in the source code. If you do not install them properly, the compiler will swear and refuse to work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, let's copy the appropriate fields from the source node </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the new node </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can then compile and execute the resulting AST:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function compile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requires not only the source code (in which can be a program itself, or the AST line), but the file name (as we asked </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), as well as one of three: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The need to copy the fields describing the position of the node in the source code arises quite often. Therefore, the module </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has a dedicated function </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just for this purpose, and we can write:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, you can extend the previous example so that it actually performs optimization, namely, on the node </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">According to the transformation rule, first we must transform / optimize the left, and then the right node as part of BinOp. </font><font style="vertical-align: inherit;">If as a result it turns out that both the left and right nodes are numbers, then the calculations can be performed right on the spot and replace the original with the </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numerical result of the operation.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, the CPython compiler is already optimizing nodes </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as shown here. </font><font style="vertical-align: inherit;">The corresponding code is written in C and is given in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Please note: CPython optimizer is more universal and works not only with numbers, as in the example we are considering, but with different types of constant values.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing nodes in AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to make sure that the transformations we made were correct? First you need to completely bypass AST and inspect the entire program. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The optimizer presented above remains a serious flaw. What happens if you redefine somewhere in the program </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Just imagine something as simple and intelligible as </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Our optimizer will simply replace pi on the left side of the expression with the numeric value 3.14159265, and Python will then refuse to compile because it cannot assign anything to a literal value. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps this is precisely the behavior you sought, making pi a true constant, which is replaced during compilation and can never be reassigned, that is, it cannot get a different value. However, this definitely violates the semantics of Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So what to do if we want to stick to the semantics of Python, but replace pi anyway wherever possible? In this case, you first need to go through the entire program and check if the value for is assigned somewhere </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Until we complicate it: we will not resort to replacing pi if at least one point in the program has any assignment of a value to </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we use the visitor node, similar to the converter node described above. Unlike the converter, the visitor is not intended to change any nodes, he simply goes through the AST and examines the nodes (visits them). Accordingly, visiting methods do not return anything. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, we check whether the node refers </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and does anything other than loading the value</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(remember the context field </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is called by the visitor for each node for which we do not provide a specialized visiting method. </font><font style="vertical-align: inherit;">In other words: there is no such method </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the class </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we could call using </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Regarding function definitions, we must call a generic visitor to make sure that the entire body of the function is also processed correctly. </font><font style="vertical-align: inherit;">Otherwise, we could hide the instruction in the function </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and globally change the value </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so that our optimizer would not notice anything.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local Values ‚Äã‚Äãin Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our method, which allows us to determine if the programmer has changed pi, turned out to be rather rude. </font><font style="vertical-align: inherit;">However, the Python compiler acts very similarly when it determines which names in the scope of a function correspond to local variables. </font><font style="vertical-align: inherit;">If a variable changes somewhere in the scope of the function (and is not explicitly made global, for example, using the global instruction), then this variable is considered local in the entire scope of the function. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following example will execute fine without the fourth line. </font><font style="vertical-align: inherit;">But, although </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the fourth line is never executed, it is still considered an assignment to</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and therefore x becomes a local variable at the scale of the entire function, and even on line 3. That's why Python will swear that the variable x on the third line does not matter yet.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are interested in the details of exactly how Python works here, check out </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / symtable.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Python, as in most programming languages, a particular program is not executed directly from source code. </font><font style="vertical-align: inherit;">In fact, the translation of the source code takes place in two stages: first, an abstract syntax tree (AST) is made from it, and then byte code for the stacked virtual machine. </font><font style="vertical-align: inherit;">Python also provides a number of very nice features for analyzing and even transforming the AST of any particular Python program, after which the modified AST can be compiled and executed. </font><font style="vertical-align: inherit;">Thus, we can easily implement our own optimizations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I simply omitted many details here. </font><font style="vertical-align: inherit;">To make sure that your optimization will work correctly in all possible cases and circumstances is a very non-trivial matter. </font><font style="vertical-align: inherit;">However, the purpose of this article is not to tell you about the optimization that is ready for use in production, but to give a basic idea of ‚Äã‚Äãhow Python analyzes your program code so that you can learn how to correctly convert it and then optimize it.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en493408/index.html">DJI Mavic mini copter fell like a crowbar</a></li>
<li><a href="../en493412/index.html">Games with Wifi on ESP32</a></li>
<li><a href="../en493416/index.html">IDA Pro and reverse engineering techniques</a></li>
<li><a href="../en493418/index.html">Why machine learning uses ‚Äúsynthetic" data</a></li>
<li><a href="../en493420/index.html">My way to introduce junior high school students to Python</a></li>
<li><a href="../en493426/index.html">Organization of code in microservices and my approach of using hexagonal architecture and DDD</a></li>
<li><a href="../en493428/index.html">"We will not give rise to conspiracy theories." Talk about ML conferences with people from science and IT companies</a></li>
<li><a href="../en493430/index.html">Net Architecture for Web Applications</a></li>
<li><a href="../en493432/index.html">Why not start a career in a small non-IT company</a></li>
<li><a href="../en493436/index.html">Program for changing access rights and register of file / directory names on Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>