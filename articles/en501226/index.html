<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶í ü§∏üèº ü¶å Quick file search üöÄ ‚è´ üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From a translator: I bring to your attention a translation of a very old article published on January 15, 1983. Despite such an impressive age, the ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Quick file search</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501226/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From a translator: I bring to your attention a translation of a very old article published on January 15, 1983. </font><font style="vertical-align: inherit;">Despite such an impressive age, the article seemed interesting to me, and it is possible that it will be useful to someone today. </font><font style="vertical-align: inherit;">By the way, this article is referenced by the man locate (1) help topic on opennet.ru: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.opennet.ru/man.shtml?topic=locate</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dq/aa/o7/dqaao7k_sxha8y9dwfcmzkkz7bc.jpeg"></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article describes a quick file search mechanism on UNIX. It combines two data compression methods with a new line search technique, and is designed to quickly search for arbitrary files. The code, integrated into the standard find utility, searches the previously created database, updated daily. This distinguishes it from the usual mechanism for searching for key matches with candidates, which are generated on the fly from a scattered (on disk) directory structure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The file path database is an incrementally encoded, lexicographically sorted list (sometimes called a ‚Äúfront compressed‚Äù file), which is also subjected to regular bigramic encoding in order to obtain effective compression. </font><font style="vertical-align: inherit;">The compression ratio is 5 to 6 compared to the usual ASCII representation. </font><font style="vertical-align: inherit;">The list is scanned using a modified linear search, specially adapted for incremental coding, while the typical time spent by the algorithm is 40-50% less than a regular search.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finding files in a computer system, or computer network, is a complex process. UNIX users can implement it in a variety of ways, from manipulating the cd, ls, and grep commands, to specialized commands, such as those developed in Berkeley whereis and fleese, and to the more common find Unix command. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fleece</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (from Berkeley) is limited to the home directory, and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whereis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can only search for system code and documentation located in standard places. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Search:</font></font><br>
<br>
<pre><code class="bash hljs">find / -name <span class="hljs-string">"*&lt;filename&gt;*"</span> -<span class="hljs-built_in">print</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
of course, it can search for arbitrary files, but very slowly, because it uses a recursive descent throughout the file system, ruthlessly scattered throughout the disk. </font><font style="vertical-align: inherit;">Impatience prompted us to develop an alternative (in relation to the ‚Äúsearch and find‚Äù method) search for paths to files.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preliminary calculations</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why not just build a static list of all the files in the system and look for grep on it? </font><font style="vertical-align: inherit;">A typical system containing 20,000 files will contain 1,000 blocks of file names, even if you shorten / usr to / u. </font><font style="vertical-align: inherit;">Grep on our unloaded PDP-11/70 system processes 30-40 blocks per second, and will require half a minute to scan. </font><font style="vertical-align: inherit;">This is not acceptable for a commonly used command. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if we make a small sacrifice - the inability to search for files less than a day old, then this will not create big problems, since the one who created such a file is probably within reach, or the file may not be ready yet use. </font><font style="vertical-align: inherit;">Older files created by other user groups with different file naming conventions are the most likely search candidates.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To speed up access for applications, you can suggest using a binary search or a hash table, but such schemes do not work well for partial comparisons, if we are only interested in a part of the name. </font><font style="vertical-align: inherit;">The ordered data compression technique, known as incremental coding, that was used for a similar dictionary compression task is easily implemented [Morris / Thompson, 1974]. </font><font style="vertical-align: inherit;">In this case, the longest prefix of the previous name is calculated. </font><font style="vertical-align: inherit;">For instance:</font></font><br>
<br>
<pre><code class="bash hljs">/usr/src<font></font>
/usr/src/cmd/aardvark.c<font></font>
/usr/src/cmd/armadillo.c<font></font>
/usr/tmp/zoo</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
converted to </font></font><br>
<br>
<pre><code class="bash hljs">0/usr/src<font></font>
8/cmd/aardvark.c<font></font>
14armadillo.c<font></font>
5tmp/zoo</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decoding will be simple (variable declarations omitted)</font></font><br>
<br>
<pre><code class="cpp hljs">fp = fopen(COMPRESSED_FILELIST, <span class="hljs-string">"r"</span>);
<span class="hljs-keyword">while</span>((count = (getc(fp) &amp; <span class="hljs-number">0177</span>)) != EOF) {
    <span class="hljs-keyword">for</span>(p = path + count; (*p++ = getc(fp)) &lt; <span class="hljs-number">0200</span>; )<font></font>
        ; <span class="hljs-comment">/*overlay old path with new*/</span><font></font>
    ungetc(*--p, fp);<font></font>
    *p-- = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span>(math(path, name) == YES)
        <span class="hljs-built_in">puts</span>(path);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where math is a function that determines whether the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> substring is contained </font><font style="vertical-align: inherit;">in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">path</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> string </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, since the encoded list is about five times shorter than the uncoded one, and decoding is very simple, the program runs three to four times faster than </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the text file.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even faster</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach is already useful, but leaves room for further improvements. </font><font style="vertical-align: inherit;">(Note: this code is used in the find utility. There is no need to burden UNIX with another command [and man page] when we can improve an existing similar program. Fortunately, there is no find call with two arguments, and we can fill the void without embellishment :</font></font><br>
<br>
<pre><code class="bash hljs">find name</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that the code above still searches the unpacked list, albeit in memory, not on disk. This can be avoided by comparing a string with a substring in the opposite direction. Let namend point to the last character of the string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and replace </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(s = p, cutoff = path + count; s &gt; cutoff; s--) {
    <span class="hljs-keyword">if</span>(*s == namend) { <span class="hljs-comment">/*quick first char check*/</span>
        <span class="hljs-keyword">for</span>(p = namend - <span class="hljs-number">1</span>, q = s - <span class="hljs-number">1</span>; *p != <span class="hljs-literal">NULL</span>; p--, q--)
            <span class="hljs-keyword">if</span>(*q != *p)
                <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span>(*p == <span class="hljs-literal">NULL</span>) {
            <span class="hljs-built_in">puts</span>(path);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is easier to understand by looking at three cases. </font><font style="vertical-align: inherit;">If the substring is completely to the right of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutoff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the comparison will end successfully. </font><font style="vertical-align: inherit;">If they overlap, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutoff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> becomes ‚Äúsoft‚Äù and the comparison continues. </font><font style="vertical-align: inherit;">If the substring lies completely to the left of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutoff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then a match would be revealed for the previous lines, which means that we can not perform this search! </font><font style="vertical-align: inherit;">Technically, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutoff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be ported to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">path</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immediately after the comparison is done. </font><font style="vertical-align: inherit;">This condition is omitted above.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two-tier equipment</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can avoid slowing down the search caused by the processing </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of search pattern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> characters </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In doing so, we process the part of the name that does not contain metacharacters and use the slower recursive function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amath</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inside </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I.e,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">puts</span>(path)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
becomes</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(globchars == NO | amatch(path, name))
    <span class="hljs-built_in">puts</span>(path);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">globchars is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> set if </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contains metacharacters. </font><font style="vertical-align: inherit;">An example of using a search pattern for a simple </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">man</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="bash hljs">vtroff -man <span class="hljs-string">'find '</span>*man*<span class="hljs-string">'"$1"'</span>.[1-9]</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further improvements</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The production code of the find utility increases the compression ratio by another 20-25% by replacing the most common two-character combinations with non-printable ASCII codes. </font><font style="vertical-align: inherit;">".c" and ".P" are especially common. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Other algorithms that implement other trade-offs between time and data size, such as the Huffman algorithm [Reghbati, 1981], do not look promising: they just replace the I / O performance limit with the performance limit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Boyer-Moore sub-linear search methods [Boyer, 1977] or macro-model methods [Storer / Szymanski, 1982] can be used. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In conclusion, it should be noted that we scanned 19,000 file names in a few seconds, using 180 blocks and a C code that fits on two pages.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Boyer, RS A Fast String Searching Algorithm, Commun. </font><font style="vertical-align: inherit;">ACM, Vol. </font><font style="vertical-align: inherit;">20, No. 10, October 1977. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Morris, R. and Thompson, K. Webster's Second on the Head of a Pin, Unpublished Technical Memo, Bell Laboratories, Murray Hill, NY, 1974. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reghbati, HK An Overview of Data Compression Techinques, Computer, Vol. </font><font style="vertical-align: inherit;">14, No. </font><font style="vertical-align: inherit;">4, April 1981. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Storer, JA and Szymanski, TG Data Compression via Textual Substitution, J. ACM, Vol. </font><font style="vertical-align: inherit;">29, No. </font><font style="vertical-align: inherit;">4, October 1982.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501212/index.html">Realization of skeletal animation for three-dimensional models</a></li>
<li><a href="../en501214/index.html">Groupby aggregation in pandas</a></li>
<li><a href="../en501220/index.html">Parsing: can a company have too much money?</a></li>
<li><a href="../en501222/index.html">Application of COBIT when developing an IT strategy</a></li>
<li><a href="../en501224/index.html">What neural networks can ‚Äúsing‚Äù and perform death metal</a></li>
<li><a href="../en501232/index.html">How can an IT expert earn extra on his knowledge</a></li>
<li><a href="../en501234/index.html">Fast routing and NAT on Linux</a></li>
<li><a href="../en501236/index.html">So what is this all about, ‚Äúprotein folding‚Äù?</a></li>
<li><a href="../en501240/index.html">Site Security Audit</a></li>
<li><a href="../en501244/index.html">The programmer does not have to solve business problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>