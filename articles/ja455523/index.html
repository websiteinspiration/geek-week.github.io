<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏽 🧑🏽‍🤝‍🧑🏽 👩🏽‍💼 OpenStack LBaaS UIの実装 🤸🏾 🈺 💛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私はのユーザーインターフェース実装された場合、ロードバランサをするために、仮想プライベートクラウド、私は大きな困難に直面しなければなりませんでした。これにより、最初に共有したいフロントエンドの役割を振り返ることになりました。そして、特定のタスクの例を使用して、彼らの考えを正当化します。
 
 私の意...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>OpenStack LBaaS UIの実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/455523/"><img src="https://habrastorage.org/webt/ct/q8/3-/ctq83--b7viz0r6evi5um6brnam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はのユーザーインターフェース実装された場合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ロードバランサを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、仮想プライベートクラウド、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は大きな困難に直面しなければなりませんでした。</font><font style="vertical-align: inherit;">これにより、最初に共有したいフロントエンドの役割を振り返ることになりました。</font><font style="vertical-align: inherit;">そして、特定のタスクの例を使用して、彼らの考えを正当化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、問題の解決策は非常に独創的であることがわかり、非常に限られたフレームワーク内でそれを探す必要があったので、興味深いと思います。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンドの役割</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は真実を装って論争の的となる問題を提起しないことをすぐに言わなければなりません。フロントエンド、特にウェブの皮肉には、取るに足らないものとして、私は幾分落ち込んでいます。そして、時々これが合理的に起こることはさらに憂鬱です。現在、ファッションはすでに眠っていますが、誰もがフレームワーク、パラダイム、およびその他のエンティティを駆使していたとき、彼らは大々的にこれが非常に重要で非常に必要であると大声で言い、その代わりにフロントエンドがフォームの出力を処理するという皮肉を受け取りましたボタンをクリックする処理は、「膝の上」で実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、ある程度、すべてが通常に戻っています。次のフレームワークの各マイナーリリースについて話したいと思う人はいません。実用性への意識が高まっているため、完璧なツールやアプローチを探している人はほとんどいません。しかし、これでさえ、例えば、Electronとその上でのアプリケーションをほとんど不当に叱るのを妨げません。これはフロントエンドが解決しようとしているタスクを理解していないためだと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドは、バックエンドによって提供される情報を表示するための単なる手段ではなく、ユーザーアクションを処理するための単なる手段ではありません。フロントエンドはより抽象的であり、単純で明確な定義を与えると、必然的に意味が失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドは「フレームワーク」の中にあります。たとえば、技術的には、バックエンドによって提供されるAPIとI / O機能によって提供されるAPIの間です。タスクに関しては、UXが解決するユーザーインターフェースのタスクとバックエンドが解決するタスクの間です。したがって、かなり狭いフロントエンドの特殊化、つまり層の特殊化が得られます。これは、フロントエンドプロバイダーが専門分野を超えて領域に影響を与えることができないことを意味しませんが、この影響が不可能である瞬間に、真のフロントエンドタスクが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は矛盾として表現できます。</font><font style="vertical-align: inherit;">ユーザーインターフェイスは、データモデルとバックエンドの動作に準拠する必要はありません。</font><font style="vertical-align: inherit;">バックエンドの動作とデータモデルは、ユーザーインターフェイスのタスクに合わせる必要はありません。</font><font style="vertical-align: inherit;">そして、フロントエンドの役割は、この矛盾を取り除くことです。</font><font style="vertical-align: inherit;">バックエンドのタスクとユーザーインターフェースのタスクの不一致が大きいほど、フロントエンドの役割が重要になります。</font><font style="vertical-align: inherit;">そして、私が話していることを明確にするために、この不一致が何らかの理由で重大であることが判明した例を挙げます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStack LBaaSは、私の意見では、サーバー間の負荷のバランスをとるために必要なツールのハードウェアとソフトウェアの複合体です。その実装は、客観的な要素、物理的な表示に依存することが重要です。このため、APIとこのAPIとの対話方法にはいくつかの特殊性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーインターフェイスを開発する際の主な関心は、バックエンドの技術的機能ではなく、その基本的な機能です。インターフェースはユーザー用に作成され、ユーザーはバランシングパラメーターを管理するためのインターフェースを必要とし、ユーザーはバックエンド実装の内部機能に飛び込む必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドは大部分がコミュニティによって開発されており、非常に限られた量でその開発に影響を与えることが可能です。私にとっての重要な機能の1つは、バックエンド開発者がパフォーマンスのためにコントロールの利便性とシンプルさを犠牲にする準備ができていることです。これは、負荷のバランスをとることが問題なので絶対に正当化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の微妙な点があり、いくつかの質問に警告しながら、すぐにそれを概説したいと思います。</font><font style="vertical-align: inherit;">OpenStackとそのAPIではライトが収束しなかったことは明らかです。</font><font style="vertical-align: inherit;">OpenStack APIと連動する独自のツールセットまたは「レイヤー」をいつでも開発して、ユーザータスクに便利な独自のAPIを作成できます。</font><font style="vertical-align: inherit;">唯一の問題は便宜です。</font><font style="vertical-align: inherit;">最初に利用可能なツールを使用して、意図したとおりにユーザーインターフェイスを実装できる場合、エンティティを作成することには意味がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問への答えは多面的であり、ビジネスにとっては、開発者、その雇用、能力、責任の問題、サポートなどにかかっています。</font><font style="vertical-align: inherit;">私たちのケースでは、フロントエンドでいくつかのタスクを解決することが最も好都合でした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenStack LBaaSの機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドに大きな影響を与えた機能のみを特定したいと思います。これらの機能が発生した理由やそれらが依存する機能についての質問は、この記事の範囲を超えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は既製のドキュメントを扱い、その機能を受け入れる必要があります。 OpenStack Octaviaの内部に興味がある人なら誰でも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公式ドキュメントを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知ることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。 Octaviaは、OpenStackエコシステムの負荷を分散するように設計されたツールスイートの名前です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発中に遭遇した最初の機能は、バランサーの状態を表示するために必要な多数のモデルと関係です。で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オクタヴィアAPI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12のモデルが説明されていますが、クライアント側に必要なのは7つだけです。これらのモデルには接続があり、多くの場合非正規化されています。下の画像はおおよその図を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img title="OpenStack Octaviaモデルと関係のサンプル図" src="https://habrastorage.org/webt/p2/fw/2v/p2fw2vvyascudv9zjx5a0m-5bkq.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「7」はそれほど印象的ではありませんが、実際には、インターフェイスの完全な動作を保証するために、このテキストを書いている時点で、16のデータモデルとそれらの間の約30の関係を使用する必要がありました。</font><font style="vertical-align: inherit;">Octaviaはバランサーにすぎないため、他のOpenStackモジュールが機能する必要があります。</font><font style="vertical-align: inherit;">そして、これらすべては、ユーザーインターフェイスの2ページだけに必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目と3番目の機能は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびトランザクションOctaviaです。</font><font style="vertical-align: inherit;">データモデルには</font><font style="vertical-align: inherit;">、オブジェクトに対して実行された操作の状態を反映</font><font style="vertical-align: inherit;">する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド</font><font style="vertical-align: inherit;">があります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティブ</font></font></td>
<td>   </td>
</tr>
<tr>
<td>DELETED</td>
<td> </td>
</tr>
<tr>
<td>ERROR</td>
<td> </td>
</tr>
<tr>
<td>PENDING_CREATE</td>
<td>   </td>
</tr>
<tr>
<td>PENDING_UPDATE</td>
<td>   </td>
</tr>
<tr>
<td>PENDING_DELETE</td>
<td>   </td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの読み取り操作は同期的に行われ、制限はありません。ただし、作成、更新、削除の操作には、不特定の時間がかかる場合があります。これは、データモデルには、おおまかに言って物理的な意味があるという事実によるものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成のリクエストを送信した後、レコードが表示され、それを読み取ることができますが、作成操作が完了するまで、このレコードに対して他の操作を実行することはできません。そのような試みはエラーになります。オブジェクトが入っている場合にのみ、オブジェクトの変更動作を開始することができる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACTIVE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font><font style="vertical-align: inherit;">;あなたが削除のためにオブジェクトを送信することができ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACTIVE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERROR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータス</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのステータスはWebSocketを介して送信され、処理が非常に容易になりますが、トランザクションははるかに大きな問題です。</font><font style="vertical-align: inherit;">オブジェクトに変更を加えると、関連するすべてのモデルもトランザクションに参加します。</font><font style="vertical-align: inherit;">変更行う場合たとえば、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メンバーを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関連する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プール</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスナー、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロードバランサーが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックされます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、Webソケットで受信したイベントに関しては次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img title="関連オブジェクトのステータスを変更するプロセス。" src="https://habrastorage.org/webt/ia/fp/ff/iafpffzblzikgdekdrrs83br1_y.png"></div><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の4つのイベントは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PENDING_UPDATE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスへのオブジェクトの転送です</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターゲット</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド</font><font style="vertical-align: inherit;">には、トランザクションに参加しているオブジェクトのモデルの名前が含まれています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5番目のイベントは単なる複製です（何に関連しているかはわかりません）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後の4つは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACTIVE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスへの復帰転送</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">この場合、これは重量変更操作であり、1秒未満で完了しますが、多くの時間がかかる場合があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリーンショットでは、イベントの順序が厳密である必要がないことも確認できます。</font><font style="vertical-align: inherit;">したがって、操作を開始するには、オブジェクト自体のステータスだけでなく、トランザクションに参加するすべての依存関係のステータスも知る必要があることがわかります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーインターフェース機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、2つのサーバー間でバランスを取るためにどこかを知る必要があるユーザーの立場にいる自分を想像してください。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バランシングアルゴリズムを定義するリスナーを作成する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プールを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスナーにプールを割り当てます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バランスポートへのリンクをプールに追加します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前に作成されたすべてのオブジェクトに依存する、操作の完了を待つ必要があるたび。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部調査が示したように、通常のユーザーの見解では、バランサーには入口点が必要であり、出口点と実行される平衡化のパラメーター（アルゴリズム、重量など）が必要であるというおおよその認識しかありません。ユーザーはOpenStackが何であるかを知る必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
認識のためのインターフェースがどれほど複雑であるかはわかりません。ユーザー自身が、上記のバックエンドのすべての技術的機能に従う必要があります。コンソールの場合、これはテクノロジーへの高度な没入を意味するため、これは許容される場合がありますが、Webの場合、そのようなインターフェースは恐ろしいものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web上では、ユーザーは彼が1つの明確で論理的なフォームに記入し、1つのボタンを押して待つのを待つだけで、すべてが機能します。おそらくこれは議論の余地がありますが、私はフロントエンドの実装に影響を与える機能に集中することを提案します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースは、操作のカスケード使用を含むように設計されました。インターフェースの1つのアクションには複数の操作が含まれる場合があります。インターフェースは、ユーザーが現在不可能であるアクションを実行できることを意味しませんが、インターフェースは、ユーザーがこれがなぜそうであるかを理解する必要があると想定しています。インターフェースは単一の全体であるため、その個々の要素は、メタ情報を含むさまざまな依存エンティティからの情報を使用できます。</font></font><br>
<br>
<div style="text-align:center;"><img title="Selectelパネルのバランサーリストインターフェース" src="https://habrastorage.org/webt/cc/no/am/ccnoamyjre40swvpswygbqezn_w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スイッチ、アコーディオン、タブ、コンテキストメニューなど、バランサーに固有ではないいくつかのインターフェース機能があることを考慮し、最初にそれらの動作原理が明確であると想定すると、負荷分散が何であるかを知っているユーザーにとっては、上記のインターフェースのほとんどを読んで、それを管理する方法について推測することは非常に困難です。</font><font style="vertical-align: inherit;">しかし、インターフェースのどの部分がバランサー、リスナー、プール、メンバー、およびその他のエンティティーのモデルの背後に隠れているかを強調することは、もはや最も明白なタスクではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矛盾の解決</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドの機能がインターフェースにうまく適合しないこと、およびこれらの機能がバックエンドによって常に削除できるわけではないことを示すことができたと思います。これに加えて、インターフェースの機能はバックエンドにうまく適合せず、インターフェースを複雑にすることなく常に排除できるわけではありません。これらの領域はそれぞれ独自の問題を解決します。フロントエンドの責任は、問題を解決して、インターフェースとバックエンド間の必要なレベルの対話を確実にすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の練習では、私はすぐに頭を使ってプールに急いで行き、注意を払っていなかったり、むしろより高い機能を理解しようとしたりしていませんでしたが、幸運でしたか、経験が役立ちました（そして正しいベクトルが選択されました）。サードパーティのAPIまたはライブラリを使用する場合は、ドキュメントを事前に理解しておくと非常に便利であることにすでに気づきました。詳細が多いほど良いでしょう。ドキュメントは多くの場合互いに類似しており、人々は依然として他の人々の経験に依存していますが、個々のシステムの機能の説明があり、詳細に含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な情報をキーワードで抽出するのではなく、最初にドキュメントの調査にさらに2時間を費やした場合、私は遭遇する問題について考えたでしょう。この知識は、ごく初期の段階からプロジェクトのアーキテクチャに影響を与える可能性があります。初めに犯した間違いをなくすために戻ることは、非常に意気消沈します。また、完全なコンテキストがないと、何度か戻ってくる必要がある場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、ラインを曲げて、「スイートスポット」のコードを徐々に生成していくこともできますが、このコードのヒープが大きくなるほど、結局、レーキは難しくなります。もちろん、アーキテクチャを設計するときは、あまり深く掘り下げないでください。可能な限り多くの時間を費やして、可能なオプションと不可能なオプションをすべて検討し、バランスを見つけることが重要です。しかし、多かれ少なかれドキュメンテーションとの詳細な知り合いは、それほど多くの時間ではなく、非常に有用な投資であることが判明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、最初から、多数のモデルが関与していたので、すべての接続を維持したまま、クライアントへのバックエンド状態のマッピングを構築する必要があることに気付きました。</font><font style="vertical-align: inherit;">すべての接続など、必要なすべての情報をクライアントに表示した後、タスクキューを編成する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データは非同期に更新され、操作の可用性はさまざまな条件によって決まります。カスケード操作が必要な場合、そのような条件ではキューを省略できません。</font><font style="vertical-align: inherit;">おそらく、簡単に言えば、これは私のソリューションのアーキテクチャ全体です。つまり、バックエンドの状態とタスクキューを反映したストレージです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルと関係の数は不明確であるため、リポジトリコレクションの宣言的な説明を返すファクトリを使用してこれを行うことにより、リポジトリの構造にスケーラビリティを組み込みました。コレクションには、CRUDを使用した単純なモデルクラスであるサービスがあります。たとえば、RoRや古き良きバックボーンで行われているように、モデル内のリンクの説明を作成することは可能ですが、これには大量のコードを変更する必要があります。したがって、リレーションの説明はモデルクラスの隣にあります。</font></font><br>
<br>
<div style="text-align:center;"><img title="リンク説明例" src="https://habrastorage.org/webt/_y/jw/pr/_yjwpryzsckc_by0igzpq5vlog0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計で、1対1、1対多の2種類の接続を取得しました。フィードバックも記述できます。タイプに加えて、依存関係のコレクション、検出された依存関係が関連付けられているフィールド、および依存オブジェクトのIDが読み取られるフィールド（1対多の関係の場合は、IDのリストが読み取られます）が示されます。オブジェクトの通信条件がオブジェクトへの単純なリンクよりも複雑である場合、ファクトリでは2つのオブジェクトをテストする機能を説明できます。その結果は接続の存在を決定します。それはすべて少し「自転車」のように見えますが、不必要な依存関係がなく、正確に機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリには、リソースの追加と削除を待機するためのモジュールがあり、本質的に、条件付きチェックとpromisインターフェースで1回限りのイベントを処理しています。サブスクライブすると、イベントのタイプ（追加、削除）、テスト関数、およびハンドラーが渡されます。特定のイベントが発生し、テスト結果が正の場合、ハンドラーが実行され、その後追跡が停止します。同期的にサブスクライブしているときにイベントが発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなパターンを使用することで、モデル間の任意の複雑な関係を自動的に付加し、1か所で実行できるようになりました。この場所をトラッカーと呼んだ。オブジェクトをリポジトリに追加すると、その関係の追跡が開始されます。待機モジュールを使用すると、イベントに応答し、監視対象オブジェクトとストレージ内のオブジェクトの間の接続を確認できます。オブジェクトがすでにストレージにある場合、待機モジュールはハンドラーをすぐに呼び出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなストレージデバイスを使用すると、任意の数のコレクションとそれらの間の関係を記述できます。オブジェクトを追加および削除すると、ストアは依存オブジェクトのコンテンツを含むプロパティを自動的に配置またはリセットします。このアプローチの利点は、すべての関係が明示的に記述され、それらが1つのシステムによって監視および更新されることです。短所-実装とデバッグの複雑さ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、そのようなリポジトリはかなり自明であり、既製のソリューションを既存のコードベースに統合することははるかに困難ですが、既製のソリューションにタスクキューをアタッチすることはさらに難しいため、私は自分で作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクションのようなすべてのタスクには宣言的な説明があり、ファクトリによって作成されます。</font><font style="vertical-align: inherit;">タスクの説明には、開始の条件と、現在のタスクが完了した後にキューに追加する必要があるタスクのリストを含めることができます。</font></font><br>
<br>
<div style="text-align:center;"><img title="プールを作成するためのタスクを生成する例" src="https://habrastorage.org/webt/03/7w/fo/037wfo0c0fn7uxeblixnsahw7j8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、プールを作成するタスクについて説明しています。</font><font style="vertical-align: inherit;">依存関係はバランサーとリスナーを示します。デフォルトでは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACTIVE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスのチェックが実行されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">キュー内のタスクの処理は同期的に発生する可能性があるため、バランサーのオブジェクトはブロックされます。ブロックにより、実行要求が送信されたときの競合が回避されますが、ステータスはまだ変更されていませんが、変更されることが想定されています。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PARENTの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">、タスクのカスケードの結果としてプールが作成された場合、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は自動的に置き換えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プールを作成した後、タスクをキューに追加して、可用性モニターを作成し、このプールのすべてのメンバーを作成します。出力は、完全にJSONに変換できる構造です。これは、障害が発生した場合にキューを復元できるようにするために行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューは、タスクの説明に基づいて、リポジトリ内のすべての変更を個別に監視し、タスクの実行に必要な条件を確認します。</font><font style="vertical-align: inherit;">すでに述べたように、ステータスはWebソケットを介して送信され、キューに必要なイベントを生成するのは非常に簡単ですが、必要に応じてタイマーデータ更新メカニズムをアタッチすることは問題になりません（これは、Webソケットがさまざまな理由で非常に安定して動作しない場合があります）。</font><font style="vertical-align: inherit;">タスクが完了すると、キューは指定されたオブジェクトのリンクを更新する必要があることをリポジトリに自動的に通知します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケーラビリティの必要性から、宣言型アプローチが導入されました。モデルとモデル間の関係を表示する必要性から、単一のリポジトリーが生まれました。依存オブジェクトを処理する必要があるため、キューが発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのニーズを組み合わせることは、実装の点で最も簡単な作業ではない場合があります（ただし、これは別の問題です）。ただし、アーキテクチャに関しては、このソリューションは非常にシンプルであり、バックエンドのタスクとユーザーインターフェースの間のすべての矛盾を排除し、それらの相互作用を確立して、任意の関係者の他の可能な機能の基盤を築くことができます。</font><font style="vertical-align: inherit;">Selectel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コントロールパネル</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の側面から見る</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、バランシングプロセスはシンプルで明確であり、顧客は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">サービス</font></a><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">利用</font></a><font style="vertical-align: inherit;">でき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トラフィックを柔軟に管理する機能を維持しながら、バランサーの独立した実装にリソースを費やさないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今すぐバランサーを動かしてみて、コメントにレビューを書いてください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455511/index.html">睡眠はプログラマーの頭脳のための主要な資源です</a></li>
<li><a href="../ja455513/index.html">爆発と世界的な陰謀：リチウムイオン電池の物語</a></li>
<li><a href="../ja455515/index.html">自己暗号化Aigo外付けHDDを逆にしてハッキングする。パート1：パーツに分解する</a></li>
<li><a href="../ja455517/index.html">銀行業界での彼の仕事についてのNetologyコース「Data Science」の卒業生</a></li>
<li><a href="../ja455519/index.html">新しい開発者のオンボーディングを実装した方法</a></li>
<li><a href="../ja455525/index.html">ジンブラとメール爆弾防御</a></li>
<li><a href="../ja455527/index.html">これには何が書いてあるの？JavaScriptオブジェクトの舞台裏</a></li>
<li><a href="../ja455529/index.html">自己暗号化外付けAigo HDDを逆にしてハッキングする。パート2：サイプレスPSoCでのダンプ</a></li>
<li><a href="../ja455533/index.html">バブル物理学：泡破壊メカニズムの探索</a></li>
<li><a href="../ja455535/index.html">クラウドとコンテナでのSSL / TLS証明書の管理-人間の作業ではない</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>