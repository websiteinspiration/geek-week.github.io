<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍⚖️ 👩🏻‍⚖️ ✍🏻 Vanya去找祖母或动态JavaScript自适应 👫 🌀 🍗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在进行自适应工作时，我们时不时必须更改对象的外观。通常，我们只要注册几个媒体查询就可以了。在某些情况下，我们需要更改元素的顺序，例如，这里有来自Flexbox或Grid技术的order属性。但是有时候这对我们没有帮助。
 
 动态自适应的思想旨在简化布局设计者的工作，并快速适应复杂的布局元素。
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Vanya去找祖母或动态JavaScript自适应</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502028/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在进行自适应工作时，我们时不时必须更改对象的外观。</font><font style="vertical-align: inherit;">通常，我们只要注册几个媒体查询就可以了。</font><font style="vertical-align: inherit;">在某些情况下，我们需要更改元素的顺序，例如，这里有来自Flexbox或Grid技术的order属性。</font><font style="vertical-align: inherit;">但是有时候这对我们没有帮助。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
动态自适应的思想旨在简化布局设计者的工作，并快速适应复杂的布局元素。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/QKuMr575vlQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，看这种情况。在这里，我们具有以下结构：标题和一些文本。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jd/hs/i8/jdhsi8bq-3u7lszevxzxd9mmgxq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在获得一定许可的情况下，设计人员指出，标题下的文本现在应该在结构中完全不同的位置。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cy/e4/u6/cye4u6m9mmoop_qysyp4mzfxinq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，布局设计人员可以通过以下两种方法之一解决此问题。我会很快提醒您的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将以一个生活状况的例子为例进行说明，当时男生Vanya确实想在夏天到祖母那里来。但这不是因为他想念祖母，而是因为他想和女孩Olya一起去河里。他想以低于992px的分辨率进行操作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x9/ev/nj/x9evnjtlgrzdje2vpbxvajitcw8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将如何解决Vani问题？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以执行以下操作：在获得许可的情况下将Vanya隐藏在城市中，并与Olya在河上展示Vanya。但是为此，我们需要克隆Vani。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是城市（原始）瓦尼亚。但是事实上，瓦尼亚（Vanya）已经和奥利亚（Olya）在河上了。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cq/34/hu/cq34hu8vfdlpqmc5nqsniftrdxw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是最初，这条河Vanya隐藏在CSS中。我们用所需的参数编写媒体查询，在其中显示新的Vanya，隐藏旧的Vanya（城市）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2t/i0/id/2ti0idhaphwbdm9kelpifg0ndec.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都为我们解决了-在我们需要的许可下，Vanya陷入Olya的统治之下。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/hz/i6/vvhzi6fnhiti6hed2t5ojkq42wg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，当分辨率大于992px时，Vanya立即返回城市。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vd/s1/q7/vds1q743_a221midfog7xtlodtq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切似乎都还好，需要时Vanya和Olya在一起。你可以驱散...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但不是那么简单。实际上，一些客户非常反对重复的内容。这是由SEO的一些问题以及原则上不必要的块的创建引起的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们很幸运，在我们的情况下，Vanya有点小，而Vanya却又很大，很笨重，需要很多代码。在这种情况下，包括客户在内，他们都要求您使用JavaScript移动DOM对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这可以大致如下进行。首先，我必须从HTML中删除克隆的Vanya，并将Vanya保留为原始格式。在CSS中，注释掉我们最初用于其他包装选项的所有行。并在此处添加这样一个简单的JS代码。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-keyword">const</span> parent_original = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.content__blocks_city'</span>);
<span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.content__column_river'</span>);
<span class="hljs-keyword">const</span> item = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.content__block_item'</span>);<font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, move);<font></font>
<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-keyword">const</span> viewport_width = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">document</span>.documentElement.clientWidth, <span class="hljs-built_in">window</span>.innerWidth || <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span> (viewport_width &lt;= <span class="hljs-number">992</span>) {
		<span class="hljs-keyword">if</span> (!item.classList.contains(<span class="hljs-string">'done'</span>)) {<font></font>
			parent.insertBefore(item, parent.children[<span class="hljs-number">2</span>]);<font></font>
			item.classList.add(<span class="hljs-string">'done'</span>);<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (item.classList.contains(<span class="hljs-string">'done'</span>)) {<font></font>
			parent_original.insertBefore(item, parent_original.children[<span class="hljs-number">2</span>]);<font></font>
			item.classList.remove(<span class="hljs-string">'done'</span>);<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
move();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们声明变量以“拨号”到城市，河流和原始瓦尼。接下来，我们开始“监听”屏幕的宽度，以捕捉需要移动Vanya的时刻。得到宽度并设置条件后，我们检查宽度是否小于或等于992px。搬迁Vanya时，我们为他分配了一个班级，因此我们检查班级是否存在，以确保这种迁移不会一直发生（Vanya搬了一次，就是这样，您不需要不断地转移它）。然后，我们在父级（到河流）内部执行转移，在这里，我们指出了需要移动Vanya（在Olya之下，Olya之上）在DOM树中的位置。当分辨率大于992px时，必须将Vanya返回该位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们尝试看到我们的Vanya再次移居Olya之下。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都很好：我们没有重复的内容，一切都很好，客户满意，每个人都很高兴。但是，此方法存在许多与js代码本身的编写相关的问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们了解在单个情况下这是正常现象-我们写得很好。但是我想到了使这个过程自动化的想法。假设我需要在页面上抛出5-6个完全不同的元素。对于此任务，使用此方法编写js代码非常麻烦且耗时。第二点自然使许多人感到压力，这是用户PC上的负载，因为在这里，我们一直在“监听”屏幕的宽度。我也想优化这一刻。也可以在此代码中对其进行优化，但是由于我编写了一个称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“动态自适应”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的自动化</font><b><font style="vertical-align: inherit;">工具</font></b><font style="vertical-align: inherit;">，因此我</font><font style="vertical-align: inherit;">在此处进行了优化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我将向您展示一切。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接了动态自适应系统后，我只需要使用HTML文件，就不需要访问JavaScript。为此，我需要编写data-da属性（da是动态自适应的缩写），并在引号中指定三个参数，并用逗号分隔。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个参数是where。我将要移动Vanya的对象放在独特的类中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个参数是（连续）。我的对象有两个元素：零和第一个（我们知道在JavaScript中，一切都是从头开始的）。我需要在“ 1”对象之后插入Vanya，因此我正在编写“ 2”参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三个参数是when。在第三个参数中，我输入“ 992”，这是Vanya真正想要达到Olya的分辨率。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二和第三个参数是可选的。默认情况下，对象将以低于768px的分辨率移动到块的末尾。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s6/aw/an/s6awan4diwfqltbtcyvt7nkkg-k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们检查。一切工作与以前的版本相同，但是没有内容重复并且一切都是自动化的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑设施。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，为了将Vanya移到Olya上，我只需要更改第二个属性参数中的序列号即可。 Vanya已经超过Olya。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cl/w1/it/clw1it_jfjybuy4wewk8bwxdbio.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方便吧？我可以对第三个断点参数执行相同的操作。我可以指定例如1280px。 （data-da =“ content__column_river，1,1280”）。因此，恰好达到此值时，Vanya会更早到达Olya。最酷的是Vanya绝对会自动回到他的位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了增加舒适度，您可以指定两个值之一-第一个或最后一个，以代替属性的第二个参数中的序列号。当我第一次写时，Vanya将移至标题“我是河”。它将位于我们发送对象的内部的第一个位置。因此，如果您指定last，那么我们的Vanya将位于对象的最底部。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/kb/l4/hxkbl42bvvf9aqvsnffcqhpkq0w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们再看几个例子。假设我们可以将Kolya发送到Lota的花园，也可以将Anya发送到河中的Van和Ola，这将变得更加有趣。我们为Kolya编写了一个参数为</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data-da =“ content__column_garden，2,992”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的属性</font><font style="vertical-align: inherit;">。对于Ani，我们编写</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data-da =“ content__column_river，1.1280”。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我们看：河上的Anya，Olya和Vanya。 Kolya过了一会儿去了Lota。返回时，所有的人都在他们的地方。一切都很棒。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在CodePen中玩：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codepen.io/FreelancerLifeStyle/project/full/ZmWOPm</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当然，您可能会遇到一个问题：可挂在可重定位对象上的事件呢？例如，最初，当单击Anya时，我们将获得一个标有“一切都OK”的窗口。让我们看看当她和家伙们一起搬到河边时会发生什么。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移动，单击-一切正常，还显示窗口。事件在移动时仍与对象一起保留。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/yp/9w/pnyp9wq5kdlt6nl5ypa-rgx3uhw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个令人兴奋的问题是负载，我试图将其最小化。现在，我将通过讲一些隐藏在动态自适应引擎背后的代码来展示这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我声明一些变量，包括创建数组，这些变量我在下面填写。我得到属性，将其分离，将其变成数组以获取单个元素。接下来，我填写对象的原始位置，以便可以将其返回到父母的位置（在城市中）。之后，我填写元素本身的数组，以便可以对其进行排序以进行正确的操作。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> originalPositions = [];
<span class="hljs-keyword">let</span> daElements = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'[data-da]'</span>);
<span class="hljs-keyword">let</span> daElementsArray = [];
<span class="hljs-keyword">let</span> daMatchMedia = [];
<span class="hljs-comment">// </span>
<span class="hljs-keyword">if</span> (daElements.length &gt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">let</span> number = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; daElements.length; index++) {
		<span class="hljs-keyword">const</span> daElement = daElements[index];
		<span class="hljs-keyword">const</span> daMove = daElement.getAttribute(<span class="hljs-string">'data-da'</span>);
		<span class="hljs-keyword">if</span> (daMove != <span class="hljs-string">''</span>) {
			<span class="hljs-keyword">const</span> daArray = daMove.split(<span class="hljs-string">','</span>);
			<span class="hljs-keyword">const</span> daPlace = daArray[<span class="hljs-number">1</span>] ? daArray[<span class="hljs-number">1</span>].trim() : <span class="hljs-string">'last'</span>;
			<span class="hljs-keyword">const</span> daBreakpoint = daArray[<span class="hljs-number">2</span>] ? daArray[<span class="hljs-number">2</span>].trim() : <span class="hljs-string">'767'</span>;
			<span class="hljs-keyword">const</span> daDestination = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.'</span> + daArray[<span class="hljs-number">0</span>].trim())
			<span class="hljs-keyword">if</span> (daArray.length &gt; <span class="hljs-number">0</span> &amp;&amp; daDestination) {<font></font>
				daElement.setAttribute(<span class="hljs-string">'data-da-index'</span>, number);
				<span class="hljs-comment">//   </span><font></font>
				originalPositions[number] = {<font></font>
					<span class="hljs-string">"parent"</span>: daElement.parentNode,
					<span class="hljs-string">"index"</span>: indexInParent(daElement)<font></font>
				};<font></font>
				<span class="hljs-comment">//   </span><font></font>
				daElementsArray[number] = {<font></font>
					<span class="hljs-string">"element"</span>: daElement,
					<span class="hljs-string">"destination"</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.'</span> + daArray[<span class="hljs-number">0</span>].trim()),
					<span class="hljs-string">"place"</span>: daPlace,
					<span class="hljs-string">"breakpoint"</span>: daBreakpoint<font></font>
				}<font></font>
				number++;<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
	dynamicAdaptSort(daElementsArray);<font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; daElementsArray.length; index++) {
		<span class="hljs-keyword">const</span> el = daElementsArray[index];
		<span class="hljs-keyword">const</span> daBreakpoint = el.breakpoint;
		<span class="hljs-keyword">const</span> daType = <span class="hljs-string">"max"</span>; <span class="hljs-comment">// MobileFirst   min</span><font></font>
<font></font>
		daMatchMedia.push(<span class="hljs-built_in">window</span>.matchMedia(<span class="hljs-string">"("</span> + daType + <span class="hljs-string">"-width: "</span> + daBreakpoint + <span class="hljs-string">"px)"</span>));<font></font>
		daMatchMedia[index].addListener(dynamicAdapt);<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，实现了我所讨论的优化：不是使用窗口调整大小（监听每个窗口更改），而是仅使用窗口matchMedia监听断点处的更改。</font><font style="vertical-align: inherit;">这样，我们仅在某些时候获得浏览器响应：在对象属性中指示的响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我收集这些断点的数组，并为每个断点挂起一个事件。</font><font style="vertical-align: inherit;">在主要的dynamic_adapt函数中，我将所有这些扩展到我们收集和排序的数组内，检查是否存在断点，移动元素或将其返回到其位置。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dynamicAdapt</span>(<span class="hljs-params">e</span>) </span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; daElementsArray.length; index++) {
		<span class="hljs-keyword">const</span> el = daElementsArray[index];
		<span class="hljs-keyword">const</span> daElement = el.element;
		<span class="hljs-keyword">const</span> daDestination = el.destination;
		<span class="hljs-keyword">const</span> daPlace = el.place;
		<span class="hljs-keyword">const</span> daBreakpoint = el.breakpoint;
		<span class="hljs-keyword">const</span> daClassname = <span class="hljs-string">"_dynamic_adapt_"</span> + daBreakpoint;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (daMatchMedia[index].matches) {
			<span class="hljs-comment">// </span>
			<span class="hljs-keyword">if</span> (!daElement.classList.contains(daClassname)) {
				<span class="hljs-keyword">let</span> actualIndex = indexOfElements(daDestination)[daPlace];
				<span class="hljs-keyword">if</span> (daPlace === <span class="hljs-string">'first'</span>) {<font></font>
					actualIndex = indexOfElements(daDestination)[<span class="hljs-number">0</span>];<font></font>
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (daPlace === <span class="hljs-string">'last'</span>) {<font></font>
					actualIndex = indexOfElements(daDestination)[indexOfElements(daDestination).length];<font></font>
				}<font></font>
				daDestination.insertBefore(daElement, daDestination.children[actualIndex]);<font></font>
				daElement.classList.add(daClassname);<font></font>
			}<font></font>
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">//  </span>
			<span class="hljs-keyword">if</span> (daElement.classList.contains(daClassname)) {<font></font>
				dynamicAdaptBack(daElement);<font></font>
				daElement.classList.remove(daClassname);<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
	customAdapt();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回原位功能：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dynamicAdaptBack</span>(<span class="hljs-params">el</span>) </span>{
	<span class="hljs-keyword">const</span> daIndex = el.getAttribute(<span class="hljs-string">'data-da-index'</span>);
	<span class="hljs-keyword">const</span> originalPlace = originalPositions[daIndex];
	<span class="hljs-keyword">const</span> parentPlace = originalPlace[<span class="hljs-string">'parent'</span>];
	<span class="hljs-keyword">const</span> indexPlace = originalPlace[<span class="hljs-string">'index'</span>];
	<span class="hljs-keyword">const</span> actualIndex = indexOfElements(parentPlace, <span class="hljs-literal">true</span>)[indexPlace];<font></font>
	parentPlace.insertBefore(el, parentPlace.children[actualIndex]);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然，许多人都对Mobile First有疑问。</font><font style="vertical-align: inherit;">没问题-我们只需要更改代码中的一些变量即可（在HTML中删除此设置已在起作用）：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我收集一组断点时，我们需要在此处将“ max”更改为“ min”。</font><font style="vertical-align: inherit;">事件将不是通过最大宽度而是最小宽度来“监听”。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您还需要更改排序，以便在我们按断点对它们进行排序时，数组中的对象以不同的顺序对齐。 </font></font></li>
</ol><br>
<pre><code class="javascript hljs">	<span class="hljs-comment">// </span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dynamicAdaptSort</span>(<span class="hljs-params">arr</span>) </span>{<font></font>
		arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
			<span class="hljs-keyword">if</span> (a.breakpoint &gt; b.breakpoint) { <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> } <span class="hljs-comment">// MobileFirst </span><font></font>
		});<font></font>
		arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
			<span class="hljs-keyword">if</span> (a.place &gt; b.place) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> }<font></font>
		});<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样在动态自适应中，当对象被抛出时，我使用某种获取索引的方法。</font><font style="vertical-align: inherit;">这是第一个缺陷-我必须排除传输的对象。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">当我将对象转移到同一位置时，以便一切都足够，并且对象按我们想要的顺序排列，转移时，我需要将先前转移的对象排除到同一点。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//       </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOfElements</span>(<span class="hljs-params">parent, back</span>) </span>{
	<span class="hljs-keyword">const</span> children = parent.children;
	<span class="hljs-keyword">const</span> childrenArray = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
		<span class="hljs-keyword">const</span> childrenElement = children[i];
		<span class="hljs-keyword">if</span> (back) {<font></font>
			childrenArray.push(i);<font></font>
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">//  </span>
			<span class="hljs-keyword">if</span> (childrenElement.getAttribute(<span class="hljs-string">'data-da'</span>) == <span class="hljs-literal">null</span>) {<font></font>
				childrenArray.push(i);<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> childrenArray;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是带来了另一个分类问题。例如，如果我将这些人同时转移到同一位置，则将无法控制他们的订单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开发这种动态自适应方法的一种方法可以是，例如，创建多个断点。例如，我们需要将Vanya移至1280px处的Ola，然后将Vanya移至992px处才能移至花园或返回该位置。该功能现在不可用，因此仍有工作要做。通常，要满足95％的自适应日常任务，现在的功能对我来说已经足够了。为了解决将项目移动到另一个地方的问题，我现在需要花几秒钟编写一个属性。我会得到所需的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然，我强烈要求所有喜欢动态自适应的人参与其功能，代码本身的优化的测试，开发和改进。</font><font style="vertical-align: inherit;">所有这些使我们的Kohl，Ani，Vani和Olya可以在需要的时候在一起。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库GitHub的上</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/FreelancerLifeStyle/dynamic_adapt</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
基于视频“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态自适应//在JavaScript复杂对象的快速自适应</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的YouTube频道”“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自由职业者的生活</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN502000/index.html">12项数据工程在线课程</a></li>
<li><a href="../zh-CN502004/index.html">看板方法：将您的过程理解为集体知识的构建过程-第1部分（食谱）</a></li>
<li><a href="../zh-CN502008/index.html">面向大众编程</a></li>
<li><a href="../zh-CN502012/index.html">面向所有人的Azure：入门课程</a></li>
<li><a href="../zh-CN502018/index.html">播客关于移动设备的安全性及其保护解决方案的开发</a></li>
<li><a href="../zh-CN502030/index.html">Oracle中的Web服务</a></li>
<li><a href="../zh-CN502034/index.html">React中的受控组件和非受控组件不必太复杂</a></li>
<li><a href="../zh-CN502038/index.html">提升原子，方法2.0.1</a></li>
<li><a href="../zh-CN502040/index.html">关于短语动词5（上/下）</a></li>
<li><a href="../zh-CN502042/index.html">分析师访谈-AppMetrica产品经理Alexander Sibrikov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>