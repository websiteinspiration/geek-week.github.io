<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏽 🔉 💮 如何在3年内不从头开始创建加密货币 ☸️ 🙏 😰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将描述我是如何从头开始独自编写加密货币的，我从那里学到了什么有趣的技术，我留下了什么经验以及后来发生了什么。这不是教程，而只是事件的描述，但是，如果我愿意，我可以写几篇关于事件和原因的文章，尽管我不确定是否有人需要它。在本文的结尾，将得出我创建3年后得出的结论。
 
 大家好，我很久没写...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>如何在3年内不从头开始创建加密货币</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505330/"><img src="https://habrastorage.org/webt/p5/vm/p3/p5vmp3vpw1waurtqnk8ccsaqmgc.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将描述我是如何从头开始独自编写加密货币的，我从那里学到了什么有趣的技术，我留下了什么经验以及后来发生了什么。</font><font style="vertical-align: inherit;">这不是教程，而只是事件的描述，但是，如果我愿意，我可以写几篇关于事件和原因的文章，尽管我不确定是否有人需要它。</font><font style="vertical-align: inherit;">在本文的结尾，将得出我创建3年后得出的结论。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大家好，我很久没写任何东西了。</font><font style="vertical-align: inherit;">我关于prolog机器人的最后一篇文章或多或少取得了成功，并且观众喜欢它。</font><font style="vertical-align: inherit;">由于我喜欢适应各种奇怪的事情，所以我想做点什么。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一点历史</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在2017年夏天，我开始阅读有关区块链和加密货币的文章，因此，如何向我学习是最好的实践方法-我决定编写自己的加密货币。</font><font style="vertical-align: inherit;">实际上，目标不仅是研究，还始于一个简单的想法-区块链-注册表，因此-数据库。</font><font style="vertical-align: inherit;">那么，为什么只有财务数据存储在区块链中-为什么不存储任意数据呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑到这些想法，我开始研究比特币区块链，并在4个月内用我的计算（当然还有自行车）在nodejs上完全重复了它。到2017年10月，我有了一个非常歪斜的代码的工作草案，这很难维护，实际上是在11月，我编写了另一个SPV客户端并为网络增加了轻客户端支持，此外我重新定义了挖矿池（这是我从头做起的唯一部分，但只完成了一部分并完成了它），创建并设计了块浏览器，该块浏览器通过rpc方法与本地节点进行通信。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
III ...发生了一些我无法控制的事件，将无限期的开发（或可能启动）无限期地推迟了（直到第19年，后来才证明）。让我提醒您，第17种加密货币的秋冬某个地方突然决定达到其最高价格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我拥有一个具有一定构想和基础架构的可运行加密货币的事实，但我错过了所有人都绝对显示所有加密货币都已达到最大值并可以启动任何加密货币的那一刻（甚至有些带有砖头的代币），这让我有些失望光明的计划，但我没有绝望。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那时我无法继续开发，但是有时间研究十大加密货币，因此我创建了一个电报频道，从技术方面分析了当时十大加密货币中的主要加密货币。顺便说一句，如果habrayuzery想要-我可以在这里“移植”这些文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来，当我确实回到开发阶段时，便进行了这种分析-他们使我能够改进模型并更详细地考虑未来加密货币的体系结构。</font><font style="vertical-align: inherit;">在2019年，我重新开始开发并从头开始。</font><font style="vertical-align: inherit;">我更详细地考虑了未来的体系结构，摆脱了代码中的交叉引用，删除了冗余模块，将一些模块转移到单独的npm软件包中，并在最近才收集了加密货币。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细节</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我必须马上说这不是一个项目，而只是一组无用的代码，所以我希望我不会因为链接到github并指明名称而被禁止使用。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加密货币</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一个相对成功的实验之后，我变得更加大胆，并决定下一个项目在代码方面应比第一个原型更加美观。</font><font style="vertical-align: inherit;">另外，我决定以框架的形式使系统模块化，以便在必要时能够连接和断开模块。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，用技术术语编写一种加密货币并不是一件困难的事情，总之：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为块和索引建立数据库</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组织用于在节点之间交换消息的协议</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义数据序列化格式和事务签名算法</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义共识并建立添加和验证的规则</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rpc服务器可选</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后配置控制台客户端，并尝试通过生成创世纪块并设置验证程序来运行</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经过大量纠正的错误和不准确性后-您的加密货币正在运作中，恭喜</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在那之后，有一个添加基础功能的阶段。</font><font style="vertical-align: inherit;">例如，我有此数据脚本，该项目的基础。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据脚本</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我写了4个月的项目被称为orwell，在很大程度上是比特币的分支，但它还假定每笔交易除财务信息外，还包含HEX格式的其他数据，这些数据（如果该交易有效且属于区块）将转换为专门的数据。解密该数据并将其转换为常规数据库的VM。</font><font style="vertical-align: inherit;">我将此虚拟机命名为orwelldb，格式为数据脚本，解密示例：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十六进制：</font></font><br>
<br>
<code>ef01fd4f01190b6578616d706c6564617461fd3f0154fd3b011f000f0fa1067e45f40003f1096f776e65725f6b65798230343233633635653064373364626161386537393435633965663135626338366533643864396638636364323636626366323362623032646336333432386636623239343766336164643731636536333962653739646561333933313237613061336661623136613339306630326537363966633135373561333535333130323461f30a70726976696c6567657301f1008230346231363165656566623739363163366637306137643338666434373764616633333437643231346561663365313639643964316434336232346437323338383665343063643962633563633232393638333635656531663962653635333932303539383630643735656432356136303836653830666462653138336565613364f20b7772697465536372697074fdb815</code> <br>
<br>
<pre><code class="json hljs">[<font></font>
{<font></font>
   <span class="hljs-attr">"dataset"</span>: <span class="hljs-string">"exampledata"</span>,
   <span class="hljs-attr">"operator"</span>: <span class="hljs-string">"create"</span>,
   <span class="hljs-attr">"content"</span>: {
    <span class="hljs-attr">"owner_key"</span>: <span class="hljs-string">"0423c65e0d73dbaa8e7945c9ef15bc86e3d8d9f8ccd266bcf23bb02dc63428f6b2947f3add71ce639be79dea393127a0a3fab16a390f02e769fc1575a35531024a"</span>,
    <span class="hljs-attr">"privileges"</span>: [
<span class="hljs-string">"04b161eeefb7961c6f70a7d38fd477daf3347d214eaf3e169d9d1d43b24d723886e40cd9bc5cc22968365ee1f9be65392059860d75ed25a6086e80fdbe183eea3d"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"writeScript"</span>: <span class="hljs-number">5560</span><font></font>
   },<font></font>
   <span class="hljs-attr">"canRead"</span>: <span class="hljs-literal">true</span>,
   <span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span><font></font>
  }<font></font>
]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我会告诉你一些有关内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据脚本包含对特定数据库及其数据集的调用数组，在这种情况下，事务描述了新数据集（即表，如果我们谈论的是关系数据库）的创建，其依据是“ operator”字段的内容。除了创建之外，还可以有“写入”和“设置”-分别添加（或更改）数据和更新数据集参数。 “内容”只是写入数据集的数据。在这种情况下，我们创建一个表，因此内容与用operator = settings-table settings编写的内容相同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了描述在那里确切地写了什么，必须转向数据脚本的概念。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将演示为这些目的而创建的2017年图表：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/jd/_7/njjd_72nro0czhi3e_4bbhkbrv4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
类似于比特币及其锁定和解锁脚本，数据脚本包含read和writeScript，第一个确定谁可以读取消息，第二个确定谁可以写入特定数据集。</font><font style="vertical-align: inherit;">脚本是面向堆栈的语言。</font><font style="vertical-align: inherit;">Readscript写在消息本身中，指示可以阅读该消息的人。</font><font style="vertical-align: inherit;">这是使用加密实现的。</font><font style="vertical-align: inherit;">指定加密时，只有在密钥库中具有必需密钥的人才能读取，否则，任何想要的人都可以读取。</font><font style="vertical-align: inherit;">带有create / settings语句的消息永远不要加密。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打开readScript的示例（任何人都可以阅读）：</font></font><br>
<br>
<pre><code class="plaintext hljs">DATA_HEXJSON + jsonhexbytes <font></font>
 DATA_HEXJSON  = 0x54</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加密：</font></font><br>
<br>
<pre><code class="plaintext hljs">DATA_HEXJSONENCRYPTED + var_str(encrypted data) + PUSHDATA_DBREADPRIVATEKEY + uint8(encryption) + OP_DECRYPT + OP_HASH256 + DATA_HASH + char[32](hash) + OP_EQUAL</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原始形式： </font></font><br>
<br>
<pre><code class="plaintext hljs">0x53 + var_str + 0x56 + (0x1 or 0x2) + 0x57 + 0x59 + 0x58 + char[32] + 0x87</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据解密测试，对解密数据进行哈希验证。 </font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有人感兴趣，我会在协议文档中更详细地描述所有内容：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github：datascript docs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是代码中指定的jsonhex是我将json转换成二进制格式的实现。</font><font style="vertical-align: inherit;">看来您可以保留通常的json，但是我想要统一性，所以我开发了一个单独的协议。</font><font style="vertical-align: inherit;">如果您想阅读有关他的信息，请</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参见以下</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">github：bitowl</font></a><font style="vertical-align: inherit;">。</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Writescript在数据集设置中注册，在示例中为0x5560。</font><font style="vertical-align: inherit;">在这种情况下，它说：</font></font><br>
<br>
<pre><code class="plaintext hljs">PUSHDATA_DBWRITEPUBLICKEY  OP_CHECKDBPRIVILEGES</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些。</font><font style="vertical-align: inherit;">将消息发送者的公钥发送到堆栈-并检查此数据集的特权列表。</font><font style="vertical-align: inherit;">如果此密钥在特权列表中（创建消息的发送者或owner_key），则他可以写。</font><font style="vertical-align: inherit;">另外，如果writescript为空，则表示ALL，即 </font><font style="vertical-align: inherit;">任何人都可以写入此数据集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于operator = settings，一切看起来都是一样的，只是内容内部的设置发生了变化。</font><font style="vertical-align: inherit;">对于写入-内容包含实际数据。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于区块链的一些知识</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是您问数据库呢？就我而言，我做了一个黑客-如果该交易包含数据脚本内容-该交易的第一个输出始终为零，并将此数据脚本发送给它，即网络上的每个地址都是一个数据库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该模型允许您将数据存储在区块链本身内部，这提供了一定的灵活性，但同时又增加了存储问题，因为比特币区块链已经增长到将近500 GB，并且仅用于财务数据。如果您在此处也添加任意内容-将会多余。因此，存储仅限于各种密钥和授权连接。顺便说一下，所有规则都在创建过程中在VM级别上进行了验证，但是您需要将其与区块链同步。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我在系统数据库中制作了几个系统数据集：domain，masternode，token，dapp，因此，您可以为每个地址/数据库创建域，并且不使用一组晦涩的字符，但使用方便的昵称（例如）来操作域，此外，根据设计，它们可以在dapp中使用（我将在稍后介绍）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于数据集令牌和主节点，第一个存储每个参与者可以创建的用户令牌，而主节点存储作为网络验证者的参与者的公共密钥列表。</font><font style="vertical-align: inherit;">这里需要一点题外话。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共识 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区块链的基础是共识，即节点之间的协议，在网络上运行的一组特定规则，并且所有这些规则都遵从以便网络可以运行。例如，比特币共识是工作量证明或挖掘，我敢肯定，在这里已经写了很多次。共识的实质是检查网络参与者发布的新块。在比特币中，网络参与者会随机发布区块-谁发现第一个区块将获得奖励。他最初在网络上进行了相同的操作，但后来认为这是不合理的，因为一个比特币矿工足以破坏我的网络并施加51％的攻击。所以一段时间后，我实现了共识模块</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concept.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中描述了几种不同的共识：集中式，PoW，PoS（PoW + PoS），静态dpow，静态dos，动态dpos。最后我停了下来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
动态委托pos（ddpos）假设一开始，如果有一定数量的代表（验证者），其列表按等级和使用的硬币数量进行排序，则会创建一个回合，在此期间，列表中的每个验证者均以严格的顺序发布一个区块。当回合结束时，将计算一个新的回合，并且网络中的每个成员都有机会根据来自网络的开放数据独立计算当前回合和下一回合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这需要masternode表，其中存储了所有表示希望成为验证者的人及其当前评分。</font><font style="vertical-align: inherit;">在每个回合开始时，我们对该表进行排序，并使用结果N个验证器创建回合。</font><font style="vertical-align: inherit;">如果验证器的数量少于N，我们将使用配置文件（其公共密钥）中描述的标准网络验证器创建回合。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">民主</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
网络内部投票的概念是在旧版本的加密货币中发明和实现的，它允许您从所有投票的节点接收网络中的平均数据。</font><font style="vertical-align: inherit;">在新版本中，我实现了一个单独的模块，但没有设法将其集成。</font><font style="vertical-align: inherit;">假设在民主的帮助下，可以通过公平投票来更改网络参数，并可以通过改变块的起源来减小存储的区块链的大小（通过在其中放置旧的UTXO和数据来使起源的块变大），但是它不会同步一百万个块，例如仅最后1000个。</font><font style="vertical-align: inherit;">另外，投票可以管理网络中的分支和变更，以及解决与网络相关的组织问题。</font><font style="vertical-align: inherit;">没错，如上所述，我没有设法实现此模块，但想法仍然存在。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapps</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dapps的概念是在18世纪初期比特币达到顶峰后不久发明的。然后就有了通过在区块链中注册应用程序（公钥），在系统表中注册工作人员（公钥），工作人员与应用程序进行通信以及使工作人员已经在自己独立的区块链中工作的想法。在这个概念中仍然有一个观众，即该应用程序的一部分具有与客户端进行通信的界面，浏览器和单独的应用程序都可以充当查看器。后来，我拒绝了这个想法，因为它花了我很长时间才能实现，并使它变得更容易一些。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还可以在区块链中注册dApp，将其与域相关联，并且参与者知道与应用程序的公共密钥相关联的域可以与该应用程序进行交互。</font><font style="vertical-align: inherit;">访问域时，网络客户端中的透明dns服务器会读取用户的请求，并使用ecdh加密对其进行加密，以便只有具有应用程序公钥的参与者才能读取内容并将其发送到网络。</font><font style="vertical-align: inherit;">应用程序接收该请求，将其发送到配置中为此应用程序指定的端点，然后将结果返回给网络（也已加密）。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 顺便说一句，一个有趣的事实：由于节点之间使用ecdh加密进行通信，并且dApp发送和接收加密的数据-在节点之间进行传输时，部分消息被加密了两次。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此方法，可以获得一个加密的网络，每个参与者都可以（不仅是）创建站点，并且控制流量变得更加容易，因为每个参与者都包含自己的“浏览站点”的公共密钥，ip地址从请求和答案中被切断。使网络匿名。</font><font style="vertical-align: inherit;">因此，最初具有授权，并且还可以查看用户的余额，令牌的余额（例如，与站点相关联）并完成支付过程，而无需离开站点和网络。</font><font style="vertical-align: inherit;">测试时唯一的缺点是性能-以这种形式，由于站点是通过分散的网络发送的，因此站点的加载速度要慢10倍。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面描述的机制只是一个概念，但是已经实现了一半。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在剧透状态下，我推送了一个链接到实现该代码的代码（github）：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始dapp代码</font></font></b>
                        <div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://github.com/gettocat/friday/blob/master/node/modules/dapps/index.js</a><br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我现在从哪里开始</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 最后，我想写一些技巧，如果我必须从当前的知识重新开始，我将应用这些技巧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模块化架构-绝对只是为了确保每个模块与其他模块之间的连接最少，例如在共识改变的情况下可以替换。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模块的隔离本质上是上一段的延续，已经专门针对功能模块，而不是逻辑模块。</font><font style="vertical-align: inherit;">例如-在我的代码中，共识是由一个单独的Conscept.js模块实现的，该协议允许您在工作草案中实现它之前先对其进行上下测试，这同样适用于所谓的基元（事务格式，块及其序列化/反序列化），从而可以测试特定模块的功能，直至将其嵌入主代码中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试-在测试过程中覆盖每个模块是发射过程中的幸福感以及夜间正常睡眠（对自己进行测试）的基础。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于加密货币是一个封闭的系统，因此所有内容的版本都需要预先考虑，接下来将要发生的事情-您将如何支持它。</font><font style="vertical-align: inherit;">有必要考虑一种用于为所有参与者从一个版本更新另一个版本的功能的模型，以免遭受尚未更新的参与者的痛苦，因为在相反情况下，可能会发生主网络的意外分支。</font><font style="vertical-align: inherit;">在我的共识js模块中，实现了确定分叉和有效块版本的功能，但我尚未将其添加到主代码中。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我所承诺的，在本文的结尾，我将总结一些结果。这篇文章可以被认为是使用自制加密货币的历史要点。一方面，我意识到这不是用于生产的，需要更加敏感的代码控制，测试覆盖范围以及生产项目中的其他内容，以及多个程序员。还有金融，金融，金融。没有它，无处不在。我没有所有这些，我也没有，所以我只是想尝试一下，研究这项技术，看看是否值得。值得。我可以说，完成工作后，我开始更好地了解编程，技术的许多方面（例如，我在处理字节序列方面确实非常先进），并且肯定研究了基于此的区块链和技术。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我可以肯定地知道，以太坊使用与交易数据类似的概念以及处理该数据的虚拟机，只有以太坊使用数据作为函数（如果以简单的方式）并访问它们（除了创建合同）。我肯定知道比特币（堆栈语言）的内部脚本是很强大的东西，中本聪暗示在“智能合约”概念出现很久之前就已经基于它们创建了智能合约，但是由于比特币，这些脚本的使用受到限制，因为可能以前未知的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们谈论我三年研究后喜欢的技术-这绝对是一个共识，即网络参与者与邮件验证一般规则之间的协议。 Bloom筛选器是一件很有趣的事情，它使我们可以向另一个参与者发送一个筛选器，他可以通过该参与者在不透露细节的情况下筛选要发送的数据。从而-在获取数据时无需透露所需的数据类型。 Merkle树作为一种数据存储结构，是比特币和状态树（其中有三个）以太坊中光节点的基础。 PoW是如此简单，但同时又有一个优雅的主意，“每个人都在寻找比最后N个块的总平均复杂度要少的数字（以通常的比率计算）。”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于缺点，也有很多缺点。首先是人工成本。随着时间的流逝，即使这个想法让我住了大约3年，我还是对这个想法不满意。例如，现在加密货币似乎甚至被启动了，似乎已经没有什么东西可以启动它了，但是在5千个块之后形成了一个奇怪的错误，事实是由于某种原因，块计数从头开始（索引似乎以某种方式崩溃） ，寻找没有时间，没有欲望的东西。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许有一天我会回到这个想法或类似的想法（或基于它）。</font><font style="vertical-align: inherit;">如果愿意，您可以研究代码或在我的github上创建星期五项目，所有代码均已获得MIT许可。</font><font style="vertical-align: inherit;">绝对肯定不会停止朝这个方向努力，因为分散技术虽然非常费力，但却非常有趣。</font><font style="vertical-align: inherit;">如果有任何问题/建议或澄清，我在下午等候。</font><font style="vertical-align: inherit;">如果您突然需要，我将帮助您解决。</font><font style="vertical-align: inherit;">在下面，我将组织一个调查-尽管该评级本身可以将所有内容放置到位，但是否值得在此撰写有关此主题的其他文章。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN505302/index.html">10电路设计技巧</a></li>
<li><a href="../zh-CN505306/index.html">从游戏到电子商务项目。更改Technopark的两年计划</a></li>
<li><a href="../zh-CN505310/index.html">技术先进的公司与众不同之处以及技术支持如何帮助您的团队成长</a></li>
<li><a href="../zh-CN505314/index.html">Linux时间同步：NTP，Chrony和systemd-timesyncd</a></li>
<li><a href="../zh-CN505322/index.html">未来的调度员：他在服务公司中的角色将如何改变？</a></li>
<li><a href="../zh-CN505336/index.html">如何：马奈或莫奈？神经网络响应</a></li>
<li><a href="../zh-CN505340/index.html">沃尔玛员工试图证明防盗AI不起作用</a></li>
<li><a href="../zh-CN505342/index.html">依赖注入和依赖倒置原理是不相同的</a></li>
<li><a href="../zh-CN505362/index.html">Vite-在Vue上没有捆绑的潜在客户开发</a></li>
<li><a href="../zh-CN505378/index.html">所有这些营销：如何与IT公司的联络点合作？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>