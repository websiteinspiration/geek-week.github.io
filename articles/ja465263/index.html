<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙 ⏳ 🖼️ PostgreSQLのロック：3.他のオブジェクトをロックします 🧗🏽 🚵🏻 🚄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="オブジェクトレベルでのいくつかのロック（特にリレーションのロックについて）、および行レベルでのロック、オブジェクトロックとの接続、待機キューについては、すでに正直とは言えません。
 
 今日はホッジポッジがあります。デッドロックから始めましょう（実際、前回はそれらについて話していましたが、その記事は...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQLのロック：3.他のオブジェクトをロックします</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/465263/"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトレベルでの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ロック</font></a><font style="vertical-align: inherit;">（特にリレーションのロックについて）、および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行レベル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でのロック、オブジェクトロックとの接続、待機キュー</font><font style="vertical-align: inherit;">については、すでに</font><font style="vertical-align: inherit;">正直とは言えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日はホッジポッジがあります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始めましょう</font><font style="vertical-align: inherit;">（実際、前回はそれらについて話していましたが、その記事はかなり長い間判明しました）、残りの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトロック</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について説明</font><font style="vertical-align: inherit;">し、最後に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">述語ロック</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について話し</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックを使用すると、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">状態が発生する可能性があり</font><font style="vertical-align: inherit;">ます。これは、あるトランザクションが別のトランザクションによって既にキャプチャされているリソースをキャプチャしようとするときに、別のトランザクションが最初のトランザクションによってキャプチャされたリソースをキャプチャしようとすると発生します。これは下の左側の図に示されています。実線の矢印はキャプチャされたリソースを示し、破線の矢印はすでに占有されているリソースをキャプチャする試みを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
期待値のグラフを作成してデッドロックを視覚化すると便利です。これを行うには、特定のリソースを削除し、トランザクションのみを残して、どのトランザクションが待機しているかを記録します。グラフに等高線がある場合（上から矢印でアクセスできます）-これはデッドロックです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-b/rg/yr/-brgyrpjzf-xgudc27jgtyzr6d4.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、デッドロックは2つのトランザクションだけでなく、それ以上の数のトランザクションでも可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドロックが発生した場合、それに関連するトランザクションはそれについて何も実行できません。トランザクションは無期限に待機します。したがって、すべてのDBMSおよびPostgreSQLも自動的にデッドロックを追跡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、チェックには特定の作業が必要です。新しいロックが要求されたときはいつでもやりたくありません（結局、デッドロックは非常にまれです）。したがって、プロセスがロックを取得しようとして失敗すると、キューに入り、スリープ状態になりますが、タイマーは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deadlock_timeout</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーターで指定された値</font><font style="vertical-align: inherit;">（デフォルトでは1秒）</font><font style="vertical-align: inherit;">まで開始</font><font style="vertical-align: inherit;">されます。リソースが以前に解放された場合、それで良いので、検証で節約しました。しかし、</font><em><font style="vertical-align: inherit;">deadlock_timeoutの</font></em><font style="vertical-align: inherit;">後</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機が続くと、保留中のプロセスが起こされ、チェックが開始されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チェック（期待値のグラフの作成とその中の等高線の検索で構成されます）でデッドロックが明らかにならない場合、プロセスはスリープ状態を続けます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメントの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冒頭で</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私は</font><em><font style="vertical-align: inherit;">lock_timeout</font></em><font style="vertical-align: inherit;">パラメーターについて何も言わないことで非難されました</font><font style="vertical-align: inherit;">。これは、任意のオペレーターに作用し、無期限に長い待機を回避します。指定された時間内にロックを取得できなかった場合、ステートメントはlock_not_availableエラーで終了します。</font><font style="vertical-align: inherit;">ロックを期待している場合でも、単にジョブを実行している場合でも、ステートメントの合計実行時間を制限</font><font style="vertical-align: inherit;">する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statement_timeout</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータと混同しないでください</font><font style="vertical-align: inherit;">。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドロックが検出されると、トランザクションの1つ（ほとんどの場合、チェックを開始したトランザクション）が強制的に終了されます。</font><font style="vertical-align: inherit;">同時に、それによってキャプチャされたロックが解放され、残りのトランザクションは引き続き機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドロックは通常、アプリケーションが正しく設計されていないことを意味します。</font><font style="vertical-align: inherit;">このような状況を検出するには2つの方法があります。1つ目はサーバーログにメッセージが表示され、2つ目はpg_stat_database.deadlocksの値が増加します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロックの例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドロックの一般的な原因は、テーブルの行がロックされる順序が異なることです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例。</font><font style="vertical-align: inherit;">最初の取引では、最初の口座から2番目の口座に100ルーブルを送金する予定です。</font><font style="vertical-align: inherit;">これを行うには、最初に最初の数を減らします。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">BEGIN</span>;<font></font>
=&gt; <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = amount - <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> acc_no = <span class="hljs-number">1</span>;
</code></pre><pre><code class="plaintext hljs">UPDATE 1
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、2番目のトランザクションは、2番目の口座から最初の口座に10ルーブルを転送することを意図しています。</font><font style="vertical-align: inherit;">彼女は2番目のカウントを減らすことから始めます。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">BEGIN</span>;<font></font>
|  =&gt; <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = amount - <span class="hljs-number">10.00</span> <span class="hljs-keyword">WHERE</span> acc_no = <span class="hljs-number">2</span>;
</code></pre><pre><code class="plaintext hljs">|  UPDATE 1
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、最初のトランザクションは2番目のアカウントを増やしようとしていますが、行がロックされていることがわかります。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = amount + <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> acc_no = <span class="hljs-number">2</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2番目のトランザクションは最初のアカウントを増やしようとしますが、ブロックされます。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = amount + <span class="hljs-number">10.00</span> <span class="hljs-keyword">WHERE</span> acc_no = <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ自体で終わることのない循環的な期待があります。</font><font style="vertical-align: inherit;">1秒後、リソースにアクセスできない最初のトランザクションがデッドロックチェックを開始し、サーバーを中断します。</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  deadlock detected<font></font>
DETAIL:  Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513.<font></font>
Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477.<font></font>
HINT:  See server log for query details.<font></font>
CONTEXT:  while updating tuple (0,2) in relation "accounts"<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、2番目のトランザクションを続行できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">|  UPDATE 1
</code></pre><pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">ROLLBACK</span>;
</code></pre><br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">ROLLBACK</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような操作を実行する正しい方法は、同じ順序でリソースをブロックすることです。</font><font style="vertical-align: inherit;">たとえば、この場合、番号の昇順でアカウントをブロックできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのUPDATEコマンドのデッドロック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々、デッドロックが発生する可能性があります。</font><font style="vertical-align: inherit;">たとえば、SQLコマンドをアトミ​​ックであると認識しておくと便利ですが、UPDATEを使用します。このコマンドは、行が更新されると行をブロックします。</font><font style="vertical-align: inherit;">これはすぐには起こりません。</font><font style="vertical-align: inherit;">したがって、1つのコマンドが1つの順序で行を更新し、別のコマンドが別の順序で行を更新すると、デッドロックになる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような状況になる可能性は低いですが、それでも満たすことができます。</font><font style="vertical-align: inherit;">再生用に、amount列にインデックスを作成し、amountの降順で作成します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> accounts(amount <span class="hljs-keyword">DESC</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こっているのかを確認するために、送信された値を1秒ずつゆっくりとゆっくりと増加させる関数を記述します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> inc_slow(n <span class="hljs-type">numeric</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">numeric</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
  <span class="hljs-keyword">SELECT</span> pg_sleep(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">SELECT</span> n + <span class="hljs-number">100.00</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pgrowlocks拡張も必要です。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> pgrowlocks;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のUPDATEコマンドはテーブル全体を更新します。</font><font style="vertical-align: inherit;">実行計画は明白です-順次スキャン：</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)<font></font>
|  <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = inc_slow(amount);
</code></pre><pre><code class="plaintext hljs">|           QUERY PLAN         <font></font>
|  ----------------------------<font></font>
|   Update on accounts<font></font>
|     -&gt;  Seq Scan on accounts<font></font>
|  (2 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルのページの行のバージョンは合計の昇順であるため（追加したとおりに）、同じ順序で更新されます。</font><font style="vertical-align: inherit;">動作するように更新を開始します。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = inc_slow(amount);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、別のセッションでは、シーケンシャルスキャンの使用を禁止します。</font></font><br>
<br>
<pre><code class="pgsql hljs">||     =&gt; <span class="hljs-keyword">SET</span> enable_seqscan = <span class="hljs-keyword">off</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、スケジューラーは、次のUPDATEステートメントに索引スキャンを使用することを決定します。</font></font><br>
<br>
<pre><code class="pgsql hljs">||     =&gt; <span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)<font></font>
||     <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = inc_slow(amount) <span class="hljs-keyword">WHERE</span> amount &gt; <span class="hljs-number">100.00</span>;
</code></pre><pre><code class="plaintext hljs">||                            QUERY PLAN                       <font></font>
||     --------------------------------------------------------<font></font>
||      Update on accounts<font></font>
||        -&gt;  Index Scan using accounts_amount_idx on accounts<font></font>
||              Index Cond: (amount &gt; 100.00)<font></font>
||     (3 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目と3番目の行はこの条件に該当し、インデックスは降順で構築されているため、行は逆の順序で更新されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のアップデートを開始します。</font></font><br>
<br>
<pre><code class="pgsql hljs">||     =&gt; <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount = inc_slow(amount) <span class="hljs-keyword">WHERE</span> amount &gt; <span class="hljs-number">100.00</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表形式のページをざっと見ると、最初のオペレーターがすでに最初の行（0,1）を更新しており、2番目のオペレーターが最後の行（0,3）を更新していることがわかります。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pgrowlocks(<span class="hljs-string">'accounts'</span>) \gx
</code></pre><pre><code class="plaintext hljs">-[ RECORD 1 ]-----------------<font></font>
locked_row | (0,1)<font></font>
locker     | 530699            &lt;- <font></font>
multi      | f<font></font>
xids       | {530699}<font></font>
modes      | {"No Key Update"}<font></font>
pids       | {16513}<font></font>
-[ RECORD 2 ]-----------------<font></font>
locked_row | (0,3)<font></font>
locker     | 530700            &lt;- <font></font>
multi      | f<font></font>
xids       | {530700}<font></font>
modes      | {"No Key Update"}<font></font>
pids       | {16549}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の秒が通過します。</font><font style="vertical-align: inherit;">最初のオペレーターが2行目を更新し、2番目のオペレーターがこれを実行しようとしていますが、できません。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pgrowlocks(<span class="hljs-string">'accounts'</span>) \gx
</code></pre><pre><code class="plaintext hljs">-[ RECORD 1 ]-----------------<font></font>
locked_row | (0,1)<font></font>
locker     | 530699            &lt;- <font></font>
multi      | f<font></font>
xids       | {530699}<font></font>
modes      | {"No Key Update"}<font></font>
pids       | {16513}<font></font>
-[ RECORD 2 ]-----------------<font></font>
locked_row | (0,2)<font></font>
locker     | 530699            &lt;-   <font></font>
multi      | f<font></font>
xids       | {530699}<font></font>
modes      | {"No Key Update"}<font></font>
pids       | {16513}<font></font>
-[ RECORD 3 ]-----------------<font></font>
locked_row | (0,3)<font></font>
locker     | 530700            &lt;- <font></font>
multi      | f<font></font>
xids       | {530700}<font></font>
modes      | {"No Key Update"}<font></font>
pids       | {16549}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、最初のステートメントはテーブルの最後の行を更新しようとしていますが、2番目のステートメントによってすでにロックされています。</font><font style="vertical-align: inherit;">これがデッドロックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションの1つが中止されました：</font></font><br>
<br>
<pre><code class="plaintext hljs">||     ERROR:  deadlock detected<font></font>
||     DETAIL:  Process 16549 waits for ShareLock on transaction 530699; blocked by process 16513.<font></font>
||     Process 16513 waits for ShareLock on transaction 530700; blocked by process 16549.<font></font>
||     HINT:  See server log for query details.<font></font>
||     CONTEXT:  while updating tuple (0,2) in relation "accounts"<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、もう一方は実行を完了します。</font></font><br>
<br>
<pre><code class="plaintext hljs">|  UPDATE 3
</code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロックの検出と防止に関する興味深い詳細は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">READMEロックマネージャにあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドロックについては以上です。残りのオブジェクトロックに進みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wb/wm/ho/wbwmhoocvz64odsj3qqooqup9jw.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非関係ロック</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLの理解において</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関係</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">
はないリソースをロックしたい場合</font><font style="vertical-align: inherit;">、オブジェクトロックが使用されます。</font><font style="vertical-align: inherit;">このようなリソースは、ほとんど何でもかまいません。テーブルスペース、サブスクリプション、スキーマ、ロール、列挙データ型...大まかに言えば、システムカタログにあるすべてのものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例を見てみましょう。</font><font style="vertical-align: inherit;">トランザクションを開始し、その中にテーブルを作成します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">BEGIN</span>;<font></font>
=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> example(n <span class="hljs-type">integer</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、pg_locksに表示されたオブジェクトロックのタイプを見てみましょう。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">database</span>,<font></font>
  (<span class="hljs-keyword">SELECT</span> datname <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> <span class="hljs-type">oid</span> = l.<span class="hljs-keyword">database</span>) <span class="hljs-keyword">AS</span> dbname,<font></font>
  classid,<font></font>
  (<span class="hljs-keyword">SELECT</span> relname <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> <span class="hljs-type">oid</span> = l.classid) <span class="hljs-keyword">AS</span> classname,<font></font>
  objid,<font></font>
  mode,<font></font>
  granted<font></font>
<span class="hljs-keyword">FROM</span> pg_locks l
<span class="hljs-keyword">WHERE</span> l.locktype = <span class="hljs-string">'object'</span> <span class="hljs-keyword">AND</span> l.pid = pg_backend_pid();
</code></pre><pre><code class="plaintext hljs"> database | dbname | classid |  classname   | objid |      mode       | granted<font></font>
----------+--------+---------+--------------+-------+-----------------+---------<font></font>
        0 |        |    1260 | pg_authid    | 16384 | AccessShareLock | t<font></font>
    16386 | test   |    2615 | pg_namespace |  2200 | AccessShareLock | t<font></font>
(2 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何がブロックされているかを正確に理解するには、データベース、クラスID、オブジェクトIDの3つのフィールドを調べる必要があります。最初の行から始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Databaseは、ロックされたリソースが属するデータベースのOIDです。私たちの場合、この列はゼロです。これは、特定のベースに属さないグローバルオブジェクトを扱っていることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classidには、リソースのタイプを決定するシステムカタログテーブルの名前に対応するpg_classのOIDが含まれています。私たちの場合、pg_authid、つまりロールはリソース（ユーザー）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objidには、classidが示したシステムカタログテーブルのOIDが含まれています。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> rolname <span class="hljs-keyword">FROM</span> pg_authid <span class="hljs-keyword">WHERE</span> <span class="hljs-type">oid</span> = <span class="hljs-number">16384</span>;
</code></pre><pre><code class="plaintext hljs"> rolname<font></font>
---------<font></font>
 student<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、学生の役割がブロックされ、そこから私たちが働きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、2行目を見てみましょう。</font><font style="vertical-align: inherit;">データベースが表示され、これが接続しているテストデータベースです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classidは、スキーマを含むpg_namespaceテーブルを指します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> nspname <span class="hljs-keyword">FROM</span> pg_namespace <span class="hljs-keyword">WHERE</span> <span class="hljs-type">oid</span> = <span class="hljs-number">2200</span>;
</code></pre><pre><code class="plaintext hljs"> nspname<font></font>
---------<font></font>
 public<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、パブリックスキーマはブロックされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、オブジェクトを作成すると、所有者の役割とオブジェクトが作成されるスキームが（共有モードで）ブロックされることがわかりました。</font><font style="vertical-align: inherit;">これは論理的です。そうでなければ、トランザクションがまだ完了していない間に誰かがロールまたはスキーマを削除した可能性があります。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">ROLLBACK</span>;
</code></pre><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関係拡張ロック</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リレーション（つまり、テーブル、インデックス、マテリアライズドビュー）の行数が増えると、PostgreSQLは既存のページの空き領域を使用して挿入できますが、明らかに、ある時点で、新しいページを追加する必要があります。物理的には、対応するファイルの最後に追加されます。これは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関係</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><em><font style="vertical-align: inherit;">拡大すると</font></em><font style="vertical-align: inherit;">理解され</font><em><font style="vertical-align: inherit;">てい</font></em><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのプロセスが急いで同時にページを追加しないようにするために、このプロセスは拡張タイプの特別なロックによって保護されています。他のプロセスがスキャン中にページを追加できないように、インデックスをクリーニングするときに同じロックが使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このロックはトランザクションの終了を待たずに解放されます。</font></font><br>
<br>
<blockquote>        .         ,    PostgreSQL&nbsp;9.6  ,        (    ,   &nbsp;512).<br>
</blockquote><br>
<h1> </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページレベルのロックが適用されるのは唯一の場合です（後で説明する述語ロックを除く）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GINインデックスを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、テキストドキュメント内の単語（または配列内の要素）などの複合値の検索を高速</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">化</font></a><font style="vertical-align: inherit;">できます。最初の近似として、そのようなインデックスは通常のBツリーとして表すことができ、ドキュメント自体は格納されず、これらのドキュメントの個々の単語が格納されます。したがって、新しいドキュメントを追加するときは、インデックスを非常に強力に再構築して、ドキュメントに含まれるすべての単語をインデックスに導入する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスを向上させるために、GINインデックスには、fastupdateストレージオプションによって有効になる遅延挿入機能があります。新しい単語が最初に順序付けされていない</font><em><font style="vertical-align: inherit;">待機リストに</font></em><font style="vertical-align: inherit;">すばやく追加され</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（保留リスト）、そしてしばらくすると、蓄積されたすべてがメインのインデックス構造に移動されます。</font><font style="vertical-align: inherit;">節約の理由は、異なるドキュメントに重複した単語が含まれている可能性があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
待機リストからメインインデックスに同時に移動することから複数のプロセスを除外するために、インデックスメタページは、転送の間、排他モードでブロックされます。</font><font style="vertical-align: inherit;">これは、通常モードでのインデックスの使用を妨げません。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">勧告的ロック</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のロック（ブロック関係など）とは異なり、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨ロック</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><em><font style="vertical-align: inherit;">推奨ロック</font></em><font style="vertical-align: inherit;">）は自動的にインストールされることはなく、アプリケーション開発者が制御します。</font><font style="vertical-align: inherit;">たとえば、アプリケーションが通常のロックの標準ロジックに適合しない何らかの目的でブロックロジックを必要とする場合に使用すると便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのデータベースオブジェクトにも対応しない条件付きリソースがあるとします（SELECT FORやLOCK TABLEなどのコマンドでブロックできます）。</font><font style="vertical-align: inherit;">そのための数値識別子を考え出す必要があります。</font><font style="vertical-align: inherit;">リソースに一意の名前がある場合、単純なオプションは、リソースからハッシュコードを取得することです。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> hashtext(<span class="hljs-string">'1'</span>);
</code></pre><pre><code class="plaintext hljs"> hashtext  <font></font>
-----------<font></font>
 243773337<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがロックを取得する方法です。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">BEGIN</span>;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> pg_advisory_lock(hashtext(<span class="hljs-string">'1'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常どおり、pg_locksでロック情報を利用できます。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> locktype, objid, mode, granted 
<span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> locktype = <span class="hljs-string">'advisory'</span> <span class="hljs-keyword">AND</span> pid = pg_backend_pid();
</code></pre><pre><code class="plaintext hljs"> locktype |   objid   |     mode      | granted <font></font>
----------+-----------+---------------+---------<font></font>
 advisory | 243773337 | ExclusiveLock | t<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックが実際に機能するには、他のプロセスもリソースにアクセスする前にロックを取得する必要があります。</font><font style="vertical-align: inherit;">このルールへの準拠は、アプリケーションによって明らかに保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、ロックはセッションの終了まで有効であり、通常どおりトランザクションではありません。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">COMMIT</span>;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> locktype, objid, mode, granted 
<span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> locktype = <span class="hljs-string">'advisory'</span> <span class="hljs-keyword">AND</span> pid = pg_backend_pid();
</code></pre><pre><code class="plaintext hljs"> locktype |   objid   |     mode      | granted <font></font>
----------+-----------+---------------+---------<font></font>
 advisory | 243773337 | ExclusiveLock | t<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明示的に解放する必要があります。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> pg_advisory_unlock(hashtext(<span class="hljs-string">'1'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての状況でアドバイザリロックを操作するための関数の大きなセットがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_advisory_lock_sharedは共有ロックを取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_advisory_xact_lock（およびpg_advisory_xact_lock_shared）は、トランザクションが終了するまでロックを取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_try_advisory_lock（およびpg_try_advisory_xact_lockとpg_try_advisory_xact_lock_shared）はロックを受け取ることを期待していませんが、ロックをすぐに取得できなかった場合はfalse値を返します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一連のtry関数は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、以前の記事に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストさ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れた</font></a><font style="vertical-align: inherit;">ものに加えて、ロックを待機しない別の方法を提供します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">述語ロック</font></font></h1><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">述語ロック</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
という用語</font><font style="vertical-align: inherit;">はずっと前に出現しました。初期のDBMSでロックに基づいて完全な分離を実装しようとした最初の試みです（レベルはSerializableですが、当時SQL標準は存在しませんでした）。その後発生した問題は、すべての読み取りおよび変更された行をブロックしても完全な分離が提供されないことでし</font><font style="vertical-align: inherit;">た。同じ選択条件に該当</font><font style="vertical-align: inherit;">する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">がテーブルに表示され、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファントムに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つながる</font><font style="vertical-align: inherit;">可能性があります</font><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離に関する記事を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">） 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語ロックのアイデアは、行ではなく述語をブロックすることでした。条件</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;&gt; 10で</font><font style="vertical-align: inherit;">クエリを実行するとき</font><font style="vertical-align: inherit;">に、述語</font><em><font style="vertical-align: inherit;">aが</font></em><font style="vertical-align: inherit;">ブロックされている場合</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;&gt; 10、これは条件に該当するテーブルに新しい行を追加することを許可せず、ファントムを回避することを許可します。問題は、一般的なケースでは、これは計算が難しいタスクであることです。実際には、非常に単純な形式の述語に対してのみ解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLでは、既存のスナップショットベースの分離に加えて、シリアライズ可能レイヤーの実装方法が異なります。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">述語ロック</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という用語</font><font style="vertical-align: inherit;">は残ってい</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">が、その意味は根本的に変わりました。実際、このような「ロック」は何もブロックしませんが、トランザクション間のデータの依存関係を追跡するために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像に基づいた分離により、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一貫性のない記録</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><em><font style="vertical-align: inherit;">異常と読み取りトランザクションのみの</font></em><em><font style="vertical-align: inherit;">異常が</font></em><font style="vertical-align: inherit;">許容されることが証明されています</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、他の異常は起こり得ません。</font><font style="vertical-align: inherit;">リストされている2つの異常の1つに対処していることを理解するために、トランザクション間の依存関係を分析し、それらの特定のパターンを見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのタイプの依存関係に関心があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのトランザクションが行を読み取ると、その行は別のトランザクションによって変更されます（RW依存関係）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのトランザクションが別のトランザクションが読み取る行を変更します（WR依存関係）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WR依存関係は、既存の従来のロックを使用して追跡できますが、RW依存関係は追加で追跡するだけで済みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度繰り返します。名前にもかかわらず、述語ロックは何もブロックしません。</font><font style="vertical-align: inherit;">代わりに、トランザクションがコミットされるとチェックが実行され、異常を示す可能性のある依存関係の「不良」シーケンスが検出された場合、トランザクションは中断します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語ロックがどのように設定されるか見てみましょう。</font><font style="vertical-align: inherit;">これを行うには、十分な数の行とその上にインデックスを持つテーブルを作成します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pred(n <span class="hljs-type">integer</span>);<font></font>
=&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> pred(n) <span class="hljs-keyword">SELECT</span> g.n <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>) g(n);<font></font>
=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> pred(n) <span class="hljs-keyword">WITH</span> (fillfactor = <span class="hljs-number">10</span>);<font></font>
=&gt; <span class="hljs-keyword">ANALYZE</span> pred;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリがテーブル全体の順次スキャンによって実行される場合、述語ロックはテーブル全体に設定されます（すべての行がフィルタリング条件に該当しない場合でも）。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">SELECT</span> pg_backend_pid();
</code></pre><pre><code class="plaintext hljs">|   pg_backend_pid <font></font>
|  ----------------<font></font>
|            12763<font></font>
|  (1 row)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">SERIALIZABLE</span>;<font></font>
|  =&gt; <span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">analyze</span>, <span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)<font></font>
|    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pred <span class="hljs-keyword">WHERE</span> n &gt; <span class="hljs-number">100</span>;
</code></pre><pre><code class="plaintext hljs">|                             QUERY PLAN                           <font></font>
|  ----------------------------------------------------------------<font></font>
|   Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1)<font></font>
|     Filter: (n &gt; 100)<font></font>
|     Rows Removed by Filter: 100<font></font>
|   Planning Time: 0.190 ms<font></font>
|   Execution Time: 15.244 ms<font></font>
|  (5 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語ロックは、常に1つの特別なSIReadLock（Serializable Isolation Read）モードでキャプチャされます。</font></font><br>
 <br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> locktype, relation::<span class="hljs-type">regclass</span>, page, tuple
<span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode = <span class="hljs-string">'SIReadLock'</span> <span class="hljs-keyword">AND</span> pid = <span class="hljs-number">12763</span>;
</code></pre><pre><code class="plaintext hljs"> locktype | relation | page | tuple <font></font>
----------+----------+------+-------<font></font>
 relation | pred     |      |      <font></font>
(1 row)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">ROLLBACK</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、インデックススキャンを使用してクエリを実行すると、状況はより良く変化します。</font><font style="vertical-align: inherit;">Bツリーについて説明する場合は、読み取りテーブル行とインデックスのスキャンされたリーフページにロックを設定するだけで十分です。これにより、特定の値だけでなく、読み取り範囲全体もブロックされます。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">SERIALIZABLE</span>;<font></font>
|  =&gt; <span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">analyze</span>, <span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)<font></font>
|    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pred <span class="hljs-keyword">WHERE</span> n <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1001</span>;
</code></pre><pre><code class="plaintext hljs">|                                       QUERY PLAN                                     <font></font>
|  ------------------------------------------------------------------------------------<font></font>
|   Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1)<font></font>
|     Index Cond: ((n &gt;= 1000) AND (n &lt;= 1001))<font></font>
|     Heap Fetches: 2<font></font>
|   Planning Time: 0.096 ms<font></font>
|   Execution Time: 0.153 ms<font></font>
|  (5 rows)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> locktype, relation::<span class="hljs-type">regclass</span>, page, tuple
<span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode = <span class="hljs-string">'SIReadLock'</span> <span class="hljs-keyword">AND</span> pid = <span class="hljs-number">12763</span>;
</code></pre><pre><code class="plaintext hljs"> locktype |  relation  | page | tuple <font></font>
----------+------------+------+-------<font></font>
 tuple    | pred       |    3 |   236<font></font>
 tuple    | pred       |    3 |   235<font></font>
 page     | pred_n_idx |   22 |      <font></font>
(3 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはいくつかの困難に気づくかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、読み取られる行のバージョンごとに個別のロックが作成されますが、そのようなバージョンが多数存在する可能性があります。システム内の述語ロックの総数は、パラメーター値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max_pred_locks_per_transaction</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max_connections</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の積によって制限され</font><font style="vertical-align: inherit;">ます（デフォルト値はそれぞれ64と100です）。このようなロック用のメモリは、サーバーの起動時に割り当てられます。この数を超えようとすると、エラーが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、述語ロック（およびそれらのみ）では、</font><em><font style="vertical-align: inherit;">レベルの増加が</font></em><font style="vertical-align: inherit;">使用されます。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">PostgreSQL 10より前のバージョンでは、コードに組み込まれた制限があり、それを基にしてレベルを上げることでパラメーターを制御できました。</font><font style="vertical-align: inherit;">行</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ごと</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の行バージョンロックの数が</font><em><font style="vertical-align: inherit;">max_pred_locks_per_page</font></em><font style="vertical-align: inherit;">より大きい場合</font><font style="vertical-align: inherit;">、そのようなロックは1つのページレベルのロックに置き換えられます。</font><font style="vertical-align: inherit;">次に例を示します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SHOW</span> max_pred_locks_per_page;
</code></pre><pre><code class="plaintext hljs"> max_pred_locks_per_page <font></font>
-------------------------<font></font>
 2<font></font>
(1 row)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">analyze</span>, <span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)<font></font>
|    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pred <span class="hljs-keyword">WHERE</span> n <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1002</span>;
</code></pre><pre><code class="plaintext hljs">|                                       QUERY PLAN                                     <font></font>
|  ------------------------------------------------------------------------------------<font></font>
|   Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1)<font></font>
|     Index Cond: ((n &gt;= 1000) AND (n &lt;= 1002))<font></font>
|     Heap Fetches: 3<font></font>
|   Planning Time: 0.069 ms<font></font>
|   Execution Time: 0.057 ms<font></font>
|  (5 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのタプルロックの代わりに、1つのページタイプが表示されます。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> locktype, relation::<span class="hljs-type">regclass</span>, page, tuple
<span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode = <span class="hljs-string">'SIReadLock'</span> <span class="hljs-keyword">AND</span> pid = <span class="hljs-number">12763</span>;
</code></pre><pre><code class="plaintext hljs"> locktype |  relation  | page | tuple <font></font>
----------+------------+------+-------<font></font>
 page     | pred       |    3 |      <font></font>
 page     | pred_n_idx |   22 |      <font></font>
(2 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、1つの関係に関連するページロックの数が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max_pred_locks_per_relation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を超える</font><em><font style="vertical-align: inherit;">と</font></em><font style="vertical-align: inherit;">、そのようなロックは1つの関係レベルのロックに置き換えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のレベルはありません。述語ロックは、関係、ページ、または行バージョンに対してのみキャプチャされ、常にSIReadLockモードでキャプチャされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ロックのレベルを上げると、必然的にトランザクションの数が増えると、誤ってシリアル化エラーが発生し、その結果、システムのスループットが低下します。ここでは、メモリ消費とパフォーマンスのバランスを見つける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の難点は、インデックスを使用したさまざまな操作で（たとえば、新しい行を挿入するときにインデックスページが分割されるため）、読み取り範囲をカバーするシートページの数が変わる可能性があることです。しかし、これの実装は考慮に入れます：</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> pred <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1001</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>);<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> locktype, relation::<span class="hljs-type">regclass</span>, page, tuple
<span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode = <span class="hljs-string">'SIReadLock'</span> <span class="hljs-keyword">AND</span> pid = <span class="hljs-number">12763</span>;
</code></pre><pre><code class="plaintext hljs"> locktype |  relation  | page | tuple <font></font>
----------+------------+------+-------<font></font>
 page     | pred       |    3 |      <font></font>
 page     | pred_n_idx |  211 |      <font></font>
 page     | pred_n_idx |  212 |      <font></font>
 page     | pred_n_idx |   22 |      <font></font>
(4 rows)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">ROLLBACK</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで、述語ロックは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクション</font><font style="vertical-align: inherit;">間の依存関係を追跡するために必要なので、トランザクションが完了した直後に常に削除されるとは限りません</font><font style="vertical-align: inherit;">。しかし、いずれにしても、それらは自動的に管理されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLのすべてのインデックスタイプが述語ロックをサポートしているわけではありません。以前は、これを自慢できるのはBツリーだけでしたが、PostgreSQL 11では状況が改善されました。ハッシュインデックス、GiSTおよびGINがリストに追加されました。インデックスアクセスが使用され、インデックスが述語ロックで機能しない場合、インデックス全体がロックにロックされます。もちろん、これにより、誤ったトランザクションブレークの数も増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、完全な分離を保証するために、</font><em><font style="vertical-align: inherit;">すべての</font></em><font style="vertical-align: inherit;">制限があるのは述語ロックの使用であることに注意してください。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションはシリアライズ可能でなければなりません。</font><font style="vertical-align: inherit;">トランザクションが別のレベルを使用する場合、それは単に述語ロックを設定（およびチェック）しません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伝統的に、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">述語ロックに関するREADMEへの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクを残しておきます。</font><font style="vertical-align: inherit;">そこからソースコードの研究を開始できます。</font></font><br>
</blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">続くこと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465251/index.html">夏がもうすぐ終わります。データ漏洩はほとんどありません</a></li>
<li><a href="../ja465255/index.html">HttpClientFactoryを使用した.Net CoreのWCF接続プールの実装</a></li>
<li><a href="../ja465257/index.html">「注意、FAS！」：マクドナルドのトリック、神のシャワルマ、偽のクルーニーといくつかのストリートマジック</a></li>
<li><a href="../ja465259/index.html">ValueTask <TResult>-理由、理由、方法</a></li>
<li><a href="../ja465261/index.html">マクロの魔法の力、またはAVRアセンブラープログラマーの生活を楽にする方法</a></li>
<li><a href="../ja465267/index.html">TypeScript 表現の魔法</a></li>
<li><a href="../ja465269/index.html">Cisco 200-125 CCNA v3.0のトレーニング。26日目。DNSとDHCP</a></li>
<li><a href="../ja465271/index.html">ハッカーは、食べ物の配達やホテルの予約サービスを通じてお金を盗んだり、洗濯したりします。</a></li>
<li><a href="../ja465275/index.html">アリスはスキルを得る</a></li>
<li><a href="../ja465277/index.html">SEOのセマンティクスの解析と分析：5つの無料のGoogleスプレッドシートテンプレート</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>