<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👀 🎀 ⭕️ OpenID Connect：从通用到标准的内部应用程序授权 👧🏿 📫 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几个月前，我正在实现一个OpenID Connect服务器来控制对数百个内部应用程序的访问。从我们自己的发展，在较小的规模上方便起见，我们转向了公认的标准。通过中央服务的访问极大地简化了单调的操作，降低了执行授权的成本，使您能够找到许多现成的解决方案，并且在开发新解决方案时不会动脑筋。在本文中，我将...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>OpenID Connect：从通用到标准的内部应用程序授权</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/uchi_ru/blog/492488/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个月前，我正在实现一个OpenID Connect服务器来控制对数百个内部应用程序的访问。</font><font style="vertical-align: inherit;">从我们自己的发展，在较小的规模上方便起见，我们转向了公认的标准。</font><font style="vertical-align: inherit;">通过中央服务的访问极大地简化了单调的操作，降低了执行授权的成本，使您能够找到许多现成的解决方案，并且在开发新解决方案时不会动脑筋。</font><font style="vertical-align: inherit;">在本文中，我将讨论这种过渡以及我们设法弥补的障碍。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lf/rf/lc/lfrflcyqjujtcdbfqn71iok4i1o.png" alt="介绍"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曾几何时...一切如何开始</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
几年前，当内部应用程序太多需要手动控制时，我们在公司内部编写了一个用于访问控制的应用程序。这是一个简单的Rails应用程序，连接到具有有关员工信息的数据库，并在其中配置了对各种功能的访问权限。然后，我们提出了第一个SSO，该SSO基于来自客户端和授权服务器的令牌验证，该令牌以加密的形式传输并带有多个参数，并在授权服务器上进行了检查。这不是最方便的选择，因为在每个内部应用程序上必须描述一个相当大的逻辑层，并且雇员的基础与授权服务器完全同步。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一段时间后，我们决定简化集中授权的任务。 SSO转移到平衡器。他们在Lua上使用OpenResty，添加了一个模板来检查令牌，知道请求所在的应用程序，并可以检查那里是否有访问权限。这种方法大大简化了控制内部应用程序访问的任务-在每个应用程序的代码中，不再需要描述其他逻辑。结果，我们从外部关闭了流量，应用程序本身对授权一无所知。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然而，问题之一仍然没有解决。</font><font style="vertical-align: inherit;">那些需要有关员工信息的应用程序呢？</font><font style="vertical-align: inherit;">您可以编写用于授权服务的API，但是随后您必须为每个此类应用程序添加其他逻辑。</font><font style="vertical-align: inherit;">此外，我们希望摆脱对我们内部授权服务器上对我们自己编写的应用程序之一的依赖，该应用程序进一步致力于转换为OpenSource。</font><font style="vertical-align: inherit;">我们待会儿再谈他。</font><font style="vertical-align: inherit;">解决这两个问题的方法是OAuth。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">达到公认的标准</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OAuth是一种可以理解的，公认的授权标准，但是由于其功能还不够，因此立即开始考虑使用OpenID Connect（OIDC）。</font><font style="vertical-align: inherit;">OIDC本身是开放式身份验证标准的第三种实现，已通过OAuth 2.0协议（开放式授权协议）扩展到了外接程序中。</font><font style="vertical-align: inherit;">该解决方案解决了关于最终用户的数据不足的问题，并且还使得可以改变授权提供者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，我们没有选择特定的提供程序，而是决定为现有的授权服务器添加与OIDC的集成。</font><font style="vertical-align: inherit;">为了支持这种解决方案，OIDC在授权最终用户方面非常灵活。</font><font style="vertical-align: inherit;">因此，可以在当前的授权服务器上实现OIDC支持。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j3/df/7x/j3df7xjz3ehktpwzwpf8redrmmc.png" alt="图片"><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们实现自己的OIDC服务器的方式</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）他们将数据带到所需的形式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要集成OIDC，您需要以一种标准可以理解的方式带来当前用户数据。</font><font style="vertical-align: inherit;">在OIDC中，这称为索赔。</font><font style="vertical-align: inherit;">品牌本质上是用户数据库中的结束字段（名称，电子邮件，电话等）。</font><font style="vertical-align: inherit;">有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准的品牌列表，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该列表中未包括的所有内容均视为自定义。</font><font style="vertical-align: inherit;">因此，如果要选择现有的OIDC提供商，首先要注意的一点是可以方便地自定义新品牌。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
品牌组将合并到下一个子集-范围。</font><font style="vertical-align: inherit;">在授权过程中，即使不需要范围中的某些标志，也不要求访问特定品牌，即范围。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）实施必要的赠款</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OIDC集成的下一部分是选择和实现授权类型，即所谓的授权。所选应用程序与授权服务器交互的其他场景将取决于所选授权。下图给出了选择权利授予的近似方案。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/c1/8b/fmc18b4jfprq3mjz-knzjo_4yso.png" alt="图片"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于我们的第一个应用程序，我们使用了最常见的授权-授权码。它与其他人的区别在于它是三个步骤，即通过其他验证。首先，用户发出授权许可请求，接收令牌-授权码，然后使用此令牌（好像带有旅行票证）来请求访问令牌。此授权方案的所有主要交互都基于应用程序和授权服务器之间的重定向。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读有关此补助金的更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OAuth坚持以下概念：授权后收到的访问令牌应该是临时的，最好平均每10分钟更改一次。授权代码的授予是通过重定向进行的三个步骤的检查；坦率地说，每10分钟执行一次此步骤对眼睛来说并不是一种愉快的体验。为了解决这个问题，我们还部署了另一个补助金-刷新令牌。这里的一切都比较简单。在测试过程中，除了主要访问令牌之外，还从另一个授权中发出了另一个令牌-刷新令牌，该令牌只能使用一次，并且其寿命通常会更长。使用此刷新令牌，当主访问令牌的TTL（生存时间）结束时，对新访问令牌的请求将到达另一个授予的端点。使用的刷新令牌将立即重置。这种检查是两步操作，可以在后台执行，对用户是不可见的。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）定制的用户数据输出格式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选定的赠款实施后，授权即可生效，值得一提的是有关最终用户的数据接收。</font><font style="vertical-align: inherit;">OIDC为此具有一个单独的端点，您可以在该端点上使用当前访问令牌并在相关时请求用户数据。</font><font style="vertical-align: inherit;">而且，如果用户数据变化不那么频繁，并且您需要多次进行修改，则可以做出像JWT令牌这样的决策。</font><font style="vertical-align: inherit;">这些令牌也受标准支持。</font><font style="vertical-align: inherit;">JWT令牌本身由三部分组成：标头（有关令牌的信息），有效负载（任何必要的数据）和签名（签名，令牌由服务器签名，以后您可以检查其签名的来源）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在OIDC实现中，JWT令牌称为id_token。</font><font style="vertical-align: inherit;">可以将其与常规访问令牌一起请求，剩下的只是验证签名。</font><font style="vertical-align: inherit;">授权服务器为此具有一个单独的终结点，该终结点带有一堆</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式的公钥</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">值得一提的是，还有一个基于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC5785</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准的端点可以</font><font style="vertical-align: inherit;">反映OIDC服务器的当前配置。</font><font style="vertical-align: inherit;">它包含端点的所有地址（包括用于签名的公钥链的地址），支持的品牌和范围，使用的加密算法，支持的授权等。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如在Google上：</font></font></b>
                        <div class="spoiler_text"><pre><code class="json hljs">{
 <span class="hljs-attr">"issuer"</span>: <span class="hljs-string">"https://accounts.google.com"</span>,
 <span class="hljs-attr">"authorization_endpoint"</span>: <span class="hljs-string">"https://accounts.google.com/o/oauth2/v2/auth"</span>,
 <span class="hljs-attr">"device_authorization_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/device/code"</span>,
 <span class="hljs-attr">"token_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/token"</span>,
 <span class="hljs-attr">"userinfo_endpoint"</span>: <span class="hljs-string">"https://openidconnect.googleapis.com/v1/userinfo"</span>,
 <span class="hljs-attr">"revocation_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/revoke"</span>,
 <span class="hljs-attr">"jwks_uri"</span>: <span class="hljs-string">"https://www.googleapis.com/oauth2/v3/certs"</span>,
 <span class="hljs-attr">"response_types_supported"</span>: [
  <span class="hljs-string">"code"</span>,
  <span class="hljs-string">"token"</span>,
  <span class="hljs-string">"id_token"</span>,
  <span class="hljs-string">"code token"</span>,
  <span class="hljs-string">"code id_token"</span>,
  <span class="hljs-string">"token id_token"</span>,
  <span class="hljs-string">"code token id_token"</span>,
  <span class="hljs-string">"none"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"subject_types_supported"</span>: [
  <span class="hljs-string">"public"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"id_token_signing_alg_values_supported"</span>: [
  <span class="hljs-string">"RS256"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"scopes_supported"</span>: [
  <span class="hljs-string">"openid"</span>,
  <span class="hljs-string">"email"</span>,
  <span class="hljs-string">"profile"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"token_endpoint_auth_methods_supported"</span>: [
  <span class="hljs-string">"client_secret_post"</span>,
  <span class="hljs-string">"client_secret_basic"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"claims_supported"</span>: [
  <span class="hljs-string">"aud"</span>,
  <span class="hljs-string">"email"</span>,
  <span class="hljs-string">"email_verified"</span>,
  <span class="hljs-string">"exp"</span>,
  <span class="hljs-string">"family_name"</span>,
  <span class="hljs-string">"given_name"</span>,
  <span class="hljs-string">"iat"</span>,
  <span class="hljs-string">"iss"</span>,
  <span class="hljs-string">"locale"</span>,
  <span class="hljs-string">"name"</span>,
  <span class="hljs-string">"picture"</span>,
  <span class="hljs-string">"sub"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"code_challenge_methods_supported"</span>: [
  <span class="hljs-string">"plain"</span>,
  <span class="hljs-string">"S256"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"grant_types_supported"</span>: [
  <span class="hljs-string">"authorization_code"</span>,
  <span class="hljs-string">"refresh_token"</span>,
  <span class="hljs-string">"urn:ietf:params:oauth:grant-type:device_code"</span>,
  <span class="hljs-string">"urn:ietf:params:oauth:grant-type:jwt-bearer"</span><font></font>
 ]<font></font>
}</code></pre> <br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，使用id_token，您可以将所有必要的标记转移到令牌的有效载荷上，而不必每次都与授权服务器联系以请求用户信息。</font><font style="vertical-align: inherit;">这种方法的缺点是从服务器更改用户数据不会立即进行，而是带有新的访问令牌。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行结果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在实现我们自己的OIDC服务器并在应用程序侧建立与其的连接之后，我们解决了传输用户信息的问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于OIDC是开放标准，因此我们有机会选择现有的提供程序或服务器实现。</font><font style="vertical-align: inherit;">我们尝试了Keycloak，事实证明它很容易配置，在应用程序侧设置和更改连接配置后，就可以使用了。</font><font style="vertical-align: inherit;">在应用程序端，仅需更改连接配置。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谈到现有解决方案</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为我们组织的一部分，作为第一台OIDC服务器，我们汇总了实现，并根据需要对其进行了补充。详细查看其他现成的解决方案后，我们可以说这是有争议的。供应商方面担心缺乏必要的功能可以作为其服务器实施的解决方案，以及存在一个旧系统，在该旧系统中，对某些服务有各种自定义授权，并且存储了大量有关员工的数据。但是，在现成的实现中，集成很方便。例如，Keycloak有其自己的用户管理系统，并且数据直接存储在其中，因此在这里赶超其用户将很困难。为此，Keycloak有一个API，可让您完全实现转移的所有必要步骤。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，另一个经过认证的有趣示例是Ory Hydra。</font><font style="vertical-align: inherit;">有趣的是，它由不同的组件组成。</font><font style="vertical-align: inherit;">为了进行集成，您需要将用户管理服务与其授权服务链接起来，并根据需要进行扩展。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keycloak和Ory Hydra不是唯一的交钥匙解决方案。</font><font style="vertical-align: inherit;">最好选择经过认证的OpenID Foundation实现。</font><font style="vertical-align: inherit;">通常，此类解决方案具有OpenID认证标志。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/8g/nl/ob/8gnlob5hxgfi2038fymlqsm5tjy.png" alt="Openid认证"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，如果您不想保留OIDC服务器，也不要忘记现有的付费服务提供商。</font><font style="vertical-align: inherit;">到目前为止，有很多不错的选择。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步是什么</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在不久的将来，我们将以另一种方式关闭对内部服务的访问量。</font><font style="vertical-align: inherit;">我们计划将使用OpenResty的平衡器上的当前SSO转移到基于OAuth的代理。</font><font style="vertical-align: inherit;">这里还有许多现成的解决方案，例如：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/bitly/oauth2_proxy </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/ory/oathkeeper </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/keycloak/keycloak-gatekeeper</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附加材料</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jwt.io-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openid.net/developers/JWT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认证</font><font style="vertical-align: inherit;">令牌的良好服务</font><font style="vertical-align: inherit;">-认证的OIDC实施列表</font></font><br>
<cut></cut></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492478/index.html">如果没有知识管理，那就很痛苦：缺乏系统的5个主要后果</a></li>
<li><a href="../zh-CN492480/index.html">我们以前如何应对流行病以及我们如何应对冠状病毒</a></li>
<li><a href="../zh-CN492482/index.html">3月16日至22日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN492484/index.html">3月16日至3月22日在圣彼得堡举行的数字活动</a></li>
<li><a href="../zh-CN492486/index.html">例如Nuxt + Django + GraphQL</a></li>
<li><a href="../zh-CN492492/index.html">NikiRobot-教育机器人技术的发展</a></li>
<li><a href="../zh-CN492496/index.html">Mithril.js上的样本Simple Notes SPA</a></li>
<li><a href="../zh-CN492500/index.html">俄语科学车库。翻译美国节目的经验</a></li>
<li><a href="../zh-CN492502/index.html">MIP * = RE：引起物理学和数学上的多米诺效应的计算机科学领域的划时代证据</a></li>
<li><a href="../zh-CN492504/index.html">两次导入JS模块会怎样？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>