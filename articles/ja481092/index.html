<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊 🕛 🤶🏾 PHP 8で最も興味深いこと 🐭 📿 🛋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP 7.4は安定したと宣言されたばかりであり、さらに多くの改善を提出する必要があります。そして何よりも、PHPが待ち望んでいることは、オープンソースPHPの主要開発者の1人であり、おそらく最も古いアクティブな貢献者であるDmitry Stogovに伝えることができます。
 
 ドミトリーのレポー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PHP 8で最も興味深いこと</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP 7.4は安定したと宣言されたばかりであり、さらに多くの改善を提出する必要があります。そして何よりも、PHPが待ち望んでいることは、オープンソースPHPの主要開発者の1人であり、おそらく最も古いアクティブな貢献者であるDmitry Stogovに伝えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドミトリーのレポートはすべて、彼が個人的に取り組んでいるテクノロジーとソリューションに関するもののみです。オンティコの最高の伝統の中で、カットの下で、</font><font style="vertical-align: inherit;">新しいユースケースを開くことができるPHP 8のDmitryの革新の観点から最も興味深い</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">についての</font><font style="vertical-align: inherit;">テキストバージョン</font><font style="vertical-align: inherit;">。まず第一に、JITとFFI-「驚くべき見通し」の鍵ではなく、実装の詳細と落とし穴があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考のために：</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリーStogovはドミトリーではなく、具体的ロシアの開発者のためのPHPのパフォーマンスを向上するがない、すべての読者のが生まれ、そして開発ツールの発展に大きく貢献することに成功し、特にPHP（したところ、1984年にプログラミングと知り合いになった、彼らが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表明しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HighLoad ++ Awardという形で感謝します）。</font><font style="vertical-align: inherit;">Dmitryは、Turck MMCache for PHP（eAccelerator）の作者であり、Zend OPcacheのメンテナーであり、PHP 7の基礎を形成したPHPNGプロジェクトのリーダーであり、PHP用のJITの開発のリーダーでもあります。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPパフォーマンス開発</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
15年前にZendに入社したときに、PHPのパフォーマンスに取り組み始めました。</font><font style="vertical-align: inherit;">次に、バージョン5.0をリリースしました-言語が真にオブジェクト指向になった最初のバージョンです。</font><font style="vertical-align: inherit;">それ以来、模擬テストのパフォーマンスを40倍、実際のアプリケーションのパフォーマンスを6倍向上させることができました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この間、2つの画期的な瞬間がありました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョン5.1。解釈の速度を大幅に向上させることができました。</font><font style="vertical-align: inherit;">専用のインタープリターを実装しましたが、これは主に模擬テストに影響しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての主要なデータ構造が処理され、メモリとプロセッサキャッシュでの作業が最適化されたバージョン7.0（これらの最適化の詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">これにより、模擬テストと実際のアプリケーションの両方で2倍以上の加速が発生しました。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のすべてのバージョンでは、あまり効果的でないアイデアを実装することにより、生産性が徐々に向上しました。</font><font style="vertical-align: inherit;">たとえば、バージョン7.1では、バイトコード（</font><font style="vertical-align: inherit;">これらのソリューション</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">最適化に多くの注意が払われました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図は、5番目のバージョンの開発の終わりと7番目のバージョンの開発サイクルの終わりの両方で、プラトーに達して減速することを示しています。</font><font style="vertical-align: inherit;">したがって、v7.4での昨年の作業で達成されたのは、生産性の2％の増加のみです。</font><font style="vertical-align: inherit;">そして、型付きプロパティや共変型などの新機能がPHPを遅くするように見えたため、これは悪くありません（</font><font style="vertical-align: inherit;">Nikita Popov </font><font style="vertical-align: inherit;">がPHPロシアでこれらの新製品について</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">話し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、誰もが8番目のバージョンに何が期待できるのか疑問に思っています。v7の成功を繰り返すことができますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JITするかしないか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通訳を改善するためのアイデアはまだ尽きていませんが、それらのすべては非常に実質的な研究が必要です。それらの多くは、概念実証の段階で拒否される必要があります。これは、得られる利益が、複雑さや技術的な制限が課せられた場合、収拾がつかないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、新しい画期的なテクノロジーへの希望は残っています。もちろん、JITとJavaScriptエンジンの成功事例を思い出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、JIT for PHPの作業は2012年から続いています。 3つまたは4つの実装があり、インテルの同僚、JavaScriptハッカーと協力しましたが、どういうわけか、JITをメインブランチに含めることができませんでした。結局、PHP 8では、コンパイラーにJITが含まれ、2倍の高速化が見られましたが、模擬テストのみであり、実際のアプリケーションでは、逆に減速が見られました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これは私たちが目指していることではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何か問題でもありますか？多分私たちは何か悪いことをしているかもしれません、多分WordPressはとても悪いです、そしてJITは彼を助けません（はい、実際それはそうです）インタプリタはすでに良すぎるように思われるかもしれませんが、JavaScriptの場合はさらに悪くなります。計算テストでは、これは真実です</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。PHPインタープリターは最高の1つです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マンデルブロテストでは、アセンブリ言語で作成されたインタープリターであるLuaJITなどの真珠を追い越します。このテストでは、最適化GCC-5.3コンパイラーの4倍遅れています。 JITを使用すると、マンデルブロー検定でより良い結果を得ることができます。実際、私たちはすでにこれを行っています。つまり、Cコンパイラと競合するコードを生成することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、なぜ実際のアプリケーションを高速化できないのでしょうか。</font><font style="vertical-align: inherit;">理解するために、JITの方法を説明します。</font><font style="vertical-align: inherit;">基本から始めましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPの仕組み</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーはリクエストを受け入れ、それをバイトコードにコンパイルします。バイトコードは仮想マシンに送信されて実行されます。</font><font style="vertical-align: inherit;">バイトコードを実行することにより、仮想マシンは他のPHPファイルを呼び出すこともできます。これらのファイルは、再度バイトコードに再コンパイルされ、再度実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストが完了すると、バイトコードを含む、リクエストに関連するすべての情報がメモリから削除されます。</font><font style="vertical-align: inherit;">つまり、各PHPスクリプトは、リクエストごとに再度コンパイルする必要があります。</font><font style="vertical-align: inherit;">もちろん、コンパイラーは非常に高速でなければならないため、JITコンパイルをそのようなスキームに埋め込むことは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、PHPをそのままの形で使用する人はほとんどいないでしょう。誰もがそれをOPcacheで使用しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP + OPcache</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OPcacheの主な目的は、リクエストごとに再コンパイルするスクリプトを取り除くことです。</font><font style="vertical-align: inherit;">これは、特別に設計されたポイントに埋め込まれ、すべてのコンパイル要求をインターセプトし、コンパイルされたバイトコードを共有メモリにキャッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、以前のバイトコードメモリが各プロセスのアドレス空間に割り当てられ、現在は単一のコピーに存在するため、コンパイル時間だけでなくメモリも節約されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この回路にはすでにJITを組み込むことができます。これを行います。</font><font style="vertical-align: inherit;">しかし、最初に、インタプリタがどのように機能するかを紹介します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタプリタはまず、各命令に対して独自のハンドラを呼び出すループです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのレジスタを使用します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execute_data-現在のアクティブ化フレームへのポインター。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opline-現在実行可能な仮想命令へのポインタ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gcc拡張機能を使用すると、これらの2種類のレジスタは実際のハードウェアレジスタにマップされます。これにより、これらのレジスタは非常に高速に動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループでは、各命令のハンドラーを呼び出すだけです。その後、各ハンドラーの最後で、ポインターを次の命令に移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハンドラのアドレスはバイトコードに直接書き込まれることに注意することが重要です。 1つの命令に対して、いくつかの異なるハンドラーが存在する可能性があります。これはもともと、ハンドラーがオペランド型に特化できるように、特化のために発明されました。 JITにも同じテクノロジーが使用されます。これは、アドレスをハンドラーとして新しく生成されたコードに書き込むと、インタープリターを変更せずにJITハンドラーが起動されるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例は、右側の加算ステートメント用に記述されたハンドラーを示しています。</font><font style="vertical-align: inherit;">オペランド（ここでは、1番目と2番目は定数、一時変数、またはローカル変数の場合があります）を受け取り、オペランドを読み取り、型を確認し、直接的なロジック（加算）を生成してから、ループに戻り、次のハンドラーに制御を移します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記述から専用の関数が生成されます。</font><font style="vertical-align: inherit;">3つの可能な第1オペランド、3つの可能な第2オペランドがあったため、9つの異なる関数を取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの関数では、オペランドを取得するための汎用的なメソッドの代わりに、チェックを行わない特定のメソッドが使用されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイブリッド仮想マシン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バージョン7.2で作成したもう1つの問題は、いわゆるハイブリッド仮想マシンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は常にインタープリターループで間接呼び出しを使用してハンドラーを直接呼び出していた場合は、各ハンドラーについて、ループの本体にラベルを追加で入力しました。これは、間接ジャンプを使用してジャンプし、ハンドラー自体を直接呼び出します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は間接呼び出しが1つでしたが、現在は間接遷移と直接呼び出しの2つであり、そのようなシステムはより低速で動作するはずです。</font><font style="vertical-align: inherit;">しかし、プロセッサーが遷移を予測するのを助けるので、実際にはそれはより速く機能します。</font><font style="vertical-align: inherit;">以前は、別の場所への移行が行われたポイントが1つありました。</font><font style="vertical-align: inherit;">プロセッサは、最初に1つの命令にジャンプし、次に別の命令にジャンプする必要があることを単純に思い出せなかったため、しばしば誤解されました。</font><font style="vertical-align: inherit;">現在、各直接呼び出しの後、次のラベルへの間接遷移があります。</font><font style="vertical-align: inherit;">その結果、PHPループが実行されると、仮想PHP命令が安定したシーケンスで配置され、ほぼ直線的に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハイブリッド仮想マシンにより、生産性がさらに5〜10％向上しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP + OPcache + JIT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JITはOPcacheの一部として実装されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトコードがコンパイルおよび最適化された後、JITコンパイラーが起動され、ソースコードでは動作しなくなります。 PHPバイトコードから、JITコンパイラーはネイティブコードを生成します。その後、最初の命令（実際には関数）のアドレスがバイトコードで変更されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、ネイティブで既に生成されたコードが、変更を加えずに既存のインタープリターから呼び出されます。簡単な例を示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側には、0から100までの数値の合計をカウントする特定の関数がPHPで記述されています。右側には、生成されたバイトコードがあります。最初の命令は合計に0を割り当て、2番目はiに対して同じことを行い、次にラベルによる無条件ジャンプを行います。ラベルL1では、サイクルを終了するための条件がチェックされます。条件が満たされている場合は終了し、満たされていない場合はサイクルに進みます。次に、合計にiを追加し、結果を合計に書き込み、iを1増やします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここから直接、アセンブラコードを生成します。これは非常に優れていることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の命令は、</font></font><code>QM_ASSIGN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのマシン命令（2〜3行）にコンパイルされます。レジスタに</font></font><code>%esi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、現在のアクティブ化フレームへのポインタがあります。オフセット30には可変量があります。最初の命令は値0を書き込み、2番目の命令は4を書き込みます。これは整数型の識別子（</font></font><code>IS_LONG</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）です。変数用</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラは、それが常に長いことを認識し、そのための型を格納する必要はありません。また、マシンレジスターに格納することもできます。したがって、ここでは、レジスタとそれ自体の単純なXORが、リセットのための最も単純で最も安価な命令です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、同じように、無条件遷移で、外部イベントが発生したかどうかを確認し、サイクルの状態を確認して、サイクルに入ります。ループは、合計が整数であるかどうかをチェックします。そうである場合、整数値を読み取り、それに値iを追加し、オーバーフローがあるかどうかを確認し、結果を合計に書き戻し、1 kを追加し</font></font><code>%edx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードが最適に近いことがわかります。ループの各反復で型の合計をチェックする必要がなくなるため、さらに最適化することができます。しかし、これはすでにかなり複雑な最適化であり、まだそのようなことはしていません。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちはJITをかなり単純なテクノロジーとして開発</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しています。JavaHotSpotが実行しようとしていることを実行しようとしているのではなく、V8です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jitの何が問題になっていますか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような優れたアセンブラコードで、実際のアプリケーションを高速化できないのはなぜですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に、彼らは？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボトルネックがCPUにない場合、JITは役に立ちません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成されるコードが多すぎる（コードの膨張）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的型推論は常に機能するとは限りません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正直なコード（実行されない場合）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシンの一貫した状態のサポート（および突然の例外）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスは1つの要求に対してのみ有効です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の80％のアプリケーションがデータベースからの応答を待っている場合、JITは役に立ちません。</font><font style="vertical-align: inherit;">正規表現とのマッチングなど、リソースを集中的に使用する外部関数を呼び出す場合、JITも同じ方法で同じ関数を呼び出します。</font><font style="vertical-align: inherit;">さらに、アプリケーションがツリー、グラフ、そしてそれらを読み取る大きなデータ構造を構築する場合、JITを使用して、より少ない命令で読み取るコードを生成しますが、データ自体をロードするために、それはすべて同じ時間かかりますが、また、コードをロードする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに見てきたように、JITは実際のアプリケーションの速度を低下させる可能性もあります。それは大量のコードを生成し、それを読み取ることが問題になるためです。大量のコードを読み取る場合、他のデータがキャッシュから強制的に取り出され、速度が低下します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP 8のささやかな計画</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP 8で実現したい改善の1つは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成するコードを少なくすることです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さて、先ほど言ったように、スクリプト全体のネイティブコードを生成し、ロード段階でロードします。</font><font style="vertical-align: inherit;">ただし、関数の半分は確実に呼び出されません。</font><font style="vertical-align: inherit;">したがって、少し先に進み、JITを実行するタイミングを構成できるトリガーを導入しました。</font><font style="vertical-align: inherit;">実行できます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての機能;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数が最初に呼び出されたときのみ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各関数にカウンターを掛けて、本当にホットな関数だけをコンパイルできます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなスキームは少し良く機能しますが、それでも最適ではありません。各関数には、実行されるパスと実行されないパスがあるためです。 PHPは動的プログラミング言語です。つまり、各変数は異なる型を持つことができるため、静的アナライザーが予測するすべての型をサポートする必要があることがわかります。そして、他のタイプができないことを証明できなかったとき、彼はしばしば注意してこれを行います。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの状況では、正直なコンパイルから離れ、投機的にそれを開始します。</font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、最初にアプリケーションの作業中にしばらくの間「最もホットな」関数を分析し、プログラムのパス、変数のタイプを確認し、境界条件さえ覚えてから、現在のものに最適な関数コードを生成することを計画しています実行方法-実際に実行されるセクションのみ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外の場合は、スタブを配置します。すべて同じように、最適化プロセスが開始するチェックと可能な出力があります。つまり、解釈に必要な仮想マシンの状態を復元し、実行のためにインタープリターに渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HotSpot Java VMとV8の両方で同様のスキームが使用されています。</font><font style="vertical-align: inherit;">しかし、テクノロジーをPHPに適応させることには多くの困難があります。</font><font style="vertical-align: inherit;">まず、これは、異なるプロセスから使用されるバイトコードとネイティブコードを共有していることです。</font><font style="vertical-align: inherit;">共有メモリで直接変更することはできません。最初にどこかにコピーし、変更してから、共有メモリにコミットする必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリロード。</font><font style="vertical-align: inherit;">クラスバインディングの問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、PHP 7やPHP 5に長い間含まれてきたPHPの機能強化のアイデアの多くは、JITに関連する作品に由来しています。</font><font style="vertical-align: inherit;">今日は、このような別のテクノロジーについてお話します。これはプリロードです。</font><font style="vertical-align: inherit;">このテクノロジーはすでにPHP 7.4に含まれており、一連のファイルを指定し、サーバーの起動時にそれらをロードして、これらのファイルのすべての機能を永続的にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリロード技術が解決する問題の1つは、クラスバインディングの問題です。実際のところ、単純にPHPでファイルをコンパイルすると、各ファイルは他のファイルとは別にコンパイルされます。これは、それぞれを個別に変更できるためです。あるスクリプトのクラスを別のスクリプトのクラスに関連付けることはできません。次のリクエストで、それらの1つが変更され、何かがうまくいかないからです。さらに、いくつかのファイルには同じ名前のクラスがあり、1つの要求ではそれらの1つが親として使用され、もう1つの要求では別のファイルの別のクラスが使用されます（同じ名前で完全に異なる）。複数のリクエストで実行されるコードを生成する場合、クラスまたはメソッドを参照することはできません。それらは毎回再作成されるためです（コードの存続期間がクラスの存続期間を超える）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリロードにより、最初にクラスをバインドし、それに応じてコードをより最適に生成できます。少なくとも、プリロードを使用してロードされるフレームワークの場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテクノロジーは、クラスバインディングだけでなく、同様のものがJavaでクラスデータ共有として実装されています。そこでは、このテクノロジーは主にアプリケーションの起動を加速し、消費されるメモリの総量を削減することを目的としています。 PHPでも同じプラスが得られます。これは、クラスバインディングが実行時に行われるのではなく、一度だけ行われるためです。さらに、関連するクラスは、各プロセスのアドレス空間ではなく共有メモリに格納されるようになりました。そのため、総メモリ消費量が減少します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリロードを使用すると、すべてのPHPスクリプトのグローバルな最適化にも役立ち、OPcacheオーバーヘッドが完全に削除され、より効率的なJITコードを生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、デメリットもあります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起動時に読み込まれたスクリプトは、PHPを再起動せずに置き換えることはできません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かをダウンロードして永続化すると、アンロードできなくなります。したがって、このテクノロジーは安定したフレームワークで使用できますが、アプリケーションを1日に数回デプロイすると、おそらく機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテクノロジーは透過的であると考えられていました。つまり、既存のアプリケーション（またはその一部）を変更せずにロードすることができました。しかし、実装後、これは完全に真実ではないことがわかりました、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preloadを使用してダウンロードした場合、すべてのアプリケーションが意図したとおりに機能するとは限りません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、関数</font></font><code>function_exists</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">のチェック結果に基づいてアプリケーションでコードが呼び出され、</font></font><code>class_exists</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数が定数になった場合、その関数は</font></font><code>function_exists</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にを返し</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アイデアによって以前に呼び出されたコードは呼び出されなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術的には、プリロードは、構成ファイルopcache.preloadを1つだけ使用して有効にし、その入力にスクリプトファイル（アプリケーションの起動段階で起動される（ロードされるだけでなく実行される）通常のPHPファイル）を指定します。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_preload</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $preload, <span class="hljs-keyword">string</span> $pattern = <span class="hljs-string">"/\.php$/"</span></span>) </span>{
    <span class="hljs-keyword">if</span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) {<font></font>
        opcache_compile_file($path) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">"Preloading failed"</span>);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_dir($path)) {
        <span class="hljs-keyword">if</span> ($dh = opendir($path)) {
            <span class="hljs-keyword">while</span> (($file = readdir($dh)) !== <span class="hljs-literal">false</span>) {
                <span class="hljs-keyword">if</span> ($file !== <span class="hljs-string">"."</span> &amp;&amp; $file !== <span class="hljs-string">".."</span>) {<font></font>
                    _preload($path . <span class="hljs-string">"/"</span> . $file, $pattern);<font></font>
                }<font></font>
            }<font></font>
            closedir($dh);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
_preload(<span class="hljs-string">"/usr/local/lib/ZendFramework"</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、一部のディレクトリ（この場合はZendFramework）内のすべてのファイルを再帰的に読み取る可能性のあるシナリオの1つです。</font><font style="vertical-align: inherit;">PHPで絶対に任意のスクリプトを実装できます。リストを読んだり、例外を追加したり、コンポーザーと交差させたりして、プリロードに必要なファイルをpodsovalにすることができます。</font><font style="vertical-align: inherit;">これはすべて技術の問題であり、さらに興味深いのは、どのように出荷するかではなく、何を出荷するかです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリロードで何をロードするか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この技術をWordPressで試しました。</font><font style="vertical-align: inherit;">すべての* .phpファイルをアップロードすると、前述の機能によりWordPressは動作を停止します。これにはfunction_existsチェックがあり、常にtrueになります。</font><font style="vertical-align: inherit;">したがって、前の例のスクリプトを少し変更（例外を追加）する必要があり、WordPress自体を変更せずに機能しました。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度[req / seq]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ[MB]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプトの数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス数</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何もない</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">378</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべて（ほぼ*）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">395</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">254</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1770</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">148</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されたスクリプトのみ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">396</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4,5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">84</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1532</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51</font></font></td>
</tr>
</tbody>
</table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリロード</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、</font><strong><font style="vertical-align: inherit;">約5％の加速が得られましたが</font></strong><font style="vertical-align: inherit;">、これはすでに悪くはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどすべてのファイルをダウンロードしましたが、半分は使用されていません。</font><font style="vertical-align: inherit;">あなたはさらに良いことができます-アプリケーションを動かして、どのファイルがダウンロードされたかを見てください。</font><font style="vertical-align: inherit;">これは、</font></font><code>opcache_get_status()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OPcacheによってキャッシュされたすべてのファイルを返し、プリロード用のファイルのリストを作成する</font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して行うことができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、3 MBを節約し、もう少し加速することができます。</font><font style="vertical-align: inherit;">実際には、必要なメモリが多いほど、プロセッサキャッシュがダーティになり、効率が低下します。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用するメモリが少ないほど、速度は速くなります。</font></font></strong><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFI-外部関数インターフェース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP用に開発されたもう1つのJIT関連テクノロジーはFFI（Foreign Function Interface）、またはロシア語では、コンパイルせずに他のコンパイル済みプログラミング言語で記述された関数を呼び出す機能です。このテクノロジーをPythonで実装すると上司（Zeev Surazki）に感銘を受け、PHPに適応し始めたときは非常に感銘を受けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPでFFIの拡張機能を作成する試みはすでにいくつか行われていますが、それらはすべて独自の言語またはAPIを使用してインターフェイスを記述しています。私はLuaJITでアイデアをスパイしました。C言語（サブセット）を使用してインターフェースを記述し、その結果は非常にクールなおもちゃになりました。ここで、Cでの動作を確認する必要がある場合は、PHPで記述します。これは、コマンドラインで直接行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFIを使用すると、Cで定義されたデータ構造を操作でき、JITと統合してより効率的なコードを生成できます。</font><font style="vertical-align: inherit;">そのlibffiベースの実装は、PHP 7.4にすでに含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だが：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらは、足で自分を撃つための1000の新しい方法です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cの知識が必要で、手動のメモリ管理が必要になる場合もあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cプリプロセッサ（＃include、＃define、...）とC ++をサポートしていません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JITなしのパフォーマンスはかなり低いです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、コンパイラーが不要なため、便利な場合もあります。</font><font style="vertical-align: inherit;">Windowsでも、PHPのVisual-Cがなくても機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LinuxでFFIを使用して実際のGUIアプリケーションを実装する方法を紹介します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cコードに驚かないでください。私は約20年前にCでGUIを作成しましたが、この例はインターネットで見つかりました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;gtk/gtk.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">activate</span><span class="hljs-params">(GtkApplication* app, gpointer user_data)</span> </span>{<font></font>
    GtkWidget *window = gtk_application_window_new(app);<font></font>
    gtk_window_set_title(GTK_WINDOW(window), <span class="hljs-string">"Hello from C"</span>);<font></font>
    gtk_window_set_default_size(GTK_WINDOW(window), <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<font></font>
    gtk_widget_show_all(window);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> status;<font></font>
    GtkApplication *app;<font></font>
    app = gtk_application_new(<span class="hljs-string">"org.gtk.example"</span>, G_APPLICATION_FLAGS_NONE);<font></font>
    g_signal_connect(app, <span class="hljs-string">"activate"</span>, G_CALLBACK(activate), <span class="hljs-literal">NULL</span>);<font></font>
    status = g_application_run(G_APPLICATION(app), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<font></font>
    g_object_unref(app);<font></font>
    <span class="hljs-keyword">return</span> status;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムはアプリケーションを作成し、アクティブ化コールバックイベントでハングし、アプリケーションを起動します。コールバックでウィンドウを作成し、タイトルサイズを割り当てて表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、同じことがPHPで書き直されました：</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-meta">&lt;?php</span>
$ffi = FFI::cdef(<span class="hljs-string">"
… // #include &lt;gtk/gtk.h&gt;
"</span>, <span class="hljs-string">"libgtk-3.so.0"</span>);<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params">$app, $user_data</span>) </span>{
    <span class="hljs-keyword">global</span> $ffi;<font></font>
<font></font>
    $window = $ffi-&gt;gtk_application_window_new($app);<font></font>
    $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string">"Hello from PHP"</span>);<font></font>
    $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<font></font>
    $ffi-&gt;gtk_widget_show_all($window);<font></font>
}<font></font>
<font></font>
$app = $ffi-&gt;gtk_application_new(<span class="hljs-string">"org.gtk.example"</span>, <span class="hljs-number">0</span>);<font></font>
$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string">"activate"</span>, <span class="hljs-string">"activate"</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<font></font>
$ffi-&gt;g_application_run($app, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<font></font>
$ffi-&gt;g_object_unref($app);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、FFIオブジェクトが最初に作成されます。インターフェースの説明は、入力（基本的にはhファイル）およびダウンロードするライブラリとして彼に送信されます。その後、インターフェイスに記述されているすべての関数がffiオブジェクトのメソッドとして使用可能になり、転送されたすべてのパラメーターが自動的かつ完全に透過的に必要なマシン表現に変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが前の例とまったく同じであることがわかります。唯一の違いは、Cではコールバックをアドレスとして送信し、PHPでは文字列で指定された名前で接続が行われることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、インターフェースの外観を見てみましょう。最初の部分では、Cの型と関数を決定し、最後の行では共有ライブラリをロードします。</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;?php<font></font>
$ffi = FFI::cdef(<span class="hljs-string">"
typedef struct _GtkApplication GtkApplication;
typedef struct _GtkWidget GtkWidget;
typedef void (*GCallback)(void*,void*);

int		 g_application_run 		(GtkApplication *app,
						int	 argc, char **argv);
unsigned long	 * g_signal_connect_data 	(void *ptr, const char *signal,
						GCallback handler, void *data,
						GCallback *destroy, int flags);
void 		g_object_unref			(void *ptr);
GtkApplication	 * gtk_application_new		(const char *app_id, int flags);
GtkWidget	 * gtk_application_window_new 	(GtkApplication *app);
void	 	gtk_window_set_title 		(GtkWidget *win, const char *title);
void	 	gtk_window_set_default_size 	(GtkWidget *win, int width, int height);
void 		gtk_widget_show_all 		(GtkWidget *win);
"</span>, <span class="hljs-string">"libgtk-3.so.0"</span>);<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、これらのC定義はGTKライブラリのhファイルからコピーされ、ほとんど変更されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じファイル内のCとPHPに干渉しないようにするには、Cコード全体を別のファイルに、たとえばgtk-ffi.hという名前で挿入し、インターフェイス名とロードするライブラリを指定する特別なdefine'ovを先頭にいくつか追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FFI_SCOPE <span class="hljs-meta-string">"GTK"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FFI_LIB <span class="hljs-meta-string">"libgtk-3.so.0"</span> </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、1つのファイルでCインターフェイスの記述全体を選択しました。</font><font style="vertical-align: inherit;">このgtk-ffi.hはほぼ本物ですが、残念ながら、まだCプリプロセッサーを実装していません。つまり、マクロとインクルードは機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このインターフェースをPHPにロードします。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GTK</span> </span>{
    <span class="hljs-built_in">static</span> <span class="hljs-keyword">private</span> $ffi = <span class="hljs-literal">null</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_window</span>(<span class="hljs-params">$title</span>) </span>{
        <span class="hljs-keyword">if</span> (is_null(<span class="hljs-built_in">self</span>::$ffi)) <span class="hljs-built_in">self</span>::$ffi = FFI::load(<span class="hljs-keyword">__DIR__</span> . <span class="hljs-string">"/gtk_ffi.h"</span>);<font></font>
        $app = <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_application_new(<span class="hljs-string">"org.gtk.example"</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">self</span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string">"activate"</span>,
            <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$app, $data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$title</span>) </span>{<font></font>
                $window = <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_application_window_new($app);
                <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_window_set_title($window, $title);
                <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);
                <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_widget_show_all($window);<font></font>
            }, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">self</span>::$ffi-&gt;g_application_run($app, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-built_in">self</span>::$ffi-&gt;g_object_unref($app);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFIはかなり危険な技術なので、誰にも教えたくありません。少なくともFFIオブジェクトを非表示にします。つまり、クラス内でプライベートにします。そして、help </font></font><code>FFI::cdef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font><font style="vertical-align: inherit;">なくFFIオブジェクトを作成し</font></font><code>FFI::load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、前の例のhファイルのみを読み取る</font><font style="vertical-align: inherit;">help </font><font style="vertical-align: inherit;">を使用して作成し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの残りの部分はあまり変更されていません。名前のない関数を使用し、字句バインディングを使用してタイトルを渡すイベントハンドラーとしてのみです。つまり、Cと、Cでは利用できないPHPの長所の両方を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法で作成されたライブラリは、すでにアプリケーションで使用されている可能性があります。ただし</font><strong><font style="vertical-align: inherit;">、コマンドラインでのみ</font></strong><font style="vertical-align: inherit;">機能する</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、それをWebサーバー内に置くと、各リクエストでgtk_ffi.hファイルが読み取られ、ライブラリーが作成されてロードされ、バインドされます。そして、このすべての反復作業によりサーバーがロードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを回避し、実際にはPHP拡張をPHP自体に書き込むことを許可するために、FFIとプリロードをクロスすることを決定しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFI +プリロード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードはほとんど変更されていません。今だけ、hファイルをプリロードし</font></font><code>FFI::load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、オブジェクトの作成時ではなく、プリロード時に直接実行します。</font><font style="vertical-align: inherit;">つまり、ライブラリをロードすると、すべての解析とバインディングが（サーバーの起動時に）1回実行され</font></font><code>FFI::scope("GTK")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スクリプトを使用して、プリロードされたインターフェースに名前でアクセスできます。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-meta">&lt;?php</span>
FFI::load(<span class="hljs-keyword">__DIR__</span> . <span class="hljs-string">"/gtk_ffi.h"</span>);
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GTK</span> </span>{
    <span class="hljs-built_in">static</span> <span class="hljs-keyword">private</span> $ffi = <span class="hljs-literal">null</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_window</span>(<span class="hljs-params">$title</span>) </span>{
        <span class="hljs-keyword">if</span> (is_null(<span class="hljs-built_in">self</span>::$ffi)) <span class="hljs-built_in">self</span>::$ffi = FFI::scope(<span class="hljs-string">"GTK"</span>);<font></font>
        $app = <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_application_new(<span class="hljs-string">"org.gtk.example"</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">self</span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string">"activate"</span>,
            <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$app, $data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$title</span>) </span>{<font></font>
                $window = <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_application_window_new($app);
                <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_window_set_title($window, $title);
                <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);
                <span class="hljs-built_in">self</span>::$ffi-&gt;gtk_widget_show_all($window);<font></font>
            }, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">self</span>::$ffi-&gt;g_application_run($app, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-built_in">self</span>::$ffi-&gt;g_object_unref($app);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実施形態では、ＦＦＩは、ウェブサーバから使用することができる。</font><font style="vertical-align: inherit;">もちろん、これはGUI用ではありませんが、この方法で、たとえばデータベースへのバインディングを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法で作成された拡張機能は、コマンドラインから直接使用できます。</font></font><br>
<pre><code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロスFFIとプリロードのもう1つの利点は、すべてのユーザーレベルのスクリプトでFFIの使用を禁止する機能です。</font><font style="vertical-align: inherit;">ffi.enable = preloadを指定できます。これは、プリロードされたファイルを信頼することを意味しますが、通常のPHPスクリプトからFFIを呼び出すことは禁止されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造の操作C</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFIのもう1つの興味深い機能は、ネイティブデータ構造で動作できることです。</font><font style="vertical-align: inherit;">Cで説明されているデータ構造はいつでもメモリ内に作成できます。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-meta">&lt;?php</span>
$points = FFI::new(<span class="hljs-string">"struct {int x,y;} [100]"</span>);<font></font>
<font></font>
<span class="hljs-keyword">for</span> ($x = <span class="hljs-number">0</span>; $x &lt; count($points); $x++) {<font></font>
    $points[$x]-&gt;x = $x;<font></font>
    $points[$x]-&gt;y = $x * $x;<font></font>
}<font></font>
<font></font>
var_dump($points[<span class="hljs-number">25</span>]-&gt;y); <span class="hljs-comment">// 625</span>
var_dump(FFI::sizeof($points)); <span class="hljs-comment">// 800 </span><font></font>
<font></font>
<span class="hljs-keyword">foreach</span> ($points <span class="hljs-keyword">as</span> &amp;$p) {<font></font>
    $p-&gt;x += <span class="hljs-number">10</span>;<font></font>
}<font></font>
<font></font>
var_dump($points[<span class="hljs-number">25</span>]-&gt;x); <span class="hljs-comment">// 35</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの整数を含む100の構造の配列（FFI :: new！= New FFIに注意）を作成します。</font><font style="vertical-align: inherit;">メモリ内では、Cで記述されたとおりに表されます。その後、オブジェクトの配列であるかのように、通常のPHPプリミティブを使用してこのデータ構造を操作できます。</font><font style="vertical-align: inherit;">この場合、カウント、配列要素の読み取り/書き込み、さらには参照によるforeachの反復を使用できます。</font><font style="vertical-align: inherit;">また、この構造は800バイトしか使用しません。PHPの配列とオブジェクトからPHPで同様のデータ構造を構築すると、10倍以上かかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFIの使用例：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ニューラルネットワーク</font></a><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コンパイラ</font></a><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python / CFFIは、グラフィック（Cario、JpegTran）、ビデオ（ffmpeg）、ドキュメント（LibreOfficeKit）、ゲーム（SDL）、ニューラルネットワーク（TensorFlow）での作業に使用されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残念ながら、これまでのFFIの速度には、まだ多くの要望が残されています。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、PHPの動的機能によるものです。</font><font style="vertical-align: inherit;">彼は単に特定のデータ構造を参照していることを知らず、毎回、コールバックとロードされたデータ構造の記述を使用して、要素のタイプ、そのサイズ、およびメモリ内の位置を決定します。</font><font style="vertical-align: inherit;">FFIを使用する他の動的言語でも同じことが起こります。</font><font style="vertical-align: inherit;">彼らが言うように、奇跡はありません。</font><font style="vertical-align: inherit;">FFIをJITと交差させると、LuaJITが示すように、奇跡を実現できます。</font><font style="vertical-align: inherit;">私たちにとって、このバーはまだ利用できませんが、これは私たちが移動する予定の方向です。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">for</span> ($k=<span class="hljs-number">0</span>; $k&lt;<span class="hljs-number">1000</span>; $k++) {
    <span class="hljs-keyword">for</span> ($i=$n<span class="hljs-number">-1</span>; $i&gt;=<span class="hljs-number">0</span>; $i--) {<font></font>
        $Y[$i] += $X[$i];<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような単純な例では、FFIを使用すると、速度が2倍遅くなります。</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブ配列</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFIアレイ</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピピ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.010</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,081</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイソン</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.212</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.343</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LuaJIt -joff</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,037</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.412</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LuaJit -jon</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.003</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.002</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,040</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,093</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP + JIT</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.016</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,087</font></font></td>
</tr>
</tbody>
</table></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者の感謝：Zeev Surasky（Zend）、Andi Gutmans（ex-Zend、Amazon）、Xinchen Hui（ex-Weibo、ex-Zend、Lianjia）、Nikita Popov（JetBrains）、Anatol Belsky（Microsoft）、Anthony Ferrara（ex -Google、Lingo Live）、Joe Watkins、Mohammad Reza Haghighat（Intel）、Intelチーム、Andy Wingo（JSハッカー、Igalia）、Mike Pall（著者LuaJIT）。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
報告後の質問では、また面白いの多くがあり、そして唯一のレポートのトピックに関連していない、あなたから聞くことができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今すぐ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に。</font></font><br>
<br>
<blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">PHP Russia 2020</a> !     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">telegram-</a>,    2019     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">youtube-</a>  ,       , — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>  . </blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481074/index.html">Python計算機</a></li>
<li><a href="../ja481078/index.html">投票率は失敗しました。AgentTeslaをきれいな水に持ち込みました。パート3</a></li>
<li><a href="../ja481082/index.html">Mohnatikiはゲーム業界の市場を獲得します！Peregrine LabsがEpic Gamesとのコラボレーションを発表</a></li>
<li><a href="../ja481084/index.html">Python、DBの概要</a></li>
<li><a href="../ja481086/index.html">Vivaldi 2.10-Undercover Agent</a></li>
<li><a href="../ja481094/index.html">ソーラーパワーを搭載したJBLワイヤレスヘッドフォンとその問題点</a></li>
<li><a href="../ja481096/index.html">トップベストジョーカートーク2019</a></li>
<li><a href="../ja481100/index.html">Angular 9の新機能</a></li>
<li><a href="../ja481102/index.html">クロスプラットフォームの.NET UIツールキットリリースAvaloniaUI 0.9</a></li>
<li><a href="../ja481104/index.html">OpenJDKとNodeJSのブレンド：言語間の相互作用と垂直アーキテクチャ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>