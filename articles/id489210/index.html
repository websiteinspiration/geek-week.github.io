<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👳🏿 👱🏿 🕡 Pengujian kinerja kode Linux dengan contoh-contoh 👨🏿‍🏫 👨🏾‍🤝‍👨🏽 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika saya mulai belajar Java, salah satu tugas pertama yang saya coba selesaikan adalah untuk menentukan genap / ganjil. Saya tahu beberapa cara unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pengujian kinerja kode Linux dengan contoh-contoh</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya mulai belajar Java, salah satu tugas pertama yang saya coba selesaikan adalah untuk menentukan genap / ganjil. Saya tahu beberapa cara untuk melakukan ini, tetapi memutuskan untuk mencari cara yang "benar" di Internet. Informasi tentang semua tautan yang ditemukan memberi tahu saya tentang satu-satunya solusi yang tepat dari formulir x% 2, untuk mendapatkan sisa dari divisi tersebut. Jika sisanya adalah 0, angkanya genap, jika sisanya adalah 1, itu ganjil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejak zaman ZX Spectrum, saya ingat cara lain dan itu terkait dengan representasi angka dalam sistem biner. Angka apa pun dalam sistem desimal dapat ditulis sebagai jumlah dari kekuatan dua. Misalnya, untuk satu byte, dan ini adalah 8 bit, angka apa pun dalam sistem desimal dapat direpresentasikan sebagai jumlah dari angka 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini hanya urutan kekuatan dua. Ketika menerjemahkan angka ke dalam sistem biner, jika kita perlu memperhitungkan angka tersebut, dalam representasi biner itu akan menjadi satu, jika tidak perlu, itu akan menjadi 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010 (8 + 0 + 2 + 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101 (8 + 4 + 0 + 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000 (128 + 64 + 0 + 0 + 8 + 0 + 0 + 0)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat segera memperhatikan fakta bahwa angka ganjil hanya dapat memberikan nol kekuatan dua dengan nilai 1, semua kekuatan dua lainnya akan genap bahkan dengan definisi. </font><font style="vertical-align: inherit;">Ini secara otomatis berarti bahwa dari sudut pandang sistem bilangan biner, jika kita ingin memeriksa angka untuk paritas, kita tidak perlu memeriksa seluruh bilangan, tidak peduli seberapa besar itu. </font><font style="vertical-align: inherit;">Kita hanya perlu memeriksa bit pertama (paling kanan). </font><font style="vertical-align: inherit;">Jika 0, maka angkanya genap, karena semua bit lainnya memberikan angka genap, dan sebaliknya, jika bit tersebut berada di bit paling kanan, maka jumlahnya dijamin ganjil, karena semua bit lainnya hanya memberikan nilai genap. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memeriksa hanya bit yang tepat dalam suatu angka, Anda dapat menggunakan beberapa metode. </font><font style="vertical-align: inherit;">Salah satunya adalah biner DAN.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DAN</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biner DAN (DAN) bekerja dengan aturan berikut. Jika Anda berlaku untuk nomor apa pun, sebut saja itu orisinal, logis, dan dengan angka 0, maka hasil dari operasi semacam itu selalu 0. Dengan demikian, Anda dapat nol bit yang tidak Anda butuhkan. Jika Anda berlaku untuk yang asli 1, maka Anda mendapatkan yang asli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam sistem biner, mudah untuk menulis ini: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 DAN 0 = 0 (nol aslinya) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 DAN 0 = 0 (nol asli) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 DAN 1 = 0 (jangan ganti yang asli) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 DAN 1 = 1 (jangan ganti yang asli) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari sini beberapa sederhana aturan </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menerapkan operasi DAN dari semua unit ke semua angka (semua bit aktif), kita mendapatkan nomor awal yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menerapkan DAN dari semua nol ke nomor berapa pun (semua bit tidak aktif), kita mendapatkan 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menerapkan AND 0 ke byte 13, maka kita mendapatkan 0. Dalam desimal itu terlihat seperti 13 AND 0 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menerapkan AND 0 ke byte 200, kita mendapatkan 0, atau menuliskan 200 DAN 0 = 0 secara singkat. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal yang sama adalah kebalikannya, berlaku untuk 13 semua bit yang disertakan, untuk byte itu akan menjadi delapan unit, dan kami mendapatkan yang asli. </font><font style="vertical-align: inherit;">Dalam sistem biner 00001101 DAN 11111111 = 00001101 atau dalam sistem desimal 13 AND 255 = 13 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk 200 akan ada 11001000 DAN 11111111 = 11001000, masing-masing, atau dalam sistem desimal 200 DAN 255 = 200</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifikasi biner</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memeriksa jumlah paritas, kita hanya perlu memeriksa bit paling kanan. Jika 0, maka angkanya genap; jika 1, maka tidak genap. Mengetahui bahwa dengan DAN kita dapat meninggalkan beberapa bit asli, dan beberapa kita dapat mengatur ulang, kita hanya dapat mengatur ulang semua bit kecuali yang paling kanan. Sebagai contoh: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 dalam sistem biner adalah 1101. Mari kita terapkan DAN 0001 untuk itu (kita mereset semua bit, yang terakhir tetap yang asli). Pada 1101, kami mengubah semua bit menjadi 0 kecuali yang terakhir dan mendapatkan 0001. Kami hanya mendapatkan bit terakhir dari nomor asli kami. Dalam sistem desimal, akan terlihat seperti 13 DAN 1 = 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal yang sama dengan angka 200, dalam bentuk biner 11001000. Kami menerapkan DAN 00000001 untuk itu, menurut skema yang sama, nol semua bit, biarkan yang terakhir seperti apa adanya, kami mendapatkan 00000000, dan kami mereset 7 nol kiri dengan AND, dan kami mendapat 0 terakhir dari nomor aslinya. Dalam sistem desimal, sepertinya 200 AND 1 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, menerapkan perintah AND 1 ke angka apa pun, kita mendapatkan 0 atau 1. Dan jika hasilnya 0, maka angkanya genap. Ketika 1, jumlahnya aneh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Jawa, biner DAN ditulis sebagai &amp;. Dengan demikian, 200 &amp; 1 = 0 (datar) dan 13 &amp; 1 = 1 (tidak datar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini menyiratkan setidaknya dua metode untuk menentukan angka genap. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X% 2 - melalui sisa pembagian oleh dua </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X &amp; 1 - melalui biner DAN</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operasi biner seperti OR, AND, XOR diproses oleh prosesor dalam jumlah waktu minimum. </font><font style="vertical-align: inherit;">Tetapi operasi divisi adalah tugas yang tidak sepele, dan untuk menjalankannya, prosesor perlu memproses banyak instruksi, pada dasarnya menjalankan seluruh program. </font><font style="vertical-align: inherit;">Namun, ada operasi biner kiri dan kanan yang memungkinkan, misalnya, dengan cepat membagi angka dengan 2. Pertanyaannya adalah apakah kompiler menggunakan optimasi ini dan apakah ada perbedaan antara dua perbandingan ini, yang sebenarnya melakukan hal yang sama.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coding</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menulis sebuah program yang akan memproses angka 9.000.000.000 dalam satu siklus secara berurutan, dan menentukan milik mereka genap / ganjil dengan menentukan sisa dari divisi tersebut.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kami akan menulis persis sama, tetapi secara harfiah mengubah dua karakter, memeriksa hal yang sama melalui biner DAN.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita perlu membandingkan kedua program ini.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumberdaya di Linux. </font><font style="vertical-align: inherit;">CPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejumlah besar jam telah dihabiskan untuk menciptakan sistem operasi apa pun, khususnya distribusi sumber daya yang adil antar program. </font><font style="vertical-align: inherit;">Di satu sisi, ini bagus, karena menjalankan dua program, Anda dapat yakin bahwa mereka akan bekerja secara paralel, tetapi di sisi lain, ketika Anda perlu memeriksa kinerja suatu program, sangat penting untuk membatasi atau setidaknya mengurangi pengaruh eksternal pada program dari orang lain. program dan sistem operasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang harus diketahui adalah prosesor. </font><font style="vertical-align: inherit;">OS Linux untuk setiap proses menyimpan bitmask, yang menunjukkan kernel mana yang dapat digunakan oleh aplikasi dan mana yang tidak. </font><font style="vertical-align: inherit;">Anda dapat melihat dan mengubah topeng ini dengan perintah tasket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, mari kita lihat jumlah core di prosesor saya:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komputer saya memiliki prosesor dengan 4 core. </font><font style="vertical-align: inherit;">Ini bagus, karena saya akan mengalokasikan salah satunya untuk kebutuhan saya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat apakah semuanya sedang digunakan dengan perintah teratas:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tekan "1" untuk melihat informasi pada setiap inti secara terpisah:</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita melihat bahwa semua core digunakan kira-kira sama. </font><font style="vertical-align: inherit;">(indikator kami dan sy dan id kira-kira sama untuk setiap inti). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita coba untuk melihat hal yang sama dengan perintah tasket.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitmask "F" dalam sistem heksadesimal berarti 15 dalam desimal, atau 1111 dalam biner (8 + 4 + 2 + 1). </font><font style="vertical-align: inherit;">Semua bit diaktifkan, yang berarti bahwa semua core digunakan oleh proses dengan PID 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Linux, ketika satu proses memunculkan yang lain dengan panggilan sistem klon, topeng bit disalin dari induk pada saat kloning. </font><font style="vertical-align: inherit;">Ini berarti bahwa jika kita mengubah topeng ini untuk proses init kita (dalam kasus saya itu adalah systemd), maka ketika memulai proses baru melalui systemd proses baru ini sudah akan diluncurkan dengan topeng baru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mengubah topeng untuk proses menggunakan perintah yang sama, daftar nomor core CPU yang ingin kita tinggalkan digunakan untuk proses. </font><font style="vertical-align: inherit;">Misalkan kita ingin meninggalkan kernel 0.2.3 untuk proses kami, dan kami ingin menonaktifkan kernel 1 untuk proses systemd kami. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu menjalankan perintah:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memeriksa:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Topeng berubah menjadi "D" dalam notasi heksadesimal, yaitu 13 dalam desimal dan 1101 dalam biner (8 + 4 + 0 + 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mulai sekarang, setiap proses yang akan dikloning oleh proses systemd akan secara otomatis memiliki mask 1101 penggunaan CPU, yang berarti bahwa kernel nomor 1 tidak akan digunakan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melarang penggunaan kernel untuk semua proses</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mencegah proses utama Linux menggunakan kernel tunggal hanya akan memengaruhi proses baru yang dibuat oleh proses ini. </font><font style="vertical-align: inherit;">Tetapi dalam sistem saya sudah tidak ada satu proses, tetapi banyak sekali, seperti crond, sshd, bash dan lainnya. </font><font style="vertical-align: inherit;">Jika saya perlu melarang semua proses menggunakan satu inti, maka saya harus menjalankan perintah tasket untuk setiap proses yang berjalan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendapatkan daftar semua proses, kami akan menggunakan API yang diberikan kernel kepada kami, yaitu sistem file / proc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut dalam loop, kita melihat PID dari setiap proses yang berjalan dan mengubah topeng untuk itu dan semua utas:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena selama pelaksanaan program, beberapa proses dapat memiliki waktu untuk menelurkan proses lain, lebih baik untuk menjalankan perintah ini beberapa kali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa hasil pekerjaan kami dengan perintah atas:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, gambar telah berubah sedikit, sekarang untuk kernel 0.2.3 parameter rata-rata kita, sy, id adalah sama untuk kita, dan untuk kernel 1 konsumsi inti kita di userspace dan sys adalah 0, dan kernel idle di 100% (idle 100 ) </font><font style="vertical-align: inherit;">Kernel 1 tidak lagi digunakan oleh aplikasi kami dan saat ini persentase yang sangat kecil digunakan oleh kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tugas menguji kinerja dikurangi untuk memulai proses kami pada inti gratis.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyimpanan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memori fisik yang dialokasikan untuk suatu proses dapat dengan mudah diambil dari proses apa pun. </font><font style="vertical-align: inherit;">Mekanisme ini disebut swap. </font><font style="vertical-align: inherit;">Jika Linux memiliki tempat untuk swap, ia tetap akan melakukannya. </font><font style="vertical-align: inherit;">Satu-satunya cara untuk mencegah OS mengambil memori dari proses kami, seperti proses lainnya, adalah menonaktifkan sepenuhnya bagian swap, yang akan kami lakukan:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengalokasikan 1 inti prosesor, yang tidak digunakan, dan juga menghapus kemampuan untuk menukar memori dari kernel Linux. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengurangi dampak disk pada peluncuran proses kami, buat disk dalam memori dan salin semua file yang diperlukan ke disk ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Buat direktori dan pasang sistem file:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita perlu mencari tahu apa dan bagaimana kita berencana untuk meluncurkannya. </font><font style="vertical-align: inherit;">Untuk menjalankan program kami, pertama-tama kita perlu mengkompilasi kode kita:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka Anda perlu menjalankannya:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun dalam kasus kami, kami ingin menjalankan proses pada inti prosesor yang tidak digunakan oleh proses lain. </font><font style="vertical-align: inherit;">Oleh karena itu, jalankan melalui tasket:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pengujian kami, kami perlu mengukur waktu, jadi jalur peluncuran kami berubah menjadi</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OS Linux mendukung beberapa format file yang dapat dieksekusi, dan yang paling umum adalah format ELF. Format file ini memungkinkan Anda untuk memberitahu OS untuk tidak menjalankan file Anda, tetapi untuk menjalankan file lain. Pada pandangan pertama, itu tidak terdengar sangat logis dan dapat dimengerti. Bayangkan saya meluncurkan game Minesweeper, dan game Mario dimulai untuk saya - sepertinya virus. Tapi ini logikanya. Jika program saya memerlukan pustaka dinamis, misalnya libc, atau lainnya, ini berarti bahwa OS harus memuat pustaka ini terlebih dahulu ke dalam memori, dan setelah itu memuat dan menjalankan program saya. Dan tampaknya logis untuk menempatkan fungsionalitas seperti itu di sistem operasi itu sendiri, tetapi sistem operasi itu bekerja di area memori yang dilindungi dan harus memuat fungsionalitas sesedikit mungkin dan perlu.Oleh karena itu, format ELF memberikan kesempatan untuk memberi tahu OS bahwa kami ingin mengunduh beberapa program lain, dan program "lain" ini akan mengunduh semua perpustakaan dan program kami yang diperlukan dan memulai semuanya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kita perlu menjalankan 3 file, ini tasket, waktu, java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa yang pertama:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bash akan menjalankan file / usr / bin / tasket, periksa apa yang ada di dalamnya:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah file ELF yang saya tulis di atas. </font><font style="vertical-align: inherit;">Dalam file ELF, selain program itu sendiri, ada berbagai tajuk. </font><font style="vertical-align: inherit;">Dengan meluncurkan file ini, OS akan memeriksa tajuknya, dan jika tajuk “Requesting program interpreter” ada dalam file, OS akan meluncurkan file dari tajuk ini, dan ia akan meneruskan file yang awalnya diluncurkan sebagai argumen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa apakah header ini ada di file ELF kami:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Header ada, yang berarti bahwa dengan meluncurkan file / usr / bin / tasket kita benar-benar menjalankan /lib64/ld-linux-x86-64.so.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa apa file ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah tautan sim ke file /lib64/ld-2.17.so. </font><font style="vertical-align: inherit;">Coba lihat:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, ini adalah file ELF lain yang akan dijalankan oleh OS. </font><font style="vertical-align: inherit;">Kami melihat header:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melihat bahwa file ELF ini tidak memiliki header seperti itu, sehingga OS akan menjalankan file ini dan mentransfer kontrol ke sana. </font><font style="vertical-align: inherit;">Dan sudah file ini akan membuka file kita / usr / bin / tasket, baca dari sana informasi tentang semua perpustakaan yang diperlukan. </font><font style="vertical-align: inherit;">Daftar pustaka yang diperlukan juga ada di header file ELF. </font><font style="vertical-align: inherit;">Kita dapat melihat daftar ini dengan perintah ldd atau readelf, yang merupakan hal yang sama:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSO adalah bagian memori yang ditautkan yang tidak terkait dengan perpustakaan, oleh karena itu hilang dari file ELF sebagai perpustakaan yang diperlukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari sini jelas bahwa program /lib64/ld-2.17.so bertanggung jawab untuk menjalankan semua program yang membutuhkannya, dan ini semua adalah program dengan pustaka yang terhubung secara dinamis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menjalankan / usr / bin / tasket, ini persis sama dengan kita menjalankan /lib64/ld-2.17.so dengan argumen / usr / bin / tasket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami kembali ke masalah pengaruh disk pada pengujian kami. </font><font style="vertical-align: inherit;">Sekarang kita tahu bahwa jika kita ingin memuat program kita dari memori, maka kita perlu menyalin bukan satu file, tetapi beberapa:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melakukan hal yang sama untuk waktu, persyaratan perpustakaan yang persis sama (kami sudah menyalin ld dan libc).</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk java, masalahnya sedikit lebih rumit, karena java membutuhkan banyak pustaka yang berbeda yang dapat disalin untuk waktu yang lama. </font><font style="vertical-align: inherit;">Untuk menyederhanakan hidup saya, saya akan menyalin seluruh direktori dari java openjdk ke disk di memori dan membuat tautan sim. </font><font style="vertical-align: inherit;">Tentu saja, akses disk akan tetap dalam kasus ini, tetapi akan ada lebih sedikit.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ganti nama direktori lama, tambahkan akhiran .default ke dalamnya</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan buat symlink:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita sudah tahu bagaimana menjalankan file biner melalui argumen ke file /lib64/ld-2.17.so, yang sebenarnya dimulai. </font><font style="vertical-align: inherit;">Tetapi bagaimana cara membuat program /lib64/ld-2.17.so memuat pustaka yang dimuat dari direktori yang kita tentukan? </font><font style="vertical-align: inherit;">man ld untuk membantu kami, dari mana kami mengetahui bahwa jika Anda mendeklarasikan variabel lingkungan LD_LIBRARY_PATH, program ld akan memuat pustaka dari direktori yang kami tentukan. </font><font style="vertical-align: inherit;">Sekarang kita memiliki semua data untuk mempersiapkan jalur peluncuran aplikasi Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memulai beberapa kali berturut-turut dan memeriksa:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama eksekusi program, kita dapat menjalankan teratas dan memastikan bahwa program berjalan pada inti CPU yang benar.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, hasilnya dalam kebanyakan kasus serupa. </font><font style="vertical-align: inherit;">Sayangnya, kami tidak dapat sepenuhnya menghapus pengaruh OS pada inti CPU, sehingga hasilnya masih tergantung pada tugas-tugas khusus di dalam kernel Linux pada saat peluncuran. </font><font style="vertical-align: inherit;">Oleh karena itu, lebih baik menggunakan median nilai beberapa permulaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, kami melihat bahwa program java memproses 9.000.000.000 dengan paritas melalui sisa divisi dalam 10,65 detik pada satu inti CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lakukan tes yang sama dengan program kedua kami, yang melakukan hal yang sama melalui biner DAN.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita dapat mengatakan dengan yakin bahwa perbandingan untuk paritas melalui biner DAN membutuhkan waktu 4,02 detik, yang berarti dibandingkan dengan memeriksa sisa pembagian, ia bekerja 2,6 kali lebih cepat, setidaknya pada openjdk versi 1.8.0.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Java vs Openjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya download dan membongkar java jdk dari situs oracle ke direktori /mnt/ramdisk/jdk-13.0.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilasi:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami meluncurkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengkompilasi program kedua:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami meluncurkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Waktu eksekusi dari sumber yang sama di oracle jdk adalah sama untuk sisa divisi dan biner AND, yang terlihat normal, tetapi kali ini sama buruknya, yang ditunjukkan dalam openjdk pada sisa pembagian.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba bandingkan dengan Python. </font><font style="vertical-align: inherit;">Pertama, opsi dengan sisa pembagian dengan 2:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami meluncurkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang hal yang sama dengan biner DAN:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami meluncurkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasilnya menunjukkan bahwa DAN lebih cepat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Internet, telah ditulis berkali-kali bahwa variabel global dengan Python lebih lambat. </font><font style="vertical-align: inherit;">Saya memutuskan untuk membandingkan waktu pelaksanaan program terakhir dengan AND dan persis sama, tetapi dibungkus dengan fungsi:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jalankan dalam fungsi:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, perbandingan paritas yang sama dalam Python melalui biner DAN dalam suatu fungsi memproses angka 100000000 pada satu inti CPU dalam ~ 5 detik, perbandingan yang sama melalui DAN tanpa fungsi membutuhkan ~ 10 detik, dan perbandingan tanpa fungsi melalui sisa pembagian membutuhkan ~ 11 detik </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa program Python dalam suatu fungsi bekerja lebih cepat daripada tanpa itu telah dijelaskan lebih dari satu kali dan terkait dengan ruang lingkup variabel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python memiliki kemampuan untuk membongkar suatu program menjadi fungsi internal yang digunakan Python ketika menginterpretasikan suatu program. </font><font style="vertical-align: inherit;">Mari kita lihat fungsi apa yang digunakan Python untuk varian dengan fungsi odd_and_func.py:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan periksa sama tanpa menggunakan fungsi dalam kode kami:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, dalam varian dengan fungsi yang dideklarasikan, Python menggunakan fungsi internal dengan postfix FAST, misalnya, STORE_FAST, LOAD_FAST, dan dalam varian tanpa deklarasi fungsi, Python menggunakan fungsi internal STORE_NAME dan LOAD_NAME. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini memiliki sedikit arti praktis dan lebih ditujukan untuk memahami beberapa fitur Linux, dan kompiler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik untuk semua!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489196/index.html">Asap Ajaib: Mikrokontroler vs. Regulator Linier</a></li>
<li><a href="../id489198/index.html">Bagaimana tidak menembak diri sendiri di kaki menggunakan Liquibase</a></li>
<li><a href="../id489200/index.html">Apa yang dicari startups untuk Y Combinator pada tahun 2020</a></li>
<li><a href="../id489204/index.html">Pandangan dari Dalam tentang Keandalan Layanan Facebook</a></li>
<li><a href="../id489206/index.html">Hancurkan cerita dengan Patroni, atau Cara menjatuhkan kluster PostgreSQL</a></li>
<li><a href="../id489212/index.html">1C-Bitrix mencegah berhenti berlangganan buletin dengan persyaratan untuk mengirimkan data pribadi mereka</a></li>
<li><a href="../id489214/index.html">Pendekatan modern untuk menguji lokalisasi di iOS</a></li>
<li><a href="../id489218/index.html">Itu naif. Super: kode dan arsitektur gim sederhana</a></li>
<li><a href="../id489226/index.html">Metode untuk mengoptimalkan kueri LINQ di C # .NET</a></li>
<li><a href="../id489230/index.html">Apa itu kinerja aplikasi web?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>