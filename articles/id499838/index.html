<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤šğŸ¼ ğŸ ğŸ‘¦ğŸ¿ .NET: Pengobatan Ketergantungan ğŸ—ï¸ ğŸ”† ğŸŒ«ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siapa yang tidak mengalami masalah karena pengarahan ulang perakitan? Kemungkinan besar, setiap orang yang mengembangkan aplikasi yang relatif besar c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: Pengobatan Ketergantungan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siapa yang tidak mengalami masalah karena pengarahan ulang perakitan? </font><font style="vertical-align: inherit;">Kemungkinan besar, setiap orang yang mengembangkan aplikasi yang relatif besar cepat atau lambat akan menghadapi masalah ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya bekerja di JetBrains, dalam proyek JetBrains Rider, dan saya terlibat dalam tugas migrasi Rider ke .NET Core. </font><font style="vertical-align: inherit;">Sebelumnya terlibat dalam infrastruktur bersama di Circuit, platform hosting aplikasi berbasis cloud. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah cutscene adalah transkrip laporan saya dari konferensi Moskow DotNext 2019, di mana saya berbicara tentang kesulitan ketika bekerja dengan majelis di .NET dan menunjukkan dengan contoh-contoh praktis apa yang terjadi dan bagaimana menghadapinya.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di semua proyek di mana saya bekerja sebagai pengembang .NET, saya harus berurusan dengan berbagai masalah dengan menghubungkan dependensi dan memuat rakitan. </font><font style="vertical-align: inherit;">Kami akan membicarakan ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur posting:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah Ketergantungan</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemuatan rig yang ketat</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengalihan mengikat</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penamaan yang kuat</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerangka bersama, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifes Ketergantungan (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks untuk Menjalankan JetBrains Rider on Core</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduhan perakitan debug</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Log fusi</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peristiwa runtime</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa sajakah masalah ketergantungan?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika mereka mulai mengembangkan .NET Framework pada awal 2000-an, masalah Ketergantungan neraka sudah diketahui, ketika di semua pustaka pengembang mengizinkan perubahan, dan pustaka ini menjadi tidak kompatibel untuk digunakan dengan kode yang sudah dikompilasi. </font><font style="vertical-align: inherit;">Bagaimana mengatasi masalah seperti itu? </font><font style="vertical-align: inherit;">Solusi pertama sudah jelas. </font><font style="vertical-align: inherit;">Selalu pertahankan kompatibilitas ke belakang. </font><font style="vertical-align: inherit;">Tentu saja, ini tidak terlalu realistis, karena memecah perubahan sangat mudah dimasukkan ke dalam kode. </font><font style="vertical-align: inherit;">Misalnya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memecah perubahan dan pustaka .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah contoh khusus untuk .NET. Kami memiliki metode, dan kami memutuskan untuk menambahkan parameter dengan nilai default. Kode akan terus dikompilasi jika kita merakitnya kembali, tetapi biner akan menjadi dua metode yang sama sekali berbeda: satu metode memiliki argumen nol, metode kedua memiliki satu argumen. Jika pengembang di dalam dependensi memecah kompatibilitas ke belakang dengan cara ini, maka kami tidak akan dapat menggunakan kode yang dikompilasi dengan dependensi ini pada versi sebelumnya.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi kedua untuk masalah ketergantungan adalah menambahkan versi perpustakaan, majelis - apa pun. Mungkin ada aturan versi yang berbeda, intinya adalah bahwa kita dapat membedakan versi berbeda dari pustaka yang sama satu sama lain, dan Anda dapat memahami apakah pembaruan akan rusak atau tidak rusak. Sayangnya, segera setelah kami memperkenalkan versi-versi tersebut, muncul masalah yang berbeda. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi neraka adalah ketidakmampuan untuk menggunakan dependensi yang kompatibel dengan biner, tetapi pada saat yang sama memiliki versi yang tidak sesuai dengan runtime atau komponen lain yang memeriksa versi ini. Dalam. NET, manifestasi khas dari versi neraka adalah FileLoadException, meskipun file tersebut terletak pada disk, tetapi karena alasan tertentu tidak dimuat dengan runtime.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam .NET, majelis memiliki banyak versi berbeda - mereka mencoba memperbaiki versi neraka dengan berbagai cara, dan melihat apa yang terjadi. Kami punya paket </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Banyak orang mengenalnya. Ia memiliki versi terbaru dari paket NuGet 1.6.0. Ini berisi perpustakaan, perakitan dengan versi 1.2.4.0. Anda telah menerima bahwa Anda tidak memiliki versi perpustakaan build 1.2.4.0. Bagaimana memahami bahwa itu terletak pada paket NuGet 1.6.0? Ini tidak akan mudah. Selain Versi Perakitan, perpustakaan ini memiliki beberapa versi lagi. Misalnya, Versi File Perakitan, Versi Informasi Perakitan. Paket NuGet ini sebenarnya berisi tiga majelis berbeda dengan versi yang sama (untuk versi berbeda dari .NET Standard). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Documentation </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild standard</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak dokumentasi telah ditulis tentang cara bekerja dengan majelis di .NET. </font><font style="vertical-align: inherit;">Ada .NET Guide untuk mengembangkan aplikasi modern untuk .NET dengan mempertimbangkan .NET Framework, .NET Standard, .NET Core, open source, dan semua itu. </font><font style="vertical-align: inherit;">Sekitar 30% dari seluruh dokumen dikhususkan untuk memuat majelis. </font><font style="vertical-align: inherit;">Kami akan menganalisis masalah dan contoh spesifik yang mungkin muncul.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa semua ini perlu? </font><font style="vertical-align: inherit;">Pertama, untuk menghindari menginjak menyapu. </font><font style="vertical-align: inherit;">Kedua, Anda dapat membuat hidup lebih mudah bagi pengguna perpustakaan Anda karena dengan perpustakaan Anda mereka tidak akan memiliki masalah ketergantungan yang biasa mereka alami. </font><font style="vertical-align: inherit;">Ini juga akan membantu Anda mengatasi migrasi aplikasi yang kompleks ke .NET Core. </font><font style="vertical-align: inherit;">Dan yang paling penting, Anda bisa menjadi SRE, ini adalah insinyur Pengarah Senior (Binding), tempat semua orang di tim datang dan bertanya bagaimana cara menulis pengalihan lain.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemuatan perakitan yang ketat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemuatan perakitan yang ketat adalah masalah utama yang dihadapi pengembang di .NET Framework. </font><font style="vertical-align: inherit;">Itu diungkapkan dalam </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebelum pindah ke perakitan ketat memuat sendiri, izinkan saya mengingatkan Anda tentang beberapa hal dasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda membangun aplikasi .NET, hasilnya adalah beberapa artefak, yang biasanya terletak di Bin / Debug atau di Bin / Rilis, dan berisi kumpulan rakitan dan file konfigurasi tertentu. </font><font style="vertical-align: inherit;">Sidang akan merujuk satu sama lain dengan nama, nama Majelis. </font><font style="vertical-align: inherit;">Penting untuk dipahami bahwa tautan rakitan terletak langsung di rakitan yang mereferensikan rakitan ini, tidak ada file konfigurasi ajaib tempat rujukan rakitan ditulis. </font><font style="vertical-align: inherit;">Meskipun menurut Anda mungkin ada file seperti itu. </font><font style="vertical-align: inherit;">Rujukan ada di majelis sendiri dalam bentuk biner.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di .NET, ada proses penyelesaian rakitan - ini adalah saat definisi rakitan sudah diubah menjadi rakitan nyata, yang ada di disk atau dimuat di suatu tempat di memori. Penyelesaian perakitan dilakukan dua kali: pada tahap pembuatan, saat Anda memiliki referensi di * .csproj, dan saat runtime, saat Anda memiliki referensi di dalam rakitan, dan berdasarkan aturan mereka berubah menjadi rakitan yang dapat diunduh. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Nama sederhana </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Versi = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Budaya = netral, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Nama kuat </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Newtonsoft.Json, Versi = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Budaya = netral, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita beralih ke masalah. Nama majelis ada dua jenis utama. Jenis pertama nama majelis adalah Nama sederhana. Mereka mudah diidentifikasi oleh fakta bahwa mereka memiliki PublicKeyToken = null. Ada nama yang kuat, mudah untuk mengidentifikasi mereka dengan fakta bahwa PublicKeyToken mereka bukan nol, tetapi beberapa nilai. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ambil contoh. Kami memiliki program yang bergantung pada pustaka dengan utilitas MyUtils, dan versi MyUtils adalah 9.0.0.0. Program yang sama memiliki tautan ke perpustakaan lain. Perpustakaan ini juga ingin menggunakan MyUtils, tetapi versi 6.0.0.0. MyUtils versi 9.0.0.0, dan versi 6.0.0.0 memiliki PublicKeyToken = null, yaitu, mereka memiliki nama Sederhana. Versi mana yang akan jatuh ke dalam artefak biner, 6.0.0.0 atau 9.0.0.0? Versi ke-9. Bisakah MyLibrary menggunakan MyUtils versi 9.0.0.0, yang masuk ke dalam artefak biner?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, itu bisa, karena MyUtils memiliki nama Sederhana dan, karenanya, memuat perakitan ketat tidak ada untuk itu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh lain. </font><font style="vertical-align: inherit;">Alih-alih MyUtils, kami memiliki perpustakaan lengkap dari NuGet, yang memiliki nama yang kuat. </font><font style="vertical-align: inherit;">Sebagian besar perpustakaan di NuGet memiliki nama yang kuat.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap build, versi 9.0.0.0 disalin ke BIN, tetapi saat runtime kita mendapatkan yang terkenal </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agar MyLibrary, yang ingin versi 6.0.0.0 untuk </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk dapat menggunakan versi 9.0.0.0, Anda harus pergi dan menulis Binding redirect to </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengalihan mengikat</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengarahkan versi perakitan</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ini menyatakan bahwa perakitan dengan nama seperti itu dan publicKeyToken tersebut harus diarahkan dari berbagai versi ke berbagai versi. </font><font style="vertical-align: inherit;">Tampaknya ini adalah catatan yang sangat sederhana, tetapi bagaimanapun juga terletak di sini </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi bisa juga di file lain. </font><font style="vertical-align: inherit;">Ada file </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di dalam .NET Framework, di dalam runtime, di mana beberapa set pengalihan standar didefinisikan, yang mungkin berbeda dari versi ke versi .NET Framework. </font><font style="vertical-align: inherit;">Mungkin terjadi bahwa pada 4.7.1 tidak ada yang berhasil untuk Anda, tetapi pada 4.7.2 itu sudah berfungsi, atau sebaliknya. </font><font style="vertical-align: inherit;">Anda harus ingat bahwa pengalihan tidak hanya berasal dari Anda </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan ini harus diperhitungkan saat debugging.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyederhanakan penulisan arahan ulang</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada yang mau menulis pengalihan Binding dengan tangan mereka. Mari berikan tugas ini ke MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mengaktifkan dan menonaktifkan pengalihan yang mengikat otomatis</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beberapa tips tentang cara menyederhanakan bekerja dengan pengalihan Binding. Tip Satu: Aktifkan Binding pengalihan generasi otomatis di MSBuild. Diaktifkan oleh properti di </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saat membangun proyek, itu akan jatuh ke dalam artefak biner </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang menunjukkan pengalihan ke versi perpustakaan yang berada di artefak yang sama. Ini hanya berfungsi untuk menjalankan aplikasi, aplikasi konsol, WinExe. Untuk perpustakaan, ini tidak berfungsi, karena untuk perpustakaan</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paling sering itu tidak relevan, karena relevan untuk aplikasi yang meluncurkan dan memuat rakitan itu sendiri. Jika Anda membuat konfigurasi untuk perpustakaan, maka dalam aplikasi beberapa dependensi mungkin juga berbeda dari yang ketika membangun perpustakaan, dan ternyata konfigurasi untuk perpustakaan tidak masuk akal. Namun demikian, kadang-kadang untuk perpustakaan konfigurasi masih masuk akal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi ketika kita menulis tes. Tes biasanya ditemukan di ClassLibrary dan mereka juga membutuhkan arahan ulang. Kerangka kerja pengujian dapat mengenali bahwa perpustakaan dengan tes memiliki dll-config, dan menukar pengalihan yang ada di dalamnya untuk kode dari tes. Anda dapat membuat arahan ulang ini secara otomatis. Jika kita memiliki format lama</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bukan SDK-style, Anda dapat pergi dengan cara sederhana, mengubah OutputType ke Exe dan menambahkan titik entri kosong, ini akan memaksa MSBuild untuk menghasilkan arahan ulang. Anda bisa pergi ke arah lain dan menggunakan retas. Anda dapat menambahkan properti lain ke </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang membuat MSBuild mempertimbangkan bahwa untuk OutputType ini Anda masih perlu menghasilkan pengalihan Binding. Metode ini, meskipun terlihat seperti peretasan, akan memungkinkan Anda untuk menghasilkan arahan ulang untuk perpustakaan yang tidak dapat diulang di Exe, dan untuk jenis proyek lainnya (kecuali tes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk format baru, </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arahan ulang akan dibuat sendiri jika Anda menggunakan Microsoft.NET.Test.Sdk modern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kiat ketiga: jangan gunakan Binding redirect generation dengan NuGet. NuGet memiliki kemampuan untuk menghasilkan pengalihan Binding untuk pustaka yang beralih dari paket ke versi terbaru, tetapi ini bukan pilihan terbaik. Semua pengalihan ini harus ditambahkan </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dikomit, dan jika Anda menghasilkan pengalihan menggunakan MSBuild, maka pengalihan dihasilkan selama membangun. Jika Anda komit, Anda mungkin memiliki menggabungkan konflik. Anda sendiri bisa saja lupa untuk memperbarui pengalihan Binding dalam file, dan jika mereka dihasilkan selama membangun, Anda tidak akan lupa. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyelesaikan Referensi Majelis </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghasilkan Pengalihan Mengikat</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pekerjaan rumah bagi mereka yang ingin lebih memahami bagaimana generasi pengalihan Binding bekerja: cari tahu cara kerjanya, lihat ini dalam kode. Pergi ke direktori .NET, pergilah ke mana-mana dengan properti nama, yang digunakan untuk mengaktifkan pembuatan. Ini umumnya merupakan pendekatan yang umum, jika ada beberapa properti aneh untuk MSBuild, Anda dapat pergi dan mengambil keuntungan dari penggunaannya. Untungnya, properti biasanya digunakan dalam konfigurasi XML, dan Anda dapat dengan mudah menemukan penggunaannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memeriksa apa yang ada di target XML ini, Anda akan melihat bahwa properti ini memicu dua tugas MSBuild. Tugas pertama disebut </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan menghasilkan satu set pengalihan yang ditulis ke file. Tugas kedua </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menulis hasil tugas pertama</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ada logika XML yang sedikit memperbaiki operasi tugas pertama dan menghapus beberapa arahan ulang yang tidak perlu, atau menambahkan yang baru.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatif untuk Konfigurasi XML</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak selalu nyaman untuk menjaga pengalihan dalam konfigurasi XML. </font><font style="vertical-align: inherit;">Kami mungkin memiliki situasi di mana aplikasi mengunduh plugin, dan plugin ini menggunakan perpustakaan lain yang memerlukan pengalihan. </font><font style="vertical-align: inherit;">Dalam hal ini, kami mungkin tidak menyadari set pengalihan yang kami butuhkan, atau kami mungkin tidak ingin menghasilkan XML. </font><font style="vertical-align: inherit;">Dalam situasi seperti itu, kita dapat membuat AppDomain dan, ketika itu dibuat, masih mentransfer ke tempat di mana XML dengan pengalihan yang diperlukan berada. </font><font style="vertical-align: inherit;">Kami juga dapat menangani kesalahan pemuatan perakitan saat runtime. </font><font style="vertical-align: inherit;">Rantime .NET memberikan kesempatan seperti itu.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu memiliki sebuah acara, itu disebut </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan berlangganan ke acara ini, kami akan menerima kesalahan tentang semua unduhan perakitan yang gagal. Kami mendapatkan nama majelis yang tidak memuat, dan kami mendapatkan majelis perakitan yang meminta majelis pertama untuk memuat. Di sini kita dapat memuat rakitan secara manual dari tempat yang tepat, misalnya menjatuhkan versi, hanya mengambilnya dari file, dan mengembalikan acara ini dari handler. Atau mengembalikan nol jika kita tidak memiliki apa pun untuk dikembalikan, jika kita tidak dapat memuat rakitan. PublicKeyToken harus sama, majelis dengan PublicKeyToken yang berbeda sama sekali tidak berteman satu sama lain.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acara ini hanya berlaku untuk satu domain aplikasi. </font><font style="vertical-align: inherit;">Jika plugin kami membuat AppDomain di dalamnya, maka pengalihan ini di runtime tidak akan berfungsi di dalamnya. </font><font style="vertical-align: inherit;">Anda harus entah bagaimana berlangganan acara ini di semua AppDomain yang dibuat oleh plugin. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini menggunakan AppDomainManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager adalah majelis terpisah yang berisi kelas yang mengimplementasikan antarmuka spesifik, dan salah satu metode antarmuka ini akan memungkinkan Anda untuk menginisialisasi AppDomain baru yang dibuat dalam aplikasi. </font><font style="vertical-align: inherit;">Setelah AppDomain dibuat, metode ini akan dipanggil. </font><font style="vertical-align: inherit;">Di dalamnya Anda dapat berlangganan acara ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemuatan perakitan ketat &amp; .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di .NET Core tidak ada masalah yang disebut "Pemuatan perakitan ketat", yang disebabkan oleh fakta bahwa majelis yang ditandatangani memerlukan versi yang diminta secara tepat. Ada persyaratan lain. Untuk semua majelis, terlepas dari apakah mereka ditandatangani oleh nama yang kuat atau tidak, diperiksa bahwa versi yang dimuat dalam runtime lebih besar atau sama dengan yang sebelumnya. Jika kita berada dalam situasi aplikasi dengan plugin, kita mungkin memiliki situasi seperti itu plugin dibangun, misalnya, dari versi baru SDK, dan aplikasi yang diunduh menggunakan versi lama SDK sejauh ini, dan bukannya berantakan, kita juga dapat berlangganan acara ini, tetapi sudah dalam. NET Core, dan juga memuat perakitan yang kita miliki. Kita dapat menulis kode ini:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki nama majelis yang tidak bisa boot, kami membatalkan versi dan menyebutnya </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari versi yang sama. Tidak akan ada rekursi di sini, karena saya sudah memeriksa rekursi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu perlu untuk mengunduh MyUtils versi 0.0.2.0. Di BIN, kami memiliki MyUtils versi 0.0.1.0. Kami membuat pengalihan dari versi 0.0.2.0 ke versi 0.0. Versi 0.0.1.0 tidak akan dimuat bersama kami. Sebuah jalan keluar akan terbang bagi kami bahwa tidak mungkin memuat unit dengan versi 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16â€“1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16â€“1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di kelas Versi, tidak semua komponen wajib, dan bukannya komponen opsional â€“1 disimpan, tetapi di suatu tempat di dalam, terjadi overflow, dan 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diperoleh </font><font style="vertical-align: inherit;">. Jika tertarik, Anda dapat mencoba menemukan di mana persisnya terjadi overflow. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda bekerja dengan rakitan refleksi dan ingin mendapatkan semua jenis, mungkin tidak semua jenis bisa mendapatkan metode GetTypes Anda. Majelis memiliki kelas yang mewarisi dari kelas lain yang ada di perakitan yang tidak dimuat.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, masalahnya adalah ReflectionTypeLoadException akan dibuang. </font><font style="vertical-align: inherit;">Di dalamnya </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada properti di mana ada jenis-jenis yang masih berhasil dimuat. </font><font style="vertical-align: inherit;">Tidak semua perpustakaan populer mempertimbangkan hal ini. </font><font style="vertical-align: inherit;">AutoMapper, setidaknya salah satu versinya, jika dihadapkan dengan ReflectionTypeLoadException, baru saja jatuh, alih-alih pergi dan memilih jenis dari dalam pengecualian.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penamaan yang kuat</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Majelis yang bernama kuat</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mari kita bicara tentang apa yang menyebabkan pemuatan perakitan yang ketat, ini adalah nama yang kuat. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nama Kuat adalah tanda tangan majelis oleh beberapa kunci pribadi menggunakan enkripsi asimetris. PublicKeyToken adalah hash kunci publik dari majelis ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penamaan Kuat memungkinkan Anda untuk membedakan antara majelis berbeda yang memiliki nama yang sama. Misalnya, MyUtils bukan nama yang unik, mungkin ada beberapa majelis dengan nama itu, tetapi jika Anda menandatangani Nama yang kuat, mereka akan memiliki PublicKeyToken yang berbeda dan kami dapat membedakannya dengan cara ini. Nama yang kuat diperlukan untuk beberapa skenario pemuatan perakitan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, untuk memasang perakitan di Global Assembly Cache atau mengunduh beberapa versi berdampingan sekaligus. </font><font style="vertical-align: inherit;">Yang paling penting, majelis bernama kuat hanya bisa merujuk majelis bernama kuat lainnya. </font><font style="vertical-align: inherit;">Karena beberapa pengguna ingin menandatangani bangunan mereka dengan nama yang kuat, pengembang perpustakaan juga menandatangani perpustakaan mereka, sehingga lebih mudah bagi pengguna untuk menginstalnya, sehingga pengguna tidak perlu menandatangani ulang perpustakaan ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nama kuat: Warisan?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penamaan yang kuat dan perpustakaan .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft secara eksplisit mengatakan pada MSDN bahwa Anda tidak boleh menggunakan nama yang kuat untuk tujuan keamanan, bahwa mereka menyediakan hanya untuk membedakan majelis yang berbeda dengan nama yang sama. Kunci perakitan tidak dapat diubah dengan cara apa pun, jika Anda mengubahnya, maka Anda akan memutuskan pengalihan ke semua pengguna Anda. Jika Anda memiliki bagian pribadi dari kunci untuk Nama kuat bocor ke akses publik, maka Anda tidak dapat menarik tanda tangan ini dengan cara apa pun. Format file SNK tempat Strong name berada tidak memberikan peluang seperti itu, dan format lain untuk menyimpan kunci setidaknya berisi tautan ke Daftar Pencabutan Sertifikat CRL, yang dapat dipahami bahwa sertifikat ini tidak lagi valid. Tidak ada yang seperti itu di SNK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panduan Open-source memiliki rekomendasi berikut. Pertama, tambahan untuk tujuan keamanan menggunakan teknologi lain. Kedua, jika Anda memiliki pustaka sumber terbuka, umumnya disarankan agar Anda mengkomit bagian pribadi dari kunci repositori, sehingga lebih mudah bagi orang untuk mem-fork perpustakaan Anda, membangun kembali dan meletakkannya di aplikasi yang sudah jadi. Ketiga, jangan pernah ganti nama Strong. Terlalu merusak. Terlepas dari kenyataan bahwa itu terlalu destruktif dan ditulis tentang hal itu dalam panduan Open-source, Microsoft terkadang memiliki masalah dengan perpustakaannya sendiri.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada perpustakaan yang disebut System.Reactive. </font><font style="vertical-align: inherit;">Sebelumnya, ini adalah beberapa paket NuGet, salah satunya adalah Rx-Linq. </font><font style="vertical-align: inherit;">Ini hanya contoh, sama untuk sisa paket. </font><font style="vertical-align: inherit;">Di versi kedua, itu ditandatangani dengan kunci Microsoft. </font><font style="vertical-align: inherit;">Pada versi ketiga, ia pindah ke repositori di proyek </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mulai memiliki tanda tangan .NET Foundation. </font><font style="vertical-align: inherit;">Perpustakaan, pada kenyataannya, telah mengubah nama yang kuat. </font><font style="vertical-align: inherit;">Paket NuGet diubah namanya, tetapi rakitan itu disebut di dalam persis sama seperti sebelumnya. </font><font style="vertical-align: inherit;">Bagaimana cara mengalihkan dari versi kedua ke yang ketiga? </font><font style="vertical-align: inherit;">Pengalihan ini tidak dapat dilakukan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validasi nama yang kuat</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara: Nonaktifkan fitur bypass nama yang kuat</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumen lain bahwa nama yang kuat sudah merupakan sesuatu yang merupakan masa lalu dan tetap murni formal adalah bahwa mereka tidak divalidasi. Kami memiliki rakitan yang telah ditandatangani dan kami ingin memperbaiki beberapa jenis bug di dalamnya, tetapi kami tidak memiliki akses ke sumbernya. Kami hanya dapat mengambil dnSpy - ini adalah utilitas yang memungkinkan Anda untuk mendekompilasi dan memperbaiki rakitan yang sudah dikompilasi. Semuanya akan bekerja untuk kita. Karena secara default, memotong validasi nama yang kuat diaktifkan, yaitu, hanya memeriksa bahwa PublicKeyToken sama, dan integritas tanda tangan itu sendiri tidak dicentang. Mungkin ada studi lingkungan di mana tanda tangan masih diverifikasi, dan di sini contoh nyata adalah IIS. Integritas tanda tangan diperiksa pada IIS (Bypass validasi nama kuat dinonaktifkan secara default), dan semuanya akan rusak jika kita mengedit rakitan yang ditandatangani. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahan:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menonaktifkan verifikasi tanda tangan untuk majelis menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanda publik.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan itu, hanya kunci publik yang digunakan untuk penandatanganan, yang menjamin keamanan nama majelis. Kunci publik yang digunakan oleh Microsoft diposting di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Rider, tanda publik dapat diaktifkan di properti proyek. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapan mengubah versi fileassembly</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panduan open-source juga menawarkan beberapa kebijakan Versi, yang tujuannya adalah untuk mengurangi jumlah pengalihan Binding yang diperlukan dan perubahannya untuk pengguna di NET Framework. Kebijakan Versi ini adalah bahwa kita tidak boleh mengubah Versi Majelis terus-menerus. Ini, tentu saja, dapat menyebabkan masalah dengan pemasangan di GAC, sehingga gambar asli yang diinstal mungkin tidak sesuai dengan perakitan dan Anda harus melakukan kompilasi JIT lagi, tetapi, menurut saya, ini lebih jahat daripada masalah dengan versi. Dalam kasus CrossGen, majelis asli tidak diinstal secara global - tidak akan ada masalah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, paket NuGet Newtonsoft.Json, ia memiliki beberapa versi: 12.0.1, 12.0.2, dan seterusnya - semua paket ini memiliki rakitan dengan versi 12.0.0.0. </font><font style="vertical-align: inherit;">Rekomendasi adalah bahwa Versi Majelis harus diperbarui ketika versi utama dari paket NuGet berubah.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ikuti tips untuk .NET Framework: hasilkan pengalihan secara manual dan coba gunakan versi dependensi yang sama di semua proyek dalam solusi Anda. </font><font style="vertical-align: inherit;">Ini harus secara signifikan meminimalkan jumlah arahan ulang. </font><font style="vertical-align: inherit;">Anda memerlukan penamaan yang kuat hanya jika Anda memiliki skenario pemuatan build khusus di mana diperlukan, atau Anda sedang mengembangkan perpustakaan dan ingin menyederhanakan kehidupan bagi pengguna yang benar-benar membutuhkan penamaan yang kuat. </font><font style="vertical-align: inherit;">Jangan mengubah nama yang kuat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Standard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami beralih ke .NET Standard. Ini sangat terkait erat dengan Versi hell di .NET Framework. .NET Standard adalah alat untuk menulis pustaka yang kompatibel dengan berbagai implementasi platform .NET. Implementasi merujuk pada .NET Framework, .NET Core, Mono, Unity, dan Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Tautan ke dokumentasi</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah tabel dukungan .NET Standard untuk berbagai versi dari versi runtimes yang berbeda. Dan di sini kita dapat melihat bahwa .NET Framework sama sekali tidak mendukung .NET Standard versi 2.1. Rilis .NET Framework, yang akan mendukung .NET Standard 2.1 dan yang lebih baru, belum direncanakan. Jika Anda sedang mengembangkan perpustakaan dan ingin itu berfungsi untuk pengguna di .NET Framework, Anda harus memiliki target untuk .NET Standard 2.0. Selain fakta bahwa .NET Framework tidak mendukung versi terbaru dari .NET Standard, mari perhatikan asterisk. .NET Framework 4.6.1 mendukung .NET Standard 2.0, tetapi dengan tanda bintang. Ada catatan kaki secara langsung di dokumentasi, di mana saya mendapatkan tabel ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan contoh proyek. Aplikasi pada .NET Framework yang memiliki satu ketergantungan yang menargetkan .NET Standard. Sesuatu seperti ini: ConsoleApp dan ClassLibrary. Perpustakaan Target .NET Standard. Ketika kami menyatukan proyek ini, akan seperti ini di BIN kami. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan memiliki seratus DLL di sana, yang hanya satu yang terkait dengan aplikasi, semuanya datang untuk mendukung .NET Standard. Faktanya adalah bahwa .NET Standard 2.0 muncul lebih lambat dari .NET Framework 4.6.1, tetapi pada saat yang sama mereka ternyata kompatibel dengan API, dan para pengembang memutuskan untuk menambahkan dukungan Standard 2.0 ke .NET 4.6.1. Kami melakukannya bukan secara asli (dengan memasukkan </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam runtime itu sendiri), tetapi sedemikian rupa sehingga .NET Standard * .dll dan semua fasad perakitan lainnya ditempatkan langsung di BIN.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita melihat dependensi versi .NET Framework yang kita targetkan dan jumlah perpustakaan yang jatuh ke dalam BIN, kita akan melihat bahwa tidak banyak dari mereka di 4.7.1, dan karena 4.7.2 tidak ada perpustakaan sama sekali, dan .NET Standar didukung di sana secara asli. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah tweet dari salah satu pengembang .NET, yang menjelaskan masalah ini dan merekomendasikan untuk menggunakan .NET Framework versi 4.7.2 jika kita memiliki perpustakaan .NET Standard. </font><font style="vertical-align: inherit;">Bahkan dengan versi 2.0 di sini, tetapi dengan versi 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika memungkinkan, naikkan Kerangka Target dalam proyek Anda ke setidaknya 4.7.1, lebih disukai 4.7.2. </font><font style="vertical-align: inherit;">Jika Anda mengembangkan perpustakaan untuk membuat hidup lebih mudah bagi pengguna perpustakaan, buat Target terpisah untuk .NET Framework, itu akan menghindari sejumlah besar dll yang dapat bertentangan dengan sesuatu.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan teori umum. </font><font style="vertical-align: inherit;">Kami akan membahas bagaimana kami meluncurkan JetBrains Rider di .NET Core, dan mengapa kami harus membicarakannya sama sekali. </font><font style="vertical-align: inherit;">Rider adalah proyek yang sangat besar, ia memiliki solusi perusahaan besar dengan sejumlah besar proyek yang berbeda, sistem dependensi yang kompleks, Anda tidak bisa begitu saja mengambilnya dan bermigrasi ke runtime lain pada satu waktu. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita harus menggunakan beberapa peretasan, yang juga akan kita analisis.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplikasi .NET Core</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti apa tampilan aplikasi .NET Core? Bergantung pada bagaimana tepatnya itu digunakan, apa yang akhirnya akan terjadi. Kami dapat memiliki beberapa skenario. Yang pertama adalah penyebaran yang bergantung pada Kerangka. Ini sama dengan di .NET Framework ketika aplikasi menggunakan runtime yang sudah diinstal sebelumnya di komputer. Ini bisa menjadi penyebaran mandiri, ini adalah saat aplikasi membawa runtime. Dan mungkin ada penyebaran file tunggal, ini adalah ketika kita mendapatkan satu file exe, tetapi dalam kasus .NET Core di dalam file exe ini ada artefak aplikasi mandiri, ini adalah arsip self-extracting. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami hanya akan mempertimbangkan penyebaran yang bergantung pada Kerangka. Kami memiliki dll dengan aplikasi, ada dua file konfigurasi, yang pertama diperlukan, ini </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dimulai dengan .NET Core 3.0, file exe dihasilkan yang diperlukan untuk membuat aplikasi lebih nyaman untuk dijalankan, sehingga Anda tidak perlu memasukkan perintah .NET jika kita berada di Windows. </font><font style="vertical-align: inherit;">Ketergantungan jatuh ke dalam artefak ini, dimulai dengan .NET Core 3.0, di .NET Core 2.1 Anda harus menerbitkan atau menggunakan properti lain di </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerangka berbagi, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi pengaturan runtime yang diperlukan untuk menjalankannya. Ini menunjukkan di bawah Kerangka Bersama mana aplikasi akan diluncurkan, dan terlihat seperti ini. Kami menunjukkan bahwa aplikasi akan berjalan di bawah "Microsoft.NETCore.App" versi 3.0.0, mungkin ada Kerangka Bersama lainnya. Pengaturan lain mungkin juga ada di sini. Misalnya, Anda dapat mengaktifkan pengumpul Sampah server. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dihasilkan selama perakitan proyek. Dan jika kita ingin memasukkan server GC, maka kita perlu memodifikasi file ini terlebih dahulu, bahkan sebelum kita merakit proyek, atau menambahkannya dengan tangan. Anda dapat menambahkan pengaturan Anda di sini seperti ini. Kami dapat menyertakan properti di </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jika properti tersebut disediakan oleh pengembang .NET, atau jika properti tidak disediakan, kami dapat membuat file bernama</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tulis pengaturan yang diperlukan di sini. Selama perakitan, pengaturan lain yang diperlukan akan ditambahkan ke templat ini, misalnya, Kerangka Bersama yang sama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerangka Bersama adalah seperangkat runtime dan pustaka. Bahkan, hal yang sama dengan runtime .NET Framework, yang dulunya hanya diinstal sekali pada mesin dan untuk semua adalah satu versi. Shared Framework, dan, tidak seperti runtime .NET Framework tunggal, dapat diversi, aplikasi yang berbeda dapat menggunakan versi yang berbeda dari runtime yang diinstal. Kerangka Bersama juga dapat diwarisi. Kerangka Bersama itu sendiri dapat dilihat di lokasi tersebut pada disk seperti yang umumnya diinstal pada sistem.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa Framework Bersama standar, misalnya, Microsoft.NETCore.App, yang menjalankan aplikasi konsol konvensional, AspNetCore.App, untuk aplikasi web, dan WindowsDesktop.App, Framework Bersama baru di .NET Core 3, yang menjalankan aplikasi desktop pada Formulir Windows dan WPF. Dua Framework Bersama terakhir pada dasarnya melengkapi yang pertama diperlukan untuk aplikasi konsol, yaitu, mereka tidak membawa runtime baru, tetapi hanya melengkapi yang sudah ada dengan perpustakaan yang diperlukan. Warisan ini terlihat seperti ada juga dalam direktori Shared Framework </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana dasar Shared Framework ditentukan.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manifes ketergantungan ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjelajahan default - .NET Core</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
File konfigurasi kedua adalah ini </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. File ini berisi deskripsi semua dependensi aplikasi atau Kerangka Bersama, atau perpustakaan, perpustakaan </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga memilikinya. Ini berisi semua dependensi, termasuk yang transitif. Dan perilaku runtime .NET Core berbeda tergantung pada apakah </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi memilikinya atau tidak. Jika </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak, aplikasi akan dapat memuat semua majelis yang ada dalam Kerangka Bersama atau dalam direktori BIN-nya. Jika ada </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka validasi diaktifkan. Jika salah satu majelis yang terdaftar dalam </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak, maka aplikasi tidak akan dimulai. Anda akan melihat kesalahan yang disajikan di atas. Jika aplikasi mencoba memuat beberapa perakitan di runtime, yang</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika, misalnya, menggunakan metode beban perakitan atau selama proses penyelesaian rakitan, Anda akan melihat kesalahan yang sangat mirip dengan memuat perakitan ketat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengendara Jetbrains</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider adalah .NET IDE. Tidak semua orang tahu bahwa Rider adalah IDE yang terdiri dari frontend berdasarkan IntelliJ IDEA dan ditulis dalam Java dan Kotlin, dan backend. Backend pada dasarnya adalah R #, yang dapat berkomunikasi dengan IntelliJ IDEA. Backend ini adalah aplikasi .NET lintas platform sekarang. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di mana ia berjalan? Windows menggunakan .NET Framework, yang diinstal di komputer pengguna. Pada sistem informasi lain, di Linux dan Mac, Mono digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini bukan solusi ideal ketika ada runtimes berbeda di mana-mana, dan saya ingin datang ke keadaan berikutnya sehingga Rider berjalan di .NET Core. Untuk meningkatkan kinerja, karena dalam. NET Core semua fitur terbaru dikaitkan dengan ini. Untuk mengurangi konsumsi memori. Sekarang ada masalah dengan cara Mono bekerja dengan memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beralih ke .NET Core akan memungkinkan Anda untuk meninggalkan warisan, teknologi yang tidak didukung dan memungkinkan untuk memperbaiki beberapa perbaikan untuk masalah yang ditemukan di runtime. </font><font style="vertical-align: inherit;">Beralih ke .NET Core akan memungkinkan Anda untuk mengontrol versi runtime, yaitu, Rider tidak akan lagi berjalan di .NET Framework yang diinstal pada komputer pengguna, tetapi pada versi tertentu .NET Core, yang dapat dilarang, dalam bentuk penyebaran mandiri. </font><font style="vertical-align: inherit;">Transisi ke .NET Core pada akhirnya akan memungkinkan penggunaan API baru yang diimpor secara khusus di Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tujuannya adalah untuk meluncurkan prototipe, meluncurkannya, hanya untuk memeriksa bagaimana itu akan bekerja, apa poin potensial kegagalan, komponen mana yang harus ditulis ulang lagi, yang akan membutuhkan pemrosesan global.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur yang membuat menerjemahkan Rider ke .NET Core menjadi sulit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio, bahkan jika R # tidak diinstal di dalamnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lumpuh dari Memori Kehabisan pada solusi besar, di dalamnya ada proyek dengan SDK-style * .csproj</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">SDK-style * .csproj adalah salah satu syarat utama untuk relokasi .NET Core penuh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah masalah karena Rider didasarkan pada R #, mereka tinggal di repositori yang sama, pengembang R # ingin menggunakan Visual Studio untuk mengembangkan produk mereka sendiri dalam produk mereka untuk membuatnya menjadi makanan. </font><font style="vertical-align: inherit;">Di R # ada tautan pustaka spesifik untuk kerangka kerja yang dengannya Anda perlu melakukan sesuatu. </font><font style="vertical-align: inherit;">Di Windows, kita bisa menggunakan Framework untuk aplikasi desktop, dan di Linux dan Mac, Mock sudah digunakan untuk pustaka Windows dengan fungsionalitas minimal.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keputusan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memutuskan untuk tetap menggunakan yang lama untuk saat ini </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, berkumpul di bawah Kerangka penuh, tetapi karena majelis Kerangka dan Core adalah biner yang kompatibel, jalankan di Core. </font><font style="vertical-align: inherit;">Kami tidak menggunakan fitur yang tidak kompatibel, menambahkan semua file konfigurasi yang diperlukan secara manual dan mengunduh versi dependensi khusus untuk .NET Core, jika ada.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peretasan apa yang harus Anda lakukan?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu peretasan: kami ingin memanggil metode yang hanya tersedia di Kerangka, misalnya, metode ini diperlukan di R #, tetapi tidak pada Core. </font><font style="vertical-align: inherit;">Masalahnya adalah bahwa jika tidak ada metode, maka metode yang memanggilnya selama kompilasi JIT akan jatuh lebih awal </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Artinya, metode yang tidak ada telah merusak metode yang memanggilnya.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusinya ada di sini: kami membuat panggilan ke metode yang tidak kompatibel ke metode yang terpisah. Ada satu masalah lagi: metode seperti itu bisa menjadi inline, oleh karena itu kami menandainya dengan atribut </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retas nomor dua: kita harus dapat memuat majelis di jalur relatif. Kami memiliki satu perakitan untuk Framework, ada versi khusus untuk .NET Core. Bagaimana cara mengunduh versi .NET Core untuk .NET Core? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka akan membantu kita </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mari kita lihat </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pustaka System.Diagnostics.PerformanceCounter. Perpustakaan seperti itu luar biasa dalam hal perpustakaannya</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini memiliki bagian runtime, di mana satu versi perpustakaan dengan jalur relatifnya ditunjukkan. Pustaka ini, rakitan akan dimuat pada semua runtimes, dan itu hanya membuang eksekusi. Jika, misalnya, dimuat di Linux, PerformanceCounter tidak berfungsi pada desain di Linux, dan PlatformNotSupportedException terbang dari sana. Ada juga </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagian runtimeTarget </font><font style="vertical-align: inherit;">dalam hal ini </font><font style="vertical-align: inherit;">dan di sini sudah ditunjukkan versi perakitan ini khusus untuk Windows, di mana PerformanceCounter harus bekerja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita mengambil bagian runtime dan menulis di dalamnya jalur relatif ke perpustakaan yang ingin kita muat, ini tidak akan membantu kita. Bagian runtime sebenarnya menetapkan jalur relatif di dalam paket NuGet, dan tidak relatif terhadap BIN. Jika kita mencari rakitan ini di BIN, hanya nama file yang akan digunakan dari sana. Bagian runtimeTarget sudah berisi jalur relatif jujur, jalur jujur â€‹â€‹relatif terhadap BIN. Kami akan meresepkan jalur relatif untuk majelis kami di bagian runtimeTarget. Alih-alih pengidentifikasi runtime, yang â€œmenangâ€ di sini, kita bisa mengambil yang lain yang kita suka. Sebagai contoh, kami akan menulis pengidentifikasi runtime "any", dan rakitan ini akan dimuat secara umum di semua platform. Atau kita akan menulis "unix", dan itu akan boot di Linux, dan di Mac, dan seterusnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peretasan berikutnya: kami ingin mengunduh di Linux dan Mac Mock untuk membangun WindowsBase. Masalahnya adalah bahwa rakitan yang bernama WindowsBase sudah ada dalam Shared Framework </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bahkan jika kita tidak di Windows. Pada Windows Shared Framework, </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBase mendefinisikan ulang versi yang ada di </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mari kita lihat </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerangka ini, lebih tepatnya pada bagian-bagian yang menjelaskan WindowsBase. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah perbedaannya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika beberapa konflik perpustakaan dan ada di beberapa </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka maksimumnya dipilih untuk pasangan yang terdiri dari </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Panduan .NET mengatakan bahwa </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu hanya diperlukan untuk menunjukkannya di Windows Explorer, tetapi tidak, itu masuk ke dalamnya</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah satu-satunya kasus yang saya tahu kapan versi yang ditentukan </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, benar-benar digunakan. Dalam semua kasus lain, saya melihat perilaku yang tidak peduli versi apa </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang ditulis, majelis akan tetap memuat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retasan keempat. Tugas: kami memiliki file .deps.json untuk dua peretasan sebelumnya, dan kami hanya membutuhkannya untuk dependensi tertentu. Karena mereka </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dihasilkan dalam mode semi-manual, kami memiliki skrip yang, menurut beberapa deskripsi tentang apa yang harus ada di sana, menghasilkannya selama pembuatan, kami ingin menyimpan ini </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seminimal mungkin sehingga kami dapat memahami apa yang ada di dalamnya. Kami ingin menonaktifkan validasi dan mengizinkan unduhan majelis yang ada di BIN tetapi tidak dijelaskan dalam </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi: aktifkan konfigurasi khusus di runtimeconfig. </font><font style="vertical-align: inherit;">Pengaturan ini sebenarnya diperlukan untuk kompatibilitas dengan .NET Core 1.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada .NET Core - ini adalah jenis analog </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memungkinkan Anda melakukan hal yang sama, misalnya, memuat rakitan dengan cara yang relatif. </font><font style="vertical-align: inherit;">Menggunakan </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menulis ulang secara manual, Anda dapat menyesuaikan pemuatan majelis di .NET Core, jika Anda memiliki skenario yang sangat kompleks.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduhan perakitan debug</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berbicara tentang beberapa jenis masalah, jadi Anda harus dapat men-debug masalah dengan memuat rakitan. </font><font style="vertical-align: inherit;">Apa yang bisa membantu dengan ini? </font><font style="vertical-align: inherit;">Pertama, runtimes menulis log tentang bagaimana mereka memuat rakitan. </font><font style="vertical-align: inherit;">Kedua, Anda bisa melihat lebih dekat pada eksekusi yang terbang ke Anda. </font><font style="vertical-align: inherit;">Anda juga dapat fokus pada acara runtime.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Log fusi</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kembali ke Dasar-Dasar: Menggunakan Fusion Log Viewer Ke Debug Errors yang Tidak Jelas </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mekanisme untuk memuat rakitan dalam .NET Framework disebut Fusion, dan ia tahu cara mencatat apa yang dilakukannya pada disk. Untuk mengaktifkan pencatatan, Anda perlu menambahkan pengaturan khusus ke registri. Ini sangat tidak nyaman, jadi masuk akal untuk menggunakan utilitas, yaitu Fusion Log Viewer dan Fusion ++. Fusion Log Viewer adalah utilitas standar yang dilengkapi dengan Visual Studio dan dapat diluncurkan dari baris perintah Visual Studio, Visual Studio Developer Command Prompt. Fusion ++ adalah analog open source dari alat ini dengan antarmuka yang lebih bagus.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion Log Viewer terlihat seperti ini. Ini lebih buruk daripada WinDbg karena jendela ini bahkan tidak meregang. Namun demikian, Anda dapat menembus tanda centang di sini, meskipun tidak selalu jelas set tanda centang mana yang benar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++ memiliki satu tombol "Mulai Logging", dan kemudian tombol "Stop Logging" muncul. Di dalamnya, Anda dapat melihat semua catatan tentang memuat rakitan, membaca log tentang apa yang sebenarnya terjadi. Log ini terlihat seperti ini secara ringkas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah pengecualian dari pemuatan perakitan yang ketat. </font><font style="vertical-align: inherit;">Jika kita melihat log Fusion, kita akan melihat bahwa kita perlu mengunduh versi 9.0.0.0 setelah kita memproses semua konfigurasi. </font><font style="vertical-align: inherit;">Kami menemukan file di mana diduga bahwa kami memiliki majelis yang kami butuhkan. </font><font style="vertical-align: inherit;">Kami melihat bahwa versi 6.0.0.0 ada di file ini. </font><font style="vertical-align: inherit;">Kami memiliki peringatan bahwa kami membandingkan nama lengkap majelis, dan mereka berbeda dalam versi utama. </font><font style="vertical-align: inherit;">Dan kemudian terjadi kesalahan - versi ketidakcocokan.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peristiwa runtime</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencatat Acara Runtime</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Di Mono, Anda dapat mengaktifkan pencatatan menggunakan variabel lingkungan, dan log pada akhirnya akan ditulis ke </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tidak begitu nyaman, tetapi solusinya bekerja. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjelajahan default - .NET Core </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation / design docs / host tracing</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
.NET Core juga memiliki variabel lingkungan khusus </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mencakup login </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan .NET Core 3.0, Anda bisa menulis log ke file dengan menentukan lintasan ke sana dalam variabel </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada acara yang menyala saat majelis gagal dimuat. Ini sebuah acara </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ada acara bermanfaat kedua, ini </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anda dapat berlangganan dan mendapatkan kesalahan tentang memuat majelis, bahkan jika seseorang menulis mencoba .. menangkap dan melewatkan semua eksekusi di tempat di mana</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terjadi. </font><font style="vertical-align: inherit;">Jika aplikasi telah dikompilasi, Anda dapat memulainya </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan dapat memantau eksekusi .NET, dan di sana Anda dapat menemukan yang terkait dengan mengunduh file.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfer pekerjaan ke alat, ke alat pengembangan, ke IDE, ke MSBuild, yang memungkinkan Anda untuk menghasilkan arahan ulang. </font><font style="vertical-align: inherit;">Anda dapat beralih ke .NET Core, lalu Anda akan lupa apa itu Memuat Perakitan Ketat, dan Anda akan dapat menggunakan API baru seperti yang ingin kami capai di Rider. </font><font style="vertical-align: inherit;">Jika Anda menghubungkan pustaka .NET Standard, maka naikkan versi target .NET Framework ke setidaknya 4.7.1. </font><font style="vertical-align: inherit;">Jika Anda tampaknya berada dalam situasi tanpa harapan, cari hacks, gunakan, atau buat hack Anda sendiri untuk situasi tanpa harapan. </font><font style="vertical-align: inherit;">Dan perlengkapi diri Anda dengan alat debugging. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sangat menyarankan Anda membaca tautan berikut:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499824/index.html">Intisari acara untuk perekrut SDM dan TI pada Mei 2020</a></li>
<li><a href="../id499826/index.html">Tekanan darah terdistribusi</a></li>
<li><a href="../id499832/index.html">Bagaimana cara mengatur dengan cepat dan aman pekerjaan jarak jauh karyawan? Kami berbicara tentang berbagai pendekatan: dengan VDI dan tidak hanya</a></li>
<li><a href="../id499834/index.html">Temui Felix Arithmometer</a></li>
<li><a href="../id499836/index.html">Udalenka vs. kantor untuk tim pengembangan</a></li>
<li><a href="../id499842/index.html">Mengapa orang belajar kembali</a></li>
<li><a href="../id499846/index.html">Ketika pengumpulan sampah yang terpisah akan mulai bekerja dan mengapa pemantauan video situs untuk wadah sampah diperlukan</a></li>
<li><a href="../id499850/index.html">Cara menganalisis pesaing dan mengatur strategi digital dalam 40 menit</a></li>
<li><a href="../id499852/index.html">Dokumentasi berbahasa Inggris untuk Angular</a></li>
<li><a href="../id499854/index.html">Apache Bigtop dan pilihan distribusi Hadoop hari ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>