<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèΩ üö¢ ü§© C ++ Concept-Based Polymorphism in Product Code: PassManager in LLVM üòæ ‚¨ÖÔ∏è üçã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we are going to talk about one interesting idiom introduced by Sean Parent (Adobe), a well-known figure in the C ++ community. He often gives pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ Concept-Based Polymorphism in Product Code: PassManager in LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today we are going to talk about one interesting idiom introduced by Sean Parent (Adobe), a well-known figure in the C ++ community. </font><font style="vertical-align: inherit;">He often gives presentations and publishes a series of Better Code articles. </font><font style="vertical-align: inherit;">One of his ideas that Photoshop uses is Concept-Based Polymorphism. </font><font style="vertical-align: inherit;">This is when we implement polymorphism not through explicit inheritance, but using a technique that includes generalized programming, and as a result we get some additional advantages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The article is organized as follows:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is Concept-Based Polymorphism and Why Is It Needed?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little bit about LLVM and its device</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concept-Based Polymorphism Example in LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advantages of the Approach</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A picture illustrating the thesis "Inheritance is evil." </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is Concept-Based Polymorphism and Why Is It Needed?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C ++, dynamic polymorphism is implemented using virtual functions and inheritance, and static polymorphism using patterns. </font><font style="vertical-align: inherit;">Here we combine these two approaches and take the best of them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Explicit use of inheritance often leads to excessive code connectivity and violation of the principle of interface separation ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">How to implement dynamic polymorphism without these disadvantages? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent proposed an idiom called Concept-Based Polymorphism, where inheritance is implicit and hidden from the user. </font><font style="vertical-align: inherit;">You can learn more about this from his report </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inheritance Is The Base Class Of Evil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - where he shows the whole idea using Photoshop and action history as an example - you will learn how the ‚Äúhistorical brush‚Äù actually works.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little bit about LLVM and its device</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would like to show the advantages of this idiom using the example of LLVM. </font><font style="vertical-align: inherit;">Who does not know, LLVM is an infrastructure for developing compilers. </font><font style="vertical-align: inherit;">Below is a very high-level LLVM architecture, which covers only those entities that are used later in the article. </font><font style="vertical-align: inherit;">For more information, refer to the official </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the architecture of LLVM, and, in principle, of any modern compiler.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The main parts are as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Front End takes the source code of the program and turns it into an intermediate representation (IR). </font><font style="vertical-align: inherit;">This simplifies the work of the rest of the compiler so that it does not deal with complex C ++ code.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End - a set of optimizations, analyzes and transformations. </font><font style="vertical-align: inherit;">In its most general form, it is a set of passes (Passes). </font><font style="vertical-align: inherit;">All passes are registered and launched by a special component called PassManager.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back End generates directly the target code.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The compiler presents the program in the form of several basic entities. </font><font style="vertical-align: inherit;">This is a module (conditionally .cpp file), a function, a base unit that contains a set of instructions. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM now has two versions of PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager, it uses the classic run-time inheritance-based polymorphism. </font><font style="vertical-align: inherit;">The inheritance hierarchy includes passes run on a module, function, loop, etc.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager - a new version, just based on Concept-Based polymorphism, it is proposed to replace LegacyPassManager. </font><font style="vertical-align: inherit;">Both versions exist in parallel and develop independently.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea of ‚Äã‚Äãthe article is to demonstrate the concept on real product code, which is implemented in two different ways, and show the advantages of the latter approach.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concept-Based Polymorphism Example in LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As implemented in Legacy</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, how everything is arranged classically, in the LegacyPassManager. </font><font style="vertical-align: inherit;">Let's say we have a class PassManager and there is a class Pass - one pass. </font><font style="vertical-align: inherit;">We have such a hierarchy: ModulePass, from which our class inherits, for example, Constant Propagation. </font><font style="vertical-align: inherit;">There is a runOnModule method, here it is virtual. </font><font style="vertical-align: inherit;">So we have the usual runtime polymorphism:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the code, what is the problem here? We see that in this hierarchy, the methods for starting a passage are different depending on what they should be performed on (on a function - runOnFunction, a module - runOnModule, a cycle - runOnLoop, etc.). In turn, this makes it impossible to process the collection of passes that work with different IR entities in a single way (actually apply polymorphism). It would seem, obviously, how to do it right: you need a virtual run method, which will be redefined in the heirs. But then a problem arises: the run methods in the successor classes will have a different signature, because the parameter is always passed of its type - function, module, and so on. So, you have to make a dummy base class for Module, Function, etc., pass a pointer to this class in run, and do down-cast inside the method,depending on what kind of object is located on this pointer. And something strange begins: when a new subordinate entity appears, we are now forced to rewrite the superior code each time, which contradicts all design principles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can manually write an adapter class for each case. </font><font style="vertical-align: inherit;">But this is a long and uninteresting, and indeed a strange idea to write wrapper classes for the convenient operation of only serving components. </font><font style="vertical-align: inherit;">It would be better to generate this code automatically using templates. </font><font style="vertical-align: inherit;">This is exactly what is proposed to be addressed in the approach under discussion. </font><font style="vertical-align: inherit;">Plus, as you will see later, we will get some more useful consequences.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As suggested in the new version</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following happens in the new PassManager. </font><font style="vertical-align: inherit;">The concept of a polymorphic object is generalized as follows. </font><font style="vertical-align: inherit;">We say that if an object implements some method, then we introduce a set of methods that we want to be polymorphic, and we say that all classes that implement this method are polymorphic, that is, we can use them in interchangeable contexts in this is PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the PassManager class in LLVM. </font><font style="vertical-align: inherit;">Here is a simplified version, and the full one can be found in llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">The IR template parameter directly specializes in the entity on which we are passing (the run function). </font><font style="vertical-align: inherit;">It can be a module, function, or cycle. </font><font style="vertical-align: inherit;">We look at the code, further explanations will be:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the following basic entities:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes ‚Äî ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So what kind of type should this be? </font><font style="vertical-align: inherit;">What is stored in the Passes vector? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, let's see what PassModel and PassConcept are. </font><font style="vertical-align: inherit;">These are helper classes internal to PassManager. </font><font style="vertical-align: inherit;">They are both in the detail namespace. </font><font style="vertical-align: inherit;">First, let's see what the PassConcept class looks like. </font><font style="vertical-align: inherit;">It contains the same run method again, here it is a purely virtual method.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second class, PassModel, is also boilerplate. </font><font style="vertical-align: inherit;">It is inherited from PassConcept.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What it contains:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Private pass_ field of type PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A constructor that accepts an object of type PassT as an input. </font><font style="vertical-align: inherit;">It does nothing intriguing, it only initializes pass_ using the semantics of movement</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The run method, which simply calls the run method on pass. </font><font style="vertical-align: inherit;">Passing, respectively, all the arguments that may be there.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We recall now where we started. In turn, PassManager stores all these passages. In vector Passes from PassConcept type elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the big picture. Created by PassManager. Using AddPass, it records those passes that we want to make over the module, function, loop, etc. For example, inline, constant propagation, loop unrolling, etc. They themselves are not inherited from anyone, they should only have a run method. And just this whole concept provides this. How?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say we have inline optimization. We add an object of type Inline to addPass. Accordingly, in Passes, in the vector, we put this Inline, already in the form of PassConcept. How can we do this? Inline is not inherited from the PassConcept class. How do we put an element in a vector? We cannot do the casting to the base type (upcasting) because there is no inheritance. And here such a trick is done. We have this PassConcept helper class that defines the interface. He says that all of his descendants must implement the run method. We have PassModel, which in turn is boilerplate. And so, when we put Inline, this PassModel is instantiated with this Inline type, this object is compiled inside this class. PassModel itself redefines run, which for itself already calls run for this passage,i.e. run from the Inline class. All this is resolved in compile-time: if Inline does not define the run method, we will have a compile-time error.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, this polymorphism is achieved without inheritance. The question may arise: how is it not inheritance, because here it is, PassModel is inherited from PassConcept? Answer: there is inheritance, but it is internal, it does not stick out, the user does not know anything about it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We speak at a conceptual level. Here we have a user, he wants to override a certain method. At the same time, he does not want to be inherited, so as not to pull extra dependencies on himself. How to do it? We inside ourselves, through PassConcept, PassModel, make runtime polymorphism, through inheritance, but the user does not know about it: these are all the interiors of these two classes, they are defined in their namespace.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once again, how is this achieved? </font><font style="vertical-align: inherit;">I have a class, let's call it, let it be Inline, in terms of the compiler. </font><font style="vertical-align: inherit;">We add Inline to the vector, respectively, create the PassModel object. </font><font style="vertical-align: inherit;">It has a constructor that takes in the object of this template parameter. </font><font style="vertical-align: inherit;">And so, when we call the run method in PassManager, it runs through all the passages, in this case we have only one pass, it has the Inline type. </font><font style="vertical-align: inherit;">It calls the runC method of PassConcept. </font><font style="vertical-align: inherit;">The same run method that lies inside PassModel, which is instantiated by the Inline type. </font><font style="vertical-align: inherit;">And already this method calls the run method on the registered passage, in this case, Inline, and as a result, run on Inline is called.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advantages of the Approach</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how we did different behavior without explicitly using inheritance. We now do not have the explicit dependency that was before in the LegacyPassManager.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What an unusual recursive thing it turns out. We can use polymorphism for any object that overrides the run method. Since the run method overrides PassManager itself, it can register itself, that is, embed itself in Passes pass vector and call itself again.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that we can mix everything. The old PassManager, which is Legacy, has a clear separation. There is modular optimization, which is done on the module; there is optimization that happens on the function. And here it all happens smoothly. We make PassManager, instantiate it with the ‚ÄúModule‚Äù type, put Inline in it, something else, some other modular optimizations. Then the second PassManager, we instantiate it with the ‚ÄúFunction‚Äù type, put optimizations on the function. And then in the PassManager, which is instantiated by the module, you can put another PassManager, which is instantiated by the function, through this Passes vector.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Have time to follow? We have two PassManagers. One with type IR Module, the other with type IR Function. Let's say in the one with the module, we already put some number of passes. Now we want to mix them with passes that are executed on a function. What are we doing? We call addPass and pass PassManager as Pass, which is instantiated with the IR type ‚ÄúFunction‚Äù (in the real code, it is not PassManager that is placed there, but a special class that wraps it, but at the conceptual level it does not matter).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, we can mix different levels of optimization - thanks to the nesting of PassManagers, alternately execute passes to the module, function, cycle, etc. </font><font style="vertical-align: inherit;">In Legacy PassManager, this is more complicated, there is a separate class for modules that has a virtual function runOnModule, a separate class for functions with a virtual method runOnFunction, etc. </font><font style="vertical-align: inherit;">Both of these classes are inherited from the common ancestor of Pass, but they are independent of each other and have a different interface, which makes using the LegacyPassManager inconvenient for calling passes on different IR entities (module, function, loop) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Additional reading materials:</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM for Grad Students</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - A Simple Introduction to LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentation by</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut on how LLVM passes are arranged</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth about implementation details PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A thread</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the mailing list that discusses the difference between LegacyPassManager and PassManager</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Authors: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expert Engineer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AI Compiler Team </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, Russia </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soon Roman will speak at the C ++ Russia 2020 Moscow conference with Anton Polukhin: there they will talk about the present and future copy elision: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link to the report</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lead Specialist </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Business Development Team </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, Russia</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en505824/index.html">Guide: Your Own L2TP VPN</a></li>
<li><a href="../en505826/index.html">How to get 100% vision and even more</a></li>
<li><a href="../en505834/index.html">Median Samples. Confidence Intervals and Comparison</a></li>
<li><a href="../en505838/index.html">FPGA technology for thousands of applications</a></li>
<li><a href="../en505846/index.html">What are the real math problems when developing vaccines from COVID-19?</a></li>
<li><a href="../en505856/index.html">From Brute-Force to the attempt on privacy - what SaaS providers face</a></li>
<li><a href="../en505860/index.html">Spring Boot, Hibernate and Kotlin for beginners step by step</a></li>
<li><a href="../en505870/index.html">How to promote mobile games and applications in Japan, Korea and China</a></li>
<li><a href="../en505872/index.html">History of unmanned vehicles</a></li>
<li><a href="../en505880/index.html">How to write your index in Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>