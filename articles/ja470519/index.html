<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔇 🔢 🙆 シングルボード更新用のLinuxアセンブリの構築経験 💅🏻 🈂️ #⃣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 現在のところ、市場では、あらゆる好みに合わせて手頃な価格で幅広い単一の支払い者を提供しています。
 
 原則として、製造元のさまざまなアセンブリはプラットフォームを評価するように設計されており、新しいプロジェクトの開始点であるため、特定のタスクに常に適しているとは限りません。高い信頼性が必...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>シングルボード更新用のLinuxアセンブリの構築経験</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470519/"><img src="https://habrastorage.org/webt/uv/15/sj/uv15sjkhjdjizxf0g2acp_abzai.jpeg" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のところ、市場では、あらゆる好みに合わせて手頃な価格で幅広い単一の支払い者を提供しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、製造元のさまざまなアセンブリはプラットフォームを評価するように設計されており、新しいプロジェクトの開始点であるため、特定のタスクに常に適しているとは限りません。高い信頼性が必要なタスクでは、開発者は配布キットを変更し、イメージと更新システムを完全に作り直すことで支払いを行わない方法の問題に直面します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターネットでは、リリースビルドとは何か、その更新を実装する方法についての情報はほとんどないため、開発者は「自転車」を思い付くか、常に100％テストされているとは限らない独自の開発を使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はさまざまなLinuxデバイス用のソフトウェアの開発に携わっており（私のポートフォリオはdevelinuxという単語でGoogleにすることができます）、11部構成のプロジェクトの作者でもあるため、アセンブリの構築だけでなく、WEBまたはUSBフラッシュを介した更新メカニズムの開発にも定期的に対処する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、関連分野における私の経験と知識を共有したいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み立て要件</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなデバイスのアセンブリとアップデートを開発する過程で、私はいくつかの要件を自分で確認しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電源が突然オフになったときにアセンブリが損傷してはいけません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリはすばやく読み込まれるはずです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブートローダーは問題なく動作するはずです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリは更新をサポートする必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの要件について以下で詳しく説明します。その後、画像をセクションに分割する3つの方法とその更新について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電源が突然オフになったときに、アセンブリが損傷してはなりません。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10回目の再起動後に動作を停止するデバイスが必要なのは誰ですか？誰にも！既製のディストリビューションを使用している場合（埋め込み用のディストリビューションが非常に少ない場合）、ボックスからファイルを入手しないと、この点に関してすべて信頼性が低くなります。 imx6の下でubuntuを使用したプロジェクトをよく覚えていました。カードのファイルシステムが損傷していて、10回目の再起動、40回目の損傷など、空の星に依存していました。プロジェクトはFS aufsを保存しました。実際には、ubuntuは読み取り専用に設計されておらず、常に何かを書き込む必要があります。 SDカードでyoctoが使用された別のプロジェクトでも同様の状況を覚えています。一般に、SDカードは、emmcやnandよりもはるかに信頼性が高く、最も速くクラッシュする最も醜いタイプのドライブです。 SDカードを使用する場合は、操作中にできる限り書き込みを少なくすることをお勧めします。セクターのバックグラウンド転送アルゴリズムは非常に予測不可能であり、私は世界のブランドの数十の異なるSDカードで作業し、推奨できる単一のカードを見つけませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、SDカードにはいくつかの利点があり、手頃な価格で安価で、ソフトウェアのデバッグに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜ私は...そして、これが問題です-ルートFSは読み取り専用でなければならず、操作中はそこにエントリがありません。あなたはおそらく考えるでしょう：どのように？何百万ものAndroidデバイスが常に何かを書き込み、失敗することはありません。本当ですが、これはすべてです。ほとんどのAndroidデバイスには最初にバッテリーがあり、2番目に、ルートFSはramdiskとしてフレーム化されており、システムパーティションは読み取り専用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムの信頼性が必要な場合は、ルートFSにパッケージをインストールする際に発生するあらゆる種類のことにより、多くの問題が発生する可能性があります。ファイルシステムとしてsquashfsをお勧めします。それは素早く動作し、何も書き込むことができず、圧縮によりスペースを節約します... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、設定の保存、ファイルのダウンロードなどはどう</font><font style="vertical-align: inherit;">ですか</font><font style="vertical-align: inherit;">？あなたが尋ねる？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、そのためには、別のRWパーティションを作成する必要があります。</font><font style="vertical-align: inherit;">NANDで書き込む場合は、実績のあるオプション-UBIFSをお勧めします。</font><font style="vertical-align: inherit;">NORの場合、jffs2。</font><font style="vertical-align: inherit;">別のドライブに書き込む場合は、ext4、btrfs、ReiserFSをお勧めします。これらの中から最適なFSを指摘することはできません。</font><font style="vertical-align: inherit;">みんなで色々な問題がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、rwパーティションをマウントする前に、必ずfsckのようなユーティリティを使用してパーティションのエラーを確認してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリはすばやく読み込まれるはずです</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスのダウンロード速度は、全体的なユーザビリティに影響します。</font><font style="vertical-align: inherit;">一部のタスクでは、読み込み時間は30秒以下であり、一部のタスクでは5分が許容されます。</font><font style="vertical-align: inherit;">私自身、最大1分の時間を費やして、時間を短縮しました。</font><font style="vertical-align: inherit;">ダウンロードを1分以上待ち、デバイスがフリーズしているように見えることがあります。時間を短縮できる場合は、使用することをお勧めします。</font></font><br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローダーは、アセンブリがなければ起動しません。最近、シングルボードメーカーがブートローダーまたは完成したイメージをブートローダーに登録する方法の説明を含むSDカードのデモをアップロードすることで開発を容易にする方法をよく見かけます。ブートローダーは、ddコマンドで簡単に入力されます。しかし、SDカードがフリーズした場合はどうなりますか？同じことは珍しいことではありません。個人的には、私の練習では、カードはしばしば脱落しました。これがあなたが数時間有料で働く方法であり、あなたはソフトウェアを書き、bamであり、それがすべてです...カーネルのエラーが流れ込み始め、カードが落ちました。しかし、これが再起動せずにフィールドで機能するデバイスである場合はどうでしょうか？ちなみに、ウォッチドッグを含む再起動は、ハングしたカードを常に復活させるわけではありません。カードにはリセット信号がありません。これはemmcではありません。もちろん、これはボードの回路の問題であり、ボードにカードの電源のリセットがある場合、節約されますが、どこにでもあるわけではありません。一部のボードでは、電源またはカードを歪めるだけで効果があります。私の経験に基づいて、動作中にドライブで記録が実行される場合、メインアセンブリを備えたドライブにブートローダーを保存することはお勧めしません。システムがブートローダーを使用してドライブに何も書き込まず、これがめったに起こらない場合は、ください。私の経験では、読み取り専用モードでは、ファイルシステムはハードウェアエラーのためだけに変形され、ソフトウェアエラーのためには変形されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートローダーは、安全な場所、信頼性の高いドライブ、たとえば別のNORまたはEEPROMチップに保存する必要があります。</font><font style="vertical-align: inherit;">以下は、ブートローダーを格納するためのSPI NORを備えた、imx6ullチップに基づくモジュールの例です。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/w0/ka/um/w0kaumujmmpo6mey_ubuk6oknm4.jpeg" alt="画像" width="50%"></div></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビルドはアップグレードをサポートする必要があります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 更新せずに、どこにも...私は多くのプロジェクトに参加し、作品を提出するための完璧なソフトウェアを入手できませんでした。エラーは常に検出されるか、機能の改善が必要です。人々がソフトウェアを書いている間、彼らは間違いをし、人々がデバイスを使用している間、彼らはもう少し欲しくなることを理解する必要があります。 90％のケースでは、十分に考慮された更新システムの欠如が、製造業者の頭痛とプロジェクト全体の崩壊の両方につながる可能性があります。たとえば、ビデオ監視システムが輸送用に開発され、システムがロシア全土に設置されており、マーケティング担当者が市場を過小評価してストリーミングを提供していなかったことがわかりました。さらに、ファームウェアにいくつかのエラーが見つかり、さらに消費者は競合他社の方向を一目見始めました。購入したデバイスにはないものがあります...はい、はい、不思議な庭では、イチゴがおいしくて天気が良いです（心理学）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような状況で何をすべきか？</font><font style="vertical-align: inherit;">更新がサポートされている場合、多くの解決策があり、エラーを修正し、ストリームブロードキャストを改善し、機能をコンシューマー向けにカスタマイズして、コンシューマーファームウェアに指示を与えるだけです。</font><font style="vertical-align: inherit;">しかし、それがサポートされていない場合、製造元はデバイスの交換までサービスエンジニアの出張で大きな冒険をすることになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスのアップデートシステムは、細部まで考えて、100％テストする必要があります。</font><font style="vertical-align: inherit;">この部分の1つの間違いは、アイロンをレンガに変えるため、許容範囲や例外はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新プロセスは、電源を切らないようにする必要があり、いかなる状況でもデバイスが損傷することはありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来の更新を考慮してイメージをパーティション分割するためのアプローチの概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのアプローチのうち、私が個人的に実装した3つのタイプを推奨できます。</font><font style="vertical-align: inherit;">これらはすべてのアプローチではなく、その範囲はこの記事の範囲を超えています。</font><font style="vertical-align: inherit;">3つのタイプすべてに欠陥があり、理想からはほど遠いですが、私には、常識の黄金の平均に近いようです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプローチ1</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/y0/1l/j4y01l02_tkwvnpe-gs1e2jabiy.jpeg" alt="画像" width="50%"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単で手頃な方法：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDカードなどのドライブに、u-bootからデバイスの内蔵ドライブ（NANDフラッシュなど）にフラッシュされるイメージが配置されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
u-bootでは、このためのスクリプトを準備する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
利点-これは最も簡単なタイプの更新であり、開発には最大で1日かかります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの欠点は、プロセスを視覚化できないことと、ブートローダーの機能が非常に制限されていることです。もちろん、独自のu-bootコマンドを考えない限り、標準ツールを使用した複雑なロジックはありません（ただし、これは別の種類の更新であり、Cは非常に強力です）。この方法は、WEB経由の更新を目的としたものではありません。フラッシュされたイメージの整合性を制御することは問題があり、場合によっては、アセンブリサイズがRAMサイズを超えてはなりません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、一部のタスクでは、アップグレード中に設定を保存する必要があり、これはこのアプローチでは実装が容易ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプローチ2</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/ox/vd/iaoxvdexq7u8_biakyniktekgmk.jpeg" alt="画像" width="50%"></div></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討中の最も信頼性が高く保護された方法ですが、最も困難です。</font><font style="vertical-align: inherit;">この方法は、特に責任ある開発で使用することをお勧めします。</font><font style="vertical-align: inherit;">回路が追加のイメージを使用するため、イメージの破損とメインドライブの物理的な損傷の両方から保護されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチでは、最小ビルド（ramdiskサイズ8-16Mb）とメインビルドを使用します。</font><font style="vertical-align: inherit;">Ramdiskは圧縮アーカイブなので、16MBのビルドは物理的に数倍小さくなります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最小のアセンブリの目標は、メインアセンブリを評価して読み込むことです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ramdiskは、FITイメージのカーネルお​​よびu-bootスクリプトでホストされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜFITイメージで何が得られるのですか？ FITイメージは、u-bootでサポートされている形式です。すべてのコンポーネント（カーネル、dts、ramdisk、スクリプト）の整合性を保証します。 FITイメージの解凍はu-bootで実行され、チェックサムが収束しない場合、u-bootはイメージのロードを拒否します。これは便利です。整合性制御を自分で行う必要はありません。複数のファイルを個別に書き込んだり、独自のイメージを作成したりする必要はありません。すべてFITイメージによって行われます。通常、FITイメージは7〜20 MBを占有します。たとえば、qspiやフラッシュなど、信頼性の高い別のドライブに書き込む必要があります。メインアセンブリは、NANDフラッシュなどの安価で信頼性の低いメモリに格納できます。主な作業は本体で行われるため、最初に損傷するのは正確です。この場合、最小限のrootfsを持つ別のドライブが助けになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起動プロセス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
u-bootは、FITアップデート（FIT2）を使用しようとするスクリプトをダウンロードし、次にFITファクトリーファームウェア（FIT1）をダウンロードします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FIT2が存在しないか、整合性に違反している場合、フィットチェックは失敗し、u-bootは最初のFIT（FIT1）をロードします。</font><font style="vertical-align: inherit;">FIT更新（FIT2）があり、それが壊れていない場合は、ramfsがロードされ、rootfs更新（Rootfs2）がチェックされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rootfs2が壊れている場合、スクリプトはFIT更新（FIT2）を削除し、再起動後、FIT（FIT1）とRootfs1で構成されるファクトリーイメージがダウンロードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新プロセス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新イメージには、FIT、rootfs、およびすべてのコンポーネントのチェックサムを含むさまざまなアセンブリ情報が含まれています。</font><font style="vertical-align: inherit;">アセンブリ情報は、アップグレード中に整合性と互換性を監視するために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
進行状況を段階的に更新します。 </font></font><br>
<br>
<ul>
<li>       , </li>
<li>     , </li>
<li> Rootfs2       , </li>
<li>     , </li>
<li> FIT2   ,</li>
<li>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスが失敗した場合、FIT2の不在または損傷がシステムを台無しにすることはありません。</font><font style="vertical-align: inherit;">u-bootは単にそれを使用することを拒否し、ファクトリーイメージをロードします。</font><font style="vertical-align: inherit;">したがって、アップグレード中に、FIT2の整合性はチェックされません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新後、新しいアセンブリはFIT2およびRootfs2の形式でメインドライブに配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法は、ドライブの機械的損傷やFSエラーに耐性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重大な誤動作が発生した場合、工場出荷時のイメージが開始されます。ここで、リカバリソフトウェアが機能します。たとえば、NANDを再確認し、SSHプロトコルを使用してネットワークからファームウェアをダウンロードし、それを書き留めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は回復の例を挙げただけで、多くのオプションがあります。</font><font style="vertical-align: inherit;">このアプローチでは、リカバリプロセスは、最初のバージョンのようにブートローダーではなく、何でもできる本格的なLinuxによって駆動されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプローチ3</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/wx/mz/o-/wxmzo-tpggd3a6goz48-us359_s.jpeg" alt="画像" width="50%"></div></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプのアップデートは、非常にうまく機能しているため、ほとんどすべての11パートのプロジェクトで使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアップデートは、あらゆる種類のアセンブリ、あらゆるタイプのドライブに適しています。前のタイプとは異なり、ここではSPI NORはu-bootにのみ使用されているため、サイズが小さく、コストが低く、1 MBで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプの更新では、ramdiskを個別にビルドする必要がありません。つまり、将来の開発とサポートのためにプログラミング時間が節約されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例ではSDカードドライブを使用していますが、UBIFSを使用してNANDにすることもできます。違いはありません。このアプローチでは、ロード前にRootfs ROのチェックは行われません。アセンブリが破損している場合、システムはそれが破損していることを認識せず、円でロードします。ここでは、ROセクションのデータはいかなる方法でも変更できないと想定されています。このアプローチは、ドライブの物理的な誤動作を排除します。ドライブが物理的に正常でない場合は、デバイスをサービスセンターに運ぶ必要があります。自己修復機能はありません。これは、開発のスピードを上げ、サポートをより安く、エレメンタルベースをより安くするために払わなければならない代償ですが、それは正当化されます。ほとんど発生しないことを保証する理由。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダウンロードと更新のロジックは、前のアプローチと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートの場合、u-bootは最初にFIT更新（FIT2）をダウンロードします。それがないか、整合性に違反している場合、u-bootは最初のFIT（FIT1）をロードし、工場でステッチされたアセンブリが開始され、システムが更新されるまで続きます。</font><font style="vertical-align: inherit;">システムが更新されると、FIT2とRootfs2が表示されます。</font><font style="vertical-align: inherit;">この場合、デバイスが起動すると、FIT更新（FIT2）が最初に開始されます。</font><font style="vertical-align: inherit;">各FITに格納されているu-bootスクリプトでは、マウントするrootfsを記述する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有パーティションRW</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では、どこにも共有パーティションブロックがあり、これは書き込み用のパーティションのグループです。</font><font style="vertical-align: inherit;">そこにのみエントリが作成されます。</font><font style="vertical-align: inherit;">共有パーティションは、わかりやすくするために1つのパーティションとして示されています。</font><font style="vertical-align: inherit;">実際には、そのうちの3つがあります。2つは構成用に小さく、ミラーで機能し、もう1つはその他すべてに使用します。</font><font style="vertical-align: inherit;">さらに、更新時に一部の構成を保持することをお勧めします。たとえば、ネットワークを構成してアップグレードする場合、ネットワーク設定を再構成する必要がないので便利です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まとめる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、更新をサポートする3種類のアセンブリについて説明します。これらはすべて私が個人的に確認したものであり、プロジェクトで安全に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、要件に最も適しているため、最後の2つのみを使用します。</font><font style="vertical-align: inherit;">わかりやすくするために、これらのタイプの更新が使用されるデバイスの例を示します（11部のポートフォリオの詳細）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4G / WiFi / LAN経由のRS485リピーター、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4K V-By-One産業用ディスプレイコントローラーコントロールボード、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合された格納庫気候制御システム、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2DisplayPort-LVDS産業用ディスプレイビデオコントローラー、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライン制御システム</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPNゲートウェイ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の記事が有用で興味深い場合は、このサイトの組み込みLinuxの分野における私の経験と実証済みの技術ソリューションをさらに共有する準備ができています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ありがとうございます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゴルチャコフイリヤの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電報：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">develinux</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470503/index.html">Kubernetes RBACのユーザーと承認</a></li>
<li><a href="../ja470511/index.html">アルメニアのIT：国の戦略的セクターと技術分野</a></li>
<li><a href="../ja470513/index.html">ボットネットに支配されたスマートホームを見つけた方法</a></li>
<li><a href="../ja470515/index.html">テスターに​​とっての小さな一歩：ハイゼンバグ2019 Piterの上位10件のレポート</a></li>
<li><a href="../ja470517/index.html">最小のロシアEP</a></li>
<li><a href="../ja470521/index.html">3CX V16アップデート3とAndroid向けの新しい3CXモバイルアプリがリリースされました</a></li>
<li><a href="../ja470525/index.html">登録およびSMSなしのブラウザーでのWindows-HTML5 RDPクライアントの概要</a></li>
<li><a href="../ja470529/index.html">レガシープロジェクトをGraphQLに変換する方法</a></li>
<li><a href="../ja470531/index.html">神経生理学者は、Neuralinkプロジェクトについて話し合い、「指で」の脳の働きについて話します</a></li>
<li><a href="../ja470535/index.html">Pythonを使用して棒グラフを作成する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>