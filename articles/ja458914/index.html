<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍗 ⛷️ 🍈 Unityでゲームを作成するために知っておくべきこと（必要ではない） 👋🏻 💃🏿 👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unityは、エントリースレッショルドが0とはほど遠い（同じGame Maker Studioと比較して）ゲームエンジンです。この記事では、それを研究し始めたときに発生した問題と、見つけた解決策について説明します。このような瞬間について、Android向けの2Dパズルゲームの例で説明します（Play...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityでゲームを作成するために知っておくべきこと（必要ではない）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458914/"><img width="100%" src="https://habrastorage.org/webt/tf/uv/8n/tfuv8nnybrkzyxholyzuoaasafo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityは、エントリースレッショルドが0とはほど遠い（同じGame Maker Studioと比較して）ゲームエンジンです。この記事では、それを研究し始めたときに発生した問題と、見つけた解決策について説明します。</font><font style="vertical-align: inherit;">このような瞬間について、Android向けの2Dパズルゲームの例で説明します（Playマーケットですぐにリリースされることを願っています）。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は本当のふりをしていませんし、自分自身の後で繰り返すことを勧めません。最善の方法がわかっている場合は、自分でそれを行う方法を示します。Unityに慣れ始めたばかりの人は、少ない労力でインディーゲーム開発の傑作を作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は発電所の設計エンジニアですが、コーディングには常に興味があり、プログラミング言語にも精通しています。</font><font style="vertical-align: inherit;">したがって、Unityでゲームを作成することに同意します。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少しC＃またはJavaScript（少なくともC字型の構文）を知っている必要があります。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下で説明するのはUnityチュートリアルではなく、私なしでネットワークで十分に育てられています。</font><font style="vertical-align: inherit;">Unityで最初のプロジェクトを作成するときに発生する可能性がある困難な瞬間を以下にまとめます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提供されたスクリプトはゲームロジック（「トレードシークレット」を表す）のほとんどを省略していますが、例としてのパフォーマンスは確認されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題1-オリエンテーション</font></font></h3><br>
<img align="left" width="40%" src="https://habrastorage.org/webt/-f/za/hw/-fzahwdptbht2vwe1qm4xswgqkm.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリエンテーションロック</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初に直面した問題は、画面の向きに合わせてビジュアルインターフェイスを最適化することに十分な注意を払っていなかったことです。解決策は最も簡単です。画面の向きを変更する必要がない場合は、ブロックすることをお勧めします。過度の柔軟性は必要ありません。100万ドルの反対側にあるプロジェクトではなく、インディーゲームを作成しています。ゲームがポートレートで見栄えがよくなるのに、なぜ大量の条件付き遷移とアンカーの変更が必要なのか（たとえば）。ここで画面の向きをロックできます：</font></font><br>
&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">編集&gt;プロジェクト設定&gt;プレーヤーの</font></font></b><br clear="all">
<br clear="all">
<img align="right" width="40%" src="https://habrastorage.org/webt/jb/3u/ot/jb3uotkehyw_t2pa2e__yw0n2ng.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる解像度。</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
選択した向きで異なる解像度でビジュアルインターフェイスをテストすることも重要</font><b><font style="vertical-align: inherit;">です。</font></b><font style="vertical-align: inherit;">テストするときは、4：3の比率（まあ、または3：4）のデバイスの存在を忘れないでください。したがって、安全に追加します768x1024（または1024x768）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置の改善</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームオブジェクトの配置とスケールを調整するには、Rect Transformを使用するのが最適です。</font></font><img align="left" width="40%" src="https://habrastorage.org/webt/rm/gk/ao/rmgkao3ttyvdkj3dbs8zmtxrm2o.png"><br>
<br clear="all">
<br clear="all">
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題2-コミュニケーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はGame Maker Studioを介してゲーム開発者と初めて知り合ったという事実のために同様の問題がありました。スクリプトはゲームオブジェクトの本格的な部分であり、すぐにオブジェクトのすべてのコンポーネントに完全にアクセスできます。</font><font style="vertical-align: inherit;">Unityには共通のスクリプトがあり、それらのインスタンスのみがオブジェクトに追加されます。</font><font style="vertical-align: inherit;">単純に比喩的に言えば、スクリプトは現在実行中のオブジェクトを直接知りません。</font><font style="vertical-align: inherit;">したがって、スクリプトを作成するときは、オブジェクトのコンポーネントまたは他のオブジェクトのコンポーネントを操作するためのインターフェースの初期化を考慮する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは猫を訓練します</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のゲームにはGameFieldオブジェクトがあり、ステージにはインスタンスが1つだけあり、同じ名前のスクリプトもあります。オブジェクトはゲームスコアの表示とゲームサウンド全体の再生を担当するので、私の意見ではメモリの方が経済的です（一般に、ゲームにはオーディオソースが3つしかなく、1つのバックグラウンドミュージックと2つの他のサウンドエフェクトがあります）。このスクリプトは、ゲームアカウントの保存、サウンドの再生にAudioClipの選択、および一部のゲームロジックの問題を解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、スクリプトとオブジェクトのコンポーネントとの相互作用を簡単に示すことができるため、サウンドについてさらに詳しく説明します。</font></font><br>
<br>
<img width="40%" align="left" src="https://habrastorage.org/webt/2y/ll/ab/2yllabokihsyqwabiwnod3tiqyc.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然、オブジェクトにはGameField.csスクリプト自体とAudioSourceコンポーネントが必要です。私の場合は2つ全体です（後で理由は明らかになります）。</font></font><br clear="all">
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、スクリプトはオブジェクトにAudioSourceコンポーネントがあることを「認識していない」ため、インターフェースを宣言して初期化します（現時点では、AudioSourceは1つだけであると見なします）。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> AudioSource Sound;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>{<font></font>
	Sound = GetComponent&lt;AudioSource&gt; ();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GetComponentメソッド&lt;component_type&gt;（）は、オブジェクトから指定されたタイプの最初のコンポーネントを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AudioSourceに加えて、いくつかのAudioClipが必要になります。</font></font><br>
<pre><code class="cs hljs">	
[<span class="hljs-meta">Header (<span class="hljs-meta-string">"Audio clips"</span>)</span>]<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> AudioClip OnStart;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> AudioClip OnEfScore;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> AudioClip OnHighScore;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> AudioClip OnMainTimer;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> AudioClip OnBubbMarker;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> AudioClip OnScoreUp;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下、インスペクタ `aの角かっこ内のコマンドが必要</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細については、こちらをご覧</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img width="40%" align="left" src="https://habrastorage.org/webt/wk/t-/k7/wkt-k7spezw5hanfme5xchxexzk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、インスペクタのスクリプトに、必要なサウンドをドラッグする新しいフィールドがあります。</font></font><br>
<br clear="all">
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、AudioClipを取り込むスクリプトでSoundPlayメソッドを作成します。</font></font><br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span>(<span class="hljs-params">AudioClip Clip = <span class="hljs-literal">null</span></span>)</span>{<font></font>
	Sound.clip = Clip;<font></font>
	Sound.Play ();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームでサウンドを再生するには、クリップを使用して適切なタイミングでこのメソッドを呼び出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの重要なマイナス点が1つあります。一度に再生できるサウンドは1つだけですが、ゲーム中には、常にバックグラウンドミュージックを再生することを除いて、2つ以上のサウンドを再生する必要がある場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不協和音を防ぐには、4〜5音を超える同時再生の可能性を回避することをお勧めします（最大2〜3音が望ましい）。つまり、ゲームの短い一次音（ジャンプ、コイン、プレーヤーのショットなど）を意味します。バックグラウンドノイズについては、独自のソースを作成することをお勧めしますこのノイズを発生させるオブジェクト（2d-3dサウンドが必要な場合）またはすべてのバックグラウンドノイズの原因となる1つのオブジェクト（「ボリューム」が不要な場合）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のゲームでは、3つ以上のオーディオクリップを同時に再生する必要はありません。</font><font style="vertical-align: inherit;">両方の仮想サウンドを確実に再生するために、2つのAudioSourceをGameFieldオブジェクトに追加しました。</font><font style="vertical-align: inherit;">スクリプトのコンポーネントを決定するには、メソッドを使用します&nbsp;</font></font><br>
<pre><code class="cs hljs">GetComponents&lt;_&gt;()&nbsp;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトから指定されたタイプのすべてのコンポーネントの配列を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードは次のようになります。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> AudioSource[] Sound; <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>{<font></font>
	Sound = GetComponents&lt;AudioSource&gt; (); <span class="hljs-comment">//  GetComponents</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの変更はPlaySoundメソッドに影響します。</font><font style="vertical-align: inherit;">このメソッドには2つのバージョンがあります。「ユニバーサル」（オブジェクト内の任意の数のAudioSourceの場合）と「不器用」（2〜3のAudioSourceの場合、最もエレガントではありませんが、リソース集中型ではありません）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのAudioSourceの「不器用」オプション（私はそれを使用しました）</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span>(<span class="hljs-params">AudioClip Clip = <span class="hljs-literal">null</span></span>)</span>{
	<span class="hljs-keyword">if</span> (!Sound [<span class="hljs-number">0</span>].isPlaying) {<font></font>
		Sound [<span class="hljs-number">0</span>].clip = Clip;<font></font>
		Sound [<span class="hljs-number">0</span>].Play ();<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		Sound [<span class="hljs-number">1</span>].clip = Clip;<font></font>
		Sound [<span class="hljs-number">1</span>].Play ();<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つ以上のAudioSourceに引き伸ばすことができますが、条件の数が増えると、パフォーマンスのすべての節約になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ユニバーサル」オプション</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span>(<span class="hljs-params">AudioClip Clip = <span class="hljs-literal">null</span></span>)</span>{
	<span class="hljs-keyword">foreach</span> (AudioSource _Sound <span class="hljs-keyword">in</span> Sound) {
		<span class="hljs-keyword">if</span> (!_Sound.isPlaying) {<font></font>
			_Sound.clip = Clip;<font></font>
			_Sound.Play ();<font></font>
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部コンポーネントへの適用</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームチップなど、フィッシュカプレハブのいくつかの例が競技場にあります。</font><font style="vertical-align: inherit;">これは次のように構築されています：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpriteRendererを持つ親オブジェクト。 </font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpriteRendererを持つ子オブジェクト。 </font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子オブジェクトは、チップの本体、その色、追加の変更可能な要素を描画する責任があります。</font><font style="vertical-align: inherit;">親がチップの周りにマーカーの境界線を描画します（ゲームでアクティブなチップを選択する必要があります）。</font><font style="vertical-align: inherit;">スクリプトは親オブジェクトのみにあります。</font><font style="vertical-align: inherit;">したがって、子スプライトを管理するには、親スクリプトでこれらのスプライトを指定する必要があります。</font><font style="vertical-align: inherit;">私はそれを次のように編成しました-スクリプトで、SpriteRendererの子にアクセスするためのインターフェースを作成しました。</font></font><br>
<pre><code class="cs hljs">[<span class="hljs-meta">Header (<span class="hljs-meta-string">"Graphic objects"</span>)</span>]
<span class="hljs-keyword">public</span> SpriteRenderer Marker;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> SpriteRenderer Base;<font></font>
[<span class="hljs-meta">Space</span>]<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> SpriteRenderer Center_Red;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> SpriteRenderer Center_Green;<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> SpriteRenderer Center_Blue;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、インスペクタのスクリプトに追加のフィールドがあります。</font></font><br>
<img src="https://habrastorage.org/webt/mq/w9/kp/mqw9kpst-fen-bkdtgp_8jycpck.png"><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対応するフィールドに子をドラッグアンドドロップすると、スクリプトから子にアクセスできます。</font></font><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用例：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span>{&nbsp; <span class="hljs-comment">//       </span><font></font>
	Marker.enabled = !Marker.enabled;	<font></font>
}<font></font>
</code></pre><br>
<br clear="all">
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部スクリプトへの適用</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
外部コンポーネントの操作に加えて、サードパーティオブジェクトのスクリプトにアクセスして、そのパブリック変数、メソッド、サブクラスを操作することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでによく知られているGameFieldオブジェクトの例を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GameFieldスクリプトには、フィールド上のすべてのチップからマーカーを「削除」するために必要なパブリックメソッドFishkiMarkerDisabled（）があり、アクティブになるのは1つだけなので、チップをクリックしたときにマーカーを設定するプロセスで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fishka.csスクリプトでは、SpriteRenderer Markerはパブリックです。つまり、別のスクリプトからアクセスできます。</font><font style="vertical-align: inherit;">これを行うには、GameField.csスクリプト内のFishkaクラスのすべてのインスタンスのインターフェイスの宣言と初期化を追加します（スクリプトを作成すると、同じ名前のクラスがスクリプト内に作成されます）。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> Fishka[] Fishki;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>{<font></font>
	Fishki = GameObject.FindObjectsOfType (<span class="hljs-keyword">typeof</span>(Fishka)) <span class="hljs-keyword">as</span> Fishka[];<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FishkiMarkerDisabled</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-keyword">foreach</span> (Fishka _Fishka <span class="hljs-keyword">in</span> Fishki) {<font></font>
		_Fishka .Marker.enabled = <span class="hljs-literal">false</span>;<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fishka.csスクリプトで、GameFieldクラスのインスタンスのインターフェイスの宣言と初期化を追加します。オブジェクトをクリックすると、このクラスのFishkiMarkerDisabled（）メソッドが呼び出されます。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> GameField gf;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>{<font></font>
	gf = GameObject.FindObjectOfType (<span class="hljs-keyword">typeof</span>(GameField)) <span class="hljs-keyword">as</span> GameField;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span>{<font></font>
	gf.FishkiMarkerDisabled();<font></font>
	Marker.enabled = !Marker.enabled;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、異なるオブジェクトのスクリプト（またはクラス）間で対話することが可能です。</font></font><br>
<br clear="all">
<br clear="all">
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題3-キーパー</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アカウントキーパーアカウントの</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ようなものがゲームに表示されるとすぐに、差し迫った問題は、ゲーム中とゲーム外の両方でのストレージの問題です。また、プレーヤーにそれを超えるように促すために記録を保持したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲーム全体（メニュー、ゲーム、アカウントの引き出し）が1つのシーンで構築される場合、オプションは考慮しません。これは、最初にこれが最初のプロジェクトを構築する最良の方法ではないこと、そして2番目に、最初の読み込みシーンは。</font><font style="vertical-align: inherit;">したがって、プロジェクトには4つのシーンがあることに同意します。</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローダー-バックグラウンドミュージックオブジェクトが初期化されるシーン（後で詳しく説明します）、および保存から設定をロードします。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メニュー-メニューのあるシーン。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム-ゲームシーン;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スコア-スコア、レコード、リーダーボードのシーン。</font></font><br>
</li>
</ol><br>
<img width="40%" align="right" src="https://habrastorage.org/webt/dy/yl/4t/dyyl4tkmtx6a0ijbnjiy1jgkr9q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：シーンの読み込み順序は、[ファイル]&gt; [ビルド設定]で設定します</font></font></i><br clear="all">
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲーム中に累積されたポイントは、GameFieldクラスのスコア変数に格納されます。</font><font style="vertical-align: inherit;">ステージスコアへの移行中にデータにアクセスできるようにするには、パブリック静的クラスScoreHolderを作成します。これは、この変数の値を取得および設定するための値とプロパティを格納する変数を宣言します（メソッド</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spied</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アポカタタス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ScoreHolder</span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _Score = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Score	{
		<span class="hljs-keyword">get</span>{
			<span class="hljs-keyword">return</span> _Score;<font></font>
		}<font></font>
		<span class="hljs-keyword">set</span>{<font></font>
			_Score = <span class="hljs-keyword">value</span>;<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パブリック静的クラスをオブジェクトに追加する必要はありません。任意のスクリプトのどのシーンでもすぐに使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーン遷移メソッドのスコアでGameFieldクラスを使用する例：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameField</span> : <span class="hljs-title">MonoBehaviour</span> {<font></font>
<font></font>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Score = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-comment">//     ,         Scores</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GotoScores</span>(<span class="hljs-params"></span>)</span>{<font></font>
		ScoreHolder.Score = Score; <span class="hljs-comment">//   ScoreHolder.Score  </span><font></font>
		SceneManager.LoadScene (“scores”);<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、ゲーム中にスコアアカウントにレコードアカウントを追加できますが、終了時に保存されません。</font></font><br>
<br clear="all">
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設定のキーパー</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームにサウンド効果があるかどうかに応じて、ブール変数SoundEffectsMuteの値を保存する例を考えてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数自体は、パブリック静的クラスSettingsHolderに格納されます。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingsHolder</span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> _SoundEffectsMute = <span class="hljs-literal">false</span>;<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> SoundEffectsMute{
		<span class="hljs-keyword">get</span>{
			<span class="hljs-keyword">return</span> _SoundEffectsMute;<font></font>
		}<font></font>
		<span class="hljs-keyword">set</span>{<font></font>
			_SoundEffectsMute = <span class="hljs-keyword">value</span>;<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスはScoreHolderに似ています、それらを1つに結合することもできますが、私の意見ではこれは悪いマナーです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトからわかるように、デフォルトでは_SoundEffectsMuteはfalseと宣言されているため、ゲームが開始するたびに、ユーザーが以前に変更したかどうかに関係なく、SettingsHolder.SoundEffectsMuteはfalseを返します（メニューステージのボタンを使用して変更されます）。</font></font><br>
<br clear="all">
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font><b><font style="vertical-align: inherit;">保存</font></b><font style="vertical-align: inherit;"> Androidアプリケーションの最良のオプションは、PlayerPrefs.SetIntメソッドを使用して保存することです（詳細は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公式ドキュメントを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">）。 PlayerPrefsでSettingsHolder.SoundEffectsMuteの値を維持するための2つのオプションがあります。それらを「シンプル」および「エレガント」と呼びましょう。</font></font><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「簡単な」方法（私にとってはそのように）は、前述のボタンのクラスのOnMouseDown（）メソッドにあります。</font><font style="vertical-align: inherit;">保存された値は、同じクラスのStart（）メソッドに読み込まれます。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ButtonSoundMute</span> : <span class="hljs-title">MonoBehaviour</span> {<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-comment">//    ,  PlayerPrefs    bool</span>
		<span class="hljs-keyword">switch</span> (PlayerPrefs.GetInt (<span class="hljs-string">"SoundEffectsMute"</span>)) { 
		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
			SettingsHolder.SoundEffectsMute = <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
			SettingsHolder.SoundEffectsMute = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">default</span>: <span class="hljs-comment">//    default</span>
			SettingsHolder.SoundEffectsMute = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span>{<font></font>
		SettingsHolder.SoundEffectsMute = !SettingsHolder.SoundEffectsMute;<font></font>
<font></font>
<span class="hljs-comment">//    ,  PlayerPrefs    bool</span>
		<span class="hljs-keyword">if</span> (SettingsHolder.SoundEffectsMute)<font></font>
			PlayerPrefs.SetInt (<span class="hljs-string">"SoundEffectsMute"</span>, <span class="hljs-number">1</span>);
		<span class="hljs-keyword">else</span>
			PlayerPrefs.SetInt (<span class="hljs-string">"SoundEffectsMute"</span>, <span class="hljs-number">0</span>);<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、「エレガントな」方法は最も正確ではありません。</font><font style="vertical-align: inherit;">コードのメンテナンスは複雑ですが、コードに何かがあり、私はそれを共有せざるを得ません。</font><font style="vertical-align: inherit;">このメソッドの機能は、SettingsHolder.SoundEffectsMuteプロパティのセッターが、高いパフォーマンスを必要としない瞬間に呼び出され、PlayerPrefs（読み取り-ファイルへの書き込み）を使用して（oh、horror）ロードできることです。</font><font style="vertical-align: inherit;">パブリック静的クラスSettingsHolderを変更します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingsHolder</span><font></font>
{<font></font>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> _SoundEffectsMute = <span class="hljs-literal">false</span>;<font></font>
<font></font>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> SoundEffectsMute{
		<span class="hljs-keyword">get</span>{
			<span class="hljs-keyword">return</span> _SoundEffectsMute;<font></font>
		}<font></font>
		<span class="hljs-keyword">set</span>{<font></font>
			_SoundEffectsMute = <span class="hljs-keyword">value</span>;
		<span class="hljs-keyword">if</span> (_SoundEffectsMute)<font></font>
			PlayerPrefs.SetInt (<span class="hljs-string">"SoundEffectsMute"</span>, <span class="hljs-number">1</span>);
		<span class="hljs-keyword">else</span>
			PlayerPrefs.SetInt (<span class="hljs-string">"SoundEffectsMute"</span>, <span class="hljs-number">0</span>);<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ButtonSoundMuteクラスのOnMouseDownメソッドは、次のように単純化されます。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span>{<font></font>
	SettingsHolder.SoundEffectsMute = !SettingsHolder.SoundEffectsMute;<font></font>
}<font></font>
</code></pre><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GameFieldクラスのPlaySound（）メソッドでパフォーマンスが重要なプロセスに関与しているため、ファイルからの読み取りでゲッターをロードする価値はありません。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span>(<span class="hljs-params">AudioClip Clip = <span class="hljs-literal">null</span></span>)</span>{
	<span class="hljs-keyword">if</span> (!SettingsHolder.SoundEffectsMute) {
	<span class="hljs-comment">//      “”  (. )</span>
		<span class="hljs-keyword">if</span> (!Sound [<span class="hljs-number">0</span>].isPlaying) {<font></font>
			Sound [<span class="hljs-number">0</span>].clip = Clip;<font></font>
			Sound [<span class="hljs-number">0</span>].Play ();<font></font>
		} <span class="hljs-keyword">else</span> {<font></font>
			Sound [<span class="hljs-number">1</span>].clip = Clip;<font></font>
			Sound [<span class="hljs-number">1</span>].Play ();<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の方法で、変数のゲーム内ストレージを整理できます。</font></font><br>
<br clear="all">
<br clear="all">
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5の問題-すべてに1つ</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この音楽は永遠であり、</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
遅かれ早かれ誰もがそのような問題に直面し、私も例外ではありませんでした。</font><font style="vertical-align: inherit;">計画通り、バックグラウンドミュージックはメニューシーンで再生を開始し、オフにしないと、メニュー、ゲーム、スコアを中断することなくシーンで再生します。</font><font style="vertical-align: inherit;">ただし、メニューシーンに「再生中」のバックグラウンドミュージックがインストールされている場合、ゲームシーンに移動するとオブジェクトが破壊されてサウンドが消えます。同じオブジェクトをゲームシーンに配置すると、トランジションの後、最初に音楽が再生されます。</font><font style="vertical-align: inherit;">解決策は、音楽オブジェクトが持つスクリプトインスタンスを持つクラスのStart（）メソッドに配置されたDontDestroyOnLoad（オブジェクトターゲット）メソッドを使用することでした。</font><font style="vertical-align: inherit;">これを行うには、DontDestroyThis.csスクリプトを作成します。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DontDestroyThis</span>: <span class="hljs-title">MonoBehaviour</span> {
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>{<font></font>
		DontDestroyOnLoad(<span class="hljs-keyword">this</span>.gameObject);<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<img width="40%" align="left" src="https://habrastorage.org/webt/ee/cj/hn/eecjhn5uyzoclq7ywnqztl1untu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが機能するためには、「音楽」オブジェクトがルート（メインカメラと同じ階層レベル）である必要があります。</font></font><br clear="all">
<br clear="all">
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローダーでバックグラウンドミュージックを使用する理由</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
スクリーンショットは、「musical」オブジェクトがメニューシーンではなくローダーシーンにあることを示しています。これは、メニューシーンを複数回ロードできる（スコアシーンの後、メニューシーンへの遷移）ことが原因で発生し、ロードされるたびに別の「音楽」オブジェクトが作成され、古いオブジェクトは削除されません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公式ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の例のように行うことができます</font><font style="vertical-align: inherit;">が、ローダーシーンは1度だけロードされることが保証されているという事実を利用することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Unityで最初のゲームを開発するときに、Playマーケットにアップロードする前に（開発者アカウントをまだ登録していません）遭遇した主要な問題は、正常に終了しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS </font></font></b><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報が役に立った場合、作成者をサポートできます。彼は最終的にAndroid開発者アカウントを登録します。</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458904/index.html">Rのアニメーション化された棒グラフを使用したNBAチームの勝利数の視覚化</a></li>
<li><a href="../ja458906/index.html">[エカテリンブルク、発表] Flutteron-Flutterの開発に関するワークショップ</a></li>
<li><a href="../ja458908/index.html">ネットワーク経由でドキュメントをスキャンする</a></li>
<li><a href="../ja458910/index.html">大きなLinuxページでのPostgreSQLのベンチマーク</a></li>
<li><a href="../ja458912/index.html">imapsyncを使用してZimbraに移行する</a></li>
<li><a href="../ja458916/index.html">Reactの内部で。実装を一から作成する</a></li>
<li><a href="../ja458918/index.html">ハイパーカジュアルゲームのデザインから学べること</a></li>
<li><a href="../ja458920/index.html">DevOpsファンのための会議</a></li>
<li><a href="../ja458922/index.html">ESXiからKVM / LXDに移行し、気を失うことのないようにする方法</a></li>
<li><a href="../ja458924/index.html">事故はあなたが学ぶのに役立ちます</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>