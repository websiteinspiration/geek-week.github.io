<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍷 🎯 👩🏼‍🤝‍👨🏿 [パート2/2] FFmpegとSDLのガイド、または1000行未満でビデオプレーヤーを作成する方法 🚛 🤞🏾 👵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このマニュアルの残りのロシア語翻訳は、少し古くなっていますが、妥当性は失われていません。FFmpegおよびSDLライブラリを使用してビデオアプリケーションを作成する「キッチン」を理解するのに役立つためです。
 
 そして、試みましたが、そのような膨大なテキストでは翻訳の難しさが避けられません。バグを...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[パート2/2] FFmpegとSDLのガイド、または1000行未満でビデオプレーヤーを作成する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/502844/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/yx/qh/nq/yxqhnqwvdlvzfw22erhmpfzpfba.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このマニュアルの残りのロシア語翻訳は、少し古くなっていますが、妥当性は失われていません。FFmpegおよびSDLライブラリを使用してビデオアプリケーションを作成する「キッチン」を理解するのに役立つためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、試みましたが、そのような膨大なテキストで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は翻訳の難しさが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避けられません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バグを報告する（できればプライベートメッセージで）-一緒に改善しましょう。</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序文</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン1：スクリーンキャップの作成</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン2：レッスンの表示</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3：サウンドの再生</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン4：マルチスレッド</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン5：ビデオの同期</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン6：オーディオの同期</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン7：</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あとがきの</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">検索</font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録1.関数のリスト</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録2.データ構造</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><br>
<a name="audio"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="EDISONソフトウェア-ウェブ開発"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISONソフトウェア-ウェブ開発"></a><br clear="right">
     EDISON.<br>
<br>
    ,      .<br>
<br>
,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   Axxon Next  SureView Immix</a>.<br>
<br>
      ! ;-)</blockquote><br>
<h2> 6:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン5：ビデオ同期">←</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン7：検索">→</a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">  tutorial06.c</b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
映画を見ることができる多かれ少なかれきちんとしたプレーヤーができたので、今度は収益を上げましょう。</font><font style="vertical-align: inherit;">前回は、同期、つまり音声とビデオの同期をこの順序で少し触れましたが、その逆ではありません。</font><font style="vertical-align: inherit;">これをビデオと同じレイアウトにします。内部ビデオクロックを作成して、ビデオストリームの距離を追跡し、オーディオと同期させます。</font><font style="vertical-align: inherit;">後でさらに一般化します-オーディオとビデオを外部クロックと同期させます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオクロックの実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、前回持っていたオーディオクロックに似たビデオクロックを作成します。現在再生中のビデオの現在の時間オフセットを返す内部値です。</font><font style="vertical-align: inherit;">表示される最後のフレームの</font><font style="vertical-align: inherit;">現在の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTSで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイマーを更新するのと同じくらい簡単だと思うかもしれません</font><font style="vertical-align: inherit;">。ただし、ミリ秒レベルに落とすと、ビデオフレーム間の時間が長すぎる可能性があることを忘れないでください。したがって、解決策は別の値、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後のフレームの</font><b><font style="vertical-align: inherit;">PTSで</font></b><font style="vertical-align: inherit;">ビデオクロックを設定した時間を追跡することです</font><font style="vertical-align: inherit;">。したがって、ビデオ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロックの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の値は、</font><b><font style="vertical-align: inherit;">PTS_of_last_frame</font></b><font style="vertical-align: inherit;"> +（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_elapsed_since_PTS_value_was_set</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">このソリューションは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clockで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行ったものと非常によく似てい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、本格的な構造では、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double video_current_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t video_current_pts_timeを配置し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">クロックは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_refresh_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数で更新されます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* ... */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_openで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
初期化することを忘れないでください</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今必要なのは、情報を取得する方法です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時計から抽象化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、なぜビデオクロックを使用する必要があるのでしょうか。</font><font style="vertical-align: inherit;">さらに進んで、オーディオとビデオが互いに同期しようとしないようにビデオ同期コードを変更できます。</font><font style="vertical-align: inherit;">FFplayのように、コマンドラインオプションでこれを行おうとすると、どうなるか想像してみてください。</font><font style="vertical-align: inherit;">したがって、抽象化してみましょう。</font><font style="vertical-align: inherit;">変数</font><b><font style="vertical-align: inherit;">av_sync_type</font></b><font style="vertical-align: inherit;">をチェックしてから</font><b><font style="vertical-align: inherit;">get_audio_clock</font></b><font style="vertical-align: inherit;">、</font><b><font style="vertical-align: inherit;">get_video_clock、</font></b><font style="vertical-align: inherit;">またはそれを使用できる他のクロックを</font><font style="vertical-align: inherit;">呼び出す</font><font style="vertical-align: inherit;">新しいラッパー関数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_master_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成します</font><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">get_external_clock</font></b><font style="vertical-align: inherit;">と呼ばれるコンピュータークロックを使用することもできます</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
main() {<font></font>
...<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオ同期</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで最も難しい部分は、オーディオとビデオクロックの同期です。私たちの戦略は、オーディオがどこにあるかを測定し、それをビデオクロックと比較して、調整する必要のあるサンプルの数を見つけることです。</font><font style="vertical-align: inherit;">このセットを適切に削減または増加するために、取得したオーディオサンプルの各セットを処理</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する</font><font style="vertical-align: inherit;">たびに</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を実行</font><font style="vertical-align: inherit;">します。ただし、オーディオ処理はビデオパケットの処理よりもはるかに頻繁に発生するため、常に同期する必要はありません。そのため、</font><b><font style="vertical-align: inherit;">synchronize_audio</font></b><font style="vertical-align: inherit;">関数の連続呼び出しの最小数を設定します</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何もする前に、非同期と見なされます。もちろん、前回と同様に、「非同期」とは、オーディオクロックとビデオクロックが同期しきい値よりも大きく異なることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、分数係数、たとえば</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し、</font><font style="vertical-align: inherit;">今、</font><b><font style="vertical-align: inherit;">N</font></b><font style="vertical-align: inherit;">を得たとしましょう</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期していないオーディオサンプルのセット。同期しないサンプルの数も大きく異なる可能性があるため、それぞれが同期していないサンプルの平均値を使用します。たとえば、最初の呼び出しは、40ミリ秒同期されていないことを示し、次の呼び出しは50ミリ秒同期されていないことを示します。ただし、最新の値がそれらの前に来る値よりも重要であるため、単純な手段を取るつもりはありません。したがって、分数係数、たとえば</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、</font><font style="vertical-align: inherit;">次のように違いを要約します：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。平均差を見つける準備ができたら、単純に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avg_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =を</font><font style="vertical-align: inherit;">計算し</font><b><font style="vertical-align: inherit;">ます。</font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *（1- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何が起こっているのですか？</font><font style="vertical-align: inherit;">方程式はある種の魔法のように見えます。</font><font style="vertical-align: inherit;">まあ、これは基本的には、幾何系列を重みとして使用した加重平均です。</font><font style="vertical-align: inherit;">これに名前があるかどうかはわかりませんが（Wikipediaでも確認しました！）、詳細については、ここで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（またはここ：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weightedmean.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
  <font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size, nb_samples;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);<font></font>
<font></font>
       <span class="hljs-comment">/* Shrinking/expanding buffer code.... */</span><font></font>
<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべてがうまくいきます。</font><font style="vertical-align: inherit;">サウンドがビデオや時計として使用しているものとどの程度一致していないか、おおよそわかっています。</font><font style="vertical-align: inherit;">それでは、このコードを「バッファコードの削減/拡張」セクションに配置して、追加または破棄する必要があるサンプルの数を計算しましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
  wanted_size = samples_size + <font></font>
  ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_st-&gt;codec-&gt;sample_rate) * n);<font></font>
  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX)<font></font>
                             / <span class="hljs-number">100</span>);<font></font>
  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) <font></font>
                             / <span class="hljs-number">100</span>);
  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
    wanted_size = min_size;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
    wanted_size = max_size;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを忘れないでください</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_lengthを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *＃</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネルの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 2）のサンプル数である</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_lengthの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオの秒。</font><font style="vertical-align: inherit;">したがって、必要なサンプルの数は、既に持っているサンプルの数に、サウンドが再生された時間に対応するサンプルの数をプラスまたはマイナスした数と等しくなります。</font><font style="vertical-align: inherit;">また、修正の大きさの制限も設定します。バッファを変更しすぎると、ユーザーにとって煩わしすぎるからです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプル数の修正</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、サウンドを修正する必要があります。</font><font style="vertical-align: inherit;">皆さんは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">がサンプルサイズを返し、ストリームに送信するバイト数を通知</font><font style="vertical-align: inherit;">することに気付いたかもしれません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、サンプルサイズを目的の値に調整するだけです。</font><font style="vertical-align: inherit;">これにより、サンプルサイズが小さくなります。</font><font style="vertical-align: inherit;">ただし、バッファを増やす必要がある場合は、バッファにデータがないため、サンプルサイズを増やすことはできません。</font><font style="vertical-align: inherit;">したがって、少し追加する必要があります。</font><font style="vertical-align: inherit;">しかし、正確には何を追加するのでしょうか？</font><font style="vertical-align: inherit;">オーディオを外挿しようとするのはばかげているので、すでに持っているオーディオを使用して、最後のサンプルの値をバッファーに追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
  <span class="hljs-comment">/* remove samples */</span><font></font>
  samples_size = wanted_size;<font></font>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
  <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
  <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
  <span class="hljs-comment">/* add samples by copying final samples */</span><font></font>
  nb = (samples_size - wanted_size);<font></font>
  samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
  q = samples_end + n;<font></font>
  <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
    q += n;<font></font>
    nb -= n;<font></font>
  }<font></font>
  samples_size = wanted_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでサンプルサイズが返され、この関数は終了です。</font><font style="vertical-align: inherit;">これから行う必要があるのは、これを使用することだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行したのは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しを挿入することだけ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">（また、ソースコードを確認してください。ここでは、私が定義しなかった変数を初期化しています。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、終了する前に、「if」条件を追加して、ビデオがメインクロックの場合にビデオを同期しないようにする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
  ref_clock = get_master_clock(is);<font></font>
  diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
  <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
     FFPlay still doesn't "know if this is the best guess." */</span><font></font>
  sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay :<font></font>
                    AV_SYNC_THRESHOLD;<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
    <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
      delay = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
      delay = <span class="hljs-number">2</span> * delay;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれはうまくいきます！</font><font style="vertical-align: inherit;">ソースファイルをチェックして、私が定義したり初期化したりしなかった変数を初期化してください。</font><font style="vertical-align: inherit;">次にコンパイルします。</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial06 tutorial06.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして飛行は正常です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のレッスンでは巻き戻します。</font></font><a name="seeking"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン7：検索</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン6：オーディオ同期"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="あとがき"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリストtutorial07.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;
  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
AVPacket flush_pkt;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_ctx);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;seek_req) {
      <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
	seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
				  pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
		       seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
		is-&gt;pFormatCtx-&gt;filename);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;audioq);<font></font>
	  packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;videoq);<font></font>
	  packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
	}<font></font>
      }<font></font>
      is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;
      <span class="hljs-comment">/*
       * If the video has finished playing, then both the picture and
       * audio queues are waiting for more data.  Make them stop
       * waiting and terminate normally.
       */</span><font></font>
      SDL_CondSignal(is-&gt;audioq.cond);<font></font>
      SDL_CondSignal(is-&gt;videoq.cond);<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索コマンド処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、プレーヤーに検索機能をいくつか追加します。これは、ムービーを巻き戻せない場合に非常に煩わしいためです。さらに、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用するのがいかに簡単かがわかります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードの矢印を「左」および「右」にして、フィルムを少し前後にスクロールさせます。「上」および「下」の矢印はすでにより重要です。 「少し」-10秒、「たくさん」-すべて60です。したがって、キーストロークイベントをインターセプトするようにメインループを構成する必要があります。しかし、実際には、キーストロークを取得したときに、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frameを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接</font><font style="vertical-align: inherit;">呼び出すことはできません</font><font style="vertical-align: inherit;">。これは、メインのデコードループである</font><b><font style="vertical-align: inherit;">decode_thread</font></b><font style="vertical-align: inherit;">ループで行う必要があります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、代わりに、いくつかの値をメイン構造に追加します。これには、検索の新しい位置といくつかの検索フラグが含まれます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、キーストロークをキャッチするメインループを構成する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, <font></font>
                      (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーストロークをキャッチするには、まず</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_KEYDOWN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント</font><b><font style="vertical-align: inherit;">が発生</font></b><font style="vertical-align: inherit;">したかどうかを調べます</font><font style="vertical-align: inherit;">。次に、</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.key.keysym.sym</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、受信したキーを確認します</font><font style="vertical-align: inherit;">。探している方向がわかるとすぐに、新しい時間を計算し、新しい</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_master_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の値に増分を追加します</font><font style="vertical-align: inherit;">。次に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seek_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">など</font><font style="vertical-align: inherit;">を設定します</font><font style="vertical-align: inherit;">。新しい時間を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部タイムスタンプ</font><b><font style="vertical-align: inherit;">単位に</font></b><font style="vertical-align: inherit;">変換します</font><font style="vertical-align: inherit;">。ストリームのタイムスタンプは、次の式を使用して秒単位ではなくフレーム単位で測定されることを思い出してください。</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秒</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトでは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodecは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,000,000フレーム/秒に設定されてい</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">（したがって、2秒の位置には2,000,000のタイムスタンプ</font><b><font style="vertical-align: inherit;">が</font></b><font style="vertical-align: inherit;">設定され</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">）。なぜこの値を変換する必要があるのですか-後で参照してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">です。戻る場合はフラグを設定することに注意してください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font><font style="vertical-align: inherit;">実際に検索を実行する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_threadに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移りましょう</font><font style="vertical-align: inherit;">。ソースファイルで、「検索が進行中」の領域をマークしたことがわかります。さて、今そこに配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検索は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を中心に</font><b><font style="vertical-align: inherit;">行われ</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。この関数は、フォーマットコンテキスト、ストリーム、タイムスタンプ、およびフラグセットを引数として受け取ります。関数は、指定したタイムスタンプを探します。タイムスタンプの単位は</font><font style="vertical-align: inherit;">、関数に渡すストリーム</font><font style="vertical-align: inherit;">の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_baseです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、それをストリームに渡す必要はありません（値-1を渡すことで示されます）。これを行うと、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><b><font style="vertical-align: inherit;">avcodec</font></b><font style="vertical-align: inherit;">内部時間</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単位になります。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または1000000fps。これが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seek_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を設定するときに</font><font style="vertical-align: inherit;">位置に</font><b><font style="vertical-align: inherit;">AV_TIME_BASE</font></b><font style="vertical-align: inherit;">を掛けた理由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、</font><font style="vertical-align: inherit;">ストリームに</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡すと、一部のファイルで（まれに）問題が発生する場合があるため、ファイル</font><font style="vertical-align: inherit;">の最初のストリームを選択して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frameに渡し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。新しい「座標系」にするためには、タイムスタンプのスケールを変更する必要があることを忘れないでください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;seek_req) {
  <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
    seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
                      pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
                    seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
            is-&gt;pFormatCtx-&gt;filename);<font></font>
  } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">/* handle packet queues... more later... */</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_rescale_q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、タイムスタンプをあるベースから別のベースにスケーリングする関数です。基本的には</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cを</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算</font><nobr><b><font style="vertical-align: inherit;">し</font></b></nobr><font style="vertical-align: inherit;">ますが、この計算はオーバーフローを引き起こすことがあるので、この関数は便利です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Qは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の端数バージョンです</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらは完全に異なります：</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ただし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は実際には</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">であるため、それ</font><font style="vertical-align: inherit;">を処理するに</font><font style="vertical-align: inherit;">は</font><b><font style="vertical-align: inherit;">avcodecで</font></b><font style="vertical-align: inherit;">特別な</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用する必要があります</font><font style="vertical-align: inherit;">）。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファー洗浄</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、検索を正しく設定しましたが、まだ完了していません。パケットを蓄積するように構成されたキューがあることを覚えておいてください。別のタイムスタンプにいるので、このキューをクリアする必要があります。そうしないと、映画の検索が機能しません。さらに、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodecに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は独自の内部バッファーがあり、ストリームごとにフラッシュする必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、まず、パケットキューをクリアする関数を記述する必要があります。次に、オーディオとビデオのストリームに、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodecの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部バッファをクリアしたことを何らかの形で伝える必要があります</font><font style="vertical-align: inherit;">。クリーンアップした後、キューに特別なパケットを置くことでこれを行うことができ、彼ら（スレッド）がこの特別なパケットを発見したとき、彼らは単にバッファをクリアします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リセット機能から始めましょう。</font><font style="vertical-align: inherit;">それは本当に非常に単純なので、私はあなたにコードを示すだけです：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューがクリアされたので、「クレンジングパケット」を追加します。</font><font style="vertical-align: inherit;">しかし、最初に、それを定義して作成するとよいでしょう。</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket flush_pkt;<font></font>
<font></font>
main() {<font></font>
  ...<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このパッケージをキューに入れます。</font></font><br>
<br>
<pre><code class="cpp hljs">  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;audioq);<font></font>
      packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;videoq);<font></font>
      packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
    }<font></font>
  }<font></font>
  is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（このコードスニペットは、上記の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_threadの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードスニペットの</font><b><font style="vertical-align: inherit;">続き</font></b><font style="vertical-align: inherit;">です。）</font><font style="vertical-align: inherit;">クリーニングのための特別なパッケージを複製しないように、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も変更する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、オーディオとビデオのストリームに、私たちはには、このコールを入れ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_flush_buffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直後</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_st-&gt;codec);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードスニペットはビデオストリームとまったく同じですが、「オーディオ」が「ビデオ」に置き換えられています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これだよ！</font><font style="vertical-align: inherit;">やりました！</font><font style="vertical-align: inherit;">プレーヤーをコンパイルします。</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial07 tutorial07.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1000行未満のCで作成されたムービープレーヤーをお楽しみください！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、追加または改善できることはたくさんあります。</font></font><a name="epilogue"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あとがき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン7：検索"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="付録1.関数のリスト"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ですから、動作するプレーヤーを取得しましたが、もちろんそれは可能な限り良くはありません。</font><font style="vertical-align: inherit;">ファイルを変更し、多くの便利なものを追加することが可能です：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それに直面しよう、このプレーヤーは嫌だ。</font><font style="vertical-align: inherit;">基になっているffplay.cのバージョンは完全に古くなっているため、このチュートリアルは完全に改訂する必要があります。</font><font style="vertical-align: inherit;">FFmpegライブラリを使用してより深刻なプロジェクトに行きたい場合は、次のタスクとしてffplay.cの最新バージョンを確認することを強くお勧めします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのコードのエラー処理はひどいもので、はるかによく実装できます。</font></font></li>
<li>      ,  ,   ,     .   ,    <b>paused</b>    ,   ,    .   ,    ,      .     <b>av_read_play</b>.   -   ,     .  ,    ,       . : ,     ffplay.c.</li>
<li> .</li>
<li> .       ,    ,      ,    ,   <b>VOB-</b>.</li>
<li> .   ,        .</li>
<li> .       .</li>
<li>  ,   ,  ,      ,   <b>YUV</b>,             <b>time_base</b>.</li>
<li> .</li>
<li>--,    ;  ffplay.c      .</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFmpegについて詳しく知りたい場合は、ここではすべてから遠くを検討しました。次のステップは、マルチメディアコーディングの研究です。</font><font style="vertical-align: inherit;">FFmpegディストリビューションにある</font><font style="vertical-align: inherit;">ファイル</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">output_example.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始めるのが最善</font><font style="vertical-align: inherit;">です。このトピックについて別の教科書を書くこともできますが、このガイドを超えることはありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ずっと前に私はこのテキストを更新しませんでしたが、その間世界は静止していません。このチュートリアルでは、単純なAPI更新のみが必要です。基本的な概念に関してはほとんど変更されていません。これらの更新のほとんどは、実際にコードを簡略化しています。ただし、コード全体を調べて更新しましたが、FFplayはこのおもちゃのプレーヤーよりも優れています。これらのレッスンでは、かなりお粗末な映画プレーヤーを作成しました。したがって、今日（または将来）このチュートリアルを改善したい場合は、FFplayをよく理解し、不足しているものを見つけることをお勧めします。これは主にビデオ機器の使用に関係していると思いますが、おそらく他の明らかなものをいくつか見逃しています。おそらく、現在のFFplayと比較すると、いくつかの根本的な書き直しが必要になるでしょう-私はまだそれを見ていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、人々が他の場所でコードを頻繁に検索するという事実を考慮に入れても、長年にわたって私の仕事が多くのことを助けてくれたことを非常に誇りに思っています。</font><font style="vertical-align: inherit;">私が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェリャエフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">非常に感謝しています。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">チェリャエフは</font></a><font style="vertical-align: inherit;">、このモノグラフを8（！）年前に書いて以来、古くなっているすべての機能を置き換えるルーチンを自分で引き受けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのレッスンが有用で退屈ではないことが判明したことを願って喜んでいます。</font><font style="vertical-align: inherit;">このガイドに関して提案、エラー、苦情、感謝などがある場合は、dranger dog gmail dot comまでご連絡ください。</font><font style="vertical-align: inherit;">そして、はい、あなたのFFmpegプロジェクトの支援を私に依頼するのは意味がありません。</font><font style="vertical-align: inherit;">類似した文字が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多すぎ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><a name="functions"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録1.機能一覧</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="あとがき"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="付録2.データ構造"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avformat_open_input</span><span class="hljs-params">(AVFormatContext **ptr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, AVInputFormat *fmt, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メディアファイルの名前を開き、フォーマットコンテキストを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptrで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定されたアドレスに保存します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：NULLでない場合、ファイル形式を設定します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：バッファサイズ（オプション）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">options</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：AVDictionaryには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびデマルチプレ</font><b><font style="vertical-align: inherit;">クサー</font></b><font style="vertical-align: inherit;">のパラメーターが設定されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avformat_close_input</span><span class="hljs-params">(AVFormatContext **s)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メディアファイルを閉じます。</font><font style="vertical-align: inherit;">ただし、コーデックは閉じません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">nt <span class="hljs-title">avio_open2</span> <span class="hljs-params">(AVIOContext **s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *url, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URLで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
指定されたリソースを使用するためのI / Oコンテキストを作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が作成される場所へのポインタ</font><font style="vertical-align: inherit;">。失敗した場合、指定された値はNULLに設定されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">url</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：アクセスするリソースの名前。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URLで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定されたリソースの開始を制御します</font><font style="vertical-align: inherit;">。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int_cb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プロトコルレベルの使用のための割り込みコールバック。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">options</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プライベートプロトコルパラメータが入力された辞書。関数が戻ると、パラメーターは破棄され、見つからなかったオプションを含む辞書に置き換えられます。 NULLの場合があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_dup_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これはハックです。このパッケージが割り当てられていない場合は、ここに投稿します。</font><font style="vertical-align: inherit;">成功した場合は0を返し、失敗した場合はAVERROR_NOMEMを返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_find_stream_info</span><span class="hljs-params">(AVFormatContext *s, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、フレームレートなどの明白でないストリーム情報を検索します。</font><font style="vertical-align: inherit;">これは、MPEGなどのヘッダーのないファイル形式に役立ちます。</font><font style="vertical-align: inherit;">ファイルを開いた後に呼び出すことをお勧めします。</font><font style="vertical-align: inherit;">戻り値&gt; =成功した場合は0、エラーの場合はAVERROR_ *。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_free_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
av_frame_freeの古い名前。</font><font style="vertical-align: inherit;">lavc 55.28.1で変更されました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_frame_free</span> <span class="hljs-params">(AVFrame **frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームとその中に動的に割り当てられたオブジェクト（extended_dataなど）を解放します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
av_malloc（）またはav_realloc（）を使用して割り当てられたメモリを解放します。</font><font style="vertical-align: inherit;">この関数は、ptr == NULLで呼び出すことができます。</font><font style="vertical-align: inherit;">代わりにav_freep（）を呼び出すことをお勧めします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_freep</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリを解放し、ポインタをNULLに設定します。</font><font style="vertical-align: inherit;">内部でav_free（）を使用します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージ破棄メソッドを包み込みます（pkt-&gt; destruct）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_gettime</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の時刻をマイクロ秒単位で取得します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_init_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションのパッケージフィールドを初期化しています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_malloc</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのメモリアクセス（CPUで利用可能な場合はベクトルを含む）に適した配置を持つメモリ割り当てバイトサイズ。</font><font style="vertical-align: inherit;">av_malloc（0）はゼロ以外のポインタを返す必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_mallocz</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
av_malloc（）と同じですが、メモリをゼロに初期化します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">av_q2d</span><span class="hljs-params">(AVRational a)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVRationalを2倍にします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_read_frame</span><span class="hljs-params">(AVFormatContext *s, AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のストリームフレームを返します。情報はパッケージとしてpktに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返されたパッケージは、次のav_read_frame（）またはav_close_input_file（）まで有効であり、av_free_packetを使用して解放する必要があります。ビデオパッケージの場合、正確に1つのフレームが含まれます。オーディオの場合、各フレームのサイズが既知の固定サイズ（PCMまたはADPCMデータなど）の場合、整数のフレームが含まれます。オーディオフレームのサイズが可変の場合（たとえば、MPEGオーディオ）、1つのフレームが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pkt-&gt; pts、pkt-&gt; dts、およびpkt-&gt; durationは、常にAVStream.timebaseの単位で正しい値に設定されます（そして、フォーマットがそれらを提供できないことが想定されています）。ビデオ形式にBフレームがある場合、pkt-&gt; ptsはAV_NOPTS_VALUEになる可能性があるため、ペイロードをアンパックしない場合は、pkt-&gt; dtsを使用することをお勧めします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返される結果：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべて正常である場合は0、エラーまたはファイルの終わりがある場合は&lt;0。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_register_all</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリにすべてのコーデックを登録します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_rescale_q</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> a, AVRational bq, AVRational cq)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
戻り値</font><font style="vertical-align: inherit;">* </font><b><font style="vertical-align: inherit;">BQ</font></b><font style="vertical-align: inherit;"> / </font><b><font style="vertical-align: inherit;">CQ</font></b><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_seek_frame</span><span class="hljs-params">(AVFormatContext *s, <span class="hljs-keyword">int</span> stream_index, <span class="hljs-keyword">int64_t</span> timestamp, <span class="hljs-keyword">int</span> flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイムスタンプでキーフレームを検索します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：stream_indexが-1の場合、デフォルトのストリームが選択され、タイムスタンプがAV_TIME_BASEユニットからストリーム固有のtime_baseに自動的に変換されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：AVStream.time_baseの単位で測定された</font><b><font style="vertical-align: inherit;">タイムスタンプ</font></b><font style="vertical-align: inherit;">。ストリームが指定されていない場合は、AV_TIME_BASEの単位で測定されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：方向と検索モードに関するパラメータを設定します：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_ANY：キーフレームだけでなく、任意のフレームで検索します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BACKWARD：逆方向に検索します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BYTE：バイト単位の位置に基づいて検索します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_alloc_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
av_frame_allocの古い名前。</font><font style="vertical-align: inherit;">lavc 55.28.1で変更されました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">av_frame_alloc</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVFrameを選択して初期化します。</font><font style="vertical-align: inherit;">av_frame_free（）を使用して解放できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_audio4</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *frame, <span class="hljs-keyword">int</span> *got_frame_ptr, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオフレームをavpktからフレームにデコードします。 avcodec_decode_audio4（）関数は、AVPacketからオーディオファイルをデコードします。デコードには、avcodec_open2（）を使用してavctxに関連付けられたオーディオコーデックが使用されます。結果のデコードされたフレームは、指定されたAVFrameに格納されます。フレームがアンパックされると、got_frame_ptrが1に設定されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の最適化されたビットストリームリーダーは一度に32ビットまたは64ビットを読み取り、最大で読み取りが可能なため</font><b><font style="vertical-align: inherit;">、</font></b><font style="vertical-align: inherit;">入力バッファーavpkt-&gt;終わり。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：コーデックコンテキスト。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ターゲットフレーム。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">got_frame_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ターゲットint。フレームがアンパックされた場合に設定されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPKT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーディオを含むAVPacket。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返される結果：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーが返された場合は負の値が返され、それ以外の場合は入力AVPacketから使用されたバイト数が返されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_video2</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *picture, <span class="hljs-keyword">int</span> *frameFinished, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオフレームをbufから画像にデコードします。 avcodec_decode_video2（）関数は、サイズbuf_sizeの入力バッファーからビデオフレームをデコードします。デコードには、avcodec_open2（）を使用してavctxに関連付けられたビデオコーデックが使用されます。結果のデコードされたフレームは、画像に保存されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avcodec_decode_audio4に当てはまる位置合わせの例とバッファの問題は、この関数にも当てはまります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：コーデックコンテキスト。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：デコードされたビデオが保存されるAVFrame。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：解凍できるフレームがない場合はゼロ、それ以外の場合はゼロではありません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：入力バッファを含む入力AVPacket。</font><font style="vertical-align: inherit;">このようなパッケージはav_init_packet（）を使用して作成できます。次に、データとサイズを指定すると、一部のデコーダーはフラグやAV_PKT_FLAG_KEYなどの他のフィールドをさらに必要とする場合があります。</font><font style="vertical-align: inherit;">すべてのデコーダーは、できるだけ少ないフィールドを使用するように設計されています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返される結果：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーの場合は負の値が返されます。それ以外の場合はバイト数が使用され、フレームを圧縮解除できない場合はゼロが返されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_frame_get_best_effort_timestamp</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVFrame *frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVFrameオブジェクトからbest_effort_timestampを取得するための単純なアクセスメソッド。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodec *<span class="hljs-title">avcodec_find_decoder</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> CodecID id)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CodecIDでデコーダーを検索します。</font><font style="vertical-align: inherit;">エラーの場合はNULLを返します。</font><font style="vertical-align: inherit;">codecCtx-&gt; codec_idを使用して、AVFormatContextのストリームから必要なAVCodecContextを取得した後に呼び出す必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avcodec_flush_buffers</span><span class="hljs-params">(AVCodecContetx *avctx)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッファフラッシュ。</font><font style="vertical-align: inherit;">別のストリームを検索または切り替えるときに呼び出されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodecContext * <span class="hljs-title">avcodec_alloc_context3</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVCodec *codec)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVCodecContextを割り当て、そのフィールドをデフォルト値に設定します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_copy_context</span> <span class="hljs-params">(AVCodecContext *dest, <span class="hljs-keyword">const</span> AVCodecContext *src)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースAVCodecContextの設定をターゲットAVCodecContextにコピーします。</font><font style="vertical-align: inherit;">結果の宛先コーデックのコンテキストは閉じられます。</font><font style="vertical-align: inherit;">このAVCodecContextを使用してビデオ/オーディオデータをデコード/エンコードする前に、avcodec_open2（）を呼び出す必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dest</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：avcodec_alloc_context3（NULL）で初期化する必要があります。それ以外の場合は初期化されません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_open2</span><span class="hljs-params">(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化はで指定されたコーデックを使用するavctx </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーデックを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">avcodec_find_decoderの後に使用する必要があります。</font><font style="vertical-align: inherit;">成功した場合はゼロ、エラーの場合は負の値を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_fill</span><span class="hljs-params">(AVPicture *picture, <span class="hljs-keyword">uint8_t</span> *ptr, <span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像が指す構造体を、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファー</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式</font><b><font style="vertical-align: inherit;">、</font></b><font style="vertical-align: inherit;">および指定された幅と高さで設定します。</font><font style="vertical-align: inherit;">画像データのサイズをバイト単位で返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_get_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定された幅、高さ、画像形式の画像に必要なバイト数を計算します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct SwsContext* <span class="hljs-title">sws_getContext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcW, <span class="hljs-keyword">int</span> srcH, <span class="hljs-keyword">int</span> srcFormat, <span class="hljs-keyword">int</span> dstW, <span class="hljs-keyword">int</span> dstH, <span class="hljs-keyword">int</span> dstFormat, <span class="hljs-keyword">int</span> flags, SwsFilter *srcFilter, SwsFilter *dstFilter, <span class="hljs-keyword">double</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sws_scaleで使用するSwsContextを返します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：目的のピクセルの幅、高さ、およびフォーマット。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：最終的なピクセルの幅、高さ、フォーマット。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：使用するスケーリング方法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用可能なオプションは、SWS_FAST_BILINEAR、SWS_BILINEAR、SWS_BICUBIC、SWS_X、SWS_POINT、SWS_AREA、SWS_BICUBLIN、SWS_GAUSS、SWS_SINC、SWS_LANCZOS、SWS_SPLINEです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他のフラグには、CPU機能フラグ（SWS_CPU_CAPS_MMX、SWS_CPU_CAPS_MMX2、SWS_CPU_CAPS_3DNOW、SWS_CPU_CAPS_ALTIVEC）が含まれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他のフラグには（現在は完全に実装されていない）SWS_FULL_CHR_H_INT、SWS_FULL_CHR_H_INP、およびSWS_DIRECT_BGRがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、SWS_ACCURATE_RNDがあり、おそらく初心者に最も役立つSWS_PRINT_INFOがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らのほとんどが何をしているのか私にはわかりません。多分私に書いてください？</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ソースと宛先のSwsFilter。 SwsFilterは、色/輝度のフィルタリングを有効にします。デフォルト値はNULLです。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：係数を持つint [2]バッファへのポインタである必要があります。文書化されていません。標準のスケーリングアルゴリズムをわずかに変更するために使用されているようです。デフォルト値はNULLです。専門家のみ！</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sws_scale</span><span class="hljs-params">(SwsContext *c, <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">int</span> srcStride[], <span class="hljs-keyword">int</span> srcSliceY, <span class="hljs-keyword">int</span> srcSliceH, <span class="hljs-keyword">uint8_t</span> dst[], <span class="hljs-keyword">int</span> dstStride[]
sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height, pict.data, pict.linesize);</span></span></code></pre><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">SwsContext * cの</font></b><font style="vertical-align: inherit;">設定に従って</font><font style="vertical-align: inherit;">
、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーリングします</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ソース行と宛</font><b><font style="vertical-align: inherit;">先行の</font></b><font style="vertical-align: inherit;">サイズです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_TimerID <span class="hljs-title">SDL_AddTimer</span><span class="hljs-params">(Uint32 interval, SDL_NewTimerCallback callback, <span class="hljs-keyword">void</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定されたミリ秒後に実行されるコールバック関数を追加します。コールバック関数は、SDL_AddTimer呼び出しからの現在のタイマー間隔とユーザー指定のパラメーターを渡し、次のタイマー間隔を返します。 （コールバックの戻り値が渡された値と一致する場合、タイマーは同じ速度で動作し続けます。）コールバックの戻り値が0の場合、タイマーはキャンセルされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のタイマーをキャンセルする別の方法は、タイマー識別子（SDL_AddTimerから返された）を使用してSDL_RemoveTimerを呼び出すことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイマーコールバック関数はメインプログラムとは異なるスレッドで実行される可能性があるため、それ自体から関数を呼び出すことはできません。ただし、いつでもSDL_PushEventを呼び出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイマーの詳細度はプラットフォームによって異なりますが、これは最も一般的な値であるため、少なくとも10ミリ秒であることを期待する必要があります。</font><font style="vertical-align: inherit;">つまり、16ミリ秒のタイマーを要求すると、アンロードされたシステムで約20ミリ秒後にコールバックが開始されます。</font><font style="vertical-align: inherit;">毎秒30フレーム（33ミリ秒ごと）の速度でフレームの更新を通知するフラグを設定する必要がある場合は、タイマーを30ミリ秒に設定できます（以下の例を参照）。</font><font style="vertical-align: inherit;">この関数を使用する場合は、SDL_INIT_TIMERをSDL_Initに渡す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加されたタイマーの識別子の値を返します。エラーが発生した場合はNULLを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバックの形式：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">Uint32 <span class="hljs-title">callback</span> <span class="hljs-params">( Uint32, <span class="hljs-keyword">void</span> * param)</span></span></code></pre><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondSignal</span><span class="hljs-params">(SDL_cond *cond)</span></span></code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cond</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
条件変数を待機しているスレッドの1つを再</font><b><font style="vertical-align: inherit;">起動し</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">成功した場合は0、エラーの場合は-1を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondWait</span><span class="hljs-params">(SDL_cond *cond, SDL_mutex *mut)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提供されたミューテックスのロックを解除し、別のスレッドがcond条件変数のSDL_CondSignalまたはSDL_CondBroadcastを呼び出すのを待ってから、ミューテックスを再度ロックします。</font><font style="vertical-align: inherit;">この関数に入る前にミューテックスをロックする必要があります。</font><font style="vertical-align: inherit;">シグナルを受信すると0を返し、エラーの場合は-1を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_cond *<span class="hljs-title">SDL_CreateCond</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件変数を作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Thread *<span class="hljs-title">SDL_CreateThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *data)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateThreadは、親のグローバルメモリ全体、シグナルハンドラー、ファイル記述子などを共有する新しい実行スレッドを作成します。</font><font style="vertical-align: inherit;">そして、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fn</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を実行してvoidポインターデータを渡します。</font><font style="vertical-align: inherit;">スレッドは、fnが値を返すと終了します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Delay</span> <span class="hljs-params">(Uint32 )</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定されたミリ秒数の間待機します。 SDL_Delayは少なくとも指定された時間待機しますが、OSの計画により、おそらく長く待機します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少なくとも10ミリ秒の遅延粒度が必要です。一部のプラットフォームでは測定値が短くなっていますが、これが最も一般的なオプションです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Overlay *<span class="hljs-title">SDL_CreateYUVOverlay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Uint32 format, SDL_Surface *display)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateYUVOverlayは、指定されたディスプレイに対して、指定された幅、高さ、およびフォーマット（使用可能なフォーマットのリストについては、SDL_Overlayデータ構造を参照）のYUVオーバーレイを作成します。</font><font style="vertical-align: inherit;">SDL_Overlayを返します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は実際にはSDL_SetVideoModeから派生したサーフェスである必要があります。そうでない場合、この関数はデフォルトで機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「オーバーレイ」という用語は正しくありません。オーバーレイがハードウェアで作成されていない場合、オーバーレイが表示されるときに、オーバーレイが表示されている領域の下の表示面の内容が上書きされるためです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockYUVOverlayは、ピクセルデータに直接アクセスするためのオーバーレイをブロックします。</font><font style="vertical-align: inherit;">成功した場合は0、エラーの場合は-1を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_UnlockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前にロックされたオーバーレイのロックを解除します。</font><font style="vertical-align: inherit;">オーバーレイを表示するには、ロックを解除する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_DisplayYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay, SDL_Rect *dstrect)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成時に指定されたサーフェスにオーバーレイを配置します。</font><font style="vertical-align: inherit;">SDL_Rect dstrect構造体は、宛先の位置とサイズを定義します。</font><font style="vertical-align: inherit;">dstrectが多かれ少なかれオーバーレイである場合、オーバーレイはスケーリングされ、これは2倍のスケーリング用に最適化されます。</font><font style="vertical-align: inherit;">成功した場合は0を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_FreeYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateYUVOverlayによって作成されたオーバーレイを解放します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_Init</span><span class="hljs-params">(Uint32 flags)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDLを初期化します。これは、他のすべてのSDL関数の前に呼び出す必要があります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータ</font><font style="vertical-align: inherit;">は、SDLのどの部分を初期化</font><font style="vertical-align: inherit;">するかを</font><font style="vertical-align: inherit;">指定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_TIMER-タイマーサブシステムを初期化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_AUDIO-オーディオサブシステムを初期化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_VIDEO-ビデオサブシステムを初期化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_CDROM-CD-ROMサブシステムを初期化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_JOYSTICK-ジョイスティックサブシステムを初期化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVERYTHING-上記のすべてを初期化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_NOPARACHUTE-SDLが致命的なエラーをキャッチすることを許可しません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVENTTHREAD-別のスレッドでイベントマネージャを起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーの場合は-1、成功の場合は0を返します。</font><font style="vertical-align: inherit;">SDL_GetErrorを呼び出すことにより、拡張エラーメッセージを取得できます。</font><font style="vertical-align: inherit;">エラーの一般的な原因は、サブシステムを適切にサポートしていない特定のディスプレイを使用していることです。たとえば、デバイスでフレームバッファーを使用しているときにマウスドライバーがないことが原因です。</font><font style="vertical-align: inherit;">この場合、マウスを使わずにSDLをコンパイルするか、アプリケーションを起動する前に環境変数「SDL_NOMOUSE = 1」を設定できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_mutex *<span class="hljs-title">SDL_CreateMutex</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックされていない新しいmutexを作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockMutex</span><span class="hljs-params">(SDL_mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockMutexはSDL_mutexPのエイリアスです。</font><font style="vertical-align: inherit;">以前にSDL_CreateMutexを使用して作成されたミューテックスをブロックします。</font><font style="vertical-align: inherit;">mutexがすでに別のスレッドによってブロックされている場合、SDL_mutexPは、それによってブロックされたスレッドが（SDL_mutexVを使用して）ロックを解除するまで値を返しません。</font><font style="vertical-align: inherit;">ミューテックスが再び呼び出されるとき、ミューテックスをロック解除状態に戻すには、SDL_mutexV（別名SDL_UnlockMutex）を同じ回数呼び出す必要があります。</font><font style="vertical-align: inherit;">成功した場合は0、エラーの場合は-1を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_UnlockMutex</span><span class="hljs-params">(SDL_Mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミューテックスのロックを解除します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_OpenAudio</span><span class="hljs-params">(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、必須のパラメーターでオーディオユニットを開き、成功した場合は0を返し、実際にハードウェアパラメーターを最終的に指す構造に配置します。 NULL値を受け取った場合、コールバック関数に渡されるオーディオデータは必要な形式であることが保証され、必要に応じて、ハードウェアオーディオ形式に自動的に変換されます。この関数は、オーディオデバイスを開けなかった場合、またはオーディオストリームを構成できなかった場合、-1を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオデバイスを開くには、目的のSDL_AudioSpecを作成する必要があります。次に、この構造に必要なオーディオ仕様を入力する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desired-&gt; freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：1秒あたりのサンプル数で表した希望の周波数。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desired-&gt; format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：必要なオーディオ形式（SDL_AudioSpecを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">望ましい-&gt;チャネル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：必要なチャンネル（モノ用に1つ、ステレオ用に2つ、サラウンドサウンド用に4つ、センタリングとLFE付きのサラウンドサウンド用に6つ）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desired-&gt; samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">サンプルの</font></b><font style="vertical-align: inherit;">オーディオバッファーサイズ。この数は2の累乗でなければならず、オーディオドライバによってハードウェアにより適した値に調整できます。最適値は、アプリケーションとプロセッサー速度に応じて、512から8192の範囲です。値が小さいほど応答時間が速くなりますが、アプリケーションが重い処理を実行し、時間内にオーディオバッファーを満たすことができない場合は、パフォーマンスが低下する可能性があります。ステレオサンプルは、LR順の右チャネルと左チャネルで構成されます。サンプル数は、次の式を使用して時間に直接関連していることに注意してください：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ms</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 1000）/ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desired-&gt; callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーディオユニットが追加のデータを受信する準備ができたときに呼び出される関数に設定する必要があります。音声バッファへのポインタと音声バッファの長さ（バイト単位）が送信されます。この関数は通常、別のスレッドで実行されるため、コードでSDL_LockAudioおよびSDL_UnlockAudioを呼び出して、アクセスするデータ構造を保護する必要があります。コールバックのプロトタイプは、</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無効のコールバック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無効</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザデータ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UINT8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型のLEN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザデータ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ユーザデータフィールドSDL_AudioSpecに格納されているポインタ。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報を入力するオーディオバッファーへのポインターです</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オーディオバッファーの長さ（バイト単位）です。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">required-&gt; userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：このポインターは、最初のパラメーターとしてコールバック関数に渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudioは、関数に渡された目的のSDL_AudioSpec構造からこれらのフィールドを読み取り、目的に一致するオーディオ構成を見つけようとします。上記のように、結果のパラメーターがNULLの場合、SDLは再生中に目的のサウンド設定から機器設定に変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NULLが返された場合、必要なSDL_AudioSpecは実際の仕様です。それ以外の場合、結果のSDL_AudioSpecは実際の仕様になり、目的の仕様を削除できます。作業仕様のデータは、SDL_AudioCVTをビルドして、ダウンロードしたデータを機器の形式に変換するときに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudioは、目的の仕様と結果の仕様の両方のサイズと沈黙フィールドを計算します。サイズフィールドには、オーディオバッファーの合計サイズがバイト単位で格納されますが、無音には、オーディオバッファー内の無音を表すために使用される値が格納されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サウンドデバイスは、開いているときに無音の再生を開始します。オーディオコールバック関数を呼び出す準備ができたら、SDL_PauseAudio（0）を呼び出して再生のためにオンにする必要があります。</font><font style="vertical-align: inherit;">オーディオドライバーは、オーディオバッファーの要求サイズを変更できるため、オーディオデバイスを開いた後、ローカルのミキシングバッファーを選択する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_PauseAudio</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pause_on)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、オーディオコールバック処理を一時停止および停止します。</font><font style="vertical-align: inherit;">サウンドの再生を開始するには、オーディオデバイスを開いた後にpause_on = 0で呼び出す必要があります。</font><font style="vertical-align: inherit;">これにより、オーディオデバイスを開いた後、コールバック関数のデータを安全に初期化できます。</font><font style="vertical-align: inherit;">沈黙は、一時停止中にオーディオデバイスに記録されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_PushEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
双方向通信チャネルとして実際に使用されるイベントキュー。</font><font style="vertical-align: inherit;">キューからイベントを読み取るだけでなく、ユーザーは自分のイベントをキューに入れることもできます。</font><font style="vertical-align: inherit;">イベントは、キューに入れたいイベントの構造へのポインターです。</font><font style="vertical-align: inherit;">イベントはキューにコピーされ、呼び出し元はSDL_PushEventを返した後にポイントされたメモリを管理できます。</font><font style="vertical-align: inherit;">この関数はスレッド指向であり、他のスレッドから安全に呼び出すことができます。</font><font style="vertical-align: inherit;">成功した場合は0を返し、イベントをディスパッチできなかった場合は-1を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_WaitEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの待機中にエラーが発生した場合は0を返し、それ以外の場合は1を返します。</font><font style="vertical-align: inherit;">イベントがNULLでない場合、次のイベントがキューから削除され、この領域に格納されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Quit</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのSDLサブシステムを無効にし、それに割り当てられたリソースを解放します。これは、終了する前に必ず呼び出す必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Surface *<span class="hljs-title">SDL_SetVideoMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> bitsperpixel, Uint32 flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定された幅、高さ、ピクセルビットでのビデオモード設定。 SDL 1.2.10以降、幅と高さが0の場合、現在のビデオモード（またはモードが設定されていない場合はデスクトップモード）の幅と高さを使用します。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitsperpixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が0の</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、現在のピクセルあたりの表示ビットとして扱われます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータ</font><font style="vertical-align: inherit;">は、SDL_Surface構造体のflagsフィールドと同じです。または、次の値の組み合わせ：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE-システムメモリにビデオサーフェスを作成します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE-ビデオメモリにビデオサーフェスを作成します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT-表示面への非同期更新の使用を有効にします。これは通常、シングルプロセッサコンピュータでの作業を遅くしますが、SMPシステムでは速度を上げることができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT-通常、要求されたピクセルあたりのビット数（bpp-ピクセルあたりのビット数）のビデオサーフェスが使用できない場合、SDLはシェーディングされたサーフェスでビデオをエミュレートします。 SDL_ANYFORMATを渡すと、これが防止され、ピクセル単位の深度に関係なく、SDLはビデオの表面を使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE-SDLにパレットへの排他的アクセスを提供します。このフラグがないと、SDL_SetColorsまたはSDL_SetPaletteを使用して要求した色を常に取得できるとは限りません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF-ハードウェアのダブルバッファリングを有効にします。 SDL_HWSURFACEでのみ有効です。 SDL_Flipを呼び出すと、バッファが反転し、画面が更新されます。すべての描画は、現在表示されていないサーフェス上で行われます。ダブルバッファリングを有効にできない場合、SDL_Flipは単にSDL_UpdateRect全画面を実行します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN SDL-全画面モードを使用してみます。ハードウェアの解像度を変更できない場合（何らかの理由で）、次に高い解像度が使用され、表示ウィンドウは黒い背景の中央に配置されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL-OpenGLレンダリングコンテキストを作成します。 SDL_GL_SetAttributeを持つOpenGLビデオ属性は事前に設定されていると想定されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT-上記のようにOpenGLレンダリングコンテキストを作成しますが、通常のブリッティング操作を許可します。スクリーンサーフェス（2D）はアルファチャネルを持つことができ、スクリーンサーフェスの変更を更新するにはSDL_UpdateRectsを使用する必要があります。注意。このオプションは互換性のためにのみ保存され、将来のバージョンでは削除される予定です。新しいコードでの使用は推奨されません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABL-サイズ変更可能なウィンドウを作成します。ユーザーがウィンドウサイズを変更すると、SDL_VIDEORESIZEイベントが生成され、新しいサイズでSDL_SetVideoModeを再度呼び出すことができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_NOFRAME可能であれば、SDL_NOFRAMEはSDLにタイトルやフレームなしのウィンドウを作成させます。このフラグは全画面モードで自動的に設定されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。どのSDL_SetVideoModeフラグが満たすことができるかに関係なく、返されるサーフェスのflags要素に設定されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。ビットピクセル24は、ピクセルあたり3バイトのパック表現を使用します。より一般的な4バイト/ピクセルモードの場合は、32ビットピクセルを使用します。奇妙なことに、15と16の両方がピクセルあたり2バイトモードを要求しますが、ピクセル形式が異なります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。個別のピクセル操作を実行するか、アルファチャネルを使用してサーフェスをドラッグする予定で、高いフレームレートが必要な場合は、SDL_SWSURFACEを使用します。ハードウェアサーフェス（SDL_HWSURFACE）を使用する場合、SDLは、ロックするとサーフェスをビデオメモリからシステムメモリにコピーし、ロック解除するとその逆になります。これにより、パフォーマンスが大幅に低下する可能性があります。 （ハードウェアサーフェスに対してクエリを実行しても、ソフトウェアサーフェスを取得できることに注意してください。多くのプラットフォームは、SDL_FULLSCREENを使用する場合にのみハードウェアサーフェスを提供できます。）SDL_HWSURFACEは、ブロッティングするサーフェスもビデオメモリに格納できる場合に最適です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">ウィンドウサーフェスの作成時に画面上の位置を制御する場合は、環境変数「SDL_VIDEO_CENTERED = center」または「SDL_VIDEO_WINDOW_POS = x、y」を設定することでこれを行うことができます。</font><font style="vertical-align: inherit;">SDL_putenv経由でインストールできます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻り値：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームバッファサーフェス、または失敗した場合はNULL。</font><font style="vertical-align: inherit;">返されたサーフェスはSDL_Quitによって解放され、呼び出し元によって解放されてはなりません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">このルールには、SDL_SetVideoModeの連続呼び出し（つまり、サイズ変更）が含まれます-既存のサーフェスは自動的に解放されます。</font></font><a name="data"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録2.データ構造</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="付録1.関数のリスト"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="参考文献"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<br>
<pre><code class="cpp hljs">AVCodecContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVStream-&gt;コーデックからのストリームからのコーデックに関するすべての情報。いくつかの重要な属性：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：1秒あたりのフレーム数</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：1秒あたりのサンプル</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">チャネル</font></b><font style="vertical-align: inherit;">数</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なリスト（非常に印象的）は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=http://web.archive.org/web/20090410064257/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webアーカイブ、元のリンクが既に存在しないため</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を参照してください。多くのパラメータは主にエンコードに使用され、デコードには使用されません。</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データフィールド：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_class </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVInputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVOutputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：低レベルのファイル操作に使用されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ファイル内のスレッドの数。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream *ストリーム[MAX_STREAMS]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：各ストリームのデータはここに格納されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char filename [1024]：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、それなしではどう</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オリジナルでは</font><i><font style="vertical-align: inherit;">-duh</font></i><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイル情報：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int64_t </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムスタンプ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイトル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">author</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copyright</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">album</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">year</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">track</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [32]：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ctx_flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：指定</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能な値は、AVFMT_NOFILE、AVFMT_NEEDNUMBER、AVFMT_SHOW_IDS、AVFMT_RAWPICTURE、 AVFMT_GLOBALHEADER、AVFMT_NOTIMESTAMPS、AVFMT_GENERIC_INDEX </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：このバッファは、パケットがすでにバッファされているがデコードされていない場合にのみ必要です。たとえば、mpegストリームでコーデックパラメータを受信する場合などです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int64_t</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：デコード時：コンポーネントの最初のフレームの位置。秒の端数であるAV_TIME_BASE。この値を直接設定しないでください。AVStreamの値から推測されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t期間：デコード</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ストリームの期間（AV_TIME_BASEの分数）。この値を直接設定しないでください。AVStreamの値から推測されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t file_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：合計ファイルサイズ。不明な場合は0。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int bit_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：デコード：ストリームのビット/秒単位の合計ビットレート。使用できない場合は0。 file_sizeとffmpegで既知の継続時間が自動的に計算できる場合は、直接設定しないでください。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream * cur_st </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * cur_ptr </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int cur_len </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket cur_pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t data_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index_built</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：最初のパケットのオフセット。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int mux_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int preload</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_output</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：サポートされている形式の出力サイクル数。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intフラグ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_input</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号なしint probesize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：デコード：サンプルデータサイズ;コーディングでは使用されません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_analyze_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：入力データをav_find_stream_info（）</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keylenで分析する必要があるAV_TIME_BASEの単位での最大期間</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">AVIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースにアクセスするためのI / Oコンテキスト。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const AVClass * av_class</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プライベート設定のクラス。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">バッファーの</font></b><font style="vertical-align: inherit;">開始。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：最大バッファサイズ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：バッファ内の現在の位置。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：たとえば、読み取り関数が要求されたよりも少ないデータを返した場合、データはbuffer + buffer_sizeよりも小さくなる可能性があります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：read / write / search / ... </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int（* read_packet）に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渡されるプライベートポインター</font><b><font style="vertical-align: inherit;">（void * opaque、uint8_t * buf、int buf_size）</font></b><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int（* write_packet）（void * opaque、uint8_t * buf、int buf_size ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t（* seek）（void * opaque、int64_t offset、int whence）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：現在のバッファのファイル内の位置。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：次の検索をリセットする必要がある場合はtrue。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ファイルの終わりに達した場合はtrue。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：書き込み用に開いている場合はtrue。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long checksum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * checksum_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long（* update_checksum）（unsigned long checksum、const uint8_t * unsigned int size）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：エラーコードが含まれるか、エラーが発生しなかった場合は0。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int（* read_pause）（void * opaque、int pause）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：たとえば、ネットワークストリーミングプロトコルの再生を一時停止または再開します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t（* read_seek）（void * opaque、int stream_index、int64_t timestamp、int flags）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：指定されたstream_indexインデックスを持つストリーム内の指定されたタイムスタンプを検索します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seekable：ストリームが検索できない場合のAVIO_SEEKABLE_または0フラグの組み合わせ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t maxsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：選択を制限するために使用される最大ファイルサイズ。このフィールドはlibavformatの内部にあり、外部からのアクセスは禁止されています。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int direct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：avio_readとavio_writeは可能な限り直接実行する必要があり、バッファーを通過させないでください。avio_seekは常にメインの検索関数を直接呼び出します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t bytes_read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：バイト読み取り統計このフィールドはlibavformatの内部にあり、外部アクセスは拒否されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int seek_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：統計を検索します。</font><font style="vertical-align: inherit;">このフィールドはlibavformatの内部にあり、外部からのアクセスは禁止されています。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int writeout_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：統計を書き込みます。</font><font style="vertical-align: inherit;">このフィールドはlibavformatの内部にあり、外部からのアクセスは禁止されています。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int orig_buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：バッファーサイズをリセットするための戻り値を確認および提供した後で内部的に使用される元のバッファーサイズ。</font><font style="vertical-align: inherit;">このフィールドはlibavformatの内部にあり、外部からのアクセスは禁止されています。</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionary</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ffmpegにパラメーターを渡すために使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVDictionaryEntry * elems</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionaryEntry</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVDictionaryに辞書エントリを格納するために使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * ket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char *値</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造はコーデックのタイプに依存するため、動的に決定されます。ただし、この構造には共通のプロパティとメソッドがあります：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int linesize [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：情報ストライド。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * base [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int key_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int pict_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これらは、デコード時に期待されるptsではありません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int coded_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int display_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int quality</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int age</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int reference</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * qscale_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qstride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * mbskip_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int16_t（* motion_val [2]）[2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t * mb_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t motion_subsample_log2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ユーザーデータ</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint64_tエラー[4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intタイプ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int repeat_pict</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：画像を指定された回数繰り返すように指示します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT qscale_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型interlaced_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型top_field_first</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPanScan * pan_scan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT palette_has_changed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型buffer_hints</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短い* dct_coeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * ref_index [2] </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生パケットデータが格納される構造。フレームを受信するには、このデータをavcodec_decode_audio2またはavcodec_decode_videoに転送する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：time_base単位のプレゼンテーションタイムスタンプ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：伸長のタイムスタンプ（time_base単位）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：生データ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：データサイズ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：AVFormatContextの数量に基づいて、AVPacketの送信元のストリーム。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intフラグ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：パケットがキーフレームの場合、PKT_FLAG_KEYが設定されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プレゼンテーションの期間（time_baseの単位）（使用できない場合は0）</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void（* destruct）（struct AVPacket *）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：このパッケージのリソース解放関数（デフォルトでは、av_destruct_packet）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ストリーム内のバイト位置。不明な場合は-1。</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacketList</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージの単純なリンクリスト。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList *次の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">AVPicture</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造は最初の2つのAVFrameデータ要素とまったく同じであるため、破棄されることがよくあります。</font><font style="vertical-align: inherit;">SWS関数で一般的に使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int linesize [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：文字列のバイト数。</font></font><br>
<br>
<pre><code class="cpp hljs">AVRational</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有理数を表すための単純な構造。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int num</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：分子。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：分母。</font></font><br>
<br>
<pre><code class="cpp hljs">AVStream</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームの構造。この情報は、コーデックで最も頻繁に使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型のインデックス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext *コーデック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational r_frame_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void *型priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_tのcodec_info_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT codec_info_nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrac PTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型pts_wrap_bits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型stream_copy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙AVDiscard破棄はされている</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要はありません逆多重化で。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロートの品質</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャー言語[4] </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intはneed_pa​​rsing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：1 - &gt;完全な解析を必要とする、2 - &gt;解析ヘッダーのみ、再梱包することなく</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecParserContextを*パーサ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_tのcur_dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT last_IP_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_tのlast_IP_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIndexEntry * index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int型nb_index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int型のindex_entries_allocated_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：このストリームのフレーム数（既知の場合）または0 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts_buffer [MAX_REORDER_DELAY + 1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">ByteIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ムービーファイルに関する低レベルの情報を格納する構造。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int（* read_packet）（void * opaque、uint8_t * buf、int buf_size）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int（* write_packet）（void * opaque、 uint8_t * buf、int buf_size）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t（* seek）（void * opaque、offset_t offset、int whence）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int is_streamed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long checksum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * checksum_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned long（* update_checksum）（unsigned long checksum：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const uint8_t * buf、unsigned int size）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：エラーコードが含まれます。エラーが発生しなかった場合は0になります。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_AudioSpec</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のオーディオデータの形式を説明するために使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：サンプル/秒の音の周波数。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：音声データ形式。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャンネル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">チャンネル</font></b><font style="vertical-align: inherit;">数：1-モノ、2-ステレオ、4サラウンド、6サラウンド、センタリングおよびLFE </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイレンス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：サウンドバッファーの</font><b><font style="vertical-align: inherit;">サイレンス</font></b><font style="vertical-align: inherit;">値（計算）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">サンプルの</font></b><font style="vertical-align: inherit;">オーディオバッファーサイズ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーディオバッファーのサイズ（バイト単位）（計算）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback（..）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーディオバッファーを満たすためのコールバック関数。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：コールバック関数に渡されるユーザーデータへのポインター。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のフォーマット値が</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有効です</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">AUDIO_U8-8ビットの符号なしサンプル。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S8-符号付き8ビットサンプル。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16またはAUDIO_U16LSB-すべてのハードウェアでサポートされているわけではありません（符号なし16ビット下位バイト順）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16またはAUDIO_S16LS-すべてのハードウェアでサポートされていない（古いバイト順の16ビット）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16MSB-すべてのハードウェアでサポートされていない（符号なし16ビットビッグエンディアン）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16MS-すべてのハードウェアでサポートされているわけではありません（上位バイト順の16ビット）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16SYS：AUDIO_U16LSBまたはAUDIO_U16MSB-ハードウェアプロセッサによって異なります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16SYS：AUDIO_S16LSBまたはAUDIO_S16MSB-ハードウェアプロセッサによって異なります。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの基本構造。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：イベントのタイプ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">active</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：アクティベーションイベント（SDL_ActiveEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：キーボードイベント（SDL_KeyboardEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：マウス移動イベント（SDL_MouseMotionEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">button</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：マウスクリックイベント（SDL_MouseButtonEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jaxis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ジョイスティック軸移動イベント（SDL_JoyAxisEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jball</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ジョイスティックトラックボール移動イベント（SDL_JoyBallEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jhat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ジョイスティックヘッダー移動イベント（SDL_JoyHatEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jbutton</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ジョイスティックボタンを押すイベント（SDL_JoyButtonEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リサイズ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：アプリケーションウィンドウのサイズ変更イベント（SDL_ResizeEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公開</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：アプリケーションウィンドウのオープンイベント（SDL_ExposeEventを参照してください）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：アプリケーション終了要求イベント（SDL_QuitEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ユーザーイベント（SDL_UserEventを参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syswm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：未定義のウィンドウマネージャーイベント（SDL_SysWMEventを参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの種類は次のとおりです。詳細については、SDLのドキュメントを参照してください:. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ACTIVEEVENT SDL_ActiveEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_KEYDOWN / UP SDL_KeyboardEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEMOTION SDL_MouseMotionEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEBUTTONDOWN / UP SDL_MouseButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYAXISMOTION SDL_JoyAxisEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBALLMOTION SDL_JoyBallEventを</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JoyHatEvent SDL_JOYHATMOTION </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBUTTONDOWN / UP SDL_JoyButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEORESIZE SDL_ResizeEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEOEXPOSE SDL_ExposeEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Quit SDL_QuitEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_USEREVENT SDL_UserEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SYSWMEVENT SDL_SysWMEvent</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
YUVオーバーレイ。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーバーレイ形式（下記参照）。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w、h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーバーレイの幅/高さ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平面</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーバーレイするプランの数。通常は1または3のいずれかです。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：インデントの配列で、各プランに1つです。インデントは、バイト単位の文字列の長さです。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：各プランのデータポインターの配列。これらのポインタを使用する前に、オーバーレイをロックする必要があります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hw_overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：オーバーレイがハードウェアアクセラレーションの場合は1に設定します。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長方形の領域。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sint16 x、y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：長方形の左上隅の位置。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint16 w、h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：長方形の幅と高さ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Rectは、ピクセルの長方形の領域を定義します。これはSDL_BlitSurfaceによって使用され、ブリットの領域と他のいくつかのビデオ機能を識別します。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外側（表面）のグラフィック構造。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint32フラグ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：外部ストトロンのフラグ。読書のみ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PixelFormat * format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：読み取り専用。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int w、h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：幅と高さ。読書のみ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint16ピッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ステップ。読書のみ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * pixels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：実際のピクセルデータへのポインター。記録のみ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Rect clip_rect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：クリップの外側の長方形。読書のみ。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int refcount</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：メモリの割り当てに使用されます。主に読書のため。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造には、ここに示されていないプライベートフィールドも含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Surfaceは、描画可能な「グラフィック」メモリの領域を表します。ビデオバッファーフレームは、SDL_SetVideoModeおよびSDL_GetVideoSurfaceを使用してSDL_Surfaceとして返されます。フィールドwとhは、ピクセル単位で表面の幅と高さを表す値です。ピクセルフィールドは、実際のピクセルデータへのポインタです。注：このフィールドにアクセスする前に、（SDL_LockSurfaceを介して）サーフェスをロックする必要があります。 clip_rectフィールドは、SDL_SetClipRectによって設定されるクリップされた四角形です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグフィールドは次のOR値をサポートします</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。SDL_SWSURFACE-外部はシステムメモリに格納されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE-外部側はビデオメモリに格納されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT-可能な場合、外部は非同期グレアを使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT-任意のピクセル形式（表示面）が許可されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE-サーフェスには専用のパレットがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF-ダブルバッファサーフェス（ディスプレイサーフェス）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN-全画面表示（表示面）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL-サーフェスにはOpenGLコンテキスト（表示サーフェス）があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT-サーフェスはOpenGL（ディスプレイサーフェス）の境界をサポートします。注意。このオプションは互換性のためだけにあり、新しいコードには推奨されません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABLE-サーフェス（ディスプレイサーフェス）のサイズ変更が可能です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWACCEL-サーフェスブリットはハードウェアアクセラレーションを使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCCOLORKEY-表面性はカラーブリッティングを使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RLEACCEL-RLEを使用してカラーブリッティングが高速化されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCALPHA-Surface Blythはアルファブレンディングを使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_PREALLOC-サーフェスは事前に割り当てられたメモリを使用します。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Thread</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造はシステムに依存しないため、おそらく使用する必要はありません。</font><font style="vertical-align: inherit;">詳細については、ソースコードのsrc / thread / sdl_thread_c.hを参照してください。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_cond</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造はシステムに依存しないため、おそらく使用する必要はありません。</font><font style="vertical-align: inherit;">詳細については、ソースコードのsrc / thread / &lt;system&gt; /SDL_syscond.cを参照してください。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_mutex</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造はシステムに依存しないため、おそらく使用する必要はありません。</font><font style="vertical-align: inherit;">詳細については、ソースコードのsrc / thread / &lt;system&gt; /SDL_sysmutex.cを参照してください。</font></font><a name="links"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="付録2.データ構造"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑</font></font></a></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/ts/cs/ro/tscsrofdmymu7o1rbml2evolway.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpegとSDLチュートリアル、またはビデオプレーヤーを1000行未満で記述する方法</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">FFmpegホームページ</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">SDLホームページ</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/z0/e1/6o/z0e16ozcekig9i8jdthljdqpgga.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img width="60" height="30" src="https://habrastorage.org/webt/js/4n/23/js4n231ba7glkow_nud5i3dsveq.png"> </a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EDISON社のブログもご覧ください。</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg libavマニュアル</font></font></b></a><br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja502834/index.html">6か月以上でDevOpsエンジニアになる方法 パート5.デプロイメント</a></li>
<li><a href="../ja502836/index.html">Unityエディターアドベンチャー：シリアル化されたマトリョーシカ</a></li>
<li><a href="../ja502838/index.html">ITとデジタルの専門職の違いは何ですか：デジタルの変革と専門家の意見</a></li>
<li><a href="../ja502840/index.html">輝く3D EinScan Pro 2X Plus 3Dスキャナーレビュー</a></li>
<li><a href="../ja502842/index.html">ユーザーの生体認証データを不正使用から保護する方法</a></li>
<li><a href="../ja502846/index.html">ザッカーバーグはショップを立ち上げた。インスタグラムとフェイスブックは徐々に店になっています。</a></li>
<li><a href="../ja502852/index.html">なぜ人々は変化に抵抗し、再建をどのように支援できるのか</a></li>
<li><a href="../ja502854/index.html">ERP実装が失敗するのはなぜですか？</a></li>
<li><a href="../ja502860/index.html">5月20日の輸送：航空の急速な回復が見える</a></li>
<li><a href="../ja502862/index.html">LabVIEW NXG-フロントパネルの基本-コントロールとインジケータ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>