<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÑ üèõÔ∏è üë®‚Äçüè≠ Assurer une haute disponibilit√© des applications avec Kafka Streams ü•£ üßïüèº üå∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kafka Streams est une biblioth√®que Java pour l'analyse et le traitement des donn√©es stock√©es dans Apache Kafka. Comme toute autre plate-forme de trait...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Assurer une haute disponibilit√© des applications avec Kafka Streams</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488558/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams est une biblioth√®que Java pour l'analyse et le traitement des donn√©es stock√©es dans Apache Kafka. </font><font style="vertical-align: inherit;">Comme toute autre plate-forme de traitement en streaming, il est capable d'effectuer un traitement de donn√©es avec et / ou sans conservation d'√©tat en temps r√©el. </font><font style="vertical-align: inherit;">Dans cet article, je vais essayer de d√©crire pourquoi la haute disponibilit√© (99,99%) est probl√©matique dans Kafka Streams et ce que nous pouvons faire pour y parvenir.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qu'on a besoin de savoir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de d√©crire le probl√®me et les solutions possibles, regardons les concepts de base de Kafka Streams. </font><font style="vertical-align: inherit;">Si vous avez travaill√© avec les API Kafka pour les consommateurs / producteurs, la plupart de ces paradigmes vous sont familiers. </font><font style="vertical-align: inherit;">Dans les sections suivantes, je vais essayer de d√©crire en quelques mots le stockage des donn√©es dans les partitions, le r√©√©quilibrage des groupes de consommateurs et comment les concepts de base des clients Kafka s'int√®grent dans la biblioth√®que Kafka Streams.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka: Partitionnement des donn√©es</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde de Kafka, les applications de producteurs envoient des donn√©es sous forme de paires cl√©-valeur √† un sujet sp√©cifique. </font><font style="vertical-align: inherit;">Le sujet lui-m√™me est divis√© en une ou plusieurs partitions dans les courtiers Kafka. </font><font style="vertical-align: inherit;">Kafka utilise une cl√© de message pour indiquer dans quelle partition les donn√©es doivent √™tre √©crites. </font><font style="vertical-align: inherit;">Par cons√©quent, les messages avec la m√™me cl√© finissent toujours dans la m√™me partition.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les applications grand public sont organis√©es en groupes de consommateurs, et chaque groupe peut avoir une ou plusieurs instances de consommateurs. </font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque instance d'un consommateur dans le groupe de consommateurs est responsable du traitement des donn√©es √† partir d'un ensemble unique de partitions de la rubrique d'entr√©e.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les instances de consommateur sont essentiellement un moyen de d√©velopper le traitement dans votre groupe de consommateurs.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka: Rebalancing Consumer Group</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons dit pr√©c√©demment, chaque instance du groupe de consommateurs re√ßoit un ensemble de partitions uniques √† partir desquelles il consomme des donn√©es. </font><font style="vertical-align: inherit;">Chaque fois qu'un nouveau consommateur rejoint un groupe, un r√©√©quilibrage doit avoir lieu afin qu'il obtienne une partition. </font><font style="vertical-align: inherit;">La m√™me chose se produit lorsque le consommateur d√©c√®de, le reste du consommateur doit prendre ses partitions pour s'assurer que toutes les partitions sont trait√©es.</font></font><br>
<cut></cut><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams: Streams</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but de cet article, nous avons pris connaissance du fait que la biblioth√®que Kafka Streams est construite sur la base des API des producteurs et des consommateurs et le traitement des donn√©es est organis√© de la m√™me mani√®re que la solution standard sur Kafka. Dans la configuration de Kafka Streams, le champ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">√©quivalent √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'API grand public. Kafka Streams pr√©-cr√©e un certain nombre de threads et chacun d'eux effectue le traitement des donn√©es √† partir d'une ou plusieurs partitions de rubriques d'entr√©e. S'exprimant dans la terminologie de l'API Consumer, les flux co√Øncident essentiellement avec les instances de Consumer du m√™me groupe. Les threads sont le principal moyen de faire √©voluer le traitement des donn√©es dans Kafka Streams, cela peut √™tre fait verticalement en augmentant le nombre de threads pour chaque application Kafka Streams sur une machine, ou horizontalement en ajoutant une machine suppl√©mentaire avec le m√™me application.id. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb7/bd3/8ed/bb7bd38edd33f26a146c12a1dea385b5.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kafka.apache.org/21/documentation/streams/architecture</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a beaucoup plus d'√©l√©ments dans Kafka Streams, tels que les t√¢ches, la topologie de traitement, le mod√®le de thread, etc., dont nous ne parlerons pas dans ce post. </font><font style="vertical-align: inherit;">Plus d'informations peuvent √™tre trouv√©es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams: Stockage d'√©tat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le traitement de flux, il existe des op√©rations avec et sans conservation de l'√©tat. </font><font style="vertical-align: inherit;">L'√©tat est ce qui permet √† l'application de se souvenir des informations n√©cessaires qui vont au-del√† de la port√©e de l'enregistrement en cours de traitement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les op√©rations d'√©tat, telles que le comptage, tout type d'agr√©gation, les jointures, etc., sont beaucoup plus compliqu√©es. Cela est d√ª au fait que n'ayant qu'un seul enregistrement, vous ne pouvez pas d√©terminer le dernier √©tat (par exemple, le nombre) pour une cl√© donn√©e, vous devez donc stocker l'√©tat de votre flux dans votre application. Comme nous l'avons vu pr√©c√©demment, chaque thread traite un ensemble de partitions uniques; par cons√©quent, un thread ne traite qu'un sous-ensemble de l'ensemble de donn√©es. Cela signifie que chaque thread d'application Kafka Streams avec le m√™me application.id conserve son propre √©tat isol√©. Nous n'entrerons pas dans les d√©tails sur la fa√ßon dont l'√©tat est form√© dans Kafka Streams, mais il est important de comprendre que l'√©tat est restaur√© √† l'aide de la rubrique du journal des modifications et est enregistr√© non seulement sur le disque local, mais aussi dans Kafka Broker.L'enregistrement du journal des changements d'√©tat dans Kafka Broker en tant que rubrique distincte est effectu√© non seulement pour la tol√©rance aux pannes, mais √©galement pour que vous puissiez facilement d√©ployer de nouvelles instances de Kafka Streams avec le m√™me application.id. √âtant donn√© que l'√©tat est stock√© en tant que rubrique de journal des modifications du c√¥t√© du courtier, une nouvelle instance peut charger son propre √©tat √† partir de cette rubrique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour plus d'informations sur le stockage d'√©tat, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cliquez ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la haute disponibilit√© pose-t-elle probl√®me avec les flux Kafka?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons examin√© les concepts et principes de base du traitement des donn√©es avec Kafka Streams. </font><font style="vertical-align: inherit;">Essayons maintenant de combiner toutes les pi√®ces ensemble et analysons pourquoi la haute disponibilit√© peut √™tre probl√©matique. </font><font style="vertical-align: inherit;">Dans les sections pr√©c√©dentes, nous devons nous rappeler:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les donn√©es de la rubrique Kafka sont divis√©es en partitions, qui sont r√©parties entre les flux Kafka Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les applications Kafka Streams avec la m√™me application.id sont, en fait, un groupe de consommateurs, et chacun de ses threads est une instance isol√©e distincte du consommateur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour les op√©rations d'√©tat, le thread conserve son propre √©tat, qui est ¬´r√©serv√©¬ª par le sujet Kafka sous la forme d'un journal des modifications.</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br>
<h2>TransferWise SPaaS (Stream Processing as a Service)</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de souligner l'essence de cet article, permettez-moi d'abord de vous dire ce que nous avons cr√©√© dans TransferWise et pourquoi la haute disponibilit√© est tr√®s importante pour nous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans TransferWise, nous avons plusieurs n≈ìuds pour le traitement en streaming, et chaque n≈ìud contient plusieurs instances de Kafka Streams pour chaque √©quipe de produits. Les instances de Kafka Streams con√ßues pour une √©quipe de d√©veloppement sp√©cifique ont un application.id sp√©cial et ont g√©n√©ralement plus de 5 threads. En g√©n√©ral, les √©quipes ont g√©n√©ralement 10 √† 20 threads (√©quivalent au nombre d'instances de consommateurs) dans le cluster. Les applications d√©ploy√©es sur les n≈ìuds √©coutent les rubriques d'entr√©e et effectuent plusieurs types d'op√©rations avec et sans √©tat sur les donn√©es d'entr√©e et fournissent des mises √† jour de donn√©es en temps r√©el pour les microservices en aval ult√©rieurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les √©quipes de produits doivent mettre √† jour les donn√©es agr√©g√©es en temps r√©el. </font><font style="vertical-align: inherit;">Cela est n√©cessaire pour offrir √† nos clients la possibilit√© de transf√©rer instantan√©ment de l'argent. </font><font style="vertical-align: inherit;">Notre SLA habituel:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque jour, 99,99% des donn√©es agr√©g√©es doivent √™tre disponibles en moins de 10 secondes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour vous donner une id√©e, pendant les tests de r√©sistance, Kafka Streams a pu traiter et agr√©ger 20 085 messages d'entr√©e par seconde. </font><font style="vertical-align: inherit;">Ainsi, 10 secondes de SLA sous charge normale semblaient tout √† fait r√©alisables. </font><font style="vertical-align: inherit;">Malheureusement, notre SLA n'a pas √©t√© atteint lors de la mise √† jour continue des n≈ìuds sur lesquels les applications sont d√©ploy√©es, et ci-dessous, je vais expliquer pourquoi cela s'est produit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise √† jour du n≈ìud coulissant</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chez TransferWise, nous croyons fermement √† la livraison continue de nos logiciels et publions g√©n√©ralement de nouvelles versions de nos services deux fois par jour. </font><font style="vertical-align: inherit;">Examinons un exemple de mise √† jour de service continue simple et voyons ce qui se passe pendant le processus de publication. </font><font style="vertical-align: inherit;">Encore une fois, nous devons nous rappeler que:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les donn√©es de la rubrique Kafka sont divis√©es en partitions, qui sont r√©parties entre les flux Kafka Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les applications Kafka Streams avec la m√™me application.id sont, en fait, un groupe de consommateurs, et chacun de ses threads est une instance isol√©e distincte du consommateur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les op√©rations d'√©tat, le thread conserve son propre √©tat, qui est ¬´r√©serv√©¬ª par le sujet Kafka sous la forme d'un journal des modifications.</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un processus de publication sur un seul n≈ìud prend g√©n√©ralement de huit √† neuf secondes. </font><font style="vertical-align: inherit;">Pendant la version, les instances de Kafka Streams sur le n≈ìud ¬´red√©marrent doucement¬ª. </font><font style="vertical-align: inherit;">Ainsi, pour un seul n≈ìud, le temps requis pour red√©marrer correctement le service est d'environ huit √† neuf secondes. </font><font style="vertical-align: inherit;">De toute √©vidence, l'arr√™t d'une instance de Kafka Streams sur un n≈ìud entra√Æne un r√©√©quilibrage du groupe de consommateurs. </font><font style="vertical-align: inherit;">√âtant donn√© que les donn√©es sont partitionn√©es, toutes les partitions qui appartenaient √† l'instance amor√ßable doivent √™tre r√©parties entre les applications Kafka Streams actives avec le m√™me application.id. </font><font style="vertical-align: inherit;">Cela s'applique √©galement aux donn√©es agr√©g√©es qui ont √©t√© enregistr√©es sur le disque. </font><font style="vertical-align: inherit;">Jusqu'√† la fin de ce processus, les donn√©es ne seront pas trait√©es.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©pliques de secours</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©duire le temps de r√©√©quilibrage des applications Kafka Streams, il existe un concept de r√©plicas de sauvegarde, qui sont d√©finis dans la configuration comme num.standby.replicas. Les r√©plicas de sauvegarde sont des copies du magasin d'√©tat local. Ce m√©canisme permet de r√©pliquer le magasin d'√©tat d'une instance de Kafka Streams √† une autre. Lorsque le thread Kafka Streams meurt pour une raison quelconque, la dur√©e du processus de r√©cup√©ration d'√©tat peut √™tre r√©duite. Malheureusement, pour les raisons que j'expliquerai ci-dessous, m√™me les r√©plicas de sauvegarde n'aideront pas √† une mise √† jour continue du service.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons deux instances de Kafka Streams sur deux machines diff√©rentes: node-a et node-b. </font><font style="vertical-align: inherit;">Pour chacune des instances de Kafka Streams, num.standby.replicas = 1 est indiqu√© sur ces 2 n≈ìuds. Avec cette configuration, chaque instance de Kafka Streams conserve sa propre copie du r√©f√©rentiel sur un autre n≈ìud. </font><font style="vertical-align: inherit;">Lors d'une mise √† jour continue, nous avons la situation suivante:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La nouvelle version du service a √©t√© d√©ploy√©e sur le n≈ìud-a.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'instance Kafka Streams sur le n≈ìud-a est d√©sactiv√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le r√©√©quilibrage a commenc√©.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le r√©f√©rentiel de node-a a d√©j√† √©t√© r√©pliqu√© sur node-b, car nous avons sp√©cifi√© la configuration num.standby.replicas = 1.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-b a d√©j√† un clich√© instantan√© de node-a, donc le processus de r√©√©quilibrage se d√©roule presque instantan√©ment.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-a red√©marre.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node-a rejoint un groupe de consommateurs.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le courtier Kafka voit une nouvelle instance de Kafka Streams et commence le r√©√©quilibrage.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous pouvons le voir, num.standby.replicas n'aide que dans les sc√©narios d'arr√™t complet d'un n≈ìud. </font><font style="vertical-align: inherit;">Cela signifie que si le n≈ìud-a tombait en panne, le n≈ìud-b pourrait continuer √† fonctionner correctement presque instantan√©ment. </font><font style="vertical-align: inherit;">Mais dans une situation de mise √† jour continue, apr√®s la d√©connexion, le noeud-a rejoindra le groupe, et cette derni√®re √©tape entra√Ænera un r√©√©quilibrage. </font><font style="vertical-align: inherit;">Lorsque le n≈ìud-a rejoint le groupe de consommateurs apr√®s un red√©marrage, il sera consid√©r√© comme une nouvelle instance du consommateur. </font><font style="vertical-align: inherit;">Encore une fois, nous devons nous rappeler que le traitement des donn√©es en temps r√©el s'arr√™te jusqu'√† ce qu'une nouvelle instance restaure son √©tat √† partir de la rubrique du journal des modifications.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que le r√©√©quilibrage des partitions lorsqu'une nouvelle instance est jointe √† un groupe ne s'applique pas √† l'API Kafka Streams, car c'est exactement ainsi que fonctionne le protocole du groupe de consommateurs Apache Kafka.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©alisation: haute disponibilit√© avec les flux Kafka</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgr√© le fait que les biblioth√®ques clientes Kafka ne fournissent pas de fonctionnalit√© int√©gr√©e pour le probl√®me mentionn√© ci-dessus, il existe certaines astuces qui peuvent √™tre utilis√©es pour obtenir une haute disponibilit√© du cluster lors d'une mise √† jour continue. </font><font style="vertical-align: inherit;">L'id√©e derri√®re les r√©plicas de sauvegarde reste valide, et disposer de machines de sauvegarde au moment opportun est une bonne solution que nous utilisons pour garantir une haute disponibilit√© en cas de d√©faillance de l'instance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me avec notre configuration initiale √©tait que nous avions un groupe de consommateurs pour toutes les √©quipes sur tous les n≈ìuds. </font><font style="vertical-align: inherit;">Maintenant, au lieu d'un groupe de consommateurs, nous en avons deux, et le second agit comme un cluster ¬´chaud¬ª. </font><font style="vertical-align: inherit;">Dans prod, les n≈ìuds ont une variable sp√©ciale CLUSTER_ID, qui est ajout√©e √† l'application.id des instances de Kafka Streams. </font><font style="vertical-align: inherit;">Voici un exemple de configuration Spring Boot application.yml:</font></font><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml</font></font></b><div class="spoiler_text"><code>spring.profiles: production<br>
streaming-pipelines:<br>
 team-a-stream-app-id: "${CLUSTER_ID}-team-a-stream-app"<br>
 team-b-stream-app-id: "${CLUSTER_ID}-team-b-stream-app"</code><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä un moment donn√©, un seul des clusters est en mode actif, respectivement, le cluster de sauvegarde n'envoie pas de messages en temps r√©el aux microservices en aval. Lors de la publication de la version, le cluster de sauvegarde devient actif, ce qui permet une mise √† jour continue sur le premier cluster. Puisqu'il s'agit d'un groupe de consommateurs compl√®tement diff√©rent, nos clients ne remarquent m√™me aucune violation dans le traitement, et les services ult√©rieurs continuent de recevoir des messages du cluster r√©cemment actif. L'un des inconv√©nients √©vidents de l'utilisation d'un groupe de sauvegarde de consommateurs est la surcharge suppl√©mentaire et la consommation de ressources, mais, n√©anmoins, cette architecture offre des garanties, un contr√¥le et une tol√©rance aux pannes suppl√©mentaires de notre syst√®me de traitement en streaming.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outre l'ajout d'un cluster suppl√©mentaire, il existe √©galement des astuces qui peuvent att√©nuer le probl√®me avec un r√©√©quilibrage fr√©quent.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Augmentez group.initial.rebalance.delay.ms</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä partir de Kafka 0.11.0.0, la configuration group.initial.rebalance.delay.ms a √©t√© ajout√©e. </font><font style="vertical-align: inherit;">Selon la documentation, ce param√®tre est responsable de:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dur√©e en millisecondes pendant laquelle GroupCoordinator retardera le r√©√©quilibrage initial du consommateur du groupe.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, si nous d√©finissons 60 000 millisecondes dans ce param√®tre, alors avec une mise √† jour continue, nous pouvons avoir une fen√™tre d'une minute pour la publication de la version. </font><font style="vertical-align: inherit;">Si l'instance de Kafka Streams red√©marre avec succ√®s dans cette fen√™tre de temps, aucun r√©√©quilibrage ne sera appel√©. </font><font style="vertical-align: inherit;">Veuillez noter que les donn√©es dont l'instance Kafka Streams red√©marr√©e √©tait responsable resteront indisponibles jusqu'√† ce que le n≈ìud revienne en mode en ligne. </font><font style="vertical-align: inherit;">Par exemple, si le red√©marrage d'une instance prend environ huit secondes, vous disposerez de huit secondes d'indisponibilit√© pour les donn√©es dont cette instance est responsable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que le principal inconv√©nient de ce concept est qu'en cas de d√©faillance d'un n≈ìud, vous recevrez un d√©lai suppl√©mentaire d'une minute pendant la restauration, en tenant compte de la configuration actuelle.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©duction de la taille des segments dans les rubriques du journal des modifications</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le gros retard dans le r√©√©quilibrage de Kafka Stream est d√ª √† la restauration des magasins d'√âtat √† partir des rubriques du journal des modifications. Les rubriques du journal des modifications sont des rubriques compress√©es, ce qui vous permet de stocker le dernier enregistrement d'une cl√© particuli√®re dans la rubrique. Je d√©crirai bri√®vement ce concept ci-dessous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les sujets de Kafka Broker sont organis√©s en segments. Lorsqu'un segment atteint la taille de seuil configur√©e, un nouveau segment est cr√©√© et le pr√©c√©dent est compress√©. Par d√©faut, ce seuil est d√©fini sur 1 Go. Comme vous le savez probablement, la structure de donn√©es principale sous-jacente aux rubriques Kafka et √† leurs partitions est la structure de journal avec une √©criture en avant, c'est-√†-dire que lorsque des messages sont envoy√©s √† la rubrique, ils sont toujours ajout√©s au dernier segment ¬´actif¬ª et la compression n'est pas passe.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, la plupart des √©tats de stockage stock√©s dans le journal des modifications se trouvent toujours dans le fichier ¬´segment actif¬ª et ne sont jamais compress√©s, ce qui entra√Æne des millions de messages de journal des modifications non compress√©s. </font><font style="vertical-align: inherit;">Pour Kafka Streams, cela signifie que lors du r√©√©quilibrage, lorsque l'instance de Kafka Streams restaure son √©tat √† partir de la rubrique du journal des modifications, elle doit lire un grand nombre d'entr√©es redondantes √† partir de la rubrique du journal des modifications. </font><font style="vertical-align: inherit;">√âtant donn√© que les magasins d'√âtat ne se soucient que du dernier √©tat, et non de l'historique, ce temps de traitement est perdu. </font><font style="vertical-align: inherit;">La r√©duction de la taille du segment entra√Ænera une compression des donn√©es plus agressive, de sorte que les nouvelles instances d'applications Kafka Streams peuvent r√©cup√©rer beaucoup plus rapidement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√™me si Kafka Streams ne fournit pas de capacit√© int√©gr√©e pour fournir une haute disponibilit√© lors d'une mise √† jour de service continue, cela peut toujours √™tre fait au niveau de l'infrastructure. </font><font style="vertical-align: inherit;">Nous devons nous rappeler que Kafka Streams n'est pas un ¬´framework de cluster¬ª contrairement √† Apache Flink ou Apache Spark. </font><font style="vertical-align: inherit;">Il s'agit d'une biblioth√®que Java l√©g√®re qui permet aux d√©veloppeurs de cr√©er des applications √©volutives pour le streaming de donn√©es. </font><font style="vertical-align: inherit;">Malgr√© cela, il fournit les √©l√©ments de base n√©cessaires pour atteindre des objectifs de streaming aussi ambitieux que la disponibilit√© √† ¬´99,99%¬ª.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr488544/index.html">Supprimer la couverture de code d'une application Node.JS d√©j√† en cours d'ex√©cution</a></li>
<li><a href="../fr488546/index.html">Hack The Box. Proc√©dure pas √† pas JSON. Vuln√©rabilit√© dans Json.Net et LPE via SeImpersonatePrivilege</a></li>
<li><a href="../fr488548/index.html">Exp√©rience: comment apprendre √† cr√©er des textes populaires en anglais (et pourquoi les Habristes anglophones lisent si peu)</a></li>
<li><a href="../fr488550/index.html">Qui veut faire des coop√©ratives des g√©ants de l'informatique</a></li>
<li><a href="../fr488552/index.html">D√©veloppeurs Apple FAS et contr√¥le parental</a></li>
<li><a href="../fr488560/index.html">H√©bergement gratuit de bots Telegram sur Google Cloud Platform</a></li>
<li><a href="../fr488564/index.html">Votre premier r√©seau neuronal sur une unit√© de traitement graphique (GPU). Guide du d√©butant</a></li>
<li><a href="../fr488566/index.html">Comment un ing√©nieur QA a sauv√© une journ√©e enti√®re en liant les tests automatiques dans Visual Studio et Test IT</a></li>
<li><a href="../fr488568/index.html">Les r√©seaux de neurones r√™vent-ils d'argent √©lectrique?</a></li>
<li><a href="../fr488570/index.html">Comment les services secrets am√©ricains ont confondu le RPG cyberpunk avec un manuel pour les pirates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>