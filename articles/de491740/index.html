<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ üèÅ üì± Das Internet der Dinge in Yandex.Cloud: Wie Yandex IoT Core- und Yandex Cloud-Funktionsdienste angeordnet sind üòí üå´Ô∏è üìÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Oktober letzten Jahres fand die erste Yandex Yandex Scale Cloud-Konferenz statt. Es wurde die Einf√ºhrung vieler neuer Dienste angek√ºndigt, darunter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Internet der Dinge in Yandex.Cloud: Wie Yandex IoT Core- und Yandex Cloud-Funktionsdienste angeordnet sind</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/491740/"><img src="https://habrastorage.org/webt/wf/_u/zo/wf_uzobkj9vxp2ddkzxzux7lhbo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Oktober letzten Jahres fand die erste Yandex Yandex Scale Cloud-Konferenz statt. Es wurde die Einf√ºhrung vieler neuer Dienste angek√ºndigt, darunter Yandex IoT Core, mit dem Sie Daten mit Millionen von IoT-Ger√§ten austauschen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich dar√ºber sprechen, warum Yandex IoT Core ben√∂tigt wird und wie es funktioniert und wie es mit anderen Yandex.Cloud-Diensten interagieren kann. Sie lernen die Architektur, die Feinheiten des Zusammenspiels von Komponenten und die Merkmale der Implementierung von Funktionen kennen - all dies hilft Ihnen, die Nutzung dieser Dienste zu optimieren.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zun√§chst an die Hauptvorteile von Public Clouds und PaaS erinnern - Reduzierung der Entwicklungszeit und -kosten sowie der Support- und Infrastrukturkosten, die auch f√ºr IoT-Projekte relevant sind. Es gibt jedoch einige weniger offensichtliche n√ºtzliche Funktionen, die Sie in der Cloud erhalten k√∂nnen. Diese effektive Skalierung und Fehlertoleranz sind wichtige Aspekte bei der Arbeit mit Ger√§ten, insbesondere in Projekten f√ºr kritische Informationsinfrastrukturen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Effektive Skalierung ist die M√∂glichkeit, die Anzahl der Ger√§te frei zu erh√∂hen oder zu verringern, ohne technische Probleme zu haben und nach den √Ñnderungen eine vorhersehbare √Ñnderung der Systemkosten festzustellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fehlertoleranz ist das Vertrauen, dass Services so konzipiert und bereitgestellt werden, dass auch bei Ausfall einiger Ressourcen die h√∂chstm√∂gliche Leistung gew√§hrleistet ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir nun zu den Details.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IoT-Skriptarchitektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zun√§chst sehen, wie die Gesamtarchitektur des IoT-Skripts aussieht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/po/yk/z_poykwjdwprirjgwkxmkvjnq0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darin lassen sich zwei gro√üe Teile unterscheiden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste ist die √úbermittlung von Daten an den Speicher und die √úbermittlung von Befehlen an Ger√§te. </font><font style="vertical-align: inherit;">Wenn Sie ein IoT-System erstellen, muss dieses Problem auf jeden Fall gel√∂st werden, unabh√§ngig davon, welches Projekt Sie ausf√ºhren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite arbeitet mit empfangenen Daten. </font><font style="vertical-align: inherit;">Alles √§hnelt jedem anderen Projekt, das auf der Analyse und Visualisierung von Datens√§tzen basiert. </font><font style="vertical-align: inherit;">Sie haben ein Repository mit einer anf√§nglichen Reihe von Informationen, mit denen Sie Ihre Aufgabe realisieren k√∂nnen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Teil ist in allen IoT-Systemen ungef√§hr gleich: Er basiert auf allgemeinen Prinzipien und passt in ein gemeinsames Szenario, das f√ºr die meisten IoT-Systeme geeignet ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Teil ist in Bezug auf die ausgef√ºhrten Funktionen fast immer einzigartig, obwohl er auf Standardkomponenten basiert. Gleichzeitig wird ohne ein qualitativ hochwertiges, fehlertolerantes und skalierbares Interaktionssystem mit Hardware die Effektivit√§t des analytischen Teils der Architektur auf nahezu Null reduziert, da einfach nichts zu analysieren ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund hat sich das Yandex.Cloud-Team zun√§chst darauf konzentriert, ein komfortables √ñkosystem von Diensten aufzubauen, mit dem Daten schnell, effizient und zuverl√§ssig von Ger√§ten an Speicher √ºbertragen und Befehle an Ger√§te gesendet werden k√∂nnen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/k8/ug/tqk8ugcmjnp3-s3cscc4ldhmuou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Probleme zu l√∂sen, arbeiten wir an der Funktionalit√§t und Integration von Yandex IoT Core, Yandex-Funktionen und Datenspeicherdiensten in der Cloud: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Yandex IoT Core-Dienst ist ein ausfallsicherer skalierbarer MQTT-Broker mit mehreren Mandanten und einer Reihe zus√§tzlicher n√ºtzlicher Funktionen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Yandex Cloud Functions-Dienst ist ein Vertreter der vielversprechenden Richtung ohne Server und erm√∂glicht es Ihnen, Ihren Code als Funktion in einer sicheren, fehlertoleranten und automatisch skalierbaren Umgebung auszuf√ºhren, ohne virtuelle Maschinen zu erstellen und zu warten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Object Storage ist eine effektive Speicherung gro√üer Datenfelder und eignet sich sehr gut f√ºr ‚Äûhistorische‚Äú Archivdatens√§tze.</font></font></li>
<li>          ,    ,      Yandex Managed Service for ClickHouse,     ¬´¬ª  .       ¬´¬ª      ,       ,     ,             .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es sich bei Datenspeicherungs- und Analysediensten um Allzweckdienste handelt, √ºber die bereits viel geschrieben wurde, werfen Yandex IoT Core und seine Interaktion mit Yandex Cloud-Funktionen in der Regel viele Fragen auf, insbesondere f√ºr Personen, die gerade erst anfangen, das Internet der Dinge und Cloud-Technologien zu verstehen. </font><font style="vertical-align: inherit;">Und da diese Dienste Fehlertoleranz und Skalierung der Arbeit mit Ger√§ten bieten, werden wir zuerst sehen, was sie unter der Haube haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So funktioniert Yandex IoT Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Core ist ein spezialisierter Plattformdienst f√ºr den bidirektionalen Datenaustausch zwischen der Cloud und Ger√§ten, auf denen das MQTT-Protokoll ausgef√ºhrt wird. Tats√§chlich ist dieses Protokoll zum Standard f√ºr die √úbertragung von Daten an das Internet der Dinge geworden. Es verwendet das Konzept benannter Warteschlangen (Themen), bei denen Sie einerseits Daten schreiben und andererseits asynchron empfangen k√∂nnen, indem Sie Ereignisse dieser Warteschlange abonnieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Yandex IoT Core-Dienst ist mandantenf√§hig, dh eine einzige Entit√§t, auf die alle Benutzer zugreifen k√∂nnen. Das hei√üt, alle Ger√§te und alle Benutzer interagieren mit derselben Dienstinstanz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies erm√∂glicht einerseits die Gew√§hrleistung einer einheitlichen Arbeit f√ºr alle Benutzer, andererseits eine effektive Skalierung und Fehlertoleranz, um eine Verbindung mit einer unbegrenzten Anzahl von Ger√§ten aufrechtzuerhalten und eine unbegrenzte Datenmenge sowohl in Bezug auf Volumen als auch Geschwindigkeit zu verarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daraus folgt, dass der Dienst sowohl √ºber Redundanzmechanismen als auch √ºber die F√§higkeit verf√ºgen muss, die verwendeten Ressourcen flexibel zu verwalten, um auf Last√§nderungen reagieren zu k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus erfordert die Mandantenf√§higkeit eine spezielle Logik f√ºr die gemeinsame Nutzung von Zugriffsrechten auf MQTT-Themen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie das umgesetzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie viele andere Yandex.Cloud-Dienste ist Yandex IoT Core logisch in zwei Teile unterteilt - Steuerungsebene und Datenebene:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8a/u0/f3/8au0f3pzmwa1v-hhsxikvo_l_0m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data Plane ist f√ºr die Betriebslogik unter dem MQTT-Protokoll verantwortlich, und Control Plane ist f√ºr die Abgrenzung der Zugriffsrechte auf bestimmte Themen verantwortlich und verwendet hierf√ºr die Registrierung und das Ger√§t f√ºr logische Entit√§ten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/b1/1n/eub11nm0nlmhprrhfqzohfwcyow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Yandex.Cloud-Benutzer kann √ºber mehrere Registrierungen verf√ºgen, von denen jede eine eigene Teilmenge von Ger√§ten enthalten kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zugriff auf Themen wird wie folgt bereitgestellt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/wc/hd/dfwchdy-bdwxs56mkgykrcs0ia4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ger√§te k√∂nnen Daten nur an ihr Ereignis- und Registrierungsereignisthema senden:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und abonnieren Sie nur Nachrichten aus Ihrem Befehlsthema und dem Thema Registrierungsbefehle:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Registrierung kann Daten an alle Themen der Ger√§tebefehle und an das Thema der Registrierungsbefehle senden:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und abonnieren Sie Nachrichten zu allen Themen von Ger√§teereignissen und zum Thema Registrierungsereignisse:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um mit allen oben beschriebenen Entit√§ten arbeiten zu k√∂nnen, verf√ºgt Data Plane √ºber ein gRPC-Protokoll und ein REST-Protokoll, auf deren Grundlage der Zugriff √ºber die GUI-Konsole von Yandex.Cloud und die CLI-Befehlszeilenschnittstelle erfolgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datenebene unterst√ºtzt das MQTT-Protokoll Version 3.1.1. </font><font style="vertical-align: inherit;">Es gibt jedoch mehrere Funktionen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie beim Herstellen der Verbindung unbedingt TLS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird nur die TCP-Verbindung unterst√ºtzt. </font><font style="vertical-align: inherit;">WebSocket ist noch nicht verf√ºgbar.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Autorisierung ist sowohl √ºber die Anmeldung und das Kennwort (wobei die Anmeldung die Ger√§te- oder Registrierungs-ID ist und die Kennw√∂rter vom Benutzer festgelegt werden) als auch √ºber Zertifikate m√∂glich.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Beibehaltungsflag wird nicht unterst√ºtzt, wenn der MQTT-Broker die mit dem Flag gekennzeichnete Nachricht speichert und sie beim n√§chsten Abonnieren des Themas sendet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persistente Sitzung wird nicht unterst√ºtzt, in der der MQTT-Broker Informationen √ºber den Client (Ger√§t oder Registrierung) speichert, um die erneute Verbindung zu erleichtern.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Abonnieren und Ver√∂ffentlichen werden nur die ersten beiden Serviceebenen unterst√ºtzt:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS0 - h√∂chstens einmal. </font><font style="vertical-align: inherit;">Es gibt keine Zustellgarantie, aber keine erneute Zustellung derselben Nachricht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS1 - Mindestens einmal. </font><font style="vertical-align: inherit;">Die Zustellung ist garantiert, es besteht jedoch die M√∂glichkeit, dass dieselbe Nachricht erneut empfangen wird.</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Verbindung zu Yandex IoT Core zu vereinfachen, f√ºgen wir unserem Repository auf GitHub regelm√§√üig neue Beispiele f√ºr verschiedene Plattformen und Sprachen hinzu und beschreiben Skripte in der Dokumentation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Servicearchitektur sieht folgenderma√üen aus: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/ig/4o/6gig4ofj7dksmbn18wvq5swkpuo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gesch√§ftslogik des Service besteht aus vier Teilen:</font></font><br>
<br>
<ol>
<li> Device management ‚Äî     .   Control Plane.</li>
<li> MQTT Broker ‚Äî  MQTT-.  Data Plane.</li>
<li> Triggers ‚Äî     Yandex Cloud Functions.  Data Plane.</li>
<li> Shards ‚Äî      MQTT-    .  Data Plane.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Interaktion mit der "Au√üenwelt" erfolgt √ºber Load Balancer. Dar√ºber hinaus wird gem√§√ü der Hundefutterphilosophie Yandex Load Balancer verwendet, der allen Yandex.Cloud-Benutzern zur Verf√ºgung steht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Teil der Gesch√§ftslogik besteht aus mehreren S√§tzen von drei virtuellen Maschinen - eine in jeder Verf√ºgbarkeitszone (in Schema A, B und C). Virtuelle Maschinen sind genau die gleichen wie alle Yandex.Cloud-Benutzer. Wenn die Last zunimmt, erfolgt die Skalierung mit Hilfe des gesamten Satzes - drei Maschinen werden gleichzeitig im Rahmen eines Teils der Gesch√§ftslogik hinzugef√ºgt. Dies bedeutet, dass, wenn ein Satz von drei MQTT Broker-Maschinen die Last nicht bew√§ltigen kann, ein weiterer Satz von drei MQTT Broker-Maschinen hinzugef√ºgt wird, w√§hrend die Konfiguration anderer Teile der Gesch√§ftslogik gleich bleibt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und nur Logbroker ist nicht √∂ffentlich verf√ºgbar. Es ist ein Dienst f√ºr einen effizienten ausfallsicheren Betrieb mit Datenstr√∂men. Es basiert auf Apache Kafka, bietet jedoch viele weitere n√ºtzliche Funktionen: Es implementiert Disaster Recovery-Prozesse (einschlie√ülich genau einmaliger Semantik, wenn Sie eine Garantie f√ºr die Nachrichten√ºbermittlung ohne Duplizierung haben) und Serviceprozesse (z. B. zentrums√ºbergreifende Replikation, Datenverteilung an) Berechnungscluster) und verf√ºgt au√üerdem √ºber einen Mechanismus f√ºr die einheitliche, nicht doppelte Verteilung von Daten zwischen Flow-Teilnehmern - eine Art Load Balancer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ger√§teverwaltungsfunktionen in der Steuerungsebene sind oben beschrieben. Aber mit Data Plane ist alles viel interessanter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Instanz von MQTT Broker arbeitet unabh√§ngig und wei√ü nichts √ºber andere Instanzen. Alle empfangenen Daten (von Kunden ver√∂ffentlichen) werden von Brokern an Logbroker gesendet, von wo sie von Shards and Triggers abgeholt werden. Und in Shards findet die Synchronisation zwischen Instanzen von Brokern statt. Shards kennen alle MQTT-Clients und die Verteilung ihrer Abonnements (Subscribe) auf Instanzen von MQTT-Brokern und bestimmen, wohin die empfangenen Daten gesendet werden sollen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispielsweise hat der MQTT-Client A das Thema von Broker A abonniert, und der MQTT-Client B hat dasselbe Thema von Broker B abonniert. Wenn der MQTT-Client C das gleiche Thema ver√∂ffentlicht, jedoch an Broker C, √ºbertr√§gt der Shard Daten von Broker C an Broker A und B, wodurch die Daten sowohl vom MQTT-Client A als auch vom MQTT-Client B empfangen werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/dv/dz/iadvdzgd2cs6o1r3stjkqfhsq6y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Teil der Gesch√§ftslogik, Trigger, empf√§ngt auch alle von MQTT-Clients empfangenen Daten und √ºbertr√§gt sie, wenn dies vom Benutzer konfiguriert wird, an die Trigger des Yandex Cloud Functions-Dienstes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, verf√ºgt Yandex IoT Core √ºber eine ziemlich komplizierte Architektur und Arbeitslogik, die bei lokalen Installationen nur schwer zu wiederholen ist. </font><font style="vertical-align: inherit;">Dies erm√∂glicht es ihm, dem Verlust von sogar zwei der drei Verf√ºgbarkeitszonen standzuhalten und eine unbegrenzte Anzahl von Verbindungen und unbegrenzten Datenmengen zu ermitteln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus ist all diese Logik dem Benutzer ‚Äûunter der Haube‚Äú verborgen, aber von au√üen sieht alles sehr einfach aus - als ob Sie mit einem einzelnen MQTT-Broker arbeiten w√ºrden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trigger und Yandex Cloud-Funktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Cloud Functions ist ein Vertreter der sogenannten "serverlosen" (serverlosen) Dienste in Yandex.Cloud. Das Wesentliche an solchen Diensten ist, dass der Benutzer seine Zeit nicht damit verbringt, die Umgebung einzurichten, bereitzustellen und zu skalieren, um Code auszuf√ºhren, sondern sich nur mit dem f√ºr ihn Wertvollsten befasst - dem Schreiben des Codes selbst, der die erforderliche Aufgabe ausf√ºhrt. Bei Funktionen ist dies der sogenannte atomare zustandslose Code, der durch ein Ereignis ausgel√∂st werden kann. "Atomic" und "zustandslos" bedeuten, dass dieser Code eine relativ kleine, aber integrale Aufgabe ausf√ºhren sollte, w√§hrend der Code keine Variablen verwenden sollte, um Werte zwischen Aufrufen zu speichern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt verschiedene M√∂glichkeiten, Funktionen aufzurufen: einen direkten HTTP-Aufruf, einen Timer-Aufruf (cron) oder ein Ereignisabonnement. Als letzteres unterst√ºtzt der Dienst bereits das Abonnieren von Nachrichtenwarteschlangen (Yandex Message Queue), vom Objektspeicherdienst generierte Ereignisse und (f√ºr das IoT-Szenario am wertvollsten) das Abonnieren von Nachrichten in Yandex IoT Core.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass Sie mit Yandex IoT Core mit jedem MQTT-kompatiblen Client arbeiten k√∂nnen, ist Yandex Cloud Functions eine der optimalsten und bequemsten M√∂glichkeiten, Daten zu empfangen und zu verarbeiten. Der Grund daf√ºr ist sehr einfach. Eine Funktion kann f√ºr jede eingehende Nachricht von jedem Ger√§t aufgerufen werden, und die Funktionen werden parallel zueinander ausgef√ºhrt (aufgrund der Atomizit√§t und des zustandslosen Ansatzes), und die Anzahl ihrer Anrufe √§ndert sich nat√ºrlich, wenn sich die Anzahl der eingehenden Nachrichten von Ger√§ten √§ndert. Somit kann der Benutzer die Probleme beim Einrichten der Infrastruktur vollst√§ndig ignorieren, und im Gegensatz zu denselben virtuellen Maschinen erfolgt die Zahlung nur f√ºr die tats√§chlich ausgef√ºhrte Arbeit.Auf diese Weise k√∂nnen Sie bei geringer Last erheblich sparen und mit dem Wachstum klare und vorhersehbare Kosten erzielen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Mechanismus zum Aufrufen von Funktionen f√ºr Ereignisse (Abonnieren von Ereignissen) wird als Trigger (Trigger) bezeichnet. Das Wesentliche ist im Diagramm dargestellt: Ein </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/yv/bn/5uyvbnyviueygxt4ykzdh9n2nug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dienst, der Ereignisse zum Aufrufen von Funktionen generiert, stellt diese in eine Warteschlange in Logbroker. Im Fall von Yandex IoT Core tun dies Trigger aus der Datenebene. Ferner werden diese Ereignisse vom Pr√§prozessor erfasst, der nach einem Datensatz in der Datenbank f√ºr dieses Ereignis sucht, der die aufzurufende Funktion angibt. Wenn ein solcher Eintrag gefunden wird, stellt der Pr√§prozessor die Informationen √ºber den Funktionsaufruf (Funktions-ID und Aufrufparameter) in die Warteschlange des Yandex Message Queue-Dienstes, von wo aus der Anrufbearbeiter sie abholt. Der Handler sendet seinerseits eine HTTP-Anforderung zum Aufrufen der Funktion an den Yandex Cloud Functions-Dienst.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig wird wiederum gem√§√ü der Hundefutterphilosophie der Yandex Message Queue-Dienst verwendet, auf den alle Benutzer zugreifen k√∂nnen, und die Funktionen werden genauso aufgerufen, wie alle anderen Benutzer ihre Funktionen aufrufen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns ein paar Worte zur Yandex Message Queue sagen. Trotz der Tatsache, dass dies wie Logbroker ein Warteschlangendienst ist, gibt es einen signifikanten Unterschied zwischen ihnen. Bei der Verarbeitung von Nachrichten aus Warteschlangen informiert der Handler die Warteschlange dar√ºber, dass sie beendet wurde, und die Nachricht kann gel√∂scht werden. Dies ist ein wichtiger Zuverl√§ssigkeitsmechanismus in solchen Diensten, erschwert jedoch die Logik der Arbeit mit Nachrichten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Yandex-Nachrichtenwarteschlange k√∂nnen Sie die Verarbeitung jeder Nachricht in der Warteschlange "parallelisieren". Mit anderen Worten, die Nachricht aus der Warteschlange, die gerade verarbeitet wird, blockiert nicht die M√∂glichkeit eines anderen "Threads", das n√§chste Ereignis zur Verarbeitung aus der Warteschlange aufzunehmen. Dies wird als Parallelit√§t auf Nachrichtenebene bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und LogBroker bearbeitet Nachrichtengruppen, und bis die gesamte Gruppe verarbeitet ist, kann die n√§chste Gruppe nicht zur Verarbeitung abgeholt werden. Dieser Ansatz wird auf Partitionsebene als Parallelit√§t bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und genau die Verwendung der Yandex Message Queue erm√∂glicht es Ihnen, viele Anforderungen zum Aufrufen von Funktionen f√ºr Ereignisse eines bestimmten Dienstes schnell und effizient parallel zu verarbeiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass Trigger eine separate unabh√§ngige Einheit sind, sind sie Teil des Yandex Cloud Functions-Dienstes. Wir m√ºssen nur genau herausfinden, wie die Funktionen aufgerufen werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/ew/ke/fbewkedbrp6eyri7zkubwiu6dzu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Anforderungen zum Aufrufen von Funktionen (sowohl externe als auch interne) fallen in den Load Balancer, der sie an Router in verschiedenen Zugriffszonen (AZ) verteilt. In jeder Zone werden mehrere Teile bereitgestellt. Nach Erhalt einer Anforderung geht der Router zun√§chst zum IAM-Dienst (Identity and Access Manager), um sicherzustellen, dass die Anforderungsquelle √ºber die Berechtigung zum Aufrufen dieser Funktion verf√ºgt. Dann wendet er sich an den Scheduler und fragt, auf welchem ‚Äã‚ÄãWorker die Funktion ausgef√ºhrt werden soll. Worker ist eine virtuelle Maschine mit einer angepassten Laufzeit isolierter Funktionen. Ferner sendet der Router, der vom Scheduler die Adresse des Workers erhalten hat, auf dem die Funktion ausgef√ºhrt werden soll, einen Befehl an diesen Worker, um die Funktion mit bestimmten Parametern zu starten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Woher kommt der Arbeiter? Hier geschieht die ganze Magie ohne Server. Scheduler analysieren die Last (Anzahl und Dauer der Funktionen) und verwalten (starten und stoppen) virtuelle Maschinen mit einer bestimmten Laufzeit. NodeJS und Python werden jetzt unterst√ºtzt. Und hier ist ein Parameter extrem wichtig - die Geschwindigkeit des Startens von Funktionen. Das Service-Entwicklungsteam hat gro√üartige Arbeit geleistet, und jetzt startet die virtuelle Maschine in maximal 250 ms, w√§hrend die sicherste Umgebung zum Isolieren von Funktionen voneinander verwendet wird - die QEMU-Virtualisierung, auf der die gesamte Yandex. Cloud ausgef√ºhrt wird. Wenn gleichzeitig bereits ein Mitarbeiter f√ºr die eingehende Anforderung vorhanden ist, wird die Funktion fast sofort gestartet.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entsprechend dem gleichen Hundefutter-Ansatz verwendet der Load Balancer einen √∂ffentlichen Dienst, auf den alle Benutzer zugreifen k√∂nnen, und der Worker, der Scheduler und der Router sind normale virtuelle Maschinen, genau wie alle Benutzer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit wird die Fehlertoleranz des Dienstes auf der Ebene des Load Balancers und der Redundanz der wichtigsten Systemkomponenten (Router und Scheduler) implementiert, und die Skalierung erfolgt aufgrund der Bereitstellung oder Reduzierung der Anzahl der Mitarbeiter. </font><font style="vertical-align: inherit;">Dar√ºber hinaus arbeitet jede Zug√§nglichkeitszone unabh√§ngig voneinander, wodurch der Verlust von sogar zwei der drei Zonen √ºberlebt werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ºtzliche Links</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abschlie√üend m√∂chte ich einige Links geben, mit denen Sie die Dienste genauer untersuchen k√∂nnen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Core: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud.yandex.ru/services/iot-core</font></font></a> </li>
<li> Yandex Cloud Functions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.yandex.ru/services/functions</a> </li>
<li> Yandex Message Queue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.yandex.ru/services/message-queue</a> </li>
<li> Yandex Managed Service for ClickHouse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.yandex.ru/services/managed-clickhouse</a> </li>
<li> Yandex Load Balancer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.yandex.ru/services/load-balancer</a> </li>
<li> Yandex Object Storage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.yandex.ru/services/storage</a> </li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491724/index.html">Das Buch "Laravel. Komplette Anleitung. 2. Auflage</a></li>
<li><a href="../de491726/index.html">Erweitern Sie verschachtelte Spalten - Listen mit der R-Sprache (tidyr-Paket und unnest Familienfunktionen)</a></li>
<li><a href="../de491728/index.html">TROCKENES Prinzip mit Laravel</a></li>
<li><a href="../de491732/index.html">Gibt es ein Leben nach Scratch oder wie man ein Kind in Python einf√ºhrt?</a></li>
<li><a href="../de491736/index.html">TMS1000: der erste im Handel erh√§ltliche Mikrocontroller</a></li>
<li><a href="../de491742/index.html">Sorbet: Ergonomische Gaming-Tastatur</a></li>
<li><a href="../de491744/index.html">Iranische Hacker nutzten Schwachstellen in VPN aus</a></li>
<li><a href="../de491746/index.html">Die Geschichte der Sprachsynthese: die √Ñra der elektrischen L√∂sungen</a></li>
<li><a href="../de491748/index.html">Technologien, die Blinden helfen, Englisch zu lernen</a></li>
<li><a href="../de491780/index.html">GitLab 12.8 mit Log Browser, NuGet und Compliance Dashboard ver√∂ffentlicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>