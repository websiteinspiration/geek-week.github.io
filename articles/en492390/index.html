<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖøÔ∏è üîª üçù War on the brakes. Optimizing the number of component renderings in React Native üéª ‚úñÔ∏è üë©üèª‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! My name is Kamo Spertsyan, I am engaged in React Native development at Profi.ru. If you decide to use React Native technology to quickly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>War on the brakes. Optimizing the number of component renderings in React Native</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492390/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! My name is Kamo Spertsyan, I am engaged in React Native development at Profi.ru. If you decide to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use React Native technology</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to quickly deliver product features and focus on development speed, then you are likely to run into performance issues. At least that's what happened to us. After six months of active development, the performance of our application fell below a critical level - everything was wildly slow. Therefore, we took up the optimization - removed all the ‚Äúbrakes‚Äù during startup, transitions between screens, rendering screens, reactions to user actions. As a result, in three months they brought the user experience to the native level. In this article I want to talk about how we optimized the application on React Native and solved the problem of multiple component renders.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/qy/9b/tvqy9bo_jyqc4cz044_gneepvmw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I put together recommendations that will help minimize the number of pointless redraws of components. </font><font style="vertical-align: inherit;">For clarity, in the examples I compare the ‚Äúbad‚Äù and ‚Äúgood‚Äù implementations. </font><font style="vertical-align: inherit;">The article will be useful to those who are already faced with poor application performance, and those who do not want to allow this in the future. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We use React Native paired with Redux. </font><font style="vertical-align: inherit;">Some of the tips are related to this library. </font><font style="vertical-align: inherit;">Also in the example, I use the Redux-thunk library - to simulate working with the network.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When to think about performance?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, it is worth remembering from the very beginning of work on the application. But if your application is already slowing down - do not despair, everything can be fixed. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everyone knows, but just in case, I‚Äôll mention: it‚Äôs better to check performance on weak devices. If you are developing on powerful devices, you may not be aware of the ‚Äúbrakes‚Äù of end users. Decide for yourself the devices you will be guided by. Measure time or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in control plots to compare with results after optimization.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React Native out of the box provides the ability to measure FPS applications through Developer Tools ‚Üí Show perf monitor. </font><font style="vertical-align: inherit;">The reference value is 60 frames per second. </font><font style="vertical-align: inherit;">The lower this indicator, the stronger the application "slows down" - does not respond or reacts with a delay to user actions. </font><font style="vertical-align: inherit;">One of the main effects on FPS is the number of renders, the ‚Äúseverity‚Äù of which depends on the complexity of the components.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example description</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I show all the recommendations on the example of a simple application with a list of news. </font><font style="vertical-align: inherit;">The application has one screen, which is located </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the news. </font><font style="vertical-align: inherit;">A news item is a component </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that consists of two smaller components - the headline ( </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and the body ( </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">The entire example can be seen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Further in the text are links to various branches of the repository for specific examples. </font><font style="vertical-align: inherit;">The repository is used for the convenience of readers who want to explore examples more deeply. </font><font style="vertical-align: inherit;">The code in the repository and examples below does not claim to be perfect - it is needed solely for demonstration purposes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Below, all components are schematically shown with links and props.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/ng/z6/d9ngz6hldmphbkjky1a-7-38nlq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the render method of each component, I added the output to the console of unique information about it: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_{no}<font></font>
ITEM_TITLE_{no}<font></font>
ITEM_BODY_{no}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where </font></font><code>{no}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the news serial number in order to distinguish between different news renderings from multiple renderings of the same one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For testing on each </font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">news list, additional news is added to its beginning. </font><font style="vertical-align: inherit;">At the same time, the following message is displayed in the console:</font></font><br>
<br>
<pre><code class="plaintext hljs">--------------[ REFRESHING ]--------------</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These records will help to understand if there is a problem in any particular component, and later to determine whether it was possible to optimize it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If implemented correctly, our log after launch and several updates should look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_4<font></font>
ITEM_TITLE_4<font></font>
ITEM_BODY_4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the first start, the screen itself and two initial news are drawn. </font><font style="vertical-align: inherit;">When updating the board, the screen is rendered again, because its data has really changed. </font><font style="vertical-align: inherit;">More news comes up. </font><font style="vertical-align: inherit;">All previous news is not redrawn, as there was no change in their data.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When is a component rendered?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In React and React Native, there are two conditions for rendering a component:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changing his props / state,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">render of the parent component.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A function can be redefined in a component </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it receives new Props and State as an input and tells whether the component should be rendered. Often, to avoid unnecessary re-renders, a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shallow compare</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of Props and State objects is enough. For example, this eliminates unnecessary renders when the parent component changes, if they do not affect the child component. In order not to write a surface comparison manually each time, you can inherit a component from </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that encapsulates this check. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we use the connect link function, the Redux library creates a new component that is ‚Äúconnected‚Äù to the global State. Changes to this State trigger a method</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which returns new props. </font><font style="vertical-align: inherit;">Next, a comparison of old and new props starts, regardless of whether the component was declared as </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider these nuances in our example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let the </font><font style="vertical-align: inherit;">component </font><font style="vertical-align: inherit;">pass through </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inherit from </font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- from </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full example code</font></font></a><br>
<br>
<pre><code class="plaintext hljs">export class NewsItemTitle extends React.Component<font></font>
export class NewsItemBody extends React.PureComponent</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what the log will look like after one board update:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can see that the news and headline components are redrawn. </font><font style="vertical-align: inherit;">We will consider them in turn. </font></font><br>
<br>
<code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declared using </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As a props, this component receives an identifier, by which it subsequently receives news in </font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({<font></font>
  item: state.newsMap[ownProps.itemKey],<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since when updating the board all the news is downloaded again, the object will </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">update and afterwards will refer to various memory cells. In other words, they will be different objects, even if all the contained fields are the same. Therefore, a comparison of the previous and new State'ov component returns </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The component will be re-rendered, despite the fact that in fact the data has not changed. </font></font><br>
<br>
<code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is inherited from </font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so it is re-rendered every time the parent component is rendered. This happens regardless of the values ‚Äã‚Äãof old and new props. </font></font><br>
<br>
<code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inherited from </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so it compares old and new props. In news 1 and 2, their values ‚Äã‚Äãare equivalent, therefore the component is rendered only for news 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To optimize the renderings</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just declare it as </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the case of, you have </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to redefine the function </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return !shallowEqual(this.props.item, nextProps.item);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full example code</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Here </font></font><code>shallowEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a feature for surface comparison of objects that Redux provides. </font><font style="vertical-align: inherit;">You can write like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return (<font></font>
    this.props.item.title !== nextProps.item.title ||<font></font>
    this.props.item.body !== nextProps.item.body<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what our log will look like after this: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><div class="spoiler_text"> <code>shouldComponentUpdate</code>  <code>NewsItem</code> ,  <code>NewsItemTitle</code>   .        . <code>NewsItemTitle</code>    -         <code>NewsItem</code>,     .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo and functional components</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not possible to </font><font style="vertical-align: inherit;">override </font><font style="vertical-align: inherit;">in a functional component. </font><font style="vertical-align: inherit;">But this does not mean that in order to optimize a functional component, you have to rewrite it into a class one. </font><font style="vertical-align: inherit;">For such cases, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memoization function is </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">provided</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It accepts a component input and an optional comparison function </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When called, it </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets old and new props and should return the result of the comparison. </font><font style="vertical-align: inherit;">The difference with </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should return </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if the props are equal, and not vice versa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoization may look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">areEqual(prevProps, nextProps) {<font></font>
  return shallowEqual(prevProps, nextProps);<font></font>
}<font></font>
export OptimizedNewsItemTitle = React.memo(NewsItemTitle, areEqual)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you do not pass </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>React.memo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then a superficial comparison of props will be made, so our example can be simplified:</font></font><br>
<br>
<pre><code class="plaintext hljs">export OptimizedNewsItemTitle = React.memo(NewsItemTitle)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lambda functions in props</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To process component events, functions can be passed to its props. </font><font style="vertical-align: inherit;">The most striking example is implementation </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Often anonymous lambda functions are used for this. </font><font style="vertical-align: inherit;">Let's say in </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we want to show only the preview, and if you click on it - the whole text. </font><font style="vertical-align: inherit;">To do this, when rendering </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in, </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will pass the following prop:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={() =&gt; this.props.expandBody()}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what the log looks like with this implementation when the method </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deleted:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
News bodies 1 and 2 are rendered, although their data has not changed, but </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is due to the fact that for each render the </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value of props </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is created anew. </font><font style="vertical-align: inherit;">Technically, </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with each render, it points to a new area in memory, so a superficial comparison of props in </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns false. </font><font style="vertical-align: inherit;">The problem is fixed by the following entry:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={this.props.expandBody}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Log: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full example code</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Unfortunately, an anonymous function can by no means always be rewritten as a method or a class field for such a record. The most common case is when inside the lambda function the scope variables of the function in which it is declared are used. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider this case in our example. To switch from the general list to the screen of one news, we add the processing of clicking on the body of the news. The </font></font><code>renderItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">component </font><font style="vertical-align: inherit;">method </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={() =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An anonymous function </font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cannot be declared in a class, because then the variable </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is needed to go to a specific news </font><font style="vertical-align: inherit;">will disappear from the scope </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest solution to the problem is to change the signature of the </font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">component </font><font style="vertical-align: inherit;">props </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that the required parameter is passed to the function when called. </font><font style="vertical-align: inherit;">In this case, this is the news identifier.</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={item =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, we can already take out the anonymous function in the component class method.</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={this.onItemBodyPress}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, such a solution will require us to change the component </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">class NewsItemComponent extends React.Component {<font></font>
render() {<font></font>
  ...<font></font>
  return (<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={() =&gt; this.props.onBodyPress(this.props.item)}<font></font>
        ...<font></font>
      /&gt;<font></font>
      ...<font></font>
  );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And again we return to the indicated problem - we pass a new lambda function to the child component for each render of the parent. </font><font style="vertical-align: inherit;">Only now have we gone down a level. </font><font style="vertical-align: inherit;">Log:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To get rid of this problem at the root, you can use the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useCallback</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hook </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It allows memoizing a function call with passing an argument. </font><font style="vertical-align: inherit;">If the argument of the function does not change, then the result of the call </font></font><code>useCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will point to the same area of ‚Äã‚Äãmemory. </font><font style="vertical-align: inherit;">In our example, this means that when redrawing the same news, the prop </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">component </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will not change. </font><font style="vertical-align: inherit;">Hooks can only be used in functional components, so the final look of the component </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be as follows:</font></font><br>
<br>
<pre><code class="plaintext hljs">function NewsItemComponent(props) {<font></font>
  ...<font></font>
  const {itemKey, onBodyPress} = props.item;<font></font>
  const onPressBody = useCallback(() =&gt; onBodyPress(itemKey), [itemKey, onBodyPress]);<font></font>
  return (<font></font>
    &lt;View&gt;<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={onPressBody}<font></font>
        ...<font></font>
      /&gt;<font></font>
    &lt;/View&gt;<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the log: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full example code</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays and objects</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JavaScript, functions are represented as objects, along with arrays. </font><font style="vertical-align: inherit;">Therefore, the example from the previous block is a special case of creating a new object in props. </font><font style="vertical-align: inherit;">It is quite common, so I put it in a separate paragraph. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any creation of new functions, arrays or objects in props leads to a component re-renderer. </font><font style="vertical-align: inherit;">Consider this rule in the following example. </font><font style="vertical-align: inherit;">Let's pass in a </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combined style of two values:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  style={[styles.body, styles.item]}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And again, the log shows the extra component renderers:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve this problem, you can select a separate style that will combine </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or, for example, move the declaration of the array </font></font><code>[styles.body, styles.item]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into a global variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full example code</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array reducers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider another popular source of ‚Äúbrakes‚Äù associated with use </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A classic application that contains a long list of items from the server implements pagination. </font><font style="vertical-align: inherit;">That is, it loads a limited set of elements in the form of the first page, when the list of current elements ends, it loads the next page, and so on. </font><font style="vertical-align: inherit;">An item list reducer might look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When each next page loads in the application‚Äôs style, a new array of identifiers is created. </font><font style="vertical-align: inherit;">If we pass this array to props later </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on, here is what the component render logs will look like:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this example, I made a few changes in the test application.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set the page size to 10 news.</font></font></li>
<li>   <code>item</code>   <code>NewsItem</code>  <code>FlatList</code>-,        connect. <code>NewsItem</code>    <code>React.Component</code>    .</li>
<li>     .</li>
<li>       .       ‚Ññ1     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The example shows that when each next page loads, all the old elements are rendered again, then the old elements and the elements of the new page are rendered again. For mathematics lovers: if the page size is equal </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then when the </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ith page is </font><font style="vertical-align: inherit;">loaded, </font><font style="vertical-align: inherit;">instead of rendering only </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new elements, the elements are rendered </font></font><code>(i - 1) * X + i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúOk,‚Äù you say, ‚ÄúI understand why all the elements are drawn after adding a new page: the reducer returned a new array, a new area of ‚Äã‚Äãmemory, all that. But why do we need to render the old list before adding new elements? ‚Äù ‚ÄúGood question,‚Äù I will answer you. This is a consequence of working with the state of the component </font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on whose basis</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I will not go into details, as they pull on a separate article. </font><font style="vertical-align: inherit;">Who cares, I advise you to delve into the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to get rid of such non-optimality? </font><font style="vertical-align: inherit;">We rewrite the reducer so that he does not return a new array for each page, but adds elements to the existing one:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention! </font><font style="vertical-align: inherit;">Antipattern!</font></font></b><div class="spoiler_text">          .     ,    , ,  <code>PureComponent</code>,          .      ,             .      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"> Redux</a>.<br>
</div></div><br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    action.news.forEach(item =&gt; state.push(item.key));<font></font>
    return state;<font></font>
    // return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, our log will look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We got rid of the rendering of old elements </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">before</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adding elements to a new page, but old elements are still drawn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> updating the list. The number of renderings for the next page is now equal </font></font><code>i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The formula has become simpler, but we will not stop there. We only have </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new elements, and we only want </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new renders. We will use the already familiar tricks to remove news renders that have not changed props. Return connect to </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;11..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;21..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fine! Now we can be satisfied with ourselves. There is nowhere to optimize. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full example code</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
An attentive reader will indicate that after applying connect to the </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log, it will look like in the last example, no matter how you implement the reducer. And it will be right - if the news component checks its props before rendering, it does not matter if the old array is used by the reducer or it creates a new one. Only new elements are drawn and only once. However, changing the old array instead of creating a new one saves us from unnecessary renderings of the component </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used in it </font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and unnecessary iterations of props equivalence checks </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. With a large number of elements, this also gives a performance increase.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Use mutable arrays and objects in reducers should be with extreme caution. </font><font style="vertical-align: inherit;">In this example, this is justified, but if you have, say, normal </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then when you add elements to the mutable array, the components will not be rendered. </font><font style="vertical-align: inherit;">Its props in fact remain unchanged, since before and after updating the array points to the same memory area. </font><font style="vertical-align: inherit;">This can lead to unexpected consequences. </font><font style="vertical-align: inherit;">No wonder the described example violates the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principles of Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And something else...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you use presentation-level libraries, I advise you to make sure that you understand in detail how they are implemented. </font><font style="vertical-align: inherit;">In our application, we use a component </font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the library </font></font><code>react-native-gesture-handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It allows you to implement a block of additional actions when swiping a card from the list. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In code, it looks like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;Swipeable<font></font>
  ...<font></font>
  renderRightActions={this.renderRightActions}<font></font>
  ...<font></font>
&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Method </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>renderLeftActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the component that is displayed after the swipe. We determined and changed the height of the panel during the change of components in order to fit the necessary content. This is a resource-intensive process, but if it occurs during the swipe animation, the user does not see interference.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/n1/vg/wzn1vghiy6-wjclqcy8itdy1fns.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is that the component </font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calls the method </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the time of rendering the main component. All calculations and even rendering of the action bar, which is not visible before the swipe, occur in advance. So, all these actions are performed for all cards in the list at the same time. This caused significant ‚Äúbrakes‚Äù when scrolling the board. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem was solved in the following way. If the action panel is drawn together with the main component, and not as a result of the swipe, then the method </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns empty the </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size of the main component. Otherwise, we draw the panel of additional actions as before.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I give this example because supporting libraries do not always work as you expect. </font><font style="vertical-align: inherit;">And if these are presentation-level libraries, then it is better to make sure that they are not wasting unnecessary resources.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After eliminating the problems described in the article, we significantly accelerated the application on React Native. </font><font style="vertical-align: inherit;">Now it is difficult to distinguish it in performance from a similar one, implemented natively. </font><font style="vertical-align: inherit;">Excess renders slowed down both the loading of individual screens and the reaction to user actions. </font><font style="vertical-align: inherit;">Most of all, it was noticeable on the lists, where dozens of components are drawn at once. </font><font style="vertical-align: inherit;">We have not optimized everything, but the main screens of the application no longer slow down. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main points of the article are briefly listed below.</font></font><br>
<br>
<ol>
<li> React Native      :  Props/State-     .</li>
<li>,   <code>React.PureComponent</code>,     ,       .</li>
<li>    ,    <code>shouldComponentUpdate</code>      <code>React.Memo</code>   .</li>
<li>-        .      ,         (shallow compare).               ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supporting presentation-level libraries can lead to unexpected waste of resources. </font><font style="vertical-align: inherit;">It is worth being careful in their application.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all. </font><font style="vertical-align: inherit;">I hope you find the information useful. </font><font style="vertical-align: inherit;">I will be glad to any feedback!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful sources</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Understanding Rendering in React + Redux</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparing Objects in JavaScript</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improving Performance in React Functional Components using React.memo ()</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How Discord achieves native iOS performance with React Native</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492374/index.html">Experiment: Redux from the OOP world</a></li>
<li><a href="../en492376/index.html">How to make your article or documentation understand quickly and accurately</a></li>
<li><a href="../en492378/index.html">Reactjs, Material-UI with JSS. Short guide</a></li>
<li><a href="../en492384/index.html">Hack The Box - Postman Walkthrough Redis and WebMin</a></li>
<li><a href="../en492386/index.html">How the IT sector helps the world throw less food</a></li>
<li><a href="../en492392/index.html">IntelliJ IDEA Tips & Tricks: 3. Customizing the code style for each folder</a></li>
<li><a href="../en492394/index.html">Dark Universe. Part 2</a></li>
<li><a href="../en492396/index.html">Why did we mess up the indicator LEDs and what needs to be changed</a></li>
<li><a href="../en492398/index.html">We configure our devices for remote work, podcasting, video and streaming</a></li>
<li><a href="../en492404/index.html">Flutter + arduino nano 33 BLE sense = very simple BLE sensor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>