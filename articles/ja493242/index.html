<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👄 🔒 👨🏿‍🤝‍👨🏼 HTTP文字列高速処理アルゴリズム 🕦 👩🏽‍🔧 ♊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="標準ヘッダーの圧縮はHTTP / 2で登場しましたが、URI本体、Cookie、User-Agent値は依然として数十キロバイトになり、トークン化、検索、サブストリングの比較が必要になる場合があります。HTTPパーサーが大量の悪意のあるトラフィックを処理する必要がある場合、タスクは重要になります。標...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HTTP文字列高速処理アルゴリズム</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ヘッダーの圧縮はHTTP / 2で登場しましたが、URI本体、Cookie、User-Agent値は依然として数十キロバイトになり、トークン化、検索、サブストリングの比較が必要になる場合があります。</font><font style="vertical-align: inherit;">HTTPパーサーが大量の悪意のあるトラフィックを処理する必要がある場合、タスクは重要になります。</font><font style="vertical-align: inherit;">標準ライブラリは広範な文字列処理ツールを提供しますが、HTTP文字列には独自の特性があります。</font><font style="vertical-align: inherit;">Tempesta FW HTTPパーサーが開発されたのは、この特異性のためです。</font><font style="vertical-align: inherit;">そのパフォーマンスは、最新のオープンソースソリューションに比べて数倍高く、最速を超えています。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレクサンドル・クリザノフスキー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリザノフスキー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）Linux / x86-64でのハイパフォーマンスコンピューティングのエキスパートである創設者兼システムアーキテクトTempesta Technologies。アレクサンダーは、HTTP文字列の構造の特殊性について話し、標準ライブラリがそれらを処理するのに適さない理由を説明し、Tempesta FWソリューションを提示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンダーザカット：HTTP FloodがHTTPパーサーをボトルネックに変える方法、ブランチの予測ミス、キャッシュ、および典型的なHTTPパーサータスクのメモリ不足によるx86-64の問題、FSMと直接ジャンプ、GCC最適化、自動ベクトル化、strspn（）との比較およびstrcasecmp（）-HTTP文字列、SSE、AVX2のようなアルゴリズム、およびAVX2を使用したインジェクション攻撃のフィルタリング。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta Technologiesでは、カスタムソフトウェアを開発しています。高性能に関連する複雑な領域を専門としています。</font><font style="vertical-align: inherit;">特に、Positive Technologiesの最初のバージョンWAFのコアの開発に誇りを持っています。</font><font style="vertical-align: inherit;">Webアプリケーションファイアウォール（WAF）はHTTPプロキシです。攻撃（WebおよびDDoS）のHTTPトラフィックの非常に詳細な分析を処理します。</font><font style="vertical-align: inherit;">そのための最初のコアを書きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンサルティングに加えて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を開発してい</font><font style="vertical-align: inherit;">ます。これはApplication Delivery Controller（ADC）です。</font><font style="vertical-align: inherit;">私たちは彼について話します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション配信コントローラー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application Delivery Controllerは、機能が強化されたHTTPプロキシです。</font><font style="vertical-align: inherit;">ただし、セキュリティに関連する機能、つまりDDoSとWeb攻撃のフィルタリングについて説明します。</font><font style="vertical-align: inherit;">また、制限についても触れ、作業と機能をコード例とともに示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FWはLinux TCP / IP Stackカーネルに組み込まれています。</font><font style="vertical-align: inherit;">これと他の多くの最適化のおかげで、それは非常に高速です-安価なハードウェアで毎秒180万リクエストを処理できます。</font><font style="vertical-align: inherit;">これは、トップロードでNginxの3倍高速であり、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネルバイパスアプローチ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と比較すると高速</font><strong><font style="vertical-align: inherit;">です。</font></strong></font><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少数のコアで、ScyllaDB（DPDKで作成）で使用されているSeastarプロジェクトと同様のパフォーマンスを示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトは、2013年にPT AFに取り組み始めたときに生まれました。</font><font style="vertical-align: inherit;">このWAFは、人気のある1つのオープンソースHTTPアクセラレータに基づいていました。</font><font style="vertical-align: inherit;">Nginx、HAProxy、Varnish、Apacheのトラフィックは優れたHTTPアクセラレータです。コンテンツを適切に配信、キャッシュ、変更します</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、大規模なトラフィック処理とフィルタリングを目的として設計された</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もの</font><strong><font style="vertical-align: inherit;">はあり</font></strong><font style="vertical-align: inherit;">ません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ネットワークレベルのファイアウォールがある場合は、このアイデアを続けて、アプリケーションレベルのファイアウォールとしてTCP / IPスタックに統合してみませんか？</font><font style="vertical-align: inherit;">実際、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTPアクセラレータとファイアウォールのハイブリッドである</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tempesta FWが判明しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：Nginxはシンプルで人気のあるWebサーバーであるため、レポートの例として使用されます。</font><font style="vertical-align: inherit;">代わりに、他のオープンソースHTTPサーバーが存在する可能性があります。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTPリクエスト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（HTTP /（1、〜2））</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を</font><font style="vertical-align: inherit;">
見てみましょう</font><font style="vertical-align: inherit;">。非常に大きなURIを使用できます。</font><font style="vertical-align: inherit;">HTTP解析時に重要な</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セパレータ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、赤い太字で強調表示されています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">機能を強調します。たとえば、解析する必要がある追加の「セミコロン」やシーケンス「\ r \ n」など、さまざまな区切り文字だけでなく、数キロバイトの大きな文字列も取り上げます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 2についても少し言う必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2機能</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2は文字列とバイナリデータの混合です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この組み合わせは、サーバーリソースを節約することよりも、接続の帯域幅を最適化することを重視しています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HPACKのHTTP / 2は動的テーブルを使用します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。クライアントからの最初のリクエストは最適化されておらず、表にはありません。それを解析して、テーブルに追加する必要があります。 HTTP / 2 DDoSが登場した場合、これはまさにその通りです。通常の場合、HTTP / 2はバイナリプロトコルですが、テキスト（テキストヘッダー名、データ）を解析する必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハフマンエンコーディング</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは単純なエンコーディングですが、Huffmanは圧縮のためにすばやくプログラムするのが非常に困難です。Huffmanエンコーディングはバイト境界を越えるため、ベクトル拡張を使用できず、バイト単位で移動する必要があります。</font><font style="vertical-align: inherit;">32バイトまたは16バイトのデータをすばやく処理することはできません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookie、ユーザーエージェント、リファラー、URIは非常に大きくなる可能性があります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">まず、ハフマンを削除してから、HTTP / 1と同じように、通常のHTTPパーサーに送信します。</font><font style="vertical-align: inherit;">RFCでは許可されていますが、Cookieの圧縮はお勧めしません。これは機密データであるため、攻撃者にそのサイズに関する情報を提供しないでください。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP処理が遅い</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべてのHTTPサーバーは最初にHTTP / 2をデコードしてから、これらの行をHTTP / 1がすでに使用しているHTTP / 1パーサーに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 1解析の問題は何ですか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートマシンをすばやくプログラムする必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連続する行をすばやく処理する必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪意のあるトラフィックは、プロセスの最も遅い（最も弱い）部分をターゲットにします。</font><font style="vertical-align: inherit;">したがって、フィルターを作成する場合は、遅い部分にも注意を払い、それらがすばやく機能するようにする必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginxプロファイル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTPフラッド下のnginxプロファイルを見てみましょう。</font><font style="vertical-align: inherit;">アクセスログを無効にして、ファイルシステムが遅くならないようにします。</font><font style="vertical-align: inherit;">通常のインデックスページが要求された場合でも、パーサーが一番上に表示されます。</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンボル名</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左-「フラットプロファイル」。</font><font style="vertical-align: inherit;">興味深いことに、その中で最もホットなスポットは次のスポットよりも重くはなく、その後プロファイルはスムーズに下降します。</font><font style="vertical-align: inherit;">これは、たとえば、最初の関数を2回最適化してもパフォーマンスの大幅な向上には役立たないことを意味します。</font><font style="vertical-align: inherit;">そのため、同じNginxは最適化しませんでしたが、プロファイルのテール全体のパフォーマンスを向上させる新しいプロジェクトを作成しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のHTTPパーサーのエンコード方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ラインに沿って実行さ</font><font style="vertical-align: inherit;">れるループ（</font><font style="vertical-align: inherit;">）と2つの変数：状態（</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と現在のデータ（</font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイクル（1）に入り、現在の状態（チェック状態）を確認します。受信したデータ（シンボル</font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渡し、</font><font style="vertical-align: inherit;">いくつかのロジックを実装します。 2番目の状態（2）に進みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）に</font><font style="vertical-align: inherit;">移動します。</font><font style="vertical-align: inherit;">これは、コードの先頭からの2番目の遷移であり、おそらく命令キャッシュの2番目のミスです。次に、最初</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font><font style="vertical-align: inherit;">に移動し、</font><font style="vertical-align: inherit;">次のキャラクターを食べます</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ...再び、内部の説明で状態を探します</font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数にすでに</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">が割り当てられている</font><font style="vertical-align: inherit;">場合</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次の指示に進むことができます。</font><font style="vertical-align: inherit;">しかし、代わりに、彼らは再び上昇し、再び下降しました。</font><font style="vertical-align: inherit;">降りるのではなく、コードで「円を切り」ます。</font><font style="vertical-align: inherit;">たとえば、通常のパーサーは、直接遷移を持つパーサーを生成しません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTPパーサー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nginxパーサーとその環境について一言。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginxは通常のソケットAPIで動作します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -アダプターに送られるデータはユーザー空間にコピーされます。</font><font style="vertical-align: inherit;">その結果、必要なものを探している大きなデータチャンクができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginxは2つのパスで機​​能するアルゴリズムを使用します。最初に長さを検索し、次にチェックします。</font><font style="vertical-align: inherit;">最初のステップで、彼は文字列をスキャンしてトークンを探し、最初のトークン（「試用版」）を検索します。</font><font style="vertical-align: inherit;">2番目のトークンで</font><font style="vertical-align: inherit;">は、トークンのサイズに応じて、トークン化し</font><font style="vertical-align: inherit;">、リクエストの終了（</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">チェックして</font><font style="vertical-align: inherit;">開始</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「取得」は常に同じデータチャンクにあり</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Tempesta FWはゼロコピーで動作します。</font><font style="vertical-align: inherit;">これは、データが完全に任意のサイズ（それぞれ1バイトまたは1000バイト）で来る可能性があることを意味します。</font><font style="vertical-align: inherit;">この「メカニズム」は私たちには合いません。</font><font style="vertical-align: inherit;">GCCで</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのように機能</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">か見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルックアップテーブル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。左側は列挙型の典型的な例です。0から開始し、次に連続するラベル、26の定数、そしてそれをすべて処理するコードがあります。右側は、コンパイラーが生成するコードです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EAXレジスターの</font><font style="vertical-align: inherit;">変数</font><font style="vertical-align: inherit;">を定数と</font><font style="vertical-align: inherit;">比較します</font><font style="vertical-align: inherit;">。次に、すべてのラベルを8バイトのポインターの順次配列（ルックアップテーブル）の形式で提示します。この命令では、この配列のオフセットを渡します。これは、ポインターの二重逆参照です。右下は、このテーブルから切り替えたコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリの二重逆参照がわかります。シークレットデータを受け取った場合、バイトで配列内のアドレスを見つけ、このポインタに移動します。実生活では例よりもさらに悪いことを知っておくことが重要です-ルックアップテーブルの場合、コンパイラが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spectre攻撃の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の場合、コードはより複雑になり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ検索</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次のケースは</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、逐次定数ではなく、任意の定数です。コードは同じですが、GCCはそのような大きな配列をコンパイルできず、配列のインデックスとして定数を使用できません。彼は二分探索に切り替えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右側には、逐次比較、アドレスへの遷移、および比較の継続が示されています。バイナリ検索はコードによるものです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTPパーサー。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートマシンnginxとは何かを見てみましょう。 9キロバイトのコードがあります。これは、ベンチマークが起動されたマシンの1次レベルキャッシュよりも3分の1少ない容量です（ほとんどのx86-64プロセッサーと同様）。</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nginxヘッダーパーサー</font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は単純なトークナイザーです。</font><font style="vertical-align: inherit;">ヘッダーの値とその名前については何もせず、HTTPヘッダーのトークンをハッシュに挿入するだけです。</font><font style="vertical-align: inherit;">ヘッダー値が必要な場合は、ヘッダーテーブルをスキャンして分析を繰り返します。</font><font style="vertical-align: inherit;">セキュリティ上の理由から</font><strong><font style="vertical-align: inherit;">、ヘッダーの名前と値を厳密にチェックする</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
必要が</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります</font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW：HTTP文字列の文字列検証</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのステートマシンは桁違いに強力です。RFCヘッダーの検証を行い、すぐにパーサーでほとんどすべてを処理します。</font><font style="vertical-align: inherit;">nginxに80の状態がある場合、520あり、さらに多くの状態があります。</font><font style="vertical-align: inherit;">を運転すると</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、10倍大きくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は持っている</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / Oのゼロコピー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -異なるサイズのチャンクは異なる場所でデータをカットすることができます。</font><font style="vertical-align: inherit;">異なるチャンクがデータをカットする可能性があります。</font><font style="vertical-align: inherit;">たとえば、ゼロコピーI / Oでは、「GET」は「まれに」「GET」、「GE」および「T」または「G」、「E」および「T」として発生する可能性があるため、データの断片間の状態を保存する必要があります。</font><font style="vertical-align: inherit;">私たちは実質的にI / Oのコストを取り除きますが、プロファイルではそれが飛んでしまいます-すべてが悪いです。</font><font style="vertical-align: inherit;">大きなHTTPパーサーは、プロジェクトで最も重要な場所の1つです。</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を改善するにはどうすればよいですか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSM直接紹介</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に行うのは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループで</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><strong><font style="vertical-align: inherit;">なく、ラベル（</font></strong></font><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">による直接遷移</font></strong><font style="vertical-align: inherit;">です。 Ragelのような通常のパーサージェネレーターがこれを行います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれの状態を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">同じ名前の</font></a></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラベルとCのラベルで</font><font style="vertical-align: inherit;">エンコードします</font><font style="vertical-align: inherit;">。行きたいときはいつでも</font><font style="vertical-align: inherit;">、コードから</font><font style="vertical-align: inherit;">ラベルを見つける</font><font style="vertical-align: inherit;">か、同じ状態に直接アクセスします。最初にを通過した</font><font style="vertical-align: inherit;">後、その中で直接目的のラベルに移動します。</font><strong><font style="vertical-align: inherit;">短所</font></strong><font style="vertical-align: inherit;">：次の状態に切り替えたい場合は、データがまだ残っているかどうかをすぐに評価する必要があります（ゼロコピーI / Oのため）。条件本体</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>switch</code><font style="vertical-align: inherit;"></font><code>switch</code><font style="vertical-align: inherit;"></font><br>
<br>
<strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは各状態にコピーされます。通常のスイッチ駆動型FSMの1つの条件ではなく、状態の数に応じて500個あります。各状態のコードを生成することは素晴らしいことではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなステートマシンの場合、</font><font style="vertical-align: inherit;">内部</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が大きい</font><font style="vertical-align: inherit;">ため</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、GTC </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はコード内で</font><font style="vertical-align: inherit;">条件を</font><font style="vertical-align: inherit;">数回</font><font style="vertical-align: inherit;">繰り返し</font><font style="vertical-align: inherit;">ます。</font><strong><font style="vertical-align: inherit;">直接遷移に</font></strong></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置き換え</font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の最適化は、それを使用せず</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、保存されたメタアドレスへの直接ジャンプに切り替えることです。関数に入るとすぐに、目的のポイントに移動したいと考えています。 GCCではこれを行うことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCCには役立つ標準の拡張機能があります。ラベル名（ここでは</font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を取得し、</font><font style="vertical-align: inherit;">そのアドレスを二重アンパサンド（&amp;&amp;）を介してC変数に割り当てます。これで、直接ジャンプ命令を作成できます</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このラベルのアドレスに</font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから何が起こるか見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接変換パフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少数の状態では、直接遷移コードジェネレーターは通常よりも少し遅くなります</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、大規模なステートマシンの場合、生産性は2倍になります。</font><font style="vertical-align: inherit;">ステートマシンが小さい場合は、通常のマシンを使用することをお勧めします</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：Tempestaコードは例よりも複雑です。</font><font style="vertical-align: inherit;">GitHubにはすべての</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマークがある</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">、</font></em><em><font style="vertical-align: inherit;">すべてを詳細に確認できます。</font></em><em><font style="vertical-align: inherit;">元のパーサーコードは</font></em></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクから</font></font></em></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">入手できます</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（メインHTTPパーサー）。</font><font style="vertical-align: inherit;">それに加えて、Tempesta FWには</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">、FSMをより簡単に使用する</font></em></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなパーサー</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接遷移が遅くなる理由</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートマシンでは、多くのコードを処理するため、（予想される）分岐の予測ミスが多数発生します。</font><font style="vertical-align: inherit;">ブランチミス予測に従って「プロファイリング」を実行してみましょう。</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps – up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
406の状態を持つ大規模なステートマシンでは、の遷移の処理に38％の時間を費やしています</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">直接遷移のあるステートマシンでは、ホットスポットはライン解析です。</font><font style="vertical-align: inherit;">各状態での文字列の解析には、文字列の終わりの状態</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまりの状態マシンの状態の</font><font style="vertical-align: inherit;">チェックが含ま</font><font style="vertical-align: inherit;">れ</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、イベントL1命令キャッシュミスによる両方のタイプのステートマシンのプロファイリングを見てみましょう。</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接ジャンプの場合は</font><font style="vertical-align: inherit;">約30 </font><font style="vertical-align: inherit;">キロバイト、直接ジャンプの場合は50キロバイト（第1レベルの命令のキャッシュ以上）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュに収まらない場合、そのようなステートマシンではキャッシュミスが多数発生するはずです。</font><font style="vertical-align: inherit;">しかし、いいえ、それらは2分の1です。</font><font style="vertical-align: inherit;">これは、キャッシュがより適切に機能するためです。コードを順番に操作して、古いキャッシュからデータをプルアップします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラはコードの順序を変更します</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
でステートマシンコードをプログラムする</font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、最初に、データが受信されたときに最初に呼び出される状態（HTTPメソッド、URI、次にHTTPヘッダー）があります。データを処理するときと同じように、コードが上から下に順番にプロセッサキャッシュに読み込まれるのは当然のようです。しかし、これは完全に間違っています。アセンブラコードを見ると、驚くべきことがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側はプログラムしたものです。最初にメソッドを解析し</font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、ありそうもないメソッドのはるか下の場所</font><font style="vertical-align: inherit;">を解析します</font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、我々は、構文解析を見ると期待</font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">アセンブラの冒頭で</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、と</font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、すべてが正反対です。</font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真ん中、</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終わり、そして</font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、コンパイラーがデータの到着方法を理解していないためです。</font><font style="vertical-align: inherit;">彼は美しいコードの写真に従ってコードを配布しています。</font><font style="vertical-align: inherit;">彼がコードを正しい順序で配置できるようにするには、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーバリアを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラバリアは、コンパイラが再配列しないアセンブリダミーです。</font><font style="vertical-align: inherit;">このような障壁を設けるだけで、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生産性が4％向上しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の方法でコードを作成する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーはデータを希望どおりに配置しないため、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイラーによる最適化</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><strong><font style="vertical-align: inherit;">プロファイラー</font></strong><font style="vertical-align: inherit;">の制御下での最適化）を行います。</font><font style="vertical-align: inherit;">プロファイラーによるガイド付き最適化（PGO）は、サンプルの総数であり、一連の呼び出しではありません。</font><font style="vertical-align: inherit;">たとえば、URIはメソッド分析よりも多くのサンプルを受け取るため、メソッドを処理する前にURI処理コードを配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使い方？</font><font style="vertical-align: inherit;">コードを記述して、ベンチマークを実行し、プロファイリングの結果をコンパイラーに提供します。これにより、ロードに最適なコードが生成されます。</font><font style="vertical-align: inherit;">しかし問題は、コードの最もホットなセクションをコンパイルするだけで、時間の依存関係を追跡しないことです。</font><font style="vertical-align: inherit;">ロードで最大のURIの場合、これが最もホットな場所になります。</font><font style="vertical-align: inherit;">URIは関数の先頭に表示され、PGOはメソッド名が常にURIの前にあることを示しません。</font><font style="vertical-align: inherit;">したがって、PGOは機能しません。</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が機能しますか？</font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マクロ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Linuxカーネルコードの場合、GCC組み込み関数はユーザー空間で使用できます</font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。彼らはどちらのコードを近くに置くかを言います。たとえば、リクエスト本文はすぐ後ろにあると報告されている可能性があります</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、コードをプリフェッチ（プロセッサをプリフェッチ）すると、そのコードが選択され、すべてが高速になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像は、解析メソッドの開始、終了、およびバリアを示しています。障壁の背後にあるコードが表示されるとは予想していませんでした。これはいけないようです-私たちは障壁を設けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、実際にはどうなりますか？コンパイラは</font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件を</font><font style="vertical-align: inherit;">認識し</font><font style="vertical-align: inherit;">ます-条件の本体に入る可能性が最も高く、そこで無条件のラベルへのジャンプに切り替えます</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">条件の後のコードは「ホットパス」で処理されないことがわかります。</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホットコード条件が満たされているため、バリアにもかかわらず、</font><font style="vertical-align: inherit;">コンパイラはのラベルの下のコードをの後ろ</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">移動します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに対して、GCCには拡張機能があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">属性</font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラベルです。</font><font style="vertical-align: inherit;">彼らは、どのラベルが暑い（最も可能性が高い）と寒い（可能性が低い）ラベルを言っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私たちは</font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より可能性の高い</font><font style="vertical-align: inherit;">ものについて合意し</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、彼に任せ</font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この状態では、URI処理が上昇し、</font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下に進みます。</font><font style="vertical-align: inherit;">ラベルが冷たいため、最も可能性の低い状態マシンの他のすべてのコードは下に留まります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あいまい-O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラの最適化を見てみましょう。</font><font style="vertical-align: inherit;">最初に頭に浮かぶのは、O2ではなくO3を使用することです。</font><font style="vertical-align: inherit;">しかし、これはそうではありません-O3はより悪いコードを生成することがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3はいくつかの最適化のコレクションです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それらをO2に個別に追加すると、異なるオプションが得られます。</font><font style="vertical-align: inherit;">特定のコードでは、コードをより適切に生成する最適化のみを選択します。</font><font style="vertical-align: inherit;">最良の結果を残します。ここでは、1,838秒と1,858秒に対して1,820秒です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のオプションは緑色で強調表示されています-これは自動ベクトル化です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動ベクトル化</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCCガイドの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
サイクルの例</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返す変数配列がある場合、サイクルを最適化できます-ベクトルに分解します。</font><font style="vertical-align: inherit;">デフォルトでは、自動</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル化は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3レベルの最適化で有効になっています-O3 </font><font style="vertical-align: inherit;">：GCCは可能な場合にベクトルコードを生成します。</font><font style="vertical-align: inherit;">ただし</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてのコード</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を自動的にベクトル化できる</font><strong><font style="vertical-align: inherit;">わけではありません</font></strong><font style="vertical-align: inherit;">（原則としてベクトル化されている場合でも）。</font><font style="vertical-align: inherit;">ベクトル化されたものとされていないものを示す</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCCオプションを有効にする</font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができます。</font><font style="vertical-align: inherit;">ベンチマークの場合、ベクトル化されたものは何もないことがわかりますが、コードの生成はさらに悪くなります。</font><font style="vertical-align: inherit;">したがって、ベクトル化は常に機能するとは限りません。コードが遅くなることがあります。</font><font style="vertical-align: inherit;">ただし、ベクトル化されているものとされていないものはいつでも確認でき、必要に応じてベクトル化をオフにできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アライメント：文字列をGETと比較する方法は？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nginxのように、小さなハックを作成</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。行を</font><font style="vertical-align: inherit;">バイトで解析するのではなく、</font><font style="vertical-align: inherit;">行を</font><font style="vertical-align: inherit;">計算</font><font style="vertical-align: inherit;">してそれらと比較します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整列していない</font><font style="vertical-align: inherit;">
場合は</font><font style="vertical-align: inherit;">、2〜3倍遅くなります。</font><font style="vertical-align: inherit;">これを証明</font><font style="vertical-align: inherit;">する小さな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を書きました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、位置合わせを試みます</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">アドレスが</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アライメントされている</font><font style="vertical-align: inherit;">かどうかを調べ、</font><font style="vertical-align: inherit;">アライメントされ</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ていない場合はバイトで</font><font style="vertical-align: inherit;">比較し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このアプローチはうまくいかないことがわかります：</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、分離された、最適化できないベンチマークコードと、大量のコードが原因で最適化が失われるインラインパーサーコードとの間には違いがあります。</font><font style="vertical-align: inherit;">プロファイリングにペナルティはありませんでした。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：これがタスクで発生している理由の詳細については、</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubを参照してください</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜHTTP文字列が私たちにとって重要なのですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、これは通常のURIです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホテルについて十分にうるさい場合</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">予約に移動していくつかのフィルターを設定し、キロバイトを超えるURIを取得してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginxは</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/に</font><font style="vertical-align: inherit;">かなり大規模な解析マシンを持っています</font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それは非常に速く動作しません。</font><font style="vertical-align: inherit;">さらに、Tempesta FWの場合、URIを解析するだけでなく、インジェクションについてもチェックする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のURI：/redir_lang.jsp? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lang=foobar%0d%0aContent-Length:%200%0d% 0a％0d％0aHTTP / 1.1％20200％20OK％0d％0aContent-Type：％20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html％0d％0aContent -長さ：％2019％0d％0a％0d％0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のように見えますが、注射があります。これを理解するには、十分に深く掘る必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストを実行してみましょう。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のURI、フィードwrkをnginxに設定し、nginxの解析が非常に高温になることを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の通常のインデックスクエリで、パーサーがすでに一番上にあることが明らかである場合、ここではさらに熱くなります。</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP文字列の特別な点は何ですか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなセパレーター</font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">があり</font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、行の終わりでさえあり</font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、最初に説明した</font><font style="vertical-align: inherit;">2バイト</font><font style="vertical-align: inherit;">または1 </font><font style="vertical-align: inherit;">バイトのいずれか</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">Cラインの0終了はありません。セキュリティ上の理由から、何が来るかをより正確に確認したいと考えています。</font><font style="vertical-align: inherit;">パーサーに役立つ2つの標準関数があります。</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：アルファベット、文字列で使用可能な文字をチェックし、有効なアルファベットを動的にコンパイルしますが、プログラムのコンパイルの段階ではわかっています。</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">比較するためのケースを変換する必要はありません</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とは</font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ほとんどの場合</font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、にはコンプライアンス/非コンプライアンスのみが必要であり、ライン内の位置を知る必要はありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはゆっくりと働きます。</font><font style="vertical-align: inherit;">ベンチマークを見て、何が悪いのかを理解しましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイックパーサー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのパーサーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginxは最も単純なパーサーであり、RFCへの準拠を厳密にチェックします。 PicoHTTPParser（H2O）とCloudflareパーサーもあります。データの処理は速くなりますが</font><font style="vertical-align: inherit;">、RFCで許可されていない</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;">スキップされる</font></a><font style="vertical-align: inherit;">可能性があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーサーはいくつかの異なるアプローチを使用します。 1つはPicoパーサーで使用されるPCMESTRI命令です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指示で範囲を設定します。残念ながら、16文字または8つの範囲をロードできます。範囲が1文字のみで構成されている場合-繰り返します。この制限のため、PicoパーサーはRFCのコンプライアンスを完全に検証できません。これは、RFCがこの場所に8を超える範囲を持っているためです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルファベットをレジスタに読み込み、文字列を読み込み、命令を実行します。出口で、偶然かどうかがすぐにわかります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2-CloudFlareアプローチ。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CloudFlareパーサーは、AVX2を使用して、Picoパーサーで16バイトではなく、32バイトの文字列を一度に処理します。解析はAVX2に転送されたため、CloudFlareの方が優れています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての文字をASCIIテーブルのスペースにチェックします。すべての文字は128より大きく、それらの間の範囲をとります。単純なコードは高速です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRIとAVX2を比較してください。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちにとって、現在の制限は1500です。これは、私たちに提供される最大パッケージサイズです。ビッグデータのAVX2コードは、Picoパーサーよりもはるかに高速であることがわかります。ただし、AVX2では命令が重いため、小さなデータでは動作が遅くなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に匹敵します</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">を使用する場合</font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、特にビッグデータに関しては状況が悪化します。</font><font style="vertical-align: inherit;">「戦闘」パーサーでは使用できません</font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta matcherはより速く、より正確です</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの速度パーサーは、この2つに似ています。小さいデータでは、CloudFlareのように、大きいデータではPicoパーサーと同じくらい高速です。ただし、無効な文字はスキップされません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーサーはどのように配置されていますか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nginxとして、バイト配列を定義し、それによって入力データをチェックします。これは関数のプロローグです。ここでは短期でのみ作業し</font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ブランチの予測ミスは、長いラインよりも短いラインの方が痛いためです。このコードを取り上げます。最後の行のため、制限は4です-かなり強力な条件を記述する必要があります。 4バイトを超えると、条件が難しくなり、コードが遅くなります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインループと大きなテール。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインの処理サイクルでは、データを分割します。十分に長い場合は、それぞれ128、64、32、または16バイトを処理します。</font><font style="vertical-align: inherit;">それぞれ128個を処理するのは理にかなっています。並行して、いくつかのプロセッサチャネル（複数のパイプライン）とスーパースカラープロセッサを使用します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の終わりは始まりに似ています。</font><font style="vertical-align: inherit;">16バイト未満の場合は、ループで4バイトを処理し、最後に3バイトを超えません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットマスクとデータを読み込みます。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、関数本体のメインアルゴリズムです。 16行8列のASCIIテーブル（図のように）を示します。最初に、テーブルの行をBM URIの最初のレジスタにエンコードします。1行目と2行目です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用できる実際の記号は</font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。次のように彼らは、エンコードされます</font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆の順序でエンコードします。0から開始し、最初のサービス文字は許可されません。その後、単位は許可されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASCIIビットマスクを設定します。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、ある行が入ってくると</font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、最初の行の最初の文字はASCII、2番目の文字は2番目の行です。入力内のこれらの文字の順序に従って、エンコードされたテーブル行をシャッフルするshuffleステートメントを実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力の列ID。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、ASCIIテーブルの列を別のレジスタに配置します。次に、列と行のレジスタを「クロス」し、対応関係を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列はバイトからの最上位の4ビットなので、左にシフトします。 AVXのオフセットは2バイトしかないため、最初にバイトをシフトし、次にマスクを使用してnをシフトして、有効ビットのみを取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASCII列の配置</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2番目のシャッフルを実行し、列を目的の位置に移動します。どちらの場合も、最後の列からの入力バイトなので、最初と2番目の位置で同じ列を取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マスクの列と行の交差</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実行し</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（列と列を「クロス」）、入力データが有効であることがわかります-結果</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列と行の交差からゼロではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後にゼロの数を数えます。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてをベクターから収集</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、出力に返します-非常に簡単です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファベットをカスタマイズします。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASCIIテーブルを使用すると、安価な機能が得られます。静的テーブルを使用しますが、さまざまなヘッダーのURI、名前、および値に使用できるアルファベットをユーザーに尋ねるのを妨げるものはありません。</font><font style="vertical-align: inherit;">HTTP URIリクエストとヘッダーは、8つのアルファベット（プラスまたはマイナス）を使用して1つのHTTPリクエストを解析します。</font><font style="vertical-align: inherit;">これらのテーブルを同じコードにロードして</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有効なURI </font><strong><font style="vertical-align: inherit;">であるユーザーが指定した1つのアルファベットで比較</font></strong><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そうでない場合は異なります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻撃</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが役立つ可能性があるいくつかのケース。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BlackHat'17によるSSRF攻撃</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（「SSRFの新時代」）：</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ありそうもないアンパサンド記号。</font><font style="vertical-align: inherit;">一部のアプリケーションでは使用され、一部のアプリケーションでは使用されません。</font><font style="vertical-align: inherit;">しかし、それを使用していない場合は、有効なアルファベットから除外することができ、攻撃はブロックされます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE-攻撃：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> «効果的なようなコマンドインジェクション攻撃を実行です»、BSides'16を：</font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">User-Agentは静的ヘッダーですが、一部</font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にUser-Agentの特殊文字が含まれて</font><font style="vertical-align: inherit;">いる場合、RCE攻撃のケースがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちはドル記号を除いて自分自身を守ります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相対パスの上書き</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後のケースはGoogleが2016年に持っていたものです。</font><font style="vertical-align: inherit;">中かっこ、コロンがURIに追加されました</font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらは、アルファベットから除外できる可能性の低い文字です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはかなり自明なコードです。</font><font style="vertical-align: inherit;">また、それぞれ2つの配列である32バイトの文字列を比較します。</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker’s Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> – <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> – <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker’s Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' – 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目にパーサーの定数を小文字でプログラムしたので、レジスターは1行だけです。</font><font style="vertical-align: inherit;">重要な比較があるので、各バイトから128を差し引きます（Hacker's Delightのトリック）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、有効な文字の範囲を比較します。この文字列に登録できるかどうかは、文字かどうかです。</font><font style="vertical-align: inherit;">これを確認する時点では、aからzへの2つの比較の代わりに、1つの比較（Hacker's Delightのトリック）のみを使用して定数に移動できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスstrcasecmp（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TempestaはGLIBCよりもはるかに高速で、新しいバージョン（18または19）でも高速です。</font><font style="vertical-align: inherit;">コード</font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はAVXも使用しますが、2番目のバージョンは使用しません。</font><font style="vertical-align: inherit;">AVX2の方が高速なので、Tempestaの方がコードが高速です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinuxカーネルFPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトルプロセッサ拡張機能</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;"> -それらはカーネルで利用可能です。ベクトル命令はFPUプロセッサモジュールによって処理されます。これはメインプロセッサモジュールではなく、メインレジスタではありませんが、かなりボリュームがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Linuxには最適化があります。カーネルからユーザー空間に行き来する場合、FPUレジスタ（XMM、YMM、ZMM）のコンテキストを保存せず、メインプロセッサモジュールのレジスタのみのコンテキストを変更します。 OSカーネルは、プロセッサーのベクトル拡張では機能しないと想定されています。しかし、必要な場合、たとえば、暗号化はそれを実行でき</font><font style="vertical-align: inherit;">ますが、FPUレジスターのコンテキスト</font><font style="vertical-align: inherit;">を使用</font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存して復元する</font><font style="vertical-align: inherit;">必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは</font><font style="vertical-align: inherit;">、ベクトルレジスタを担当</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するプロセッサモジュールの状態</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">保存および復元する</font></strong><font style="vertical-align: inherit;">ネイティブマクロです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらはかなり遅いリソースです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVXおよびSSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPUコンテキストの保存と復元のベンチマークの前に、ベクトル演算についていくつか説明します。</font><font style="vertical-align: inherit;">なぜアセンブラで作業することが理にかなっているのですか？</font><font style="vertical-align: inherit;">時々、GCCは次善のコードを生成します。</font><font style="vertical-align: inherit;">問題は、古いプロセッサーモデルでは、SSEからAVXへの移行に大きなペナルティがあることです。</font><font style="vertical-align: inherit;">GCCには新しいキーがあり</font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。それを使用して、この命令を生成しないよう</font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にします。これにより、レジスタがクリアされ、このペナルティが削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この命令を使用する必要があるのは、サードパーティによってSSE用にコンパイルされた古いコードを使用している場合のみです。</font><font style="vertical-align: inherit;">これは私たちのケースではなく、これらの指示を安全に破棄できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサーに</font><font style="vertical-align: inherit;">
は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動ベクトル化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。これは、どのユーザー空間コードにもベクトル演算があることを意味します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム内の任意の2つのプロセスは、ベクトルプロセッサ拡張を使用します。プロセスがカーネルに戻ってから戻るときに、プロセッサのベクトル状態を節約して復元する時間を無駄にすることはありません。ただし、あるユーザースペースから別のユーザースペースに切り替える場合（コンテキストスイッチ）、1次レベルのキャッシュがそこで無効になるだけでなく、FPUのコンテキストスイッチモジュールの開始/終了もうまく機能しません。操作はかなり高価です-マイクロベンチマーク。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロベンチマークでは、すべてが常に劇的ですが、操作は非常に高価です。</font><font style="vertical-align: inherit;">したがって、ユーザー空間では、コンテキストを長時間切り替えてください。</font><font style="vertical-align: inherit;">カーネルには、コンテキストの切り替えがないため、すべてが高速です。</font><font style="vertical-align: inherit;">ベクトルプロセッサの保存と復元は、十分に大きなパッケージセットに対して1回だけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、スイッチコードを最適化するためのルックアップテーブルオプションを示しました。長いプロセス、列挙型、スイッチテーブルを配列にコンパイルし、この配列を飛び越えるポインタの二重逆参照に従います。これは、投機的実行を悪用するSpectre攻撃のシナリオです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Googleは、</font><font style="vertical-align: inherit;">最新のコンパイラーでのポインターの二重逆参照が現在どのように配置されているかについての</font><font style="vertical-align: inherit;">優れた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持ってい</font><font style="vertical-align: inherit;">ます（2018年の初め以降）。うまく機能しません。レジスタの前半にいくつかのアドレスが格納されていて、このアドレスに移動した場合、ここで別のコードが作成されます。</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのように機能しますか？ l1で関数を「呼び出し」、プロセスはこのラベルに移動し、ハッキングを行います。関数から戻るかのように（そうではありません）、戻りアドレスを書き換えます。命令を実行する</font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、スタックに現在のアドレスである戻りアドレス</font><font style="vertical-align: inherit;">を配置</font><font style="vertical-align: inherit;">し、必要なレジスターの内容で書き直して、l1に移動します。しかし、プロセッサーは、プリフェッチャーが実行されているときに、関数とバリアがあることを認識します。したがって、すべてが遅くなります-プリフェッチがスローされ、スペクターの脆弱性が取り除かれます。コードは遅く、パフォーマンスは15％低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の比較的新しい攻撃は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メルトダウンです。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、ユーザー空間プロセスのみに固有です。</font><font style="vertical-align: inherit;">ユーザー空間からカーネルメモリを読み取るのは非常に困難です。</font><font style="vertical-align: inherit;">攻撃は、デフォルトで新しいカーネルでコンパイルされるカーネルパテテーブル分離（KPTI）によって防止されます。</font><font style="vertical-align: inherit;">ただし、KPTIは非常に高価であり、最大30〜40％のパフォーマンス低下があります（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MariaDBで測定</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、遅延TLB最適化がなくなったためです。カーネルとプロセッサのアドレス空間は、さまざまなページテーブルで完全に分離されています（以前は、遅延TLBはカーネルスペースを各プロセスのページテーブルにマッピングし続けていました）。</font><font style="vertical-align: inherit;">これはユーザー空間にとっては苦痛ですが、カーネルで完全に機能するTempesta FWにとっては苦痛です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの便利なリンク：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP解析用の高速有限状態マシン</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C、SSE4.2、AVX2を使用したHTTP文字列処理</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッカーの喜び</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メルトダウンとスペクター攻撃ドキュメント</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">PHP Russia</a>: 13   ,  .       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">TechLead Conf</a> —     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja493226/index.html">毎週100,000行のコードを読み取って修正する方法</a></li>
<li><a href="../ja493230/index.html">Lighthouse 6（ベータ版）を利用した新しいGoogle PageSpeed Insights：サイトのパフォーマンスを確認してください</a></li>
<li><a href="../ja493232/index.html">История моей трудовой деятельности в ООО «Опен Продукт»</a></li>
<li><a href="../ja493234/index.html">INGがLionを発表：生産的で手頃な価格の柔軟なWebコンポーネントのライブラリ</a></li>
<li><a href="../ja493236/index.html">アスタリスク：リクエスト送信済み状態の外部トランク</a></li>
<li><a href="../ja493244/index.html">量子コンピュータは何ができる</a></li>
<li><a href="../ja493248/index.html">ウェビナー「Winnum Opportunities for Industrial Analytics」</a></li>
<li><a href="../ja493250/index.html">現在旅行で何が起こっているのか-輸送中の身を守る方法</a></li>
<li><a href="../ja493252/index.html">開発学校での教育経験、または大学を卒業して学校に行く必要がある理由</a></li>
<li><a href="../ja493254/index.html">人口の大量盗聴システムはFBIにとって実質的に役に立たなかった</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>