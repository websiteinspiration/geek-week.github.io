<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏼 👨‍👨‍👧 ♉️ ¿Cómo causar una pérdida de memoria en una aplicación angular? 👨🏼‍🚒 🤱 🔥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El rendimiento es la clave del éxito de una aplicación web. Por lo tanto, los desarrolladores necesitan saber cómo ocurren las pérdidas de memoria y c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¿Cómo causar una pérdida de memoria en una aplicación angular?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503312/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El rendimiento es la clave del éxito de una aplicación web. Por lo tanto, los desarrolladores necesitan saber cómo ocurren las pérdidas de memoria y cómo lidiar con ellas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este conocimiento es especialmente importante cuando la aplicación con la que se enfrenta el desarrollador alcanza un cierto tamaño. Si no presta suficiente atención a las pérdidas de memoria, entonces todo puede terminar con el desarrollador entrando en el "equipo para eliminar las pérdidas de memoria" (tenía que ser parte de ese equipo). </font><font style="vertical-align: inherit;">
Las pérdidas de memoria pueden ocurrir por varias razones. Sin embargo, creo que cuando usa Angular, puede encontrar un patrón que coincida con la causa más común de pérdidas de memoria. Hay una manera de lidiar con tales pérdidas de memoria. Y lo mejor, por supuesto, no es luchar contra los problemas, sino evitarlos.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/bg/op/jz/bgopjzk2msaiedpikpoa1qcv2cm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué es la gestión de memoria?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript utiliza un sistema automático de gestión de memoria. </font><font style="vertical-align: inherit;">El ciclo de vida de la memoria generalmente consta de tres pasos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignación de la memoria necesaria.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajar con memoria asignada, realizar operaciones de lectura y escritura.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liberar memoria después de que ya no sea necesaria.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dice que la administración automática de memoria es una fuente potencial de confusión. </font><font style="vertical-align: inherit;">Esto puede dar a los desarrolladores una falsa sensación de que no necesitan preocuparse por la administración de la memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no le importa la administración de la memoria en absoluto, esto significa que después de que su aplicación crezca a un cierto tamaño, puede encontrar una pérdida de memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, las pérdidas de memoria pueden considerarse como la memoria asignada a la aplicación, que ya no necesita, pero no se libera. </font><font style="vertical-align: inherit;">En otras palabras, estos son objetos que no pudieron someterse a operaciones de recolección de basura.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo funciona la recolección de basura?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante el procedimiento de recolección de basura, que es bastante lógico, se limpia todo lo que se puede considerar “basura”. </font><font style="vertical-align: inherit;">El recolector de basura limpia la memoria que la aplicación ya no necesita. </font><font style="vertical-align: inherit;">Para averiguar qué áreas de memoria aún necesita la aplicación, el recolector de basura utiliza el algoritmo "marcar y barrer" (algoritmo de etiquetado). </font><font style="vertical-align: inherit;">Como su nombre lo indica, este algoritmo consta de dos fases: la fase de marcado y la fase de barrido.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Fase de bandera</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los objetos y enlaces a ellos se presentan en forma de árbol. </font><font style="vertical-align: inherit;">La raíz del árbol es, en la siguiente figura, un nodo </font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En JavaScript, este es un objeto </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada objeto tiene una bandera especial. </font><font style="vertical-align: inherit;">Pongamos nombre a esta bandera </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En la fase de marcado, en primer lugar, todos los indicadores </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se establecen en un valor </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/436/b8a/433436b8a72bc7a207bd66c5b76788f5.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al principio, las banderas de los objetos marcados se establecen en falso y</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
luego se recorre el árbol de objetos. </font><font style="vertical-align: inherit;">Todas las banderas de</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objetos accesibles desde el nodo</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">están establecidas en</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y las banderas de esos objetos que no se pueden alcanzar, permanecen en el valor</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objeto se considera inalcanzable si no se puede alcanzar desde el objeto raíz.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/d14/a50/1cfd14a50f9be4e7aa402052982eb253.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos alcanzables se marcan como marcados = verdadero, los objetos inalcanzables como marcados = falso</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como resultado, todas las banderas de</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objetos inalcanzables permanecen en el valor</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La memoria aún no se ha liberado, pero, después de completar la fase de etiquetado, todo está listo para la fase de limpieza.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Fase de limpieza</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La memoria se borra precisamente en esta fase del algoritmo. Aquí, todos los objetos inalcanzables (aquellos cuya bandera </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permanece en el valor </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) son destruidos por el recolector de basura.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/75f/f16/8a075ff162428195665afe583a85151f.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árbol de objetos después de la recolección de basura. </font><font style="vertical-align: inherit;">El recolector de basura destruye todos los objetos cuya marca marcada se establece en falso.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La recolección de basura se realiza periódicamente mientras se ejecuta el programa JavaScript. </font><font style="vertical-align: inherit;">Durante este procedimiento, se libera memoria que se puede liberar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quizás la siguiente pregunta surge aquí: "Si el recolector de basura elimina todos los objetos marcados como inalcanzables, ¿cómo crear una pérdida de memoria?". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El punto aquí es que el objeto no será procesado por el recolector de basura si la aplicación no lo necesita, pero aún puede alcanzarlo desde el nodo raíz del árbol de objetos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo no puede saber si la aplicación usará alguna pieza de memoria a la que pueda acceder o no. </font><font style="vertical-align: inherit;">Solo un programador tiene ese conocimiento.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fugas de memoria angular.</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muy a menudo, las pérdidas de memoria ocurren con el tiempo cuando un componente se vuelve a representar repetidamente. </font><font style="vertical-align: inherit;">Por ejemplo, a través del enrutamiento o como resultado del uso de la directiva </font></font><code>*ngIf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Digamos, en una situación en la que algún usuario avanzado trabaja con la aplicación todo el día sin actualizar la página de la aplicación en el navegador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para reproducir este escenario, crearemos una construcción de dos componentes. </font><font style="vertical-align: inherit;">Estos serán los componentes </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-sub *ngIf="hide"&gt;&lt;/app-sub&gt;`</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
&nbsp;&nbsp;hide = <span class="hljs-literal">false</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.hide = !<span class="hljs-keyword">this</span>.hide, <span class="hljs-number">50</span>);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plantilla </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del componente usa el componente </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lo más interesante aquí es que nuestro componente utiliza una función </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cambia la bandera </font></font><code>hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada 50 ms. Esto da como resultado que un componente se vuelva a representar cada 50 ms </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es decir, se realiza la creación de nuevas instancias de la clase </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este código imita el comportamiento de un usuario que trabaja todo el día con una aplicación web sin actualizar una página en un navegador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosotros, en </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hemos implementado diferentes escenarios, en el uso de los cuales, con el tiempo, comienzan a aparecer cambios en la cantidad de memoria utilizada por la aplicación. Tenga en cuenta que el componente</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre permanece igual. </font><font style="vertical-align: inherit;">En cada escenario, descubriremos si lo que estamos tratando es una pérdida de memoria analizando el consumo de memoria del proceso del navegador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el consumo de memoria del proceso aumenta con el tiempo, esto significa que nos enfrentamos a una pérdida de memoria. </font><font style="vertical-align: inherit;">Si un proceso usa una cantidad de memoria más o menos constante, significa que no hay pérdida de memoria o que la pérdida, aunque está presente, no se manifiesta de una manera bastante obvia.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Escenario # 1: enorme para el bucle</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro primer escenario está representado por un ciclo que se ejecuta 100,000 veces. </font><font style="vertical-align: inherit;">En el bucle, se agregan valores aleatorios a la matriz. </font><font style="vertical-align: inherit;">No olvidemos que el componente se vuelve a representar cada 50 ms. </font><font style="vertical-align: inherit;">Eche un vistazo al código y piense si creamos una pérdida de memoria o no.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;arr = [];<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.arr.push(<span class="hljs-built_in">Math</span>.random());<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque dicho código no debe enviarse a producción, no crea una pérdida de memoria. </font><font style="vertical-align: inherit;">Es decir, el consumo de memoria no va más allá del rango limitado a un valor de 15 MB. </font><font style="vertical-align: inherit;">Como resultado, no hay pérdida de memoria. </font><font style="vertical-align: inherit;">A continuación hablaremos de por qué esto es así.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Escenario 2: Suscripción de BehaviorSubject</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este escenario, nos suscribimos </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y asignamos un valor a una constante. </font><font style="vertical-align: inherit;">¿Hay una pérdida de memoria en este código? </font><font style="vertical-align: inherit;">Como antes, no olvide que el componente se representa cada 50 ms.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, como en el ejemplo anterior, no hay pérdida de memoria.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Escenario 3: asignar un valor a un campo de clase dentro de una suscripción</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, se presenta casi el mismo código que en el ejemplo anterior. </font><font style="vertical-align: inherit;">La principal diferencia es que el valor no se asigna a una constante, sino a un campo de clase. </font><font style="vertical-align: inherit;">Y ahora, ¿crees que hay una fuga en el código?</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cree que no hay una fuga aquí, tiene toda la razón. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el escenario # 1 no hay suscripción. </font><font style="vertical-align: inherit;">En los escenarios No. 2 y 3, nos suscribimos a la secuencia del objeto observado inicializado en nuestro componente. </font><font style="vertical-align: inherit;">Parece que estamos a salvo suscribiéndonos a flujos de componentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¿y si agregamos servicio a nuestro esquema?</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escenarios que usan el servicio</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los siguientes escenarios, vamos a revisar los ejemplos anteriores, pero esta vez nos suscribiremos a la transmisión proporcionada por el servicio </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aquí está el código de servicio.</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({
&nbsp;&nbsp;<span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyService</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;some$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="hljs-number">42</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ante nosotros hay un servicio simple. </font><font style="vertical-align: inherit;">Este es solo un servicio que proporciona stream ( </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) en forma de un campo de clase pública.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Escenario 4: suscribirse a una secuencia y asignar un valor a una constante local</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a recrear aquí el mismo esquema que ya se describió anteriormente. </font><font style="vertical-align: inherit;">Pero esta vez, nos suscribimos a la transmisión </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y no al campo del componente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Hay una pérdida de memoria? </font><font style="vertical-align: inherit;">Nuevamente, al responder esta pregunta, recuerde que el componente se usa </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se representa muchas veces.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora finalmente creamos una pérdida de memoria. </font><font style="vertical-align: inherit;">Pero esta es una pequeña fuga. </font><font style="vertical-align: inherit;">Por "pequeña fuga" me refiero a una que, con el tiempo, conduce a un lento aumento en la cantidad de memoria consumida. </font><font style="vertical-align: inherit;">Este aumento apenas se nota, pero una inspección superficial de la instantánea del montón mostró la presencia de muchas instancias no eliminadas </font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Escenario 5: suscribirse a un servicio y asignar un valor a un campo de clase</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí nos suscribimos nuevamente a </font></font><code>dummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero esta vez asignamos el valor resultante al campo de clase, y no una constante local.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aquí finalmente creamos una pérdida significativa de memoria. </font><font style="vertical-align: inherit;">El consumo de memoria rápidamente, en un minuto, superó 1 GB. </font><font style="vertical-align: inherit;">Hablemos de por qué esto es así.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ ¿Cuándo ocurrió una pérdida de memoria?</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es posible que haya notado que en los primeros tres escenarios no pudimos crear una pérdida de memoria. </font><font style="vertical-align: inherit;">Estos tres escenarios tienen algo en común: todos los enlaces son locales al componente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando nos suscribimos a un objeto observable, almacena una lista de suscriptores. </font><font style="vertical-align: inherit;">Nuestra devolución de llamada también está en esta lista, y la devolución de llamada puede referirse a nuestro componente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/49f/92e/bda49f92eb184ad1eb78231a4144b71c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin pérdida de memoria</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cuando se destruye un componente, es decir, cuando Angular ya no tiene un enlace, lo que significa que no se puede alcanzar el componente desde el nodo raíz, tampoco se puede alcanzar el objeto observado y su lista de suscriptores desde el nodo raíz. Como resultado, todo el objeto componente es basura recolectada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras estemos suscritos a un objeto observable, cuyos enlaces están solo dentro del componente, no surgen problemas. Pero cuando el servicio entra en juego, la situación cambia.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/6f7/b5b/4546f7b5b2ab2d2858f550740243189e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pérdida de memoria</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tan pronto como nos suscribimos a un objeto observable proporcionado por un servicio u otra clase, creamos una pérdida de memoria. </font><font style="vertical-align: inherit;">Esto se debe al objeto observado, debido a su lista de suscriptores. </font><font style="vertical-align: inherit;">Debido a esto, la devolución de llamada, y por lo tanto el componente, son accesibles desde el nodo raíz, aunque Angular no tiene una referencia directa al componente. </font><font style="vertical-align: inherit;">Como resultado, el recolector de basura no toca el objeto correspondiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aclararé: puede usar tales construcciones, pero necesita trabajar con ellas correctamente, y no como nosotros.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajo de suscripción adecuado</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar pérdidas de memoria, es importante darse de baja correctamente del objeto observado, haciendo esto cuando la suscripción ya no sea necesaria. Por ejemplo, cuando se destruye un componente. Hay muchas formas de darse de baja de un objeto observado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La experiencia de asesorar a los propietarios de grandes proyectos corporativos indica que, en esta situación, es mejor utilizar la entidad </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creada por el equipo </font></font><code>new Subject&lt;void&gt;()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en combinación con el operador </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;private destroy$: Subject&lt;<span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-keyword">void</span>&gt;();<font></font>
&nbsp;&nbsp;randomNumber = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummyService.some$.pipe(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;takeUntil(<span class="hljs-keyword">this</span>.destroy$)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-keyword">this</span>.randomNumber = value);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;ngOnDestroy(): <span class="hljs-keyword">void</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.complete();<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí nos damos de baja de la suscripción utilizando el </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operador y </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">después de la destrucción del componente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementamos un enlace de ciclo de vida en el componente </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada vez que se destruye un componente, llamamos </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">métodos </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La llamada es </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy importante porque borra la suscripción </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego usamos el operador </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y le pasamos nuestro flujo </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto garantiza que la suscripción se borre (es decir, que nos hemos dado de baja de la suscripción) después de que se destruya el componente.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo recordar borrar las suscripciones?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es fácil olvidar agregar el componente </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y olvidar llamar </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el ciclo de vida de Hook </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Incluso a pesar del hecho de que enseñé esto a los equipos que trabajan en proyectos, a menudo lo olvidé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente, existe una maravillosa regla de linter, que forma parte de un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de reglas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que le permite garantizar la baja de las suscripciones. </font><font style="vertical-align: inherit;">Puede establecer un conjunto de reglas como este:</font></font><br>
<br>
<pre><code class="javascript hljs">npm install @angular-extensions/lint-rules --save-dev
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces debe estar conectado a </font></font><code>tslint.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-string">"extends"</span>: [
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"tslint:recommended"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"@angular-extensions/lint-rules"</span><font></font>
&nbsp;&nbsp;]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le recomiendo que use este conjunto de reglas en sus proyectos. </font><font style="vertical-align: inherit;">Esto le ahorrará muchas horas de depuración para encontrar fuentes de pérdidas de memoria.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Angular, es muy fácil crear una situación que provoque pérdidas de memoria. </font><font style="vertical-align: inherit;">Incluso pequeños cambios de código en lugares que, aparentemente, no deberían estar relacionados con pérdidas de memoria, pueden tener graves consecuencias adversas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mejor manera de evitar pérdidas de memoria es administrar sus suscripciones correctamente. </font><font style="vertical-align: inherit;">Desafortunadamente, el funcionamiento de las suscripciones de limpieza requiere una gran precisión por parte del desarrollador. </font><font style="vertical-align: inherit;">Esto es fácil de olvidar. </font><font style="vertical-align: inherit;">Por lo tanto, se recomienda que aplique reglas </font></font><code>@angular-extensions/lint-rules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que lo ayuden a organizar el trabajo correcto con sus suscripciones. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí está el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repositorio con el código subyacente a este material. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Ha encontrado pérdidas de memoria en aplicaciones angulares?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es503288/index.html">Cómo buscamos candidatos mediante el aprendizaje automático</a></li>
<li><a href="../es503290/index.html">Revisión de quadrocopter industrial DJI Matrice 300 RTK</a></li>
<li><a href="../es503300/index.html">El libro "Rick y Morty. Guía de los dibujos animados más brillantes de todas las galaxias »</a></li>
<li><a href="../es503302/index.html">Acelerar la compilación de un proyecto en CMake + GCC: precompilación de archivos de encabezado</a></li>
<li><a href="../es503310/index.html">¿Qué piensan los programadores senior?</a></li>
<li><a href="../es503318/index.html">Profesión: Programador. No todo esta claro</a></li>
<li><a href="../es503322/index.html">Desarrollo de Firmware: Introducción</a></li>
<li><a href="../es503324/index.html">"En la cima" de Brad Stalberg y Steve Magness: prevención de la combustión espontánea (primera parte)</a></li>
<li><a href="../es503328/index.html">Compilamos la aplicación Spring Boot en nativo usando GraalVM</a></li>
<li><a href="../es503330/index.html">Cómo aprender de un científico de datos: las habilidades técnicas más buscadas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>