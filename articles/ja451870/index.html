<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏾 🔄 🚌 すべてのプログラマーが知っておく必要のある最新のC ++機能 🚝 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👩🏾‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="資料の作成者は、その翻訳を本日公開していますが、C ++は、この言語が数年前にあったものと比較すると、現在の形式では、大幅に改善されたと述べています。もちろん、これらの変更はすぐには起こりませんでした。たとえば、昔はC ++にはダイナミズムがありませんでした。彼がこの言語に優しい感情を持っていると言...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>すべてのプログラマーが知っておく必要のある最新のC ++機能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資料の作成者は、その翻訳を本日公開していますが、C ++は、この言語が数年前にあったものと比較すると、現在の形式では、大幅に改善されたと述べています。もちろん、これらの変更はすぐには起こりませんでした。たとえば、昔はC ++にはダイナミズムがありませんでした。彼がこの言語に優しい感情を持っていると言える人を見つけるのは簡単ではありませんでした。言語の標準化を担当する人々が革新に道を譲ることにしたとき、すべてが変化しました。 2011年、C ++は動的言語になりました。動的言語は常に進化し、プログラマーにはるかに肯定的な感情を引き起こします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語が簡単になったとは思わないでください。</font><font style="vertical-align: inherit;">それは、最も複雑ではないにしても、最も複雑で広く使用されているプログラミング言語の1つと呼ぶことができます。</font><font style="vertical-align: inherit;">しかし、最近のC ++は以前よりもずっと親しみやすくなっています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日は、プログラマーが知っておくと便利な言語のいくつかの新機能（ちなみに、すでに8年前のC ++ 11以降）についてお話します。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動キーワード</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワードがC ++ 11に登場して以来、</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラマーの生活はより簡単になりました。このキーワードのおかげで、コンパイラーはコンパイル時に変数の型を出力できるため、常に自分で型を指定する必要がなくなります。これは、たとえばのようなデータ型を使用する必要がある場合などに非常に便利</font></font><code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。キーワードを使用するときは、</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの機能を考慮する必要があります。例を考えてみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> an_int = <span class="hljs-number">26</span>; <span class="hljs-comment">//    ,     - int</span>
<span class="hljs-keyword">auto</span> a_bool = <span class="hljs-literal">false</span>; <span class="hljs-comment">//   bool</span>
<span class="hljs-keyword">auto</span> a_float = <span class="hljs-number">26.04</span>; <span class="hljs-comment">//   float</span>
<span class="hljs-keyword">auto</span> ptr = &amp;a_float; <span class="hljs-comment">//      </span>
<span class="hljs-keyword">auto</span> data; <span class="hljs-comment">// #1     ?    - .</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例の最後の行に注目してください。コメントがマークされています</font></font><code>#1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以下、同様に、例の後で解析する行にマークを付けます）。この行には初期化子がありません。これは実行できません。この行にあるコードは、コンパイラーが対応する変数の型が何であるかを認識できないようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ </font><font style="vertical-align: inherit;">でのキーワードの可能性</font><font style="vertical-align: inherit;">はかなり制限されていました。次に、言語のより最近のバージョンでは、機会が</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加されました。次に別の例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)</span> <span class="hljs-comment">//            auto!</span>
</span>{
 &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; c = do_something(a, b);
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> c;<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a = { ... }; <span class="hljs-comment">// #1 - </span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; b = { ... }; <span class="hljs-comment">// #2  - </span>
<span class="hljs-keyword">auto</span> c = merge(a,b); <span class="hljs-comment">//      </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行</font></font><code>#1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>#2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中括弧の使用で変数を初期化するために使用- C ++ 11のもう一つの新機能</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Doがキーワードを使用していることを忘れないで</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイラに変数の型を取得するための、いくつかの方法である必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、興味深い質問です。</font><font style="vertical-align: inherit;">このようなデザインを使用するとどうなります</font></font><code>auto a = {1, 2, 3}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">それは何ですか？</font><font style="vertical-align: inherit;">ベクトル、またはコンパイルエラーの原因？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ビュー構造はC ++ 11で登場しました</font></font><code>std::initializer_list&lt;type&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">括弧内の初期化値のリストは、キーワードを使用するときにコンテナーと見なされ</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、すでに述べたように、複雑なデータ構造で作業する必要がある場合、コンパイラーによる型推論は非常に役立ちます。</font><font style="vertical-align: inherit;">次に例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">populate</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;data)</span> </span>{ <span class="hljs-comment">//    !</span>
 &nbsp;&nbsp;&nbsp;data.insert({<span class="hljs-string">"a"</span>,{<span class="hljs-number">1</span>,<span class="hljs-number">4</span>}});<font></font>
 &nbsp;&nbsp;&nbsp;data.insert({<span class="hljs-string">"b"</span>,{<span class="hljs-number">3</span>,<span class="hljs-number">1</span>}});<font></font>
 &nbsp;&nbsp;&nbsp;data.insert({<span class="hljs-string">"c"</span>,{<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}});<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> data, <span class="hljs-keyword">auto</span> upcoming_data)</span> </span>{ <span class="hljs-comment">//      </span>
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">auto</span> result = data;
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it: upcoming_data) {<font></font>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.insert(it);<font></font>
 &nbsp;&nbsp;&nbsp;}<font></font>
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
 &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; data;<font></font>
 &nbsp;&nbsp;&nbsp;populate(data);<font></font>
<font></font>
 &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; upcoming_data;<font></font>
 &nbsp;&nbsp;&nbsp;upcoming_data.insert({<span class="hljs-string">"d"</span>,{<span class="hljs-number">5</span>,<span class="hljs-number">3</span>}});<font></font>
<font></font>
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">auto</span> final_data = merge(data,upcoming_data);<font></font>
<font></font>
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> itr: final_data) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">auto</span> [v1, v2] = itr.second; <span class="hljs-comment">// #1        </span>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; itr.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-built_in">std</span>:<span class="hljs-built_in">endl</span>;<font></font>
 &nbsp;&nbsp;&nbsp;}<font></font>
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラインを見てください</font></font><code>#1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">式</font></font><code>auto [v1,v2] = itr.second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はC ++ 17の新機能です。これは、いわゆる変数宣言の分解です。</font><font style="vertical-align: inherit;">以前のバージョンの言語では、各値を個別に抽出する必要がありました。</font><font style="vertical-align: inherit;">このメカニズムのおかげで、そのような操作を実行することがはるかに便利になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、データを操作する場合は、この構造のリンクを使用するだけで、1つの文字をフォームに変換して追加でき</font></font><code>auto &amp;[v1,v2] = itr.second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラムダ式</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11では、ラムダ式のサポートが導入されています。それらはJavaScriptの匿名関数に似ており、名前のない機能オブジェクトと比較できます。それらは、その記述に応じてさまざまなスコープ内の変数をキャプチャーし、コンパクトな構文構成が使用されます。さらに、変数に割り当てることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラムダ式は、コードで小さな操作を実行する必要があるが、このための個別の関数を記述したくない場合に非常に便利なツールです。もう1つの一般的な使用例は、値の比較に使用される関数の作成です。例えば：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; data = {{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>}, {<span class="hljs-number">7</span>,<span class="hljs-number">6</span>}, {<span class="hljs-number">12</span>, <span class="hljs-number">4</span>}}; <span class="hljs-comment">//       </span>
<span class="hljs-built_in">std</span>::sort(begin(data), end(data), [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) { <span class="hljs-comment">//   - auto!</span>
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> a.second &lt; b.second;<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この短い例では、多くの興味深いことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、中括弧を使用して変数の初期化を使用することがいかに便利であるかに注意してください。次に、</font><font style="vertical-align: inherit;">C ++ 11にも登場し</font><font style="vertical-align: inherit;">た標準の構造体</font></font><code>begin()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font><font style="vertical-align: inherit;">確認できます</font></font><code>end()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、データを比較するメカニズムとして使用されるラムダ関数が表示されます。この関数のパラメーターはキーワードを使用して宣言されます。この機能は</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 14で導入されました。以前は、このキーワードを使用して関数のパラメーターを記述することはできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、ラムダ式が角括弧で始まることに注意してください-</font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、いわゆる変数のマスクです。</font><font style="vertical-align: inherit;">式のスコープを決定します。つまり、ラムダ式とローカル変数およびオブジェクトとの関係を制御できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、</font><font style="vertical-align: inherit;">最新のC ++機能専用の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font><font style="vertical-align: inherit;">からの抜粋</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<ul>
<li><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-式は何もキャプチャしません。</font><font style="vertical-align: inherit;">つまり、ラムダ式では、外部のスコープからローカル変数を使用することはできません。</font><font style="vertical-align: inherit;">式で使用できるのはパラメーターのみです。</font></font></li>
<li><code>[=]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-式はローカルオブジェクト（つまり、ローカル変数、パラメーター）の値をキャプチャします。</font><font style="vertical-align: inherit;">つまり、それらは使用できますが、変更することはできません。</font></font></li>
<li><code>[&amp;]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-式は、ローカルオブジェクトへの参照をキャプチャします。</font><font style="vertical-align: inherit;">次の例に示すように、変更できます。</font></font></li>
<li><code>[this]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-式は、ポインターの値をキャプチャします</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><code>[a, &amp;b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-式は、オブジェクトの値とオブジェクト</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への参照を</font><font style="vertical-align: inherit;">キャプチャ</font><font style="vertical-align: inherit;">します</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ラムダ関数内でデータを他の形式に変換する必要がある場合は、上記のメカニズムを使用できます。</font><font style="vertical-align: inherit;">例を考えてみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; data = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>};
<span class="hljs-keyword">int</span> factor = <span class="hljs-number">7</span>;<font></font>
for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword">int</span> &amp;val) { <span class="hljs-comment">//    factor  </span><font></font>
 &nbsp;&nbsp;&nbsp;val = val * factor;<font></font>
 &nbsp;&nbsp;&nbsp;factor--; <span class="hljs-comment">// #1   - ,  -    factor  </span><font></font>
});<font></font>
<font></font>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> val: data) {
 &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>; <span class="hljs-comment">// 14 24 20 4 3 6 9</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、変数が</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値でアクセスされた場合（変数マスクを使用してラムダ式を記述することになります</font></font><code>[factor]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、</font></font><code>#1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を</font><font style="vertical-align: inherit;">文字列</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で変更</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことはできません。これ</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">そのような操作を実行する権限がないためです。</font><font style="vertical-align: inherit;">この例では、そのような行為を行う権利があります。</font><font style="vertical-align: inherit;">そのような状況では、参照によって変数にアクセスする機能を乱用しないことが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なお、アクセス</font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も参考にしてください。</font><font style="vertical-align: inherit;">これにより、ラムダ関数で発生するデータ変更が確実に影響し</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifおよびswitch構文内の変数初期化式</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このC ++ 17の革新は、それを知った直後からとても気に入りました。</font><font style="vertical-align: inherit;">例を考えてみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; input = {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>};<font></font>
<font></font>
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> it = input.find(<span class="hljs-number">7</span>); it==input.end()){ <span class="hljs-comment">//   - ,  - </span>
 &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">7</span> &lt;&lt; <span class="hljs-string">" not found"</span> &lt;&lt; <span class="hljs-built_in">std</span>:<span class="hljs-built_in">endl</span>;<font></font>
}<font></font>
<span class="hljs-keyword">else</span> {
 &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    else      it</span>
 &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">7</span> &lt;&lt; <span class="hljs-string">" is there!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、変数を初期化して、1つ</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">ブロックでの使用と比較できることがわかりました</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはきちんとしたコードを書くのに役立ちます。</font><font style="vertical-align: inherit;">以下は、検討中の構造の概略図です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>( init-statement(x); condition(x)) {
 &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//   </span>
} <span class="hljs-keyword">else</span> {
 &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//     x</span>
 &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//   </span>
}</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexprを使用したコンパイル時の計算の実行</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちに大きな機会を与えてくれます。計算が必要なある種の式があるとしますが、その値は、対応する変数で初期化した後、変更されません。このような式は、事前に計算してマクロとして使用できます。または、C ++ 11で可能になったこととして、キーワードを使用し</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマは、プログラムの実行中に実行される計算量を最小限に抑えるよう努めています。その結果、コンパイルプロセス中に特定の操作を実行できるため、プログラムの実行中にシステムから負荷を取り除くことができる場合、これは実行時のプログラムの動作に良い影響を与えます。次に例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>{ <span class="hljs-comment">//       constexpr</span>
    <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (fact(n<span class="hljs-number">-1</span>) * n);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bigval = fact(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;bigval&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に一般的な使用例</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
階乗を計算するための関数をとして宣言しているため</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイラー</font></font><code>fact(20)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はプログラムのコンパイル中</font><font style="vertical-align: inherit;">に値を事前計算でき</font><font style="vertical-align: inherit;">ます。その結果、コンパイル後に文字列</font></font><code>const long long bigval = fact(20);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をに置き換えることができます</font></font><code>const long long bigval = 2432902008176640000;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数に渡される引数は定数で表されることに注意してください。これは、キーワードを使用して宣言された関数を使用する上で重要な機能です</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらに渡される引数も、キーワード</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">キーワードを使用して宣言する必要があります</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それ以外の場合、そのような関数は通常の関数のように動作します。つまり、コンパイル時に、それらの値は事前に計算されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数は、キーワードを使用して宣言することもでき</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この場合、ご想像のとおり、これらの変数の値はコンパイル時に計算する必要があります。</font><font style="vertical-align: inherit;">これが実行できない場合、コンパイルエラーメッセージが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後でC ++ 17で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr-if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr-lambda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文が登場したことに注目するのは興味深いことです</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タプルのデータ構造</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ構造と同様に、データ</font></font><code>pair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造</font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（タプル）は、固定サイズのさまざまなタイプの値のコレクションです。</font><font style="vertical-align: inherit;">次に例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> user_info = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-string">"M"</span>, <span class="hljs-string">"Chowdhury"</span>, <span class="hljs-number">25</span>); <span class="hljs-comment">//  auto    </span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(user_info);
<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(user_info);
<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">2</span>&gt;(user_info);<font></font>
<font></font>
<span class="hljs-comment">//  C++ 11     tie</span><font></font>
<font></font>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> first_name, last_name, age;
<span class="hljs-built_in">std</span>::tie(first_name, last_name, age) = user_info;<font></font>
<font></font>
<span class="hljs-comment">//  C++ 17, ,      </span>
<span class="hljs-keyword">auto</span> [first_name, last_name, age] = user_info;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ構造の代わり</font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に使用した方が便利な場合</font><font style="vertical-align: inherit;">があります</font></font><code>std::array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このデータ構造は、C言語で使用される単純な配列に似ており、C ++標準ライブラリの追加機能を備えています。</font><font style="vertical-align: inherit;">このデータ構造はC ++ 11で登場しました。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラステンプレートの引数の型を自動的に推論する</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能の名前はかなり長く複雑に見えますが、実際にはここでは複雑なことは何もありません。</font><font style="vertical-align: inherit;">ここでの主なアイデアは、C ++ 17では、型引数の引数も標準クラステンプレートに出力されるということです。</font><font style="vertical-align: inherit;">以前は、これは機能テンプレートでのみサポートされていました。</font><font style="vertical-align: inherit;">その結果、以前は次のように書いていたことがわかります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; user = {<span class="hljs-string">"M"</span>, <span class="hljs-number">25</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17のリリースにより、この設計はこれに置き換えることができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::pair user = {<span class="hljs-string">"M"</span>, <span class="hljs-number">25</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型推論は暗黙的に行われます。</font><font style="vertical-align: inherit;">このメカニズムは、タプルに関してはさらに便利です。</font><font style="vertical-align: inherit;">つまり、私は次のように書く前に：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">user</span> <span class="hljs-params">(<span class="hljs-string">"M"</span>, <span class="hljs-string">"Chy"</span>, <span class="hljs-number">25</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで同じことが次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::tuple <span class="hljs-title">user2</span><span class="hljs-params">(<span class="hljs-string">"M"</span>, <span class="hljs-string">"Chy"</span>, <span class="hljs-number">25</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの機能は、C ++テンプレートに特に詳しくない人にとっては、注目に値するものではないようです。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スマートポインター</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++でポインターを操作することは、実際には悪夢のようです。</font><font style="vertical-align: inherit;">言語がプログラマーに与える自由のおかげで、彼らが言うように、彼が「足で自分を撃たない」ことは時々非常に困難です。</font><font style="vertical-align: inherit;">多くの場合、ポインタはプログラマのそのような「ショット」を押しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、C ++ 11では、通常のポインターよりもはるかに便利なスマートポインターが導入されました。</font><font style="vertical-align: inherit;">それらは、可能であればリソースを解放することにより、プログラマーがメモリーリークを回避するのに役立ちます。</font><font style="vertical-align: inherit;">さらに、例外のセキュリティを保証します。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良いリポジトリがあります。C++の革新に追随する人々がこれをドロップするのは興味深いでしょう。</font><font style="vertical-align: inherit;">この言語には常に新しいものが現れています。</font><font style="vertical-align: inherit;">ここでは、言語のいくつかの現代的な機能のみに触れました。</font><font style="vertical-align: inherit;">実際、たくさんあります。</font><font style="vertical-align: inherit;">私たちはまだそれらについて話している可能性があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近のC ++のどの機能で最も興味深く、便利だと思いますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451858/index.html">Springで簡単なキャッシュベースのサーキットブレーカーを作る</a></li>
<li><a href="../ja451860/index.html">Математики обнаружили идеальный способ перемножения чисел</a></li>
<li><a href="../ja451862/index.html">Joe Diprimaのミュージカルライトニング：独学のエンジニアがテスラをエンターテインメントと収益に結びつけています</a></li>
<li><a href="../ja451864/index.html">Windows OSで検出されたEternalBlueレベルの重大なRCE脆弱性</a></li>
<li><a href="../ja451866/index.html">ネットワーク内の最も近いノードを選択します</a></li>
<li><a href="../ja451872/index.html">Pythonは、旅行が好きな人のための格安航空券の検索のアシスタントです</a></li>
<li><a href="../ja451874/index.html">GoogleのトップSEOトレンド</a></li>
<li><a href="../ja451876/index.html">フランクフルトデータセンター：Telehouseデータセンター</a></li>
<li><a href="../ja451878/index.html">VRグラス（Oculus Go）へのステレオビデオのライブストリーミング</a></li>
<li><a href="../ja451880/index.html">DevPRO'19：Wrikeブースからの眺め</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>