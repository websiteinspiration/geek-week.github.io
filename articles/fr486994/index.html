<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎾 🕣 🧑🏽‍🤝‍🧑🏼 Angulaire: test d'intégration (test peu profond) 📯 🥝 👐🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque l'application grandit, ou qu'il est très important pour nous qu'elle fonctionne correctement avec tout refactoring, nous commençons à penser a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Angulaire: test d'intégration (test peu profond)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/486994/"><img src="https://habrastorage.org/webt/6q/1i/kq/6q1ikqijgoa4cfkq7fk7n2di1ey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque l'application grandit, ou qu'il est très important pour nous qu'elle fonctionne correctement avec tout refactoring, nous commençons à penser aux tests unitaires ou e2e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant plusieurs années de travail avec Angular - applications dans le segment des entreprises, ayant rencontré de nombreux problèmes lors de la refactorisation et de la création de nouvelles fonctionnalités, les tests ne semblent pas être une perte de temps, mais la clé de la stabilité entre les mains des programmeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, essayons de comprendre comment tester l'application de base sur Angular et abordons un peu la théorie.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par les types de tests que les développeurs d'applications peuvent faire (dans notre cas, frontend). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wp/hc/q_/wphcq_xxcqgyvvyvoyvjlbyvx3w.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Martin Fowler et Google Testing Blog)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Angular propose de telles méthodes prêtes à l'emploi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons de plus près la pyramide de test en utilisant l'exemple des applications angulaires. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tests unitaires</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><b><font style="vertical-align: inherit;">tests</font></b><font style="vertical-align: inherit;"> isolés des méthodes de classe. Nous vérifions le fonctionnement de la méthode, en passant diverses combinaisons de paramètres à l'entrée, et comparons le résultat avec celui attendu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, nous avons un composant dans lequel les chaînes hexadécimales sont converties en rgb, ces informations sont affichées pour l'utilisateur et également envoyées au serveur de repos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous commençons à chercher des tests unitaires, nous pouvons alors écrire de nombreux tests pour chaque méthode de la classe de composants.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous avons une méthode rgbToHex (hex: string) =&gt; string, alors pour tester une méthode avec une telle signature, nous devons faire ce qui suit: expect (rgbToHex ('777')). ToBe ('rgb (119, 119, 119)')) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela semble génial, mais nous avons un problème en raison du grand nombre de fonctions qui doivent être couvertes, et nous devenons trop paresseux pour écrire des tests. De plus, même en écrivant des tests unitaires pour chaque méthode d'un composant, nous ne garantissons pas l'exactitude de leur travail commun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, après avoir créé et testé le composant de sortie de table, nous pouvons l'appeler dans le composant «calculatrice», mais spécifier accidentellement la mauvaise liaison. Ensuite, les données ne tomberont pas dans les tableaux et les composants pleinement fonctionnels ne fonctionneront pas correctement. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1j/w3/jm/1jw3jm9muxpvatfvgf6_oqjn9ms.gif" alt="image"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test d'intégration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- tester un tas de plusieurs composants. A partir de cette étape, nous commençons à tester non seulement les méthodes de classe, mais aussi leur liaison au html, c'est-à-dire cliquez sur les éléments à l'intérieur du composant. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les tests superficiels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se trouvent souvent dans la notation angulaire </font><font style="vertical-align: inherit;">, qui est essentiellement des tests d'intégration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors des tests peu profonds, nous nous attarderons plus en détail ci-dessous. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tests E2E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (de bout en bout) - un moyen de tester complètement l'application pour résoudre les problèmes des tests unitaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette approche, nous écrivons des scripts de test pour une application entièrement rendue, c'est-à-dire tous les composants et services sont assemblés ensemble et nous reproduisons les actions de l'utilisateur.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est très cool, mais nous pouvons avoir le problème de changer dynamiquement les stubs (généralement un serveur json statique sur node.js), et pour jouer à différentes situations, nous pouvons avoir besoin de données différentes du serveur émulé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple: nous avons une page avec une liste d'utilisateurs, l'un des composants de ce panneau est la pagination. Il doit se comporter différemment avec différents nombres d'utilisateurs. Mais si les données sur le serveur émulé sont définies via json, le nombre d'utilisateurs sera toujours un et nous ne pourrons pas vérifier tous les cas avec un nombre de pages différent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, nous pouvons conclure que si nous voulons changer les stubs de manière flexible et tester non pas par des méthodes, mais par des unités logiques de l'interface, nous devons utiliser quelque chose entre e2e et les tests unitaires. </font><font style="vertical-align: inherit;">C'est là que les tests superficiels (tests d'intégration) viennent à la rescousse. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glossaire:</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les maquettes sont des objets pour simuler des réponses dans divers cas d'utilisation.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les stubs sont les stubs les plus stupides sans logique (vous pouvez lire Martin).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karma est un lanceur de test intégré à angulaire (souvent conseillé d'utiliser la plaisanterie à la place, mais pas à ce sujet aujourd'hui).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jasmine est un cadre pour décrire les tests sous forme de spécifications (voir ci-dessous).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spec - extension de fichier de test (description des spécifications dans le style BDD).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est le nom des méthodes de tests dans Jasmine.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xit est le nom des méthodes qui ne s'exécuteront pas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fit - s'il existe des méthodes portant le même nom dans les spécifications, seules elles seront lancées.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les tests superficiels pour Angular, ainsi que pour d'autres frameworks, sont une approche de test unitaire, lorsqu'un composant de taille suffisamment grande est rendu pour qu'il puisse exister en tant qu'unité distincte d'interface utilisateur avec ses propres fonctionnalités. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, nous avons un composant pour convertir hex -&gt; rgb. Nous pouvons uniquement rendre ce composant, générer des stubs pour différentes situations, exécuter des cas d'utilisation possibles pour ce composant du point de vue des utilisateurs finaux et vérifier le fonctionnement du composant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons de trouver un exemple (référentiel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Préparez la classe pour accéder aux composants du composant conformément à PageObject et ajoutez un assistant à la racine du projet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aide - aidera à rechercher des éléments dans les composants qui ont été sélectionnés pour le rendu. </font><font style="vertical-align: inherit;">Nous pouvons donc rendre la vie plus facile si nous utilisons un matériau angulaire: les éléments de type select créeront alors une liste avec option dans un bloc séparé, et la recherche de ces éléments peut conduire à des passe-partout, et un wrapper sous la forme d'une aide peut vous aider.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectBase</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private root: HTMLDivElement) { }
  <span class="hljs-comment">//    input  </span>
  _inputValue(cssSelector: string, <span class="hljs-attr">value</span>: string) { 
    <span class="hljs-keyword">if</span> (value) {
      <span class="hljs-keyword">this</span>.root.querySelector&lt;HTMLInputElement&gt;(cssSelector).value = value;
      <span class="hljs-keyword">this</span>.root.querySelector&lt;HTMLInputElement&gt;(cssSelector).dispatchEvent(<span class="hljs-keyword">new</span> Event(<span class="hljs-string">'input'</span>));<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.root.querySelector&lt;HTMLInputElement&gt;(cssSelector).value<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">//          </span><font></font>
  _buttonClick(cssSelector: string) {<font></font>
    <span class="hljs-keyword">this</span>.root.querySelector&lt;HTMLButtonElement&gt;(cssSelector).dispatchEvent(<span class="hljs-keyword">new</span> Event(<span class="hljs-string">'click'</span>));<font></font>
  }<font></font>
<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PageObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un modèle de test automatisé populaire. </font><font style="vertical-align: inherit;">Utilisé pour simplifier la prise en charge des tests écrits. </font><font style="vertical-align: inherit;">Si nous changeons l'interface utilisateur, nous n'avons pas à réécrire les tests, il suffit de changer les sélecteurs d'éléments.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConverterFromHexPageObject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PageObjectBase</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(root: HTMLDivElement) {
    <span class="hljs-keyword">super</span>(root)<font></font>
  }<font></font>
<font></font>
  hex(text?: string) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._inputValue(<span class="hljs-string">'.input-hex'</span>, text);<font></font>
  }<font></font>
<font></font>
  rgb(text?: string) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._inputValue(<span class="hljs-string">'.input-rgb'</span>, text);<font></font>
  }<font></font>
<font></font>
  clear() {<font></font>
    <span class="hljs-keyword">this</span>._buttonClick(<span class="hljs-string">'.btn-clear'</span>)<font></font>
  }<font></font>
<font></font>
  calc() {<font></font>
    <span class="hljs-keyword">this</span>._buttonClick(<span class="hljs-string">'.btn-calc'</span>)<font></font>
  }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et les tests eux-mêmes:</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">// ,        api   </span>
<span class="hljs-keyword">const</span> urlToSave = <span class="hljs-string">'http://localhost:4200/save-hex'</span>;<font></font>
<font></font>
<font></font>
<span class="hljs-comment">//  -   </span>
describe(<span class="hljs-string">'ConverterFromHexComponent'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> component: ConverterFromHexComponent;
  <span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;ConverterFromHexComponent&gt;;
  <span class="hljs-keyword">let</span> page: ConverterFromHexPageObject;
  <span class="hljs-keyword">let</span> httpTestingController: HttpTestingController;<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">//      ,   </span>
  beforeEach(<span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    TestBed.configureTestingModule({<font></font>
      <span class="hljs-attr">imports</span>: [ConverterModule, HttpClientTestingModule]<font></font>
    })<font></font>
      .compileComponents();<font></font>
    httpTestingController = TestBed.get(HttpTestingController);<font></font>
  }));<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">//  ,   </span>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    fixture = TestBed.createComponent(ConverterFromHexComponent);<font></font>
    component = fixture.componentInstance;<font></font>
    page = <span class="hljs-keyword">new</span> ConverterFromHexPageObject(fixture.nativeElement);<font></font>
    fixture.detectChanges();<font></font>
  });<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">//    ,     http </span>
  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    httpTestingController.verify();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should create'</span>, () =&gt; {<font></font>
    expect(component).toBeTruthy();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should clear'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    page.hex(<span class="hljs-string">'112233'</span>); <span class="hljs-comment">//  input  </span>
    expect(page.hex()).toBe(<span class="hljs-string">'112233'</span>); <span class="hljs-comment">// ,    </span>
    <span class="hljs-keyword">await</span> page.clear(); <span class="hljs-comment">//      </span>
    fixture.detectChanges(); <span class="hljs-comment">//    </span>
    expect(page.hex()).toBe(<span class="hljs-string">''</span>); <span class="hljs-comment">// ,   clear </span><font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should convert'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    page.hex(<span class="hljs-string">'123123'</span>);<font></font>
    expect(page.rgb()).toBe(<span class="hljs-string">''</span>);<font></font>
    page.calc();<font></font>
    <span class="hljs-keyword">const</span> req = httpTestingController.expectOne(urlToSave);<font></font>
    expect(req.request.method).toEqual(<span class="hljs-string">'POST'</span>);<font></font>
    expect(req.request.body.hex).toEqual(<span class="hljs-string">'123123'</span>);<font></font>
    req.flush({});<font></font>
    <span class="hljs-keyword">await</span> fixture.detectChanges();<font></font>
    expect(page.rgb()).toBe(<span class="hljs-string">'rgb(18, 49, 35)'</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should convert three-digit hex'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    page.hex(<span class="hljs-string">'567'</span>);<font></font>
    expect(page.rgb()).toBe(<span class="hljs-string">''</span>);<font></font>
    page.calc();<font></font>
    <span class="hljs-keyword">const</span> req = httpTestingController.expectOne(urlToSave);<font></font>
    expect(req.request.method).toEqual(<span class="hljs-string">'POST'</span>);<font></font>
    req.flush({});<font></font>
    <span class="hljs-keyword">await</span> fixture.detectChanges();<font></font>
    expect(page.rgb()).toBe(<span class="hljs-string">'rgb(85, 102, 119)'</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'rgb should be empty when entered incorrectly hex'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    page.hex(<span class="hljs-string">'qw123we'</span>);<font></font>
    page.calc();<font></font>
    <span class="hljs-keyword">const</span> req = httpTestingController.expectNone(urlToSave);
    <span class="hljs-keyword">await</span> fixture.detectChanges();<font></font>
    expect(page.rgb()).toBe(<span class="hljs-string">''</span>);<font></font>
  });<font></font>
<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout semble simple, mais voici quelques notes intéressantes pour les tests Angular Shallow:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifiez toujours qu'il n'y a pas de requêtes http non réservées, cela vous aidera à comprendre exactement s'il y a des requêtes inutiles pour notre fonctionnalité.</font></font></li>
<li>     PageObject ,      .</li>
<li>    json       ,      .</li>
<li>        ,       .</li>
<li>   .</li>
<li>    . </li>
<li>    ,    session, local, cookie    (  ).</li>
<li>      fake.js. </li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>. </li>
</ul><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486994/">https://habr.com/ru/post/fr486994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486978/index.html">Notes de terrain: l'une des plus grandes conférences OpenSource FOSDEM 2020</a></li>
<li><a href="../fr486980/index.html">Kim Dotcom: Caught, la personne la plus recherchée en ligne. Partie 1</a></li>
<li><a href="../fr486982/index.html">Comment apprendre le développement frontal, trouver son premier emploi et ne pas se faire de soucis</a></li>
<li><a href="../fr486984/index.html">Passerelle Python sur InterSystems IRIS</a></li>
<li><a href="../fr486988/index.html">Station météo de poche</a></li>
<li><a href="../fr486998/index.html">Impression d'imprimante thermique chèque pas cher et rapide</a></li>
<li><a href="../fr487000/index.html">Agrumes: ensemble de styles pour AvaloniaUI</a></li>
<li><a href="../fr487002/index.html">Marketing en réalité augmentée: qu'est-ce que c'est et comment ça marche</a></li>
<li><a href="../fr487004/index.html">Pourquoi de plus en plus d'États américains renvoient la neutralité du réseau - discuter du cours des événements</a></li>
<li><a href="../fr487006/index.html">Utilitaires de console Linux qui peuvent vous faciliter la vie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>