<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏽 👨🏿‍⚖️ 😾 Kinerja Java modern ketika bekerja dengan sejumlah besar data, bagian 1 👐🏿 👨‍👦‍👦 🎒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java runtime telah berkembang lebih cepat dalam beberapa tahun terakhir daripada sebelumnya. Setelah 15 tahun, kami akhirnya mendapatkan pengumpul sam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kinerja Java modern ketika bekerja dengan sejumlah besar data, bagian 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/506706/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gy/8p/zf/gy8pzf7gjtwr9pvv1zb7rgmmjiy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java runtime telah berkembang lebih cepat dalam beberapa tahun terakhir daripada sebelumnya. </font><font style="vertical-align: inherit;">Setelah 15 tahun, kami akhirnya mendapatkan pengumpul sampah default - G1. </font><font style="vertical-align: inherit;">Dua lagi sedang dikembangkan dan tersedia sebagai fungsi eksperimental - Oracle ZGC dan OpenJDK Shenandoah. </font><font style="vertical-align: inherit;">Kami memutuskan untuk menguji semua alat baru ini dan mencari tahu apa yang paling sesuai dengan beban kerja yang khas dari mesin streaming open source Hazelcast Jet.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jet digunakan untuk menyelesaikan semua jenis tugas, dengan kebutuhan latensi dan bandwidth yang berbeda. </font><font style="vertical-align: inherit;">Tugas terbagi dalam tiga kategori penting:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streaming latensi rendah tanpa batas. </font><font style="vertical-align: inherit;">Contoh: mengidentifikasi tren dalam data dari sensor 10.000 perangkat yang mengambil informasi pada frekuensi 100 Hz, dan mengirimkan koreksi dalam 10-20 ms.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan streaming tanpa batas dengan bandwidth tinggi. </font><font style="vertical-align: inherit;">Contoh: melacak koordinat GPS dari jutaan pengguna dengan menghitung vektor kecepatannya.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan batch besar data besar. </font><font style="vertical-align: inherit;">Kriterianya adalah waktu yang dihabiskan untuk pemrosesan, yang berarti bahwa throughput yang tinggi diperlukan. </font><font style="vertical-align: inherit;">Contoh: analisis data perdagangan saham yang dikumpulkan per hari untuk memperbarui tingkat risiko untuk portofolio aset tertentu.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama kita dapat mengamati hal berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam skenario pertama, persyaratan penundaan jatuh ke zona bahaya pengumpul sampah dijeda: 100 ms. </font><font style="vertical-align: inherit;">Ini dianggap sebagai hasil yang sangat baik untuk pengumpulan sampah dalam kasus-kasus yang paling sulit, dan dalam banyak situasi dapat menjadi batu sandungan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario kedua dan ketiga identik dalam persyaratan pengumpulan sampah. </font><font style="vertical-align: inherit;">Persyaratan penundaan kurang ketat, tetapi beban besar pada generasi bertenor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario kedua lebih sulit karena persyaratan penundaan, bahkan jika tidak seketat pada skenario pertama.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mencoba kombinasi berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 8 dengan assembler Paralel default dan ConcurrentMarkSweep dan G1 opsional.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 11 dengan kolektor default G1 dan Paralel opsional.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 14 dengan kolektor default G1 dan eksperimental ZGC dan Shenandoah.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sampai pada kesimpulan berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan versi modern JDK, pembangun G1 bekerja dengan sangat baik. </font><font style="vertical-align: inherit;">Dengan mudah menangani puluhan tumpukan gigabytes (kami mencoba 60 GB), dengan jeda maksimum 200 ms. </font><font style="vertical-align: inherit;">Di bawah beban ekstrim G1 tidak masuk ke mode kritis mimpi buruk. </font><font style="vertical-align: inherit;">Sebaliknya, durasi jeda untuk pengumpulan sampah lengkap meningkat menjadi detik. </font><font style="vertical-align: inherit;">Titik lemah kolektor adalah batas atas jeda dalam kondisi yang menguntungkan dari beban rendah. </font><font style="vertical-align: inherit;">Kami berhasil menurunkannya menjadi 20-25 ms.</font></font></li>
<li>JDK 8 —   .    Parallel       .  G1    ,    ,       ,     .       12    20   Parallel     G1. ConcurrentMarkSweep       G1,           .</li>
<li>  ZGC    ,   G1,        ,  G1       10 . </li>
<li>Shenandoah        220    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baik ZGC maupun Shenandoah tidak bertingkah laku kritis seperti G1. </font><font style="vertical-align: inherit;">Pekerjaan mereka tidak dapat diandalkan, dalam mode latensi rendah, jeda yang sangat lama tiba-tiba terjadi, dan bahkan OOME.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini menjelaskan hasil pengujian kami dalam dua skenario pemrosesan streaming. </font><font style="vertical-align: inherit;">Pada bagian kedua kita akan berbicara tentang hasil pemrosesan batch.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark Pemrosesan Streaming</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk tolok ukur streaming, kami mengambil </font><font style="vertical-align: inherit;">kode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengubahnya sedikit di antara pengujian. </font><font style="vertical-align: inherit;">Inilah bagian utamanya, pipa Jet:</font></font><br>
<br>
<pre><code class="java hljs">StreamStage&lt;Long&gt; source = p.readFrom(longSource(ITEMS_PER_SECOND))<font></font>
                            .withNativeTimestamps(<span class="hljs-number">0</span>)<font></font>
                            .rebalance(); <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
source.groupingKey(n -&gt; n % NUM_KEYS)<font></font>
      .window(sliding(SECONDS.toMillis(WIN_SIZE_SECONDS), SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .filter(kwr -&gt; kwr.getKey() % DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR == <span class="hljs-number">0</span>)<font></font>
      .window(tumbling(SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .writeTo(Sinks.logger(wr -&gt; String.format(<span class="hljs-string">"time %,d: latency %,d ms, cca. %,d keys"</span>,<font></font>
              simpleTime(wr.end()),<font></font>
              NANOSECONDS.toMillis(System.nanoTime()) - wr.end(),<font></font>
              wr.result() * DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR)));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saluran pipa ini mencerminkan skenario penggunaan dengan aliran acara yang tidak terbatas. Mesin harus mengumpulkan data menggunakan metode "sliding window". Agregasi seperti itu diperlukan, misalnya, untuk memperoleh turunan waktu dari nilai yang berubah, untuk membersihkan data dari noise frekuensi tinggi (penghalusan), atau untuk mengukur frekuensi kemunculan suatu peristiwa (events per second). Mesin pertama-tama dapat membagi aliran menjadi beberapa kategori (misalnya, semua perangkat IoT atau ponsel cerdas) menjadi sub-aliran. Dan kemudian secara mandiri melacak nilai gabungan untuk setiap subflow. Di Hazelcast Jet, jendela geser bergerak dalam langkah-langkah terpisah, ukuran yang Anda tentukan. Misalnya, dengan langkah 1 detik, Anda mendapatkan serangkaian hasil lengkap setiap detik. Dan dengan langkah 1 menit, hasilnya akan mencakup semua yang terjadi di menit terakhir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa catatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini sepenuhnya mandiri. Sumber data eksternal tidak digunakan. Kami menggunakan sumber rintisan untuk meniru aliran peristiwa pada frekuensi yang tepat. Acara terjadi secara berkala. Sumber tidak menghasilkan acara yang stempel waktunya terkait dengan masa depan, tetapi menghasilkannya secepat mungkin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika pipa tertunda, maka acara "buffered" tanpa menyimpan. Dalam hal ini, pipa harus mengejar, sesegera mungkin menerima data. Karena sumber kami tidak diparalelkan, batas bandwidthnya mencapai sekitar 2,2 juta peristiwa per detik. Kami meniru 1 juta peristiwa / s, meninggalkan margin untuk menangkap hingga 1,2 juta peristiwa / s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konveyor mengukur keterlambatannya dengan membandingkan cap waktu hasil jendela geser dengan waktu saat ini. Dua tahap agregasi dengan filtrasi menengah digunakan. Hasil dari satu jendela geser berisi banyak elemen, satu untuk setiap subtream, dan kami tertarik pada penundaan untuk elemen yang terakhir. Karena itu, pertama-tama kita memfilter sebagian besar hasilnya, menyisakan setiap elemen kesepuluh ribu. Dan kemudian kita mengarahkan aliran tereduksi ke tahap kedua, dengan jendela "membalik" tanpa kunci. Pada tahap ini, kami mencatat ukuran hasil dan mengukur penundaan. Agregasi tanpa menggunakan kunci tidak diparalelkan, jadi kami memiliki satu titik pengukuran. Tahap filtrasi diparalelkan dan bersifat data-lokal, sehingga pengaruh tahap agregasi tambahan sangat kecil (jauh lebih rendah dari 1 ms).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menggunakan fungsi agregat sederhana: menghitung. Bahkan, metrik frekuensi kejadian di aliran diperoleh. Ini memiliki struktur minimal (satu nomor jenis </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), sampah tidak dihasilkan. Untuk jumlah berapa pun penggunaan tumpukan (dalam gigabytes), struktur kunci kecil seperti itu menyiratkan skenario terburuk untuk pengumpul sampah: sejumlah besar objek. Beban pada kolektor tidak tumbuh dengan ukuran tumpukan, tetapi dengan jumlah benda. Kami juga menguji opsi untuk menghitung fungsi agregat yang sama, tetapi dengan implementasi berbeda yang menghasilkan sampah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mendorong sebagian besar tolok ukur aliran pada satu node, karena kami tertarik pada dampak manajemen memori pada kinerja pipa. </font><font style="vertical-align: inherit;">Dan latensi jaringan hanya menambah noise pada data. </font><font style="vertical-align: inherit;">Untuk menguji hipotesis bahwa kinerja klaster tidak akan memengaruhi temuan kami, kami mengulangi beberapa tes utama pada kluster Amazon EC2 tiga simpul. </font><font style="vertical-align: inherit;">Lebih lanjut tentang ini akan dijelaskan pada akhir artikel kedua. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menghapus kolektor Paralel dari hasil beban streaming karena puncak penundaan yang dibuatnya tidak dapat diterima di sebagian besar skenario dunia nyata.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario 1: latensi rendah, struktur sedang</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter Skrip:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenJDK 14</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran tumpukan JVM adalah 4 GB.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk G1, diberikan </font></font><code>-XX:MaxGCPauseMillis=5</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 juta acara.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50.000 kunci individual.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela geser 30 detik setelah 0,1 detik.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skenario ini, kurang dari 1 GB tumpukan digunakan. </font><font style="vertical-align: inherit;">Beban pada pengumpul kecil, ia memiliki cukup waktu untuk pengumpulan sampah latar belakang yang kompetitif. </font><font style="vertical-align: inherit;">Berikut adalah keterlambatan maksimum dalam pengoperasian pipa dengan tiga perakit diuji:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/053/d40/26c/053d4026c6d3eb747e3e78bbdcd46ecd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai-nilai ini termasuk interval tetap sekitar 3 ms untuk transmisi hasil jendela. </font><font style="vertical-align: inherit;">Grafik berbicara sendiri: kolektor default G1 melakukan pekerjaan yang sangat baik, tetapi jika Anda membutuhkan penundaan lebih rendah, Anda dapat menggunakan ZGC eksperimental. </font><font style="vertical-align: inherit;">Kami tidak dapat menurunkan puncak penundaan di bawah 10 ms. </font><font style="vertical-align: inherit;">Tetapi dalam kasus ZGC dan Shenandoah, mereka tidak muncul karena jeda dalam pengumpulan sampah, tetapi karena periode singkat peningkatan volume pekerjaan latar belakang para kolektor. </font><font style="vertical-align: inherit;">Kadang-kadang, proses layanan Shenandoah mengangkat penundaan di atas 200 ms.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario dua: struktur yang lebih besar, persyaratan latensi yang kurang ketat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengasumsikan bahwa karena alasan di luar kendali kami (misalnya, karena jaringan seluler), penundaan dapat meningkat menjadi detik. </font><font style="vertical-align: inherit;">Ini mengurangi persyaratan untuk pipa pemrosesan aliran. </font><font style="vertical-align: inherit;">Di sisi lain, kita mungkin menemukan data yang jauh lebih besar, ukuran jutaan atau puluhan juta kunci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skenario ini, kita dapat menyiapkan peralatan untuk penggunaan berat, dengan mempertimbangkan fakta bahwa pengumpul sampah akan beroperasi di tumpukan besar, daripada mendistribusikan data di beberapa node cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menjalankan banyak tes dalam kombinasi berbeda untuk mengetahui bagaimana kombinasi faktor mempengaruhi kinerja runtime. </font><font style="vertical-align: inherit;">Ternyata ini tergantung pada dua parameter:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah catatan yang disimpan dalam agregat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persyaratan bandwidth untuk make-up.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter pertama menjelaskan jumlah objek dalam generasi bertenor. Ketika menggabungkan menggunakan metode jendela geser, kami menahan objek untuk waktu yang lama (sepanjang jendela) dan kemudian melepaskannya. Ini secara langsung bertentangan dengan hipotesis sampah generasi (Hipotesis Sampah Generasional), yang mengklaim bahwa benda mati muda atau hidup selamanya. Dalam mode ini, beban maksimum pada pengumpul sampah dibuat. Dan karena intensitas pekerjaannya bertambah dengan jumlah benda hidup, produktivitas sangat tergantung pada parameter ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter kedua berkaitan dengan berapa banyak sumber daya aplikasi dapat mengalokasikan ke pengumpul sampah. Untuk membuatnya lebih jelas, mari kita buat beberapa diagram. Saat menjumlahkan menggunakan metode jendela geser, konveyor melewati tiga tahap:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan peristiwa waktu nyata saat terjadi.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melewati hasil jendela geser.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengejar peristiwa yang diterima selama tahap kedua.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketiga tahap dapat divisualisasikan sebagai berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99c/d77/894/99cd778940f1596c2dd5e1dbf0933fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika transfer hasil jendela lebih lama, kami berada dalam situasi ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/694/760/b226947608cfb3373742d02e6dc7774f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang konveyor hampir tidak punya waktu, dan semua waktu tunda seperti jeda untuk pengumpulan sampah akan meningkatkan penundaan, dan itu akan pulih sangat lambat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ubah grafik dan hanya menampilkan rata-rata tingkat penyerapan peristiwa setelah melewati hasil jendela:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/cd9/ccb/d78cd9ccbf09b96c23705ae8bb0d6e38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita sebut tinggi persegi panjang kuning "persyaratan pengenaan": ini adalah persyaratan untuk kapasitas sumber. Jika melebihi throughput aktual dari conveyor, maka itu tidak dapat mengatasi beban. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini akan terlihat seperti jika mentransfer hasil jendela terlalu banyak waktu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/0ea/594/5b90ea59490f05c628401475c9849e21.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Area persegi panjang merah dan kuning adalah tetap dan sesuai dengan jumlah data yang harus melewati pipa. Bahkan, merah "meremas" kuning. Tetapi ketinggian persegi panjang kuning terbatas, dalam kasus kami plafon adalah 2,2 juta peristiwa / detik. Dan ketika ketinggian melebihi batas, kami mendapatkan konveyor yang tidak dapat mengatasi beban dan penundaan yang tak terbatas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membuat rumus untuk memprediksi ukuran persegi panjang untuk kombinasi frekuensi acara, ukuran jendela, langkah slip, dan ukuran set kunci. Jadi kita dapat untuk setiap kasus menentukan persyaratan untuk pengenaan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami memiliki dua atau lebih parameter independen yang diturunkan dari banyak parameter lain yang menggambarkan setiap kombinasi individu. </font><font style="vertical-align: inherit;">Anda dapat membuat grafik dua dimensi, lingkaran di mana menunjukkan tolok ukur yang dibuang. </font><font style="vertical-align: inherit;">Warnai lingkaran sesuai dengan keberhasilan atau kegagalan kombinasi. </font><font style="vertical-align: inherit;">Misalnya, untuk sekelompok JDK 14 dengan G1 yang berjalan di laptop, kita mendapatkan grafik berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab2/9e6/416/ab29e641669a2666c59d506e59fce458.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami telah mengidentifikasi tiga kategori:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ya" - konveyor sedang mengatasi,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Tidak" - pipa tidak dapat mengatasi karena kurangnya bandwidth,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Pengumpul sampah" - konveyor tidak mengatasinya karena sering jeda yang lama dalam perakitan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap perhatikan bahwa kekurangan bandwidth juga dapat terjadi karena pengumpulan sampah yang kompetitif dan sering terjadi jeda singkat. Secara umum, perbedaan antara dua kategori terakhir kecil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat batas yang memisahkan bagian kiri bawah grafik. Ini berisi poin tolok ukur yang berhasil dilewati. Kami merencanakan grafik yang sama untuk kombinasi lain dari JDK dan pemulung, mengidentifikasi batas-batas zona dan mendapatkan hasil berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/d12/394/251d123945208cbed4806928946c4241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki MacBook Pro 2018 dengan 6-core Intel Core i7 dan 16GB DDR4 RAM. Untuk JVM telah dikonfigurasi </font></font><code>-Xmx10g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun, kami percaya bahwa gambar yang serupa akan diamati pada banyak konfigurasi lainnya. Grafik menunjukkan keunggulan G1 dibandingkan kolektor lain, kelemahan G1 saat digunakan dengan JDK 8, dan kelemahan kolektor eksperimental dengan latensi rendah di bawah jenis beban ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penundaan dasar - durasi pengiriman hasil jendela - berfluktuasi sekitar 500 ms. </font><font style="vertical-align: inherit;">Namun, semburan sering terjadi karena jeda utama untuk pengumpulan sampah (yang dalam kasus G1 terlalu panjang), hingga 10 detik dalam situasi batas (ketika konveyor hampir tidak berhasil bekerja) dan berkurang menjadi 1-2 detik. </font><font style="vertical-align: inherit;">Kami juga memperhatikan efek kompilasi JIT dalam situasi batas: pipa mulai bekerja dengan penundaan yang terus meningkat, dan setelah sekitar dua menit, kinerja meningkat dan penundaan kembali ke nilai normal.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id506696/index.html">Mengelola PostgreSQL di Gitlab.com. Jose Cores Finotto</a></li>
<li><a href="../id506698/index.html">Requiem untuk "Sea Launch"</a></li>
<li><a href="../id506700/index.html">Kami mengonfigurasi Tindakan GitHub untuk Android dengan penerapan berikutnya di PlayMarket</a></li>
<li><a href="../id506702/index.html">HDD yang paling andal menurut Backblaze Q1 2020</a></li>
<li><a href="../id506704/index.html">Mengapa menulis dalam PHP pada tahun 2020? Holivarim adalah podcast interaktif di Youtube Kamis ini</a></li>
<li><a href="../id506708/index.html">Otentikasi dua faktor VPN / Mikrotik - sederhana dan dapat diskalakan</a></li>
<li><a href="../id506710/index.html">Kelola beberapa buku alamat di Edisi Terbuka Sumber-Sumber Zimbra Collaboration</a></li>
<li><a href="../id506716/index.html">Daftar Lini Multithreaded: Masalah Keberadaan Elemen, Peningkatan Kinerja, dan Hubungan STL</a></li>
<li><a href="../id506726/index.html">Pengalaman dalam menggunakan teknologi Rutoken untuk registrasi dan otorisasi pengguna dalam sistem (bagian 2)</a></li>
<li><a href="../id506730/index.html">Mendengus atau Suricata. Bagian 1: pilih IDS / IPS gratis untuk melindungi jaringan perusahaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>