<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍧 🤷🏿 👶🏼 HighLoad ++, Mikhail Tyulenev (MongoDB): Consistência causal: da teoria à prática 🤽🏼 🐙 ⚾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A próxima conferência HighLoad ++ será realizada nos dias 6 e 7 de abril de 2020 em São Petersburgo. 
 Detalhes e ingressos aqui . HighLoad ++ Sibéria...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++, Mikhail Tyulenev (MongoDB): Consistência causal: da teoria à prática</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/487638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A próxima conferência HighLoad ++ será realizada nos dias 6 e 7 de abril de 2020 em São Petersburgo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Detalhes e ingressos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . HighLoad ++ Sibéria 2019. Salão "Krasnoyarsk". 25 de junho, 12:00. Resumos e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/iw/mz/okiwmzx4qkp6dxvjvqjxvfzqtnk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ocorre que os requisitos práticos entram em conflito com uma teoria em que aspectos importantes para um produto comercial não são levados em consideração. Este relatório apresenta o processo de seleção e combinação de várias abordagens para criar componentes de consistência causal com base em pesquisa acadêmica com base nos requisitos de um produto comercial. Os alunos aprenderão sobre as abordagens teóricas existentes para relógios lógicos, rastreamento de dependências, segurança do sistema, sincronização de clock e por que o MongoDB parou nessas ou nessas soluções.</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Tyulenev (doravante - MT):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Vou falar sobre consistência causal - esse é um recurso que trabalhamos no MongoDB. </font><font style="vertical-align: inherit;">Eu trabalho em um grupo de sistemas distribuídos, fizemos isso cerca de dois anos atrás. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/xx/xg/ihxxxghkrknnqdxg7tb4w97izi0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No processo, tive que me familiarizar com muita pesquisa acadêmica, porque esse recurso é bem estudado. </font><font style="vertical-align: inherit;">Verificou-se que nem um único artigo se encaixa no que é necessário na produção, o banco de dados em vista dos requisitos muito específicos que são, provavelmente, em qualquer aplicativo de produção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vou falar sobre como nós, como consumidores de Pesquisa acadêmica, preparamos algo que podemos apresentar aos nossos usuários como um prato pronto que é conveniente e seguro de usar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistência causal. </font><font style="vertical-align: inherit;">Vamos definir conceitos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para começar, quero descrever em termos gerais o que é consistência causal. Existem dois personagens - Leonard e Penny (a série "The Big Bang Theory"): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7q/nw/lr/7qnwlrmqtidow8cl_jrdakec3d0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que Penny esteja na Europa e Leonard queira fazer algum tipo de surpresa para ela, uma festa. E ele não tem nada melhor do que jogá-la para fora da lista de amigos, enviando atualizações para alimentar todos os amigos: "Vamos fazer Penny feliz!" (ela na Europa, enquanto dorme, não vê tudo isso e não pode ver, porque ela não está lá). No final, ele exclui este post, apaga-o do "Feed" e restaura o acesso para que ele não perceba nada e não haja escândalo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo bem, mas vamos supor que o sistema esteja distribuído e que os eventos deram um certo erro. </font><font style="vertical-align: inherit;">Talvez, por exemplo, aconteça que a restrição de acesso a Penny ocorreu após a publicação desta postagem, se os eventos não estiverem conectados por um relacionamento causal. </font><font style="vertical-align: inherit;">Na verdade, este é um exemplo de quando a consistência causal é necessária para cumprir uma função comercial (neste caso). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, essas são propriedades não triviais do banco de dados - poucas pessoas as apóiam. </font><font style="vertical-align: inherit;">Vamos para os modelos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelos de consistência</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que é um modelo de consistência em bancos de dados em geral? </font><font style="vertical-align: inherit;">Essas são algumas das garantias que um sistema distribuído oferece em relação a quais dados e em que sequência o cliente pode receber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em princípio, todos os modelos de consistência se resumem a como o sistema é distribuído como um sistema que funciona, por exemplo, no mesmo aceno de um laptop. </font><font style="vertical-align: inherit;">E é assim que o sistema, que funciona em milhares de nós geodistribuídos, é semelhante a um laptop, no qual todas essas propriedades são executadas automaticamente em princípio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, os modelos de consistência se aplicam apenas a sistemas distribuídos. </font><font style="vertical-align: inherit;">Todos os sistemas que existiam anteriormente e trabalhavam na mesma escala vertical não tiveram esses problemas. </font><font style="vertical-align: inherit;">Havia um cache de buffer, e tudo era sempre lido nele.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo forte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, o primeiro modelo é Forte (ou a capacidade de aumentar a linha, como costuma ser chamada). </font><font style="vertical-align: inherit;">Este é um modelo de consistência que garante que todas as alterações, assim que a confirmação de que ocorreu, sejam visíveis a todos os usuários do sistema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso cria uma ordem global de todos os eventos no banco de dados. </font><font style="vertical-align: inherit;">Esta é uma propriedade de consistência muito forte e geralmente é muito cara. </font><font style="vertical-align: inherit;">No entanto, é muito bem conservado. </font><font style="vertical-align: inherit;">É simplesmente muito caro e lento - eles são raramente usados. </font><font style="vertical-align: inherit;">Isso é chamado de capacidade de aumento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há outra propriedade mais poderosa suportada na "Chave inglesa" - chamada Consistência externa. </font><font style="vertical-align: inherit;">Falaremos sobre ele um pouco mais tarde.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O seguinte é causal, exatamente do que eu estava falando. Existem vários subníveis entre Strong e Causal dos quais não falarei, mas todos eles se resumem a Causal. Este é um modelo importante porque é o mais forte de todos os modelos, a consistência mais forte na presença de uma rede ou partições. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Causais é realmente uma situação na qual os eventos são conectados por um relacionamento causal. Muitas vezes, eles são percebidos como direitos de leitura, do ponto de vista do cliente. Se o cliente observou alguns valores, ele não pode ver os valores que estavam no passado. Ele já está começando a ver leituras de prefixo. Tudo se resume à mesma coisa.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Causais como modelo de consistência é uma ordem parcial de eventos no servidor, na qual os eventos de todos os clientes são observados na mesma sequência. </font><font style="vertical-align: inherit;">Nesse caso, Leonard e Penny.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventual</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O terceiro modelo é a consistência eventual. É isso que suporta absolutamente todos os sistemas distribuídos, um modelo mínimo que geralmente faz sentido. Significa o seguinte: quando temos algumas alterações nos dados, elas se tornam consistentes em algum momento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse momento, ela não diz nada, caso contrário ela se tornaria Consistência Externa - haveria uma história completamente diferente. No entanto, este é um modelo muito popular, o mais comum. Por padrão, todos os usuários de sistemas distribuídos usam Consistência Eventual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero dar alguns exemplos comparativos: o </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/5s/p9/yn5sp9tyjn4dh4q3vonroirvxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que essas setas significam?</font></font><br>
<br>
<ul>
<li><b>Latency.</b>          :    ,       ,    ,     .   Eventual Consistency   ,   ,  ,    memory       .</li>
<li><b>Availability.</b>           , partitions,  -  –      ,    ,         - . Eventual Consistency        –    ,  .</li>
<li><b>Anomalies.</b>  , ,   .  Strong Consistency       ,  Eventual Consistency     .  :     Eventual Consistency,    ?    ,  Eventual Consistency- ,   , ,    ;        -   ;       .   ,       .</li>
</ul><br>
<h3> CAP</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você vê as palavras consistência, disponibilidade - o que vem à sua mente? Direito - teorema da CAP! Agora quero dissipar o mito ... Não sou eu - há Martin Kleppman, que escreveu um artigo maravilhoso, um livro maravilhoso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/rc/v1/-krcv1vofhv9ofnwbty6ql6hvhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O teorema da PAC é um princípio formulado nos anos 2000 que Consistência, Disponibilidade, Partições: pegue dois, e você não pode escolher três. Era um certo princípio. Foi provado como um teorema alguns anos depois, por Gilbert e Lynch. Em seguida, tornou-se usado como um mantra - os sistemas começaram a ser divididos em CA, CP, AP e assim por diante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse teorema foi realmente provado pelos seguintes motivos ... Primeiro, a disponibilidade não foi considerada como um valor contínuo de zero a centenas (0 - o sistema está "morto", 100 - responde rapidamente; estamos acostumados a considerá-lo), mas como uma propriedade do algoritmo , que garante que, com todas as suas execuções, retorne dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não há uma palavra sobre o tempo de resposta! Existe um algoritmo que retorna dados após 100 anos - um algoritmo perfeitamente disponível, que faz parte do teorema da CAP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segundo: foi provado um teorema para mudanças nos valores da mesma chave, apesar de essas mudanças serem uma linha redimensionável. Isso significa que, na verdade, eles praticamente não são usados, porque os modelos são diferentes de Consistência Eventual, Consistência Forte (talvez).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que isso é tudo? </font><font style="vertical-align: inherit;">Além disso, o teorema da PAC, na forma em que é provado, praticamente não é aplicável, é raramente usado. </font><font style="vertical-align: inherit;">Em uma forma teórica, de alguma forma limita tudo. </font><font style="vertical-align: inherit;">Acontece que um certo princípio é intuitivamente verdadeiro, mas de modo algum é provado em geral.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistência causal - o modelo mais forte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que está acontecendo agora - você pode obter todas as três coisas: Consistência e disponibilidade podem ser obtidas usando Partições. </font><font style="vertical-align: inherit;">Em particular, a consistência causal é o modelo de consistência mais forte que, na presença de Partições (quebras de rede), ainda funciona. </font><font style="vertical-align: inherit;">Portanto, é de tão grande interesse e, portanto, estamos envolvidos nela. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/4s/k8/ty4sk8sx4n73xnsxlkw2wtb1ity.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, simplifica o trabalho dos desenvolvedores de aplicativos. </font><font style="vertical-align: inherit;">Em particular, há muito suporte do servidor: quando todos os registros que ocorrem dentro de um cliente são garantidos para chegar nessa ordem no outro cliente. </font><font style="vertical-align: inherit;">Em segundo lugar, suporta partições.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cozinha interior MongoDB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembrando do almoço, vamos para a cozinha. Vou falar sobre o modelo do sistema, ou seja, o que é o MongoDB para quem primeiro ouviu sobre esse banco de dados. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/-b/kj/fn-bkjwvkdxcokzum9xwwkshcu8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/2u/qz/3g/2uqz3gts5ipfvvojtpo2epigtf4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O MongoDB (doravante denominado "MongoBD") é um sistema distribuído que suporta escala horizontal, ou seja, sharding; e dentro de cada fragmento, ele também suporta redundância de dados, ou seja, replicação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sharding no “MongoBD” (banco de dados não relacional) executa o balanceamento automático, ou seja, cada coleção de documentos (ou “tabela” em termos de dados relacionais) em pedaços, e o servidor já os move automaticamente entre os shards. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Query Router que distribui consultas para o cliente é um cliente através do qual ele trabalha. Ele já sabe onde e quais dados estão localizados, envia todas as solicitações para o shard correto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro ponto importante: o MongoDB é um único mestre. </font><font style="vertical-align: inherit;">Há uma Primária - ela pode receber registros que suportam as chaves que ela contém. </font><font style="vertical-align: inherit;">Você não pode fazer gravação multimestre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fizemos o lançamento 4.2 - novas coisas interessantes apareceram lá. </font><font style="vertical-align: inherit;">Em particular, eles inseriram o Lucene - a pesquisa - era executável java diretamente no "Mongo", e foi possível pesquisar no Lucene, o mesmo que no "Elastic". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E eles criaram um novo produto - Gráficos, também está disponível no Atlas (a própria nuvem do Mongo). </font><font style="vertical-align: inherit;">Eles têm nível gratuito - você pode brincar com isso. </font><font style="vertical-align: inherit;">Gostei muito dos gráficos - a visualização de dados é muito intuitiva.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingredientes causais de consistência</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contei cerca de 230 artigos que foram publicados sobre esse assunto - de Leslie Lampert. </font><font style="vertical-align: inherit;">Agora, da minha memória, trarei para você algumas partes desses materiais. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2_/dt/2n/2_dt2nhood8jlup51kyeddsy7w8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo começou com um artigo de Leslie Lampert, que foi escrito na década de 1970. </font><font style="vertical-align: inherit;">Como você pode ver, algumas pesquisas sobre esse tópico ainda estão em andamento. </font><font style="vertical-align: inherit;">Agora, a consistência causal está experimentando interesse em conexão com o desenvolvimento de sistemas distribuídos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitações</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quais são as limitações? </font><font style="vertical-align: inherit;">Este é realmente um dos pontos principais, porque as restrições impostas pelos sistemas de produção são muito diferentes das restrições existentes nos artigos acadêmicos. </font><font style="vertical-align: inherit;">Muitas vezes, são bastante artificiais.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nh/ql/qdnhql6zcor1hzt53ur72spzqzy.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em primeiro lugar, o "MongoDB" é um único mestre, como eu já disse (isso simplifica bastante).</font></font></li>
<li> ,   10     .     -  ,      .</li>
<li>   ,   ,      ,    binary,     ,    .</li>
<li>  ,   Research  :      . «» –  . ,     ,  –    .  ,     .</li>
<li>  ,     –  :    ,   performance degradation   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro ponto é geralmente anti-acadêmico: compatibilidade de versões anteriores e futuras. </font><font style="vertical-align: inherit;">Drivers antigos devem suportar novas atualizações e o banco de dados deve suportar drivers antigos.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, tudo isso impõe limitações.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componentes de consistência causal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vou falar sobre alguns dos componentes. </font><font style="vertical-align: inherit;">Se considerarmos a consistência Causal geral, podemos distinguir blocos. </font><font style="vertical-align: inherit;">Optamos pelas obras que pertencem a um determinado bloco: Rastreamento de Dependências, escolha de horas, como esses relógios podem ser sincronizados entre si e como garantimos a segurança - este é um plano aproximado do que falarei:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rb/rq/zvrbrqunyfdrj1pmbrjncugqed4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rastreamento de Dependência Total</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que é necessário? Para que, quando os dados forem replicados - cada registro, cada alteração de dados contenha informações sobre quais alterações elas dependem. A primeira e ingênua alteração ocorre quando cada mensagem que contém um registro contém informações sobre mensagens anteriores: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/ue/jh/gkuejhztxm81mfji3fazhsmbmbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, o número entre chaves é o número de registros. Às vezes, esses registros com valores são transferidos na íntegra, às vezes, algumas versões são transferidas. A conclusão é que cada mudança contém informações sobre a anterior (obviamente, ela carrega tudo por si mesma).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que decidimos não usar essa abordagem (rastreamento completo)? </font><font style="vertical-align: inherit;">Obviamente, porque essa abordagem é impraticável: qualquer alteração na rede social depende de todas as alterações anteriores nessa rede social, transmitindo, digamos, o Facebook ou o Vkontakte em cada atualização. </font><font style="vertical-align: inherit;">No entanto, existem muitas pesquisas, a saber, o Full Dependency Tracking - essas são redes sociais, para algumas situações realmente funcionam.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rastreamento de dependência explícito</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O próximo é mais limitado. </font><font style="vertical-align: inherit;">Também aqui é considerada a transmissão de informações, mas apenas as que claramente dependem. </font><font style="vertical-align: inherit;">O que depende do que, como regra, já é determinado pelo Aplicativo. </font><font style="vertical-align: inherit;">Quando os dados são replicados, apenas as respostas são retornadas quando uma solicitação é feita, quando as dependências anteriores foram atendidas, ou seja, mostradas. </font><font style="vertical-align: inherit;">Essa é a essência de como a consistência causal funciona. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y_/jc/mw/y_jcmwt2w-vqj9guslui0wl8vgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ela vê que o registro 5 depende dos registros 1, 2, 3, 4 - respectivamente, espera antes que o cliente obtenha acesso às alterações feitas pelo decreto de acesso de Penny quando todas as alterações anteriores já tiverem passado para o banco de dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso também não nos convém, porque de qualquer maneira há muita informação, e isso desacelerará. </font><font style="vertical-align: inherit;">Existe uma abordagem diferente ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamport Clock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles são muito antigos. O Lamport Clock implica que essas dependências sejam recolhidas em uma função escalar chamada Lamport Clock. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma função escalar é algum número abstrato. Muitas vezes chamado de tempo lógico. Em cada evento, esse contador aumenta. O contador, atualmente conhecido pelo processo, envia cada mensagem. É claro que os processos podem estar fora de sincronia, eles podem ter tempos completamente diferentes. No entanto, o sistema de alguma forma equilibra o relógio com essas mensagens. O que acontece nesse caso?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividi esse grande fragmento em dois para que fique claro: os amigos podem viver em um nó que contém uma parte da coleção e o Feed pode viver em outro nó que contém uma parte dessa coleção. Está claro como eles podem sair da curva? Primeiro, o Feed diz "Replicado" e depois Amigos. Se o sistema não fornecer garantias de que o Feed não será mostrado até que as dependências de Friends na coleção Friends também sejam entregues, teremos apenas uma situação que mencionei. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você vê como o tempo do contador logicamente aumenta no Feed:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/pz/vw/gvpzvwwxqonuthkwv6j2ez0fruc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, a propriedade principal dessa consistência causal e de relógio de Lamport (explicada através do relógio de Lamport) é a seguinte: se tivermos os eventos A e B e o evento B depender do evento A *, então o LogicalTime do evento A será menor do que o LogicalTime do Evento B. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Às vezes eles até dizem que A aconteceu antes de B, ou seja, A aconteceu antes de B - esse é um tipo de relacionamento que ordena parcialmente todo o conjunto de eventos que geralmente acontecem.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O contrário está errado. Esta é realmente uma das principais desvantagens do Lamport Clock - pedido parcial. Existe um conceito de eventos simultâneos, ou seja, eventos nos quais nem (A aconteceu antes de B) nem (A aconteceu antes de B). Um exemplo é a adição paralela de Leonard a amigos de outra pessoa (nem mesmo Leonard, mas Sheldon, por exemplo).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é a propriedade frequentemente usada ao trabalhar com relógios Lamport: eles examinam a função exatamente e tiram uma conclusão disso - talvez esses eventos sejam dependentes. </font><font style="vertical-align: inherit;">Porque em uma direção isso é verdade: se LogicalTime A for menor que LogicalTime B, B não poderá ocorrer antes de A; </font><font style="vertical-align: inherit;">e se mais, então talvez.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relógio de vetor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O desenvolvimento lógico dos relógios Lamport é o Vector Clock. Eles diferem em que cada nó aqui contém seu próprio relógio separado e são transmitidos como um vetor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, você vê que o índice zero do vetor é responsável pelo Feed e o primeiro índice do vetor é para Friends (cada um desses nós). E agora eles aumentarão: o índice zero do "Feed" aumenta ao gravar - 1, 2, 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/xm/cd/cvxmcdiz_dgbjsu7elnj3xt2hcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como é o relógio vetorial melhor? O fato de que eles podem descobrir quais eventos são simultâneos e quando ocorrem em diferentes nós. Isso é muito importante para um sistema de sharding como o MongoBD. No entanto, não escolhemos isso, embora seja uma coisa maravilhosa, e funcione muito bem, e provavelmente nos sirva ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se temos 10 mil fragmentos, não podemos transferir 10 mil componentes, mesmo se compactar, pensamos em outra coisa - mesmo assim, a carga útil será várias vezes menor que o volume de todo esse vetor. </font><font style="vertical-align: inherit;">Portanto, moendo nossos corações e dentes, abandonamos essa abordagem e passamos para outra.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chave inglesa TrueTime. </font><font style="vertical-align: inherit;">Relógio atômico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu disse que haverá uma história sobre a Spanner. Isso é legal, no século XXI: relógios atômicos, sincronização GPS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que ideia? O Spanner é um sistema do Google que recentemente se tornou disponível para as pessoas (elas anexaram o SQL a ele). Cada transação tem um carimbo de data / hora. Como a hora é sincronizada *, cada evento pode ser atribuído a uma hora específica - o relógio atômico possui um tempo de espera, após o qual é garantido que outra hora ocorrerá. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/vw/e3/znvwe3zwpqvjhsx-qglxpbqen9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, apenas gravando no banco de dados e aguardando um certo período de tempo, a serialização do evento é garantida automaticamente. Eles têm o modelo de consistência mais forte, que em princípio pode ser imaginado - é Consistência Externa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Esse é o principal problema dos relógios Lampart - eles nunca são síncronos em sistemas distribuídos. </font><font style="vertical-align: inherit;">Eles podem divergir, mesmo com o NTP, eles ainda não funcionam muito bem. </font><font style="vertical-align: inherit;">"Spanner" possui um relógio atômico e a sincronização parece ser microssegundos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que não escolhemos? </font><font style="vertical-align: inherit;">Não assumimos que nossos usuários tenham um relógio atômico embutido. </font><font style="vertical-align: inherit;">Quando eles aparecerem, sendo incorporados a todos os laptops, haverá algum tipo de sincronização GPS super bacana - então sim ... Enquanto isso, o melhor possível é a Amazon, estações base para fanáticos ... Portanto, usamos outros relógios.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relógio híbrido</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É isso que realmente marca o “MongoBD”, garantindo a consistência causal. </font><font style="vertical-align: inherit;">O que eles são híbridos? </font><font style="vertical-align: inherit;">Um híbrido é um valor escalar, mas consiste em dois componentes:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/wz/uv/hiwzuvz-czbmb52b9iypojrr0_u.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira é a era unix (quantos segundos se passaram desde o "começo do mundo dos computadores").</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo é um incremento, também um int não assinado de 32 bits.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo, na verdade. </font><font style="vertical-align: inherit;">Existe uma abordagem desse tipo: a parte responsável pela hora é sincronizada com o relógio o tempo todo; </font><font style="vertical-align: inherit;">toda vez que ocorre uma atualização, essa parte é sincronizada com o relógio e a hora é sempre mais ou menos correta, e o incremento permite distinguir entre os eventos que ocorreram ao mesmo tempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que isso é importante para o MongoBD? </font><font style="vertical-align: inherit;">Como ele permite que você faça algum tipo de restauração de backup em um determinado momento, ou seja, o evento é indexado por tempo. </font><font style="vertical-align: inherit;">Isso é importante quando alguns eventos são necessários; </font><font style="vertical-align: inherit;">para um banco de dados, eventos são alterações no banco de dados que ocorrem em determinados momentos no tempo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vou apenas dizer o motivo mais importante (por favor, não conte a ninguém)! </font><font style="vertical-align: inherit;">Fizemos isso porque os dados ordenados e indexados no MongoDB OpLog são assim. </font><font style="vertical-align: inherit;">O OpLog é uma estrutura de dados que contém absolutamente todas as alterações no banco de dados: elas primeiro acessam o OpLog e depois são aplicadas ao próprio armazenamento, no caso de uma data ou fragmento replicado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa foi a principal razão. </font><font style="vertical-align: inherit;">Ainda, existem também requisitos práticos para o desenvolvimento do banco de dados, o que significa que ele deve ser simples - há pouco código, o mínimo possível de coisas quebradas que precisam ser reescritas e testadas. </font><font style="vertical-align: inherit;">O fato de nossos oplogs terem sido indexados por um relógio híbrido ajudou muito e nos permitiu fazer a escolha certa. </font><font style="vertical-align: inherit;">Realmente valeu a pena e de alguma forma funcionou magicamente, no primeiro protótipo. </font><font style="vertical-align: inherit;">Foi muito legal!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincronização do relógio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem vários métodos de sincronização descritos na literatura científica. </font><font style="vertical-align: inherit;">Estou falando de sincronização quando temos dois shards diferentes. </font><font style="vertical-align: inherit;">Se houver um conjunto de réplicas, não há necessidade de sincronização: é um "mestre único"; </font><font style="vertical-align: inherit;">temos um OpLog no qual todas as alterações entram - nesse caso, tudo já está ordenado sequencialmente no próprio "Oplog". </font><font style="vertical-align: inherit;">Mas se tivermos dois shards diferentes, a sincronização de tempo é importante aqui. </font><font style="vertical-align: inherit;">Aqui os relógios vetoriais ajudaram mais! </font><font style="vertical-align: inherit;">Mas nós não os temos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/kq/bk/eikqbkbbzrsdquzxjxlzayc81qq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo são os batimentos cardíacos. </font><font style="vertical-align: inherit;">Você pode trocar alguns sinais que ocorrem a cada unidade de tempo. </font><font style="vertical-align: inherit;">Mas o Hartbits é muito lento, não podemos fornecer latência para o nosso cliente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O verdadeiro tempo é, obviamente, uma coisa maravilhosa. </font><font style="vertical-align: inherit;">Mas, novamente, este é provavelmente o futuro ... Embora o Atlas já possa ser feito, já existem sincronizadores de tempo "amazônicos" rápidos. </font><font style="vertical-align: inherit;">Mas não estará disponível para todos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fofocar é quando todas as mensagens incluem tempo. </font><font style="vertical-align: inherit;">Isto é aproximadamente o que usamos. </font><font style="vertical-align: inherit;">Cada mensagem entre nós, um driver, um roteador de nós de dados, absolutamente tudo para o MongoDB são alguns elementos, componentes de banco de dados que contêm horas que fluem. </font><font style="vertical-align: inherit;">Onde quer que eles tenham o significado de tempo híbrido, ele é transmitido. </font><font style="vertical-align: inherit;">64 bits? </font><font style="vertical-align: inherit;">Permite, é possível.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como tudo isso funciona juntos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, olho para um conjunto de réplicas para torná-lo um pouco mais fácil. Existem Primário e Secundário. O secundário faz replicação e nem sempre é totalmente sincronizado com o primário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma inserção (inserção) nas "Primárias" com um determinado valor de tempo. Esta inserção aumenta o contador interno em 11, se for o máximo. Ou irá verificar os valores do relógio e sincronizar com o relógio, se o relógio for maior. Isso permite que você classifique por tempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois que ele grava, um momento importante ocorre. As horas estão em "MongoDB" e são incrementadas apenas se gravadas no "Oplog". Este é um evento que altera o estado do sistema. Absolutamente em todos os artigos clássicos, um evento é considerado uma mensagem que entra em um nó: uma mensagem chegou - isso significa que o sistema mudou de estado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso se deve ao fato de que durante o estudo não é totalmente possível entender como essa mensagem será interpretada. Temos certeza de que, se não estiver refletido no "Oplog", não será interpretado de forma alguma, e somente a entrada no "Oplog" é uma alteração no estado do sistema. Isso simplifica tudo para nós: o modelo simplifica e nos permite organizar na estrutura de um conjunto de réplicas e muitas outras coisas úteis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele retorna o valor que já foi registrado no "Oplog" - sabemos que no "Oplog" esse valor já está, e seu tempo é 12. Agora, digamos, a leitura começa em outro nó (Secundário) e já transfere o próprio afterClusterTime mensagem. Ele diz: “Preciso de tudo o que aconteceu depois de pelo menos 12 ou durante doze” (veja a figura acima).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é chamado de causal consistente (CAT). Existe tal conceito na teoria que é uma fatia de tempo consistente em si mesma. Nesse caso, podemos dizer que esse é o estado do sistema que foi observado no tempo 12. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora não há nada aqui, porque parece imitar a situação em que o Secundário precisa replicar dados do Primário. Ele está esperando ... E agora os dados chegaram - retornam esses valores. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/q7/3q/a1q73qclyk9sn567b2x8szr_ejm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É assim que tudo funciona. Quase.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que significa "quase"? Vamos supor que haja alguém que tenha lido e entendido como tudo isso funciona. Percebi que toda vez que o ClusterTime ocorre, ele atualiza o relógio lógico interno e, em seguida, o próximo registro aumenta em um. Esta função ocupa 20 linhas. Suponha que essa pessoa transmita o maior número possível de 64 bits, menos um. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que menos um? Como o relógio interno é substituído por esse valor (obviamente, esse é o maior possível e mais que o horário atual), haverá uma entrada no "Olog" e o relógio aumentará em mais um - e já haverá um valor máximo (simplesmente existem todas as unidades, não há para onde ir , entradas não assinadas).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É claro que depois disso o sistema se torna completamente inacessível por nada. </font><font style="vertical-align: inherit;">Só pode ser descarregado, limpo - muito trabalho manual. </font><font style="vertical-align: inherit;">Disponibilidade total: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/lz/fs/iulzfslzcst3tn9c-qpouy9zqsk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
além disso, se isso for replicado em outro lugar, o cluster inteiro simplesmente ficará parado. </font><font style="vertical-align: inherit;">Uma situação absolutamente inaceitável que qualquer um pode organizar de forma rápida e simples! </font><font style="vertical-align: inherit;">Portanto, consideramos esse momento como um dos mais importantes. </font><font style="vertical-align: inherit;">Como evitá-lo?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa maneira é assinar clusterTime</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por isso, é transmitido na mensagem (antes do texto azul). Mas também começamos a gerar uma assinatura (texto azul): A </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/9r/iu/zg9riuabqzdlnw9dwttrwkwzkmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
assinatura é gerada por uma chave que é armazenada dentro do banco de dados, dentro do perímetro protegido; é gerado, atualizado (os usuários não veem nada). O hash é gerado e cada mensagem é assinada durante a criação e validada após o recebimento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provavelmente, surge a pergunta nas pessoas: "Quanto isso desacelera?" Eu disse que deveria funcionar rapidamente, principalmente na ausência desse recurso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que significa usar a consistência causal neste caso? Isso mostrará o parâmetro afterClusterTime. E sem ele, simplesmente passará valores de qualquer maneira. A fofoca, desde a versão 3.6, sempre funciona.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se deixarmos a geração constante de assinaturas, isso reduzirá a velocidade do sistema, mesmo na ausência de recursos, o que não atende às nossas abordagens e requisitos. </font><font style="vertical-align: inherit;">E o que fizemos?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faça rápido!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma coisa bastante simples, mas o truque é interessante - vou compartilhar, talvez alguém esteja interessado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos um hash que armazena dados assinados. </font><font style="vertical-align: inherit;">Todos os dados passam pelo cache. </font><font style="vertical-align: inherit;">O cache não assina especificamente a hora, mas o intervalo. </font><font style="vertical-align: inherit;">Quando um determinado valor chega, geramos um intervalo, mascaramos os últimos 16 bits e assinamos esse valor: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s8/ml/3a/s8ml3aaec2pj5xl8t0zvkrp7iik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ao receber essa assinatura, agilizamos o sistema (condicionalmente) em 65 mil vezes. </font><font style="vertical-align: inherit;">Funciona muito bem: quando eles fizeram os experimentos, o tempo em que tivemos uma atualização consistente foi realmente reduzido lá em 10 mil vezes. </font><font style="vertical-align: inherit;">É claro que, quando estão em desacordo, isso não funciona. </font><font style="vertical-align: inherit;">Mas, na maioria dos casos práticos, isso funciona. </font><font style="vertical-align: inherit;">A combinação da assinatura Range com a assinatura resolveu o problema de segurança.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que aprendemos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lições que aprendemos com isso:</font></font><br>
<br>
<ul>
<li>  , , ,       .     -  ( ,      . .),  , .   ,       ,    ,   .        –   .<br>
<br>
,     ,      («», ) –      .     ?    .     ,      .   –   ,   .</li>
<li>    .  ,        «»     ,   ,  ,      availability, latency  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A última é que tivemos que considerar idéias diferentes e combinar vários artigos geralmente diferentes em uma única abordagem. </font><font style="vertical-align: inherit;">A idéia de assinar, por exemplo, veio de um artigo que examinou o protocolo Paxos, que para Faylor não bizantino dentro do protocolo de autorização, para bizantinos fora do protocolo de autorização ... Em geral, foi exatamente isso que fizemos no final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não há absolutamente nada de novo aqui! </font><font style="vertical-align: inherit;">Mas assim que misturamos tudo ... É como dizer que a receita da salada Olivier não faz sentido, porque ovos, maionese e pepino já surgiram ... É a mesma história.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/6o/pc/q8/6opcq8ew4bcry9qnt0lsdlasflo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobre isso eu vou terminar. </font><font style="vertical-align: inherit;">Obrigado!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Questões</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pergunta da audiência (doravante - B):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Obrigado, Michael, pelo relatório! O tema do tempo é interessante. Você está usando fofocas. Eles disseram que todo mundo tem seu próprio tempo, todo mundo sabe o horário local. Pelo que entendi, temos um driver - pode haver muitos clientes com drivers, planejadores de consulta também, muitos fragmentos ... Mas para que serve o sistema se de repente tivermos uma discrepância: alguém decide que ele é por um minuto à frente, alguém - um minuto atrás? Onde nos encontraremos? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ótima pergunta mesmo! Eu só queria dizer sobre estilhaços. Se eu entendi a pergunta corretamente, temos a seguinte situação: existe o fragmento 1 e o fragmento 2, a leitura ocorre nesses dois fragmentos - eles têm uma discrepância, não interagem entre si, porque o tempo que eles conhecem é diferente, especialmente o tempo em que Eles existem em oplogs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que o shard 1 tenha feito um milhão de registros, o shard 2 não fez nada e a solicitação ocorreu em dois shards. E o primeiro tem afterClusterTime mais de um milhão. Em tal situação, como expliquei, o fragmento 2 nunca responderá. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Eu queria saber como eles são sincronizados e escolhem um horário lógico? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Muito fácil de sincronizar. Shard, quando afterClusterTime chega até ele, e ele não encontra o tempo no "Catch" - inicia não aprovado. Ou seja, ele levanta as mãos para esse valor com as mãos. Isso significa que não há eventos correspondentes a essa consulta. Ele cria esse evento artificialmente e, assim, torna-se o Causal Consistente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - E se, depois disso, alguns outros eventos perdidos em algum lugar da rede ainda vierem a ele? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- O fragmento está tão arranjado que não virá mais, pois é um único mestre. Se ele já gravou, eles não virão, mas serão depois. Não pode acontecer que em algum lugar algo esteja preso, ele não escreverá e então esses eventos chegaram - e a consistência causal foi violada. Quando ele não escreve, todos têm que vir em seguida (ele esperará por eles). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/wb/oo/t2wboofhfs7qpepqz8zwsm1o0u4.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Eu tenho algumas perguntas sobre as falas. A consistência causal pressupõe que há uma determinada fila de ações que precisam ser executadas. O que acontece se perdermos um pacote? Então o dia 10 passou, o dia 11 ... o dia 12 desapareceu, e todo mundo está esperando que isso seja cumprido. E de repente nosso carro morreu, não podemos fazer nada. Existe um comprimento máximo da fila que se acumula antes de ser executado? Que falha fatal ocorre quando um estado é perdido? Além disso, se escrevermos que existe algum tipo de estado anterior, devemos começar de alguma forma? E eles não se afastaram dele! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Também é uma pergunta maravilhosa! O que estamos fazendo? O MongoDB tem o conceito de registros de quorum, lê o quorum. Quando uma mensagem pode desaparecer? Quando o registro não é quorum ou quando a leitura não é quorum (algum lixo também pode grudar). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com relação à consistência causal, realizamos um grande teste experimental, que resultou no fato de que, quando a gravação e a leitura não são quorum, ocorrem violações da consistência causal. Exatamente o que você diz!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa dica: use pelo menos a leitura de quorum ao usar a consistência causal. Nesse caso, nada será perdido, mesmo se o registro de quorum for perdido ... Essa é uma situação ortogonal: se o usuário não quiser que os dados sejam perdidos, você precisará usar o registro de quorum. A consistência causal não garante durabilidade. A garantia de durabilidade é fornecida pela replicação e maquinaria associada à replicação. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Quando criamos uma instância que o sharding faz por nós (não mestre, mas escravo, respectivamente), ele se baseia no tempo unix de sua própria máquina ou no tempo do "mestre"; sincronizado pela primeira vez ou periodicamente? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Agora vou deixar claro. Fragmento (ou seja, partição horizontal) - sempre há Primário. E em um fragmento, pode haver um "mestre" e pode haver réplicas. Mas o shard sempre suporta gravação, porque deve suportar um determinado domínio (o Primary está no shard). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ou seja, tudo depende puramente do "mestre"? Sempre use o tempo "mestre"? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sim. Pode-se dizer figurativamente: o relógio está correndo quando há uma gravação no "master", no "Oplog". </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Temos um cliente que se conecta e ele não precisa saber nada sobre tempo? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Em geral, você não precisa saber de nada! Se falamos sobre como isso funciona no cliente: no cliente, quando ele deseja usar a consistência causal, ele precisa abrir uma sessão. Agora está tudo lá: ambas as transações na sessão e recuperar direitos ... Uma sessão é uma ordenação de eventos lógicos que ocorrem com um cliente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ele abrir esta sessão e disser que deseja consistência causal (se por padrão a sessão suportar consistência causal), tudo funcionará automaticamente. O motorista lembra desse tempo e aumenta quando recebe uma nova mensagem. Ele lembra qual resposta retornou a anterior do servidor que retornou os dados. A solicitação a seguir conterá afterCluster ("o tempo é maior que isso").</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cliente não precisa saber absolutamente nada! Isso é absolutamente opaco para ele. Se as pessoas usam esses recursos, o que posso fazer? Primeiro, você pode ler com segurança os secundários: você pode escrever no Primário e ler os secundários geograficamente replicados e garantir que funcione. Ao mesmo tempo, as sessões que foram gravadas na Primária podem ser transferidas até para a Secundária, ou seja, você pode usar não uma sessão, mas várias. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - O tópico Consistência eventual está fortemente relacionado à nova camada de ciência de computação - tipos de dados CRDT (tipos de dados replicados sem conflitos). Você considerou a integração desses tipos de dados no banco de dados e o que você pode dizer sobre isso? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Boa pergunta! O CRDT faz sentido para conflitos de gravação: no MongoDB - mestre único. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Eu tenho uma pergunta dos devops. No mundo real, existem situações jesuítas quando ocorre a falha bizantina, e as pessoas más dentro do perímetro protegido começam a aderir ao protocolo, enviam pacotes de artesanato de uma maneira especial? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/m3/p5/8dm3p5em6rsqsv2ojzy-vdylffg.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Pessoas más dentro do perímetro são como um cavalo de Tróia! Pessoas más dentro do perímetro podem fazer muitas coisas ruins. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - É claro que deixar um buraco no servidor, grosso modo, através do qual você pode enfiar o zoológico de elefantes e recolher todo o cluster para sempre ... Levará tempo para a recuperação manual ... Isto é, para dizer o mínimo, errado. Por outro lado, isso é curioso: na vida real, na prática, há situações em que ataques internos naturalmente semelhantes ocorrem? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Como raramente encontro violações de segurança na vida real, não posso dizer - talvez elas aconteçam. Mas se falamos sobre filosofia de desenvolvimento, pensamos assim: temos um perímetro que fornece aos indivíduos que fazem segurança - é um castelo, um muro; e dentro do perímetro você pode fazer o que quiser. É claro que existem usuários com a capacidade de procurar apenas e há usuários com a capacidade de apagar o diretório. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dependendo dos direitos, o dano que os usuários podem causar pode ser um mouse ou um elefante. É claro que um usuário com todos os direitos pode fazer qualquer coisa. Um usuário sem direitos amplos de dano pode causar significativamente menos. Em particular, ele não pode quebrar o sistema. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- No perímetro seguro, alguém escalou para formar protocolos inesperados para o servidor, a fim de configurar o servidor com câncer e, se você tiver sorte, todo o cluster ... Isso acontece tão "bem"? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Eu nunca ouvi falar dessas coisas. O fato de que dessa maneira você pode preencher o servidor não é um segredo. Para preencher por dentro, sendo do protocolo, sendo um usuário autorizado que pode escrever algo assim em uma mensagem ... Na verdade, é impossível, porque de qualquer maneira será verificado. É possível desativar essa autenticação para usuários que não desejam - este é o problema deles; grosso modo, eles mesmos destruíram as paredes e você pode amontoar um elefante ali, o que vai atropelar ... Em geral, você pode se vestir como reparador, venha buscá-lo! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Obrigado pelo relatório. </font><font style="vertical-align: inherit;">Sergey (Yandex). </font><font style="vertical-align: inherit;">Em "Mong", existe uma constante que limita o número de membros votantes no conjunto de réplicas, e essa constante é 7 (sete). </font><font style="vertical-align: inherit;">Por que isso é uma constante? </font><font style="vertical-align: inherit;">Por que isso não é algum tipo de parâmetro? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Conjunto de réplicas também temos 40 nós. </font><font style="vertical-align: inherit;">Sempre existe uma maioria. </font><font style="vertical-align: inherit;">Não sei qual versão ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - No conjunto de réplicas, você pode executar membros sem direito a voto, mas votando - no máximo 7. Como, nesse caso, ocorrerá o desligamento se o conjunto de réplicas for puxado para três datacenters? </font><font style="vertical-align: inherit;">Um data center pode desligar-se facilmente e outra máquina cai. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Isso já está um pouco fora do escopo do relatório. </font><font style="vertical-align: inherit;">Essa é uma pergunta comum. </font><font style="vertical-align: inherit;">Talvez então eu possa contar a ele.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9t/cr/ga/9tcrgaodiufisllhrktf_5iok_a.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UnAprFMX1d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco de publicidade :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obrigado por ficar com a gente. Você gosta dos nossos artigos? Deseja ver materiais mais interessantes? Ajude-nos fazendo um pedido ou recomendando aos seus amigos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS na nuvem para desenvolvedores a partir de US $ 4,99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analógico exclusivo de servidores de nível básico que foi inventado por nós para você: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toda a verdade sobre o VPS (KVM) E5-2697 v3 (6 núcleos) 10 GB DDR4 480 GB SSD 1 Gbps de US $ 19 ou como dividir o servidor?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 vezes mais barato no data center Equinix Tier IV em Amsterdã?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somente nós temos </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 TVs Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV a partir de US $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na Holanda!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - a partir de US $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leia sobre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como criar um prédio de infraestrutura. </font><font style="vertical-align: inherit;">classe c usando servidores Dell R730xd E5-2650 v4 que custam 9.000 euros por um centavo?</font></font></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt487626/index.html">Como os sensores de estacionamento funcionam e como enganá-lo</a></li>
<li><a href="../pt487628/index.html">Diagnóstico do envelhecimento com base em 9 características dos sinais de envelhecimento</a></li>
<li><a href="../pt487630/index.html">O algoritmo mais simples para criar um quebra-cabeça de campo (parte 1)</a></li>
<li><a href="../pt487632/index.html">“Colegas, respirem mais silenciosamente”: por que o barulho do escritório nos deixa loucos - discutimos pesquisas</a></li>
<li><a href="../pt487636/index.html">APIs para as quais finalmente vale a pena atualizar do Java 8. Parte 2</a></li>
<li><a href="../pt487640/index.html">Teste de automação de jogos</a></li>
<li><a href="../pt487644/index.html">Obtendo cotações de ações usando Python</a></li>
<li><a href="../pt487646/index.html">Estrela de nêutrons do tubo de ensaio. Sonoluminescência</a></li>
<li><a href="../pt487648/index.html">Poderia ser outro framework javascript.</a></li>
<li><a href="../pt487650/index.html">Espere no SDK e não dê errado: o problema dos pergaminhos aninhados no BottomSheetBehavior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>