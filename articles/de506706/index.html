<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öõÔ∏è üë≤üèæ üë©üèΩ‚Äçü§ù‚Äçüë®üèæ Die Leistung von modernem Java beim Arbeiten mit gro√üen Datenmengen, Teil 1 ‚úãüèæ üà≥ üë©üèΩ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Java-Laufzeit hat sich in den letzten Jahren schneller entwickelt als zuvor. Nach 15 Jahren haben wir endlich den Standard-Garbage Collector bekom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Die Leistung von modernem Java beim Arbeiten mit gro√üen Datenmengen, Teil 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/506706/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gy/8p/zf/gy8pzf7gjtwr9pvv1zb7rgmmjiy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Java-Laufzeit hat sich in den letzten Jahren schneller entwickelt als zuvor. </font><font style="vertical-align: inherit;">Nach 15 Jahren haben wir endlich den Standard-Garbage Collector bekommen - G1. </font><font style="vertical-align: inherit;">Zwei weitere befinden sich in der Entwicklung und sind als experimentelle Funktionen verf√ºgbar - Oracle ZGC und OpenJDK Shenandoah. </font><font style="vertical-align: inherit;">Wir haben uns entschlossen, all diese neuen Tools zu testen und herauszufinden, was mit den f√ºr die verteilte Open Source-Streaming-Engine von Hazelcast Jet typischen Workloads am besten funktioniert.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jet wird verwendet, um alle Arten von Aufgaben mit unterschiedlichen Latenz- und Bandbreitenanforderungen zu l√∂sen. </font><font style="vertical-align: inherit;">Aufgaben fallen in drei wichtige Kategorien:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unbegrenztes Streaming mit geringer Latenz. </font><font style="vertical-align: inherit;">Beispiel: Identifizieren von Datentrends von Sensoren von 10.000 Ger√§ten, die Informationen mit einer Frequenz von 100 Hz erfassen, und Senden von Korrekturen innerhalb von 10 bis 20 ms.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unbegrenzte Streaming-Verarbeitung mit hoher Bandbreite. </font><font style="vertical-align: inherit;">Beispiel: Verfolgen von GPS-Koordinaten von Millionen von Benutzern mit der Berechnung ihrer Geschwindigkeitsvektoren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassische Stapelverarbeitung von Big Data. </font><font style="vertical-align: inherit;">Das Kriterium ist die f√ºr die Verarbeitung aufgewendete Zeit, was bedeutet, dass ein hoher Durchsatz erforderlich ist. </font><font style="vertical-align: inherit;">Beispiel: Analyse der pro Tag gesammelten Aktienhandelsdaten, um das Risiko f√ºr ein bestimmtes Portfolio von Verm√∂genswerten zu aktualisieren.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst k√∂nnen wir Folgendes beobachten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten Szenario fallen die Verz√∂gerungsanforderungen in den Gefahrenbereich der Garbage Collector-Pausen: 100 ms. </font><font style="vertical-align: inherit;">Dies wird in den schwierigsten F√§llen als hervorragendes Ergebnis f√ºr die Speicherbereinigung angesehen und kann in vielen Situationen zu einem Stolperstein werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite und dritte Szenario sind hinsichtlich der Anforderungen an die Speicherbereinigung identisch. </font><font style="vertical-align: inherit;">Die Verz√∂gerungsanforderungen sind weniger streng, aber eine gro√üe Belastung f√ºr fest angestellte Generationen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite Szenario ist aufgrund der Verz√∂gerungsanforderungen schwieriger, auch wenn es nicht so streng ist wie im ersten Szenario.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben folgende Kombinationen ausprobiert:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 8 mit Standard-Parallel-Assembler und optionalem ConcurrentMarkSweep und G1.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 11 mit Standardkollektor G1 und optionalem Parallel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 14 mit Standardkollektor G1 und experimentellem ZGC und Shenandoah.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind zu folgenden Schlussfolgerungen gekommen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit modernen Versionen von JDK funktioniert der G1 Builder hervorragend. </font><font style="vertical-align: inherit;">Es verarbeitet problemlos Dutzende von Gigabyte Heap (wir haben 60 GB ausprobiert) mit einer maximalen Pause von 200 ms. </font><font style="vertical-align: inherit;">Unter extremer Last geht G1 nicht in alptraumkritische Modi. </font><font style="vertical-align: inherit;">Stattdessen erh√∂ht sich die Dauer der Pausen f√ºr die vollst√§ndige Speicherbereinigung auf Sekunden. </font><font style="vertical-align: inherit;">Die Schwachstelle des Kollektors ist die obere Grenze der Pausen bei g√ºnstigen Bedingungen geringer Last. </font><font style="vertical-align: inherit;">Wir haben es geschafft, es auf 20-25 ms zu senken.</font></font></li>
<li>JDK 8 ‚Äî   .    Parallel       .  G1    ,    ,       ,     .       12    20   Parallel     G1. ConcurrentMarkSweep       G1,           .</li>
<li>  ZGC    ,   G1,        ,  G1       10 . </li>
<li>Shenandoah        220    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weder ZGC noch Shenandoah verhielten sich in kritischen Modi so konstant wie G1. </font><font style="vertical-align: inherit;">Ihre Arbeit war unzuverl√§ssig, im Modus mit geringer Latenz traten unerwartet sehr lange Pausen auf, und sogar OOME.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel beschreibt die Ergebnisse unserer Tests in zwei Streaming-Verarbeitungsszenarien. </font><font style="vertical-align: inherit;">Im zweiten Teil werden wir √ºber die Ergebnisse der Stapelverarbeitung sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream-Verarbeitungs-Benchmark</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den Streaming-Benchmark haben wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code zwischen den Tests ein wenig ge√§ndert. </font><font style="vertical-align: inherit;">Hier ist der Hauptteil, die Jet-Pipeline:</font></font><br>
<br>
<pre><code class="java hljs">StreamStage&lt;Long&gt; source = p.readFrom(longSource(ITEMS_PER_SECOND))<font></font>
                            .withNativeTimestamps(<span class="hljs-number">0</span>)<font></font>
                            .rebalance(); <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
source.groupingKey(n -&gt; n % NUM_KEYS)<font></font>
      .window(sliding(SECONDS.toMillis(WIN_SIZE_SECONDS), SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .filter(kwr -&gt; kwr.getKey() % DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR == <span class="hljs-number">0</span>)<font></font>
      .window(tumbling(SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .writeTo(Sinks.logger(wr -&gt; String.format(<span class="hljs-string">"time %,d: latency %,d ms, cca. %,d keys"</span>,<font></font>
              simpleTime(wr.end()),<font></font>
              NANOSECONDS.toMillis(System.nanoTime()) - wr.end(),<font></font>
              wr.result() * DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR)));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Pipeline spiegelt Nutzungsszenarien mit einem unbegrenzten Ereignisfluss wider. Die Engine sollte Daten mithilfe der Methode "Schiebefenster" aggregieren. Eine solche Aggregation ist beispielsweise erforderlich, um die zeitliche Ableitung eines sich √§ndernden Werts zu erhalten, Daten aus hochfrequentem Rauschen zu l√∂schen (Gl√§ttung) oder um die H√§ufigkeit des Auftretens eines Ereignisses (Ereignisse pro Sekunde) zu messen. Die Engine kann den Stream zun√§chst in Kategorien (z. B. alle einzelnen IoT-Ger√§te oder Smartphones) in Sub-Streams unterteilen. Verfolgen Sie dann unabh√§ngig den aggregierten Wert f√ºr jeden Subflow. In Hazelcast Jet bewegt sich ein Schiebefenster in diskreten Schritten, deren Gr√∂√üe Sie angeben. Mit einem Schritt von 1 Sekunde erhalten Sie beispielsweise jede Sekunde einen vollst√§ndigen Satz von Ergebnissen. Und mit einem Schritt von 1 Minute enthalten die Ergebnisse alles, was in der letzten Minute passiert ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Notizen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code ist vollst√§ndig in sich geschlossen. Externe Datenquellen werden nicht verwendet. Wir verwenden eine Stub-Quelle, um einen Strom von Ereignissen mit der richtigen Frequenz zu emulieren. Ereignisse treten in regelm√§√üigen Abst√§nden auf. Die Quelle generiert keine Ereignisse, deren Zeitstempel sich auf die Zukunft beziehen, sondern generiert sie so schnell wie m√∂glich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Pipeline verz√∂gert ist, werden die Ereignisse ohne Speichern ‚Äûgepuffert‚Äú. In diesem Fall sollte die Pipeline so schnell wie m√∂glich aufholen und Daten empfangen. Da unsere Quelle nicht parallelisiert ist, erreichte ihre Bandbreitenbeschr√§nkung etwa 2,2 Millionen Ereignisse pro Sekunde. Wir haben 1 Million Ereignisse / s emuliert und einen Spielraum f√ºr das Aufholen von bis zu 1,2 Millionen Ereignissen / s gelassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der F√∂rderer misst seine Verz√∂gerung, indem er den Zeitstempel des Ergebnisses des Schiebefensters mit der aktuellen Zeit vergleicht. Es wurden zwei Aggregationsstufen mit Zwischenfiltration verwendet. Das Ergebnis eines Schiebefensters enth√§lt viele Elemente, eines f√ºr jeden Teilstrom, und wir sind an der Verz√∂gerung f√ºr das letzte der Elemente interessiert. Daher filtern wir zuerst den gr√∂√üten Teil des Ergebnisses heraus und lassen jedes zehntausendste Element √ºbrig. Und dann lenken wir den reduzierten Durchfluss auf die zweite Stufe, mit einem ‚ÄûFlip‚Äú -Fenster ohne Schl√ºssel. In diesem Stadium notieren wir die Gr√∂√üe des Ergebnisses und messen die Verz√∂gerung. Die Aggregation ohne Verwendung eines Schl√ºssels ist nicht parallelisiert, daher haben wir einen Messpunkt. Die Filtrationsstufe ist parallelisiert und datenlokal, so dass der Einfluss der zus√§tzlichen Aggregationsstufe sehr gering ist (viel geringer als 1 ms).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine einfache Aggregatfunktion verwendet: Z√§hlen. Tats√§chlich wurde eine Metrik der H√§ufigkeit von Ereignissen im Strom erhalten. Es hat eine minimale Struktur (eine Typennummer </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), M√ºll wird nicht generiert. F√ºr jede Menge Heap-Nutzung (in Gigabyte) impliziert eine so kleine Schl√ºsselstruktur das Worst-Case-Szenario f√ºr den Garbage Collector: eine sehr gro√üe Anzahl von Objekten. Die Belastung des Kollektors w√§chst nicht mit der Gr√∂√üe des Heaps, sondern mit der Anzahl der Objekte. Wir haben auch die Option getestet, dieselbe Aggregatfunktion zu berechnen, jedoch mit einer anderen Implementierung, die M√ºll erzeugt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die meisten Stream-Benchmarks auf einem Knoten durchgef√ºhrt, da wir an den Auswirkungen der Speicherverwaltung auf die Pipeline-Leistung interessiert waren. </font><font style="vertical-align: inherit;">Und die Netzwerklatenz f√ºgt den Daten nur Rauschen hinzu. </font><font style="vertical-align: inherit;">Um die Hypothese zu testen, dass die Clusterleistung unsere Ergebnisse nicht beeinflusst, haben wir einige Schl√ºsseltests an einem Amazon EC2-Cluster mit drei Knoten wiederholt. </font><font style="vertical-align: inherit;">Mehr dazu wird am Ende des zweiten Artikels beschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Parallelkollektor aus den Ergebnissen der Streaming-Last entfernt, da die von ihm erzeugten Verz√∂gerungsspitzen in den meisten realen Szenarien nicht akzeptabel sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenario 1: geringe Latenz, mittlere Struktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skriptoptionen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenJDK 14</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gr√∂√üe des JVM-Heapspeichers betr√§gt 4 GB.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr G1 gegeben </font></font><code>-XX:MaxGCPauseMillis=5</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Million Ereignisse / s.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50.000 Einzelschl√ºssel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 Sekunden Schiebefenster nach 0,1 Sekunden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Szenario wird weniger als 1 GB Heap verwendet. </font><font style="vertical-align: inherit;">Die Belastung des Kollektors ist gering, er hat genug Zeit f√ºr eine wettbewerbsf√§hige Speicherbereinigung im Hintergrund. </font><font style="vertical-align: inherit;">Hier sind die maximalen Verz√∂gerungen beim Betrieb der Pipeline mit drei getesteten Assemblern:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/053/d40/26c/053d4026c6d3eb747e3e78bbdcd46ecd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Werte umfassen feste Intervalle von ungef√§hr 3 ms f√ºr die √úbertragung von Fensterergebnissen. </font><font style="vertical-align: inherit;">Die Grafik spricht f√ºr sich: Der Standardkollektor G1 leistet hervorragende Arbeit, aber wenn Sie eine noch geringere Verz√∂gerung ben√∂tigen, k√∂nnen Sie die experimentelle ZGC verwenden. </font><font style="vertical-align: inherit;">Wir konnten die Verz√∂gerungsspitzen nicht unter 10 ms senken. </font><font style="vertical-align: inherit;">Im Fall von ZGC und Shenandoah entstehen sie jedoch nicht aufgrund von Pausen bei der M√ºllabfuhr, sondern aufgrund kurzer Zeitr√§ume mit erh√∂htem Hintergrundarbeitsvolumen von Sammlern. </font><font style="vertical-align: inherit;">Gelegentlich erh√∂hten Shenandoah-Serviceprozesse die Verz√∂gerung auf √ºber 200 ms.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenario zwei: gr√∂√üere Struktur, weniger strenge Latenzanforderungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen davon aus, dass sich die Verz√∂gerung aus Gr√ºnden, die au√üerhalb unserer Kontrolle liegen (z. B. aufgrund des Mobilfunknetzes), auf Sekunden erh√∂hen kann. </font><font style="vertical-align: inherit;">Dies verringert die Anforderungen an die Stream-Verarbeitungspipeline. </font><font style="vertical-align: inherit;">Auf der anderen Seite k√∂nnen wir auf viel gr√∂√üere Daten sto√üen, die Millionen oder Dutzende Millionen Schl√ºssel gro√ü sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Szenario k√∂nnen wir die Ger√§te f√ºr eine starke Beanspruchung vorbereiten, wobei die Tatsache ber√ºcksichtigt wird, dass der Garbage Collector in einem gro√üen Heap ausgef√ºhrt wird, anstatt Daten auf mehrere Knoten des Clusters zu verteilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben viele Tests in verschiedenen Kombinationen durchgef√ºhrt, um herauszufinden, wie sich Kombinationen von Faktoren auf die Leistung der Laufzeit auswirken. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies von zwei Parametern abh√§ngt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der in Aggregaten gespeicherten Datens√§tze.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bandbreitenbedarf f√ºr Make-up.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Parameter beschreibt die Anzahl der Objekte in der dauerhaften Generation. Beim Aggregieren mit der Schiebefenstermethode halten wir Objekte f√ºr eine lange Zeit (im gesamten Fenster) und geben sie dann frei. Dies steht in direktem Widerspruch zur Generationsm√ºllhypothese (Generationsm√ºllhypothese), nach der Objekte entweder jung sterben oder f√ºr immer leben. In diesem Modus wird die maximale Belastung des Garbage Collector erstellt. Und da die Intensit√§t seiner Arbeit mit der Anzahl der lebenden Objekte zunimmt, h√§ngt die Produktivit√§t stark von diesem Parameter ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Parameter bezieht sich darauf, wie viele Ressourcen die Anwendung dem Garbage Collector zuweisen kann. Um es klarer zu machen, erstellen wir einige Diagramme. Bei der Aggregation nach der Schiebefenstermethode durchl√§uft der F√∂rderer drei Stufen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echtzeit-Ereignisverarbeitung, sobald sie auftritt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbergeben der Ergebnisse eines Schiebefensters.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufholen der Ereignisse, die in der zweiten Phase eingegangen sind.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle drei Stufen k√∂nnen wie folgt visualisiert werden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99c/d77/894/99cd778940f1596c2dd5e1dbf0933fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die √úbertragung von Fensterergebnissen l√§nger dauert, befinden wir uns in dieser Situation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/694/760/b226947608cfb3373742d02e6dc7774f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt hat der F√∂rderer kaum noch Zeit, und alle Zeitverz√∂gerungen wie Pausen f√ºr die Speicherbereinigung erh√∂hen die Verz√∂gerung und erholen sich sehr langsam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns das Diagramm √§ndern und nur die durchschnittliche Absorptionsrate von Ereignissen anzeigen, nachdem die Ergebnisse des Fensters √ºbergeben wurden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/cd9/ccb/d78cd9ccbf09b96c23705ae8bb0d6e38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nennen wir die H√∂he des gelben Rechtecks ‚Äã‚Äã‚ÄûAuferlegungsanforderung‚Äú: Dies ist die Anforderung an die Quellkapazit√§t. Wenn es den tats√§chlichen Durchsatz des F√∂rderers √ºberschreitet, kann es die Last nicht bew√§ltigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus, wenn das √úbertragen von Fensterergebnissen zu lange dauert:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/0ea/594/5b90ea59490f05c628401475c9849e21.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bereich der roten und gelben Rechtecke ist fest und entspricht der Datenmenge, die durch die Pipeline geleitet werden muss. Tats√§chlich ‚Äûdr√ºckt‚Äú Rot Gelb. Die H√∂he des gelben Rechtecks ‚Äã‚Äãist jedoch begrenzt. In unserem Fall betr√§gt die Obergrenze 2,2 Millionen Ereignisse / s. Und wenn die H√∂he den Grenzwert √ºberschreitet, erhalten wir einen F√∂rderer, der die Last nicht bew√§ltigen kann, und eine unbegrenzt wachsende Verz√∂gerung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben Formeln zur Vorhersage der Gr√∂√üe von Rechtecken f√ºr eine bestimmte Kombination aus Ereignisfrequenz, Fenstergr√∂√üe, Schlupfschritt und Schl√ºsselsatzgr√∂√üe abgeleitet. So k√∂nnen wir auf jeden Fall das Erfordernis der Auferlegung bestimmen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir zwei mehr oder weniger unabh√§ngige Parameter, die von vielen anderen Parametern abgeleitet sind, die jede einzelne Kombination beschreiben. </font><font style="vertical-align: inherit;">Sie k√∂nnen ein zweidimensionales Diagramm erstellen, auf dem Kreise die verbannten Benchmarks anzeigen. </font><font style="vertical-align: inherit;">F√§rben Sie die Kreise nach Erfolg oder Misserfolg der Kombination. </font><font style="vertical-align: inherit;">F√ºr eine Reihe von JDK 14 mit G1 auf einem Laptop erhalten wir beispielsweise die folgende Grafik:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab2/9e6/416/ab29e641669a2666c59d506e59fce458.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben drei Kategorien identifiziert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ja" - der F√∂rderer kommt zurecht,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Nein" - die Pipeline kann aufgrund mangelnder Bandbreite nicht bew√§ltigen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûM√ºllsammler‚Äú - der F√∂rderer kommt aufgrund h√§ufiger langer Montagepausen nicht zurecht.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass aufgrund der wettbewerbsf√§higen Speicherbereinigung und h√§ufiger kurzer Montagepausen auch ein Mangel an Bandbreite auftreten kann. Im Allgemeinen ist der Unterschied zwischen den letzten beiden Kategorien gering. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen den Rand sehen, der unten links im Diagramm trennt. Es enth√§lt Punkte erfolgreich bestandener Benchmarks. Wir haben das gleiche Diagramm f√ºr andere Kombinationen von JDK und Garbage Collector erstellt, die Grenzen der Zonen identifiziert und das folgende Ergebnis erhalten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/d12/394/251d123945208cbed4806928946c4241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir hatten ein MacBook Pro 2018 mit einem 6-Kern Intel Core i7 und 16 GB DDR4 RAM. F√ºr die JVM wurde konfiguriert </font></font><code>-Xmx10g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir glauben jedoch, dass ein √§hnliches Bild bei vielen anderen Konfigurationen beobachtet wird. Die Grafik zeigt die √úberlegenheit von G1 gegen√ºber anderen Kollektoren, die Schw√§che von G1 bei Verwendung mit JDK 8 und die Schw√§che von experimentellen Kollektoren mit geringer Latenz unter dieser Art von Last.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundverz√∂gerung - die Dauer der √úbertragung der Fensterergebnisse - schwankte um 500 ms. </font><font style="vertical-align: inherit;">Bursts traten jedoch h√§ufig aufgrund der Hauptpausen f√ºr die M√ºllabfuhr auf (die im Fall von G1 unangemessen lang waren), bis zu 10 s in Grenzsituationen (wenn der F√∂rderer kaum mit der Arbeit fertig wird) und sanken auf 1-2 s. </font><font style="vertical-align: inherit;">Wir haben auch den Effekt der JIT-Kompilierung in Grenzsituationen festgestellt: Die Pipeline beginnt mit immer gr√∂√üerer Verz√∂gerung zu arbeiten, und nach etwa zwei Minuten verbessert sich die Leistung und die Verz√∂gerung kehrt zu normalen Werten zur√ºck.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506696/index.html">Verwalten von PostgreSQL auf Gitlab.com. Jose Cores Finotto</a></li>
<li><a href="../de506698/index.html">Requiem f√ºr "Sea Launch"</a></li>
<li><a href="../de506700/index.html">Wir konfigurieren GitHub-Aktionen f√ºr Android mit der anschlie√üenden Bereitstellung in PlayMarket</a></li>
<li><a href="../de506702/index.html">Die zuverl√§ssigsten Festplatten nach Backblaze Q1 2020</a></li>
<li><a href="../de506704/index.html">Warum 2020 in PHP schreiben? Holivarim ist diesen Donnerstag ein interaktiver Podcast auf Youtube</a></li>
<li><a href="../de506708/index.html">VPN / Mikrotik Zwei-Faktor-Authentifizierung - einfach und skalierbar</a></li>
<li><a href="../de506710/index.html">Verwalten Sie mehrere Adressb√ºcher in der Open-Source-Edition der Zimbra Collaboration Suite</a></li>
<li><a href="../de506716/index.html">Lineare Multithread-Liste: Elementexistenzproblem, Produktivit√§tsverbesserung und STL-Beziehung</a></li>
<li><a href="../de506726/index.html">Erfahrung in der Verwendung der Rutoken-Technologie zur Registrierung und Autorisierung von Benutzern im System (Teil 2)</a></li>
<li><a href="../de506730/index.html">Schnauben oder Suricata. Teil 1: W√§hlen Sie ein kostenloses IDS / IPS, um das Unternehmensnetzwerk zu sch√ºtzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>