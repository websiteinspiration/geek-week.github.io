<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚛️ 👲🏾 👩🏽‍🤝‍👨🏾 Die Leistung von modernem Java beim Arbeiten mit großen Datenmengen, Teil 1 ✋🏾 🈳 👩🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Java-Laufzeit hat sich in den letzten Jahren schneller entwickelt als zuvor. Nach 15 Jahren haben wir endlich den Standard-Garbage Collector bekom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Die Leistung von modernem Java beim Arbeiten mit großen Datenmengen, Teil 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/506706/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gy/8p/zf/gy8pzf7gjtwr9pvv1zb7rgmmjiy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Java-Laufzeit hat sich in den letzten Jahren schneller entwickelt als zuvor. </font><font style="vertical-align: inherit;">Nach 15 Jahren haben wir endlich den Standard-Garbage Collector bekommen - G1. </font><font style="vertical-align: inherit;">Zwei weitere befinden sich in der Entwicklung und sind als experimentelle Funktionen verfügbar - Oracle ZGC und OpenJDK Shenandoah. </font><font style="vertical-align: inherit;">Wir haben uns entschlossen, all diese neuen Tools zu testen und herauszufinden, was mit den für die verteilte Open Source-Streaming-Engine von Hazelcast Jet typischen Workloads am besten funktioniert.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jet wird verwendet, um alle Arten von Aufgaben mit unterschiedlichen Latenz- und Bandbreitenanforderungen zu lösen. </font><font style="vertical-align: inherit;">Aufgaben fallen in drei wichtige Kategorien:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unbegrenztes Streaming mit geringer Latenz. </font><font style="vertical-align: inherit;">Beispiel: Identifizieren von Datentrends von Sensoren von 10.000 Geräten, die Informationen mit einer Frequenz von 100 Hz erfassen, und Senden von Korrekturen innerhalb von 10 bis 20 ms.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unbegrenzte Streaming-Verarbeitung mit hoher Bandbreite. </font><font style="vertical-align: inherit;">Beispiel: Verfolgen von GPS-Koordinaten von Millionen von Benutzern mit der Berechnung ihrer Geschwindigkeitsvektoren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassische Stapelverarbeitung von Big Data. </font><font style="vertical-align: inherit;">Das Kriterium ist die für die Verarbeitung aufgewendete Zeit, was bedeutet, dass ein hoher Durchsatz erforderlich ist. </font><font style="vertical-align: inherit;">Beispiel: Analyse der pro Tag gesammelten Aktienhandelsdaten, um das Risiko für ein bestimmtes Portfolio von Vermögenswerten zu aktualisieren.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst können wir Folgendes beobachten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten Szenario fallen die Verzögerungsanforderungen in den Gefahrenbereich der Garbage Collector-Pausen: 100 ms. </font><font style="vertical-align: inherit;">Dies wird in den schwierigsten Fällen als hervorragendes Ergebnis für die Speicherbereinigung angesehen und kann in vielen Situationen zu einem Stolperstein werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite und dritte Szenario sind hinsichtlich der Anforderungen an die Speicherbereinigung identisch. </font><font style="vertical-align: inherit;">Die Verzögerungsanforderungen sind weniger streng, aber eine große Belastung für fest angestellte Generationen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite Szenario ist aufgrund der Verzögerungsanforderungen schwieriger, auch wenn es nicht so streng ist wie im ersten Szenario.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben folgende Kombinationen ausprobiert:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 8 mit Standard-Parallel-Assembler und optionalem ConcurrentMarkSweep und G1.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 11 mit Standardkollektor G1 und optionalem Parallel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDK 14 mit Standardkollektor G1 und experimentellem ZGC und Shenandoah.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind zu folgenden Schlussfolgerungen gekommen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit modernen Versionen von JDK funktioniert der G1 Builder hervorragend. </font><font style="vertical-align: inherit;">Es verarbeitet problemlos Dutzende von Gigabyte Heap (wir haben 60 GB ausprobiert) mit einer maximalen Pause von 200 ms. </font><font style="vertical-align: inherit;">Unter extremer Last geht G1 nicht in alptraumkritische Modi. </font><font style="vertical-align: inherit;">Stattdessen erhöht sich die Dauer der Pausen für die vollständige Speicherbereinigung auf Sekunden. </font><font style="vertical-align: inherit;">Die Schwachstelle des Kollektors ist die obere Grenze der Pausen bei günstigen Bedingungen geringer Last. </font><font style="vertical-align: inherit;">Wir haben es geschafft, es auf 20-25 ms zu senken.</font></font></li>
<li>JDK 8 —   .    Parallel       .  G1    ,    ,       ,     .       12    20   Parallel     G1. ConcurrentMarkSweep       G1,           .</li>
<li>  ZGC    ,   G1,        ,  G1       10 . </li>
<li>Shenandoah        220    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weder ZGC noch Shenandoah verhielten sich in kritischen Modi so konstant wie G1. </font><font style="vertical-align: inherit;">Ihre Arbeit war unzuverlässig, im Modus mit geringer Latenz traten unerwartet sehr lange Pausen auf, und sogar OOME.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel beschreibt die Ergebnisse unserer Tests in zwei Streaming-Verarbeitungsszenarien. </font><font style="vertical-align: inherit;">Im zweiten Teil werden wir über die Ergebnisse der Stapelverarbeitung sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream-Verarbeitungs-Benchmark</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den Streaming-Benchmark haben wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code zwischen den Tests ein wenig geändert. </font><font style="vertical-align: inherit;">Hier ist der Hauptteil, die Jet-Pipeline:</font></font><br>
<br>
<pre><code class="java hljs">StreamStage&lt;Long&gt; source = p.readFrom(longSource(ITEMS_PER_SECOND))<font></font>
                            .withNativeTimestamps(<span class="hljs-number">0</span>)<font></font>
                            .rebalance(); <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
source.groupingKey(n -&gt; n % NUM_KEYS)<font></font>
      .window(sliding(SECONDS.toMillis(WIN_SIZE_SECONDS), SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .filter(kwr -&gt; kwr.getKey() % DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR == <span class="hljs-number">0</span>)<font></font>
      .window(tumbling(SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .writeTo(Sinks.logger(wr -&gt; String.format(<span class="hljs-string">"time %,d: latency %,d ms, cca. %,d keys"</span>,<font></font>
              simpleTime(wr.end()),<font></font>
              NANOSECONDS.toMillis(System.nanoTime()) - wr.end(),<font></font>
              wr.result() * DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR)));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Pipeline spiegelt Nutzungsszenarien mit einem unbegrenzten Ereignisfluss wider. Die Engine sollte Daten mithilfe der Methode "Schiebefenster" aggregieren. Eine solche Aggregation ist beispielsweise erforderlich, um die zeitliche Ableitung eines sich ändernden Werts zu erhalten, Daten aus hochfrequentem Rauschen zu löschen (Glättung) oder um die Häufigkeit des Auftretens eines Ereignisses (Ereignisse pro Sekunde) zu messen. Die Engine kann den Stream zunächst in Kategorien (z. B. alle einzelnen IoT-Geräte oder Smartphones) in Sub-Streams unterteilen. Verfolgen Sie dann unabhängig den aggregierten Wert für jeden Subflow. In Hazelcast Jet bewegt sich ein Schiebefenster in diskreten Schritten, deren Größe Sie angeben. Mit einem Schritt von 1 Sekunde erhalten Sie beispielsweise jede Sekunde einen vollständigen Satz von Ergebnissen. Und mit einem Schritt von 1 Minute enthalten die Ergebnisse alles, was in der letzten Minute passiert ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Notizen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code ist vollständig in sich geschlossen. Externe Datenquellen werden nicht verwendet. Wir verwenden eine Stub-Quelle, um einen Strom von Ereignissen mit der richtigen Frequenz zu emulieren. Ereignisse treten in regelmäßigen Abständen auf. Die Quelle generiert keine Ereignisse, deren Zeitstempel sich auf die Zukunft beziehen, sondern generiert sie so schnell wie möglich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Pipeline verzögert ist, werden die Ereignisse ohne Speichern „gepuffert“. In diesem Fall sollte die Pipeline so schnell wie möglich aufholen und Daten empfangen. Da unsere Quelle nicht parallelisiert ist, erreichte ihre Bandbreitenbeschränkung etwa 2,2 Millionen Ereignisse pro Sekunde. Wir haben 1 Million Ereignisse / s emuliert und einen Spielraum für das Aufholen von bis zu 1,2 Millionen Ereignissen / s gelassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Förderer misst seine Verzögerung, indem er den Zeitstempel des Ergebnisses des Schiebefensters mit der aktuellen Zeit vergleicht. Es wurden zwei Aggregationsstufen mit Zwischenfiltration verwendet. Das Ergebnis eines Schiebefensters enthält viele Elemente, eines für jeden Teilstrom, und wir sind an der Verzögerung für das letzte der Elemente interessiert. Daher filtern wir zuerst den größten Teil des Ergebnisses heraus und lassen jedes zehntausendste Element übrig. Und dann lenken wir den reduzierten Durchfluss auf die zweite Stufe, mit einem „Flip“ -Fenster ohne Schlüssel. In diesem Stadium notieren wir die Größe des Ergebnisses und messen die Verzögerung. Die Aggregation ohne Verwendung eines Schlüssels ist nicht parallelisiert, daher haben wir einen Messpunkt. Die Filtrationsstufe ist parallelisiert und datenlokal, so dass der Einfluss der zusätzlichen Aggregationsstufe sehr gering ist (viel geringer als 1 ms).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine einfache Aggregatfunktion verwendet: Zählen. Tatsächlich wurde eine Metrik der Häufigkeit von Ereignissen im Strom erhalten. Es hat eine minimale Struktur (eine Typennummer </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), Müll wird nicht generiert. Für jede Menge Heap-Nutzung (in Gigabyte) impliziert eine so kleine Schlüsselstruktur das Worst-Case-Szenario für den Garbage Collector: eine sehr große Anzahl von Objekten. Die Belastung des Kollektors wächst nicht mit der Größe des Heaps, sondern mit der Anzahl der Objekte. Wir haben auch die Option getestet, dieselbe Aggregatfunktion zu berechnen, jedoch mit einer anderen Implementierung, die Müll erzeugt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die meisten Stream-Benchmarks auf einem Knoten durchgeführt, da wir an den Auswirkungen der Speicherverwaltung auf die Pipeline-Leistung interessiert waren. </font><font style="vertical-align: inherit;">Und die Netzwerklatenz fügt den Daten nur Rauschen hinzu. </font><font style="vertical-align: inherit;">Um die Hypothese zu testen, dass die Clusterleistung unsere Ergebnisse nicht beeinflusst, haben wir einige Schlüsseltests an einem Amazon EC2-Cluster mit drei Knoten wiederholt. </font><font style="vertical-align: inherit;">Mehr dazu wird am Ende des zweiten Artikels beschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Parallelkollektor aus den Ergebnissen der Streaming-Last entfernt, da die von ihm erzeugten Verzögerungsspitzen in den meisten realen Szenarien nicht akzeptabel sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenario 1: geringe Latenz, mittlere Struktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skriptoptionen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenJDK 14</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Größe des JVM-Heapspeichers beträgt 4 GB.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für G1 gegeben </font></font><code>-XX:MaxGCPauseMillis=5</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Million Ereignisse / s.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50.000 Einzelschlüssel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 Sekunden Schiebefenster nach 0,1 Sekunden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Szenario wird weniger als 1 GB Heap verwendet. </font><font style="vertical-align: inherit;">Die Belastung des Kollektors ist gering, er hat genug Zeit für eine wettbewerbsfähige Speicherbereinigung im Hintergrund. </font><font style="vertical-align: inherit;">Hier sind die maximalen Verzögerungen beim Betrieb der Pipeline mit drei getesteten Assemblern:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/053/d40/26c/053d4026c6d3eb747e3e78bbdcd46ecd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Werte umfassen feste Intervalle von ungefähr 3 ms für die Übertragung von Fensterergebnissen. </font><font style="vertical-align: inherit;">Die Grafik spricht für sich: Der Standardkollektor G1 leistet hervorragende Arbeit, aber wenn Sie eine noch geringere Verzögerung benötigen, können Sie die experimentelle ZGC verwenden. </font><font style="vertical-align: inherit;">Wir konnten die Verzögerungsspitzen nicht unter 10 ms senken. </font><font style="vertical-align: inherit;">Im Fall von ZGC und Shenandoah entstehen sie jedoch nicht aufgrund von Pausen bei der Müllabfuhr, sondern aufgrund kurzer Zeiträume mit erhöhtem Hintergrundarbeitsvolumen von Sammlern. </font><font style="vertical-align: inherit;">Gelegentlich erhöhten Shenandoah-Serviceprozesse die Verzögerung auf über 200 ms.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenario zwei: größere Struktur, weniger strenge Latenzanforderungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen davon aus, dass sich die Verzögerung aus Gründen, die außerhalb unserer Kontrolle liegen (z. B. aufgrund des Mobilfunknetzes), auf Sekunden erhöhen kann. </font><font style="vertical-align: inherit;">Dies verringert die Anforderungen an die Stream-Verarbeitungspipeline. </font><font style="vertical-align: inherit;">Auf der anderen Seite können wir auf viel größere Daten stoßen, die Millionen oder Dutzende Millionen Schlüssel groß sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Szenario können wir die Geräte für eine starke Beanspruchung vorbereiten, wobei die Tatsache berücksichtigt wird, dass der Garbage Collector in einem großen Heap ausgeführt wird, anstatt Daten auf mehrere Knoten des Clusters zu verteilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben viele Tests in verschiedenen Kombinationen durchgeführt, um herauszufinden, wie sich Kombinationen von Faktoren auf die Leistung der Laufzeit auswirken. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies von zwei Parametern abhängt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der in Aggregaten gespeicherten Datensätze.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bandbreitenbedarf für Make-up.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Parameter beschreibt die Anzahl der Objekte in der dauerhaften Generation. Beim Aggregieren mit der Schiebefenstermethode halten wir Objekte für eine lange Zeit (im gesamten Fenster) und geben sie dann frei. Dies steht in direktem Widerspruch zur Generationsmüllhypothese (Generationsmüllhypothese), nach der Objekte entweder jung sterben oder für immer leben. In diesem Modus wird die maximale Belastung des Garbage Collector erstellt. Und da die Intensität seiner Arbeit mit der Anzahl der lebenden Objekte zunimmt, hängt die Produktivität stark von diesem Parameter ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Parameter bezieht sich darauf, wie viele Ressourcen die Anwendung dem Garbage Collector zuweisen kann. Um es klarer zu machen, erstellen wir einige Diagramme. Bei der Aggregation nach der Schiebefenstermethode durchläuft der Förderer drei Stufen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echtzeit-Ereignisverarbeitung, sobald sie auftritt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übergeben der Ergebnisse eines Schiebefensters.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufholen der Ereignisse, die in der zweiten Phase eingegangen sind.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle drei Stufen können wie folgt visualisiert werden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99c/d77/894/99cd778940f1596c2dd5e1dbf0933fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Übertragung von Fensterergebnissen länger dauert, befinden wir uns in dieser Situation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/694/760/b226947608cfb3373742d02e6dc7774f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt hat der Förderer kaum noch Zeit, und alle Zeitverzögerungen wie Pausen für die Speicherbereinigung erhöhen die Verzögerung und erholen sich sehr langsam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns das Diagramm ändern und nur die durchschnittliche Absorptionsrate von Ereignissen anzeigen, nachdem die Ergebnisse des Fensters übergeben wurden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/cd9/ccb/d78cd9ccbf09b96c23705ae8bb0d6e38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nennen wir die Höhe des gelben Rechtecks ​​„Auferlegungsanforderung“: Dies ist die Anforderung an die Quellkapazität. Wenn es den tatsächlichen Durchsatz des Förderers überschreitet, kann es die Last nicht bewältigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus, wenn das Übertragen von Fensterergebnissen zu lange dauert:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/0ea/594/5b90ea59490f05c628401475c9849e21.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bereich der roten und gelben Rechtecke ist fest und entspricht der Datenmenge, die durch die Pipeline geleitet werden muss. Tatsächlich „drückt“ Rot Gelb. Die Höhe des gelben Rechtecks ​​ist jedoch begrenzt. In unserem Fall beträgt die Obergrenze 2,2 Millionen Ereignisse / s. Und wenn die Höhe den Grenzwert überschreitet, erhalten wir einen Förderer, der die Last nicht bewältigen kann, und eine unbegrenzt wachsende Verzögerung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben Formeln zur Vorhersage der Größe von Rechtecken für eine bestimmte Kombination aus Ereignisfrequenz, Fenstergröße, Schlupfschritt und Schlüsselsatzgröße abgeleitet. So können wir auf jeden Fall das Erfordernis der Auferlegung bestimmen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir zwei mehr oder weniger unabhängige Parameter, die von vielen anderen Parametern abgeleitet sind, die jede einzelne Kombination beschreiben. </font><font style="vertical-align: inherit;">Sie können ein zweidimensionales Diagramm erstellen, auf dem Kreise die verbannten Benchmarks anzeigen. </font><font style="vertical-align: inherit;">Färben Sie die Kreise nach Erfolg oder Misserfolg der Kombination. </font><font style="vertical-align: inherit;">Für eine Reihe von JDK 14 mit G1 auf einem Laptop erhalten wir beispielsweise die folgende Grafik:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab2/9e6/416/ab29e641669a2666c59d506e59fce458.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben drei Kategorien identifiziert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ja" - der Förderer kommt zurecht,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Nein" - die Pipeline kann aufgrund mangelnder Bandbreite nicht bewältigen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Müllsammler“ - der Förderer kommt aufgrund häufiger langer Montagepausen nicht zurecht.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass aufgrund der wettbewerbsfähigen Speicherbereinigung und häufiger kurzer Montagepausen auch ein Mangel an Bandbreite auftreten kann. Im Allgemeinen ist der Unterschied zwischen den letzten beiden Kategorien gering. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können den Rand sehen, der unten links im Diagramm trennt. Es enthält Punkte erfolgreich bestandener Benchmarks. Wir haben das gleiche Diagramm für andere Kombinationen von JDK und Garbage Collector erstellt, die Grenzen der Zonen identifiziert und das folgende Ergebnis erhalten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/d12/394/251d123945208cbed4806928946c4241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir hatten ein MacBook Pro 2018 mit einem 6-Kern Intel Core i7 und 16 GB DDR4 RAM. Für die JVM wurde konfiguriert </font></font><code>-Xmx10g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir glauben jedoch, dass ein ähnliches Bild bei vielen anderen Konfigurationen beobachtet wird. Die Grafik zeigt die Überlegenheit von G1 gegenüber anderen Kollektoren, die Schwäche von G1 bei Verwendung mit JDK 8 und die Schwäche von experimentellen Kollektoren mit geringer Latenz unter dieser Art von Last.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundverzögerung - die Dauer der Übertragung der Fensterergebnisse - schwankte um 500 ms. </font><font style="vertical-align: inherit;">Bursts traten jedoch häufig aufgrund der Hauptpausen für die Müllabfuhr auf (die im Fall von G1 unangemessen lang waren), bis zu 10 s in Grenzsituationen (wenn der Förderer kaum mit der Arbeit fertig wird) und sanken auf 1-2 s. </font><font style="vertical-align: inherit;">Wir haben auch den Effekt der JIT-Kompilierung in Grenzsituationen festgestellt: Die Pipeline beginnt mit immer größerer Verzögerung zu arbeiten, und nach etwa zwei Minuten verbessert sich die Leistung und die Verzögerung kehrt zu normalen Werten zurück.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506696/index.html">Verwalten von PostgreSQL auf Gitlab.com. Jose Cores Finotto</a></li>
<li><a href="../de506698/index.html">Requiem für "Sea Launch"</a></li>
<li><a href="../de506700/index.html">Wir konfigurieren GitHub-Aktionen für Android mit der anschließenden Bereitstellung in PlayMarket</a></li>
<li><a href="../de506702/index.html">Die zuverlässigsten Festplatten nach Backblaze Q1 2020</a></li>
<li><a href="../de506704/index.html">Warum 2020 in PHP schreiben? Holivarim ist diesen Donnerstag ein interaktiver Podcast auf Youtube</a></li>
<li><a href="../de506708/index.html">VPN / Mikrotik Zwei-Faktor-Authentifizierung - einfach und skalierbar</a></li>
<li><a href="../de506710/index.html">Verwalten Sie mehrere Adressbücher in der Open-Source-Edition der Zimbra Collaboration Suite</a></li>
<li><a href="../de506716/index.html">Lineare Multithread-Liste: Elementexistenzproblem, Produktivitätsverbesserung und STL-Beziehung</a></li>
<li><a href="../de506726/index.html">Erfahrung in der Verwendung der Rutoken-Technologie zur Registrierung und Autorisierung von Benutzern im System (Teil 2)</a></li>
<li><a href="../de506730/index.html">Schnauben oder Suricata. Teil 1: Wählen Sie ein kostenloses IDS / IPS, um das Unternehmensnetzwerk zu schützen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>