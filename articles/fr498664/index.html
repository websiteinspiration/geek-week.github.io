<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🍳 🐎 🧕🏿 Interface utilisateur pilotée par le backend avec des widgets 🌨️ ☕️ 🌍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Considérez les caractéristiques de cette approche et notre implémentation à l'aide de widgets, leur concept, leurs avantages et leurs différences par ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Interface utilisateur pilotée par le backend avec des widgets</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/498664/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considérez les caractéristiques de cette approche et notre implémentation à l'aide de widgets, leur concept, leurs avantages et leurs différences par rapport aux autres vues d'Android.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0z/p9/hd/0zp9hdtjfkdd28_s70pm46rqvw0.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interface utilisateur pilotée par le backend - une approche qui vous permet de créer des composants d'interface utilisateur basés sur la réponse du serveur. La description de l'API doit contenir les types de composants et leurs propriétés, et l'application doit afficher les composants nécessaires en fonction des types et des propriétés. En général, la logique des composants peut être définie, et pour une application mobile, il s'agit d'une boîte noire, car chaque composant peut avoir une logique indépendante du reste de l'application et peut être configuré arbitrairement par le serveur, en fonction de la logique métier requise. C'est pourquoi cette approche est souvent utilisée dans les applications bancaires: par exemple, lorsque vous devez afficher un formulaire de traduction avec un grand nombre de champs définis dynamiquement. L'application ne connaît pas à l'avance la composition du formulaire et l'ordre des champs qu'il contient, par conséquent,cette approche est le seul moyen d'écrire du code sans béquilles. De plus, cela ajoute de la flexibilité: du côté serveur, vous pouvez modifier le formulaire à tout moment, et l'application mobile sera prête pour cela.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cas d'utilisation</font></font></h3><br>
<img src="https://habrastorage.org/webt/kd/ao/vw/kdaovw36bkxi3ec-y5ajmidakke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les types de composants suivants sont présentés ci-dessus:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste des comptes disponibles pour le transfert;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nom du type de traduction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ pour entrer un numéro de téléphone (il a un masque pour entrer et contient une icône pour sélectionner les contacts de l'appareil);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ de saisie du montant du virement.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le formulaire également, un certain nombre d'autres composants intégrés dans la logique métier et déterminés au stade de la conception sont possibles. Les informations sur chaque composant qui viennent dans la réponse du serveur doivent répondre aux exigences, et chaque composant doit être attendu par l'application mobile pour son traitement correct. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/3g/hu/j93ghualguxt2lxhch93sraomys.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Différents champs de saisie ont différents masques et règles de validation; le bouton peut avoir une animation chatoyante au démarrage; un widget pour sélectionner un compte de prélèvement peut avoir une animation lors du défilement, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les composants de l'interface utilisateur sont indépendants les uns des autres, et la logique peut être reprise dans des vues distinctes avec différents domaines de responsabilité - appelons-les widgets. Chaque widget reçoit sa configuration dans la réponse du serveur et encapsule la logique d'affichage et de traitement des données.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la mise en œuvre de l'écran, RecyclerView est le mieux adapté, dont les éléments contiendront des widgets. </font><font style="vertical-align: inherit;">Le ViewHolder de chaque élément de liste unique initialisera le widget et lui donnera les données dont il a besoin pour afficher.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concept de widget</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons les widgets plus en détail. </font><font style="vertical-align: inherit;">À sa base, un widget est une vue personnalisée "à vitesse maximale". </font><font style="vertical-align: inherit;">Une vue personnalisée ordinaire peut également contenir des données et la logique de leur affichage, mais le widget implique quelque chose de plus - il a un présentateur, un modèle d'écran et a sa propre portée DI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de plonger dans les détails de l'implémentation des widgets, nous discutons de leurs avantages:</font></font><br>
<br>
<ul>
<li>     ,   ,   «» ,       —     UI-  ,             .</li>
<li>        ,         ,         .</li>
<li>,     —        :  ,      ,    .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour implémenter des widgets évolutifs, nous utilisons les classes de base pour les ViewGroups les plus couramment utilisés, qui ont leurs propres étendues DI. Toutes les classes de base, à leur tour, sont héritées de l'interface commune, qui contient tout le nécessaire pour initialiser les widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cas le plus simple pour utiliser des widgets est les vues statiques, spécifiées directement dans la mise en page. Après avoir implémenté les classes de widgets, vous pouvez l'ajouter en toute sécurité à la disposition XML, sans oublier de spécifier son identifiant dans la disposition (en fonction de l'identifiant, la portée DI d'un widget sera formée). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous considérons les widgets dynamiques plus en détail, car le cas du formulaire de traduction décrit ci-dessus avec un ensemble arbitraire de champs est facilement résolu avec leur aide.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout widget, à la fois statique et dynamique, dans notre implémentation n'est presque pas différent de la vue ordinaire en termes de MVP. </font><font style="vertical-align: inherit;">En règle générale, 4 classes sont nécessaires pour implémenter un widget:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher la classe, où la mise en page et l'affichage du contenu se produisent;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidget</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        context: Context,<font></font>
        attrs: AttributeSet? = <span class="hljs-literal">null</span><font></font>
) : CoreFrameLayoutView(context, attrs) {<font></font>
<span class="hljs-meta">@Inject</span>
<span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> presenter: TextInputFieldPresenter<font></font>
…<font></font>
<span class="hljs-keyword">init</span> {<font></font>
     inflate(context, R.layout.view_field_text_input, <span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe pour le présentateur, où la logique de base du widget est décrite, par exemple:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> charger des données et les transmettre pour un rendu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abonnement à divers événements et émission d'événements de modifications d'entrée de widget;</font></font></li>
</ol><br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@PerScreen</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldPresenter</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        basePresenterDependency: BasePresenterDependency,<font></font>
        rxBus: RxBus<font></font>
) : BaseInputFieldPresenter&lt;TextInputFieldWidget&gt;(<font></font>
       basePresenterDependency, rxBus<font></font>
) {<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TextInputFieldScreenModel()<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre implémentation, la classe RxBus est un bus basé sur PublishSubject pour envoyer des événements et s'y abonner.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe pour le modèle d'écran, à l'aide de laquelle le présentateur reçoit des données et les transfère pour le rendu dans une vue (en termes de modèle de modèle de présentation);</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldScreenModel</span> : <span class="hljs-type">ScreenModel</span></span>() {
	<span class="hljs-keyword">val</span> value = String = “”
	<span class="hljs-keyword">val</span> hint = String = “”
	<span class="hljs-keyword">val</span> errorText = String = “”<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe de configurateur pour implémenter DI, à l'aide de laquelle sont fournies les dépendances pour le widget qui ont la portée souhaitée, et le présentateur est injecté dans sa vue.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidgetConfigurator</span> : <span class="hljs-type">WidgetScreenConfigurator</span></span>() {
	<span class="hljs-comment">// logic for components injection</span><font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seule différence entre les widgets et notre implémentation d'écrans à part entière (Activity, Fragment) est que le widget n'a pas beaucoup de méthodes de cycle de vie (onStart, onResume, onPause). </font><font style="vertical-align: inherit;">Il n'a que la méthode onCreate, qui montre que le widget a actuellement créé sa portée, et le scoop est détruit dans la méthode onDetachedFromWindow. </font><font style="vertical-align: inherit;">Mais pour plus de commodité et de cohérence, le présentateur du widget bénéficie des mêmes méthodes de cycle de vie que les autres écrans. </font><font style="vertical-align: inherit;">Ces événements lui sont automatiquement transmis par le parent. </font><font style="vertical-align: inherit;">Il convient de noter que la classe de base du présentateur de widget est la même classe de base des présentateurs d'autres écrans.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de widgets dynamiques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons à la mise en œuvre du cas décrit au début de l'article.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le présentateur d'écran, les données du formulaire de traduction sont chargées, les données sont transmises à la vue pour le rendu. </font><font style="vertical-align: inherit;">À ce stade, peu importe que la vue de l'écran d'activité soit un fragment ou un widget. </font><font style="vertical-align: inherit;">Nous voulons seulement avoir RecyclerView et rendre un formulaire dynamique avec.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormPresenter</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TransferFormScreenModel()<font></font>
…<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {<font></font>
	loadDataDisposable.dispose()<font></font>
  	loadDataDisposable = subscribe(<font></font>
              observerDataForTransfer().io(), <font></font>
              { <span class="hljs-keyword">data</span> -&gt; <font></font>
                      sm.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span><font></font>
                      view.render(sm)<font></font>
              },<font></font>
              { error -&gt; <span class="hljs-comment">/* error handling */</span> }<font></font>
  	)<font></font>
 }<font></font>
</code></pre><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les données de formulaire sont transférées vers l'adaptateur de liste et rendues à l'aide de widgets qui se trouvent dans le ViewHolder pour chaque élément de formulaire unique. </font><font style="vertical-align: inherit;">Le ViewHolder souhaité pour le rendu du composant est déterminé en fonction de types prédéfinis de composants de formulaire.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormView</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(sm: <span class="hljs-type">TransferFormScreenModel</span>)</span></span> {
    <span class="hljs-comment">//      </span>
    <span class="hljs-comment">//   EasyAdapter [3]</span>
    <span class="hljs-keyword">val</span> list = ItemList.create()
    <span class="hljs-comment">//       Controller,</span>
    <span class="hljs-comment">//       </span><font></font>
<font></font>
    sm.<span class="hljs-keyword">data</span><font></font>
        .filter { transferField -&gt; transferField.visible }<font></font>
        .forEach { transferField -&gt;<font></font>
            <span class="hljs-keyword">when</span> (transferField.type) {<font></font>
                TransferFieldType.PHONE_INPUT -&gt; {<font></font>
                    list.add(<font></font>
                        PhoneInputFieldData(transferField),<font></font>
                        phoneInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.MONEY -&gt; {<font></font>
                    list.add(<font></font>
                        MoneyInputFieldData(transferField),<font></font>
                        moneyInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.BUTTON -&gt; {<font></font>
                    list.add(<font></font>
                        ButtonInputFieldData(transferField),<font></font>
                        buttonController<font></font>
                    )<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> -&gt; {<font></font>
                    list.add(<font></font>
                        TextInputFieldData(transferField),<font></font>
                        textInputController<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-comment">//     RecyclerView</span><font></font>
        adapter.setItems(list)<font></font>
}  <font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le widget est initialisé dans la méthode de liaison de ViewHolder. </font><font style="vertical-align: inherit;">En plus de transmettre des données pour le rendu, il est également important de définir un identifiant unique pour le widget, sur la base duquel sa portée DI sera formée. </font><font style="vertical-align: inherit;">Dans notre cas, chaque élément du formulaire avait un identifiant unique, qui était responsable de la nomination de l'entrée et est venu en réponse en plus du type d'élément (les types peuvent être répétés sur le formulaire).</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ViewHolder</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">TransferFieldUi</span>)</span></span> {
	<span class="hljs-comment">// get initialize params from given data</span><font></font>
	itemView.findViewById(R.id.field_tif).initialize(...)<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode d'initialisation initialise les données de vue de widget, qui sont ensuite transmises au présentateur à l'aide de la méthode de cycle de vie onCreate, où les valeurs de champ sont définies sur le modèle de widget et son rendu.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">(
       id: <span class="hljs-type">String</span> = this.id,
       value: <span class="hljs-type">String</span> = this.value,
       hint: <span class="hljs-type">String</span> = this.hint,
       errorText: <span class="hljs-type">String</span> = this.errorText
)</span></span> {
       <span class="hljs-keyword">this</span>.id = id
       <span class="hljs-keyword">this</span>.value = value
       <span class="hljs-keyword">this</span>.hint = hint
       <span class="hljs-keyword">this</span>.errorText = errorText<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
       presenter.onCreate(value, hint, errorText)<font></font>
       <span class="hljs-comment">// other logic...</span><font></font>
}<font></font>
<span class="hljs-comment">// TextInputFieldPresenter</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, hint: <span class="hljs-type">String</span>, errorText: <span class="hljs-type">String</span>)</span></span> {<font></font>
       sm.value = value<font></font>
       sm.hint = hint<font></font>
       sm.errorText = errorText<font></font>
       view.render(sm)<font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roches sous-marines</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme le montre la description, la mise en œuvre est très simple et intuitive. </font><font style="vertical-align: inherit;">Cependant, certaines nuances doivent être prises en compte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenez compte du cycle de vie des widgets</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que les classes de base des widgets sont les héritiers des ViewGroups couramment utilisés, nous connaissons également le cycle de vie des widgets. </font><font style="vertical-align: inherit;">En règle générale, les widgets sont initialisés dans le ViewHolder en appelant une méthode spéciale où les données sont transférées, comme indiqué dans le paragraphe précédent. </font><font style="vertical-align: inherit;">Une autre initialisation a lieu dans onCreate (par exemple, la définition d'écouteurs de clic) - cette méthode est appelée après onAttachedToWindow à l'aide d'un délégué spécial qui contrôle les entités clés de la logique du widget.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// CoreFrameLayoutView (      ViewGroup)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreFrameLayoutView</span></span><font></font>
          extends FrameLayout implements CoreWidgetViewInterface {<font></font>
…<font></font>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onAttachedToWindow() {
   <span class="hljs-keyword">super</span>.onAttachedToWindow();
   <span class="hljs-keyword">if</span> (!isManualInitEnabled) {<font></font>
        widgetViewDelegate = createWidgetViewDelegate();<font></font>
        widgetViewDelegate.onCreate();<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
    <span class="hljs-comment">//empty. define in descendant class if needed</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WidgetViewDelegate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetViewDelegate</span> </span>{<font></font>
…<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
   <span class="hljs-comment">// other logic of widget initialization</span><font></font>
   coreWidgetView.onCreate();<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nettoyez toujours les auditeurs</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il y a des champs dépendants sur le formulaire, nous pouvons avoir besoin de onDetachedFromWindow. </font><font style="vertical-align: inherit;">Prenons le cas suivant: le formulaire de traduction comporte de nombreux champs, parmi lesquels une liste déroulante. </font><font style="vertical-align: inherit;">Selon la valeur sélectionnée dans la liste, un champ de saisie de formulaire supplémentaire peut devenir visible ou un champ existant peut disparaître.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur déroulante pour choisir le type de traduction</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilité du champ de saisie de la période de paiement</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visibilité du champ de saisie du numéro de téléphone</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfert par numéro de téléphone</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faux</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vrai</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paiement</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vrai</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faux</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas décrit ci-dessus, il est très important d'effacer tous les écouteurs de widget dans la méthode onDetachedFromWindow, car si vous ajoutez à nouveau le widget à la liste, tous les écouteurs seront réinitialisés.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
     initListeners()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> {
      <span class="hljs-keyword">super</span>.onDetachedFromWindow()<font></font>
      clearListeners()<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gérer correctement les abonnements aux événements de widget</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La présentation de l'écran contenant les widgets doit être notifiée des changements dans l'entrée de chaque widget. L'implémentation la plus évidente de chaque widget à l'aide d'émettre des événements et de s'abonner à tous les événements avec un présentateur d'écran. L'événement doit contenir l'identifiant du widget et ses données. Il est préférable de mettre en œuvre cette logique afin que les valeurs d'entrée actuelles soient enregistrées dans le modèle d'écran et lorsque vous cliquez sur le bouton, les données finies sont envoyées dans la demande. Avec cette approche, il est plus facile de mettre en œuvre la validation du formulaire: elle se produit lorsqu'un bouton est cliqué, et s'il n'y a pas eu d'erreurs, la demande est envoyée avec les données du formulaire enregistrées à l'avance.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTextChangedListener = <span class="hljs-keyword">object</span> : OnMaskedValueChangedListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onValueChanged</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {<font></font>
            presenter.onTextChange(value, id)<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Events.kt</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputValueType</span></span>(<span class="hljs-keyword">val</span> id: String)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextValue</span></span>(id: String, <span class="hljs-keyword">val</span> value: String) : InputValueType(id)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataEvent</span></span>(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: InputValueType)<font></font>
<font></font>
<span class="hljs-comment">// TextInputFieldPresenter -  </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChange</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, id: <span class="hljs-type">String</span>)</span></span> {<font></font>
	rxBus.emitEvent(DataEvent(<span class="hljs-keyword">data</span> = TextValue(id = id, value = value)))<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// TransferFormPresenter -  </span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeToEvents</span><span class="hljs-params">()</span></span> {<font></font>
	subscribe(rxBus.observeEvents(DataEvent::<span class="hljs-keyword">class</span>.java))<font></font>
        {<font></font>
            handleValue(it.<span class="hljs-keyword">data</span>) // handle <span class="hljs-keyword">data</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handleValue(value: InputValueType) {
	 <span class="hljs-keyword">val</span> id = value.id
	 <span class="hljs-keyword">when</span> (value) {<font></font>
		 // handle event using its type, saving event value using its id<font></font>
	 	 <span class="hljs-keyword">is</span> TextValue -&gt; {<font></font>
       		 	 sm.fieldValuesMap[id] = value.value<font></font>
       	 	 }<font></font>
		 <span class="hljs-keyword">else</span> -&gt; {<font></font>
			// handle other events<font></font>
		 }<font></font>
 	 }<font></font>
}<font></font>
// TransferScreenModel<font></font>
<span class="hljs-keyword">class</span> TransferScreenModel : ScreenModel() {<font></font>
 	 // map <span class="hljs-keyword">for</span> form values: key = input id
	 <span class="hljs-keyword">val</span> fieldValuesMap: MutableMap&lt;String, String&gt; = mutableMapOf()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une deuxième option de mise en œuvre, dans laquelle les événements des widgets avec leurs données ne surviennent qu'après avoir cliqué sur le bouton, et non au fur et à mesure que vous tapez, c'est-à-dire que nous collectons toutes les données immédiatement avant d'envoyer la demande. </font><font style="vertical-align: inherit;">Avec cette option, il y aura beaucoup moins d'événements, mais il convient de noter que cette implémentation peut s'avérer non triviale dans la pratique, et une logique supplémentaire sera nécessaire pour vérifier si tous les événements ont été reçus.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unifier toutes les exigences</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais une fois de plus noter que le cas décrit n'est possible qu'après coordination des exigences avec le backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelles exigences doivent être unifiées:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Types de champs. </font><font style="vertical-align: inherit;">Chaque champ doit être attendu par l'application mobile pour son affichage et son traitement corrects.</font></font></li>
<li>  —     ,   ,     ,        .</li>
<li>   ,         .</li>
<li> .    ,          : ,    ,     —              ,        -,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/vy/h-/v4/vyh-v4r81dk91ehe3t3j8fgurkq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est nécessaire pour que le composant reçu dans la réponse soit connu de l'application mobile pour l'affichage et le traitement corrects de la logique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxième nuance est que les composants de la forme eux-mêmes sont généralement indépendants les uns des autres, cependant, certains scénarios sont possibles lorsque, par exemple, la visibilité d'un élément dépend de l'état d'un autre, comme décrit ci-dessus. </font><font style="vertical-align: inherit;">Pour implémenter cette logique, il est nécessaire que les éléments dépendants se réunissent toujours, et la réponse doit contenir une description de la logique, quels composants dépendent les uns des autres et comment. </font><font style="vertical-align: inherit;">Et bien sûr, tout cela doit être convenu avec l'équipe du serveur avant de commencer le développement.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, lorsque vous implémentez même un cas standard tel que le remplissage d'une liste dynamique, vous ne pouvez pas toujours vous arrêter aux solutions déjà existantes. </font><font style="vertical-align: inherit;">Pour nous, c'était un nouveau concept, qui nous a permis de sélectionner des éléments atomiques de logique et de représentation à partir d'énormes écrans et nous avons réussi à obtenir une solution extensible de travail qui est facile à maintenir en raison de la similitude des widgets avec d'autres vues. </font><font style="vertical-align: inherit;">Dans notre implémentation, les widgets ont été développés en termes de modèle RxPM - après l'ajout de liants, il est devenu encore plus pratique d'utiliser des widgets, mais c'est une histoire complètement différente.</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens utiles</font></font></b></h4><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cadre de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> développement d'applications Android </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Surf</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module Widget</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémentation de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendu simple de listes complexes</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PrésentationModèle de modèle</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498654/index.html">Qu'est-ce que VPS / VDS et comment l'acheter. L'instruction la plus intelligible</a></li>
<li><a href="../fr498656/index.html">Test de batterie de Crohn</a></li>
<li><a href="../fr498658/index.html">Guide de test de sécurité Web mis à jour par le consortium OWASP</a></li>
<li><a href="../fr498660/index.html">Comment notre tram sans pilote voit la vraie ville</a></li>
<li><a href="../fr498662/index.html">Comment COVID-19 peut-il modifier à jamais les résultats de recherche de Google?</a></li>
<li><a href="../fr498672/index.html">Boutons et leur variété</a></li>
<li><a href="../fr498674/index.html">Tendances de sécurité des produits 2020 Enregistrements vidéo de conférence en ligne</a></li>
<li><a href="../fr498678/index.html">Cartographie au sommet de la montagne et un phonendoscope près de la statue du Christ - comment les projecteurs vous permettent d'exprimer des mots de soutien dans les moments difficiles</a></li>
<li><a href="../fr498688/index.html">Excellent guide de test A / B</a></li>
<li><a href="../fr498692/index.html">Connecteur SIP Telegram + Voximplant = appels vers les téléphones cellulaires et logiciels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>