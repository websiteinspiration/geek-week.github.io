<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüç≥ üêé üßïüèø Interface utilisateur pilot√©e par le backend avec des widgets üå®Ô∏è ‚òïÔ∏è üåç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consid√©rez les caract√©ristiques de cette approche et notre impl√©mentation √† l'aide de widgets, leur concept, leurs avantages et leurs diff√©rences par ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Interface utilisateur pilot√©e par le backend avec des widgets</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/498664/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rez les caract√©ristiques de cette approche et notre impl√©mentation √† l'aide de widgets, leur concept, leurs avantages et leurs diff√©rences par rapport aux autres vues d'Android.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0z/p9/hd/0zp9hdtjfkdd28_s70pm46rqvw0.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interface utilisateur pilot√©e par le backend - une approche qui vous permet de cr√©er des composants d'interface utilisateur bas√©s sur la r√©ponse du serveur. La description de l'API doit contenir les types de composants et leurs propri√©t√©s, et l'application doit afficher les composants n√©cessaires en fonction des types et des propri√©t√©s. En g√©n√©ral, la logique des composants peut √™tre d√©finie, et pour une application mobile, il s'agit d'une bo√Æte noire, car chaque composant peut avoir une logique ind√©pendante du reste de l'application et peut √™tre configur√© arbitrairement par le serveur, en fonction de la logique m√©tier requise. C'est pourquoi cette approche est souvent utilis√©e dans les applications bancaires: par exemple, lorsque vous devez afficher un formulaire de traduction avec un grand nombre de champs d√©finis dynamiquement. L'application ne conna√Æt pas √† l'avance la composition du formulaire et l'ordre des champs qu'il contient, par cons√©quent,cette approche est le seul moyen d'√©crire du code sans b√©quilles. De plus, cela ajoute de la flexibilit√©: du c√¥t√© serveur, vous pouvez modifier le formulaire √† tout moment, et l'application mobile sera pr√™te pour cela.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cas d'utilisation</font></font></h3><br>
<img src="https://habrastorage.org/webt/kd/ao/vw/kdaovw36bkxi3ec-y5ajmidakke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les types de composants suivants sont pr√©sent√©s ci-dessus:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste des comptes disponibles pour le transfert;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nom du type de traduction;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ pour entrer un num√©ro de t√©l√©phone (il a un masque pour entrer et contient une ic√¥ne pour s√©lectionner les contacts de l'appareil);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ de saisie du montant du virement.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le formulaire √©galement, un certain nombre d'autres composants int√©gr√©s dans la logique m√©tier et d√©termin√©s au stade de la conception sont possibles. Les informations sur chaque composant qui viennent dans la r√©ponse du serveur doivent r√©pondre aux exigences, et chaque composant doit √™tre attendu par l'application mobile pour son traitement correct. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/3g/hu/j93ghualguxt2lxhch93sraomys.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diff√©rents champs de saisie ont diff√©rents masques et r√®gles de validation; le bouton peut avoir une animation chatoyante au d√©marrage; un widget pour s√©lectionner un compte de pr√©l√®vement peut avoir une animation lors du d√©filement, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les composants de l'interface utilisateur sont ind√©pendants les uns des autres, et la logique peut √™tre reprise dans des vues distinctes avec diff√©rents domaines de responsabilit√© - appelons-les widgets. Chaque widget re√ßoit sa configuration dans la r√©ponse du serveur et encapsule la logique d'affichage et de traitement des donn√©es.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la mise en ≈ìuvre de l'√©cran, RecyclerView est le mieux adapt√©, dont les √©l√©ments contiendront des widgets. </font><font style="vertical-align: inherit;">Le ViewHolder de chaque √©l√©ment de liste unique initialisera le widget et lui donnera les donn√©es dont il a besoin pour afficher.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concept de widget</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons les widgets plus en d√©tail. </font><font style="vertical-align: inherit;">√Ä sa base, un widget est une vue personnalis√©e "√† vitesse maximale". </font><font style="vertical-align: inherit;">Une vue personnalis√©e ordinaire peut √©galement contenir des donn√©es et la logique de leur affichage, mais le widget implique quelque chose de plus - il a un pr√©sentateur, un mod√®le d'√©cran et a sa propre port√©e DI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de plonger dans les d√©tails de l'impl√©mentation des widgets, nous discutons de leurs avantages:</font></font><br>
<br>
<ul>
<li>     ,   ,   ¬´¬ª ,       ‚Äî     UI-  ,             .</li>
<li>        ,         ,         .</li>
<li>,     ‚Äî        :  ,      ,    .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour impl√©menter des widgets √©volutifs, nous utilisons les classes de base pour les ViewGroups les plus couramment utilis√©s, qui ont leurs propres √©tendues DI. Toutes les classes de base, √† leur tour, sont h√©rit√©es de l'interface commune, qui contient tout le n√©cessaire pour initialiser les widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cas le plus simple pour utiliser des widgets est les vues statiques, sp√©cifi√©es directement dans la mise en page. Apr√®s avoir impl√©ment√© les classes de widgets, vous pouvez l'ajouter en toute s√©curit√© √† la disposition XML, sans oublier de sp√©cifier son identifiant dans la disposition (en fonction de l'identifiant, la port√©e DI d'un widget sera form√©e). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous consid√©rons les widgets dynamiques plus en d√©tail, car le cas du formulaire de traduction d√©crit ci-dessus avec un ensemble arbitraire de champs est facilement r√©solu avec leur aide.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout widget, √† la fois statique et dynamique, dans notre impl√©mentation n'est presque pas diff√©rent de la vue ordinaire en termes de MVP. </font><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, 4 classes sont n√©cessaires pour impl√©menter un widget:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher la classe, o√π la mise en page et l'affichage du contenu se produisent;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidget</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        context: Context,<font></font>
        attrs: AttributeSet? = <span class="hljs-literal">null</span><font></font>
) : CoreFrameLayoutView(context, attrs) {<font></font>
<span class="hljs-meta">@Inject</span>
<span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> presenter: TextInputFieldPresenter<font></font>
‚Ä¶<font></font>
<span class="hljs-keyword">init</span> {<font></font>
     inflate(context, R.layout.view_field_text_input, <span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe pour le pr√©sentateur, o√π la logique de base du widget est d√©crite, par exemple:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> charger des donn√©es et les transmettre pour un rendu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abonnement √† divers √©v√©nements et √©mission d'√©v√©nements de modifications d'entr√©e de widget;</font></font></li>
</ol><br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@PerScreen</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldPresenter</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        basePresenterDependency: BasePresenterDependency,<font></font>
        rxBus: RxBus<font></font>
) : BaseInputFieldPresenter&lt;TextInputFieldWidget&gt;(<font></font>
       basePresenterDependency, rxBus<font></font>
) {<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TextInputFieldScreenModel()<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre impl√©mentation, la classe RxBus est un bus bas√© sur PublishSubject pour envoyer des √©v√©nements et s'y abonner.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe pour le mod√®le d'√©cran, √† l'aide de laquelle le pr√©sentateur re√ßoit des donn√©es et les transf√®re pour le rendu dans une vue (en termes de mod√®le de mod√®le de pr√©sentation);</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldScreenModel</span> : <span class="hljs-type">ScreenModel</span></span>() {
	<span class="hljs-keyword">val</span> value = String = ‚Äú‚Äù
	<span class="hljs-keyword">val</span> hint = String = ‚Äú‚Äù
	<span class="hljs-keyword">val</span> errorText = String = ‚Äú‚Äù<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe de configurateur pour impl√©menter DI, √† l'aide de laquelle sont fournies les d√©pendances pour le widget qui ont la port√©e souhait√©e, et le pr√©sentateur est inject√© dans sa vue.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidgetConfigurator</span> : <span class="hljs-type">WidgetScreenConfigurator</span></span>() {
	<span class="hljs-comment">// logic for components injection</span><font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seule diff√©rence entre les widgets et notre impl√©mentation d'√©crans √† part enti√®re (Activity, Fragment) est que le widget n'a pas beaucoup de m√©thodes de cycle de vie (onStart, onResume, onPause). </font><font style="vertical-align: inherit;">Il n'a que la m√©thode onCreate, qui montre que le widget a actuellement cr√©√© sa port√©e, et le scoop est d√©truit dans la m√©thode onDetachedFromWindow. </font><font style="vertical-align: inherit;">Mais pour plus de commodit√© et de coh√©rence, le pr√©sentateur du widget b√©n√©ficie des m√™mes m√©thodes de cycle de vie que les autres √©crans. </font><font style="vertical-align: inherit;">Ces √©v√©nements lui sont automatiquement transmis par le parent. </font><font style="vertical-align: inherit;">Il convient de noter que la classe de base du pr√©sentateur de widget est la m√™me classe de base des pr√©sentateurs d'autres √©crans.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de widgets dynamiques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons √† la mise en ≈ìuvre du cas d√©crit au d√©but de l'article.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le pr√©sentateur d'√©cran, les donn√©es du formulaire de traduction sont charg√©es, les donn√©es sont transmises √† la vue pour le rendu. </font><font style="vertical-align: inherit;">√Ä ce stade, peu importe que la vue de l'√©cran d'activit√© soit un fragment ou un widget. </font><font style="vertical-align: inherit;">Nous voulons seulement avoir RecyclerView et rendre un formulaire dynamique avec.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormPresenter</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TransferFormScreenModel()<font></font>
‚Ä¶<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {<font></font>
	loadDataDisposable.dispose()<font></font>
  	loadDataDisposable = subscribe(<font></font>
              observerDataForTransfer().io(), <font></font>
              { <span class="hljs-keyword">data</span> -&gt; <font></font>
                      sm.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span><font></font>
                      view.render(sm)<font></font>
              },<font></font>
              { error -&gt; <span class="hljs-comment">/* error handling */</span> }<font></font>
  	)<font></font>
 }<font></font>
</code></pre><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les donn√©es de formulaire sont transf√©r√©es vers l'adaptateur de liste et rendues √† l'aide de widgets qui se trouvent dans le ViewHolder pour chaque √©l√©ment de formulaire unique. </font><font style="vertical-align: inherit;">Le ViewHolder souhait√© pour le rendu du composant est d√©termin√© en fonction de types pr√©d√©finis de composants de formulaire.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormView</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(sm: <span class="hljs-type">TransferFormScreenModel</span>)</span></span> {
    <span class="hljs-comment">//      </span>
    <span class="hljs-comment">//   EasyAdapter [3]</span>
    <span class="hljs-keyword">val</span> list = ItemList.create()
    <span class="hljs-comment">//       Controller,</span>
    <span class="hljs-comment">//       </span><font></font>
<font></font>
    sm.<span class="hljs-keyword">data</span><font></font>
        .filter { transferField -&gt; transferField.visible }<font></font>
        .forEach { transferField -&gt;<font></font>
            <span class="hljs-keyword">when</span> (transferField.type) {<font></font>
                TransferFieldType.PHONE_INPUT -&gt; {<font></font>
                    list.add(<font></font>
                        PhoneInputFieldData(transferField),<font></font>
                        phoneInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.MONEY -&gt; {<font></font>
                    list.add(<font></font>
                        MoneyInputFieldData(transferField),<font></font>
                        moneyInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.BUTTON -&gt; {<font></font>
                    list.add(<font></font>
                        ButtonInputFieldData(transferField),<font></font>
                        buttonController<font></font>
                    )<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> -&gt; {<font></font>
                    list.add(<font></font>
                        TextInputFieldData(transferField),<font></font>
                        textInputController<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-comment">//     RecyclerView</span><font></font>
        adapter.setItems(list)<font></font>
}  <font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le widget est initialis√© dans la m√©thode de liaison de ViewHolder. </font><font style="vertical-align: inherit;">En plus de transmettre des donn√©es pour le rendu, il est √©galement important de d√©finir un identifiant unique pour le widget, sur la base duquel sa port√©e DI sera form√©e. </font><font style="vertical-align: inherit;">Dans notre cas, chaque √©l√©ment du formulaire avait un identifiant unique, qui √©tait responsable de la nomination de l'entr√©e et est venu en r√©ponse en plus du type d'√©l√©ment (les types peuvent √™tre r√©p√©t√©s sur le formulaire).</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ViewHolder</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">TransferFieldUi</span>)</span></span> {
	<span class="hljs-comment">// get initialize params from given data</span><font></font>
	itemView.findViewById(R.id.field_tif).initialize(...)<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode d'initialisation initialise les donn√©es de vue de widget, qui sont ensuite transmises au pr√©sentateur √† l'aide de la m√©thode de cycle de vie onCreate, o√π les valeurs de champ sont d√©finies sur le mod√®le de widget et son rendu.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">(
       id: <span class="hljs-type">String</span> = this.id,
       value: <span class="hljs-type">String</span> = this.value,
       hint: <span class="hljs-type">String</span> = this.hint,
       errorText: <span class="hljs-type">String</span> = this.errorText
)</span></span> {
       <span class="hljs-keyword">this</span>.id = id
       <span class="hljs-keyword">this</span>.value = value
       <span class="hljs-keyword">this</span>.hint = hint
       <span class="hljs-keyword">this</span>.errorText = errorText<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
       presenter.onCreate(value, hint, errorText)<font></font>
       <span class="hljs-comment">// other logic...</span><font></font>
}<font></font>
<span class="hljs-comment">// TextInputFieldPresenter</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, hint: <span class="hljs-type">String</span>, errorText: <span class="hljs-type">String</span>)</span></span> {<font></font>
       sm.value = value<font></font>
       sm.hint = hint<font></font>
       sm.errorText = errorText<font></font>
       view.render(sm)<font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roches sous-marines</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme le montre la description, la mise en ≈ìuvre est tr√®s simple et intuitive. </font><font style="vertical-align: inherit;">Cependant, certaines nuances doivent √™tre prises en compte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenez compte du cycle de vie des widgets</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que les classes de base des widgets sont les h√©ritiers des ViewGroups couramment utilis√©s, nous connaissons √©galement le cycle de vie des widgets. </font><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, les widgets sont initialis√©s dans le ViewHolder en appelant une m√©thode sp√©ciale o√π les donn√©es sont transf√©r√©es, comme indiqu√© dans le paragraphe pr√©c√©dent. </font><font style="vertical-align: inherit;">Une autre initialisation a lieu dans onCreate (par exemple, la d√©finition d'√©couteurs de clic) - cette m√©thode est appel√©e apr√®s onAttachedToWindow √† l'aide d'un d√©l√©gu√© sp√©cial qui contr√¥le les entit√©s cl√©s de la logique du widget.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// CoreFrameLayoutView (      ViewGroup)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreFrameLayoutView</span></span><font></font>
          extends FrameLayout implements CoreWidgetViewInterface {<font></font>
‚Ä¶<font></font>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onAttachedToWindow() {
   <span class="hljs-keyword">super</span>.onAttachedToWindow();
   <span class="hljs-keyword">if</span> (!isManualInitEnabled) {<font></font>
        widgetViewDelegate = createWidgetViewDelegate();<font></font>
        widgetViewDelegate.onCreate();<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
    <span class="hljs-comment">//empty. define in descendant class if needed</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WidgetViewDelegate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetViewDelegate</span> </span>{<font></font>
‚Ä¶<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
   <span class="hljs-comment">// other logic of widget initialization</span><font></font>
   coreWidgetView.onCreate();<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nettoyez toujours les auditeurs</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il y a des champs d√©pendants sur le formulaire, nous pouvons avoir besoin de onDetachedFromWindow. </font><font style="vertical-align: inherit;">Prenons le cas suivant: le formulaire de traduction comporte de nombreux champs, parmi lesquels une liste d√©roulante. </font><font style="vertical-align: inherit;">Selon la valeur s√©lectionn√©e dans la liste, un champ de saisie de formulaire suppl√©mentaire peut devenir visible ou un champ existant peut dispara√Ætre.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur d√©roulante pour choisir le type de traduction</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilit√© du champ de saisie de la p√©riode de paiement</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visibilit√© du champ de saisie du num√©ro de t√©l√©phone</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfert par num√©ro de t√©l√©phone</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faux</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vrai</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paiement</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vrai</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faux</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas d√©crit ci-dessus, il est tr√®s important d'effacer tous les √©couteurs de widget dans la m√©thode onDetachedFromWindow, car si vous ajoutez √† nouveau le widget √† la liste, tous les √©couteurs seront r√©initialis√©s.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
     initListeners()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> {
      <span class="hljs-keyword">super</span>.onDetachedFromWindow()<font></font>
      clearListeners()<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G√©rer correctement les abonnements aux √©v√©nements de widget</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La pr√©sentation de l'√©cran contenant les widgets doit √™tre notifi√©e des changements dans l'entr√©e de chaque widget. L'impl√©mentation la plus √©vidente de chaque widget √† l'aide d'√©mettre des √©v√©nements et de s'abonner √† tous les √©v√©nements avec un pr√©sentateur d'√©cran. L'√©v√©nement doit contenir l'identifiant du widget et ses donn√©es. Il est pr√©f√©rable de mettre en ≈ìuvre cette logique afin que les valeurs d'entr√©e actuelles soient enregistr√©es dans le mod√®le d'√©cran et lorsque vous cliquez sur le bouton, les donn√©es finies sont envoy√©es dans la demande. Avec cette approche, il est plus facile de mettre en ≈ìuvre la validation du formulaire: elle se produit lorsqu'un bouton est cliqu√©, et s'il n'y a pas eu d'erreurs, la demande est envoy√©e avec les donn√©es du formulaire enregistr√©es √† l'avance.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTextChangedListener = <span class="hljs-keyword">object</span> : OnMaskedValueChangedListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onValueChanged</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {<font></font>
            presenter.onTextChange(value, id)<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Events.kt</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputValueType</span></span>(<span class="hljs-keyword">val</span> id: String)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextValue</span></span>(id: String, <span class="hljs-keyword">val</span> value: String) : InputValueType(id)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataEvent</span></span>(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: InputValueType)<font></font>
<font></font>
<span class="hljs-comment">// TextInputFieldPresenter -  </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChange</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, id: <span class="hljs-type">String</span>)</span></span> {<font></font>
	rxBus.emitEvent(DataEvent(<span class="hljs-keyword">data</span> = TextValue(id = id, value = value)))<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// TransferFormPresenter -  </span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeToEvents</span><span class="hljs-params">()</span></span> {<font></font>
	subscribe(rxBus.observeEvents(DataEvent::<span class="hljs-keyword">class</span>.java))<font></font>
        {<font></font>
            handleValue(it.<span class="hljs-keyword">data</span>) // handle <span class="hljs-keyword">data</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handleValue(value: InputValueType) {
	 <span class="hljs-keyword">val</span> id = value.id
	 <span class="hljs-keyword">when</span> (value) {<font></font>
		 // handle event using its type, saving event value using its id<font></font>
	 	 <span class="hljs-keyword">is</span> TextValue -&gt; {<font></font>
       		 	 sm.fieldValuesMap[id] = value.value<font></font>
       	 	 }<font></font>
		 <span class="hljs-keyword">else</span> -&gt; {<font></font>
			// handle other events<font></font>
		 }<font></font>
 	 }<font></font>
}<font></font>
// TransferScreenModel<font></font>
<span class="hljs-keyword">class</span> TransferScreenModel : ScreenModel() {<font></font>
 	 // map <span class="hljs-keyword">for</span> form values: key = input id
	 <span class="hljs-keyword">val</span> fieldValuesMap: MutableMap&lt;String, String&gt; = mutableMapOf()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une deuxi√®me option de mise en ≈ìuvre, dans laquelle les √©v√©nements des widgets avec leurs donn√©es ne surviennent qu'apr√®s avoir cliqu√© sur le bouton, et non au fur et √† mesure que vous tapez, c'est-√†-dire que nous collectons toutes les donn√©es imm√©diatement avant d'envoyer la demande. </font><font style="vertical-align: inherit;">Avec cette option, il y aura beaucoup moins d'√©v√©nements, mais il convient de noter que cette impl√©mentation peut s'av√©rer non triviale dans la pratique, et une logique suppl√©mentaire sera n√©cessaire pour v√©rifier si tous les √©v√©nements ont √©t√© re√ßus.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unifier toutes les exigences</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais une fois de plus noter que le cas d√©crit n'est possible qu'apr√®s coordination des exigences avec le backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelles exigences doivent √™tre unifi√©es:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Types de champs. </font><font style="vertical-align: inherit;">Chaque champ doit √™tre attendu par l'application mobile pour son affichage et son traitement corrects.</font></font></li>
<li>  ‚Äî     ,   ,     ,        .</li>
<li>   ,         .</li>
<li> .    ,          : ,    ,     ‚Äî              ,        -,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/vy/h-/v4/vyh-v4r81dk91ehe3t3j8fgurkq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est n√©cessaire pour que le composant re√ßu dans la r√©ponse soit connu de l'application mobile pour l'affichage et le traitement corrects de la logique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxi√®me nuance est que les composants de la forme eux-m√™mes sont g√©n√©ralement ind√©pendants les uns des autres, cependant, certains sc√©narios sont possibles lorsque, par exemple, la visibilit√© d'un √©l√©ment d√©pend de l'√©tat d'un autre, comme d√©crit ci-dessus. </font><font style="vertical-align: inherit;">Pour impl√©menter cette logique, il est n√©cessaire que les √©l√©ments d√©pendants se r√©unissent toujours, et la r√©ponse doit contenir une description de la logique, quels composants d√©pendent les uns des autres et comment. </font><font style="vertical-align: inherit;">Et bien s√ªr, tout cela doit √™tre convenu avec l'√©quipe du serveur avant de commencer le d√©veloppement.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, lorsque vous impl√©mentez m√™me un cas standard tel que le remplissage d'une liste dynamique, vous ne pouvez pas toujours vous arr√™ter aux solutions d√©j√† existantes. </font><font style="vertical-align: inherit;">Pour nous, c'√©tait un nouveau concept, qui nous a permis de s√©lectionner des √©l√©ments atomiques de logique et de repr√©sentation √† partir d'√©normes √©crans et nous avons r√©ussi √† obtenir une solution extensible de travail qui est facile √† maintenir en raison de la similitude des widgets avec d'autres vues. </font><font style="vertical-align: inherit;">Dans notre impl√©mentation, les widgets ont √©t√© d√©velopp√©s en termes de mod√®le RxPM - apr√®s l'ajout de liants, il est devenu encore plus pratique d'utiliser des widgets, mais c'est une histoire compl√®tement diff√©rente.</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens utiles</font></font></b></h4><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cadre de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©veloppement d'applications Android </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Surf</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module Widget</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl√©mentation de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendu simple de listes complexes</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√©sentationMod√®le de mod√®le</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498654/index.html">Qu'est-ce que VPS / VDS et comment l'acheter. L'instruction la plus intelligible</a></li>
<li><a href="../fr498656/index.html">Test de batterie de Crohn</a></li>
<li><a href="../fr498658/index.html">Guide de test de s√©curit√© Web mis √† jour par le consortium OWASP</a></li>
<li><a href="../fr498660/index.html">Comment notre tram sans pilote voit la vraie ville</a></li>
<li><a href="../fr498662/index.html">Comment COVID-19 peut-il modifier √† jamais les r√©sultats de recherche de Google?</a></li>
<li><a href="../fr498672/index.html">Boutons et leur vari√©t√©</a></li>
<li><a href="../fr498674/index.html">Tendances de s√©curit√© des produits 2020 Enregistrements vid√©o de conf√©rence en ligne</a></li>
<li><a href="../fr498678/index.html">Cartographie au sommet de la montagne et un phonendoscope pr√®s de la statue du Christ - comment les projecteurs vous permettent d'exprimer des mots de soutien dans les moments difficiles</a></li>
<li><a href="../fr498688/index.html">Excellent guide de test A / B</a></li>
<li><a href="../fr498692/index.html">Connecteur SIP Telegram + Voximplant = appels vers les t√©l√©phones cellulaires et logiciels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>