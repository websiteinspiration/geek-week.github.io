<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏾 🗼 🤶 Pemrograman GPU di Jawa 🍨 🚓 👩🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengakses GPU dari Jawa menunjukkan kekuatan yang luar biasa. Ini menjelaskan cara kerja GPU dan cara mengakses dari Java. 
 
 Pemrograman GPU adalah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pemrograman GPU di Jawa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengakses GPU dari Jawa menunjukkan kekuatan yang luar biasa. </font><font style="vertical-align: inherit;">Ini menjelaskan cara kerja GPU dan cara mengakses dari Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemrograman GPU adalah dunia yang sangat tinggi bagi programmer Java. </font><font style="vertical-align: inherit;">Ini dapat dimengerti karena tugas-tugas Java yang normal tidak cocok untuk GPU. </font><font style="vertical-align: inherit;">Namun, GPU memiliki kinerja teraflops, jadi mari kita jelajahi kemampuan mereka. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membuat topik ini dapat diakses, saya akan meluangkan waktu menjelaskan arsitektur GPU bersama dengan sedikit sejarah yang akan memfasilitasi perendaman dalam pemrograman besi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah saya ditunjukkan perbedaan antara komputasi GPU dan CPU, saya akan menunjukkan cara menggunakan GPU di dunia Java. </font><font style="vertical-align: inherit;">Akhirnya, saya akan menjelaskan kerangka kerja utama dan perpustakaan yang tersedia untuk menulis kode Java dan menjalankannya pada GPU, dan saya akan memberikan beberapa contoh kode.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit latar belakang</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU pertama kali dipopulerkan oleh NVIDIA pada tahun 1999. Ini adalah prosesor khusus yang dirancang untuk memproses data grafik sebelum dipindahkan ke layar. </font><font style="vertical-align: inherit;">Dalam banyak kasus, ini memungkinkan beberapa perhitungan untuk membongkar CPU, sehingga membebaskan sumber daya CPU yang mempercepat perhitungan yang tidak dimuat ini. </font><font style="vertical-align: inherit;">Hasilnya adalah input besar dapat diproses dan disajikan pada resolusi output yang lebih tinggi, menjadikan presentasi visual lebih menarik dan laju bingkai lebih halus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inti dari pemrosesan 2D / 3D terutama dalam manipulasi matriks, ini dapat dikontrol menggunakan pendekatan terdistribusi. </font><font style="vertical-align: inherit;">Apa yang akan menjadi pendekatan yang efektif untuk pemrosesan gambar? </font><font style="vertical-align: inherit;">Untuk menjawab ini, mari kita bandingkan arsitektur CPU standar (ditunjukkan pada Gambar 1.) dan GPU.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d6c/58e/c4c/d6c58ec4ccbec78f237d58a822f9ab92.jpg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 1. Blok Arsitektur CPU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dalam CPU, elemen pemrosesan aktual - register, unit logika aritmatika (ALU), dan konteks eksekusi - hanyalah sebagian kecil dari keseluruhan sistem. Untuk mempercepat pembayaran tidak beraturan yang datang dalam urutan yang tidak dapat diprediksi, ada cache yang besar, cepat, dan mahal; berbagai jenis kolektor; dan prediktor cabang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda tidak memerlukan semua ini pada GPU, karena data diterima dengan cara yang dapat diprediksi, dan GPU melakukan serangkaian operasi yang sangat terbatas pada data. Dengan demikian, dimungkinkan untuk membuatnya sangat kecil dan prosesor yang murah dengan arsitektur blok yang mirip dengan ini ditunjukkan pada Gambar. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/365/425/84c/36542584c2d34d817c48ca2cd0e8d433.jpg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 2. Blok arsitektur untuk inti GPU sederhana</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena prosesor tersebut lebih murah dan data yang diproses di dalamnya dalam potongan paralel, mudah untuk membuat banyak dari mereka bekerja secara paralel. Ini dirancang dengan mengacu pada beberapa instruksi, banyak data atau MIMD (diucapkan "mim-dee"). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan kedua didasarkan pada fakta bahwa seringkali sebuah instruksi tunggal diterapkan pada beberapa bagian data. Ini dikenal sebagai instruksi tunggal, banyak data atau SIMD (diucapkan “sim-dee”). Dalam desain ini, satu GPU berisi beberapa ALU dan konteks eksekusi, area kecil yang ditransfer ke data konteks bersama, seperti yang ditunjukkan pada Gambar 3. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/453/4cb/013/4534cb0135c6c5c3075594787c3266c6.jpg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 3. Perbandingan arsitektur gaya-MIMD dari blok GPU (dari kiri), dengan desain SIMD (dari kanan)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memadukan pemrosesan SIMD dan MIMD memberikan bandwidth maksimum yang akan saya bypass. </font><font style="vertical-align: inherit;">Dalam desain ini, Anda memiliki beberapa prosesor SIMD yang berjalan secara paralel, seperti pada Gambar </font><font style="vertical-align: inherit;">4. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d81/fc5/f10/d81fc5f10ab5cf27584669ab846b9836.jpg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. </font><font style="vertical-align: inherit;">4. Bekerja beberapa prosesor SIMD secara paralel; </font><font style="vertical-align: inherit;">ada 16 core dengan 128 ALU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Karena Anda memiliki banyak prosesor kecil dan sederhana, Anda dapat memprogramnya untuk mendapatkan efek khusus dalam output.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menjalankan program pada GPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar efek grafis awal dalam game adalah program kecil yang benar-benar dikodekan yang berjalan pada GPU dan diterapkan pada aliran data dari CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini jelas, bahkan ketika algoritma hard-code tidak mencukupi, terutama dalam desain game, di mana efek visual adalah salah satu arahan magis utama. Sebagai tanggapan, penjual besar membuka akses ke GPU, dan kemudian pengembang pihak ketiga dapat memprogram mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan tipikal adalah menulis program kecil yang disebut shader dalam bahasa khusus (biasanya subspesies C) dan mengompilasinya menggunakan kompiler khusus untuk arsitektur yang diinginkan. </font><font style="vertical-align: inherit;">Istilah shader dipilih karena shader sering digunakan untuk mengontrol efek cahaya dan bayangan, tetapi ini tidak berarti bahwa mereka dapat mengontrol efek khusus lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap vendor GPU memiliki bahasa pemrograman dan infrastruktur sendiri untuk membuat shader untuk arsitektur mereka. </font><font style="vertical-align: inherit;">Pada pendekatan ini, banyak platform telah dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang utama adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectCompute: Bahasa Microsoft Shader / API pribadi yang merupakan bagian dari Direct3D, dimulai dengan DirectX 10.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD FireStream: Teknologi ATI / Radeon pribadi yang sudah usang oleh AMD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenACC: Konsorsium Multi-Vendor, Solusi Komputasi Paralel</font></font></li>
<li>++ AMP:   Microsoft     C++</li>
<li>CUDA:   Nvidia,     </li>
<li>OpenL:  ,   Apple,      Khronos Group</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar waktu, bekerja dengan GPU adalah pemrograman tingkat rendah. </font><font style="vertical-align: inherit;">Untuk membuat ini sedikit lebih dimengerti bagi pengembang, untuk pengkodean, beberapa abstraksi disediakan. </font><font style="vertical-align: inherit;">Yang paling terkenal adalah DirectX, dari Microsoft, dan OpenGL, dari Khronos Group. </font><font style="vertical-align: inherit;">Ini adalah API untuk menulis kode tingkat tinggi, yang kemudian dapat disederhanakan untuk GPU, lebih semantik, untuk programmer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh yang saya tahu, tidak ada infrastruktur Java untuk DirectX, tetapi ada solusi yang baik untuk OpenGL. </font><font style="vertical-align: inherit;">JSR 231 dimulai pada tahun 2002 dan ditujukan kepada pemrogram GPU, tetapi ditinggalkan pada tahun 2008 dan hanya mendukung OpenGL 2.0.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dukungan OpenGL berlanjut dalam proyek JOCL independen (yang juga mendukung OpenCL) dan tersedia untuk audiens. </font><font style="vertical-align: inherit;">Dengan demikian, game Minecraft yang terkenal ditulis menggunakan JOCL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPGPU datang</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh ini, Java dan GPU tidak memiliki kesamaan, meskipun mereka seharusnya. </font><font style="vertical-align: inherit;">Java sering digunakan dalam perusahaan, dalam ilmu data, dan di sektor keuangan, di mana ada banyak komputasi dan di mana banyak daya komputasi dibutuhkan. </font><font style="vertical-align: inherit;">Beginilah ide GPU tujuan umum (GPGPU). </font><font style="vertical-align: inherit;">Gagasan menggunakan GPU di sepanjang jalur ini dimulai ketika produsen adapter video mulai memberikan akses ke buffer bingkai program, yang memungkinkan pengembang membaca konten. </font><font style="vertical-align: inherit;">Beberapa peretas telah menentukan bahwa mereka dapat menggunakan kekuatan penuh GPU untuk komputasi universal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resepnya seperti ini:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyandikan data sebagai array raster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulis shader untuk menanganinya.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kirim keduanya ke kartu grafis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapatkan hasil dari frame buffer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decode data dari array raster.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah penjelasan yang sangat sederhana. Saya tidak yakin apakah ini akan berhasil dalam produksi, tetapi itu benar-benar berfungsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, banyak penelitian dari Stanford Institute mulai menyederhanakan penggunaan GPU. Pada tahun 2005, mereka membuat BrookGPU, yang merupakan ekosistem kecil yang mencakup bahasa pemrograman, kompiler, dan runtime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BrookGPU mengkompilasi program yang ditulis dalam bahasa pemrograman thread Brook, yang merupakan varian ANSI C. Ini dapat menargetkan OpenGL v1.3 +, DirectX v9 + atau AMD Close to Metal untuk bagian komputasi server, dan dijalankan pada Microsoft Windows dan Linux. Untuk debugging, BrookGPU juga dapat mensimulasikan kartu grafis virtual pada CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, ini tidak lepas landas, karena peralatan yang tersedia saat itu. Di dunia GPGPU, Anda perlu menyalin data ke perangkat (dalam konteks ini, perangkat mengacu pada GPU dan perangkat di mana ia berada), tunggu GPU untuk menghitung data, dan kemudian salin kembali data ke program kontrol. Ini menciptakan banyak penundaan. Dan pada pertengahan 2000-an, ketika proyek sedang dalam pengembangan aktif, keterlambatan ini juga mengecualikan penggunaan intensif GPU untuk komputasi dasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, banyak perusahaan telah melihat masa depan dalam teknologi ini. Beberapa pengembang adapter video mulai memberikan GPGPU dengan teknologi eksklusif mereka, dan aliansi yang dibentuk lainnya menyediakan model pemrograman yang kurang mendasar dan serbaguna yang bekerja pada sejumlah besar perangkat keras.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya sudah memberi tahu Anda segalanya, mari kita periksa dua teknologi komputasi GPU paling sukses - OpenCL dan CUDA - lihat juga bagaimana Java bekerja dengannya. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL dan Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti paket infrastruktur lainnya, OpenCL menyediakan implementasi dasar dalam C. Ini secara teknis tersedia menggunakan Java Native Interface (JNI) atau Java Native Access (JNA), tetapi pendekatan ini akan terlalu sulit bagi kebanyakan pengembang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, pekerjaan ini sudah dilakukan oleh beberapa perpustakaan: JOCL, JogAmp, dan JavaCL. Sayangnya, JavaCL telah menjadi proyek mati. Tetapi proyek JOCL masih hidup dan sangat disesuaikan. Saya akan menggunakannya untuk contoh-contoh berikut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi pertama-tama saya harus menjelaskan apa itu OpenCL. Saya sebutkan sebelumnya bahwa OpenCL menyediakan model yang sangat mendasar yang cocok untuk pemrograman semua jenis perangkat - tidak hanya GPU dan CPU, tetapi bahkan prosesor dan FPGA DSP.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat contoh paling sederhana: melipat vektor mungkin adalah contoh paling terang dan paling sederhana. Anda memiliki dua array angka untuk tambahan dan satu untuk hasilnya. Anda mengambil elemen dari array pertama dan elemen dari array kedua, dan kemudian Anda memasukkan jumlah ke dalam array hasil, seperti yang ditunjukkan pada Gambar. 5. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fff/896/f1f/fff896f1feb607506f35dc8dcdce973b.jpg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 5. Menambahkan elemen dua array dan menyimpan jumlah dalam array yang dihasilkan</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Seperti yang Anda lihat, operasi ini sangat konsisten dan tetap didistribusikan. Anda dapat mendorong setiap operasi penambahan ke GPU inti yang berbeda. Ini berarti bahwa jika Anda memiliki 2048 core, seperti pada Nvidia 1080, Anda dapat melakukan operasi penambahan 2048 secara bersamaan. Ini berarti bahwa di sini potensi teraflops daya komputer sedang menunggu untuk Anda. Kode untuk larik 10 juta angka ini diambil dari situs web JOCL:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayGPU</span> </span>{
    <span class="hljs-comment">/**
     * The source code of the OpenCL program 
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String programSource =
        <span class="hljs-string">"__kernel void "</span>+
        <span class="hljs-string">"sampleKernel(__global const float *a,"</span>+
        <span class="hljs-string">"             __global const float *b,"</span>+
        <span class="hljs-string">"             __global float *c)"</span>+
        <span class="hljs-string">"{"</span>+
        <span class="hljs-string">"    int gid = get_global_id(0);"</span>+
        <span class="hljs-string">"    c[gid] = a[gid] + b[gid];"</span>+
        <span class="hljs-string">"}"</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span>
    </span>{
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10_000_000</span>;
        <span class="hljs-keyword">float</span> srcArrayA[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> srcArrayB[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> dstArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<font></font>
        {<font></font>
            srcArrayA[i] = i;<font></font>
            srcArrayB[i] = i;<font></font>
        }<font></font>
        Pointer srcA = Pointer.to(srcArrayA);<font></font>
        Pointer srcB = Pointer.to(srcArrayB);<font></font>
        Pointer dst = Pointer.to(dstArray);<font></font>
<font></font>
<font></font>
        <span class="hljs-comment">// The platform, device type and device number</span>
        <span class="hljs-comment">// that will be used</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> platformIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deviceType = CL.CL_DEVICE_TYPE_ALL;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> deviceIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Enable exceptions and subsequently omit error checks in this sample</span>
        CL.setExceptionsEnabled(<span class="hljs-keyword">true</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the number of platforms</span>
        <span class="hljs-keyword">int</span> numPlatformsArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetPlatformIDs(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numPlatformsArray);
        <span class="hljs-keyword">int</span> numPlatforms = numPlatformsArray[<span class="hljs-number">0</span>];<font></font>
<font></font>
        <span class="hljs-comment">// Obtain a platform ID</span>
        cl_platform_id platforms[] = <span class="hljs-keyword">new</span> cl_platform_id[numPlatforms];<font></font>
        CL.clGetPlatformIDs(platforms.length, platforms, <span class="hljs-keyword">null</span>);<font></font>
        cl_platform_id platform = platforms[platformIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Initialize the context properties</span>
        cl_context_properties contextProperties = <span class="hljs-keyword">new</span> cl_context_properties();<font></font>
        contextProperties.addProperty(CL.CL_CONTEXT_PLATFORM, platform);<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain the number of devices for the platform</span>
        <span class="hljs-keyword">int</span> numDevicesArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numDevicesArray);
        <span class="hljs-keyword">int</span> numDevices = numDevicesArray[<span class="hljs-number">0</span>];<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain a device ID </span>
        cl_device_id devices[] = <span class="hljs-keyword">new</span> cl_device_id[numDevices];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, numDevices, devices, <span class="hljs-keyword">null</span>);<font></font>
        cl_device_id device = devices[deviceIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Create a context for the selected device</span><font></font>
        cl_context context = CL.clCreateContext(<font></font>
            contextProperties, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> cl_device_id[]{device}, 
            <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create a command-queue for the selected device</span><font></font>
        cl_command_queue commandQueue = <font></font>
            CL.clCreateCommandQueue(context, device, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Allocate the memory objects for the input and output data</span>
        cl_mem memObjects[] = <span class="hljs-keyword">new</span> cl_mem[<span class="hljs-number">3</span>];<font></font>
        memObjects[<span class="hljs-number">0</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcA, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">1</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcB, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">2</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_WRITE,<font></font>
            Sizeof.cl_float * n, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the program from the source code</span><font></font>
        cl_program program = CL.clCreateProgramWithSource(context,<font></font>
            <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> String[]{ programSource }, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Build the program</span>
        CL.clBuildProgram(program, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the kernel</span>
        cl_kernel kernel = CL.clCreateKernel(program, <span class="hljs-string">"sampleKernel"</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Set the arguments for the kernel</span>
        CL.clSetKernelArg(kernel, <span class="hljs-number">0</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">0</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">1</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">1</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">2</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">2</span>]));<font></font>
        <font></font>
        <span class="hljs-comment">// Set the work-item dimensions</span>
        <span class="hljs-keyword">long</span> global_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{n};
        <span class="hljs-keyword">long</span> local_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{<span class="hljs-number">1</span>};<font></font>
        <font></font>
        <span class="hljs-comment">// Execute the kernel</span>
        CL.clEnqueueNDRangeKernel(commandQueue, kernel, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>,<font></font>
            global_work_size, local_work_size, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Read the output data</span>
        CL.clEnqueueReadBuffer(commandQueue, memObjects[<span class="hljs-number">2</span>], CL.CL_TRUE, <span class="hljs-number">0</span>,<font></font>
            n * Sizeof.cl_float, dst, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Release kernel, program, and memory objects</span>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">0</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">1</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">2</span>]);<font></font>
        CL.clReleaseKernel(kernel);<font></font>
        CL.clReleaseProgram(program);<font></font>
        CL.clReleaseCommandQueue(commandQueue);<font></font>
        CL.clReleaseContext(context);<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getString</span><span class="hljs-params">(cl_device_id device, <span class="hljs-keyword">int</span> paramName)</span> </span>{
        <span class="hljs-comment">// Obtain the length of the string that will be queried</span>
        <span class="hljs-keyword">long</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceInfo(device, paramName, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, size);<font></font>
<font></font>
        <span class="hljs-comment">// Create a buffer of the appropriate size and fill it with the info</span>
        <span class="hljs-keyword">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)size[<span class="hljs-number">0</span>]];<font></font>
        CL.clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Create a string from the buffer (excluding the trailing \0 byte)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, buffer.length-<span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini tidak seperti kode Java, tetapi kode itu. Saya akan menjelaskan kode lebih lanjut; jangan menghabiskan banyak waktu sekarang, karena saya akan membahas secara singkat solusi yang kompleks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode akan didokumentasikan, tetapi mari kita lakukan sedikit langkah-langkah. Seperti yang Anda lihat, kode ini sangat mirip dengan kode dalam C. Ini normal karena JOCL hanyalah OpenCL. Pada awalnya, ini adalah beberapa kode di baris, dan kode ini adalah bagian yang paling penting: Dikompilasi menggunakan OpenCL dan kemudian dikirim ke kartu video, di mana kode tersebut dieksekusi. Kode ini disebut Kernel. Jangan bingung istilah ini dengan OC Kernel; Ini adalah kode perangkat. Kode ini ditulis dalam subset C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah kernel datang kode Java untuk menginstal dan mengkonfigurasi perangkat, membagi data, dan membuat buffer memori yang sesuai untuk data yang dihasilkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk meringkas: di sini adalah "kode host", yang biasanya merupakan bahasa yang mengikat (dalam kasus kami, di Jawa), dan "kode perangkat". Anda selalu menyorot apa yang akan berfungsi pada host dan apa yang harus bekerja pada perangkat, karena host mengontrol perangkat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode sebelumnya harus menunjukkan GPU yang setara dengan "Hello World!" Seperti yang Anda lihat, sebagian besar sangat besar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jangan lupa tentang fitur SIMD. Jika perangkat Anda mendukung ekstensi SIMD, Anda dapat membuat kode aritmatika lebih cepat. Sebagai contoh, mari kita lihat kode perkalian matriks kernel. Kode ini dalam garis Jawa sederhana dalam aplikasi.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dim,
                  __global <span class="hljs-keyword">float</span> *A,
                  __global <span class="hljs-keyword">float</span> *B,
                  __global <span class="hljs-keyword">float</span> *C)</span></span>{<font></font>
<font></font>
    <span class="hljs-keyword">int</span> iCol = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> iRow = get_global_id(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">float</span> result = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; dim; ++i)<font></font>
    {<font></font>
          result +=<font></font>
          A[iRow*dim + i]*B[i*dim + iCol];<font></font>
    }<font></font>
    C[iRow*dim + iCol] = result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara teknis, kode ini akan bekerja pada potongan data yang diinstal untuk Anda oleh kerangka kerja OpenCL, dengan instruksi yang Anda panggil di bagian persiapan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kartu video Anda mendukung instruksi SIMD dan dapat memproses vektor empat angka floating-point, optimisasi kecil dapat mengubah kode sebelumnya menjadi yang berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VECTOR_SIZE 4    </span>
<span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic_vector4</span><span class="hljs-params">(
    <span class="hljs-keyword">size_t</span> dim, <span class="hljs-comment">// dimension is in single floats</span>
    <span class="hljs-keyword">const</span> float4 *A,
    <span class="hljs-keyword">const</span> float4 *B,
    float4 *C)</span>
</span>{
    <span class="hljs-keyword">size_t</span> globalIdx = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">size_t</span> globalIdy = get_global_id(<span class="hljs-number">1</span>);<font></font>
    float4 resultVec = (float4){ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
    <span class="hljs-keyword">size_t</span> dimVec = dim / <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dimVec; ++i) {<font></font>
        float4 Avector = A[dimVec * globalIdy + i];<font></font>
        float4 Bvector[<span class="hljs-number">4</span>];<font></font>
        Bvector[<span class="hljs-number">0</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">0</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">1</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">2</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">3</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>) + globalIdx];<font></font>
        resultVec += Avector[<span class="hljs-number">0</span>] * Bvector[<span class="hljs-number">0</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">1</span>] * Bvector[<span class="hljs-number">1</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">2</span>] * Bvector[<span class="hljs-number">2</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">3</span>] * Bvector[<span class="hljs-number">3</span>];<font></font>
    }<font></font>
<font></font>
    C[dimVec * globalIdy + globalIdx] = resultVec;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan kode ini Anda dapat menggandakan kinerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keren. </font><font style="vertical-align: inherit;">Anda baru saja membuka GPU untuk dunia Java! </font><font style="vertical-align: inherit;">Tetapi sebagai pengembang Java, apakah Anda benar-benar ingin melakukan semua pekerjaan kotor ini, dengan kode C, dan bekerja dengan detail tingkat rendah seperti itu? </font><font style="vertical-align: inherit;">Saya tidak mau. </font><font style="vertical-align: inherit;">Tetapi sekarang setelah Anda memiliki pengetahuan tentang bagaimana GPU digunakan, mari kita lihat solusi lain yang berbeda dari kode JOCL yang baru saja saya sajikan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA dan Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA adalah solusi Nvidia untuk masalah pemrograman ini. </font><font style="vertical-align: inherit;">CUDA menyediakan lebih banyak perpustakaan yang siap digunakan untuk operasi GPU standar, seperti matriks, histogram, dan bahkan jaringan saraf yang dalam. </font><font style="vertical-align: inherit;">Daftar perpustakaan telah muncul dengan banyak solusi yang sudah jadi. </font><font style="vertical-align: inherit;">Ini semua dari proyek JCuda:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCublas: segalanya untuk matriks</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCufft: Fast Fourier Transform </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCurand: Semuanya untuk Angka Acak</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusparse: matriks langka</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusolver: faktorisasi angka</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNvgraph: semuanya untuk grafik </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudpp: Perpustakaan CUDA data paralel primitif dan beberapa algoritma penyortiran</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNpp: Pemrosesan gambar GPU</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudnn: perpustakaan jaringan saraf yang mendalam</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sedang mempertimbangkan menggunakan JCurand, yang menghasilkan angka acak. </font><font style="vertical-align: inherit;">Anda dapat menggunakan ini dari kode Java tanpa bahasa Kernel khusus lainnya. </font><font style="vertical-align: inherit;">Sebagai contoh:</font></font><br>
<br>
<pre><code class="java hljs">...
<span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>;<font></font>
curandGenerator generator = <span class="hljs-keyword">new</span> curandGenerator();
<span class="hljs-keyword">float</span> hostData[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<font></font>
Pointer deviceData = <span class="hljs-keyword">new</span> Pointer();<font></font>
cudaMalloc(deviceData, n * Sizeof.FLOAT);<font></font>
curandCreateGenerator(generator, CURAND_RNG_PSEUDO_DEFAULT); <font></font>
curandSetPseudoRandomGeneratorSeed(generator, <span class="hljs-number">1234</span>);<font></font>
curandGenerateUniform(generator, deviceData, n);<font></font>
cudaMemcpy(Pointer.to(hostData), deviceData, <font></font>
        n * Sizeof.FLOAT, cudaMemcpyDeviceToHost);<font></font>
System.out.println(Arrays.toString(hostData));<font></font>
curandDestroyGenerator(generator);<font></font>
cudaFree(deviceData);<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini menggunakan GPU untuk membuat sejumlah besar angka acak berkualitas sangat tinggi, berdasarkan matematika yang sangat kuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di JCuda, Anda juga dapat menulis kode CUDA umum dan memanggilnya dari Jawa dengan memanggil beberapa file JAR di classpath Anda. </font><font style="vertical-align: inherit;">Lihat dokumentasi JCuda untuk contoh yang bagus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap di atas kode level rendah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya tampak hebat, tetapi ada terlalu banyak kode, terlalu banyak instalasi, terlalu banyak bahasa yang berbeda untuk menjalankan semuanya. Apakah ada cara untuk menggunakan GPU setidaknya sebagian? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana jika Anda tidak ingin memikirkan semua OpenCL, CUDA, dan hal-hal lain yang tidak perlu ini? Bagaimana jika Anda hanya ingin memprogram di Jawa dan tidak memikirkan segala sesuatu yang tidak jelas? Proyek Aparapi dapat membantu. Aparapi didasarkan pada "API paralel." Saya menganggapnya sebagai bagian dari Hibernate untuk pemrograman GPU yang menggunakan OpenCL di bawah tenda. Mari kita lihat contoh penambahan vektor.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] _args)</span> </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">512</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    <span class="hljs-comment">/* fill the arrays with random values */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<font></font>
        a[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
        b[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    Kernel kernel = <span class="hljs-keyword">new</span> Kernel(){
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
I           <span class="hljs-keyword">int</span> gid = getGlobalId();<font></font>
            sum[gid] = a[gid] + b[gid];<font></font>
        }<font></font>
    };<font></font>
<font></font>
    kernel.execute(Range.create(size));<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
        System.out.printf(<span class="hljs-string">"%6.2f + %6.2f = %8.2f\n"</span>, a[i], b[i], sum[i])<font></font>
    }<font></font>
    kernel.dispose();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah kode Java murni (diambil dari dokumentasi Aparapi), juga di sana-sini, Anda dapat melihat istilah Kernel tertentu dan getGlobalId. </font><font style="vertical-align: inherit;">Anda masih perlu memahami cara memprogram GPU, tetapi Anda dapat menggunakan pendekatan GPGPU dengan cara yang lebih mirip Java. </font><font style="vertical-align: inherit;">Selain itu, Aparapi menyediakan cara mudah untuk menggunakan konteks OpenGL ke lapisan OpenCL - sehingga memungkinkan data untuk sepenuhnya tetap pada kartu grafis - dan dengan demikian menghindari masalah latensi memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda perlu melakukan banyak perhitungan independen, lihat Aparapi. </font><font style="vertical-align: inherit;">Ada banyak contoh cara menggunakan komputasi paralel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, ada beberapa proyek yang disebut TornadoVM - secara otomatis mentransfer perhitungan yang sesuai dari CPU ke GPU, sehingga memberikan optimasi massal di luar kotak.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada banyak aplikasi di mana GPU dapat membawa beberapa keuntungan, tetapi bisa dibilang masih ada beberapa kendala. </font><font style="vertical-align: inherit;">Namun, Java dan GPU dapat melakukan hal-hal besar bersama. </font><font style="vertical-align: inherit;">Dalam artikel ini, saya hanya menyentuh topik yang luas ini. </font><font style="vertical-align: inherit;">Saya bermaksud menunjukkan berbagai opsi level tinggi dan rendah untuk mengakses GPU dari Java. </font><font style="vertical-align: inherit;">Menjelajahi area ini akan memberikan manfaat kinerja yang luar biasa, terutama untuk tugas-tugas kompleks yang membutuhkan banyak perhitungan yang dapat dilakukan secara paralel. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan Sumber</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id500086/index.html">Menulis kalkulator javascript</a></li>
<li><a href="../id500098/index.html">JavaScript Nehronikal</a></li>
<li><a href="../id500100/index.html">TV dulu, tipografi responsif atau bagaimana tidak melupakan semua ukuran perangkat</a></li>
<li><a href="../id500102/index.html">Roslyn & EF Core: membangun DbContext dalam runtime</a></li>
<li><a href="../id500104/index.html">Pemodelan proses bisnis, terjemahan diagram-teks otomatis dan notasi CH-1</a></li>
<li><a href="../id500108/index.html">(Spring) State dalam Shell (Spring): bukan produksi tunggal</a></li>
<li><a href="../id500110/index.html">Sepatah kata tentang pengiriman barang</a></li>
<li><a href="../id500114/index.html">Pencarian pekerjaan di Jerman sebagai manajer produk dan banyak lagi. Bagian 2/5. Struktur pasar tenaga kerja. ATS. Papan pekerjaan</a></li>
<li><a href="../id500116/index.html">Pekerjaan tim terdistribusi dalam kondisi isolasi diri: karena kami hampir tidak melihat perbedaannya</a></li>
<li><a href="../id500118/index.html">Lima langkah untuk membuat sistem rujukan cross-selling yang tak terhindarkan, atau cross-selling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>