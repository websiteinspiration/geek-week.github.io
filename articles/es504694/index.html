<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚲 🤘🏾 ☘️ Cómo compilar un decorador: C ++, Python y su propia implementación. Parte 1 🕜 🧔 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta serie de artículos estará dedicada a la posibilidad de crear un decorador en C ++, las características de su trabajo en Python, y también conside...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cómo compilar un decorador: C ++, Python y su propia implementación. Parte 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504694/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta serie de artículos estará dedicada a la posibilidad de crear un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decorador</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en C ++, las características de su trabajo en Python, y también consideraremos una de las opciones para implementar esta funcionalidad en nuestro propio lenguaje compilado, utilizando el enfoque general para crear cierres: conversión de cierre y modernización del árbol de sintaxis.</font></font></p><br>
<img src="https://habrastorage.org/webt/mm/gu/wn/mmguwnnsrlpzur2dgs8pf0woq7m.png"><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargo de responsabilidad</font></font></b>
                        <div class="spoiler_text">        ,    Python —    .   Python  ,    (). -   ( ),        -    ( ,    ..),   Python  «»      .<br>
</div>
                    </div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decorador en C ++</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo comenzó con el hecho de que mi amigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VoidDruid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decidió escribir un pequeño compilador como diploma, cuya característica clave son los decoradores. Incluso durante la defensa previa, cuando describió todas las ventajas de su enfoque, que incluía cambiar el AST, me preguntaba: ¿es realmente imposible implementar estos mismos decoradores en el gran y poderoso C ++ y prescindir de términos y enfoques complicados? Buscando en Google este tema, no encontré ningún enfoque simple y general para resolver este problema (por cierto, solo encontré artículos sobre la implementación del patrón de diseño) y luego me senté a escribir mi propio decorador.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, antes de pasar a una descripción directa de mi implementación, me gustaría hablar un poco sobre cómo se organizan las lambdas y los cierres en C ++ y cuál es la diferencia entre ellos. </font><font style="vertical-align: inherit;">Inmediatamente haga una reserva de que si no se menciona un estándar específico, por defecto me refiero a C ++ 20. </font><font style="vertical-align: inherit;">En resumen, las lambdas son funciones anónimas y los cierres son funciones que utilizan objetos de su entorno. </font><font style="vertical-align: inherit;">Entonces, por ejemplo, comenzando con C ++ 11, una lambda se puede declarar y llamar así:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{<font></font>
    [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }(<span class="hljs-number">10</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O asigne su valor a una variable y llámelo más tarde.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    <span class="hljs-keyword">auto</span> lambda = [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
    lambda(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¿qué sucede durante la compilación y qué es lambda? </font><font style="vertical-align: inherit;">Para sumergirse en la estructura interna de la lambda, solo vaya al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sitio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> web </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">cppinsights.io</font></a><font style="vertical-align: inherit;"> y ejecute nuestro primer ejemplo. </font><font style="vertical-align: inherit;">A continuación, adjunto una posible conclusión:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_60_19</span>
{</span>
<span class="hljs-keyword">public</span>: 
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">using</span> retType_60_19 = <span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>);
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">retType_60_19</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> __invoke;<font></font>
    };<font></font>
    <font></font>
<span class="hljs-keyword">private</span>: 
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __invoke(<span class="hljs-keyword">int</span> a)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }    <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, al compilar, el lambda se convierte en una clase, o más bien un functor (un objeto para el cual se define el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operador ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) con un nombre único generado automáticamente que tiene un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operador ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que toma los parámetros que pasamos a nuestro lambda y su cuerpo contiene El código que debe ejecutar nuestra lambda. </font><font style="vertical-align: inherit;">Con esto, todo está claro, pero ¿qué pasa con los otros dos métodos, por qué son? </font><font style="vertical-align: inherit;">El primero es el operador de conversión a un puntero de función, cuyo prototipo coincide con nuestro lambda, y el segundo es el código que debe ejecutarse cuando se llama a nuestro lambda en su asignación preliminar al puntero, por ejemplo así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> (*p_lambda) (<span class="hljs-keyword">int</span>) = lambda;<font></font>
p_lambda(<span class="hljs-number">10</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, hay menos acertijos, pero ¿qué pasa con los cierres? </font><font style="vertical-align: inherit;">Escribamos el ejemplo más simple de un cierre que captura la variable "a" por referencia y la aumenta en uno.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, el mecanismo para crear cierres y lambdas en C ++ es casi el mismo, por lo que estos conceptos a menudo se confunden y los lambdas y cierres simplemente se llaman lambdas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero volvamos a la representación interna del cierre en C ++.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_61_20</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
    </span>{<font></font>
        a += <span class="hljs-number">1</span>;<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> &amp; a;
<span class="hljs-keyword">public</span>:<font></font>
    __lambda_61_20(<span class="hljs-keyword">int</span> &amp; _a)<font></font>
    : a{_a}<font></font>
    {}<font></font>
};</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, hemos agregado un nuevo constructor no predeterminado que toma nuestro parámetro como referencia y lo guarda como miembro de la clase. </font><font style="vertical-align: inherit;">En realidad, es por eso que debe ser extremadamente cuidadoso al configurar [&amp;] o [=], porque todo el contexto se almacenará dentro del cierre, y esto puede ser bastante subóptimo de la memoria. </font><font style="vertical-align: inherit;">Además, perdimos el operador de conversión a un puntero de función, porque ahora se necesita su contexto de llamada normal. </font><font style="vertical-align: inherit;">Y ahora el código anterior no se compilará:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
    <span class="hljs-keyword">void</span> (*ptr)(<span class="hljs-keyword">int</span>) = closure;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, si aún necesita pasar el cierre en alguna parte, nadie ha cancelado el uso de la función std ::.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; function = closure;<font></font>
function();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que hemos descubierto aproximadamente qué lambdas y cierres hay en C ++, pasemos a escribir el decorador directamente. </font><font style="vertical-align: inherit;">Pero primero, debe decidir sobre nuestros requisitos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, el decorador debe tomar nuestra función o método como entrada, agregarle la funcionalidad que necesitamos (por ejemplo, esto se omitirá) y devolver una nueva función cuando se le llame, que ejecuta nuestro código y el código de función / método. En este punto, cualquier pitonista respetuoso dirá: “¡Pero cómo es eso! ¡El decorador debe reemplazar el objeto original y cualquier llamada al mismo debe llamar a una nueva función! Esta es la principal limitación de C ++, no podemos evitar que el usuario invoque la función anterior. Por supuesto, hay una opción para obtener su dirección en la memoria y molerla (en este caso, acceder a ella dará lugar a una terminación anormal del programa) o reemplazar su cuerpo con una advertencia de que no debe usarse en la consola, pero esto está lleno de graves consecuencias. Si la primera opción parece bastante difícil,luego, el segundo, cuando se utilizan varias optimizaciones de compilador, también puede provocar un bloqueo y, por lo tanto, no las utilizaremos. Además, el uso de cualquier macro magia aquí lo considero redundante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, pasemos a escribir nuestro decorador. </font><font style="vertical-align: inherit;">La primera opción que me vino a la mente fue esta:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;R(Args...)&gt;&amp; f)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> [=](Args... args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> f(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que es una estructura con un método estático que toma std :: function y devuelve un cierre que tomará los mismos parámetros que nuestra función y, cuando se llame, simplemente llamará a nuestra función y devolverá su resultado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creemos una función simple que queremos decorar.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"here"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y nuestro principal se verá así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; f = myFunc;
    <span class="hljs-keyword">auto</span> decorated = Decorator::make(f);<font></font>
    decorated(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo funciona, todo está bien y en general Hurra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad, esta solución tiene varios problemas. </font><font style="vertical-align: inherit;">Comencemos en orden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código solo se puede compilar con la versión C ++ 14 y superior, ya que no es posible conocer el tipo devuelto de antemano. </font><font style="vertical-align: inherit;">Desafortunadamente, tengo que vivir con esto y no encontré otras opciones.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make requiere que se le pase std :: function, y pasar una función por su nombre conduce a errores de compilación. </font><font style="vertical-align: inherit;">¡Y esto no es tan conveniente como nos gustaría! </font><font style="vertical-align: inherit;">No podemos escribir código como este:</font></font><br>
<br>
<pre><code class="cpp hljs">Decorator::make([](){});<font></font>
Decorator::make(myFunc);<font></font>
<span class="hljs-keyword">void</span>(*ptr)(<span class="hljs-keyword">int</span>) = myFunc;<font></font>
Decorator::make(ptr);</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, no es posible decorar un método de clase.</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, después de una breve conversación con colegas, se inventó la siguiente opción para C ++ 17 y superior:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] (<span class="hljs-keyword">auto</span> &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las ventajas de esta opción en particular son que ahora podemos decorar absolutamente cualquier objeto que tenga un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operador ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entonces, por ejemplo, podemos pasar el nombre de una función libre, un puntero, una lambda, cualquier functor, función std :: y, por supuesto, un método de clase. </font><font style="vertical-align: inherit;">En el caso de este último, también será necesario pasarle un contexto al llamar a la función decodificada.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opciones de aplicación</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> decorated_1 = Decorator::make(myFunc);<font></font>
    decorated_1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> my_lambda = [] (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) <font></font>
    { <font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <font></font>
    };<font></font>
    <span class="hljs-keyword">auto</span> decorated_2 = Decorator::make(my_lambda);<font></font>
    decorated_2(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = myFunc;
    <span class="hljs-keyword">auto</span> decorated_3 = Decorator::make(ptr);<font></font>
    decorated_3(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; fun = myFunc;
    <span class="hljs-keyword">auto</span> decorated_4 = Decorator::make(fun);<font></font>
    decorated_4(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_5 = Decorator::make(decorated_4);<font></font>
    decorated_5(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_6 = Decorator::make(&amp;MyClass::func);<font></font>
    decorated_6(MyClass(<span class="hljs-number">10</span>));<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, este código se puede compilar con C ++ 14 si hay una extensión para usar std :: invoke, que debe reemplazarse con std :: __ invoke. </font><font style="vertical-align: inherit;">Si no hay una extensión, tendrá que renunciar a la capacidad de decorar métodos de clase, y esta funcionalidad no estará disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Para no escribir el engorroso "std :: forward &lt;decltype (args)&gt; (args) ...", puede usar la funcionalidad disponible con C ++ 20 y hacer nuestra placa lambda!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] <font></font>
        &lt;<span class="hljs-keyword">typename</span> ...Args&gt; (Args &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo es perfectamente seguro e incluso funciona de la manera que queremos (o al menos finge). </font><font style="vertical-align: inherit;">Este código está compilado para las versiones gcc y clang 10-x y puede encontrarlo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">También habrá implementaciones para varios estándares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los siguientes artículos, pasaremos a la implementación canónica de decoradores usando el ejemplo de Python y su estructura interna.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es504682/index.html">Mensaje de Nostalgia: j2me, Gravity Defied, 64kb</a></li>
<li><a href="../es504686/index.html">Como dibujar un gato</a></li>
<li><a href="../es504688/index.html">Las máscaras son inútiles: crítica científica de la política social en KOVID-19</a></li>
<li><a href="../es504690/index.html">La historia de cómo configuré Azure AD B2C en React and React Native Part 3 (Tutorial)</a></li>
<li><a href="../es504692/index.html">Conceptos básicos de ZFS: almacenamiento y rendimiento</a></li>
<li><a href="../es504696/index.html">Noticias del mundo de OpenStreetMap No. 513 (12.05.2020-18.05.2020)</a></li>
<li><a href="../es504698/index.html">Incorporación en un sitio remoto</a></li>
<li><a href="../es504700/index.html">Tableta gráfica soviética "bosquejo"</a></li>
<li><a href="../es504702/index.html">La gente no quiere saber inglés</a></li>
<li><a href="../es504706/index.html">Administración automática de energía de Wi-Fi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>