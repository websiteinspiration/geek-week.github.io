<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕐 👨🏼‍✈️ 👸🏻 Inserciones de Android: lidiar con los miedos y prepararse para Android Q 👷🏼 👩🏿‍🤝‍👩🏼 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Android Q es la décima versión de Android con API nivel 29. Una de las ideas principales de la nueva versión es el concepto de borde a borde, cuando l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Inserciones de Android: lidiar con los miedos y prepararse para Android Q</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488196/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android Q es la décima versión de Android con API nivel 29. </font><font style="vertical-align: inherit;">Una de las ideas principales de la nueva versión es el concepto de borde a borde, cuando las aplicaciones ocupan toda la pantalla, de abajo hacia arriba. </font><font style="vertical-align: inherit;">Esto significa que la barra de estado y la barra de navegación deben ser transparentes. </font><font style="vertical-align: inherit;">Pero, si son transparentes, entonces no hay una interfaz de usuario del sistema: se superpone a los componentes interactivos de la aplicación. </font><font style="vertical-align: inherit;">Este problema se resuelve con inserciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los desarrolladores móviles evitan las inserciones, les causan miedo. </font><font style="vertical-align: inherit;">Pero en Android Q no será posible evitar las inserciones: tendrá que estudiarlas y aplicarlas. </font><font style="vertical-align: inherit;">De hecho, las inserciones no tienen nada de complicado: muestran qué elementos de la pantalla se cruzan con la interfaz del sistema y sugieren cómo mover el elemento para que no entre en conflicto con la interfaz de usuario del sistema. </font><strong><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></strong><font style="vertical-align: inherit;"> contará sobre cómo funcionan los insertos y cómo son útiles</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Djql74drwk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrakok</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) funciona en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redmadrobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ha estado involucrado en Android durante 10 años y ha acumulado mucha experiencia en varios proyectos en los que no había lugar para las inserciones, siempre lograron moverse de alguna manera. </font><font style="vertical-align: inherit;">Konstantin contará sobre una larga historia de evitar el problema de las inserciones, sobre estudiar y luchar contra Android. </font><font style="vertical-align: inherit;">Considerará las tareas típicas de su experiencia en las que se podrían aplicar inserciones, y mostrará cómo dejar de temer al teclado, reconocer su tamaño y responder a la apariencia. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. </font><font style="vertical-align: inherit;">El artículo fue escrito en base a un informe de Konstantin en </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saint AppsConf 2019</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El informe utilizó materiales de varios artículos sobre inserciones. </font><font style="vertical-align: inherit;">Enlace a estos materiales al final.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tareas típicas</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de estado de color. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En muchos proyectos, el diseñador dibuja una barra de estado de color. </font><font style="vertical-align: inherit;">Se puso de moda cuando llegó Android 5 junto con el nuevo Material Design. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/ii/76/9lii76jdfrbb5i0vq8-ecv2ikby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo pintar la barra de estado? </font><font style="vertical-align: inherit;">Elemental: agrega </font></font><code>colorPrimaryDark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el color se sustituye.</font></font><br>
<br>
<pre><code class="kotlin hljs"> &lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"colorPrimaryDark"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para Android por encima de la quinta versión (API de 21 y superior), puede establecer parámetros especiales en el tema:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:statusBarColor"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de estado multicolor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A veces, los diseñadores en diferentes pantallas dibujan la barra de estado en diferentes colores. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/ev/nl/uoevnldknz2rtfq5lcqpn1mpj4g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Está bien, la forma más fácil de trabajar es con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferentes temas en diferentes actividades</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma más interesante es cambiar los colores </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directamente en tiempo de ejecución</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span>: View {<font></font>
    requireActivity().window.statusBarColor = requireContext().getColor(R.color.colorPrimary)<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El parámetro se cambia a través de una bandera especial. </font><font style="vertical-align: inherit;">Pero lo principal es no olvidar cambiar el color cuando el usuario vuelve a salir de la pantalla. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de estado transparente. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es mas dificil. </font><font style="vertical-align: inherit;">La mayoría de las veces, la transparencia está asociada con los mapas, porque es en los mapas donde se ve mejor la transparencia. </font><font style="vertical-align: inherit;">En este caso, como antes, establecemos un parámetro especial:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;    <font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, por supuesto, hay un truco bien conocido: sangrar más alto, de lo contrario, la barra de estado se superpondrá en el ícono y será fea.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/49/8f/c8/498fc8wuip6i-o4eutfnviumuio.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en otras pantallas todo se rompe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/-0/0q/if-00qq6b7zidoz-_nfyehlev7s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Como resolver el problema? El primer método que viene a la mente son las diferentes actividades: tenemos diferentes temas, diferentes parámetros, funcionan de manera diferente. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabaja con el teclado.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitamos las inserciones no solo con la barra de estado, sino también cuando trabajamos con el teclado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/jk/mz/s-jkmzxzi-5xqr1ei0ku6pfubpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A nadie le gusta la opción de la izquierda, pero para convertirla en una opción de la derecha, hay una solución simple.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;activity<font></font>
    ...<font></font>
    android:windowSoftInputMode=<span class="hljs-string">"adjustResize"</span>&gt;<font></font>
    ...<font></font>
&lt;/activity&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La actividad ahora puede cambiar de tamaño cuando aparece el teclado. Funciona de manera simple y severa. Pero no olvides otro truco: envuelve todo </font></font><code>ScrollView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De repente, el teclado ocupará toda la pantalla y habrá una pequeña franja en la parte superior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay momentos más difíciles cuando queremos cambiar el diseño cuando aparece el teclado. Por ejemplo, organice los botones u oculte el logotipo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q3/ia/zl/q3iazltlnajt-cpvdzc0u2i8zcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entrenamos tantas muletas con un teclado y una barra de estado transparente, ahora es difícil detenernos. Vaya a StackOverflow y copie el hermoso código.</font></font><br>
<br>
<pre><code class="kotlin hljs">boolean isOpened = <span class="hljs-literal">false</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> void setListenerToRootView() {
    <span class="hljs-keyword">final</span> View activityRootView = getWindow().getDecorView().findViewById(android.R.id.content);<font></font>
    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {<font></font>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> void onGlobalLayout() {<font></font>
    <font></font>
            int heightDiff = activityRootView.getRootView().getHeight() - activityRootView.getHeight();      <font></font>
            <span class="hljs-keyword">if</span> (heightDiff &gt; <span class="hljs-number">100</span>) { <span class="hljs-comment">// 99% of the time the height diff will be due to a keyboard.       </span>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"Gotcha!!! softKeyboardup"</span>, <span class="hljs-number">0</span>).show();<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">false</span>) {
                   <span class="hljs-comment">//Do two things, make the view top visible and the editText smaller</span><font></font>
                }<font></font>
                isOpened = <span class="hljs-literal">true</span>;<font></font>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">true</span>) {<font></font>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"softkeyborad Down!!!"</span>, <span class="hljs-number">0</span>).show();<font></font>
                isOpened = <span class="hljs-literal">false</span>;<font></font>
            }    <font></font>
        }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso calculó la probabilidad de que aparezca un teclado. </font><font style="vertical-align: inherit;">El código funciona, incluso en uno de los proyectos lo usamos, pero durante mucho tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchas muletas en los ejemplos están asociadas con el uso de diferentes actividades. </font><font style="vertical-align: inherit;">Pero son malos no solo porque son muletas, sino también por otras razones: el problema del "arranque en frío", la asincronía. </font><font style="vertical-align: inherit;">Describí los problemas con más detalle en el artículo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Licencia para conducir un automóvil, o por qué las aplicaciones deberían ser de actividad única</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Además, la documentación de Google indica que el enfoque recomendado es una aplicación de Actividad única.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué hicimos antes de Android 10?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosotros (en Redmadrobot) estamos desarrollando aplicaciones de bastante alta calidad, pero hemos evitado las inserciones durante mucho tiempo. ¿Cómo logramos evitarlos sin muletas grandes y en una sola actividad? </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. Capturas de pantalla y código tomados de mi proyecto de mascota </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Imagina la pantalla de la aplicación. Cuando desarrollamos nuestras aplicaciones, nunca pensamos que podría haber una barra de navegación transparente a continuación. ¿Hay una barra negra debajo? Y qué, los usuarios están acostumbrados. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/ab/6v/ceab6v6m5dqnbl9zpotdi1vqmre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte superior, inicialmente establecemos el parámetro de que la barra de estado es negra con transparencia. ¿Cómo se ve en términos de diseño y código?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/tu/of/0gtuoffisoeudtgxlnmqd-jicnk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La abstracción en la figura: el bloque rojo es la actividad de la aplicación, el azul es el fragmento con el bot de navegación (con pestañas), y dentro de él se cambian los fragmentos verdes con el contenido. Se puede ver que la barra de herramientas no está debajo de la barra de estado. ¿Cómo logramos esto? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android tiene una bandera difícil </font></font><code>fitSystemWindow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si lo establece en verdadero, el contenedor agregará relleno para sí mismo para que nada dentro de él caiga bajo la barra de estado. Creo que esta bandera es la muleta oficial de Google para aquellos que tienen miedo a las inserciones. Usar todo funcionará relativamente bien sin inserciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La bandera </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agrega relleno al contenedor que especificó. Pero la jerarquía es importante: si uno de los padres establece este indicador en "verdadero", entonces su distribución no se tendrá en cuenta, porque el contenedor ya ha aplicado la sangría.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La bandera funciona, pero aparece otro problema. </font><font style="vertical-align: inherit;">Imagine una pantalla con dos pestañas. </font><font style="vertical-align: inherit;">Al cambiar, se inicia una transacción, que causa un </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragmento uno sobre otro, y todo se rompe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/02/_u/lv02_ui9sepxlvi7djz_xpem2sy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo fragmento también tiene un conjunto de banderas </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y esto no debería suceder. </font><font style="vertical-align: inherit;">Pero qué pasó, ¿por qué? </font><font style="vertical-align: inherit;">La respuesta es que esto es una muleta, y a veces no funciona. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero encontramos una solución en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : use root para no fragmentos </font></font><code>FrameLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fue creado para otros fines, pero funciona aquí.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que funciona</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos en la fuente lo que está sucediendo en </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> void onAttachedToWindow() {   
    <span class="hljs-keyword">super</span>.onAttachedToWindow();<font></font>
    ...    <font></font>
    <span class="hljs-keyword">if</span> (mLastInsets == <span class="hljs-literal">null</span> &amp;&amp; ViewCompat.getFitsSystemWindows(<span class="hljs-keyword">this</span>)) {         
        <span class="hljs-comment">// We're set to fitSystemWindows but we haven't had any insets yet...</span>
        <span class="hljs-comment">// We should request a new dispatch of window insets</span>
        ViewCompat.requestApplyInsets(<span class="hljs-keyword">this</span>);<font></font>
    }     <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos un hermoso comentario de que aquí se necesitan inserciones, pero no lo son. </font><font style="vertical-align: inherit;">Necesitamos volver a preguntarles cuando solicitamos una ventana. </font><font style="vertical-align: inherit;">Descubrimos que las inserciones de alguna manera funcionan dentro, pero no queremos trabajar con ellas e irnos </font></font><code>Coordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la primavera de 2019, desarrollamos la aplicación, momento en el que Google I / O acaba de pasar. </font><font style="vertical-align: inherit;">Todavía no hemos resuelto todo, así que seguimos aferrándonos a los prejuicios. </font><font style="vertical-align: inherit;">Pero notamos que cambiar las pestañas en la parte inferior es de alguna manera lento, porque tenemos un diseño complejo, cargado con la interfaz de usuario. </font><font style="vertical-align: inherit;">Encontramos una manera simple de resolver esto: cambie </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>show/hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cada vez que no vuelva a crear el diseño.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/7l/vz/hx7lvzsl8-kfv3qqac2pbvllt8q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambiamos, y de nuevo nada funciona, ¡todo se ha roto! </font><font style="vertical-align: inherit;">Aparentemente no es posible esparcir muletas, debes entender por qué funcionaron. </font><font style="vertical-align: inherit;">Estudiamos el código y resulta que cualquier ViewGroup también puede trabajar con inserciones.</font></font><br>
<br>
<pre><code class="kotlin hljs">
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {    <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {         
        <span class="hljs-keyword">final</span> int count = getChildCount();        
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);             <font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {          
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe una lógica de este tipo: si al menos alguien ya ha procesado inserciones, todas las vistas posteriores dentro del ViewGroup no las recibirán. </font><font style="vertical-align: inherit;">¿Qué significa esto para nosotros? </font><font style="vertical-align: inherit;">Déjame mostrarte un ejemplo de nuestro FrameLayout, que cambia las pestañas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/fo/nn/h1fonnc4qrqpmj_x-fc8m47ptci.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro hay el primer fragmento que tiene la bandera establecida </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto significa que el primer fragmento procesa las inserciones. </font><font style="vertical-align: inherit;">Después de eso, llamamos al </font></font><code>HIDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primer fragmento y al </font></font><code>SHOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo. </font><font style="vertical-align: inherit;">Pero el primero permanece en el diseño: su vista se deja, solo oculta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El contenedor pasa por su Vista: toma el primer fragmento, le da insertos, y de él </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, los tomó y los procesó. </font><font style="vertical-align: inherit;">Perfectamente, FrameLayout parecía que los insertos fueron procesados, y no se lo dio al segundo fragmento. </font><font style="vertical-align: inherit;">Todo funciona como deberia. </font><font style="vertical-align: inherit;">Pero esto no nos conviene, ¿qué debemos hacer?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escribimos nuestro propio ViewGroup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Venimos de Java, y hay POO en todo su esplendor, así que decidimos heredar. </font><font style="vertical-align: inherit;">Escribimos nuestro propio ViewGroup, desde el cual redefinimos el método </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Funciona de la manera que lo necesitamos: siempre devuelve a los niños las inserciones que vinieron, independientemente de si las procesamos o no.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInsetFrameLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,      <font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,     <font></font>
    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><font></font>
) : FrameLayout(context, attrs, defStyleRes) {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchApplyWindowInsets</span><span class="hljs-params">(insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets { 
        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> until childCount)) {<font></font>
            getChildAt(child).dispatchApplyWindowInsets(insets)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> insets.consumeSystemWindowInsets()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Custom ViewGroup funciona, el proyecto también es todo lo que necesitamos. </font><font style="vertical-align: inherit;">Pero aún no llega a una solución general. </font><font style="vertical-align: inherit;">Cuando descubrimos lo que nos dijeron en Google IO, nos dimos cuenta de que ya no podremos actuar así.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10 nos mostró dos conceptos importantes de IU a los que se recomienda cumplir estrictamente: borde a borde y navegación gestual. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borde a borde.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concepto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sugiere que el contenido de la aplicación debería ocupar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo el espacio posible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la pantalla. Para nosotros, como desarrolladores, esto significa que las aplicaciones deben colocarse </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bajo los paneles del sistema de la barra de estado y la barra de navegación.</font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/cr/gl/nh/crglnh9iw__fu4lct0gavaibqey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Anteriormente, de alguna manera podíamos ignorar esto o colocarnos solo debajo de la Barra de estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a las listas, deben desplazarse no solo hasta el último elemento, sino también más allá </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para no permanecer debajo de la barra de navegación.</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/pl/it/tlplit1o65rn55edkixuuojxtha.png" width="350"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navegación gestual. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este segundo concepto importante es la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navegación por gestos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le permite controlar la aplicación con los dedos desde el borde de la pantalla. </font><font style="vertical-align: inherit;">El modo de gestos no es estándar, todo parece diferente, pero ahora no puede cambiar entre dos barras de navegación diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este momento, nos dimos cuenta de que no todo es tan simple. </font><font style="vertical-align: inherit;">No será posible evitar más inserciones si queremos desarrollar aplicaciones de calidad. </font><font style="vertical-align: inherit;">Es hora de estudiar la documentación y comprender qué son los insertos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserciones </font><font style="vertical-align: inherit;">¿Qué necesitas saber sobre ellos?</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las inserciones fueron creadas para asustar a los desarrolladores.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo han estado haciendo perfectamente desde el momento en que apareció en Android 5. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, no todo es tan aterrador. El concepto de insertos es simple: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informan una superposición de IU del sistema en la pantalla de la aplicación.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puede ser una barra de navegación, una barra de estado o un teclado. El teclado también es una interfaz de usuario del sistema normal, que se superpone en la parte superior de la aplicación. No es necesario tratar de procesarlo con muletas, solo insertos. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de las inserciones es resolver conflictos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por ejemplo, si hay otro elemento sobre nuestro botón, podemos mover el botón para que el usuario pueda continuar usando la aplicación. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para manejar la inserción,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use </font></font><code>Windowlnsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para Android 10 y </font></font><code>WindowInsetsCompat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para otras versiones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay </font><strong><font style="vertical-align: inherit;">5 tipos diferentes de inserciones</font></strong><font style="vertical-align: inherit;"> en Android 10</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y un "bono", que se llama no insertado, sino de otro modo. </font><font style="vertical-align: inherit;">Nos ocuparemos de todos los tipos, porque la mayoría solo sabe una cosa: Inserciones de ventanas del sistema.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de ventanas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introducido en Android 5.0 (API 21). </font><font style="vertical-align: inherit;">Obtenido por el método </font></font><code>getSystemWindowInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el tipo principal de inserciones con las que necesita aprender a trabajar, porque el resto funciona de la misma manera. </font><font style="vertical-align: inherit;">Son necesarios para procesar la barra de estado, en primer lugar, y luego la barra de navegación y el teclado. </font><font style="vertical-align: inherit;">Por ejemplo, resuelven un problema cuando la barra de navegación está por encima de la aplicación. </font><font style="vertical-align: inherit;">Como en la imagen: el botón permaneció debajo de la barra de navegación, el usuario no puede hacer clic en él y está muy descontento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/yj/tt/nxyjttdppbkrnrnqkspovzp4hko.png" width="350"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserciones de elementos que se pueden tocar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apareció solo en Android 10. Obtenido por el método </font></font><code>getTappableElementInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas inserciones </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son útiles </font><strong><font style="vertical-align: inherit;">para manejar varios modos de barra de navegación</font></strong><font style="vertical-align: inherit;"> . Como dice el propio </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Bane</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puede olvidarse de este tipo de inserciones y moverse solo por los recuadros de ventana del sistema. Pero si desea que la aplicación sea 100% fresca, no 99.9% fresca, debe usarla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mira la foto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/yd/fk/rlydfkwy39pfrc7jfhizhqdkg0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte superior, el color carmesí indica los recuadros de la ventana del sistema, que vendrán en diferentes modos de la barra de navegación. Se puede ver que a la derecha y a la izquierda son iguales a la barra de navegación.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde cómo funciona la navegación por gestos: en el modo correcto, nunca hacemos clic en un nuevo panel, sino que siempre arrastramos los dedos de abajo hacia arriba. </font><font style="vertical-align: inherit;">Esto significa que los botones no se pueden quitar. </font><font style="vertical-align: inherit;">Podemos continuar presionando nuestro botón FAB (botón de acción flotante), nadie interferirá. </font><font style="vertical-align: inherit;">Por lo tanto, </font></font><code>TappableElementInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quedará vacío porque no es necesario mover FAB. </font><font style="vertical-align: inherit;">Pero si nos movemos un poco más arriba, está bien. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La diferencia aparece solo con la navegación por gestos y la barra de navegación transparente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (adaptación de color). </font><font style="vertical-align: inherit;">Esta no es una situación muy agradable. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/ei/qz/zveiqz33n9dc290ib9yhrrjl09u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo funcionará, pero se ve desagradable. </font><font style="vertical-align: inherit;">El usuario puede confundirse por la proximidad de los elementos. </font><font style="vertical-align: inherit;">Se puede explicar que uno es para gestos y el otro para presionar, pero aún no es hermoso. </font><font style="vertical-align: inherit;">Por lo tanto, eleve el FAB más alto o déjelo a la derecha.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserciones gestuales del sistema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apareció solo en Android 10. Obtenido por el método </font></font><code>getSystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas inserciones están relacionadas con la navegación por gestos. Inicialmente, se suponía que la IU del sistema se dibuja sobre la aplicación, pero las Inserciones de gestos del sistema dicen que no se dibuja la IU, sino que el sistema mismo maneja los gestos. Describen dónde el sistema manejará los gestos por defecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las áreas de estas inserciones son aproximadamente las marcadas en amarillo en el diagrama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/8d/jl/vv8djlgxe4cnjchozbllrysagd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero quiero advertirte: no siempre serán así. Nunca sabremos qué pantallas nuevas se le ocurrirán a Samsung y otros fabricantes. Ya hay dispositivos en los que la pantalla está en todos los lados. Quizás las inserciones no estarán donde esperamos en absoluto. Por lo tanto, debe trabajar con ellos como con alguna abstracción: existen inserciones en los recuadros de gestos del sistema en los que el sistema mismo procesa los gestos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas inserciones pueden ser anuladas. </font><font style="vertical-align: inherit;">Por ejemplo, está desarrollando un editor de fotos. </font><font style="vertical-align: inherit;">En algunos lugares, usted mismo quiere manejar los gestos, incluso si están cerca del borde de la pantalla. </font><font style="vertical-align: inherit;">Indique al sistema que procesará el punto en la pantalla en la esquina de la foto usted mismo. </font><font style="vertical-align: inherit;">Se puede redefinir diciéndole al sistema: "Yo mismo siempre procesaré el cuadrado alrededor del punto".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserciones obligatorias de gestos del sistema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apareció solo en Android 10. Este es un subtipo de Inserciones de gestos del sistema, pero la aplicación no puede anularlas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usamos el método </font></font><code>getMandatorySystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar el área donde no funcionarán. </font><font style="vertical-align: inherit;">Esto se hizo intencionalmente para que fuera imposible desarrollar una aplicación "desesperada": redefinir el gesto de navegación de abajo hacia arriba, lo que le permite salir de la aplicación a la pantalla principal. </font><font style="vertical-align: inherit;">Aquí, el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema siempre procesa los gestos en sí</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/89/gl/df/89gldfknoq8z9dje_naytwp0pti.png" width="450"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No necesariamente estará en la parte inferior del dispositivo y no necesariamente de este tamaño. </font><font style="vertical-align: inherit;">Trabaja con él como una abstracción. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos eran relativamente nuevos tipos de insertos. </font><font style="vertical-align: inherit;">Pero hay aquellos que aparecieron incluso antes de Android 5 y se llamaron de manera diferente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertos estables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introducido con Android 5.0 (API 21). Obtenido por el método </font></font><code>getStableInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso los desarrolladores experimentados no siempre pueden decir por qué son necesarios. Te diré un secreto: estas inserciones solo son útiles para aplicaciones de pantalla completa: reproductores de video, juegos. Por ejemplo, en el modo de reproducción, cualquier interfaz de usuario del sistema está oculta, incluida la barra de estado, que se mueve más allá del borde de la pantalla. Pero vale la pena tocar la pantalla ya que la barra de estado aparece en la parte superior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si coloca cualquier botón "ATRÁS" en la parte superior de la pantalla, mientras procesa correctamente los recuadros de la ventana del sistema, entonces con cada pestaña aparece una IU en la parte superior de la pantalla, y el botón salta hacia abajo. Si no toca la pantalla durante un tiempo, la barra de estado desaparece, el botón se activa porque los recuadros de la ventana del sistema han desaparecido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para tales casos, los recuadros estables son perfectos. </font><font style="vertical-align: inherit;">Dicen que ahora no se dibuja ningún elemento en su aplicación, pero puede hacerlo. </font><font style="vertical-align: inherit;">Con estas inserciones, puede conocer de antemano el valor de la barra de estado en este modo, por ejemplo, y colocar el botón donde desee. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. </font><font style="vertical-align: inherit;">El método </font></font></em><code><em>getStableInsets()</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apareció solo con API 21. Anteriormente, había varios métodos para cada lado de la pantalla.&nbsp;</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinamos 5 tipos de insertos, pero hay uno más que no se aplica a los insertos directamente. </font><font style="vertical-align: inherit;">Ayuda a lidiar con flequillo y recortes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flequillo y escotes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pantallas ya no son cuadradas. </font><font style="vertical-align: inherit;">Son oblongos, con uno o más recortes para la cámara y golpes en todos los lados. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/kv/sc/lskvscp_j-hy2gesyynicb346cq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta 28 API no pudimos procesarlos. </font><font style="vertical-align: inherit;">Tuve que adivinar a través de las inserciones lo que estaba sucediendo allí. </font><font style="vertical-align: inherit;">Pero con la API 28 y más allá (desde el Android anterior), la clase apareció oficialmente </font></font><code>DisplayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Está en las mismas inserciones de donde puede obtener todos los otros tipos. </font><font style="vertical-align: inherit;">La clase le permite averiguar la ubicación y el tamaño de los artefactos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de la información de ubicación, se proporciona un conjunto de indicadores y para el desarrollador </font></font><code>WindowManager.LayoutParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le permiten incluir diferentes comportamientos en torno a los recortes. </font><font style="vertical-align: inherit;">Su contenido puede mostrarse a su alrededor, o puede no mostrarse: en modo horizontal y vertical de diferentes maneras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banderas</font></font><code>window.attributes.layoutInDisplayCutoutMode =</code><br>
<br>
<ul>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En vertical, hay, y en horizontal, una barra negra por defecto.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para nada, una franja negra.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - siempre lo es.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La pantalla se puede controlar, pero trabajamos con ellos de la misma manera que con cualquier otro recuadro.</font></font><br>
<br>
<pre><code class="kotlin hljs">insets.displayCutout<font></font>
    .boundingRects<font></font>
    .forEach { rect -&gt; ... }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La devolución de llamada con inserciones con una matriz nos llega </font></font><code>displayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego podemos ejecutarlo, procesar todos los recortes y explosiones que se encuentran en la aplicación. </font><font style="vertical-align: inherit;">Puede obtener más información sobre cómo trabajar con ellos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el artículo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entendido con 6 tipos de inserciones. </font><font style="vertical-align: inherit;">Ahora hablemos de cómo funciona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo funciona</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se necesitan inserciones, en primer lugar, cuando se dibuja algo en la parte superior de la aplicación, por ejemplo, la barra de navegación. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ft/ct/_w/ftct_wh_dc64t9rw6ir_7zpqg8m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin inserciones, la aplicación no tendrá una barra de navegación y una barra de estado transparentes. </font><font style="vertical-align: inherit;">No te sorprendas de no venir </font></font><code>SystemWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esto sucede.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separar inserciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda la jerarquía de la interfaz de usuario se parece a un árbol con una vista en sus extremos. </font><font style="vertical-align: inherit;">Los nodos suelen ser un ViewGroup. </font><font style="vertical-align: inherit;">También heredan de View, por lo que las inserciones les llegan de una manera especial </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A partir de la Vista raíz, el sistema envía inserciones en todo el árbol. </font><font style="vertical-align: inherit;">Veamos cómo funciona Ver en este caso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/rw/hk/jyrwhkavrimytpqs4je0ltfn7-w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El sistema recurre al método </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por el cual entran las inserciones. </font><font style="vertical-align: inherit;">Volver esta vista debería devolver algo. </font><font style="vertical-align: inherit;">¿Qué hacer para manejar este comportamiento? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por simplicidad, solo consideramos WindowInsets.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manejo de insertos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, la redefinición del método </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la implementación dentro de su propia lógica </font><font style="vertical-align: inherit;">parece lógica </font><font style="vertical-align: inherit;">: llegaron las inserciones, implementamos todo dentro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si abre la clase Ver y mira el Javadoc escrito sobre este método, puede ver: "¡No anule este método!"</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manejamos Insets a través de delegación o herencia.</font></font></blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar delegación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Google brindó la oportunidad de exponer a su propio delegado, quien es responsable del manejo de las inserciones. </font><font style="vertical-align: inherit;">Puede instalarlo a través del método </font></font><code>setOnApplyWindowInsetsListener(listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Establecemos una devolución de llamada que maneja estas inserciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si por alguna razón esto no nos conviene, puede </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heredar de Ver y anular otro método</font></font></strong> <code>onApplyWindowInsets(WindowInsets insets)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sustituimos nuestras propias inserciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google no eligió entre delegación y herencia, pero permitió hacer todo junto. </font><font style="vertical-align: inherit;">Esto es genial porque no tenemos que redefinir todas las barras de herramientas o ListView para manejar las inserciones. </font><font style="vertical-align: inherit;">Podemos tomar cualquier Vista ya preparada, incluso una de biblioteca, y establecer el delegado allí, que manejará las inserciones sin redefinir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué devolveremos?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué devolver algo?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, debe comprender cómo funciona la distribución de inserciones, es decir, ViewGroup. </font><font style="vertical-align: inherit;">¿Qué está haciendo ella dentro de sí misma? </font><font style="vertical-align: inherit;">Echemos un vistazo más de cerca al comportamiento predeterminado usando el ejemplo que mostré anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las inserciones del sistema llegaron en la parte superior e inferior, por ejemplo, 100 píxeles cada una. </font><font style="vertical-align: inherit;">ViewGroup los envía a la primera vista que tiene. </font><font style="vertical-align: inherit;">Esta vista los manejó de alguna manera y devuelve inserciones: en la parte superior disminuye a 0, pero en la parte inferior se va. </font><font style="vertical-align: inherit;">En la parte superior, agregó relleno o margen, pero en la parte inferior no tocó e informó sobre esto. </font><font style="vertical-align: inherit;">A continuación, ViewGroup pasa inserciones a la segunda vista. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/-a/rw/tj-arwxjkus-n6xnvl099lqbqqg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente Vista procesa y renderiza inserciones. </font><font style="vertical-align: inherit;">Ahora ViewGroup ve que las inserciones se procesan tanto arriba como abajo: no queda nada, todos los parámetros son cero. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tercera Vista ni siquiera sabe que hubo algunas inserciones y que algo estaba sucediendo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ViewGroup devolverá las inserciones a quien las expuso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando comenzamos a tratar este tema, escribimos la idea por nosotros mismos: siempre devolvemos las mismas inserciones que vinieron. </font><font style="vertical-align: inherit;">Queríamos evitar tal situación cuando alguna Vista ni siquiera reconocía que había inserciones. </font><font style="vertical-align: inherit;">La idea parecía lógica. </font><font style="vertical-align: inherit;">Pero resultó que no. </font><font style="vertical-align: inherit;">Google no ha agregado en vano el comportamiento a las inserciones, como en el ejemplo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es necesario para que las inserciones siempre lleguen a la jerarquía completa de la Vista y siempre pueda trabajar con ellas. </font><font style="vertical-align: inherit;">En este caso, no habrá situación cuando cambiemos dos fragmentos, uno ha procesado y el segundo aún no ha recibido. </font><font style="vertical-align: inherit;">En la sección de práctica, volveremos a este punto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Práctica</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La teoría está hecha. </font><font style="vertical-align: inherit;">Veamos cómo se ve en el código, porque en teoría todo siempre es fluido. </font><font style="vertical-align: inherit;">Usaremos AndroidX. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. </font><font style="vertical-align: inherit;">En </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox,</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todo ya está implementado en el código, soporte completo para todos los extras del nuevo Android. </font><font style="vertical-align: inherit;">Para no verificar las versiones de Android y no buscar el tipo requerido de Insets, use siempre la </font></font></em><code><em>view.setOnApplyWindowInsetsListener { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versión de AndroidX </font></font></em><code><em>ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una pantalla con una barra de navegación oscura. </font><font style="vertical-align: inherit;">No se superpone a ningún elemento en la parte superior. </font><font style="vertical-align: inherit;">Todo es como estamos acostumbrados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3r/wq/sp/3rwqspgcdlgie2m00lmedkwzgi8.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero resulta que ahora tenemos que hacerlo transparente. </font><font style="vertical-align: inherit;">¿Cómo?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activar transparencia</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo más simple es indicar en el tema que la barra de estado y la barra de navegación son transparentes.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentNavigation"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este momento, todo comienza a superponerse tanto desde arriba como desde abajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curiosamente, hay dos banderas, y siempre hay tres opciones: si especifica la transparencia para la barra de navegación, la barra de estado se volverá transparente por sí misma, tal limitación. </font><font style="vertical-align: inherit;">No puedes escribir la primera línea, pero siempre me encanta la claridad, así que escribo 2 líneas para que los seguidores puedan entender lo que está sucediendo y no profundizar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si elige este método, la barra de navegación y la barra de estado se volverán negras con transparencia. </font><font style="vertical-align: inherit;">Si la aplicación es blanca, puede agregar colores solo desde el código. </font><font style="vertical-align: inherit;">¿Cómo hacerlo?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activa la transparencia con color</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bueno que tengamos una aplicación de Actividad única, por lo que ponemos dos banderas en una actividad.</font></font><br>
<br>
<pre><code class="kotlin hljs">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or  <font></font>
    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<font></font>
<font></font>
&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;!-- Set the navigation bar to <span class="hljs-number">50</span>% translucent white --&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:navigationBarColor"</span>&gt;#<span class="hljs-number">80F</span>FFFFF&lt;/item&gt; <font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay muchas banderas allí, pero son estas dos las que ayudarán a hacer transparencia en la Barra de navegación y la Barra de estado. </font><font style="vertical-align: inherit;">El color se puede especificar a través del tema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el comportamiento extraño de Android: algo a través del tema y algo a través de las banderas. </font><font style="vertical-align: inherit;">Pero podemos especificar parámetros tanto en el código como en el tema. </font><font style="vertical-align: inherit;">Esto no es tan malo para Android, solo en versiones anteriores de Android se ignorará la bandera especificada en el tema. </font></font><code>navigationBarColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Destacará que en Android 5 esto no es así, pero todo se unirá. </font><font style="vertical-align: inherit;">En GitFox, fue desde el código que configuré el color de la barra de navegación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizamos fraudes: indicamos que la barra de navegación es blanca con transparencia. </font><font style="vertical-align: inherit;">Ahora la aplicación se ve así.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/vs/mz/eovsmz1tczlc9vl_kg2yihxs0u0.png" width="350"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué podría ser más fácil que manipular insertos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, primaria.</font></font><br>
<br>
<pre><code class="kotlin hljs">ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;  <font></font>
        view.updatePadding(bottom = insets.systemWindowInsetBottom) <font></font>
        insets<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos el método </font></font><code>setOnApplyWindowInsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se lo pasamos </font></font><code>bottomNav</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Decimos que cuando vienen las inserciones, instale el relleno inferior que entró </font></font><code>systemWindowInsetBottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo queremos debajo, pero todos nuestros elementos en los que se puede hacer clic están en la parte superior. </font><font style="vertical-align: inherit;">Devolvemos las inserciones completas para que todas las demás Vistas de nuestra jerarquía también las reciban. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo se ve genial.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zl/8e/ku/zl8ekuc_pvpc2wrmeop-khxmomg.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay una trampa. </font><font style="vertical-align: inherit;">Si en el diseño indicamos algún tipo de relleno en la barra de navegación a continuación, entonces aquí se eliminó: establezca las </font></font><code>updatePadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inserciones iguales. </font><font style="vertical-align: inherit;">Nuestro diseño no se ve como nos gustaría. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para guardar los valores del diseño, primero debe guardar lo que está en el relleno inferior. </font><font style="vertical-align: inherit;">Más tarde, cuando lleguen las inserciones, agregue y establezca los valores resultantes.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> bottomNavBottomPadding = bottomNav.paddingBottom<font></font>
ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;                 <font></font>
        view.updatePadding(<font></font>
        bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    Insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es un inconveniente escribir de esta manera: en todas partes del código donde usa inserciones, debe guardar el valor del diseño y luego agregarlo a la interfaz de usuario. </font><font style="vertical-align: inherit;">Pero está Kotlin, y esto es maravilloso: puede escribir su propia extensión, que hará todo esto por nosotros.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Añadir Kotlin!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo recordamos </font></font><code>initialPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se lo damos al manejador cuando aparecen nuevos insertos (junto con ellos). </font><font style="vertical-align: inherit;">Esto los ayudará de alguna manera a agregar o construir algún tipo de lógica desde arriba.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {    <font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
<font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
    <font></font>
    requestApplyInsetsWhenAttached()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
   Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)<font></font>
<font></font>
  .<font></font>
<font></font>
bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;   <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    ) <font></font>
    insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos que redefinir la lambda. </font><font style="vertical-align: inherit;">No solo tiene inserciones, sino también acolchados. </font><font style="vertical-align: inherit;">Podemos agregarlos no solo desde abajo, sino también desde arriba, si se trata de una barra de herramientas que procesa la barra de estado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo olvidado!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un llamado a un método incomprensible.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
     <font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
      <font></font>
    requestApplyInsetsWhenAttached() <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
      Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se debe al hecho de que no puedes esperar que el sistema te envíe inserciones. </font><font style="vertical-align: inherit;">Si creamos una Vista desde el código o la instalamos un </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poco más tarde, el sistema en sí mismo puede no pasar el último valor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debemos verificar que cuando la Vista esté en la pantalla, le hayamos dicho al sistema: "Los recuadros han llegado, queremos procesarlos". </font><font style="vertical-align: inherit;">Configuramos el oyente y debemos hacer una solicitud </font></font><code>requestsApplyInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">".</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">requestApplyInsetsWhenAttached</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">if</span> (isAttachedToWindow) {        <font></font>
        requestApplyInsets()<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : View.OnAttachStateChangeListener {            
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {<font></font>
                v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>)<font></font>
                v.requestApplyInsets()           <font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> = <span class="hljs-built_in">Unit</span><font></font>
        })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si creamos un código de Vista y aún no lo hemos adjuntado a nuestro diseño, entonces debemos suscribirnos al momento en que lo hacemos. </font><font style="vertical-align: inherit;">Solo entonces solicitamos inserciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, de nuevo, está Kotlin: escribieron una extensión simple y ya no tenemos que pensar en eso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refinar RecyclerView</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora hablemos de finalizar RecyclerView. El último elemento se encuentra debajo de la barra de navegación y permanece debajo, feo. También es inconveniente hacer clic en él. Si este no es un panel nuevo, sino el antiguo, uno grande, entonces, en general, todo el elemento puede desaparecer debajo de él. ¿Qué hacer? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/qa/f7/jcqaf7okahkrhrrnols54exqhdu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera idea es agregar un elemento a continuación y establecer la altura para encajar en las inserciones. Pero si tenemos una aplicación con cientos de listas, entonces de alguna manera tendremos que suscribir cada lista a inserciones, agregar un nuevo elemento allí y establecer la altura. Además, RecyclerView es asíncrono, no se sabe cuándo funcionará. Hay muchos problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay otro truco oficial. Sorprendentemente, funciona de manera eficiente.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;androidx.recyclerview.widget.RecyclerView <font></font>
        android:id=<span class="hljs-string">"@+id/recyclerView"</span>        
    android:layout_width=<span class="hljs-string">"match_parent"</span>    
    android:layout_height=<span class="hljs-string">"match_parent"</span>             
    android:clipToPadding=<span class="hljs-string">"false"</span> /&gt;<font></font>
<font></font>
recyclerView.doOnApplyWindowInsets { view, insets, padding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una bandera en el diseño </font></font><code>clipToPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por defecto, siempre es cierto. Esto sugiere que no necesita dibujar elementos que aparecen donde el relleno está expuesto. Pero si está configurado </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces puedes dibujar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, si configura el relleno en la parte inferior, en RecyclerView funcionará así: el relleno se configura en la parte inferior y el elemento se dibuja encima de él hasta que nos desplazamos. Una vez alcanzado el final, RecyclerView desplazará los elementos a la posición que necesitamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al establecer uno de estos indicadores, podemos trabajar con RecyclerView como con una vista normal. No piense que hay elementos que se desplazan, simplemente configure el relleno a continuación, como, por ejemplo, en la barra de navegación inferior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora siempre devolvíamos las inserciones como si no hubieran sido procesadas. </font><font style="vertical-align: inherit;">Los insertos enteros vinieron a nosotros, hicimos algo con ellos, colocamos el relleno y devolvimos todos los insertos enteros nuevamente. </font><font style="vertical-align: inherit;">Esto es necesario para que cualquier ViewGroup siempre pase estas inserciones a toda la Vista. </font><font style="vertical-align: inherit;">Funciona.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error de aplicación</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En muchas aplicaciones en Google Play que ya han procesado inserciones, noté un pequeño error. Ahora les contaré sobre él. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una pantalla con navegación en el sótano. A la derecha está la misma pantalla que muestra la jerarquía. El fragmento verde muestra el contenido en la pantalla, dentro tiene un RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/e6/jo/hle6jod0ws19fydq734lqnuaixu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Quién manejó las inserciones aquí? Barra de herramientas: aplicó relleno en la parte superior para que su contenido se mueva debajo de la barra de estado. En consecuencia, la barra de navegación inferior aplicó inserciones desde abajo y se elevó por encima de la barra de navegación. Pero RecyclerView no maneja las inserciones de ninguna manera, no cae debajo de ellas, no necesita procesar inserciones: todo se hace correctamente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r3/xc/qi/r3xcqipovgqu-zbbxruxsy-wqvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero aquí resulta que queremos usar el fragmento verde RecyclerView en otro lugar donde la barra de navegación inferior ya no está allí. En este punto, RecyclerView ya está comenzando a manejar inserciones desde abajo. Necesitamos aplicarle relleno para desplazarnos correctamente desde debajo de la barra de navegación. Por lo tanto, en RecyclerView, también agregamos procesamiento de inserciones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ws/m-/vewsm-_o80cw7mbn9tyk0bu_mfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volvemos a nuestra pantalla, donde todos procesan las inserciones. ¿Recuerdas que nadie informa que los procesó? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/vd/x8/umvdx8faxxk48r-inx-cxhkjqdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos esta situación: RecyclerView procesó las inserciones desde abajo, aunque no llega a la barra de navegación, apareció un espacio en la parte inferior. Me di cuenta de esto en las aplicaciones, y bastante grande y popular.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i9/3_/ar/i93_arxauyvbitayfpyonkxnudy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si este es el caso, recordamos que devolvemos todas las inserciones para procesar. Entonces (¡resulta!) Es necesario informar que las inserciones se procesan: la barra de navegación debe informar que las inserciones se procesaron. No deberían llegar a RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jf/r2/vi/jfr2vi8jpsas_ptxjjqh_qhg1vk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, instale la barra de navegación inferior </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Resta dentro de </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que no se procesan, devuelve 0.</font></font><br>
<br>
<pre><code class="kotlin hljs">doOnApplyWindowInsets { view, insets, initialPadding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    insets.replaceSystemWindowInsets(<font></font>
        Rect(<font></font>
            insets.systemWindowInsetLeft,            <font></font>
            insets.systemWindowInsetTop,            <font></font>
            insets.systemWindowInsetRight,<font></font>
            <span class="hljs-number">0</span><font></font>
        )<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devolvemos nuevas inserciones, en las que todos los parámetros antiguos son iguales, pero </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iguales a 0. Parece que todo está bien. </font><font style="vertical-align: inherit;">Comenzamos y nuevamente tonterías: RecyclerView todavía maneja inserciones por alguna razón. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lp/yw/ut/lpywut3fvlk5w-nwbd3-wnrceaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entendí de inmediato que el problema es que el contenedor de estas tres Vistas es LinearLayout. </font><font style="vertical-align: inherit;">Dentro de ellos hay una barra de herramientas, un fragmento con RecyclerView y en la parte inferior de la barra de navegación inferior. </font><font style="vertical-align: inherit;">LinearLayout toma a sus hijos en orden y les aplica inserciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que la barra de navegación inferior será la última. </font><font style="vertical-align: inherit;">Le dijo a alguien que procesó todas las inserciones, pero ya era demasiado tarde. </font><font style="vertical-align: inherit;">Todos los insertos se procesaron de arriba a abajo, RecyclerView ya los recibió, y esto no nos salva. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/mm/jd/ujmmjdgumv0bl6e0ewydx7ueq5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué hacer? </font><font style="vertical-align: inherit;">LinearLayout no funciona como yo quiero, los transfiere de arriba a abajo, y primero necesito obtener el inferior.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redefinir todo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El desarrollador de Java jugó en mí, ¡ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> necesita ser </font><strong><font style="vertical-align: inherit;">redefinido</font></strong><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Bueno, ahora </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redefinir, establecer </font></font><code>yLinearLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que siempre irá de abajo hacia arriba. </font><font style="vertical-align: inherit;">Primero enviará inserciones a la barra de navegación inferior y luego a todos los demás.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {     <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {        
        <span class="hljs-keyword">final</span> int count = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);<font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero me detuve a tiempo, recordando el comentario de que no había necesidad de redefinir este método. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, un poco más alto es la salvación: ViewGroup busca un delegado que procese las inserciones, luego llama al súper método en View y habilita su propio procesamiento. </font><font style="vertical-align: inherit;">En este código, obtenemos inserciones, y si aún no se han procesado, comenzamos la lógica estándar para nuestros hijos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribí una extensión simple. </font><font style="vertical-align: inherit;">Permite, aplicando </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a una Vista, decir a quién pasan estas inserciones.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">addSystemBottomPadding</span><span class="hljs-params">(    
    targetView: <span class="hljs-type">View</span> = this
)</span></span> {<font></font>
    doOnApplyWindowInsets { _, insets, initialPadding -&gt;           <font></font>
        targetView.updatePadding(<font></font>
            bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
        )<font></font>
        insets.replaceSystemWindowInsets(<font></font>
            Rect(<font></font>
                insets.systemWindowInsetLeft,<font></font>
                insets.systemWindowInsetTop,     <font></font>
                insets.systemWindowInsetRight,<font></font>
                <span class="hljs-number">0</span><font></font>
            )<font></font>
        )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es igual por defecto a la misma Vista sobre la cual aplicamos </font></font><code>addSystemBottomPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Podemos redefinirlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mi diseño lineal colgué un controlador de este tipo, pasando como </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: esta es mi barra de navegación inferior.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero le dará inserciones a la barra de navegación inferior.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso procesará las inserciones, devolverá el fondo cero.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, de manera predeterminada, irán de arriba a abajo: barra de herramientas, fragmento con RecyclerView.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, tal vez, enviará nuevamente insertos Barra de navegación inferior. </font><font style="vertical-align: inherit;">Pero esto ya no es importante, todo funcionará muy bien.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logré exactamente lo que quería: todas las inserciones se procesan en el orden en que se necesitan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/b0/nc/s3b0nc07bayude3nvrvevkxnwyc.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Importante</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunas cosas importantes a tener en cuenta. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El teclado es la interfaz de usuario del sistema en la parte superior de su aplicación.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No hay necesidad de tratarla de una manera especial. Si observa el teclado de Google, no es solo un diseño con botones en los que puede hacer clic. Hay cientos de modos para este teclado: búsqueda de gifs y memes, entrada de voz, cambio de tamaño de 10 píxeles de altura a tamaños de pantalla. No pienses en el teclado, sino suscríbete a las inserciones. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cajón de navegación aún no admite la navegación por gestos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En Google IO, prometieron que todo saldría de la caja. </font><font style="vertical-align: inherit;">Pero en Android 10, Navigation Drawer todavía no es compatible con esto. </font><font style="vertical-align: inherit;">Si actualiza a Android 10 y habilita la navegación con gestos, el cajón de navegación se caerá. </font><font style="vertical-align: inherit;">Ahora debe hacer clic en el menú de hamburguesas para que aparezca, o una combinación de circunstancias aleatorias le permite estirarlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la versión pre-alfa de Android, Navigation Drawer funciona, pero no me atreví a actualizarlo, esto es pre-alfa. </font><font style="vertical-align: inherit;">Por lo tanto, incluso si instala la última versión de GitFox desde el repositorio, hay un cajón de navegación allí, pero no se puede extraer. </font><font style="vertical-align: inherit;">Tan pronto como salga el soporte oficial, actualizaré y todo funcionará bien.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de verificación de preparación de Android 10</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establezca la transparencia de la barra de navegación y la barra de estado desde el comienzo del proyecto</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google recomienda encarecidamente mantener una barra de navegación transparente. Para nosotros, esta es una parte práctica importante. Si el proyecto funciona, pero no lo activó, tómese el tiempo para admitir Android 10. Actívelo primero en el tema, como translúcido, y corrija el diseño donde se rompió. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue extensiones a Kotlin</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : es más fácil con ellas. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Añadir a toda la barra de herramientas en la parte superior del relleno.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las barras de herramientas siempre están en la parte superior, y eso es lo que debe hacer. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para todas las RecyclerViews, agregue relleno desde la parte inferior</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y la capacidad de desplazarse </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piense en todos los botones en los bordes de la pantalla </font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(FAB)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo más probable es que las FAB no estén donde esperabas.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No anule ni realice sus propias implementaciones para todos LinearLayout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y otros casos similares. Haz el truco, como en GitFox, o toma mi extensión ya preparada para ayudar. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifique los gestos en los bordes de la pantalla para una vista personalizada</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Navigation Drawer no es compatible con esto. Pero no es tan difícil apoyarlo con las manos, redefinir las inserciones para los gestos en la pantalla con el cajón de navegación. Tal vez tienes editores de imágenes donde funcionan los gestos. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desplazarse en ViewPager no funciona desde el borde, sino solo desde el centro hacia la derecha y hacia la izquierda</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google dice que esto es normal. Si tira de ViewPager desde el borde, se percibe que presiona el botón "Atrás". </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un nuevo proyecto, incluya de inmediato toda la transparencia.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puede decirle a los diseñadores que no tiene una barra de navegación y una barra de estado. </font><font style="vertical-align: inherit;">Todo el cuadrado es el contenido de su aplicación. </font><font style="vertical-align: inherit;">Y los desarrolladores ya descubrirán dónde y qué recaudar. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces útiles:</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@rmr_spb en un telegrama: registros de mitaps internos de Redmadrobot SPb.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo el código fuente en este artículo y aún más en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hay una rama separada de Android 10, donde puedes ver confirmando cómo llegué a todo esto y cómo admití el nuevo Android.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">biblioteca de</font></a><font style="vertical-align: inherit;"> Chris Bane </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Insetter</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Contiene 5-6 extensiones que mostré. </font><font style="vertical-align: inherit;">Para usar en su proyecto, comuníquese con la biblioteca, lo más probable es que se traslade a Android Jetpack. </font><font style="vertical-align: inherit;">Los desarrollé en mi proyecto y, me parece, mejoraron.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">artículo de</font></a><font style="vertical-align: inherit;"> Chris Bane.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   FunCorn,    ,      .</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Why would I want to fitsSystemWindows?</a>»  .</li>
</ul><br>
<blockquote>    AppConf,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">youtube-</a>      .            ,     - .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a>     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>, stay tuned!</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488160/index.html">Windows Server 2019 vs. Instantáneas de VMware con inactividad: una solución elegante al problema</a></li>
<li><a href="../es488162/index.html">Cuanto mayor sea la calificación, más dinero y viceversa.</a></li>
<li><a href="../es488164/index.html">Batalla de la SEC contra Telegram</a></li>
<li><a href="../es488190/index.html">Una vez más sobre el agotamiento emocional</a></li>
<li><a href="../es488194/index.html">¿Por qué estamos escribiendo programas de tan mala calidad?</a></li>
<li><a href="../es488198/index.html">¿A qué le temen los Timlids y por qué deberían dejar de hacerlo?</a></li>
<li><a href="../es488200/index.html">El debate sobre el primer lenguaje de programación: la decisión final</a></li>
<li><a href="../es488202/index.html">PVS-Studio ahora está en Chocolatey: comprobando Chocolatey desde Azure DevOps</a></li>
<li><a href="../es488208/index.html">Aniversario DUMP2020 - 4 días que no olvidará</a></li>
<li><a href="../es488210/index.html">Reconocer objetos en Android usando TensorFlow: desde la preparación de datos hasta el lanzamiento en el dispositivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>