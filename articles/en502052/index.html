<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üèáüèΩ üåà Kubernetes best practices. Create small containers üçÆ üì∑ ‚èÆÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first step in deploying to Kubernetes is to place your application in a container. In this series, we will look at how you can create an image of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes best practices. Create small containers</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/502052/"><img src="https://habrastorage.org/webt/bc/pv/j4/bcpvj4erzyasxzahyvqqlrc7y04.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first step in deploying to Kubernetes is to place your application in a container. In this series, we will look at how you can create an image of a small and safe container. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to Docker, creating container images has never been easier. Specify the base image, add your changes and create a container. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i5/qe/jn/i5qejnsvy7prgkddy7b9cdfgeoo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although this technique is great for getting started, using basic images by default can lead to unsafe work with large images full of vulnerabilities.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, most images in Docker use Debian or Ubuntu as the base image, and although this provides excellent compatibility and easy adaptation (the Docker file takes only two lines of code), basic images can add hundreds of megabytes of extra load to your container. For example, a simple node.js file of the Go hello-world application takes about 700 megabytes, while the size of your application itself is only a few megabytes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/r-/eo/car-eo6tz-ovcb-nb3tfh8rifoa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, all this additional load is a waste of digital space and an excellent cache for vulnerabilities and errors in the security system. So let's look at two ways to reduce the size of a container image.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first is the use of basic images of small size, the second is the use of the design pattern Builder Pattern. Using smaller base images is probably the easiest way to reduce the size of your container. Most likely, your language or the stack you are using provides an original application image that is much smaller than the default image. Let's take a look at our container node.js.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wn/cl/xf/wnclxfmemicysaxmkdka2iecjiq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By default, in Docker, the size of the base node: 8 image is 670 MB, and the size of node: 8-alpine is only 65 MB, that is, 10 times smaller. Using the smaller Alpine base image will significantly reduce the size of your container. Alpine is a small and lightweight Linux distribution that is very popular among Docker users because it is compatible with many applications, while maintaining the small size of the containers. Unlike the standard Docker ‚Äúnode‚Äù image, ‚Äúnode: alpine‚Äù removes a lot of utility files and programs, leaving only those that are enough to run your application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To switch to a smaller base image, simply update the Docker file to start working with the new base image:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vn/om/20/vnom20vd5gb1c1wmwpgnwslrxf8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, unlike the old onbuild image, you need to copy your code into the container and install any dependencies. In the new Docker file, the container starts with the node: alpine image, then creates a directory for the code, installs dependencies using the NPM package manager, and finally starts server.js. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/x7/i3/_1/x7i3_14bs8tjo5kp-fsqh1kb5aw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this update, a container is 10 times smaller. If your programming language or stack does not have the ability to reduce the base image, use Alpine Linux. It will also provide the ability to fully manage the contents of the container. Using basic small-sized images is a great way to quickly create small containers. But you can achieve even greater reduction using the Builder Pattern.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uu/ad/ej/uuadejqnhgqhmg3-bsrcz5zvo5u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In interpreted languages, the source code is first passed to the interpreter and then directly executed. In compiled languages, the source code is first converted to compiled code. However, compilation often uses tools that are not really needed to run the code. This means that you can completely remove these tools from the final container. You can use the Builder Pattern for this. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5f/oj/nz/5fojnzzsh5ji6mumtiwgj1fquvm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code is created in the first container and compiled. Then, the compiled code is packaged in the final container without the compilers and tools needed to compile this code. Let's skip the Go app through this process. First, we will move from the onbuild image to Alpine Linux.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/ws/of/lswsofx6rz8wd9wo3pp7ptamwie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the new Docker file, the container starts with the golang: alpine image. He then creates a directory for the code, copies it to the source code, creates this source code and launches the application. This container is much smaller than the onbuild container, but it still contains the compiler and other Go tools that we don't really need. So let's just extract the compiled program and put it in our own container.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/xf/wy/sdxfwyghqamrsm-wuhaaxef4r4g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may notice something strange in this Docker file: it contains two FROM lines. The first section of 4 lines looks exactly the same as the previous Docker file, except that it uses the AS keyword to name this step. In the next section, there is a new FROM line that allows you to start a new image, and instead of the golang: alpine image, we will use Raw alpine as the base image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raw Alpine Linux does not have any SSL certificates installed, which will cause most HTTPS API calls to fail, so let's install some CA root certificates.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now the most interesting: to copy the compiled code from the first container to the second, you can simply use the COPY command located on the 5th line of the second section. It will copy only one application file and will not affect Go utility tools. The new multi-stage Docker file will contain a container image of only 12 megabytes in size, while the original container image was 700 megabytes, and this is a big difference! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, using small basic images and Builder Patterns are great ways to create much smaller containers without a lot of work.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is possible that depending on the application stack, there are additional ways to reduce the size of the image and the container, but do small containers really have a measurable advantage? Let's look at two aspects where small containers are extremely effective - performance and security. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To evaluate the performance increase, consider the duration of the process of creating a container, inserting it into the registry (push) and then retrieving from there (pull). You can see that a smaller container has an undeniable advantage over a larger container.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vk/0b/d0/vk0bd0bv3wcsxd-mv5xhmfntypk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Docker will cache the layers, so subsequent builds will be very fast. However, in many CI systems that are used to build and test containers, layers are not cached, so there is significant time savings. As you can see, the time to build a large container, depending on the power of your machine, is from 34 to 54 seconds, and when using a container reduced with the Builder Pattern, from 23 to 28 seconds. For operations of this kind, productivity gains will be 40-50%. So just think how many times you create and test your code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the container is built, you need to insert its image (push container image) into the container registry in order to use Kubernetes in your cluster. I recommend using the Google container registry.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8j/x2/nc/8jx2ncmiv6r6op7ii8yn7di00ru.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the Google Container Registry (GCR), you pay only for the raw storage and network, and there is no additional container management fee. It is confidential, secure and very fast. GCR uses many tricks to speed up the pull operation. As you can see, inserting a Docker Container Image container image using go: onbuild, depending on computer performance, will take from 15 to 48 seconds, and the same operation with a smaller container will take from 14 to 16 seconds, and for less efficient machines the advantage in operation speed increases by 3 times. For large machines, the time is approximately the same, since GCR uses the global cache for a common database of images, that is, you do not need to download them at all. In a low-power computer, the CPU is a bottleneck,therefore, the advantage of using small containers here is much more tangible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you use GCR, I highly recommend using Google Container Builder (GCB) as part of your build system. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/td/fp/b8/tdfpb8jpar4jfjk0ifhsd1ja8sa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, using it allows you to achieve much better results in reducing the duration of the Build + Push operation than even a productive machine - in this case, the process of building and sending containers to the host is almost 2 times faster. In addition, every day you get 120 minutes of assembly for free, which in most cases meets the needs of creating containers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next comes the most important performance metric - the speed at which you retrieve or download Pull containers. And if you don‚Äôt really care about the time spent on the push operation, then the duration of the pull process seriously affects the overall performance of the system. Suppose you have a cluster of three nodes and one of them crashes. If you use a management system, such as Google Kubernetes Engine, it will automatically replace the idle node with a new one. However, this new node will be completely empty, and you will have to drag all your containers into it to get it working. If the pull operation is long enough, then all this time your cluster will work with lower performance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many cases where this can happen: adding a new node to a cluster, updating nodes, or even switching to a new container for deployment. Thus, minimizing pull extraction time becomes a key factor. It is indisputable that a small container downloads much faster than a large one. If you use multiple containers in a Kubernetes cluster, saving time can be very significant. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9n/lv/1d/9nlv1dlgiem9o83xxuwyqu-kqje.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take a look at the comparison: the pull operation when working with small containers takes 4-9 times less time depending on the power of the machine than the same operation using go: onbuild. Using common basic images of small container containers greatly speeds up the time and speed with which new Kubernetes nodes can deploy and go online.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the issue of security. Smaller containers are thought to be much safer than large containers because they have a smaller attack surface. Is it really? One of the most useful features of the Google Container Registry is the ability to automatically scan your containers for vulnerabilities. A few months ago, I created both onbuild and multi-stage containers, so let's see if there are any vulnerabilities there.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b-/hy/n3/b-hyn3ocsdqhydufmjpfef5rgv0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result is amazing: only 3 medium vulnerabilities were found in a small container, and 16 critical and 376 other vulnerabilities in a large one. </font><font style="vertical-align: inherit;">If you look at the contents of a large container, you can see that most security problems have nothing to do with our application, but are related to programs that we don‚Äôt even use. </font><font style="vertical-align: inherit;">So when people talk about a large surface for attacks, they mean exactly that. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/tw/ba/xwtwbakf57ubzw_ivsbycxzpzk4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The conclusion is obvious: create small containers because they provide real benefits in the performance and security of your system. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes best practices. </font><font style="vertical-align: inherit;">Kubernetes organization with namespace</font></font></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wGz_cbtCiEA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of advertising :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for staying with us. Do you like our articles? Want to see more interesting materials? Support us by placing an order or recommending to your friends, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud VPS for developers from $ 4.99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique analog of entry-level servers that was invented by us for you: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The whole truth about VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps from $ 19 or how to divide the server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 times cheaper at the Equinix Tier IV data center in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only we have </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV from $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the Netherlands!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - from $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read about</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to Build Infrastructure Bldg. </font><font style="vertical-align: inherit;">class c using Dell R730xd E5-2650 v4 servers costing 9,000 euros for a penny?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502040/index.html">About Phrasal Verbs-5 (up / down)</a></li>
<li><a href="../en502042/index.html">Interview with Analyst - Alexander Sibrikov, Product Manager at AppMetrica</a></li>
<li><a href="../en502046/index.html">Five years Rust</a></li>
<li><a href="../en502048/index.html">Complex behavior without neural networks and training. The philosophical basis</a></li>
<li><a href="../en502050/index.html">A few notes about Culture</a></li>
<li><a href="../en502054/index.html">Convolutional neural network and its integration in iOS (part 2)</a></li>
<li><a href="../en502056/index.html">How to Build a Smart Home and Not Go Crazy</a></li>
<li><a href="../en502066/index.html">Simple console commands that everyone should know</a></li>
<li><a href="../en502068/index.html">110 volts on your computer</a></li>
<li><a href="../en502070/index.html">The history of Pentax (article plus video)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>