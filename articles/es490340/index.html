<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👖 🙋🏿 👩‍👦 Ir zen 🕖 🔛 🐄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al evaluar mi trabajo, recientemente pensé mucho sobre cómo escribir un buen código. Dado que a nadie le interesa cómo escribir un código incorrecto ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ir zen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/490340/"><img src="https://habrastorage.org/webt/kr/ic/9k/kric9kwqdonbm71t_zw5b35ui4o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al evaluar mi trabajo, recientemente pensé mucho sobre cómo escribir un buen código. </font><font style="vertical-align: inherit;">Dado que a nadie le interesa cómo escribir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> código </font><i><font style="vertical-align: inherit;">incorrecto</font></i><font style="vertical-align: inherit;"> , surge la pregunta: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿cómo sabe si escribió un buen código en Go</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Si hay algún tipo de escala entre el bien y el mal, ¿cómo entender qué partes de la escala pertenecen al bien? </font><font style="vertical-align: inherit;">¿Cuáles son sus propiedades, atributos, características distintivas, patrones y modismos?</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ir idiomático</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas consideraciones me llevaron al Go idiomático. </font><font style="vertical-align: inherit;">Si llamamos a algo "idiomático", entonces este algo corresponde a un cierto estilo de algún tiempo. </font><font style="vertical-align: inherit;">Si algo no es idiomático, entonces no corresponde al estilo dominante. </font><font style="vertical-align: inherit;">Eso no está de moda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Más importante aún, cuando decimos que el código de alguien no es idiomático, esto no explica la razón. </font><font style="vertical-align: inherit;">¿Por qué no idiomático? </font><font style="vertical-align: inherit;">La respuesta la da el diccionario.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiom (n.): Una revolución del habla, utilizada como un todo, no sujeta a una mayor descomposición y generalmente no permite permutaciones dentro de sí misma.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los modismos son sellos de significados comunes. </font><font style="vertical-align: inherit;">Los libros no te enseñarán el Go idiomático; solo se sabe cuando te conviertes en parte de una comunidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me preocupa el idiomático Go mantra porque a menudo es restrictivo. </font><font style="vertical-align: inherit;">Ella dice: "no puedes sentarte con nosotros". </font><font style="vertical-align: inherit;">¿No es eso lo que queremos decir cuando criticamos el trabajo de otra persona como "no idiomático"? </font><font style="vertical-align: inherit;">Lo hicieron mal. </font><font style="vertical-align: inherit;">Esto no se ve bien. </font><font style="vertical-align: inherit;">Esto no coincide con el estilo de la época. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que el Go idiomático no es adecuado para enseñar a escribir un buen código, porque, en esencia, significa decirle a la gente que hicieron algo mal. </font><font style="vertical-align: inherit;">Es mejor dar ese consejo que no aleje a una persona en el momento en que más quiera recibir este consejo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refranes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a distraernos de los problemas idiomáticos. </font><font style="vertical-align: inherit;">¿Qué otros artefactos culturales son inherentes a los programadores de Go? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dirígete</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la hermosa página </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Go Proverbios</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">¿Son estos dichos una herramienta de aprendizaje adecuada? </font><font style="vertical-align: inherit;">¿Les dicen a los principiantes cómo escribir un buen código Go? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No lo creo. </font><font style="vertical-align: inherit;">No quiero menospreciar el trabajo del autor. </font><font style="vertical-align: inherit;">Los dichos que compuso son meras observaciones, no definiciones de significados. </font><font style="vertical-align: inherit;">El diccionario viene al rescate nuevamente:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proverbio (n.): Una declaración breve que tiene un significado literal o figurado.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La misión de Go Proverbios es mostrar la profunda esencia de la arquitectura del lenguaje. </font><font style="vertical-align: inherit;">¿Pero será útil dar consejos como "La </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interfaz vacía no dice nada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " a un principiante que vino de un idioma sin tipeo estructural? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una comunidad en crecimiento, es importante reconocer que la cantidad de estudiantes de Go es mucho mayor que la cantidad de aquellos que dominan este idioma. </font><font style="vertical-align: inherit;">Es decir, los dichos probablemente no sean la mejor manera de aprender en tal situación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores de diseño</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan Liu encontró </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una vieja presentación de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mark Lukowski sobre la cultura del diseño en el equipo de desarrollo de Windows NT-Windows 2000. Mencioné esto porque Lukowski describe la cultura como una forma común de evaluar arquitecturas y hacer compromisos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0d/487/0cba0d4873afc7945a74500669efd389.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea principal es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomar decisiones basadas en valores dentro de una arquitectura desconocida</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El equipo de NT tenía estos valores: portabilidad, confiabilidad, seguridad y extensibilidad. </font><font style="vertical-align: inherit;">En pocas palabras, los valores de diseño son una forma de resolver problemas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ir valores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cuáles son los valores explícitos de Go? </font><font style="vertical-align: inherit;">¿Cuáles son los conceptos o filosofías clave que determinan cómo los programadores de Go interpretan el mundo? </font><font style="vertical-align: inherit;">¿Cómo se proclaman? </font><font style="vertical-align: inherit;">¿Cómo se les enseña? </font><font style="vertical-align: inherit;">¿Cómo se siguen? </font><font style="vertical-align: inherit;">¿Cómo cambian con el tiempo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo se convierte un programador Go para obtener los valores del diseño Go? </font><font style="vertical-align: inherit;">¿O cómo usted, un experimentado Go-pro, proclama sus valores a las generaciones futuras? </font><font style="vertical-align: inherit;">Y para que entiendas, ¿este proceso de transferencia de conocimiento no es opcional? </font><font style="vertical-align: inherit;">Sin la afluencia de nuevos participantes y nuevas ideas, nuestra comunidad se vuelve miope y se marchita.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores de otros idiomas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para preparar el camino para lo que quiero decir, podemos prestar atención a otros idiomas, a sus valores de diseño. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, en C ++ y Rust se cree que un programador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no debe pagar por una función que no utiliza</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si el programa no utiliza alguna función del lenguaje que requiere muchos recursos, entonces no se puede obligar al programa a asumir el costo de mantener esta función. Este valor se proyecta desde el lenguaje en la biblioteca estándar y se utiliza como criterio para evaluar la arquitectura de todos los programas escritos en C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valor principal en Java, Ruby y Smalltalk: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo es un objeto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este principio subyace en el diseño del programa en términos de transferencia de mensajes, ocultación de información y polimorfismo. </font><font style="vertical-align: inherit;">Las arquitecturas que se ajustan a un paradigma procesal o funcional se consideran erróneas en estos lenguajes. </font><font style="vertical-align: inherit;">O, como diría un programador de Go, no idiomático. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volvamos a nuestra comunidad. </font><font style="vertical-align: inherit;">¿Qué valores de diseño profesan los programadores de Go? </font><font style="vertical-align: inherit;">Las discusiones sobre este tema a menudo están fragmentadas, por lo que no es fácil formular un conjunto de significados. </font><font style="vertical-align: inherit;">Es imperativo llegar a un acuerdo, pero la dificultad de alcanzarlo crece exponencialmente con el creciente número de participantes en la discusión. </font><font style="vertical-align: inherit;">Pero, ¿y si alguien hiciera este trabajo difícil para nosotros?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace unas décadas, Tim Peters se sentó y escribió </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP-20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El Zen de Python</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Trató de documentar los valores de diseño a los que Guido Van Rossum se adhirió como el dictador Python generoso de por vida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Miremos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Zen of Python</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y veamos si podemos aprender algo sobre los valores de diseño del diseñador Go.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un buen paquete comienza con un buen nombre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con el filoso:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los espacios de nombres son una gran idea, ¡hagámoslos más grandes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python, récord 19.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin ambigüedades: los programadores de Python deberían usar espacios de nombres. Muchos espacios </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la terminología Go, un espacio de nombres es un paquete. No hay duda de que la agrupación favorece el diseño y la reutilización. Pero puede haber confusión sobre cómo hacer esto, especialmente si tiene muchos años de experiencia en programación en otro idioma. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Go, cada paquete debe estar diseñado para algo. Y el nombre es la mejor manera de entender este destino. Reformulando los pensamientos de Peteres, cada paquete en Go debe estar diseñado para una cosa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea no es nueva, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya he hablado de esto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero, ¿por qué debería usarse este enfoque, y no otro, en el que los paquetes se usan para las necesidades de una clasificación detallada? Se trata de los cambios.</font></font><br>
<br>
<blockquote> —    ,         .<br>
<br>
 </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cambio es el nombre del juego en el que estamos participando. Nosotros, como programadores, gestionamos el cambio. Si lo hacemos bien, lo llamamos arquitectura. Y si es malo, entonces lo llamamos deuda técnica o código heredado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si escribe un programa que funciona muy bien una vez con un conjunto fijo de datos de entrada, entonces a nadie le interesará si tiene un buen código, porque solo el resultado de su trabajo es importante para los negocios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero esto </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no sucede</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hay errores en los programas, los requisitos y el cambio de datos de entrada, y muy pocos programas se escriben con una sola expectativa de ejecución. Es decir, el programa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cambiar con el tiempo. Tal vez esta tarea le sea asignada, pero lo más probable es que alguien más lo haga. Alguien debe acompañar este código.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo facilitamos el cambio de programas? </font><font style="vertical-align: inherit;">Añadir interfaces en todas partes? </font><font style="vertical-align: inherit;">¿Todo lo adecuado para crear trozos? </font><font style="vertical-align: inherit;">¿Desplegar dependencias estrechamente? </font><font style="vertical-align: inherit;">Quizás, para algunos tipos de programas, estas técnicas son adecuadas, pero no para muchos. </font><font style="vertical-align: inherit;">Sin embargo, para la mayoría de los programas, crear una arquitectura flexible es más que un diseño. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Y si en lugar de expandir los componentes los reemplazaremos? </font><font style="vertical-align: inherit;">Si el componente no hace lo que se especifica en las instrucciones, entonces es hora de cambiarlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un buen paquete comienza con la elección de un buen nombre. </font><font style="vertical-align: inherit;">Considérelo una breve presentación que describe la función de un paquete con una sola palabra. </font><font style="vertical-align: inherit;">Y cuando el nombre ya no cumpla con el requisito, busque un reemplazo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La simplicidad importa</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple es mejor que complejo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python, entrada 3.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PEP-20 afirma que lo simple es mejor que lo complejo, y estoy completamente de acuerdo. </font><font style="vertical-align: inherit;">Hace unos años escribí:</font></font><br>
<br>
<div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="539576755254611968"></twitter-widget>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayoría de los lenguajes de programación intentan ser simples al principio, pero luego deciden ser poderosos.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según mis observaciones, al menos en ese momento, no podía recordar un idioma que sabía que no se consideraría tan simple. Como justificación y tentación, los autores de cada nuevo idioma declararon simplicidad. Pero descubrí que la simplicidad no era el valor central de muchos idiomas de la misma edad que Go (Ruby, Swift, Elm, Go, NodeJS, Python, Rust). Tal vez esto llegue a un punto doloroso, pero tal vez la razón es que ninguno de estos idiomas es simple. O sus autores no los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consideraron</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples. La simplicidad no se incluyó en la lista de valores centrales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes considerarme anticuado, pero ¿cuándo pasó de moda esta simplicidad? ¿Por qué la industria del software comercial olvida constantemente y con alegría esta verdad fundamental?</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos formas de crear una arquitectura de software: hacerla tan simple que la falta de fallas sea obvia, y hacerla tan compleja que no tenga fallas obvias. </font><font style="vertical-align: inherit;">El primer método es mucho más difícil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Charles Hoar, The Emperor's Old Clothes, Turing Award Lecture, 1980</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simple no significa fácil, lo sabemos. </font><font style="vertical-align: inherit;">A menudo se necesita más esfuerzo para garantizar la facilidad de uso, en lugar de la facilidad de creación.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La simplicidad es la clave de la fiabilidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Edsger Dijkstra, EWD498, 18 de junio de 1975</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué luchar por la simplicidad? </font><font style="vertical-align: inherit;">¿Por qué es importante que los programas Go sean simples? </font><font style="vertical-align: inherit;">Simple significa crudo, significa legible y fácil de seguir. </font><font style="vertical-align: inherit;">Simple no significa descuidado, significa confiable, inteligible y comprensible.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El núcleo de la programación es la gestión de la complejidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brian Kernigan, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herramientas de software</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1976)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si Python sigue su mantra de simplicidad es una cuestión discutible. </font><font style="vertical-align: inherit;">En Go, sin embargo, la simplicidad es un valor central. </font><font style="vertical-align: inherit;">Creo que todos estaremos de acuerdo en que en Go el código simple es preferible al código inteligente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evitar estados a nivel de paquete</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explícito es mejor que implícito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python, entrada 2</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, Peters, en mi opinión, más bien sueña que se adhiere a los hechos. En Python, mucho no es explícito: decoradores, métodos dunder, etc. Sin lugar a dudas, estas son herramientas poderosas, y existen por una razón. En la implementación de cada característica, especialmente compleja, alguien trabajó. Pero el uso activo de tales características hace que sea difícil evaluar el costo de la operación al leer el código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente, los programadores de Go Go pueden hacer que el código sea explícito. Quizás, para usted, la manifestación puede ser sinónimo de burocracia y verbosidad, pero esta es una interpretación superficial. Será un error enfocarse solo en la sintaxis, cuidar la longitud de las líneas y la aplicación de los principios DRY a las expresiones. Me parece más importante proporcionar explícitamente en términos de conectividad y estados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conectividad es una medida de la dependencia de uno sobre el otro. Si uno está estrechamente relacionado con el otro, ambos se mueven juntos. Una acción que afecta a uno se refleja directamente en el otro. Imagine un tren en el que todos los vagones están conectados, o mejor dicho, conectados entre sí. Donde va el tren de vapor, están los vagones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conectividad también se puede describir con el término cohesión - cohesión. Esta es una medida de cuánto pertenece uno al otro. En un equipo soldado, todos los participantes están tan adaptados entre sí, como si hubieran sido creados especialmente de esa manera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué es importante la coherencia? Como en el caso del tren, cuando necesita cambiar un código, debe cambiar el resto del código estrechamente relacionado. Por ejemplo, alguien ha lanzado una nueva versión de su API, y ahora su código no se compila.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una API es una fuente inevitable de enlace. Pero puede presentarse en formas más insidiosas. Todos saben que si la firma de la API ha cambiado, los datos transferidos hacia y desde la API también cambiarán. Se trata de la firma de la función: tomo los valores de un tipo y devuelvo los valores de otros tipos. ¿Y si la API comienza a transferir datos de una manera diferente? ¿Qué sucede si el resultado de cada llamada a la API depende de la llamada anterior, incluso si no cambió su configuración? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se llama estado, y la gestión estatal es un problema en informática.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> counter<font></font>
<font></font>
<span class="hljs-keyword">var</span> count <span class="hljs-keyword">int</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Increment</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {<font></font>
        count += n<font></font>
        <span class="hljs-keyword">return</span> count<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí tenemos un paquete simple </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para cambiar el contador, puede llamar </font></font><code>Increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluso puede recuperar el valor si aumenta con un valor cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que necesitas probar este código. ¿Cómo restablecer el contador después de cada prueba? Y si desea ejecutar pruebas en paralelo, ¿cómo se puede hacer esto? Y supongamos que desea utilizar varios contadores en el programa, ¿lo logrará? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto no. Obviamente, la solución es encapsular la variable </font></font><code>variable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el tipo.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> counter<font></font>
<font></font>
<span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> {<font></font>
        count <span class="hljs-keyword">int</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">Increment</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {<font></font>
        c.count += n<font></font>
        <span class="hljs-keyword">return</span> c.count<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora imagine que el problema descrito no se limita a los contadores, sino que también afecta la lógica comercial principal de sus aplicaciones. </font><font style="vertical-align: inherit;">¿Se puede probar de forma aislada? </font><font style="vertical-align: inherit;">¿Se puede probar en paralelo? </font><font style="vertical-align: inherit;">¿Se pueden usar varias instancias al mismo tiempo? </font><font style="vertical-align: inherit;">Si la respuesta es no para todas las preguntas, entonces la razón es el estado a nivel de paquete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Evita estas condiciones. </font><font style="vertical-align: inherit;">Reduzca la conectividad y el número de acciones remotas de pesadilla al proporcionar tipos con las dependencias que necesitan como campos, en lugar de usar variables de paquete.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haga planes para el fracaso, no para el éxito</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca pase errores en silencio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python, entrada 10</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se dice sobre los idiomas que fomentan el manejo de excepciones al estilo samurai: regresa con una victoria o no regreses en absoluto. En idiomas basados ​​en excepciones, las funciones solo devuelven resultados válidos. Si la función no puede hacer esto, entonces el flujo de control va de una manera completamente diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, las excepciones no verificadas son un modelo de programación inseguro. ¿Cómo puede escribir código confiable en presencia de errores si no sabe qué expresiones pueden generar una excepción? Java intenta reducir los riesgos con el concepto de excepciones marcadas. Y hasta donde sé, en otros idiomas populares no hay análogos de esta solución. Hay excepciones en muchos idiomas, y en todas partes, excepto Java, no están marcadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, Go tomó un camino diferente. </font><font style="vertical-align: inherit;">Los programadores de Go creen que los programas confiables están compuestos de partes que manejan fallas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procesar rutas exitosas. </font><font style="vertical-align: inherit;">Dado que el lenguaje fue creado para el desarrollo del servidor, la creación de programas multiproceso, así como los programas que procesan los datos que ingresan a través de la red, los programadores deben centrarse en trabajar con datos inesperados y dañados, tiempos de espera y fallas de conexión. </font><font style="vertical-align: inherit;">Por supuesto, si quieren hacer productos confiables.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que los errores deben manejarse explícitamente, este debería ser el valor principal del lenguaje. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peter Burgon, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GoTime # 91</font></font></a></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me uno a las palabras de Peter, sirvieron de impulso a la redacción de este artículo. </font><font style="vertical-align: inherit;">Creo que Go debe su éxito al manejo explícito de errores. </font><font style="vertical-align: inherit;">Los programadores piensan principalmente en posibles bloqueos. </font><font style="vertical-align: inherit;">Primero, resolvemos problemas como "y si". </font><font style="vertical-align: inherit;">El resultado son programas en los que las fallas se manejan en la etapa de escribir código, y no como suceden durante la operación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La verbosidad de este código.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supera la importancia de manejar deliberadamente cada estado fallido en el momento en que ocurre. </font><font style="vertical-align: inherit;">La clave para esto es el valor de manejar explícitamente cada error.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es mejor regresar temprano que invertir profundamente</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hermano es mejor que anidar </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python, entrada 5</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este sabio consejo proviene de un lenguaje en el que la sangría es la forma principal de flujo de control. ¿Cómo interpretamos este consejo en la terminología de Go? gofmt administra la cantidad total de espacio vacío en los programas Go, por lo que no tenemos nada que hacer aquí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribí arriba sobre los nombres de los paquetes. Quizás sea aconsejable evitar una jerarquía compleja de paquetes. En mi experiencia, cuanto más intenta un programador separar y clasificar una base de código en Go, mayor es el riesgo de importación cíclica de paquetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que el mejor uso de la quinta entrada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Zen of Python</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es crear un flujo de control </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro de una</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> función. En otras palabras, evite un flujo de control que requiera una sangría de varios niveles.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visibilidad directa es una línea recta a lo largo de la cual nada oculta la vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
May Ryer, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código: alinee la ruta feliz al borde izquierdo</font></font></a></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
May Ryer describe esta idea como programación en línea de visión directa:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilice las declaraciones de control para regresar antes si no se cumple la condición previa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocando la declaración de retorno exitoso al final de la función, y no dentro del bloque condicional.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduzca el nivel general de anidamiento mediante la extracción de funciones y métodos.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intente asegurarse de que las funciones importantes nunca se muevan fuera de la línea de visión al borde derecho de la pantalla. </font><font style="vertical-align: inherit;">Este principio tiene un efecto secundario: evitará disputas sin sentido con el equipo sobre la longitud de las líneas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada vez que sangra, agrega una condición previa más a los jefes de los programadores, ocupando una de sus 7 ± 2 ranuras de memoria a corto plazo. </font><font style="vertical-align: inherit;">En lugar de profundizar el anidamiento, intente mantener la ruta exitosa de la función lo más cerca posible del lado izquierdo de la pantalla.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si crees que algo funciona lentamente, pruébalo con un punto de referencia</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renunciar a la tentación de adivinar ante la ambigüedad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python 12</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programación se basa en las matemáticas y la lógica. </font><font style="vertical-align: inherit;">Estos dos conceptos rara vez usan el elemento de la suerte. </font><font style="vertical-align: inherit;">Pero nosotros, como programadores, hacemos numerosas suposiciones todos los días. </font><font style="vertical-align: inherit;">¿Qué hace esta variable? </font><font style="vertical-align: inherit;">¿Qué hace esta opción? </font><font style="vertical-align: inherit;">¿Qué pasa si paso cero aquí? </font><font style="vertical-align: inherit;">¿Qué sucede si llamo a la caja registradora dos veces? </font><font style="vertical-align: inherit;">En la programación moderna, debes asumir mucho, especialmente cuando usas las bibliotecas de otras personas.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La API debe ser fácil de usar y difícil de usar incorrectamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Josh Bloch</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las mejores formas que he conocido para ayudar a un programador a evitar adivinar cuando crea una API es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">centrarse en los métodos de uso estándar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La persona que llama debe poder realizar operaciones normales con la mayor facilidad posible. Sin embargo, antes de escribir mucho y hablar sobre el diseño de la API, aquí está mi interpretación del registro 12: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no adivine sobre el tema del rendimiento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de su actitud ante el consejo de Knut, una de las razones del éxito de Go es la efectividad de su ejecución. Los programas eficaces se pueden escribir en este idioma, y gracias a esto, la gente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elige ir. </font><font style="vertical-align: inherit;">Hay muchos conceptos erróneos relacionados con el rendimiento. </font><font style="vertical-align: inherit;">Por lo tanto, cuando esté buscando formas de mejorar el rendimiento del código, o siga consejos dogmáticos como "ralentizar las estanterías", "CGO es costoso" o "siempre use operaciones atómicas en lugar de mutexes", no haga adivinación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No complique su código debido a dogmas obsoletos. </font><font style="vertical-align: inherit;">Y si crees que algo funciona lentamente, primero asegúrate de hacerlo con la ayuda de un punto de referencia. </font><font style="vertical-align: inherit;">Go tiene excelentes herramientas gratuitas de evaluación comparativa y creación de perfiles. </font><font style="vertical-align: inherit;">Úselos para encontrar cuellos de botella en el rendimiento de su código.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar gorutin, averigüe cuándo se detendrá</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que he enumerado los artículos valiosos de PEP-20 y quizás expandí su interpretación más allá del buen gusto. </font><font style="vertical-align: inherit;">Esto es bueno, porque aunque este es un dispositivo retórico útil, todavía estamos hablando de dos idiomas diferentes.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escriba g, o, un espacio y luego una llamada a la función. </font><font style="vertical-align: inherit;">Tres botones presionados, no puede ser más corto. </font><font style="vertical-align: inherit;">Tres clics de botón, y usted lanzó el subproceso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rob Pike, la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplicidad es complicada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dotGo 2015</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes dos consejos los dedico a los goroutines. Las gorutinas son un rasgo característico del lenguaje, nuestra respuesta a la competitividad de alto nivel. Son muy fáciles de usar: coloque una palabra </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delante del operador y ejecute la función de forma asincrónica. Sin hilos de ejecución, sin ejecutores de grupo, sin ID, sin seguimiento del estado de finalización. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las gorutinas son baratas. Debido a la capacidad del entorno de tiempo de ejecución para multiplexar goroutines en un pequeño número de subprocesos de ejecución (que no necesita administrar), puede crear fácilmente cientos de miles o millones de goroutines. Esto le permite crear arquitecturas que serían poco prácticas al usar otros modelos competitivos, en forma de hilos de ejecución o devoluciones de llamadas de eventos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero no importa cuán baratas sean las gorutinas, no son gratuitas. Su pila toma al menos unos kilobytes. Y cuando tienes millones de gorutinas, se vuelve notable. No quiero decir que no necesites usar millones de gorutinas, si la arquitectura te empuja a esto. Pero si lo usa, es extremadamente importante controlarlos, ya que en tales cantidades las gorutinas pueden consumir muchos recursos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las goroutinas son la principal fuente de propiedad de Go. Para ser útil, goroutine debe hacer algo. Es decir, casi siempre contiene un enlace a un recurso, es decir, información de propiedad: bloqueo, conexión de red, búfer de datos que envía el final del canal. Mientras goroutine vive, el bloqueo se mantiene, la conexión permanece abierta, el búfer se guarda y los destinatarios del canal esperarán nuevos datos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma más sencilla de liberar recursos es vincularlos con el ciclo de vida de la rutina. </font><font style="vertical-align: inherit;">Cuando se completa, los recursos se liberan. </font><font style="vertical-align: inherit;">Y dado que es muy fácil ejecutar goroutine, antes de escribir "go and space" asegúrese de tener respuestas a estas preguntas:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Bajo qué condición se detiene la gorutina? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ir no puede decirle a la rutina que termine. </font><font style="vertical-align: inherit;">Por una razón específica, no hay función para detener o interrumpir. </font><font style="vertical-align: inherit;">No podemos ordenar que las goroutines se detengan, pero podemos pedir cortésmente. </font><font style="vertical-align: inherit;">Esto casi siempre está relacionado con el funcionamiento del canal. </font><font style="vertical-align: inherit;">Cuando está cerrado, el rango se enlaza para salir del canal. </font><font style="vertical-align: inherit;">Al cerrar el canal, puede seleccionarlo. </font><font style="vertical-align: inherit;">La señal de una rutina a otra se expresa mejor como un canal cerrado.</font></font></li>
<li><strong>    ?</strong>          ,        ,   :        ?</li>
<li><strong>     ,   ?</strong>     ,    -       .        ,       .           .          ,        .</li>
</ul><br>
<h2>  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente en cualquiera de sus programas Go serios, se use la concurrencia. Esto a menudo conduce al problema de un patrón de trabajo: una rutina por conexión. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un buen ejemplo es net / http. Es bastante simple detener el servidor que posee el socket de escucha, pero ¿qué pasa con las goroutines que genera este socket? net / http proporciona un objeto de contexto dentro del objeto de solicitud que puede usarse para decirle al oyente que la solicitud debe cancelarse y, por lo tanto, interrumpir la rutina. Pero no está claro cómo averiguar cuándo debe hacerse todo esto. Una cosa es llamar </font></font><code>context.Cancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, otra saber que la cancelación se ha completado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A menudo encuentro fallas en net / http, pero no porque sea malo. Por el contrario, es la API más exitosa, más antigua y más popular en la base de código Go. Por lo tanto, su arquitectura, evolución y defectos se analizan cuidadosamente. Considere esta adulación, no crítica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, quiero traer net / http como un contraejemplo de buenas prácticas. Como cada conexión es procesada por el goroutin creado dentro del tipo </font></font><code>net/http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el programa fuera del paquete net / http no puede controlar los goroutins creados por el socket receptor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta área de la arquitectura aún está en desarrollo. Puede recuperar </font></font><code>run.Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el go-kit, o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ErrGroup,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del equipo de desarrollo de Go, que proporciona un marco para ejecutar, cancelar y esperar funciones ejecutadas asincrónicamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todos los que escriben código que se puede ejecutar de forma asíncrona, el principio principal de la creación de arquitecturas es que la responsabilidad de ejecutar goroutines debe pasar a la persona que llama. </font><font style="vertical-align: inherit;">Deje que elija cómo quiere correr, rastrear y esperar a que se completen sus funciones.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escriba pruebas para bloquear el comportamiento de su paquete API</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es posible que haya esperado que en este artículo no mencione las pruebas. Lo siento, en otro momento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sus pruebas son un acuerdo sobre lo que hace su programa y lo que no. Las pruebas unitarias deberían bloquear el comportamiento de sus API a nivel de paquete. Las pruebas describen en forma de código lo que promete hacer el paquete. Si hay una prueba unitaria para cada conversión de entrada, entonces usted, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en forma de código</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y no de documentación, ha definido un acuerdo sobre lo que hará el código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprobar este acuerdo es tan simple como escribir un examen. En cualquier etapa, puede </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declarar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con un alto grado de confianza </font><font style="vertical-align: inherit;">que el comportamiento en el que confiaban las personas antes de los cambios que realizó continuará funcionando después de los cambios.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pruebas bloquean el comportamiento de la API. </font><font style="vertical-align: inherit;">Cualquier cambio que agregue, cambie o elimine la API pública debe incluir cambios en las pruebas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La moderación es una virtud.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go es un lenguaje simple con solo 25 palabras clave. </font><font style="vertical-align: inherit;">En cierto modo, esto destaca las características integradas en el lenguaje. </font><font style="vertical-align: inherit;">Estas son las características que permiten que el lenguaje se promueva a sí mismo: competencia simple, mecanografía estructural, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que todos estamos confundidos al tratar de usar todas las funciones de Go a la vez. </font><font style="vertical-align: inherit;">¿Cuántos de ustedes estaban tan inspirados por el uso de canales que los usaron siempre que pudieron? </font><font style="vertical-align: inherit;">Descubrí que los programas resultantes son difíciles de probar, son frágiles y demasiado complejos. </font><font style="vertical-align: inherit;">¿Y tu?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tuve la misma experiencia con goroutines. Intentando dividir el trabajo en pequeños fragmentos, creé la oscuridad de goroutin, que era difícil de controlar, y perdí de vista por completo el hecho de que la mayoría de ellos siempre estaban bloqueados debido a la expectativa de sus predecesores de completar el trabajo. El código era completamente consistente y tuve que aumentar considerablemente la complejidad para obtener una pequeña ventaja. ¿Cuántos de ustedes han encontrado esto? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tuve lo mismo con la incrustación. Al principio lo confundí con la herencia. Luego se topó con el problema de una clase base frágil, combinando varios tipos complejos que ya tenían varias tareas en tipos enormes aún más complejos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este puede ser el consejo menos efectivo, pero considero importante mencionarlo. </font><font style="vertical-align: inherit;">El consejo es el mismo: mantener la moderación, y las capacidades de Go no son una excepción. </font><font style="vertical-align: inherit;">Siempre que sea posible, no use goroutines, canales, estructuras de incrustación, funciones anónimas, una gran cantidad de paquetes e interfaces. </font><font style="vertical-align: inherit;">Use soluciones más simples que las inteligentes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Facilidad de mantenimiento.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, te daré otra entrada de PEP-20:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La legibilidad importa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El zen de Python, récord 7</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ha dicho mucho sobre la importancia de la legibilidad del código en todos los lenguajes de programación. Quienes promueven Go utilizan palabras como simplicidad, legibilidad, claridad, productividad. Pero todos estos son sinónimos de un concepto: la comodidad del mantenimiento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objetivo real es crear código que sea fácil de mantener. El código que sobrevive al autor. Un código que puede existir no solo como una inversión de tiempo, sino como una base para obtener un valor futuro. Esto no significa que la legibilidad no sea importante, solo la conveniencia del mantenimiento es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más importante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go no es uno de esos lenguajes optimizados para programas de una sola línea. Y ninguno de esos idiomas está optimizado para programas con un número mínimo de líneas. No optimizamos para el tamaño del código fuente en el disco, o para la velocidad de escribir programas en el editor. Queremos optimizar nuestro código para que sea más comprensible para los lectores. Porque son ellos los que tendrán que acompañarlo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si escribe un programa para usted mismo, tal vez se iniciará solo una vez, o usted es el único que ve su código. </font><font style="vertical-align: inherit;">En este caso, haz cualquier cosa. </font><font style="vertical-align: inherit;">Pero si más de una persona trabaja en el código, o si se utilizará durante mucho tiempo y los requisitos, las capacidades o el tiempo de ejecución pueden cambiar, entonces el programa debería ser conveniente de mantener. </font><font style="vertical-align: inherit;">Si el software no se puede mantener, no se puede reescribir. </font><font style="vertical-align: inherit;">Y esta puede ser la última vez que su empresa invierte en Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿En qué trabaja duro será conveniente acompañarlo después de su partida? </font><font style="vertical-align: inherit;">¿Cómo puede facilitar el mantenimiento de su código para aquellos que vienen después de usted hoy?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490324/index.html">¿Cómo encontramos errores no obvios en las interfaces de asignación en línea para niños?</a></li>
<li><a href="../es490328/index.html">Profesión: Probador</a></li>
<li><a href="../es490332/index.html">Hacemos un clon del servicio de entrega de alimentos usando Nuxt.js, GraphQL, Strapi y Stripe. Parte 2/7</a></li>
<li><a href="../es490336/index.html">Anatomía del canal en Go</a></li>
<li><a href="../es490338/index.html">En un experimento innovador, los físicos aprendieron a capturar átomos individuales.</a></li>
<li><a href="../es490342/index.html">Lo que aprendimos al probar el sistema de información del estado</a></li>
<li><a href="../es490344/index.html">¿Quién es Techlide y por qué lo necesita el equipo?</a></li>
<li><a href="../es490346/index.html">El papel del protocolo MQTT en el desarrollo de la Internet industrial de las cosas.</a></li>
<li><a href="../es490348/index.html">Cómo dar retroalimentación y no comenzar la Tercera Guerra Mundial</a></li>
<li><a href="../es490354/index.html">Mejora de la cultura de seguridad de la información en empresas fintech.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>