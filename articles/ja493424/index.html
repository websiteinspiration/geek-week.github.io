<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍡 🌵 🧢 Pythonコード変換を実装します 🤸🏿 📭 👃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル。
 
 今日、私たちはあなたが最も議論されていないトピックに触れる記事の翻訳を提供します：Pythonでのコードのコンパイル、すなわち：抽象構文木（AST）とバイトコードでの作業。 Pythonはインタプリタ言語ですが、そのような機能は最適化の観点から非常に重要です。今日はそれら...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pythonコード変換を実装します</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、私たちはあなたが最も議論されていないトピックに触れる記事の翻訳を提供します：Pythonでのコードのコンパイル、すなわち：抽象構文木（AST）とバイトコードでの作業。 Pythonはインタプリタ言語ですが、そのような機能は最適化の観点から非常に重要です。今日はそれらについて話します。</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーがどのようにコードを最適化してより高速に動作するのか疑問に思ったことはありませんか？</font><font style="vertical-align: inherit;">抽象構文ツリー（AST）とは何か、それを何に使用できるのか知りたいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このレビュー記事では、Pythonコードをツリー形式（AST）に変換する方法について説明します。</font><font style="vertical-align: inherit;">プログラムのASTを構築したら、コードを最適化および変換する機会を探すことができます。</font><font style="vertical-align: inherit;">ただし、自明ではない方法でPythonプログラムを最適化することは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に難しい</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことを覚えておいて</font><font style="vertical-align: inherit;">ください。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツリーとしてのプログラムコード</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピュータは、コードの式を正しい順序で評価することをどのように確認できますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、彼は最初にプログラムコードをASTと呼ばれるツリー構造に再作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタープリター型プログラミング言語（Pythonなど）を使用する場合、一般に、インタープリターがコードを通過し、Pythonコードをマシンコードに変換することなく、その場で出会うすべてのことを実行することが認められています。ただし、実際には、この実行スキームは多くの問題を引き起こし、非常に不便です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、演算子の優先順位としてこのような単純な問題を取り上げます。ビュー式</font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、パーツが最初に計算されます</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてそのときだけ、乗算の結果に3を加えることができます。おそらく、式の下でこれらのツリーを描画することにより、数学クラスでの演算子の優先順位を学習しました。Pythonは</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、数学表記の標準規則を使用します（最初に乗算、次に加算）。演算子の優先順位と混同しないように、Pythonでは最初に、前の図のようなツリーを構築します。一般的な演算は（ツリーのルートでの）加算です。この合計の左側は通常の数値ですが、右側には積があります。結果のデータ構造は次のようになります。</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二項演算（二項演算）を意味し、加算や乗算などの演算では2つのオペランドがあることを示します。当然、式の正しい部分に正しい値がない場合は加算されません。そのため、最初に乗算する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラとプログラミング言語の理論では、このようなツリーは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract Syntax Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">略して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。上記の例のASTには</font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2 </font><font style="vertical-align: inherit;">つのノード</font><font style="vertical-align: inherit;">、2つのノード、</font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font><font style="vertical-align: inherit;">つのノードが</font><font style="vertical-align: inherit;">含まれてい</font><font style="vertical-align: inherit;">ます</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonには、特定のPythonプログラムのASTを直接表示および表示できるという優れた機能があります。必要なのは、標準モジュールをインポートすることだけです</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プログラムを解析し、結果を画面に表示します（ちなみに、解析はプログラムのソースコードをASTツリーに変換するプロセスです）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Pythonによって生成されたASTには追加のノードとフィールドがあり、1行で表示されるため、一見すると実際よりも複雑に見えます。 </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回と同様に、それを別々のノードに分割して、ツリー全体の一部として、すでに一番上にあるASTを再度開きます。 </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、Pythonは解析のために指定した行がモジュール全体であると「考え」ます。モジュールの本体は、モジュールに含まれるすべての命令のリストです。この例での唯一の命令は、</font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記で説明したとおりの意味を持つ</font><font style="vertical-align: inherit;">式</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：ノード</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には追加のフィールド</font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（「context」と省略）があり、値があります</font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、Pythonでは、変数</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">格納された値を使用し</font><font style="vertical-align: inherit;">、名前を（再）定義または削除しないと述べています</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さて、あなたの移動、</font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">自分自身を解析しよう</font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とすると</font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ノード</font><font style="vertical-align: inherit;">のフィールド</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">それぞれ</font><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">どのように</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変化する</font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">がわかります</font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、モジュールをインストールした場合</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すると、画面へのAST出力がより美しくなり、ASTをライブのPythonコードに変換することもできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイルプロセス：残り</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASTプログラムを収集した後は、ASTを通過し、示された順序で操作を実行することにより、プログラム全体を完了することが原則として可能です。ただし、このアプローチには少なくとも2つの欠点があります。第1に、特に冗長な情報が含まれている場合、ASTは比較的大量のメモリを占有する可能性があります。次に、ASTトラバーサルは必要以上に時間がかかる場合があります。つまり、それは可能ですが、非効率的です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーはASTを直接処理しませんが、バイトコードを準備します。バイトコードは、Python仮想マシンで実行されます。このプロセスの詳細についてはこの記事の範囲を超えていますが、基本的な原則は、コンパイラがASTを逆ポーランド記法（RPN）に変換することです。演算子を置く代わりに</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左と右のオペランドの間では、両方のオペランドの後に置きます。</font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記</font><font style="vertical-align: inherit;">の例</font><font style="vertical-align: inherit;">では、シーケンスを取得しています</font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（この表記は、シーケンスからすぐに確認できるため、特に優れています。最初に乗算を実行し、次に加算を実行する必要があります）。このシーケンスの5つの要素のそれぞれは、原則として1バイトとして表現できるため、このようなコードはバイトコードと呼ばれます。次に、Pythonは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックされた仮想マシン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して、</font><font style="vertical-align: inherit;">このコードを効率的に実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、Pythonで作成されたプログラムをコンパイルするプロセスは、2つの段階で行われます。</font><font style="vertical-align: inherit;">まず、入力で受け取ったプログラムが解析され、結果が抽象構文ツリー（AST）になります。</font><font style="vertical-align: inherit;">次に、コンパイラーはASTを通過してバイトコードを生成します。</font><font style="vertical-align: inherit;">その後、Pythonインタープリターがこのバイトコードを実行します。</font><font style="vertical-align: inherit;">最適化を取り入れた後、ASTレベルまたはバイトコードレベルのいずれかで適用できます。</font><font style="vertical-align: inherit;">これらのオプションには、それぞれ独自の長所と短所があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ASTはすべてのPython実装で一般的ですが、ASTをバイトコードに変換するプロセスは異なる場合があり、一部のPython実装では、たとえばバイトコードではなくJavaScriptが中間段階で生成される場合があることに注意してください。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のプログラミング言語のパラダイム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonのように、すべてのプログラミング言語が中置表記法を使用するわけではありません。</font><font style="vertical-align: inherit;">この場合に注目に値する2つの例は、プログラムが逆ポーランド記法で直接書かれているPostScriptと、もちろんプログラムが通常ポーランド記法で書かれているLispです。</font><font style="vertical-align: inherit;">したがって、上の例のLispでの表現は次の形式になります</font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST内のノード変換</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASTプログラムがある場合、このツリーの個々の部分を変換する方法は？ Pythonの便利な組み込み機能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASTを見て、たとえば、フィールド</font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードの</font><font style="vertical-align: inherit;">両方</font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が数値（ノード</font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）であることがわかった場合、対応する計算を事前に実行してから、</font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のノードに</font><font style="vertical-align: inherit;">置き換えることができ</font><font style="vertical-align: inherit;">ます</font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、プログラムの振る舞いを変えないように非常に注意深く行動し、そのような変換を行う必要があります。例えば、中</font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には結果が4であることは明らかである。しかし、我々は数4 4ためのすべての機能表現を置き換えることはできません、</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだ正常に起動されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、簡単な最適化から始めます。プログラムのソースコードに名前が表示されている場合は、</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを値3.14159265に置き換えます。 Pythonモジュール</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、これを行うために必要なデータ構造をすでに提供しています。</font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのASTを通過し、各ノードが置き換え可能かどうかをチェック</font><font style="vertical-align: inherit;">するコンバータークラス</font><font style="vertical-align: inherit;">です。デフォルトでは、変換メソッドは各ノードのソースノードを返すだけなので、開始したのと同じASTを取得します。しかし</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば</font><font style="vertical-align: inherit;">nodeのメソッドを簡単にオーバーライドして</font><font style="vertical-align: inherit;">、それがそうであるかどうかを</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確認</font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、元の名前の</font><font style="vertical-align: inherit;">ノードの</font><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">ノード</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">ようにすること</font><font style="vertical-align: inherit;">ができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンバーター/オプティマイザーがツリーを通過するためには、そのメソッドを呼び出す必要</font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。これにより、変更された新しいツリーが返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、結果のASTをコンパイルして実行することは不可能です。これの理由は、技術的な詳細の1つです。これはまだ表示されていませんが、ASTの（ほぼ）すべてのノードにもフィールド</font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とがあり</font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。それらは、ソースコード内の特定のノードの正確な位置を示します。それらを適切にインストールしないと、コンパイラは誓い、動作を拒否します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、適切なフィールドをソースノード</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から新しいノードに</font><font style="vertical-align: inherit;">コピーしてみましょう</font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、結果のASTをコンパイルして実行できます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数のコンパイルに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ソースコード（プログラム自体、またはAST行にすることができます）だけでなく、ファイル名（要求したとおり</font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、および次の3つの</font><font style="vertical-align: inherit;">いずれかが必要</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">：</font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースコード内のノードの位置を説明するフィールドをコピーする必要性は、かなり頻繁に発生します。したがって、モジュールに</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この目的のためだけの</font><font style="vertical-align: inherit;">専用関数があり、次の</font><font style="vertical-align: inherit;">ように記述できます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、前の例を拡張して、実際に、つまりノードで最適化を実行できます</font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">変換ルールに従って、最初に左を変換/最適化し、次にBinOpの一部として右ノードを最適化する必要があります。</font><font style="vertical-align: inherit;">その結果、左右両方のノードが数値であることが判明した場合、その場で計算を実行し、元のノードを演算の</font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値結果で</font><font style="vertical-align: inherit;">置き換えることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、</font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに示す</font><font style="vertical-align: inherit;">ように、CPythonコンパイラはすでにノード</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">最適化</font><font style="vertical-align: inherit;">しています。</font><font style="vertical-align: inherit;">対応するコードはCで記述され、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.cで提供され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">注意：CPythonオプティマイザーはより普遍的であり、検討している例のように数値だけでなく、さまざまな種類の定数値でも機能します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASTでのノードの確認</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが行った変換が正しいことを確認するにはどうすればよいですか？まず、ASTを完全にバイパスし、プログラム全体を検査する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のオプティマイザには依然として重大な欠陥があります。プログラムのどこかに再定義するとどうなりますか</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？のような単純でわかりやすいものを想像してみてください</font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。オプティマイザは、式の左側のpiを数値3.14159265に単純に置き換えます。Pythonは、リテラル値に何も割り当てることができないため、コンパイルを拒否します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれはまさに求めていた動作であり、piを真の定数にします。これはコンパイル時に置き換えられ、再割り当てすることはできません。つまり、異なる値を取得することはできません。ただし、これは間違いなくPythonのセマンティクスに違反します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、Pythonのセマンティクスに固執したいが、とにかくpiを可能な限り置き換える場合はどうすればよいでしょうか。この場合、まずプログラム全体を調べて、の値がどこかに割り当てられているかどうかを確認する必要があります</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。複雑になるまで：プログラムの少なくとも1つのポイントにへの値の割り当てがある場合、piを置き換える手段はありません</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、上記のコンバーターノードに似たビジターノードを使用します。コンバーターとは異なり、ビジターはノードを変更することを意図していません。単にASTを通過してノードを調べます（ノードにアクセスします）。したがって、visitingメソッドは何も返しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、ノード</font><font style="vertical-align: inherit;">が値をロードする以外に</font><font style="vertical-align: inherit;">参照</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">している</font><font style="vertical-align: inherit;">かどうかを確認</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（コンテキストフィールドを覚えておいてください</font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、特別な訪問メソッドを提供していないノードごとに訪問者によって呼び出されます。</font><font style="vertical-align: inherit;">つまり</font><font style="vertical-align: inherit;">、を使用して呼び出すことができる</font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">には、そのようなメソッドはありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">関数の定義については、汎用ビジターを呼び出して、関数の本体全体も正しく処理されるようにする必要があります。</font><font style="vertical-align: inherit;">それ以外の場合は、関数内の命令を非表示にし</font><font style="vertical-align: inherit;">、値をグローバルに変更し</font><font style="vertical-align: inherit;">て、オプティマイザが何も気付かないようにすることができます。</font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"></font><code>super()</code><font style="vertical-align: inherit;"></font><code>global pi</code><font style="vertical-align: inherit;"></font><code>pi</code><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonのローカル値</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーがpiを変更したかどうかを判断できる方法は、かなり失礼なものであることが判明しました。</font><font style="vertical-align: inherit;">ただし、Pythonコンパイラーは、関数のスコープ内のどの名前がローカル変数に対応するかを決定する場合にも非常によく似た動作をします。</font><font style="vertical-align: inherit;">変数が関数のスコープのどこかで変更された場合（たとえば、グローバル命令を使用して明示的にグローバルにされない場合）、この変数は関数のスコープ全体でローカルと見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例では、4行目がなくても問題なく実行されます。</font><font style="vertical-align: inherit;">ただし</font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、4行目は決して実行されませんが、それでもへの割り当てと見なされます</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> したがって、xは関数全体のスケールで、さらに3行目でもローカル変数になります。そのため、Pythonは3行目の変数xはまだ問題ではないと断言します。</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでPythonがどのように機能するかの詳細に興味がある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / symtable.cを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックしてください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonでは、ほとんどのプログラミング言語と同様に、特定のプログラムはソースコードから直接実行されません。</font><font style="vertical-align: inherit;">実際、ソースコードの変換は2つの段階で行われます。最初にソースから抽象構文ツリー（AST）が作成され、次にスタックされた仮想マシンのバイトコードが作成されます。</font><font style="vertical-align: inherit;">Pythonは、特定のPythonプログラムのASTを分析および変換するための多数の非常に優れた機能も提供します。その後、修正されたASTをコンパイルして実行できます。</font><font style="vertical-align: inherit;">したがって、独自の最適化を簡単に実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ここでは多くの詳細を省略しました。</font><font style="vertical-align: inherit;">可能なすべてのケースと状況で最適化が正しく機能することを確認することは、非常に重要なことです。</font><font style="vertical-align: inherit;">ただし、この記事の目的は、本番環境で使用できる最適化について説明することではなく、Pythonがプログラムコードを分析して、正しく変換して最適化する方法を学ぶ方法の基本的な考え方を提供することです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja493408/index.html">DJI Mavicミニヘリコプターがバールのように落下しました</a></li>
<li><a href="../ja493412/index.html">ESP32でWi-Fiを使用するゲーム</a></li>
<li><a href="../ja493416/index.html">IDA Proおよびリバースエンジニアリング技術</a></li>
<li><a href="../ja493418/index.html">機械学習が「合成」データを使用する理由</a></li>
<li><a href="../ja493420/index.html">中学生にPythonを紹介する方法</a></li>
<li><a href="../ja493426/index.html">マイクロサービスでのコードの編成と六角形のアーキテクチャとDDDを使用する私のアプローチ</a></li>
<li><a href="../ja493428/index.html">「私たちは陰謀論を生じさせません。」科学およびIT企業の人々とのMLカンファレンスについて話し合う</a></li>
<li><a href="../ja493430/index.html">Webアプリケーションのネットアーキテクチャ</a></li>
<li><a href="../ja493432/index.html">IT以外の小さな会社でキャリアを始めてみませんか</a></li>
<li><a href="../ja493436/index.html">Bash上のファイル/ディレクトリ名のアクセス権と登録を変更するためのプログラム</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>