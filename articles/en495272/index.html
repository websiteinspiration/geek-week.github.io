<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöâ üñïüèΩ üôåüèΩ SNES emulators just a few pixels away from absolute perfection ü§∑ üò• üå∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are so close to creating an emulator that can perfectly recreate all the functions of real hardware and SNES software. 
 
 Over the past 15 years, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SNES emulators just a few pixels away from absolute perfection</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495272/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/f3b/e14/44bf3be14304180044d2e7deb216f07d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are so close to creating an emulator that can perfectly recreate all the functions of real hardware and SNES software. </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Over the past 15 years,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as a coder for the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> emulator </font><em><font style="vertical-align: inherit;">,</font></em><font style="vertical-align: inherit;"> I tried to perfect the Super Nintendo emulation, but now we are faced with the last problem: accurate timing of the clock cycles of the SNES video processors. </font><font style="vertical-align: inherit;">To reach this final stage of emulation accuracy, the help of the entire community is required, and I hope for your support. </font><font style="vertical-align: inherit;">But first, I‚Äôll tell you what we have already achieved.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current state</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today, the situation with SNES emulation is very good. Apart from the unusual peripherals that resist emulation (for example, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">golf club with a light sensor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bicycle simulator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and a dial-up modem, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Japan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">for horse racing betting in</font></a><font style="vertical-align: inherit;"> Japan), all officially licensed SNES games are fully playable, and no game has obvious problems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The SNES emulation became so precise that I even had to split the emulator into two versions: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">higan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which strives for absolute accuracy and consistency with the hardware documentation, and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which strives for speed, wide capabilities and ease of use.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recently, in the field of SNES emulation, many interesting achievements have been received, including:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Low level emulation of all SNES coprocessors</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Support for HD mode 7</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brake removal</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wide screen support</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSU1 for CD-audio and FMV</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preliminary execution to reduce delays</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic data rate control for perfect audio and video synchronization</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¶ and much more! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, is it done? Did everyone work well, bye, and thanks for the fish? Well, not quite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today, we have achieved accuracy at the beat level of almost all SNES components. The only exceptions were the PPU (picture processing unit, image processing modules) used to generate video frames transmitted to the screen. We </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> know how PPUs work, but for some functions we have to use guesswork, which leads to imperfect accuracy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On a general scale, the remaining problems are pretty minor. If you do not strive for the absolutely perfect ideality of emulation for the love of art, then I can not convince you of the need to further improve PPU emulation. As in any field, the closer we are to the ideal, the lower the return.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But I can say why this is important to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">me</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : this is the work of my whole life, and I don‚Äôt want me to say that I got </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> close to completion without taking the last step. </font><font style="vertical-align: inherit;">I am aging and I am not eternal. </font><font style="vertical-align: inherit;">I want the last piece of the puzzle to be solved, so that, having retired, I was sure that the SNES legacy is reliable and fully preserved thanks to the emulation. </font><font style="vertical-align: inherit;">I want to say that the problem is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solved</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are still intrigued then continue reading to get acquainted with a background of a problem and solutions offered by me.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modeling SNES Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start by listing the components that make up SNES:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3c/f4f/e25/c3cf4fe250fbbed2b897e46ef58628bd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super NES system diagram. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The arrows indicate the directions in which various SNES processors can exchange data with each other, and the dotted lines indicate the connections to the memory chips. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most important thing for us now is to notice that the output of video and sound is transmitted directly from PPU and DSP. </font><font style="vertical-align: inherit;">This means that they act as "black boxes", and we can not see what is happening inside them. </font><font style="vertical-align: inherit;">Later it will become important to us.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correctness</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine that we emulate the CPU command ‚Äúmultiply‚Äù, which takes two registers (variables), multiplies them, receives the result and several flags indicating the state of the result (for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can write a program that multiplies any possible value from 0 to 255 as a factor and a multiplier. Then we can derive the numerical and flag multiplication results. Thus, we get two tables of 65 536 elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By analyzing these tables, we can accurately determine how and where the results of CPU calculations are set in a certain way. Then we can modify the emulators so that when running the same test we get exactly the same tables at the same time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's say that the CPU can do 16-bit x 16-bit multiplication. When testing every possible value, 4 billion results will be generated, which are almost impossible to test in a reasonable amount of time. If the CPU has multiplications of 32 bits x 32 bits, then in practice it will not be possible to test all combinations of input values ‚Äã‚Äãbefore the thermal death of the Universe (at least at the current level of technology). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In such cases, we act more selectively in the tests and try to determine when the flags can exactly change, when the results may overflow, and so on. Otherwise, we would have to run tests that would never end.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multiplication is a rather trivial operation, but the same principle can be extended to the entire process of reverse engineering, including more complex operations, for example, data transmission via DMA (direct memory access) during the horizontal return of the beam. </font><font style="vertical-align: inherit;">We create tests that try to determine what happens in borderline cases, and then check whether our emulation behaves identically to the behavior of real SNES.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Signal Generators and Beats</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNES has two signal generators (oscillators): a crystal oscillator operating at a frequency of approximately 21 MHz (it controls the CPU and PPU modules), and a ceramic resonator operating at a frequency of approximately 24 MHz, which controls SMP and DSP. </font><font style="vertical-align: inherit;">In cartridge coprocessors, sometimes a 21 MHz crystal oscillator is used, and sometimes its own signal generators working with other frequencies.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97d/ecb/bc1/97decbbc1161fcf170f063d2fd42795d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recreating this Super Famicom circuit board in code is harder than it sounds.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The clock is the basic element of the timing of any system, and SNES is designed to perform various tasks with certain frequencies and time intervals. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you imagine a 100 hertz clock, it will be a device with a binary output switching to a high logical state of the signal (for example, +5 V), and then to a low state of the signal (0 V, or ground) 100 times per second. That is, every second the voltage at the output will fluctuate 200 times: increasing 100 times and 100 times lowering the front of the clock signal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A clock cycle is usually considered one complete transition, that is, a 100 Hz cycle will generate 100 clock cycles per second. </font><font style="vertical-align: inherit;">Some systems require a distinction between rising and falling edges, and for them we break the cycle into half-cycles to indicate each phase (high or low) of the clock signal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most important task of an accurate emulator is to complete tasks in exactly the same way and in exactly the same time as on real equipment. </font><font style="vertical-align: inherit;">However, it is not very important </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tasks are performed. </font><font style="vertical-align: inherit;">The only thing that is important is that the emulator, receiving the same input signals, generate the same output signals in the same time as on real hardware.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sometimes operations take time. Take for example multiplication in the SNES CPU. Instead of pausing and waiting for the multiplication to complete, the SNES CPU calculates the result of the multiplication one bit at a time in the background for eight clock cycles of the CPU opcodes. This potentially allows the code to perform other tasks while waiting for the multiplication to complete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most likely, any commercial software will wait for these eight cycles, because if you try to read the result before it is ready, we will get a partially completed result. However, before SNES emulators gave correct results </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instantly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , without waiting for these additional clock cycles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When fans of consoles began to create and test self-written software in emulators, this discrepancy began to cause certain problems. Part of the software, for example, many of the first </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario World</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ROM hacks </font><font style="vertical-align: inherit;">, worked correctly only in these old emulators, but not on real SNES hardware. This happened because they were developed taking into account the instant (unreliable from the point of view of real equipment) obtaining of the multiplication results. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the process of improving emulators, the compatibility of old software was broken, and therefore we had to add compatibility options to the new emulators so as not to lose these programs. Yes, no matter how surreal it sounds, but today emulators must emulate other emulators!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The convenience of this delay of multiplication in the CPU lies in the fact that it is very predictable: eight clock cycles of calculations begin immediately after the request of the multiplication operation. </font><font style="vertical-align: inherit;">By writing code that reads the results after each cycle, we were able to verify that the SNES CPU uses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Booth algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for multiplication </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clock Sync</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Other operations are not easy to model because they are asynchronously executed in the background. One such case is the DRAM update of the central SNES processor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the rendering of each raster line, the entire SNES CPU at a certain stage suspends its operation for a short period of time while the contents of the RAM chip are updated. This is necessary because in order to reduce the cost in SNES, dynamic (rather than static) RAM was used as the main memory of the CPU. To save the contents of dynamic RAM, it must be periodically updated.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d61/cb1/ab9/d61cb1ab914186314069b09f88218fcf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a truly perfect emulator is not enough to ensure the playability of all three and a half thousand SNES games. It is also necessary to achieve simulation of each function of the system with perfect tact accuracy.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The key factor in the analysis of the exact timings of these operations was the possibility of using horizontal and vertical PPU counters. These counters perform increments and are reset after each reverse horizontal and vertical beam travel. However, their accuracy is only a quarter of the frequency of the SNES CPU signal generator; in other words, the horizontal counter increments every four clock cycles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reading several times the values ‚Äã‚Äãof the counters, I was able to determine which quarter of the clock cycle the counter is aligned with. Combining this knowledge with specially created functions that can take a step towards the exact number of clock cycles indicated by the user, I was able to perfectly match the SNES CPU with any exact position of the clock cycle I need. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to an iterative traversal of many clock cycles, I was able to determine when certain operations are exactly happening (for example, updating DRAM, transmitting HDMA, interrupt polling, etc.). After that, I could exactly recreate all this in emulation. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMP chip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SNES console also has its own timers, and successful reverse engineering was also performed for this processor. </font><font style="vertical-align: inherit;">I can devote an entire article only to the SMP TEST register, which allows programmers to control the SMP frequency divider and its timer, not to mention other terrible things. </font><font style="vertical-align: inherit;">It will be enough to say that it was not an easy and quick process, but in the end we won.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We collect coprocessors</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/8ec/80c/1ce8ec80c157a980c0222eb7462679e9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SuperFX chip is just one of many cartridge coprocessors that the SNES emulator can handle.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
There are a whole bunch of SNES coprocessors used inside various game cartridges that we also needed to tame. From individual general-purpose CPUs like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SuperFX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA-1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , digital signal processors like DSP-1 and Cx4 to decompression accelerators like S-DD1 and SPC7110, or Sharp and Epson real-time clocks, and much more ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means that the SNES emulator must cope with SuperFX instruction and pixel caches; with the SA-1 memory bus conflict resolution scheme (allowing the SNES and SA-1 CPUs to use the same ROM and RAM chips simultaneously); with integrated firmware DSP-1 and Cx4; with prediction-based arithmetic encoders S-DD1 and SPC7110; as well as with odd borderline cases of BCD (binary-coded decimal) in real-time generators. Slowly but surely, using all the techniques for determining correctness and timings described above, we managed to learn how to emulate all these chips almost perfectly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It took a lot of effort and thousands of dollars to remove the chip covers and remove the firmware from the digital signal processors used in different games. In one case, NEC uPD772x emulation allowed</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use the code from higan to save the voice of the late Stephen Hawking! </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In another case, we needed to reverse engineer a whole set of instructions for the Hitachi HG51B architecture, because no one had ever published the documentation for this architecture. </font><font style="vertical-align: inherit;">In another case, it turned out that one game ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hayazashi Nidan Morita Shougi 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) has a powerful 32-bit ARM6 CPU with a frequency of 21 MHz, which accelerates the Japanese shogi game! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just saving all the SNES coprocessors turned out to be a long-term process, full of difficulties and surprises.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digital signal processing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Sony S-DSP (Digital Signal Processor) chip, which should not be confused with the DSP-1 cartridge coprocessor, generated a unique SNES sound. In this chip, eight audio channels with 4-bit ADPCM encoding were connected, which ensured the creation of a 16-bit stereo signal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outwardly, and from the system diagram presented above, at first it seems that the DSP is a ‚Äúblack box‚Äù: we adjust the sound channels and mixer parameters, after which the chip generates sound transmitted to the speakers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But one important function allowed the developer under the nickname blargg to perform a complete reverse engineering of this chip: it was an echo buffer. </font><font style="vertical-align: inherit;">The SNES DSP has a function that mixes the output from previous samples to create an echo effect. </font><font style="vertical-align: inherit;">This happens at the very end of the sound generation process (apart from the last one sound blocking flag, which can be used to turn off the entire sound output.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By writing code with the correct timing of the measures and tracking the resulting echo, we were able to determine the exact order of operations performed by the DSP to generate of each sample and creating perfect sound and beat accuracy.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saving PPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this led us to the last part of the SNES architectural scheme: PPU-1 and PPU-2 chips. </font><font style="vertical-align: inherit;">Thanks to John McMaster, we have scans of the S-PPU1 (revision 1) and S-PPU2 (revision 3) chips with a twenty-fold increase.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/678/641/68e/67864168e9f383375b8e081ffff1606f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twenty-fold scan of the crystal of the first PPU SNES ...</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/524/a23/fad524a235729831ae880c3edf1bb4b8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... and the second PPU.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Both crystal scans let us know that the chips are obviously not general-purpose CPUs, nor are they specialized architectures that execute operation codes from the internal ROM of the firmware program. These are separate logical circuits with hard-coded logic that receive incoming signals from different registers and memory, and create a video signal to the monitor one raster line at a time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPUs remain the last obstacle to emulating SNES because, unlike all the components described above, PPUs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are actually</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a black box. We can configure them to any state, but the SNES CPU can‚Äôt directly monitor what they generate.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we use our previous example with multiplication as an analogy, imagine that you requested the result 3 * 7, but instead of the binary answer, you get a fuzzy analog image of the numbers ‚Äú21‚Äù on the screen. Anyone who runs your software will </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> able to </font><i><font style="vertical-align: inherit;">see</font></i><font style="vertical-align: inherit;"> 21, but you cannot write a test program to automatically check if he sees the correct answer. A person‚Äôs manual verification of such results cannot be scaled to more than several thousand tests, and millions will be required to maximize the PPU behavior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I know what you thought: ‚ÄúBut is it easier to use a capture card, perform image processing, approximately compare them with the image on the digital screen of the emulator, and conduct tests based on this?‚Äù</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well yes, it is possible! </font><font style="vertical-align: inherit;">Especially if the test is to check two huge numbers that occupy the entire screen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what if testing has many nuances, and we are trying to recognize the color difference of a half-tone of one pixel? </font><font style="vertical-align: inherit;">What if we want to run a million tests in order, and we don‚Äôt always know what we will generate, but still want to compare the result with the output of our emulation? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nothing beats convenience and accuracy with digital data ‚Äî an accurate stream of bits that can only match or not match. </font><font style="vertical-align: inherit;">The analogue nature of a CRT signal cannot provide us with this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is it important?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the exception of one game ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), all officially licensed SNES software (should have been) based on raster strings. These games do not try to change the state of PPU rendering in the middle of the current rendered raster line (such a trick by programmers is called the "raster effect"). This means that the execution timings of the vast majority of games do not have to be particularly accurate; if you have time for the next full raster line, then everything is in order. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this is important for one single game.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/c75/08c/349c7508c9724e946a687c60881e77fc.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/7ee/5b2/3a47ee5b2b9ceacabcf2c4f1c34a1fe3.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77e/149/23c/77e14923ce342dc49287fa908aea5b93.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This series of images shows a complex emulation effect used in the ‚ÄúGood Luck‚Äù message of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In the images above, you see the frame-by-frame text ‚ÄúGood Luck‚Äù from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The game implements it by changing the position of vertically scrolling the background layer 3 (BG3). However, the dashboard display on the left (where you can see that the player has 39 missiles) is also on the same background layer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The game manages to perform this separation by changing the position of the BG3 scroll in each raster line after rendering the left dashboard, but before the text ‚ÄúGood Luck‚Äù begins to be rendered. This can be done because outside the dashboard and text, BG3 is transparent and there is nothing to draw between these two points, regardless of the value of the vertical scrolling register. This behavior shows us that scrolling registers </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> changed at any stage of rendering.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/658/047/8806580479dcbbaf6671fc971c12ba8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This small shadow under the plane caused a bunch of headaches for the precision-obsessed emulator developer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The image above shows the infamous shadow of an airplane. This effect is rendered by changing the screen brightness register with short ripples over five raster lines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the game, you can see that this shadow is rather chaotic. In the image above, it looks a bit like the letter ‚Äúc,‚Äù but its shape in each raster line changes in length and starting point with each frame. The developers of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> just roughly outlined where the shadow should appear, and solved this problem directly. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In most cases</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this works.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correct emulation of such behavior requires perfect timing, which is absolutely </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extremely</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> difficult to </font><font style="vertical-align: inherit;">obtain in the emulator </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/b7f/fa2/1c5b7ffa2601b6480209321b60a131a1.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pause screen </font><font style="vertical-align: inherit;">, raster effects are used that were not intentionally used in any other SNES game.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Now let's talk about the pause screen. It turns on BG3 while drawing a yellow-black border on the left and turns it off again during the same border on the right to draw gray lines on the screen. He also alternately through the frame switches the raster lines in which these gray lines are displayed to create the effect of an overlay jitter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you enlarge the emulated image shown above, you will notice that during the pair of raster lines in the left corner of these gray lines there are several missing pixels. It happened because my PPU emulation is 100% imperfect in clock cycles. In this case, it causes the effect of enabling BG3 a little later than it should.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I can very easily change the timings so that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> image renders correctly. But such a change is likely to adversely affect </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> games that change the PPU display registers in the middle of the raster line. Although </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the only game that does this on purpose, there are at least a dozen games in which this happens by chance (perhaps IRQ fires in them too sooner or later). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sometimes this causes brief noticeable damage to the picture, which is not paid attention to during development (for example, in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full Throttle Racing</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">during the transition between the store and the game). Sometimes recording is performed while rendering the screen that is transparent in the rest, and therefore does not cause visual anomalies (for example, as in the case of displaying HP status in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dai Kaijuu Monogatari II</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) But even such ‚Äúinvisible‚Äù border cases can cause problems in less accurate rendering of raster lines which are used in the most productive emulators. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even if you ignore </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , all of these random (but valid) raster effects in SNES software do not allow you to functionally design a PPU renderer that generates the entire raster line with perfect clock accuracy.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of bsnes over the years of trial and error, we have created a list of such games with ‚Äúraster effects‚Äù. </font><font style="vertical-align: inherit;">We also created individual rendering positions that allow much faster rendering based on raster lines to correctly display all these games (except for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , of course). </font><font style="vertical-align: inherit;">But in essence, this is a bunch of hacks unpleasant for us, designed for specific games. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I also have a clock-based PPU renderer that doesn‚Äôt need all these hacks, but from time to time it creates small (one to four pixels) differences with the rendering of this equipment, as in the screenshot above of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Latch Registers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reason for all these small misses comes down to snapping timings. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say SNES renders its </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">famous mode 7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is an affine texture transformation with parameter changes in each raster line. </font><font style="vertical-align: inherit;">To determine any screen pixel, you need to perform similar calculations:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">px = a * clip (hoffset - hcenter) + b * clip (voffset - vcenter) +</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b * y + (hcenter &lt;&lt; 8)</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
py = c * clip (hoffset - hcenter) + d * clip (voffset - vcenter) +</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d * y + (vcenter &lt;&lt; 8)</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Real SNES will not be able to complete all of these six multiplications fast enough for each pixel that is rendered in the frame. </font><font style="vertical-align: inherit;">But none of these values ‚Äã‚Äãchanges for each pixel (or, at least, should not change), so we just need to calculate px and py once at the beginning of each raster line. </font><font style="vertical-align: inherit;">That is, PPU caches static results in latches, which are essentially copies of PPU registers. </font><font style="vertical-align: inherit;">In the future, they can be transformed, or remain unchanged. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then the x, y coordinates are transformed by mode 7 as follows:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ox = (px + a * x) &gt;&gt; 8</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oy = (py + c * x) &gt;&gt; 8</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although x varies for each pixel, we know that the increment is performed by one each time. Thanks to the storage of internal drives, we can simply add constant values ‚Äã‚Äãa and c to ox and oy for each pixel, rather than perform two multiplications for each pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then the question arises before us: in what particular position of the clock cycle does the PPU read the values ‚Äã‚Äãof a and c from the external PPU registers to which the CPU has access? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we take them too soon, then this can break some games. If we take it too late, it can break other games. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The easiest way is to wait for bug reports and adjust these positions so as to fix problems in each specific game. But in this case, we will never find the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exact</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> positions, only their approximations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And every time we change one of these variables, it is unrealistic for us to retest all three and a half thousand games from the SNES library to detect the deterioration that our changes could make.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Out of the frying pan into the fire</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/741/b84/c0a741b84071dd0252021ae422277c1a.jpg"></div> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artistic interpretation of the process of eliminating emulation errors.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A similar style of testing methodology, ‚Äúwe‚Äôll just make the game we are interested in working at any cost‚Äù led to the phenomenon, which I call emulation ‚Äúfrom the fire, but into the fire‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the very beginning of the development of SNES emulation, when problems arose in the game, then </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correction in this game that allowed it to work was accepted and added to the emulator. This fix necessarily broke some other game. And then they corrected </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game, after which the third one broke. Fixing the third game again broke the first. This went on for many years.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The mistake here was that the developers tried to take into account only one variable at a time. Suppose we have a game, and for it to work, events must occur between measures 20 and 120. We do not know the exact measure, so just choose 70, exactly in the middle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Later we get a bug report in another game, and determine that for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game </font><font style="vertical-align: inherit;">to work </font><font style="vertical-align: inherit;">, the measure value should be between 10 and 60. So now we change it to 40, which works for both games. Sounds logical! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But then the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">third</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game </font><font style="vertical-align: inherit;">appears </font><font style="vertical-align: inherit;">, in which the event should work between measures 80 and 160! Now we can‚Äôt make all three games work at the same time with the same value.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This forced emulator developers to create hacks for specific games. </font><font style="vertical-align: inherit;">Coders do not want to release an emulator in which you can not run </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mario</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Therefore, for the general case, clock cycle 40 is used, but when loading </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we force the timing value to 100. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How is this possible, why do two games need different values? </font><font style="vertical-align: inherit;">This happens because not only one variable is involved here. </font><font style="vertical-align: inherit;">The timing that you previously used to trigger another event may affect the timing value that is required for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine this in the form of a simple algebraic expression:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2x + y = 120</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can solve it by taking x = 10, y = 100. Or x = 20, y = 80. Or x = 30, y = 60. If we only think about the value of x, which allows you to simultaneously run one set of games, then we miss the fact that in fact the problem may be in the wrong y! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first versions of emulators to increase compatibility simply redefined the value of x depending on the running game. Such individual game hacks persisted, even if the correct, single value of x was later discovered. So the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problem </font><font style="vertical-align: inherit;">would never be solved!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, in the case of SNES, not one or two variables are involved simultaneously. The SNES console PPU alone has 52 external registers, which is approximately 130 parameters. In the process of rendering a single raster line, all 130 of these parameters and an unknown number of internal registers and latches are involved. This is too much information for someone outside to be able to realize the full state of the PPU at a particular point in time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This aspect of emulation is not obvious to the uninitiated, but it is very fair: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accuracy is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not equal to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compatibility</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We can create an emulator with 99 percent accuracy, capable of running 10% of games. </font><font style="vertical-align: inherit;">And you can write an 80% accurate emulator that runs 98% of games. </font><font style="vertical-align: inherit;">Sometimes a correct implementation in the short term breaks popular games. </font><font style="vertical-align: inherit;">This is a necessary sacrifice if you are trying to achieve both 100% accuracy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100% compatibility.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solve the problem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We got to the current stage of PPU emulation thanks to deductive reasoning and results in the real world. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We know that two PPUs have access to two VRAM chips. </font><font style="vertical-align: inherit;">We know that they can read from each chip a known number of data bytes per raster line. </font><font style="vertical-align: inherit;">We know the rough details of how each of the SNES video modes works. </font><font style="vertical-align: inherit;">And based on this, we can outline a generalized pattern of how architecture might look. </font><font style="vertical-align: inherit;">For example, here is a brief example of how the first three SNES video modes can work:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (io.bgMode == 0) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (io.bgMode == 1) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter (1);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (0);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter (1);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (io.bgMode == 2) {</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable ();</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable ();</font></font><font></font>
<font></font>
bg3.fetchOffset(0);<font></font>
<font></font>
bg3.fetchOffset(8);<font></font>
<font></font>
bg2.fetchCharacter(0);<font></font>
<font></font>
bg2.fetchCharacter(1);<font></font>
<font></font>
bg1.fetchCharacter(0);<font></font>
<font></font>
bg1.fetchCharacter(1);<font></font>
<font></font>
}</pre></blockquote><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPU reveals to a third-party observer only a small part of its state: horizontal and vertical backward (horizontal / vertical blanking) flags, horizontal and vertical pixel counts, and tile overlay flags in the interval for sprites. This is not so much, but I repeat - every tiny element of the state accessible to the observer helps us. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The VRAM (video RAM, video memory) of the PPU chip during rendering is closed to SNES CPUs, even for reading. But as it turned out, OAM (sprite memory) and CGRAM (palette memory) are open. The trick is that at this time, the PPU controls the address bus. Therefore, reading OAM and CGRAM during screen rendering, I can observe what the PPU gets from these two memory blocks at such a critical time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These are not all pieces of the puzzle, but they are enough for me to be able to implement the practically correct patterns for obtaining sprites. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using access patterns for open OAM and CGRAM, PPU flags, general observations (i.e. guesses) from error reports for different games, and deductive reasoning, we were able to create clock-based PPU renderers that can </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfectly </font><font style="vertical-align: inherit;">launch all released games. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the situation is still precarious: if someone starts creating homebrew games using accurate timing of ticks and raster effects, then all of our modern emulators will not be able to handle this. Including software and hardware implementations based on FPGA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I must say clearly: today </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">everything</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they are only aware of the internal order of operations and snap behavior in the PPU chips of the SNES console. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> one knows how to emulate them perfectly. </font><font style="vertical-align: inherit;">At least for now.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possible solutions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What shall we do with this? </font><font style="vertical-align: inherit;">How to determine the exact order of operations in a PPU if, from the point of view of the SNES CPU, it is a "black box"? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I see four possible options: logic analyzers, digital video output in test mode, risers and removing covers from chips.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logic analyzers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look at the scans of PPU crystals shown above, you will notice black areas at the edges of the chip. These are the platforms connecting to the contacts of the chips. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These pins store the state of the PPU chips during each clock cycle. Here you can find the current address to which the chips access the video memory chip, the values ‚Äã‚Äãof the data transferred from one PPU to the second, and much more. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This information is not available for code running on the SNES CPU, but it provides valuable observations about the internal order of PPU operations.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/157/c0d/2c8157c0df8caaebd7e24f620bf2c60f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connecting Super NES console PPUs to a similar logic analyzer can be the key to the black box. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The critical problem of logic analyzers is that they are not very convenient to manage: if you try to sample live data from a working system, we will get a stream of results that is rather difficult to decipher. </font><font style="vertical-align: inherit;">You will encounter the same problem if you try to analyze the analog RGB output of the system: to capture this data, you will have to manually perform each of the tests. </font><font style="vertical-align: inherit;">Such a system is not very good for creating reproducible automated regression tests.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digital video output in test mode</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recently, through a scan of crystal slices with a 20x magnification, a secret test mode has been discovered in the SNES console PPU chips. If you make a small hardware modification, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then the PPU will begin to output a 15-bit digital RGB signal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is almost what we need! However, this mode has problems, because the famous mode 7 cannot display the correct picture in it. It seems that this function has not been fully completed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, to implement this method, manual modification of SNES consoles and an appropriate mechanism for capturing and analyzing output in test mode are still required. </font><font style="vertical-align: inherit;">Nevertheless, unlike the solution with capturing an analog RGB signal, such a digital signal can be subjected to automatic testing, which can allow us to quickly complete a large amount of work on PPU reverse engineering.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Risers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Given that the PPUs are static, we could remove the PPU chips from a working SNES console and connect them to a prototyping board or a custom made circuit board along with two VRAM chips. </font><font style="vertical-align: inherit;">After that, you can place a microcontroller between the PPU and the USB interface, and connect the interface to the PC, which will allow the encoder to program all external video memory registers and PPUs. </font><font style="vertical-align: inherit;">In addition, the encoder will be able to manually control the PPU clock cycles and read the resulting signals on the I / O connectors, registers and in the PPU memory in each clock cycle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By modifying the software emulator so that it generates the same internal values ‚Äã‚Äãof the I / O connectors, we could directly compare real hardware with emulation, even in real time. </font><font style="vertical-align: inherit;">However, this will be very hard work because we cannot yet see the internal PPU operations.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cover removal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Last, the most extreme solution is to further study the crystal by removing the chip cover. </font><font style="vertical-align: inherit;">We already have crystal scans with a 20x magnification, but their resolution is not enough to analyze and recreate individual logic circuits, as was done in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Visual 6502 project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If we can get the crystal scans of both PPUs with a 100x magnification, then we can begin the hard work of compiling PPU circuits and converting them to connection tables or VHDL code. </font><font style="vertical-align: inherit;">Then they can be used directly in FPGA, as well as ported to C ++ or another programming language, applicable for creating software emulators.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One specialist who had done this before gave me a rough estimate: it would take about 600 hours to map both PPUs. </font><font style="vertical-align: inherit;">This task is much higher than the level of ‚Äúlet's collect money by fundraising and pay someone‚Äù, and ideally falls into the category ‚Äúlet's hope that someone very talented with a unique set of skills will want to help us voluntarily‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, this does not mean that I would not be happy to financially reward someone for their help, I can pay for the necessary details and work.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Request for help</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To summarize: I went as far as possible in my SNES emulator project, and I need help to complete this final task. </font><font style="vertical-align: inherit;">If you have read to the end, then you might want to help! </font><font style="vertical-align: inherit;">Any support, including participation in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the bsnes project on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or any research documentation on the internal workings of PPU chips, will prove invaluable to us! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for reading and for your support! </font><font style="vertical-align: inherit;">It has been an honor for me for fifteen years to be a member of the SNES emulation community.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en495256/index.html">About ports and encryption in mail servers</a></li>
<li><a href="../en495258/index.html">How Zoom became the most important company in the era of coronavirus</a></li>
<li><a href="../en495262/index.html">PostgreSQL version upgrade practice. Andrey Salnikov</a></li>
<li><a href="../en495266/index.html">Renaissance e-learning. Why 2020 will show all the advantages of distance learning</a></li>
<li><a href="../en495268/index.html">UI / UX case: airport parking automation</a></li>
<li><a href="../en495274/index.html">How to fix route leaks</a></li>
<li><a href="../en495276/index.html">And demonstrate, or How we passed the Operational Sustainability audit at Uptime Institute</a></li>
<li><a href="../en495278/index.html">Databases, cards, checklists, or Why a business knowledge manager</a></li>
<li><a href="../en495280/index.html">Max Patrol SIEM. Information Security Event Management System Overview</a></li>
<li><a href="../en495282/index.html">XML validation using XSD, JAXB, and Spring Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>