<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚐 💔 🤾🏿 フロントエンド開発者Habrのログ：リファクタリングと反射 👨🏿‍🎤 😪 🤦🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は常に、Habrが内部からどのように配置されるか、ワークフローがどのように構築されるか、通信がどのように構築されるか、どの標準が適用されるか、およびコードがここにどのように記述されるかに常に関心がありました。幸いなことに、最近私はそのような機会を得ました。なぜなら、私は最近、ハブラコマンダの一部に...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>フロントエンド開発者Habrのログ：リファクタリングと反射</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/habr/blog/452098/"><img src="https://habrastorage.org/webt/bu/8e/tl/bu8etlfvktvmkcjotmzz6al7rgg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は常に、Habrが内部からどのように配置されるか、ワークフローがどのように構築されるか、通信がどのように構築されるか、どの標準が適用されるか、およびコードがここにどのように記述されるかに常に関心がありました。幸いなことに、最近私はそのような機会を得ました。なぜなら、私は最近、ハブラコマンダの一部になったからです。モバイルバージョンの小さなリファクタリングの例を使用して、質問に答えてみましょう。ここで前面に出て作業するのはどのようなものですか。プログラムでは、Node、Vue、Vuex、SSRと、Habréでの個人的な体験についてのメモを添えています。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発チームについて最初に知っておくべきことは、私たちが少ないということです。すべてのHabr-Bucksleyの3つのフロント、2つのバック、およびテクニカルはほとんどありません。もちろん、テスター、デザイナー、3つのヴァディム、奇跡のほうき、マーケティング担当者、その他のブンブルムもあります。しかし、Habraソートに直接貢献しているのは6人だけです。これは非常にまれです。外部から見た巨大な企業のように見える数百万ドルの聴衆がいるプロジェクトは、実際には最もフラットな組織構造を持つ居心地の良いスタートアップのようなものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の多くのIT企業と同様に、Habrはアジャイルのアイデア、CIの実践を公言し、それがすべてです。しかし、私の感情によると、製品としてのHabrは、継続的というよりも波状に発展します。したがって、連続した複数のスプリントについては、コードの作成、設計と再設計、何かの破壊と修復、チケットの解決と新しいものの開始、レーキを踏んで脚を撃ち、最終的に機能を本番環境にリリースすることに苦労しています。そして、その後、「重要で緊急ではない」象限にあるものをやめる、再開発の期間、時が来ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下で説明するのは、このような「オフシーズン」のスプリントについてです。</font><font style="vertical-align: inherit;">今回は、モバイルバージョンのHabrのリファクタリングを取得しました。</font><font style="vertical-align: inherit;">一般的に、同社はそれを強く望んでおり、将来的には、Habrの化身動物園全体に取って代わり、ユニバーサルクロスプラットフォームソリューションになるはずです。</font><font style="vertical-align: inherit;">いつの日か、アダプティブレイアウト、PWA、オフラインモード、カスタムカスタマイズ、その他多くの興味深いものがここに表示されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクを設定します</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、通常のスタンドアップで、フロントの1つがモバイルバージョンのコメントコンポーネントのアーキテクチャの問題について話しました。このプレゼンテーションから、グループ心理療法の形式でマイクロミーティングを開催しました。それぞれが彼が痛みを持っている場所を順番に言った、誰もが拍手しなかったことを除いて、すべてが紙に固定され、共感され、理解された。出力は20の問題のリストであり、モバイルHabrが成功するには長く厄介な道を進む必要があることが明らかになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の主な関心事は、リソース効率と、スムーズなインターフェースと呼ばれるものでした。 「在宅勤務」ルートで毎日、古い電話が必死にストリームに20個の見出しを表示しようとしているのを見ました。それはこのようなものでした：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/v8/zr/nvv8zr5uneyynf4ntntk9sp3gzs.gif" alt="画像"></div><sub><font color="grey"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リファクタリング前のモバイルHabrインターフェース</font></font></i></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここで何が起こっているのですか？</font><font style="vertical-align: inherit;">つまり、サーバーは、ユーザーがログインしているかどうかに関係なく、全員に同じ方法でHTMLページを提供しました。</font><font style="vertical-align: inherit;">次に、クライアントJSがロードされ、必要なデータを再度要求しますが、許可の調整が行われます。</font><font style="vertical-align: inherit;">つまり、実際には同じ作業を2回実行しました。</font><font style="vertical-align: inherit;">インターフェイスがちらつき、ユーザーはさらに100キロバイト多くダウンロードしました。</font><font style="vertical-align: inherit;">詳細には、すべてがさらに不気味に見えました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/py/d8/0kpyd8h81q0_sgb8dd2gt7wfhvw.jpeg"></div><sub><font color="grey"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いSSR-CSR回路。</font><font style="vertical-align: inherit;">ノードJSがHTMLの生成でビジー状態ではなく、APIリクエストをプロキシできるステージC3およびC4でのみ承認が可能です。</font></font></i></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当時の私たちのアーキテクチャは、Habrのユーザーの1人によって非常に正確に説明されていました。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイル版はたわごとです。</font><font style="vertical-align: inherit;">そのままお話します。</font><font style="vertical-align: inherit;">SSRとCSRのひどい組み合わせ。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはそれを認めなければなりませんでしたが、悲しいかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はオプションを見つけ、「Dzhira」にチケットを設定しました。「今は悪い、規範を立てる」のレベルで説明し、広いストロークでタスクを分解しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを再利用する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再描画の数を最小限に抑え、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重複するリクエストを除外する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロードプロセスをより明確にします。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを再利用する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には、サーバー側のレンダリングは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPAインデックス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する検索エンジンの制限を受けないこと</font><font style="vertical-align: inherit;">と、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックを改善する</font><font style="vertical-align: inherit;">（必然的に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TTIを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪化</font><font style="vertical-align: inherit;">させる）という</font><font style="vertical-align: inherit;">2つの問題を解決するように設計されてい</font><font style="vertical-align: inherit;">ます。 2013年に最終的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にAirbnbで策定された</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Backbone.jsに戻った）</font><font style="vertical-align: inherit;">古典的なシナリオでは</font><font style="vertical-align: inherit;">、SSRはNode環境で実行されているのと同じ同型のJSアプリケーションです。サーバーは、生成されたレイアウトをリクエストへの応答として返すだけです。次に、クライアント側で再水和が行われ、ページの再読み込みなしですべてが機能します。 Habrおよびその他の多くのテキスト入力リソースの場合、サーバーレンダリングは、検索エンジンとの友好的な関係を構築する上で重要な要素です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクノロジーの登場から6年以上が経過し、この期間中、フロントエンドの世界には本当に大量の水が流れてきましたが、多くの開発者にとって、このアイデアは依然として秘密のベールに覆われています。私たちは脇に立たず、SSRをサポートするVueアプリケーションを製品にロールアウトしましたが、1つの小さな詳細が欠けていました。クライアントに初期状態をスローしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうして？この質問に対する正確な答えはありません。彼らは、サーバーからの応答のサイズを大きくしたくなかったのか、または他の多くのアーキテクチャ上の問題のためにそうしたのか、あるいは単に離陸しなかったのか、です。何らかの方法で、状態をスローし、サーバーが行ったすべてを再利用することは、非常に適切で便利なようです。タスクは実際には取るに足らない- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態が注入されるだけ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行コンテキストでは、Vueは生成されたレイアウトにグローバル変数として自動的に追加します</font></font><code>window.__INITIAL_STATE__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発生した問題の1つは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循環</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造をJSONに変換できないことでした</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのような構造をそれらの平らな類似物で単に置き換えることによって解決されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、UGCコンテンツを処理するときは、HTMLを壊さないようにデータをHTMLエンティティに変換する必要があることに注意してください。</font><font style="vertical-align: inherit;">これらの目的のために、私たちは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用&nbsp; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再描画を最小化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図からわかるように、この場合、1つのNode JSインスタンスが2つの機能を実行します。SSRとAPIの「プロキシ」で、ユーザーが承認されます。</font><font style="vertical-align: inherit;">この状況では、ノードがシングルスレッドであり、SSR機能が同期しているため、サーバーでのJSコードの実行時に認証が不可能になります。</font><font style="vertical-align: inherit;">つまり、呼び出しスタックが何かでビジー状態の間、サーバーはそれ自体に要求を送信できません。</font><font style="vertical-align: inherit;">状態をスキップしたことがわかりましたが、ユーザーセッションを考慮してクライアントのデータを更新する必要があるため、インターフェイスは切り替えを停止しませんでした。</font><font style="vertical-align: inherit;">ユーザーのログインを考慮して、初期状態で正しいデータを配置するようにアプリケーションを教える必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題に対する解決策は2つしかありませんでした。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー間リクエストに認証データを貼り付ける;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node JSレイヤーを2つの個別のインスタンスに分割します。</font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のソリューションではサーバーでグローバル変数を使用する必要があり、2番目のソリューションではタスクを完了するのに必要な時間が少なくとも1か月延長されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択する方法は？ Habrは抵抗が最も少ない経路に沿って移動することがよくあります。非公式には、アイデアからプロトタイプまでのサイクルを最小限に抑えたいという一般的な要望があります。製品に対する態度のモデルは、booking.comの仮定を多少連想させますが、唯一の違いは、Habrはユーザーのフィードバックについてはるかに真剣であり、開発者としてのそのような決定の採用を信頼していることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このロジックと、問題をすばやく解決したいという私自身の願望に従って、私はグローバル変数を選択しました。そして、これがしばしば起こるように、遅かれ早かれ彼らは彼らのために支払わなければなりません。私たちはほぼ即座に支払いました：私たちは週末に働き、結果をかき集め、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">死後</font></a><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事を</font></a><font style="vertical-align: inherit;">書きました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーを2つの部分に分割し始めました。</font><font style="vertical-align: inherit;">間違いは非常に愚かであり、彼女の参加によるバグは再現が容易ではありませんでした。</font><font style="vertical-align: inherit;">そして、はい、そのような恥ずかしさのために、どういうわけか、つまずき、不平をぶつけて、グローバル変数を使用した私のPoCは、まだ生産に入り、新しい "2日間"アーキテクチャへの移行を見越して、非常にうまく機能しています。</font><font style="vertical-align: inherit;">これは重要なステップでした。正式に目標が達成されたためです。SSRは完全に使用可能なページをレンダリングすることを学び、UIは非常に落ち着きました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/rx/d-/rmrxd-fkzne7vbcj-jxxrbbwid8.gif" alt="画像"></div><sub><font color="grey"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リファクタリングの最初の段階の後のモバイルHabrインターフェース</font></font></i></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最終的に、SSR-CSRモバイルバージョンのアーキテクチャは、この図につながります：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
</font></font><div style="text-align:center;"><img src="https://habrastorage.org/webt/7t/jb/km/7tjbkmkiq4n5atanzsj3ylkwrke.jpeg" alt="画像"></div><sub><font color="grey"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「2日間」のSSR-CSRスキーム。</font><font style="vertical-align: inherit;">Node JS APIは常に非同期I / Oの準備ができており、SSR関数は別のインスタンスにあるため、SSR関数によってブロックされません。</font><font style="vertical-align: inherit;">クエリチェーン＃3は必要ありません。</font></font></i></font></sub><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重複するリクエストを除外する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操作後、最初のページのレンダリングはてんかんを誘発しなくなりました。</font><font style="vertical-align: inherit;">しかし、SPAモードでHabrをさらに使用すると、戸惑いが生じました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーフローは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、記事のリスト→記事→コメント</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびその逆の</font><font style="vertical-align: inherit;">遷移に基づいているため</font><font style="vertical-align: inherit;">、最初にこのチェーンのリソースの消費を最適化することが重要でした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/eo/01/ukeo01u79_olhiv1eo9vxao4yv4.gif" alt="画像"></div><sub><font color="grey"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿フィードに戻ると、新しいデータリクエストが発生し</font></font></i></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ます。深く掘り下げる必要はありませんでした。上記のスクリーンキャストは、アプリケーションがスワイプして戻るときに記事のリストを再クエリし、リクエスト中に記事が表示されないことを示しています。つまり、以前のデータがどこかに消えています。記事リストコンポーネントはローカル状態を使用しており、破棄するとそれを失います。実際、アプリケーションはグローバル状態を使用していましたが、Vuexアーキテクチャは額に基づいて構築されていました。モジュールはページに接続されており、ページはルートに接続されています。さらに、すべてのモジュールは「使い捨て」で、ページにアクセスするたびにモジュール全体が書き直されました。</font></font><br>
<br>
<pre><code class="javascript hljs">ArticlesList: [<font></font>
  { Article1 },<font></font>
  ...<font></font>
],<font></font>
<span class="hljs-attr">PageArticle</span>: { ArticleFull1 },
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計では、我々は持っていた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticlesListの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール</font><font style="vertical-align: inherit;">のオブジェクトが含まれ、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">種類</font><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PageArticleの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール</font><font style="vertical-align: inherit;">の拡張版だった、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">の種類</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticleFullを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。概して、この実装自体にはひどいことは何もありません。それは非常に単純で、簡単に言うこともできますが、非常に明確です。ルートを変更するたびにモジュールのゼロ化をカットすれば、それで生きることもできます。ただし、</font><font style="vertical-align: inherit;">新しいデータを入力する</font><i><font style="vertical-align: inherit;">ArticlesList</font></i><font style="vertical-align: inherit;">は1つしかないため、</font><font style="vertical-align: inherit;">記事フィード間の遷移（たとえば</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ feed→/ all</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、個人フィードに関連するすべてのものを確実にスローし</font><font style="vertical-align: inherit;">ます。これもクエリの重複につながります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこのトピックで何とか発掘できたすべてをまとめて、新しい状態構造を作成し、それを同僚に提示しました。議論は長いものでしたが、結局、「の」という議論は疑念を上回り、実装を開始しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションのロジックは、2つの段階で最もよく開示されます。最初に、ページからVuexモジュールの関連付けを解除して、ルートに直接バインドしようとします。はい、ストアにはもう少しデータがあります。ゲッターはもう少し複雑になりますが、記事を2回ロードすることはありません。モバイル版の場合、これはおそらく最も強力な議論です。次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">ArticlesList: {
  <span class="hljs-attr">ROUTE_FEED</span>: [ <font></font>
    { Article1 },<font></font>
    ...<font></font>
  ],<font></font>
  <span class="hljs-attr">ROUTE_ALL</span>: [ <font></font>
    { Article2 },<font></font>
    ...<font></font>
  ],<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、記事リストが複数のルート間で重複する可能性がある場合、および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトデータ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">再利用し</font><font style="vertical-align: inherit;">て投稿ページをレンダリングし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticleFullに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換</font><font style="vertical-align: inherit;">し&nbsp; </font><font style="vertical-align: inherit;">たい場合はどうなり</font><font style="vertical-align: inherit;">ますか？この場合、そのような構造を使用するほうがより論理的です。</font></font><br>
<br>
<pre><code class="javascript hljs">ArticlesIds: {
  <span class="hljs-attr">ROUTE_FEED</span>: [ <span class="hljs-string">'1'</span>, ... ],
  <span class="hljs-attr">ROUTE_ALL</span>: [ <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, ... ],<font></font>
},<font></font>
<span class="hljs-attr">ArticlesList</span>: {
  <span class="hljs-string">'1'</span>: { Article1 }, 
  <span class="hljs-string">'2'</span>: { Article2 },<font></font>
  ...<font></font>
}<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここの</font><i><font style="vertical-align: inherit;">ArticlesList</font></i><font style="vertical-align: inherit;">は、一種の記事リポジトリです。ユーザーセッション中にアップロードされたすべての記事。これは、駅間の地下鉄のどこかの痛みによってロードされた可能性のあるトラフィックであり、ユーザーに再びこの痛みを引き起こしたくはないため、ユーザーがすでにダウンロードしたデータをロードすることを強制するため、可能な限り慎重に扱います。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticlesIds</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトへの識別子（「リンク」など）の単なる配列です</font><font style="vertical-align: inherit;">。このような構造により、</font><font style="vertical-align: inherit;">拡張データをマージして投稿ページをレンダリングするときに</font><font style="vertical-align: inherit;">、ルートに共通のデータを複製せずに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを再利用</font><font style="vertical-align: inherit;">できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事リストの出力もより透過的になりました：イテレーターコンポーネントは記事IDで配列を反復処理し、記事ティーザーコンポーネントを描画して、Idを小道具として渡し、次に子コンポーネントが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticlesList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から必要なデータを取得します&nbsp; </font><font style="vertical-align: inherit;">。公開ページに移動すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticlesList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から既存の日付を取得&nbsp; </font><font style="vertical-align: inherit;">し、不足しているデータを要求して、それを既存のオブジェクトに追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこのアプローチが優れているのですか？</font><font style="vertical-align: inherit;">上で書いたように、このアプローチはダウンロードされたデータに関してより注意深く、それらを再利用することができます。</font><font style="vertical-align: inherit;">しかし、これに加えて、それはそのようなアーキテクチャに完全に適合するいくつかの新しい機会への道を開きます。</font><font style="vertical-align: inherit;">たとえば、表示されたとおりに記事をポーリングしてフィードにアップロードします。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticlesList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ store” </font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">新しい投稿を追加し</font><font style="vertical-align: inherit;">、新しいIDの個別のリストを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArticlesIds</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に保存して、&nbsp; </font><font style="vertical-align: inherit;">これをユーザーに通知するだけです。</font><font style="vertical-align: inherit;">「新しい出版物を表示」ボタンをクリックすると、現在の記事リストの配列の先頭に新しいIDを挿入するだけで、すべてがほぼ魔法のように機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードをもっと楽しくする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リファクタリングケーキのチェリーはスケルトンの概念でした。これにより、低速のインターネットでコンテンツをダウンロードするプロセスが少し不快になります。</font><font style="vertical-align: inherit;">このテーマについての議論はありませんでした。アイデアからプロトタイプまでの道のりは文字通り2時間かかりました。</font><font style="vertical-align: inherit;">デザインはほとんど自分で描いたもので、データを待つ間に、目立たない、ちらつきのないdivブロックをレンダリングする方法をコンポーネントに教えました。</font><font style="vertical-align: inherit;">主観的に、このローディングへのアプローチは、ユーザーの体内のストレスホルモンの量を本当に減らします。</font><font style="vertical-align: inherit;">スケルトンは次のようになります：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/gn/ey/yngneyh8sftpmyyyj4ur_ihjo2c.jpeg" alt="画像"><br>
<sub><font color="grey"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habraloading</font></font></i></font></sub><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反射する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はハブレで6か月間働いていますが、友達はまだ尋ねます：ええ、そこではどうですか？良い、快適-はい。しかし、この作品を他の作品と区別するものがあります。私は彼らの製品にまったく無関心で、ユーザーが誰であるかを知らず、理解していなかったチームで働いていました。しかし、ここではすべてが異なります。ここであなたは自分がしていることに責任を感じます。機能を開発するプロセスでは、部分的にその責任者になり、機能に関連するすべての製品ミーティングに参加し、提案を行い、自分で決定します。自分で毎日使う製品を作るのはとてもクールで、それを上手にできる人のためにコードを書くのは信じられないほどの気持ちです（嫌味なし）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての変更がリリースされた後、私たちは肯定的なフィードバックを受けました。</font><font style="vertical-align: inherit;">それは刺激的です。</font><font style="vertical-align: inherit;">感謝！</font><font style="vertical-align: inherit;">もっと書いてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバル変数の後、アーキテクチャを変更し、プロキシレイヤーを個別のインスタンスに分離することにしました。</font><font style="vertical-align: inherit;">「2日間」のアーキテクチャは、すでに公開ベータテストの形でリリースされています。</font><font style="vertical-align: inherit;">これで誰もがそれに切り替えて、モバイルHabrをより良くすることができます。</font><font style="vertical-align: inherit;">それが今日のすべてです。</font><font style="vertical-align: inherit;">コメントであなたのすべての質問に答えさせていただきます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452086/index.html">私のピクセルには何がありますか：プラズモンメタサーフェスを使用したナノピクセルの作成</a></li>
<li><a href="../ja452088/index.html">セマンティックセグメンテーションによる道路認識</a></li>
<li><a href="../ja452090/index.html">手続き型パズルジェネレーターの作成</a></li>
<li><a href="../ja452092/index.html">アプリ内アップデート：Androidアプリケーションアップデートの高速化</a></li>
<li><a href="../ja452094/index.html">.NET：マルチスレッドと非同期を操作するためのツール。パート1</a></li>
<li><a href="../ja452102/index.html">ドローンが好きな人のための写真ゲーム：AirSelfie 2について簡単に</a></li>
<li><a href="../ja452106/index.html">2019年6月16日の夏のDIYミーティングにスピーカーを招待します</a></li>
<li><a href="../ja452108/index.html">Docker：無害なアドバイス</a></li>
<li><a href="../ja452110/index.html">Ansibleでディスク交換を自動化</a></li>
<li><a href="../ja452112/index.html">CRM ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>