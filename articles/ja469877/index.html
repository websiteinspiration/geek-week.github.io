<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 🤫 🏕️ ああ、このニュートンの方法 👨🏾‍🚀 👩🏿‍🤝‍👩🏼 💋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="数値最適化手法についてはたくさん書かれています。これは、特にディープニューラルネットワークによって最近実証された成功の背景に対して、理解できます。そして、少なくとも一部の愛好家が、これらのインターネットで人気を博しているフレームワークでニューラルネットワークを爆破する方法だけでなく、それがどのように...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ああ、このニュートンの方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469877/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値最適化手法についてはたくさん書かれています。</font><font style="vertical-align: inherit;">これは、特にディープニューラルネットワークによって最近実証された成功の背景に対して、理解できます。</font><font style="vertical-align: inherit;">そして、少なくとも一部の愛好家が、これらのインターネットで人気を博しているフレームワークでニューラルネットワークを爆破する方法だけでなく、それがどのようにそしてなぜ機能するかにも関心を持っていることは非常に嬉しいことです。</font><font style="vertical-align: inherit;">ただし、最近、ハブレを含むニューラルネットワークのトレーニング（トレーニングだけでなく、ネットワークだけでなく）に関連する問題を提起する際に、転送に多くの「よく知られた」ステートメントが使用されることに注意する必要がありました。控えめに言っても疑わしい。</font><font style="vertical-align: inherit;">そのような疑わしい声明の中で：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2次以上の次数のメソッドは、ニューラルネットワークのトレーニングタスクではうまく機能しません。</font><font style="vertical-align: inherit;">なぜなら。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュートン法は、ヘッセ行列の正定性（2次導関数）を必要とするため、うまく機能しません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Levenberg-Marquardt法は勾配降下法とニュートン法の折衷案であり、一般にヒューリスティックです。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等 </font><font style="vertical-align: inherit;">このリストを続けるよりも、ビジネスに取り掛かることをお勧めします。</font><font style="vertical-align: inherit;">私はハブレで少なくとも2回だけ彼に会ったので、この投稿では2番目の声明を検討します。</font><font style="vertical-align: inherit;">最初に取り上げるのは、ニュートン法の方がはるかに広範囲なので、その部分でのみ触れます。</font><font style="vertical-align: inherit;">3番目と残りはより良い時間まで残されます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの注意の焦点は、無条件最適化の問題です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/823/e50/c93/823e50c935e4cc19a175f53c17ca79af.gif" title="「f（x）\ rightarrow \ min」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc7/838/e10/bc7838e10e143195c0381efbf0671cce.gif" title="「x =（x_ {1}、x_ {2}、\ドット）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、はベクトル空間のポイント、または単に-ベクトルです。当然のことながら、この問題を解決するのが簡単であるほど、私たちはより多くのことを知ってい</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="「f」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。通常、それは各引数に関して</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6d8/d4e/07d/6d8d4e07d259325d5dd652e4b3b97af6.gif" title="&quot;Xのk}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして私たちの汚い行為に必要なだけ何度</font><font style="vertical-align: inherit;">も微分可能であると想定されています</font><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8ae/e32/d7e/8aee32d7e93fb189b268894bf91622b0.gif" title="「x ^ {*}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある</font><font style="vertical-align: inherit;">点</font><font style="vertical-align: inherit;">で最小値に到達する</font><font style="vertical-align: inherit;">ために必要な条件は、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/735/1d5/454/7351d54544ca7acc4b7a9bff7a2c2f6a.gif" title="「\ bigtriangledown f（x ^ {*}）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この点</font><font style="vertical-align: inherit;">での関数の勾配が</font><font style="vertical-align: inherit;">ゼロになることです。ここから、即座に次の最小化方法を取得します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方程式を解きます</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d59/223/ac1/d59223ac159bfe660ea26a1d60f8f33f.gif" title="「\ bigtriangledown f（x）= 0 &quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
穏やかに言えば、その仕事は簡単なものではありません。間違いなくオリジナルより簡単ではありません。ただし、この時点で、最小化問題と非線形方程式系を解く問題の間の関係をすぐに確認できます。この接続は、Levenberg-Marquardt法を検討すると（私たちがそれに到達したとき）戻ってきます。それまでの間、非線形方程式を解くために最も一般的に使用される方法の1つがニュートン法であることを覚えておいてください（または見つけてください）。これは、方程式を解くために、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="&quot;F（x）= 0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の初期近似から始めて、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="「x_ {0}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンスを作成します</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a0/23d/4a2/3a023d4a27cdff86f8cf3bc78d5b3a21.gif" title="&quot;x_ {i + 1} = x_ {i} -H ^ {-1}（x_ {i}）F（x_ {i}）&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">—陽的なニュートン法</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/116/6fa/27b/1166fa27b4038fed75d435daaaab53fe.gif" title="&quot;\ begin {cases} H（x_ {i}）p_ {i} =-F（x_ {i}）\\ x_ {i + 1} = x_ {i} + p_ {i} \ end {cases}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">陰的なニュートン法</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="「H」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、は関数の偏微分からなる行列です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="「F」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当然のことながら、一般的なケースでは、非線形方程式のシステムが感覚で単純に与えられている場合、行列から何か</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="「H」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">要求する</font><font style="vertical-align: inherit;">資格はありません。方程式が関数の最小条件である場合、行列は</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="「H」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対称である</font><font style="vertical-align: inherit;">と言え</font><font style="vertical-align: inherit;">ます。しかし、それ以上ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非線形方程式のシステムを解くためのニュートンの方法は、かなりよく研究されてきました。そして、ここに問題があります-その収束のために、行列の正定性は必要ありません</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="「H」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。はい、必要ありません。そうでなければ、彼は無価値でした。代わりに、この方法の局所的な収束を保証する他の条件があり、ここでは考慮しません。専門家の文献（または解説）に関心のある人々を送ります。ステートメント2が偽であることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そう？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はいといいえ。ここでの待ち伏せは、言葉の前の局所的な収束です。これは、最初の近似</font></font><img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="「x_ {0}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がソリューションに「十分に近い」ものでなければならない</font><font style="vertical-align: inherit;">ことを意味し</font><font style="vertical-align: inherit;">ます。そうしないと、各ステップで、さらに</font><font style="vertical-align: inherit;">近似</font><font style="vertical-align: inherit;">から取り除かれます。何をすべきか？この問題が一般形式の非線形方程式のシステムでどのように解決されるかについては詳しく説明しません。代わりに、最適化タスクに戻ります。通常、最適化問題にニュートン法の話が変更に起因するものであることを、本当に最初のアサーションエラー2 -減衰ニュートン法、規則によって構築さ近似値の中のシーケンス</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/23d/ca8/404/23dca84042b77a1560b8cd2db607e8ae.gif" title="&quot;x_ {i + 1} = x_ {i}-\ alpha_ {i} H ^ {-1}（x_ {i}）F（x_ {i}）&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-明確な減衰ニュートン法</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9d4/67c/c96/9d467cc96266cf1179d3e553718f5bee.gif" title="&quot;\ begin {cases} H（x_ {i}）p_ {i} =-F（x_ {i}）\\ x_ {i + 1} = x_ {i} + \ alpha_ {i} p_ {i} \ {cases}を終了」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-暗黙の減衰ニュートン法</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンス</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c70/738/fd1/c70738fd1eb4d9bfff34f20904f41bbf.gif" title="「\ {\ alpha_ {i} \}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメソッドのパラメーターであり、その構築は別のタスクです。</font><font style="vertical-align: inherit;">最小化問題では、自然な選択</font></font><img src="https://habrastorage.org/getpro/habr/post_images/eb2/94d/fe4/eb294dfe4cfca7355f8b030f3d7dade8.gif" title="「\ alpha_ {i}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、関数fの値が各反復で減少するという要件です。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3ae/e45/ba0/3aee45ba0097ca8bdc8a23ef6a465f21.gif" title="「f（x_ {i + 1}）＆lt; f（x_ {i}）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">論理的な問題が発生します：そのような（肯定的な）はまったく存在します</font></font><img src="https://habrastorage.org/getpro/habr/post_images/eb2/94d/fe4/eb294dfe4cfca7355f8b030f3d7dade8.gif" title="「\ alpha_ {i}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">そして、この質問に対する答えが肯定的である場合、彼ら</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="「p_ {i}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそれを降下の方向と呼びます。</font><font style="vertical-align: inherit;">次に、この方法で問題を提起することができます。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュートン法によって生成される方向は、いつ降下する方向ですか？</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれに答えるには、最小化問題を別の側面から見る必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降下法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最小化問題の場合、このアプローチは非常に自然に見えます。任意のポイントから始めて、方向pを何らかの方法で選択し、この方向に一歩進み</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fbf/01e/b21/fbf01eb21703831c5dd0e196a2efccc2.gif" title="「\ alpha p」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。の場合</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bd9/6f9/580/bd96f95806b05f65a5766db233a85653.gif" title="「f（x + \ alpha p）＆lt; f（x）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b87/e59/538/b87e59538ed10c96ec3db2e7bad8dc85.gif" title="「x + \ alpha p」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい開始点として、手順を繰り返します。方向を任意に選択する場合、そのような方法はランダムウォーク法と呼ばれることがあります。単位基底ベクトルを方向として使用することが可能です。つまり、1つの座標のみでステップを実行するため、この方法は座標降下法と呼ばれます。言うまでもなく、効果がないのですか？このアプローチがうまく機能するためには、追加の保証が必要です。これを行うには、補助機能を導入します</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8bf/1d5/4e1/8bf1d54e1f36dd4c9dfd5720437af51c.gif" title="「g（p）= f（x + p）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最小化が最小化と</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="「f」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に同等であること</font><font style="vertical-align: inherit;">は非常に明白だと思います</font></font><img src="https://habrastorage.org/getpro/habr/post_images/da7/7c5/b48/da77c5b4891cf3d059f1b04a28b230ef.gif" title="g"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="「f」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微分可能である</font><font style="vertical-align: inherit;">場合は</font></font><img src="https://habrastorage.org/getpro/habr/post_images/da7/7c5/b48/da77c5b4891cf3d059f1b04a28b230ef.gif" title="g"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フォームで表現可能で</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e47/615/d31/e47615d310276ab67a9163889a2335a5.gif" title="&quot;g（p）= f（x）+ \ bigtriangledown f ^ {T}（x）p + o（\ parallel p \ parallel ^ {2}）&quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a7/342/acb/2a7342acbe0772f75af6eee281c247d0.gif" title="「\平行p \平行」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十分に小さい場合は</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2ef/8a9/23f/2ef8a923f49cf84264effb5f3f703c31.gif" title="&quot;g(p)\approx\bar{g}(p)=f(x)+\bigtriangledown f^{T}(x)p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これで、最小化</font></font><img src="https://habrastorage.org/getpro/habr/post_images/076/563/484/076563484d4e576c5c48098bfa94d45c.gif" title="&quot;g(p)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題をその近似（または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を最小化するタスク</font><font style="vertical-align: inherit;">に置き換えることができます</font></font><img src="https://habrastorage.org/getpro/habr/post_images/174/774/888/1747748884846362babfd8fe73857f1e.gif" title="&quot;\bar{g}(p)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ちなみに、モデルの使用に基づくすべての方法</font></font><img src="https://habrastorage.org/getpro/habr/post_images/174/774/888/1747748884846362babfd8fe73857f1e.gif" title="&quot;\bar{g}(p)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は勾配と呼ばれます。しかし、問題</font></font><img src="https://habrastorage.org/getpro/habr/post_images/462/957/dda/462957dda265f4fb8be04327f1c12b0f.gif" title="&quot;\bar{g}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は線形関数であるため、最小値はありません。この問題を解決するために、実行するステップの長さに制限を追加します。この場合、これは完全に自然な要件です。これは、モデルが多かれ少なかれ、十分に小さい近傍でのみ目的関数を正しく記述しているためです。その結果、条件付き最適化の追加の問題が発生します。</font><font style="vertical-align: inherit;">
この問題には明らかな解決策があります。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8a2/c43/279/8a2c4327974067619cfad20b7ea1e821.gif" title="\\\bar{g}(p) =f(x)+\bigtriangledown f^{T}(x)p\rightarrow\min \\ \parallel p\parallel_{2}=\Delta"></a><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1f6/a21/3ff1f6a2117e5d9a99603bcc8fde4f69.gif" title="&quot;p=-\beta\bigtriangledown f(x)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="&quot;\beta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、制約の実現を保証する要素です。その後、反復降下が形になります</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/987/c25/966987c257a50df1855a50ea363350dd.gif" title="&quot;x_{i+1}=x_{i}-\beta\bigtriangledown f(x_{i})&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、よく知られた見つけるれる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">勾配降下方法を</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。パラメータ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="&quot;\beta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は通常降下速度と呼ばれ、完全に理解可能な意味を獲得しました。その値は、新しい点が、古い点の周囲にある特定の半径の球上にあるという条件から決定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構築された目的関数のモデルの特性に基づいて、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="&quot;\Delta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に小さい場合でも</font></font><img src="https://habrastorage.org/getpro/habr/post_images/84b/5fd/00f/84b5fd00fe1f4ca32b7cd7bd095a1490.gif" title="&quot;\bar{g}(p) &amp;lt; \bar{g}(0)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その</font><font style="vertical-align: inherit;">ような場合</font><font style="vertical-align: inherit;">、その</font><font style="vertical-align: inherit;">ような場合</font><font style="vertical-align: inherit;">があると主張でき</font></font><img src="https://habrastorage.org/getpro/habr/post_images/553/80b/dc5/55380bdc5a434366df6d181078d6a8b7.gif" title="&quot;g(p) &amp;lt; g(0)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。この場合、移動する方向がこの球の半径のサイズに依存しないことに注意してください。次に、次のいずれかの方法を選択できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何らかの方法で値を選択すること</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="&quot;\Delta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切な値を選択するタスクを設定する</font></font><img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="&quot;\beta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、目的関数の値が確実に減少します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のアプローチは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トラストリージョンの方法に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的であり</font><font style="vertical-align: inherit;">、2番目の</font><font style="vertical-align: inherit;">アプローチは</font><font style="vertical-align: inherit;">いわゆるの補助問題の定式化につながります </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形検索（LineSearch）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この特定のケースでは、これらのアプローチの違いは小さく、考慮しません。</font><font style="vertical-align: inherit;">代わりに、次のことに注意を払いましょう。</font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ、実際に、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確に球に</font><font style="vertical-align: inherit;">あるオフセットを探しているの</font><font style="vertical-align: inherit;">ですか？</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、この制限を、たとえば、pが立方体の表面に属しているという要件に置き換えることができます。つまり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cf1/a35/92e/cf1a3592ebe97c9e262a083ea44c594c.gif" title="&quot;\parallel p\parallel_{\infty}=\Delta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（この場合、これはあまりにも合理的ではありませんが、なぜそうではないのですか）、または楕円形の表面ですか？ガリー関数を最小化するときに発生する問題を思い出せば、これはすでに非常に論理的に思えます。この問題の本質は、一部の座標線に沿って関数が他の座標線よりもはるかに速く変化することです。このため、増分が球に属している場合</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="&quot;\Delta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「降下」が提供される</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">は非常に小さいはずです。そして、これは最小値を達成するには非常に多くのステップが必要になるという事実につながります。しかし、代わりに適切な楕円を近傍として取ると、この問題は魔法のように無効になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
楕円面の点が属しているという条件により、次のような形</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6ff/1b4/930/6ff1b49309ec84aa656d848764359b4e.gif" title="&quot;\parallel p\parallel_{B}=\sqrt{p^{T}Bp}=\Delta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">書くことができます</font><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="&quot;B&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックとも呼ばれる正定行列です。ノルム</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ab8/b42/711/ab8b42711a932f9129bdb193b6a74360.gif" title="&quot;\parallel\cdot\parallel_{B}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、行列によって誘導される楕円ノルムと呼ばれ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="&quot;B&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。それはどのようなマトリックスであり、それをどこから取得するのか-後で検討しますが、今は新しいタスクに到達します。</font><font style="vertical-align: inherit;">
ノルムの二乗と1/2係数は、ここでは便宜のためにのみ示しています。これは、ルーツを混乱させないためです。ラグランジュ乗数の方法を適用すると、無条件最適化の限界問題が発生します。その</font><font style="vertical-align: inherit;">
最小値に必要な条件は</font><font style="vertical-align: inherit;">、または</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">
この</font><font style="vertical-align: inherit;">場合も</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">移動</font><font style="vertical-align: inherit;">する方向</font><font style="vertical-align: inherit;">は値に依存せず</font><font style="vertical-align: inherit;">、行列にのみ</font><font style="vertical-align: inherit;">依存することがわかります</font><font style="vertical-align: inherit;">。繰り返しになります</font><font style="vertical-align: inherit;">が、計算の必要性に悩まされているものを</font><font style="vertical-align: inherit;">選択し</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">、行列を明示的に反転させる</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f4c/cc0/757/f4ccc0757e09fb304ff10a9a8c4751b6.gif" title="\\\bar{g}(p) =f(x)+\bigtriangledown f^{T}(x)p\rightarrow\min \\ \dfrac{1}{2}\parallel p\parallel_{B}^{2}=\Delta"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/605/36d/d5e/60536dd5e2297580940a5b926760a3ce.gif" title="f(x)+\bigtriangledown f^{T}(x)p+\dfrac{\lambda}{2}p^{T}Bp-\lambda\Delta\rightarrow\min"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4c5/f7e/921/4c5f7e921637c73fcb992c5d9b9efcd6.gif" title="\bigtriangledown f(x)+\lambda Bp=0"></a><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/a80/6c9/ff7/a806c9ff7ce22ea27c87b6a61a4c8fed.gif" title="&quot;B \左（\ラムダp \右）=-\ bigtriangledown f（x）&quot;"><font style="vertical-align: inherit;"></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/b50/032/3a9/b500323a970c7ae821295450627bdad2.gif" title="p =-\ dfrac {1} {\ lambda} B ^ {-1} \ bigtriangledown f（x）= \ dfrac {1} {\ lambda} \ bar {p}"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/697/906/5d7/6979065d729033e0093ffad8475e80a6.gif" title="\\\ dfrac {1} {\ lambda ^ {2}} \左（B ^ {-1} \ bigtriangledown f（x）\ right）^ {T} B \左（B ^ {-1} \ bigtriangledown f （x）\右）= \ dfrac {1} {\ lambda ^ {2}} \ bigtriangledown f（x）^ {T} B ^ {-1} BB ^ {-1} \ bigtriangledown f（x）= \ \ = \ dfrac {1} {\ lambda ^ {2}} \ bigtriangledown f（x）^ {T} B ^ {-1} \ bigtriangledown f（x）= \ Delta"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/41f/689/d89/41f689d890b92c84f05fdd0ede8a8114.gif" title="\ lambda = \ sqrt {\ dfrac {1} {\ Delta} \ bigtriangledown f（x）^ {T} B ^ {-1} \ bigtriangledown f（x）}> 0"></a><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/45b/686/bb0/45b686bb0219a74b212cfdeaf1998653.gif" title="&quot;\ bar {p} =-B ^ {-1} \ bigtriangledown f（x）&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="「\ Delta」"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="「B」"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="「\ Delta」"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="「\ラムダ」"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="「B」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、適切なバイアスを見つけるという補助問題を解決し</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b7b/6a7/371/b7b6a73716dc8f4e40a52c1c5ef0e6b4.gif" title="「x_ {i + 1} = x_ {i} + \ beta \ bar {p} _ {i}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。以来</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0b8/52f/d1b/0b852fd1bbc20f2966bf757a56186312.gif" title="「\ラムダ＆gt; 0」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この補助問題に対する解決策が存在することが保証されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、行列Bはどうなるのでしょうか。私たちは自分たちを投機的なアイデアに制限します。目的関数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="「f」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が2次</font><font style="vertical-align: inherit;">関数で</font><font style="vertical-align: inherit;">ある</font><font style="vertical-align: inherit;">場合、つまり、目的関数</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">正定の</font><font style="vertical-align: inherit;">形式</font></font><img src="https://habrastorage.org/getpro/habr/post_images/974/f7f/cf6/974f7fcf6345b91ef8466f2cabba6efe.gif" title="「f（x）= a + b ^ {T} x + x ^ {T} Hx」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である場合</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="「H」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="「B」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッセ</font><font style="vertical-align: inherit;">行列が行列の役割の最良の候補であることは明らか</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="「H」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。 Hが正定でない場合、Hはメトリックにすることはできません。Hを使用して作成された反復は、減衰ニュートン法の反復ですが、降下法の反復ではありません。最後に、私たちは厳密な答えを出すことができます</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質問：</font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュートン法のヘッセ行列は正定でなければなりませんか？</font></font></i><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回答：</font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ、標準または減衰ニュートン法では必要ありません。ただし、この条件が満たされている場合、減衰ニュートン法は降下法であり、</font><font style="vertical-align: inherit;">ローカル収束だけでなく</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のプロパティを持ちます</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
例として、よく知られたローゼンブロック関数が勾配降下法とニュートン法によって最小化された場合の信頼領域の様子と、領域の形状がプロセスの収束にどのように影響するかを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_x/30/nx/_x30nxs-eyrixuan0-diyvwixww.gif" width="600"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、降下法が球面信頼領域でどのように動作するかであり、勾配降下でもあります。すべてが教科書のようなものです-私たちは峡谷で立ち往生しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9x/ik/td/9xiktd4lapdka-uk010evfvlcdm.gif" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてこれは、信頼領域がヘッセ行列によって定義された楕円の形状を持っている場合に得られます。これは、減衰ニュートン法の反復にすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一の未解決の問題は、ヘッセ行列が正定でない場合にどうするかです。多くのオプションがあります。最初は得点することです。多分あなたは幸運で、ニュートンの反復はこの特性なしで収束します。これは非常に現実的であり、特に最小化プロセスの最終段階では、すでにソリューションに十分近づいています。この場合、標準のニュートン法の反復は、降下が許容される近傍の検索に煩わされることなく使用できます。または、の場合</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6da/2c0/bc5/6da2c0bc54434a64d7630c142d0c7bf9.gif" title="「\ベータ= 0」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまり取得した方向が降下の方向ではない</font><font style="vertical-align: inherit;">場合でも、減衰ニュートン法の反復を使用</font><font style="vertical-align: inherit;">して、逆勾配に変更します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で行っ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">ように</font><i><font style="vertical-align: inherit;">、シルベスター基準に従ってヘッセ行列が正定であるかどうかを明示的に確認する必要はありません。</font></i><font style="vertical-align: inherit;">。それは無駄で無意味です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より微妙な方法では、ヘッセ行列に近い意味で行列を作成しますが、特に固有値を修正することにより、正定性の特性を備えています。別のトピックは、準ニュートン法、または可変計量法です。これらは、行列Bの正定性を保証し、2次導関数の計算を必要としません。一般に、これらの問題の詳細な説明は、この記事の範囲をはるかに超えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、そしてちなみに、それは言われていることから続きます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッセン勾配法の正定性を持つニュートンの減衰法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">準ニュートン法のように。</font><font style="vertical-align: inherit;">そして、他の多くは、方向とステップサイズの個別の選択に基づいています。</font><font style="vertical-align: inherit;">したがって、ニュートン法と勾配用語を対比することは正しくありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要約する</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニュートン法は、最小化法を論じるときによく覚えられますが、通常、古典的な意味でのニュートン法ではなく、目的関数のヘッセ行列によって指定されるメトリックを使用した降下法です。そして、はい、ヘッセ行列がどこでも正定であれば、それはグローバルに収束します。これは、実際にはあまり一般的ではない凸関数でのみ可能であるため、適切な変更を行わない場合、一般に、Newtonメソッドの適用（集合から脱却せず、引き続き呼び出します）では、正しい結果が保証されません。ニューラルネットワークのトレーニングは、たとえ浅いネットワークでも、通常、多くの極小値を持つ非凸最適化問題を引き起こします。そして、ここに新しい待ち伏せがあります。ニュートン法は通常、収束します（収束した場合）。とても速いという意味です。そして、これは奇妙なことに、悪いです、数回の反復で極小値に到達するためです。また、地形が複雑な関数の場合は、グローバルなものよりもはるかに悪くなる可能性があります。線形探索による勾配降下法は収束がはるかに遅くなりますが、最小化の初期段階で非常に重要であるターゲット関数のリッジを「スキップ」する可能性が高くなります。目的関数の値をすでに十分に下げており、勾配降下法の収束が大幅に遅くなっている場合は、ここでメトリックの変更によってプロセスが加速される可能性がありますが、これは最終段階のものです。目的関数の値をすでに十分に下げており、勾配降下法の収束が大幅に遅くなっている場合は、ここでメトリックの変更によってプロセスが加速される可能性がありますが、これは最終段階のものです。目的関数の値をすでに十分に下げており、勾配降下法の収束が大幅に遅くなっている場合は、ここでメトリックの変更によってプロセスが加速される可能性がありますが、これは最終段階のものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、この議論は普遍的ではなく、議論の余地もありません。</font><font style="vertical-align: inherit;">同様に、勾配法は問題を学習するのに最適です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469861/index.html">ゲームプログラマー向けのデータ構造：バルクデータ</a></li>
<li><a href="../ja469867/index.html">それがどのように男子生徒になるのか（そしてボードゲームがそれとどう関係するのか）</a></li>
<li><a href="../ja469869/index.html">ランダムアクセスメモリをオーバークロックする理由（簡単です！）</a></li>
<li><a href="../ja469871/index.html">キーボードがテーブルだったとき</a></li>
<li><a href="../ja469875/index.html">2019年にパスワードを保護する方法</a></li>
<li><a href="../ja469879/index.html">ワンクリックでダブルVPN。入口と出口のIPアドレスを簡単に分割する方法</a></li>
<li><a href="../ja469881/index.html">ハブレの投稿の生涯の最初の3日間</a></li>
<li><a href="../ja469883/index.html">ランダム性をプログラムすることは可能ですか？</a></li>
<li><a href="../ja469885/index.html">x11vncを使用する場合はローカルコンソールを無効にする</a></li>
<li><a href="../ja469889/index.html">SamsPcbGuide、パート12：テクノロジー-BGAタイプの筐体、プラスチックおよびスペースII</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>