<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♠️ 🏈 🔊 当我写信使时 👧🏻 👩🏻‍🔧 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在又一个令人沮丧的一天之后的一个晚上，充满了平衡游戏的尝试，我决定我急需休息一下。我将切换到另一个项目，迅速执行，返回在游戏开发过程中逐渐减弱的自尊心，并将以新的活力席卷整个游戏！最主要的是选择一个不错且轻松的项目。写您自己的Messenger？哈！它能有多难？
 
 该代码可以在这里找到。
   ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>当我写信使时</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490070/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在又一个令人沮丧的一天之后的一个晚上，充满了平衡游戏的尝试，我决定我急需休息一下。</font><font style="vertical-align: inherit;">我将切换到另一个项目，迅速执行，返回在游戏开发过程中逐渐减弱的自尊心，并将以新的活力席卷整个游戏！</font><font style="vertical-align: inherit;">最主要的是选择一个不错且轻松的项目。写您自己的Messenger？</font><font style="vertical-align: inherit;">哈！</font><font style="vertical-align: inherit;">它能有多难？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/_b/cw/av/_bcwavbn-h0r3vgv8zzhdkaq09y.jpeg"></td>
<td><img src="https://habrastorage.org/webt/97/4x/qd/974xqd470ltfwu6gge0hfnaqry4.jpeg"></td>
</tr>
</tbody></table></div><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简要背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始从事Messenger之前的将近一年时间里，他一直在从事在线多人在线《线下大战》游戏。</font><font style="vertical-align: inherit;">编程进行得很顺利，其他所有东西（尤其是平衡感和视觉感）都不是很好。</font><font style="vertical-align: inherit;">突然发现，制作游戏和制作有趣的游戏（为自己以外的人带来乐趣）是两回事。</font><font style="vertical-align: inherit;">经过一年的磨难，我需要分心，所以我决定尝试其他事情。</font><font style="vertical-align: inherit;">选择取决于移动开发，即Flutter。</font><font style="vertical-align: inherit;">我听到了关于Flutter的很多好消息，经过短暂的实验，我喜欢飞镖。</font><font style="vertical-align: inherit;">我决定写自己的Messenger。</font><font style="vertical-align: inherit;">首先，最好同时实施客户端和服务器。</font><font style="vertical-align: inherit;">其次，我将在投资组合中寻找重要的工作。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预定功能</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私人和群聊</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送文本，图像和视频</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频和视频通话</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确认收货和阅读（Votsap的提示）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“印刷品...”</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知事项</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过QR码和地理位置搜索</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
展望未来，我可以自豪地（并欣慰地）说，几乎所有已计划的计划都已实施，而尚未实施-将在不久的将来实施。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://player.vimeo.com/video/393246625" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语言选择</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我很久没有选择语言了。</font><font style="vertical-align: inherit;">最初，在客户端和服务器上都使用dart是很诱人的，但是更详细的检查表明，没有可用的dart驱动程序，而那些驱动程序并没有激发很大的信心。</font><font style="vertical-align: inherit;">尽管我不保证谈论当前时刻，但情况可能有所改善。</font><font style="vertical-align: inherit;">因此，我的选择落在了我在Unity中工作过的C＃上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建筑</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他开始思考建筑。</font><font style="vertical-align: inherit;">当然，考虑到三分之二的人最有可能使用我的Messenger，因此一般而言，人们不必去烦恼建筑。</font><font style="vertical-align: inherit;">您可以按照无数教程中的说明进行操作。</font><font style="vertical-align: inherit;">这是节点，这是mongo，这是Web套接字。</font><font style="vertical-align: inherit;">做完了 </font><font style="vertical-align: inherit;">Firebase就在附近。</font><font style="vertical-align: inherit;">但这并不有趣。</font><font style="vertical-align: inherit;">我决定制作一个可以轻松水平扩展的Messenger，好像我希望有数百万个同时进行的客户一样。</font><font style="vertical-align: inherit;">但是，由于我没有这方面的经验，因此我不得不通过错误和错误的方法来学习实践中的所有内容。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终的架构看起来像这样</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/xp/jc/n7/xpjcn7otuw8am5jv9yztpp1sgyu.png"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我并不是说这样的体系结构超级酷且可靠，但是它是可行的，并且</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理论上</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该可以承受重负荷并可以水平扩展，但是我并不真正了解如何检查。</font><font style="vertical-align: inherit;">我希望我不要错过除了我之外每个人都知道的明显时刻。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是各个组件的详细说明。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前端服务器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
甚至在我开始制作游戏之前，我就对异步单线程服务器的概念着迷。</font><font style="vertical-align: inherit;">有效且没有潜在的竞赛机会-您还能要求什么。</font><font style="vertical-align: inherit;">为了了解如何安排这些服务器，我开始深入研究</font></font><code>asyncio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python语言</font><font style="vertical-align: inherit;">模块</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我看到的解决方案看起来非常优雅。</font><font style="vertical-align: inherit;">简而言之，伪代码解决方案如下所示。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-comment">//  ,      ,    </span>
<span class="hljs-comment">//       .      socket.Receive</span>
<span class="hljs-comment">//     , :</span>
<span class="hljs-keyword">var</span> bytesReceived = Completer&lt;<span class="hljs-keyword">object</span>&gt;();<font></font>
selector.Register(<font></font>
    socket,<font></font>
    SocketEvent.Receive,<font></font>
    () =&gt; bytesReceived.Complete(<span class="hljs-literal">null</span>)<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">await</span> bytesReceived.Future;<font></font>
<font></font>
<span class="hljs-keyword">int</span> n = socket.Receive(...); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-comment">// selector -     poll.   </span>
<span class="hljs-comment">//        (Receive </span>
<span class="hljs-comment">//  ), ,    ,  .</span>
<span class="hljs-comment">//   completer,      ,</span>
<span class="hljs-comment">//        , ,     .</span>
<span class="hljs-comment">//     ,       .</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用这种简单的技术，我们可以在单个线程中服务大量套接字。</font><font style="vertical-align: inherit;">我们永远不会在等待接收或发送字节时阻塞流。</font><font style="vertical-align: inherit;">流总是忙于有用的工作。</font><font style="vertical-align: inherit;">总之，并发。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前端服务器是通过这种方式实现的。</font><font style="vertical-align: inherit;">它们都是单线程和异步的。</font><font style="vertical-align: inherit;">因此，为了获得最佳性能，一台计算机上需要运行具有核心数量的服务器（图中为4个）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前端服务器从客户端读取消息，然后根据消息代码将其发送到Kafka中的主题之一。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不熟悉kafa的人的小注脚</font></font></b><div class="spoiler_text">   ,          RabbitMQ.    .       ,              (   authentication backend     authentication, ).  ?      -  ,         (partition).      ,      .      ,   ,       . ,             ( ,   ,  ,     (headers)).<br>
<br>
  ?     ?      .   (consumer)         (  consumer'),    ( )      . , ,      ,    2 ,       .   3 —     2.                .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前端服务器不带密钥就向Kafka发送消息（如果没有密钥，则Kafka只是依次向聚会发送消息）。消息由相应的后端服务器之一从主题中拉出。服务器处理该消息，然后...接下来是什么？还有什么进一步取决于消息的类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最常见的情况下，会发生请求-响应周期。例如，对于注册请求，我们只需要给客户一个答案（</font></font><code>Success</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>EmailAlreadyInUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）。但是，对于包含邀请邀请新成员（Vasya，Emil和Julia）进行现有聊天的消息，我们需要立即使用三种不同类型的消息进行响应。第一种类型-您需要将操作的结果通知邀请者（突然发生服务器错误）。第二种类型-您需要通知聊天的所有当前成员，聊天中现在有此类成员。第三是向Vasya，Emil和Yulia发送邀请。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，这听起来并不困难，但是为了向任何客户端发送消息，我们需要：1）找出此客户端连接到哪个前端服务器（我们不选择客户端将连接到哪个服务器，平衡器会为我们决定）； 2）从后端服务器向所需的前端服务器发送消息； 3）实际上是向客户端发送消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了实现第1点和第2点，我决定使用一个单独的主题（“前端服务器”主题）。将身份验证，会话和呼叫主题分隔为多个分区可充当并行化机制。我们看到会话服务器负载很重吗？只需添加几个新的分区和会话服务器，Kafka就会为我们重新分配负载，卸载现有的会话服务器。将“前端服务器”主题分离到分区中充当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路由</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机制</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个前端服务器对应于“前端服务器”主题的一部分（具有与服务器本身相同的索引）。也就是说，服务器0-分区0，依此类推。 Kafka不仅可以订阅特定主题，还可以订阅特定主题的特定部分。初创企业上的所有前端服务器都订阅相应的分区。因此，后端服务器能够通过将消息发送到特定分区来将消息发送到特定前端服务器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，现在客户端加入时，您只需要在某处保存一对UserId-Frontend Server Index。如果断开连接-删除。为此，许多内存键值数据库都可以使用。我选了萝卜。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在实践中的外观。</font><font style="vertical-align: inherit;">首先，建立连接后，客户端Andrey向服务器发送一条消息</font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">前端服务器接收到该消息并将其转发到会话主题，并预先添加了“前端服务器”标头：{index}。</font><font style="vertical-align: inherit;">其中一个后端会话服务器将收到一条消息，读取授权令牌，确定已加入的用户类型，读取前端服务器添加的索引，并将UserId-索引写入萝卜。</font><font style="vertical-align: inherit;">从这一刻起，该客户端被认为是联机的，现在我们知道当其他客户端向Andrey发送消息时，可以通过哪个前端服务器（相应地，通过“前端服务器”主题的哪一部分）与该客户端“联系”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*实际上，该过程比我描述的要复杂一些。</font><font style="vertical-align: inherit;">您可以在源代码中找到它。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前端服务器伪代码</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-comment">// Frontend Server 6</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Consume from "Frontend Servers" topic, partition 6</span>
    <span class="hljs-keyword">var</span> messageToClient = consumer.Consume();
    <span class="hljs-keyword">if</span> (message != <span class="hljs-literal">null</span>) {<font></font>
        relayMessageToClient(messageToClient);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> callbacks = selector.Poll();
    <span class="hljs-keyword">while</span> (callbacks.TryDequeue(<span class="hljs-keyword">out</span> callback)) {<font></font>
        callback();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">long</span> now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    <span class="hljs-keyword">while</span> (!callAtQueue.IsEmpty &amp;&amp; callAtQueue.PeekPriority() &lt;= now) {<font></font>
        callAtQueue.Dequeue()();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (messagesToRelayToBackendServers.TryDequeue(<span class="hljs-keyword">out</span> messageFromClient)) {
        <span class="hljs-comment">// choose topic</span><font></font>
        producer.Produce(topic, messageFromClient);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里有一些技巧。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）</font></font><code>relayMessageToClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。仅获取所需的套接字并立即开始向其发送消息是一个错误，因为也许我们</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向客户端发送其他消息。如果我们开始发送字节而不检查套接字当前是否繁忙，则消息将混合在一起。像在许多其他需要顺序处理数据的地方一样，诀窍是使用队列，即来自Completers的队列（</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在C＃中）。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">relayMessageToClient</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-comment">// find client</span>
    <span class="hljs-keyword">await</span> client.ReadyToSend();
    <span class="hljs-keyword">await</span> sendMessage(client, message);<font></font>
    client.CompleteSend();<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {
    <span class="hljs-comment">// ...</span>
    sendMessageQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Completer&lt;<span class="hljs-keyword">object</span>&gt;&gt;();<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">async</span> Future <span class="hljs-title">ReadyToSend</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">var</span> sendMessage = Completer&lt;<span class="hljs-keyword">object</span>&gt;();
	<span class="hljs-keyword">if</span> (sendMessageQueue.IsEmpty) {<font></font>
	    sendMessageQueue.AddLast(sendMessage);<font></font>
	} <span class="hljs-keyword">else</span> {
	    <span class="hljs-keyword">var</span> prevSendMessage = sendMessageQueue.Last;<font></font>
	    sendMessageQueue.AddLast(sendMessage);<font></font>
	    <span class="hljs-keyword">await</span> prevSendMessage.Future;<font></font>
	}<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CompleteSend</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">var</span> sendMessage = sendMessageQueue.RemoveFirst();<font></font>
	sendMessage.Complete(<span class="hljs-literal">null</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果队列不为空，则此刻套接字已被占用。创建一个新的</font></font><code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，把它添加到队列中，并</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前面的一个</font></font></i> <code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，发送上一条消息时，它将</font></font><code>CompleteSend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成</font></font><code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这将导致服务器开始发送下一条消息。这样的队列还允许平稳传播异常。假设在向客户端发送消息时发生错误。在这种情况下，我们不仅需要发送此消息，还需要发送队列中当前正在等待的所有消息（挂在</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ ah”上），因此需要完成。如果我们不这样做，则它们将继续挂起，并且我们将收到内存泄漏。为简便起见，此处未显示执行此操作的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）</font></font><code>selector.Poll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。实际上，这甚至不是一个技巧，而只是试图消除方法实现的缺点</font></font><code>Socket.Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>selector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-只是对该方法的包装）。根据内部操作系统的不同，此方法使用</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>poll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但这在这里并不重要。重要的是此方法如何与我们将其馈送到输入的列表（用于读取，写入，错误检查的套接字列表）一起使用。此方法获取列表，轮询套接字，仅将那些准备好执行所需操作的套接字留在列表中。所有其他套接字都从列表中抛出。 “踢”通过</font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（也就是说，所有后续元素都会移动，这是无效的）。另外，由于我们需要在循环的每个迭代中轮询所有已注册的套接字，所以这种“清理”通常是有害的，因此我们每次都必须重新填充列表。我们可以使用自定义</font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">来解决所有这些问题</font><font style="vertical-align: inherit;">，</font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">不会将项目从列表中删除，而只是将其标记为已删除。该类</font></font><code>ListForPolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我对此类列表的实现。</font></font><code>ListForPolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅适用于该方法</font></font><code>Socket.Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不适用于其他任何方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）</font></font><code>callAtQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在大多数情况下，已将客户端消息发送到后端服务器的前端服务器期望得到响应（确认操作成功，如果出现问题则返回错误）。如果他没有在可配置的时间段内等待答案，那么他会将错误发送给客户端，这样他就不会等待永远不会出现的答案。</font></font><code>callAtQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是优先级队列。服务器将消息发送到Kafka之后，立即执行以下操作：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">long</span> now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
callAtQueue.Enqueue(callback, now + config.WaitForReplyMSec);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在回调中，等待响应被取消，服务器错误发送开始。如果收到来自后端服务器的响应，则回调不执行任何操作。</font><font style="vertical-align: inherit;">由于它</font><font style="vertical-align: inherit;">是在池中的线​​程上执行的，</font><font style="vertical-align: inherit;">因此无法</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><code>await Task.WhenAny(answerReceivedTask, Task.Delay(x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font></font><code>Task.Delay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这里是有关前端服务器的所有内容。这里需要进行一些更正。实际上，服务器不</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单线程。当然，幕后的kafka使用线程，但是我的意思是应用程序代码。事实是，将消息发送到kafka（生产）主题可能不会成功。如果发生故障，Kafka会重复发送一定数量的可配置次数，但是，如果重复出发失败，Kafka会毫无希望地放弃这项业务。您可以检查消息是否成功发送，</font></font><code>deliveryHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后我们将其传递给该方法</font></font><code>Produce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Kafka在生产者的I / O线程（发送消息的线程）中调用此处理程序。我们必须确保成功发送了消息，如果没有成功，则取消等待后端服务器的响应（由于未发送请求，响应不会出现），然后将错误发送给客户端。也就是说，我们无法避免与另一个线程进行交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*在写文章时，我突然意识到我们不能传递</font></font><code>deliveryHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给该方法</font></font><code>Produce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或简单地忽略所有的kafka错误（该错误仍将在我前面描述的超时之前发送给客户端）-然后我们所有的代码都将是单线程的。</font><font style="vertical-align: inherit;">现在我正在考虑如何做得更好。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么实际上是卡夫卡而不是兔子？</font></font></b><div class="spoiler_text">,        ,   ,  , ,   RabbitMQ?        .  , ,   .     ?    ,         frontend .   ,     backend ,      ,          .    ,       ,     .   ,       error-prone.  ,     <code>basicGet</code> ,    ,   ,      .     .      <code>basicGet</code>,      ,       .          .<br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后端服务器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与前端服务器相比，这里几乎没有有趣的地方。</font><font style="vertical-align: inherit;">所有后端服务器都以相同的方式工作。</font><font style="vertical-align: inherit;">在启动时，服务器订阅主题（身份验证，会话或呼叫，取决于角色），而kafka为其分配一个或多个分区。</font><font style="vertical-align: inherit;">服务器从Kafka接收消息，进行处理并通常发送一个或多个消息作为响应。</font><font style="vertical-align: inherit;">几乎真实的代码：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">long</span> lastCommitTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> consumeResult = consumer.Consume(<font></font>
            TimeSpan.FromMilliseconds(config.Consumer.PollTimeoutMSec)<font></font>
        );<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (consumeResult != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> workUnit = <span class="hljs-keyword">new</span> WorkUnit() {<font></font>
                ConsumeResult = consumeResult,<font></font>
            };<font></font>
<font></font>
            LinkedList&lt;WorkUnit&gt; workUnits;<font></font>
            <span class="hljs-keyword">if</span> (partitionToWorkUnits.ContainsKey(consumeResult.Partition)) {<font></font>
                workUnits = partitionToWorkUnits[consumeResult.Partition];<font></font>
            } <span class="hljs-keyword">else</span> {<font></font>
                workUnits = partitionToWorkUnits[consumeResult.Partition] =<font></font>
                    <span class="hljs-keyword">new</span> LinkedList&lt;WorkUnit&gt;();<font></font>
            }<font></font>
<font></font>
            workUnits.AddLast(workUnit);<font></font>
<font></font>
            handleWorkUnit(workUnit);<font></font>
        }<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (<font></font>
            DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - lastCommitTime &gt;=<font></font>
            config.Consumer.CommitIntervalMSec<font></font>
        ) {<font></font>
            commitOffsets();<font></font>
	    lastCommitTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
	}<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要提交哪种补偿？</font></font></b><div class="spoiler_text">       .   —   (offset)    (0, 1  ).         0.        <code>TopicPartitionOffset</code>.    (consume)   ,   <code>ConsumeResult</code>, ,   ,   <code>TopicPartitionOffset</code>.     ?<br>
<br>
  at least once delivery,  ,              (    ).     ,           (commited) . ,  consumer         16,  ,  16 ,   ,      ,   .     -  consumer'     consumer'        ,    16 + 1 (   + 1).    17   .        N ,       .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我禁用了自动提交并承诺自己。这是必需的，因为</font></font><code>handleWorkUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实际执行消息处理的地方，这是一种</font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法，因此不能保证在消息6之前将处理消息5。Kafka在提交偏移之前仅分别存储一个提交的偏移（而不是一组偏移）。 6，我们需要确保所有先前的消息也已处理。此外，一台后端服务器可以同时使用来自多个分区的消息，因此，必须确保它对相应的分区提交正确的偏移量。为此，我们使用表单分区的哈希图：工作单位。这是代码的样子</font></font><code>commitOffsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（这次</font><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">实际代码）：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitOffsets</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">foreach</span> (LinkedList&lt;WorkUnit&gt; workUnits <span class="hljs-keyword">in</span> partitionToWorkUnits.Values) {<font></font>
        WorkUnit lastFinishedWorkUnit = <span class="hljs-literal">null</span>;<font></font>
        LinkedListNode&lt;WorkUnit&gt; workUnit;<font></font>
        <span class="hljs-keyword">while</span> ((workUnit = workUnits.First) != <span class="hljs-literal">null</span> &amp;&amp; workUnit.Value.IsFinished) {<font></font>
            lastFinishedWorkUnit = workUnit.Value;<font></font>
            workUnits.RemoveFirst();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lastFinishedWorkUnit != <span class="hljs-literal">null</span>) {<font></font>
            offsets.Add(lastFinishedWorkUnit.ConsumeResult.TopicPartitionOffset);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (offsets.Count &gt; <span class="hljs-number">0</span>) {<font></font>
        consumer.Commit(offsets);<font></font>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> offset <span class="hljs-keyword">in</span> offsets) {<font></font>
            logger.Debug(<font></font>
                <span class="hljs-string">"{Identifier}: Commited offset {TopicPartitionOffset}"</span>,<font></font>
                identifier,<font></font>
                offset<font></font>
            );<font></font>
        }<font></font>
        offsets.Clear();<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们遍历单位，找到此刻之前完成的最后一个单位，此后</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有不完整的单位</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并提交相应的偏移量。</font><font style="vertical-align: inherit;">这样的循环使我们避免了“漏洞”提交。</font><font style="vertical-align: inherit;">例如，如果我们当前有4个单位（</font></font><code>0: Finished, 1: Not Finished, 2: Finished, 3: Finished</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），则只能提交第0个单位，因为如果立即提交第三个单位，则可能导致丢失第1个单位（如果服务器立即死亡）。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkUnit</span> {
    <span class="hljs-keyword">public</span> ConsumeResult&lt;Null, <span class="hljs-keyword">byte</span>[]&gt; ConsumeResult { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> finished = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsFinished =&gt; finished == <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Finish</span>(<span class="hljs-params"></span>)</span> {<font></font>
        Interlocked.Increment(<span class="hljs-keyword">ref</span> finished);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br>
<code>handleWorkUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前所述，该</font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法及其</font><font style="vertical-align: inherit;">相应</font><font style="vertical-align: inherit;">方法已完全封装在中</font></font><code>try-catch-finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在中，</font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他呼唤必要的服务，在</font></font><code>finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-中</font></font><code>workUnit.Finish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务非常简单。</font><font style="vertical-align: inherit;">例如，在这里，当用户发送新消息时执行什么代码：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task&lt;ServiceResult&gt; <span class="hljs-title">createShareItem</span>(<span class="hljs-params">CreateShareItemMessage msg</span>)</span> {
    <span class="hljs-keyword">byte</span>[] message;
    <span class="hljs-keyword">byte</span>[] messageToPals1 = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">int</span>?[] partitions1 = <span class="hljs-literal">null</span>;<font></font>
<font></font>
    <span class="hljs-comment">//  UserId  .</span>
    <span class="hljs-keyword">long</span>? userId = hashService.ValidateSessionIdentifier(msg.SessionIdentifier);
    <span class="hljs-keyword">if</span> (userId != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> shareItem = <span class="hljs-keyword">new</span> ShareItemModel(<font></font>
            requestIdentifier: msg.RequestIdentifier,<font></font>
            roomIdentifier: msg.RoomIdentifier,<font></font>
            creatorId: userId,<font></font>
            timeOfCreation: <span class="hljs-literal">null</span>,<font></font>
            type: msg.ShareItemType,<font></font>
            content: msg.Content<font></font>
        );<font></font>
<font></font>
        <span class="hljs-comment">//      null,</span>
        <span class="hljs-comment">//     .</span>
        <span class="hljs-keyword">long</span>? timeOfCreation = <span class="hljs-keyword">await</span> storageService.CreateShareItem(shareItem);
        <span class="hljs-keyword">if</span> (timeOfCreation != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">//      .</span>
            List&lt;<span class="hljs-keyword">long</span>&gt; pals = <span class="hljs-keyword">await</span> inMemoryStorageService.GetRoomPals(<font></font>
                msg.RoomIdentifier<font></font>
            );<font></font>
            <span class="hljs-keyword">if</span> (pals == <span class="hljs-literal">null</span>) {
            	<span class="hljs-comment">//     -       .</span>
                pals = <span class="hljs-keyword">await</span> storageService.GetRoomPals(msg.RoomIdentifier);
                <span class="hljs-keyword">await</span> inMemoryStorageService.SaveRoomPals(msg.RoomIdentifier, pals);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-comment">//    ,  .</span><font></font>
            pals.Remove(userId.Value);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (pals.Count &gt; <span class="hljs-number">0</span>) {
            	<span class="hljs-comment">//  ack,  ,    </span>
                <span class="hljs-comment">//    .</span>
                <span class="hljs-keyword">await</span> storageService.CreateAck(<font></font>
                    msg.RequestIdentifier, userId.Value, msg.RoomIdentifier,<font></font>
                    timeOfCreation.Value, pals<font></font>
                );<font></font>
<font></font>
                <span class="hljs-comment">// in -  UserId, out -   frontend ,</span>
                <span class="hljs-comment">//    .  -   -</span>
                <span class="hljs-comment">//   null.</span>
                partitions1 = <span class="hljs-keyword">await</span> inMemoryStorageService.GetUserPartitions(pals);<font></font>
<font></font>
                List&lt;<span class="hljs-keyword">long</span>&gt; onlinePals = getOnlinePals(pals, partitions1);<font></font>
<font></font>
                <span class="hljs-comment">//    ,       .</span>
                <span class="hljs-comment">//         .</span>
                <span class="hljs-keyword">if</span> (onlinePals.Count &gt; <span class="hljs-number">0</span>) {<font></font>
                    messageToPals1 = converterService.EncodeNewShareItemMessage(<font></font>
                        userId.Value, timeOfCreation.Value, onlinePals, shareItem<font></font>
                    );<font></font>
                    nullRepeatedPartitions(partitions1);<font></font>
                    <span class="hljs-comment">// -         </span>
                    <span class="hljs-comment">// frontend ,    null' .</span><font></font>
                }<font></font>
            }<font></font>
<font></font>
            message = converterService.EncodeSuccessfulShareItemCreationMessage(<font></font>
                msg.RequestIdentifier, timeOfCreation.Value<font></font>
            );<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
            message = converterService.EncodeMessage(<font></font>
                MessageCode.RoomNotFound, msg.RequestIdentifier<font></font>
            );<font></font>
        }<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        message = converterService.EncodeMessage(<font></font>
            MessageCode.UserNotFound, msg.RequestIdentifier<font></font>
        );<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceResult(<font></font>
        message: message, <span class="hljs-comment">//    .</span>
        messageToPals1: messageToPals1, <span class="hljs-comment">//  -    .</span><font></font>
        partitions1: partitions1<font></font>
    );<font></font>
}<font></font>
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
后端服务器调用的服务的大多数功能只是将新数据添加到数据库并处理现有数据。显然，数据库的组织方式和操作方式对于Messenger来说非常重要，在这里我想说的是，在仔细研究了所有选项之后，我非常仔细地研究了选择数据库的问题，但事实并非如此。我之所以选择CockroachDb，是因为它以最小的努力承诺了很多，并且具有与postgres兼容的语法（我之前使用过postgres）。曾经有过使用Cassandra的想法，但是最后我决定专注于一些熟悉的东西。我从未与Kafka，Rabbit，Flutter和Dart或WebRtc一起工作过，所以我决定也不拖累Cassandra，因为我担心自己会淹没很多新技术。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在项目的所有部分中，我最怀疑的是数据库设计。我不知道我所做的决定确实</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不错</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的决定。一切正常，但可以做得更好。例如，有表ShareRooms（如我所说的聊天）和ShareItems（如我所说的消息）。因此，进入会议室的所有用户都记录在该会议室的jsonb字段中。这很方便，但显然很慢，因此我可能会使用外键重做。或者，例如，ShareItems表存储</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消息。这也很方便，但是由于ShareItems是负载最大的表之一（持久表</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），则可能需要为每个房间或类似的地方创建一个新表。 Kokroach将记录分散在不同的节点上，因此，您需要仔细考虑要走哪条记录才能获得最佳性能，但是我没有。通常，从以上所有内容可以理解，数据库不是我的强项。现在，我通常会测试所有Postgres而不是kokroach的东西，因为我的工作机器上的负载较少，负载已经很差了，很快就会起飞。幸运的是，postgres和kokroach的代码相差很多，因此切换并不困难。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我正在研究cocroach实际如何工作（SQL和键值之间的映射是如何发生的（cocroach在后台使用RocksDb），如何在节点之间分配数据，复制等等）。当然，在使用cocroach之前值得研究，但是迟到总比没有好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为，当我更好地理解这个问题时，基础将会发生很大的变化。现在，Acks桌子正困扰着我。在此表中，我存储有关谁尚未收到和谁尚未阅读消息的数据（以显示用户选中标记）。如果用户现在在线，很容易通知用户已经阅读了他的消息，但是如果没有，我们需要保存此信息以便以后通知用户。而且由于可以进行群聊，因此仅存储标记是不够的，您需要有关单个用户的数据。因此，在这里，我们直接要求使用位串（对于尚未接收到的用户来说是一行，对于尚未阅读的用户来说是第二行）。特别是kokroach的支持</font></font><code>bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>bit varying</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，鉴于房间的组成可以不断变化，我从未想出如何实施这项业务。为了使位串保持其含义，房间中的用户必须保持相同的顺序，这在例如某些用户离开房间时很难做到。这里有选项。也许值得写-1，而不是从jsonb字段中删除用户以保留顺序或使用某种版本控制方法，这样我们就知道此位字符串是指用户的顺序，那时，而不是按照当前的用户顺序。我仍在考虑如何更好地实施这项业务，但是就目前而言，那些尚未收到并且尚未阅读用户的人也只是jsonb字段。假设Acks表是随每条消息写入的，则数据量很大。尽管记录当然会在每个人都收到并读取消息后删除。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扑</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
长期以来，我在服务器端工作，并使用简单的控制台客户端进行测试，因此我什至没有创建Flutter项目。</font><font style="vertical-align: inherit;">当我创建它时，我以为服务器部分是一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分，而应用程序就是这样，垃圾，我将在几天之内解决它。</font><font style="vertical-align: inherit;">在服务器上工作时，我创建了Hello Worlds几次，以使他们对框架有所了解，并且由于Messenger不需要任何复杂的UI，所以我认为它已经完全准备就绪。</font><font style="vertical-align: inherit;">因此，UI确实是垃圾，但是该功能的实现给我带来了问题（并且仍然可以交付，因为还没有准备好一切）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国家管理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最受欢迎的话题。有上千种方法可以管理您的病情，建议的方法每六个月更改一次。现在主流是提供商。就个人而言，我为自己选择了两种方式：bloc和redux。 Bloc（业务逻辑组件）用于管理本地状态，redux用于管理全局。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloc不是某种类型的库（尽管，当然还有一个减少样板的库，但我不使用它）。 Bloc是一种基于流的方法。通常，dart是一种非常不错的语言，并且流通常是如此的甜美。这种方法的本质是，我们将整个业务逻辑推送到服务中，并通过为我们提供各种流的控制器在UI和服务之间进行通信。用户是否单击了“查找联系人”按钮？使用</font></font><code>sink</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（流的另一端），我们向控制器发送事件</font></font><code>SearchContactsEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，控制器将调用所需的服务，等待结果，并通过流将用户列表返回给UI。 UI使用</font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">通过</font><font style="vertical-align: inherit;">每次订阅的流中新数据到达时都会重建的小部件）</font><font style="vertical-align: inherit;">等待结果</font><font style="vertical-align: inherit;">。实际上，仅此而已。在某些情况下，我们需要在没有用户参与的情况下更新UI（例如，当收到新消息时），但这也很容易通过流来完成。实际上，带有流的简单MVC，没有任何魔力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与其他一些方法相比，bloc需要更多样板，但我认为，最好在没有第三方库参与的情况下使用本机解决方案，除非使用第三方解决方案会带来一些</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重大变化</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点。</font><font style="vertical-align: inherit;">顶层的抽象越多，发生错误时就越难理解错误是什么。</font><font style="vertical-align: inherit;">我认为提供者的优势不足以切换到它。</font><font style="vertical-align: inherit;">但是我在这方面经验不足，因此将来可能会改变阵营。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，关于redux，所以每个人都知道一切，所以无话可说。</font><font style="vertical-align: inherit;">此外，我从应用程序中删除了它：)我用它来管理我的帐户，但是随后意识到，在这种情况下，该块没有特别的优势，所以我切出了它，以免拖得太多。</font><font style="vertical-align: inherit;">但总的来说，我认为redux对于管理全局状态很有用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最令人难忘的部分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果用户发送了一条消息，但是在发送之前，Internet连接丢失，该怎么办？如果用户收到读取确认，但是在更新数据库中的相应记录之前关闭了应用程序，该怎么办？如果用户邀请他的朋友去房间，但是在发送邀请之前，他的电池没电了，该怎么办？您曾经问过类似的问题吗？我在这里。之前。但是在开发过程中我开始怀疑。由于连接可以随时消失，并且手机可以随时关闭，因此必须</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确认所有内容</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不好玩。因此，客户端发送到服务器的第一条消息（</font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您还记得的话）不仅是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“你好我在线”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“您好我在线，这里是未确认的房间，这里是未确认的座位，这里是未确认的房间成员身份操作，这是每个房间最近收到的消息</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">” </font></i><font style="vertical-align: inherit;">服务器用类似的表格回应：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“当您处于脱机状态时，这样的用户读取了这样的消息，他们还邀请Petya到这个房间，而Sveta离开了这个房间，您被邀请到这个房间，但是这两个房间有40个新职位</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">“ </font></i><font style="vertical-align: inherit;">我真的很想知道在其他Messenger中是如何完成类似的事情的，因为我的实现并不优雅。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图片</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目前，您可以发送文本，文本+图片以及仅图片。</font><font style="vertical-align: inherit;">视频上传尚未实现。</font><font style="vertical-align: inherit;">图像会进行一点压缩并保存在Firebase存储中。</font><font style="vertical-align: inherit;">消息本身包含链接。</font><font style="vertical-align: inherit;">收到消息后，客户端下载图像，生成缩略图并将所有内容保存到文件系统。</font><font style="vertical-align: inherit;">文件路径被写入数据库。</font><font style="vertical-align: inherit;">顺便说一下，缩略图生成是在单独的线程上执行的唯一代码，因为它是计算量很大的操作。</font><font style="vertical-align: inherit;">我只是开始一个工作流，向其提供图像，然后返回缩略图。</font><font style="vertical-align: inherit;">该代码非常简单，因为dart为使用流提供了方便的抽象。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThumbnailGeneratorService</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThumbnailGeneratorService</span> </span>{<font></font>
  SendPort _sendPort;<font></font>
  final Queue&lt;Completer&lt;Uint8List&gt;&gt; _completerQueue =<font></font>
      Queue&lt;Completer&lt;Uint8List&gt;&gt;();<font></font>
<font></font>
  ThumbnailGeneratorService() {<font></font>
    <span class="hljs-keyword">var</span> receivePort = ReceivePort();<font></font>
    Isolate.spawn(startWorker, receivePort.sendPort);<font></font>
<font></font>
    receivePort.listen((data) {<font></font>
      <span class="hljs-keyword">if</span> (data is SendPort) {<font></font>
        _sendPort = data;<font></font>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> completer = _completerQueue.removeFirst();<font></font>
        completer.complete(data);<font></font>
      }<font></font>
    });<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> startWorker(SendPort sendPort) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">var</span> receivePort = ReceivePort();<font></font>
    sendPort.send(receivePort.sendPort);<font></font>
<font></font>
    receivePort.listen((imageBytes) {<font></font>
      Image image = decodeImage(imageBytes);<font></font>
      Image thumbnail = copyResize(image, <span class="hljs-attr">width</span>: min(image.width, <span class="hljs-number">200</span>));<font></font>
<font></font>
      sendPort.send(Uint8List.fromList(encodePng(thumbnail)));<font></font>
    });<font></font>
  }<font></font>
<font></font>
  Future&lt;Uint8List&gt; generate(Uint8List imageBytes) {<font></font>
    <span class="hljs-keyword">var</span> completer = Completer&lt;Uint8List&gt;();<font></font>
    _completerQueue.add(completer);<font></font>
    <font></font>
    _sendPort.send(imageBytes);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> completer.future;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还使用Firebase身份验证，但仅用于访问Firebase存储的授权（这样，用户就无法将个人资料图片填写给</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他人</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">所有其他授权都是通过我的服务器完成的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讯息格式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我使用常规字节数组，因此您在这里可能会感到恐惧。 Json消失是因为需要效率，而我刚开始时并不了解protobuf。使用数组需要格外小心，因为一个索引错误并且事情出错了。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前4个字节</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是消息的长度。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个字节</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是消息代码。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来的16个字节</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是请求标识符（uuid）。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来的40个字节</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是授权令牌。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其余消息</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讯息长度</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是必需的，因为我不使用http或Web套接字，也不使用其他将某条消息与另一条消息分开的协议。我的前端服务器只看到字节流，它们需要知道一条消息在哪里结束而另一条消息在哪里开始。分离消息有几种方法（例如，使用在消息中找不到的某种字符作为分隔符），但我更喜欢指定长度，因为此方法最简单，尽管会带来开销，因为大多数消息都会丢失并且一个字节来指示长度。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消息代码</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是枚举的成员之一</font></font><code>MessageCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。路由是根据代码执行的，并且由于我们可以在不进行初步反序列化的情况下从数组中提取代码，因此前端服务器决定在kafka的哪个主题上发送消息，而不是将此职责委托给其他人。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求编号</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现在大多数帖子中，但不是全部。它执行2个功能：通过此标识符，客户端在发送的请求和接收的响应之间建立对应关系（如果客户端以该顺序发送消息A，B，C，这并不意味着答案也将依次出现）。第二个功能是避免重复。如前所述，kafka保证至少交货一次。也就是说，在极少数情况下，消息仍然可以被复制。通过将具有唯一约束的RequestIdentifier列添加到所需的数据库表中，我们可以避免插入重复项。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权令牌</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个UserId（8个字节）+ 32个字节的HmacSha256签名。</font><font style="vertical-align: inherit;">我认为在这里使用Jwt不值得。</font><font style="vertical-align: inherit;">Jwt是什么的大约7-8倍？</font><font style="vertical-align: inherit;">我的用户没有任何要求，因此简单的hmac签名就可以了。</font><font style="vertical-align: inherit;">通过其他服务进行授权不是，而且也没有计划。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频和视频通话</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我特意推迟了音频和视频通话的实现，这很有趣，因为我确定我无法解决问题，但实际上，它却是实现起来最简单的功能之一。</font><font style="vertical-align: inherit;">至少是基本功能。</font><font style="vertical-align: inherit;">通常，仅将WebRtc添加到应用程序中并进行第一次视频会话就只花了几个小时，而且奇迹般地，第一次测试是成功的。</font><font style="vertical-align: inherit;">在此之前，我认为第一次起作用的代码是一个神话。</font><font style="vertical-align: inherit;">通常，由于某种愚蠢的错误（例如“添加了服务，但未将其注册到DI容器中”），对新功能的首次测试始终会失败。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于初学者来说，WebRtc并不是很简短</font></font></b><div class="spoiler_text">WebRtc —  ,   peer-to-peer    , ,    peer-to-peer  ,     .   - ,     ,      .      ,      .<br>
<br>
          (peer-to-peer),     <i></i> ,  3   (     <i></i> ,  3  .           3 ).<br>
<br>
    — stun .   stun  ,    —  Source IP  Source Port      ,    <i></i> .    ?        - .       IP .      - , ,    ,   Source IP  Source Port    IP  -        NAT  [ Source IP | Source Port | Router External IP | Router Port ].     - ,   Dest IP  Dest Port     Router External IP  Router Port  NAT, ,    Source IP — Source Port     ,   .   , ,       ,      , ,    ,      NAT .       stun     NAT .     stun     Router External IP — Router Port.   — <i></i>   .     ,  «»    NAT (NAT traversal)  ,      NAT  ,     stun .<br>
*  NAT ,      . ,     ,  WebRtc    .<br>
<br>
  — turn.  ,       ,   peer-to-peer . Fallback .    , ,  ,  ,   ,   peer-to-peer     .    turn  — coturn,      .<br>
<br>
  — .    <i> </i>  ,    .       ,    .   —           .       .    ,          , ,     :)       —   .<br>
<br>
 WebRtc  3   : offer, answer  candidate.    offer     ,    answer,       .    , ,  ,    ,       .    (     )   ,  .<br>
</div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WebRtc技术本身会建立连接并参与来回传输流，但这不是用于创建完整调用的框架。所谓通话，是指可以取消，拒绝和接受通话以及挂断电话的通信会话。另外，您需要让呼叫者知道对方是否已被占用。而且还可以执行一些小事情，例如“等待呼叫N秒，然后重置”。如果仅以裸露的形式在应用程序中实现WebRtc，则在有来电时，摄像头和视频会自动打开，这当然是不可接受的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以纯粹的形式，WebRtc通常意味着尽快将候选人发送给另一方，以使谈判尽快开始，这是合乎逻辑的。在我的测试中，接收方的候选人通常</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在要约到来之前就开始出现。这样的“早期”候选者不能被丢弃，必须记住它们，以便稍后，当报价到达并</font></font><code>RTCPeerConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建时，将它们添加到连接中。候选人甚至可能在要约之前就开始到来的事实以及其他一些原因，使得执行完整的招聘举足轻重。如果有多个用户立即致电我们该怎么办？我们将收到来自所有人的候选人，尽管我们可以将一个用户的候选人与另一个用户分开，但是不清楚哪些候选人被拒绝，因为我们不知道谁的提议会更早提出。如果候选人开始来找我们，然后在我们</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给某人打电话</font><font style="vertical-align: inherit;">时提出要约，也会有问题</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在使用裸露的WebRtc测试了几个选项之后，我得出的结论是，尝试以这种形式进行调用会出现问题并且充满内存泄漏，因此我决定在WebRtc协商过程中增加另一个阶段。我称这个阶段</font></font><code>Inquire - Grant/Refuse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个想法很简单，但是花了我一段时间。甚至在创建流之前</font></font><code>RTCPeerConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（通常在执行</font><font style="vertical-align: inherit;">与WebRtc相关的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font><font style="vertical-align: inherit;">之前），调用方</font><font style="vertical-align: inherit;">都会</font><font style="vertical-align: inherit;">通过信号服务器将消息发送到另一端</font></font><code>Inquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在接收方，检查用户此刻是否处于其他通信会话中（简单</font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段）。如果是，那么将发送回一条消息。</font></font><code>Refuse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这样，我们就可以让呼叫者知道用户正忙，让接收者知道当他正忙于另一个对话时，某某电话正在打电话。如果用户当前有空，则</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font><font style="vertical-align: inherit;">。</font></font><code>Inquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会话标识符</font><font style="vertical-align: inherit;">在消息中发送</font><font style="vertical-align: inherit;">，并且此标识符设置为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会话</font><font style="vertical-align: inherit;">的标识符</font><font style="vertical-align: inherit;">。如果保留该用户，则他将拒绝所有</font></font><code>Inquire/Offer/Candidate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有会话标识符（当前标识符除外）的消息。预订之后，接收方通过信号服务器向呼叫方发送一条消息</font></font><code>Grant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。值得一提的是，此过程对接收用户不可见，因为还没有呼叫。最主要的是不要忘记在接收方挂断超时。突然，我们将保留一个会议，没有报价。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼叫者会收到</font></font><code>Grant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是WebRtc从要约，候选人开始的地方，这就是每个人都可以使用的地方。</font><font style="vertical-align: inherit;">报价会飞给接收者，接收者会在接收器上显示一个带有“应答/拒绝”按钮的屏幕。</font><font style="vertical-align: inherit;">但是候选人像往常一样没有期待任何人。</font><font style="vertical-align: inherit;">他们甚至早于要约开始到达，因为没有理由等待用户应答呼叫。</font><font style="vertical-align: inherit;">他可能不会回答，但会拒绝或等到超时时间到期-然后候选人将被直接抛出。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现状和未来计划</font></font></h2><br>
<ul>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私人和群聊</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送文本，图像</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和视频</font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频和视频通话</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确认收货和阅读</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“印刷品...”</font></font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知事项</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过QR码和地理位置搜索</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出乎意料的是，通过QR码搜索很难实现，因为我尝试尝试的几乎所有用于代码扫描的插件都无法启动或无法正常工作。</font><font style="vertical-align: inherit;">但我认为问题将在这里解决。</font><font style="vertical-align: inherit;">对于实施地理位置搜索，我尚未开始。</font><font style="vertical-align: inherit;">从理论上讲，不应有任何特殊问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正在进行通知以及发送视频。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有什么需要做的？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哦，很多。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有测试。同事以前经常写测试，所以我完全放松了。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前无法邀请用户加入现有聊天。服务器代码已准备就绪，客户端代码尚未准备好。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果服务器上的错误处理或多或少，则客户端上没有错误处理。仅进行日志输入是不够的；您需要重试该操作。现在，例如，没有实现用于重新发送消息的机制。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器不对客户端执行ping操作，因此，例如，如果客户端丢失了Internet，则不会检测到断开连接。仅当客户端关闭应用程序时，才会检测到断开连接。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第五，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库中不使用索引。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第六，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化。该代码在很多地方都写有类似代码</font></font><code>// @@TODO: Pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。大多数数组就是</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样。后端服务器会创建许多固定长度的数组，因此您可以在这里使用池。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第七，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端上有很多代码</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束的地方，尽管这不是必需的。例如，发送图像似乎很慢，因为代码</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管不需要执行任何操作，但它会将图片保存到文件系统并在显示消息之前生成缩略图。或者，例如，如果您打开该应用程序，并且在您不在的情况下它们将图像发送给您，则启动会很慢，因为所有这些图像都会再次下载，保存到系统，生成缩略图，并且只有在启动结束并从初始屏幕中退出后，在主屏幕上。所有这些冗余</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都是为了简化调试而进行的，但是，当然，您需要在发布之前摆脱不必要的等待。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第八</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户界面现在已经准备就绪，因为我还没有决定如何查看它。因此，现在一切都不直观，一半按钮不清楚它们在做什么。而且通常不会第一次按下按钮，因为现在它们只是带有</font></font><code>GestureDetector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或不</font><font style="vertical-align: inherit;">带有</font><font style="vertical-align: inherit;">填充的</font><font style="vertical-align: inherit;">图标</font><font style="vertical-align: inherit;">，因此并不总是能够进入它们。加上在某些地方像素溢出不是固定的。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第九，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在什至不可能登录帐户，只能注册。因此，如果您卸载该应用程序并重新安装它，则将无法登录您的帐户：）</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第十，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证码不会发送到邮件中。现在，代码通常总是相同的，再次是因为它更易于调试。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第十一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在很多地方违反了单一责任原则。需要重构。负责与数据库交互的类（在客户端和服务器上）通常非常庞大，因为它们参与了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库操作。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第十二，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前端服务器现在始终期望后端服务器提供响应，即使该消息并不意味着发送响应（例如，带有代码的消息</font></font><code>IsTyping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及一些与WebRtc相关的消息）。因此，尽管这不是错误，但他无需等待答案就将错误写入控制台。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第十三，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的图像无法点击打开。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亿五分之一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要分批发送的某些消息将单独发送。这同样适用于某些数据库操作。而不是执行单个命令，而是使用</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（brr ..）</font><font style="vertical-align: inherit;">循环执行命令</font><font style="vertical-align: inherit;">。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亿分之六，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有些值是硬编码的，而不是可配置的。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一百一十分之一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，仅在控制台上登录服务器，通常在客户端上直接登录到小部件。在主屏幕上，有一个“日志”选项卡，其中放置了所有点击的日志。事实是，我的工作机器拒绝同时运行模拟器和服务器所需的一切（kafka，数据库，萝卜和所有服务器）。连接设备的借记卡也无法解决问题，在一半情况下，一切都紧紧地挂着了，因为计算机无法应付负荷。因此，您必须每次进行构建，然后将其拖放到设备上，进行安装和测试。要查看日志，我将其直接放到小部件中。我知道变态，但别无选择。出于相同的原因，许多方法返回</font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们是（捕获异常并扔到小部件中），尽管它们不应该这样。如果看一下代码，您会</font></font><code>_logError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在许多类中</font><font style="vertical-align: inherit;">看到一个丑陋的</font><font style="vertical-align: inherit;">方法。当然，这也将变成垃圾。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一亿零八，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有声音。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一亿分之一，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要使用更多的缓存。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十分之一，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很多重复的代码。例如，许多操作首先检查令牌的有效性，如果无效，则发送错误。我认为您需要实现一个简单的中间件管道。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有很多小事情，例如连接字符串而不是使用</font></font><code>StringBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'a，</font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非到处都应该在任何地方调用它，依此类推。</font><font style="vertical-align: inherit;">通常，项目的正常状态正在开发中。</font><font style="vertical-align: inherit;">上面所有这些都是可以解决的，但是直到最后一刻我才想到一个基本问题，因为它浮现在脑海了-即使应用程序未打开，并且即使我的应用程序无法运行，Messenger仍然可以工作。</font><font style="vertical-align: inherit;">老实说，解决这个问题的办法还没有想到。</font><font style="vertical-align: inherit;">在这里，显然，您不能没有本机代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为该项目的就绪程度为70％。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自该项目开始工作以来已经过去了六个月。</font><font style="vertical-align: inherit;">结合兼职工作，花了很长的时间，但仍然花费了大量的时间和精力。</font><font style="vertical-align: inherit;">我计划实施所有已声明的功能+在房间里添加井字游戏或草稿等不寻常的内容。</font><font style="vertical-align: inherit;">无缘无故，只是因为它很有趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如有任何疑问，请写下。</font><font style="vertical-align: inherit;">邮件在github上。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490052/index.html">iOS应用可以从设备的剪贴板和MacOS威胁监视调查中窃取数据</a></li>
<li><a href="../zh-CN490056/index.html">黑匣子：忘记日志</a></li>
<li><a href="../zh-CN490060/index.html">搜索知识图：从多个来源构建</a></li>
<li><a href="../zh-CN490066/index.html">从中国到南极：共同解决中微子质量难题</a></li>
<li><a href="../zh-CN490068/index.html">通过对伪随机序列进行排序来伪造随机性和变换</a></li>
<li><a href="../zh-CN490076/index.html">电子竞技学科的运动分类</a></li>
<li><a href="../zh-CN490082/index.html">遗传密码分析I</a></li>
<li><a href="../zh-CN490084/index.html">了解ECMAScript规范，第1部分</a></li>
<li><a href="../zh-CN490086/index.html">初学者冲浪指南或程序员在葡萄牙的生活</a></li>
<li><a href="../zh-CN490088/index.html">如何继续在UE4中创建地图</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>