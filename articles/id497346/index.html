<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🚒 ⛺️ 🕤 Percepat numpy, scikit, dan panda 100 kali dengan Rust dan LLVM: wawancara dengan pengembang Weld 📚 🤣 👌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan untuk Anda terjemahan artikel "Wawancara dengan kontributor utama Weld: percepatan numpy, scikit dan panda sebanyak 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Percepat numpy, scikit, dan panda 100 kali dengan Rust dan LLVM: wawancara dengan pengembang Weld</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497346/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! Saya mempersembahkan untuk Anda terjemahan artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Wawancara dengan kontributor utama Weld: percepatan numpy, scikit dan panda sebanyak 100x dengan Rust dan LLVM"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah bekerja selama beberapa minggu dengan perangkat ilmu data dalam Python dan R, saya mulai bertanya-tanya apakah ada representasi perantara (IR) seperti CUDA yang dapat digunakan dalam berbagai bahasa. Pasti ada sesuatu yang lebih baik daripada implementasi ulang dan optimalisasi metode yang sama di setiap bahasa. Selain itu, alangkah baiknya jika ada runtime umum untuk mengoptimalkan seluruh program, daripada masing-masing fungsi secara individual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah beberapa hari meneliti dan menguji berbagai proyek, saya menemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weld</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Anda dapat membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel akademik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang mengejutkan saya, salah satu penulis Weld adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matei Zaharia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Matei Zaharia), pencipta Spark. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, saya menghubungi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shoumik Palkar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kontributor utama Weld, dan mewawancarainya. </font><font style="vertical-align: inherit;">Showmick adalah mahasiswa pascasarjana di Departemen Ilmu Komputer di Universitas Stanford, di mana ia masuk atas saran dari Matey Zakharia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las belum siap untuk penggunaan industri, tetapi sangat menjanjikan. </font><font style="vertical-align: inherit;">Jika Anda tertarik pada masa depan ilmu data dan Rust khususnya, Anda akan menyukai wawancara ini.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iklan penulis artikel asli</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/9r/ca/bq/9rcabqje-oekzfhuecowkord13a.png" alt="image"><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a> «Not a Monad Tutorial»,   Weld    .  !<br>
<br>
    ,     mail@fcarrone.com           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">@unbalancedparen</a>.<br>
</div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk apa Las dirancang, masalah apa yang dipecahkannya?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan Weld adalah untuk meningkatkan produktivitas untuk aplikasi yang menggunakan API tingkat tinggi seperti NumPy dan Pandas. Masalah utama yang dipecahkannya adalah optimisasi lintas-fungsional dan lintas-perpustakaan yang tidak disediakan oleh perpustakaan lain saat ini. Secara khusus, banyak perpustakaan yang banyak digunakan memiliki implementasi modern dari algoritma untuk fungsi individu (misalnya, algoritma join cepat diimplementasikan di Pandas oleh C, atau perkalian matriks cepat di NumPy), tetapi mereka tidak memberikan kemungkinan mengoptimalkan kombinasi fungsi-fungsi ini. Misalnya, mencegah pemindaian memori yang tidak perlu saat melakukan perkalian matriks diikuti dengan agregasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weld menyediakan lingkungan runtime umum yang memungkinkan perpustakaan untuk mengekspresikan komputasi dalam representasi perantara sedang (IR). </font><font style="vertical-align: inherit;">IR ini kemudian dapat dioptimalkan menggunakan optimizer kompiler, dan kemudian dikompilasi dengan cepat (JIT) ke dalam kode mesin paralel dengan optimisasi seperti penggabungan loop, vektorisasi, dll. </font><font style="vertical-align: inherit;">IR Weld awalnya paralel, sehingga program-program yang dinyatakan di dalamnya selalu bisa diparalelkan secara sepele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga memiliki proyek baru yang disebut anotasi Split, yang akan diintegrasikan dengan Weld dan dirancang untuk mengurangi hambatan dengan dimasukkannya optimasi tersebut di perpustakaan yang ada.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah lebih mudah untuk mengoptimalkan numpy, panda, dan scikit? </font><font style="vertical-align: inherit;">Seberapa cepat?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weld menyediakan optimalisasi kombinasi fungsi di pustaka ini, sementara optimalisasi pustaka dapat mempercepat panggilan hanya fungsi individu. Bahkan, banyak perpustakaan ini sudah dioptimalkan dengan sangat baik untuk setiap fungsi individu, tetapi memberikan kinerja di bawah batas peralatan modern, karena mereka tidak menggunakan paralelisme atau tidak menggunakan hierarki memori secara efisien.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, banyak fungsi NumPy untuk array multidimensi (ndarray) diimplementasikan dalam bahasa C tingkat rendah, tetapi panggilan ke setiap fungsi memerlukan pemindaian penuh dari data input. Jika array ini tidak sesuai dengan cache CPU, sebagian besar waktu eksekusi dapat dihabiskan memuat data dari memori utama, daripada melakukan perhitungan. Weld dapat melihat panggilan fungsi individual dan melakukan optimasi, seperti menggabungkan loop yang akan menyimpan data dalam cache atau register CPU. Optimalisasi semacam itu dapat meningkatkan kinerja lebih dari satu urutan besarnya dalam sistem multi-core, karena mereka memberikan skalabilitas yang lebih baik.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/12/uo/pw12uohofii1vdbwzb8fdcucfus.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Integrasi prototipe Weld dengan Spark (kiri atas), NumPy (kanan atas) dan TensorFlow (kiri bawah) menunjukkan peningkatan hingga 30 kali lipat dibandingkan implementasi infrastruktur mereka sendiri tanpa perubahan dalam kode aplikasi pengguna. </font><font style="vertical-align: inherit;">Optimalisasi lintas-perpustakaan Pandas dan NumPy (kanan bawah) dapat meningkatkan kinerja dengan dua kali lipat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu Baloo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baloo adalah perpustakaan yang mengimplementasikan subset dari Pandas API menggunakan Weld. </font><font style="vertical-align: inherit;">Ini dikembangkan oleh Radu Jica, seorang Master di CWI (Centrum Wiskunde &amp; Informatica, Amsterdam). </font><font style="vertical-align: inherit;">Tujuan dari Baloo adalah untuk menerapkan jenis optimasi di atas untuk Pandas untuk meningkatkan kinerja single-threaded, mengurangi penggunaan memori, dan memastikan konkurensi.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Weld / Baloo mendukung operasi eksternal (seperti, katakanlah, Dask) untuk memproses data yang tidak sesuai dengan memori?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weld dan Baloo saat ini tidak mendukung operasi eksternal (out-of-core, memori eksternal), meskipun kami akan dengan senang hati menerima pengembangan opensource ke arah ini!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Anda memilih Rust dan LLVM untuk mengimplementasikan Weld? </font><font style="vertical-align: inherit;">Apakah Anda datang ke Rust segera?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memilih Rust karena:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memiliki runtime minimal (pada kenyataannya, itu hanya memeriksa batas-batas array) dan mudah untuk ditanamkan dalam bahasa lain seperti Java dan Python</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berisi paradigma pemrograman fungsional, seperti pencocokan pola, yang membuat penulisan kode lebih mudah, misalnya, untuk mengoptimalkan kompilasi pencocokan pola</font></font></li>
<li>       ( Rust   crates),     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memilih LLVM karena ini merupakan kerangka kompilasi sumber terbuka yang banyak digunakan dan didukung. Kami menghasilkan LLVM secara langsung, bukan C / C ++, jadi kami tidak memerlukan kompiler C. Ini juga mengurangi waktu kompilasi, karena kami tidak menguraikan kode C / C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karat bukan bahasa pertama Weld diimplementasikan di. Implementasi pertama adalah pada Scala, yang dipilih karena tipe data aljabar dan kehadiran fitur yang kuat seperti pencocokan pola. Ini menyederhanakan penulisan optimizer, yang merupakan bagian utama dari kompiler. Pengoptimal asli kami dibuat seperti Catalyst, pengoptimal yang dapat dikembangkan dalam Spark SQL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami pindah dari Scala karena terlalu sulit untuk menanamkan bahasa berbasis JVM di runtimes dan bahasa lain.</font></font><br>
<br>
<h4> Weld   CPU  GPU,         RAPIDS,   data science  Python  GPU?</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perbedaan utama antara Weld dan sistem seperti RAPIDS adalah bahwa ia ditujukan untuk mengoptimalkan aplikasi yang berisi kernel yang berbeda (fungsi dalam istilah CUDA) dengan mengkompilasi dengan cepat, dan tidak mengoptimalkan implementasi dari fungsi individual. Misalnya, backend GPU Weld akan mengkompilasi satu kernel CUDA tunggal yang dioptimalkan untuk aplikasi akhir, alih-alih memanggil kernel yang terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, Weld IR adalah perangkat keras yang independen, yang memungkinkannya digunakan untuk GPU dan CPU, serta peralatan non-standar seperti prosesor vektor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, Weld pada dasarnya bersinggungan dengan proyek-proyek lain di bidang yang sama, termasuk RAPIDS, dan dibuat di bawah pengaruh mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lingkungan runtime seperti Bohrium (mengimplementasikan komputasi malas di NumPy) dan Numba (pustaka Python, kompiler kode JIT) berbagi tujuan tingkat tinggi Weld. </font><font style="vertical-align: inherit;">Dan sistem pengoptimal seperti Spark SQL secara langsung memengaruhi desain Weld.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Weld memiliki kegunaan lain selain optimasi perpustakaan sains data?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu aspek yang paling menarik dari Weld IR adalah bahwa ia secara asli mendukung konkurensi data. </font><font style="vertical-align: inherit;">Ini berarti bahwa paralelisasi loop dalam Weld IR selalu aman. </font><font style="vertical-align: inherit;">Ini membuat Weld IR menarik untuk jenis peralatan baru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, karyawan NEC menggunakan Weld untuk menjalankan beban kerja Python pada prosesor vektor bandwidth tinggi kustom, cukup menambahkan backend baru ke IR Weld yang ada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IR juga dapat digunakan untuk mengimplementasikan lapisan operasi fisik dalam database. </font><font style="vertical-align: inherit;">Dan kami berencana untuk menambahkan fitur yang juga memungkinkan kami untuk mengkompilasi subset Python ke dalam kode Weld.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah perpustakaan siap digunakan dalam proyek nyata? </font><font style="vertical-align: inherit;">Dan jika tidak, kapan Anda bisa mengharapkan hasil yang selesai?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak contoh dan tolok ukur di mana kami menguji perpustakaan ini diambil dari beban kerja nyata. Karena itu, kami sangat ingin pengguna mencoba versi saat ini di aplikasi mereka, dan meninggalkan umpan balik mereka. Dan yang terbaik, mereka mengusulkan tambalan mereka sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, saat ini tidak dapat dikatakan bahwa dalam aplikasi nyata semuanya akan bekerja di luar kotak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rilis kami berikutnya selama beberapa bulan ke depan akan fokus secara eksklusif pada kegunaan dan keandalan perpustakaan Python. Tujuan kami adalah membuat perpustakaan cukup baik untuk dimasukkan dalam proyek nyata. Dan juga kemampuan untuk menggunakan versi pustaka non-Weld di tempat-tempat di mana dukungan belum ditambahkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya catat dalam pertanyaan pertama, proyek anotasi Split ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel akademik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) harus menyederhanakan transisi ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Split annotations adalah sistem yang memungkinkan Anda menambahkan anotasi ke kode yang ada untuk menentukan cara memecah, mengubah, dan memparalelkannya. Ini memberikan optimasi yang kami anggap paling efektif di Weld (menyimpan potongan data dalam cache CPU di antara panggilan fungsi, alih-alih memindai seluruh kumpulan data). Tetapi anotasi Split jauh lebih mudah diintegrasikan daripada Weld, karena mereka menggunakan kode pustaka yang ada tanpa mengandalkan kompiler IR. Ini juga memfasilitasi pemeliharaan dan debugging, yang pada gilirannya meningkatkan keandalan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perpustakaan yang belum memiliki dukungan las penuh dapat menggunakan anotasi Split. </font><font style="vertical-align: inherit;">Ini akan memungkinkan kami untuk secara bertahap menambahkan dukungan Weld berdasarkan umpan balik pengguna, sambil memasukkan optimasi baru.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497334/index.html">Bug terkenal dan bagaimana menghindarinya pada contoh ClickHouse</a></li>
<li><a href="../id497336/index.html">Merek komputer tahun 90-an, bagian 3, final</a></li>
<li><a href="../id497338/index.html">Apa yang terjadi dengan transportasi minggu lalu - krisis sedang berkembang</a></li>
<li><a href="../id497340/index.html">COVID-19: cara berhenti membaca berita dan mulai menganalisis data</a></li>
<li><a href="../id497342/index.html">Browser waspada terhadap permintaan API: membangun komunikasi aman antara front-end dan back-end</a></li>
<li><a href="../id497350/index.html">Pelanggaran Ketentuan Layanan belum merupakan kejahatan</a></li>
<li><a href="../id497356/index.html">Pisahkan pelanggan dengan loyalitas menggunakan analisis RFM</a></li>
<li><a href="../id497358/index.html">PhpStorm 2020.1: support composer.json, alat untuk PHPUnit, cakupan kode dengan PCOV dan PHPDBG, Grazie, dan lainnya</a></li>
<li><a href="../id497362/index.html">Bagaimana penemu Amerika pertama mendanai bisnis mereka</a></li>
<li><a href="../id497368/index.html">Hackintosh di Powermac G5 atau cara merakit workstation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>