<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 👨‍❤️‍💋‍👨 🐒 Redisのベストプラクティス、パート2 👨🏽‍🤝‍👨🏻 🚮 🗳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis LabsのRedisベストプラクティス変換サイクルの後半では、相互作用パターンとデータストレージパターンについて説明します。
 最初の部分はここです。
 
 相互作用パターン
 Redisは、従来のDBMSとして機能するだけでなく、その構造とコマンドを使用して、マイクロサービスまたはプロ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redisのベストプラクティス、パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487570/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis LabsのRedisベストプラクティス変換サイクルの後半では、相互作用パターンとデータストレージパターンについて説明します。</font></font><div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相互作用パターン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisは、従来のDBMSとして機能するだけでなく、その構造とコマンドを使用して、マイクロサービスまたはプロセス間でメッセージを交換することもできます。</font><font style="vertical-align: inherit;">Redisクライアントの広範囲にわたる使用、サーバーとプロトコルの速度と効率、および組み込みのクラシック構造により、独自のワークフローとイベントメカニズムを作成できます。</font><font style="vertical-align: inherit;">この章では、次のトピックについて説明します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントのキュー。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redlockによるブロック。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブ/サブ;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散イベント。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントキュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisのリストは順序付けられた行のリストであり、よく知っているリンクリストとよく似ています。リストへの値の追加（プッシュ）およびリストからの値の削除（ポップ）は、非常に軽量な操作です。ご想像のとおり、これはキューを管理するための非常に優れた構造です。最初に要素を追加し、最後から要素を読み取ります（FIFO）。 Redisには、このパターンをより効率的、信頼性の高い、使いやすいものにする追加機能も用意されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストには、「ブロック」動作を実行できるコマンドのサブセットがあります。</font><font style="vertical-align: inherit;">「ブロッキング」という用語は、1つのクライアントのみとの接続を指します。</font><font style="vertical-align: inherit;">実際、これらのコマンドでは、リストに値が表示されるまで、またはタイムアウトになるまで、クライアントは何もできません。</font><font style="vertical-align: inherit;">これにより、結果を待つRedisをポーリングする必要がなくなります。</font><font style="vertical-align: inherit;">クライアントは値を期待している間は何も実行できないため、これを説明するために2つのオープンクライアントが必要になります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOP my-q 0</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">【期待値】</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><pre><code class="plaintext hljs">&gt; LPUSH my-q hello<font></font>
(integer) 1</code></pre></td>
<td><pre><code class="plaintext hljs">1) "my-q"<font></font>
2) "hello"</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[クライアントがロック解除され、コマンドを受け入れる準備ができています]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOP my-q 0</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">【期待値】</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例のステップ1では、ブロックされたクライアントには何も含まれていないため、すぐには何も返されません。</font><font style="vertical-align: inherit;">最後の引数は待機時間です。</font><font style="vertical-align: inherit;">ここで0は永遠の期待を意味します。</font><font style="vertical-align: inherit;">2行目</font><font style="vertical-align: inherit;">では</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my-q</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に値が入力さ</font><font style="vertical-align: inherit;">れ</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">最初のクライアントは直ちにブロッキング状態を終了します。</font><font style="vertical-align: inherit;">3行目では、BRPOPが再度呼び出され（アプリケーションのループでこれを実行できます）、クライアントも次の値を待ちます。</font><font style="vertical-align: inherit;">「Ctrl + C」を押すと、ロックを解除してクライアントを終了できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を逆にして、空でないリストでBRPOPがどのように機能するかを見てみましょう。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; LPUSH my-q hello<font></font>
(integer) 1</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><pre><code class="plaintext hljs">&gt; LPUSH my-q hej<font></font>
(integer) 2</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><pre><code class="plaintext hljs">&gt; LPUSH my-q bonjour<font></font>
(integer) 3</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOP my-q 0<font></font>
1) "my-q"<font></font>
2) "hello"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOP my-q 0<font></font>
1) "my-q"<font></font>
2) "hej"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOP my-q 0<font></font>
1) "my-q"<font></font>
2) "bonjour"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOP my-q 0</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">【期待値】</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステップ1から3で、リストに3つの値を入力し、リスト内の要素の数を示す答えが増えることを確認します。ステップ4は、BRPOPを呼び出しても、すぐに値を返します。これは、キューに値がない場合にのみブロック動作が発生するためです。これはキュー内の各アイテムに対して行われるため、手順5〜6で同じインスタント応答を確認できます。ステップ7では、BRPOPはキュー内で何も検出せず、何かが追加されるまでクライアントをブロックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、キューは別のプロセス（ワーカー）で実行する必要があるいくつかの作業を表します。</font><font style="vertical-align: inherit;">このタイプのワークロードでは、実行中にワーカーが何らかの理由で落ちた場合に作業が消えないようにすることが重要です。</font><font style="vertical-align: inherit;">Redisはこのタイプのキューをサポートしています。</font><font style="vertical-align: inherit;">これを行うには、BRPOPの代わりにBRPOPLPUSHコマンドを使用します。</font><font style="vertical-align: inherit;">彼女はあるリストの値を期待し、そこに表示されたらすぐに別のリストに配置します。</font><font style="vertical-align: inherit;">これはアトミックに行われるため、2人のワーカーが同じ値を変更することは不可能です。</font><font style="vertical-align: inherit;">それがどのように機能するか見てみましょう：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; LINDEX worker-q 0<font></font>
(nil)</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[結果がnilでない場合、どういうわけかそれを処理し、ステップ4に進みます]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; LREM worker-q -1 [   1]<font></font>
(integer) 1</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ステップ1に戻る]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; BRPOPLPUSH my-q worker-q 0</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">【期待値】</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><pre><code class="plaintext hljs">&gt; LPUSH my-q hello</code></pre></td>
<td><pre><code class="plaintext hljs">"hello"</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[クライアントがロック解除され、コマンドを受け入れる準備ができています]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[こんにちは]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; LREM worker-q -1 hello<font></font>
(integer) 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ステップ1に戻る]</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手順1-2では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worker-qが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font><font style="vertical-align: inherit;">であるため、何もしません</font><font style="vertical-align: inherit;">。何かが戻ってきた場合は、それを処理して削除し、ステップ1に戻って、何かがキューに入ったかどうかを確認します。したがって、最初にワーカーのキューをクリアして、既存の作業を実行します。ステップ4では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my-qに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が現れるまで待機し、出現すると</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">原子的に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worker-qに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送され</font><font style="vertical-align: inherit;">ます。次に、何らかの方法で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「hello」を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理します</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">その後</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worker-q</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から削除して、</font><font style="vertical-align: inherit;">手順1に戻ります。手順6でプロセスが停止しても、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worker-qに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は値が残ってい</font><font style="vertical-align: inherit;">ます。プロセスを再起動すると、手順7で削除されなかったものはすべてすぐに削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンにより、ジョブが失われる可能性が大幅に減少しますが、ワーカーがステップ2と3または5と6の間に死亡した場合に限りますが、これはまれですが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベストプラクティスで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれをワーカーのロジックで考慮します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッドロックでロック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムでは、リソースをブロックする必要がある場合があります。</font><font style="vertical-align: inherit;">これは、競争の激しい環境では解決できない重要な変更を適用するために必要になる場合があります。</font><font style="vertical-align: inherit;">ブロッキングの目的：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1人のワーカーだけがリソースをキャプチャできるようにします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックオブジェクトを確実に解放できる。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースをしっかりとロックしないでください（一定時間後にロックを解除する必要があります）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisはシンプルなキーベースのデータモデルを持ち、各シャードはシングルスレッドでかなり高速であるため、ブロッキングを実装するのに適したオプションです。 Redlockと呼ばれるRedisを使用した優れたロック実装があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redlockクライアントは、ほぼすべての言語で利用できますが、安全かつ効果的に使用するには、Redlockの仕組みを理解することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Redlockは独立したRedisインスタンスを備えた少なくとも3台のマシンで実行するように設計されていることを理解する必要があります。これにより、すべてのリソースのデッドロックにつながる可能性のあるロックメカニズムの単一障害点が排除されます。理解しておくべきもう1つのポイントは、マシンのクロックは100％同期する必要はありませんが、同じように機能する必要があるということです。時間は同じ速度で移動します。マシンでは1秒、マシンBでは1秒と同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redlockを使用したロックオブジェクトの設定は、ミリ秒の精度のタイムスタンプを取得することから始まります。また、事前にブロッキング時間を指定する必要があります。次に、ランダムな値でキーを設定（SET）し（このキーがまだ存在しない場合のみ）、キーのタイムアウトを設定することにより、ブロッキングオブジェクトを設定します。これは、独立したインスタンスごとに繰り返されます。インスタンスが落ちた場合、すぐにスキップされます。タイムアウトになる前にロックオブジェクトがほとんどのインスタンスに正常にインストールされた場合、そのオブジェクトはキャプチャされたと見なされます。ロックオブジェクトをインストールまたは更新する時間は、ロック状態になるまでにかかる時間から、事前定義されたロック時間を差し引いた時間です。エラーまたはタイムアウトが発生した場合は、すべてのインスタンスのロックを解除して、再試行してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックオブジェクトを解放するには、予想されるランダムな値がキーのセットに含まれているかどうかをチェックするLuaスクリプトを使用することをお勧めします。</font><font style="vertical-align: inherit;">存在する場合は、それを削除できます。そうでない場合は、新しいロックオブジェクトである可能性があるため、キーを残しておくことをお勧めします。</font></font><br>
<br>
<pre><code class="plaintext hljs">if redis.call("get",KEYS[1]) == ARGV[1] then<font></font>
    return redis.call("del",KEYS[1])<font></font>
else<font></font>
    return 0<font></font>
end</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redlockプロセスは優れた保証を提供し、単一障害点が存在しないため、単一のロックオブジェクトが分散され、相互ロックが発生しないことを完全に確認できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブ/サブ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データストレージに加えて、RedisはPub / Subプラットフォーム（パブリッシャー/サブスクライバー）としても使用できます。</font><font style="vertical-align: inherit;">このパターンでは、パブリッシャーは任意の数のチャネルサブスクライバーにメッセージを発行できます。</font><font style="vertical-align: inherit;">これらは「ショットアンドフォーゲット」の原則に基づいたメッセージです。つまり、メッセージが解放され、サブスクライバが存在しない場合、メッセージは回復する可能性なしに消えます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャネルにサブスクライブすると、クライアントはサブスクライバーモードに入り、コマンドを呼び出すことができなくなります-読み取り専用になります。</font><font style="vertical-align: inherit;">出版社にはそのような制限はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のチャンネルに登録できます。</font><font style="vertical-align: inherit;">まず、SUBSCRIBEコマンドを使用して、2つの天気およびスポーツチャンネルをサブスクライブします。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; SUBSCRIBE weather sports<font></font>
Reading messages... (press Ctrl-C to quit)<font></font>
1) "subscribe"<font></font>
2) "weather"<font></font>
3) (integer) 1<font></font>
1) "subscribe"<font></font>
2) "sports"<font></font>
3) (integer) 2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のクライアント（別のターミナルウィンドウなど）では、PUBLISHコマンドを使用して、これらのチャネルのいずれかにメッセージを発行できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PUBLISH sports oilers/7:leafs/1<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の引数はチャネルの名前、2番目はメッセージです。</font><font style="vertical-align: inherit;">メッセージは任意であり、この場合はゲーム内のコード化されたアカウントです。</font><font style="vertical-align: inherit;">コマンドは、メッセージが配信されるクライアントの数を返します。</font><font style="vertical-align: inherit;">サブスクライバークライアントでは、次のメッセージがすぐに表示されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">1) "message"<font></font>
2) "sports"<font></font>
3) "oilers/7:leafs/1"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
応答には3つの要素が含まれます。これがメッセージであることを示す通知、サブスクリプションチャネル、そして実際にはメッセージです。</font><font style="vertical-align: inherit;">受信直後のクライアントは、チャネルのリスニングに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出版社に戻り、次のメッセージを投稿する場合があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PUBLISH weather snow/-4c<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクライバーには同じ形式が表示されますが、メッセージのあるチャネルは異なります。</font></font><br>
<br>
<pre><code class="plaintext hljs">1) "message"<font></font>
2) "weather"<font></font>
3) "snow/-4c"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャンネル登録者がいないチャンネルにメッセージを投稿しましょう：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PUBLISH currency CADUSD/0.787<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰も</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通貨</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネルを聞いていないので</font><font style="vertical-align: inherit;">、答えは0になります。このメッセージは消え、このチャネルにサブスクライブした後にクライアントはこのメッセージに関する通知を受信しません-メッセージは送信され、忘れられました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisでは、単一のチャネルのサブスクライブに加えて、チャネルをマスクでサブスクライブできます。</font><font style="vertical-align: inherit;">globスタイルのマスクがPSUBSCRIBEコマンドに渡されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PSUBSCRIBE sports:*</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーツ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始まるすべてのチャンネルからメッセージを受信します</font><i><font style="vertical-align: inherit;">：</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">別のクライアントで、次のコマンドを呼び出します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PUBLISH sports:hockey oilers/7:leafs/1<font></font>
(integer) 1<font></font>
&gt; PUBLISH sports:basketball raptors/33:pacers/7<font></font>
(integer) 1<font></font>
&gt; PUBLISH weather:edmonton snow/-4c<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2つのチームは1を返し、最後のチームは0を返します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーツ：ホッケー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポーツ：バスケットボール</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には</font><font style="vertical-align: inherit;">直接サブスクライブしていませんが</font><font style="vertical-align: inherit;">、クライアントはマスクによるサブスクリプションを通じてメッセージを受信します。</font><font style="vertical-align: inherit;">クライアント/サブスクライバーウィンドウで、マスクに一致するチャネルのみの結果があることがわかります。</font></font><br>
<br>
<pre><code class="plaintext hljs">1) "pmessage"<font></font>
2) "sports:*"<font></font>
3) "sports:hockey"<font></font>
4) "oilers/7:leafs/1"<font></font>
1) "pmessage"<font></font>
2) "sports:*"<font></font>
3) "sports:basketball"<font></font>
4) "raptors/33:pacers/7"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この出力は、マスク自体とチャネルの実際の名前が含まれているため、SUBSCRIBEコマンドの出力とは少し異なります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散イベント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisのパブ/サブメッセージングスキームを拡張して、興味深い分散イベントを作成できます。</font><font style="vertical-align: inherit;">ハッシュテーブルに格納されている構造があるが、単一のフィールドがサブスクライバーによって設定された数値を超えた場合にのみクライアントを更新するとします。</font><font style="vertical-align: inherit;">チャンネルをマスクでリッスンし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のハッシュを抽出し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この例では</font><font style="vertical-align: inherit;">、値5-9の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">update_statusに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関心が</font><font style="vertical-align: inherit;">あります。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PSUBSCRIBE update_status:[5-9]<font></font>
1) "psubscribe"<font></font>
2) "update_status:[5-9]"<font></font>
3) (integer) 1<font></font>
...</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">status / error_level値</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を変更するには、</font><font style="vertical-align: inherit;">順次またはMULTI / EXECブロックで実行できる2つのコマンドが必要です。</font><font style="vertical-align: inherit;">最初のコマンドはレベルを設定し、2番目のコマンドはチャネル自体にエンコードされた値で通知を発行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET status error_level 5<font></font>
(integer) 1<font></font>
&gt; PUBLISH update_status:5 0<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のウィンドウで、メッセージが受信されたことがわかります。その後、別のクライアントに切り替えてHGETALLコマンドを呼び出すことができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">...<font></font>
1) "pmessage"<font></font>
2) "update_status:[5-9]"<font></font>
3) "update_status:5"<font></font>
4) "0"<font></font>
<font></font>
&gt; HGETALL status<font></font>
1) "error_level"<font></font>
2) "5"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドを使用して、長いプロセスのローカル変数を更新することもできます。</font><font style="vertical-align: inherit;">これにより、同じプロセスの複数のインスタンスがリアルタイムでデータを交換できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンがPub / Subを使用するよりも優れている理由 </font><font style="vertical-align: inherit;">プロセスが再起動すると、状態全体を取得してリスニングを開始できます。</font><font style="vertical-align: inherit;">変更は、任意の数のプロセス間で同期されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データストレージパターン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisに構造化データを保存するには、いくつかのパターンがあります。</font><font style="vertical-align: inherit;">この章では、以下について検討します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSONでのデータストレージ;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">貯蔵施設。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSONデータストレージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONデータをRedisに保存するには、いくつかのオプションがあります。</font><font style="vertical-align: inherit;">最も一般的な形式は、オブジェクトを事前にシリアル化し、特別なキーの下に保存することです。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; SET car "{\"colour\":\"blue\",\"make\":\"saab\",\"model\":93,\"features\":[\"powerlocks\",\"moonroof\"]}"<font></font>
OK<font></font>
&gt; GET car<font></font>
"{\"colour\":\"blue\",\"make\":\"saab\",\"model\":93,\"features\":[\"powerlocks\",\"moonroof\"]}"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
見た目はシンプルに見えますが、非常に重大な欠点がいくつかあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアライゼーションは、クライアントコンピューティングリソースを読み書きします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSON形式はデータサイズを増やします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redisには、JSONでデータを処理する間接的な方法しかありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2、3のポイントは少量のデータでは無視できるかもしれませんが、データが増加するにつれてコストは増加します。</font><font style="vertical-align: inherit;">ただし、3番目のポイントが最も重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis 4.0以前は、Redis内でJSONを使用する唯一の方法は、cjsonモジュールでLuaスクリプトを使用することでした。</font><font style="vertical-align: inherit;">これは問題を部分的に解決しましたが、それでもボトルネックのままであり、Luaの学習に追加の手間がかかりました。</font><font style="vertical-align: inherit;">さらに、多くのアプリケーションは、JSON文字列全体を受け取り、それを逆シリアル化し、データを操作し、シリアル化して、再度保存しました。</font><font style="vertical-align: inherit;">これはアンチパターンです。</font><font style="vertical-align: inherit;">この方法でデータを失う大きなリスクがあります。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションインスタンス＃1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションインスタンス＃2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; GET my-car</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[デシリアライズ、マシンの色を変更して再度シリアライズ]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; GET my-car</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><pre><code class="plaintext hljs">&gt; SET my-car</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[インスタンス＃1の新しい値]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[デシリアライズ、マシンモデルの変更、および再度シリアライズ]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SET my-car</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[インスタンス＃2の新しい値]</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; GET my-car</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5行目の結果はインスタンス2への変更のみを示し、インスタンス1による色の変更は失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisバージョン4.0以降には、モジュールを使用する機能があります。</font><font style="vertical-align: inherit;">ReJSONは、特別なデータ型と直接対話するためのコマンドを提供するモジュールです。</font><font style="vertical-align: inherit;">ReJSONは、バイナリ形式でデータを保存します。これにより、格納されたデータのサイズが縮小され、逆シリアル化に時間を費やすことなく、要素へのより高速なアクセスが提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReJSONを使用するには、ReJSONをRedisサーバーにインストールするか、Redis Enterpriseで有効にする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のReJSONの使用例は次のようになります。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションインスタンス＃1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションインスタンス＃2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; JSON.SET car2 . '{"colour": "blue",  "make":"saab", "model":93,  "features": ["powerlocks",  "moonroof"]}‘<font></font>
OK</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><pre><code class="plaintext hljs">&gt; JSON.SET car2 colour '"red"'<font></font>
OK</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; JSON.SET car2 model '95'<font></font>
OK<font></font>
&gt; JSON.GET car2 .<font></font>
"{\"colour\":\"red",\"make\":\"saab\",\"model\":95,\"features\":[\"powerlocks\",\"moonroof\"]}"</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReJSONは、特にネストされた要素へのアトミックな変更が必要な場合に、RedisでJSONデータを操作するためのより安全で高速かつ直感的な方法を提供します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトストレージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、標準のRedisの「ハッシュテーブル」データ型は、JSONオブジェクトや他の型と非常によく似ているように見えます。</font><font style="vertical-align: inherit;">フィールドを文字列または数値のいずれかにして、ネストされた構造を防止する方がはるかに簡単です。</font><font style="vertical-align: inherit;">ただし、各フィールドへの「パス」を計算した後、オブジェクトを「フラット化」してRedisハッシュテーブルに保存できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">{<font></font>
    "colour": "blue",<font></font>
    "make": "saab",<font></font>
    "model": {<font></font>
        "trim": "aero",<font></font>
        "name": 93<font></font>
    },<font></font>
    "features": ["powerlocks", "moonroof"]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSONPath</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（JSONのXPath）</font><font style="vertical-align: inherit;">
を使用して</font><font style="vertical-align: inherit;">、ハッシュテーブルの同じレベルで各要素を表すことができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET car3 colour blue<font></font>
&gt; HSET car3 make saab<font></font>
&gt; HSET car3 model.trim aero<font></font>
&gt; HSET car3 model.name 93<font></font>
&gt; HSET car3 features[0] powerlocks<font></font>
&gt; HSET car3 features[1] moonroof</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、コマンドは個別にリストされていますが、多くのパラメーターをHSETに渡すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、オブジェクト全体またはその個々のフィールドをリクエストできます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HGETALL car3<font></font>
 1) "colour"<font></font>
 2) "blue"<font></font>
 3) "make"<font></font>
 4) "saab"<font></font>
 5) "model.trim"<font></font>
 6) "aero"<font></font>
 7) "model.name"<font></font>
 8) "93"<font></font>
 9) "features[0]"<font></font>
10) "powerlocks"<font></font>
11) "features[1]"<font></font>
12) "moonroof"<font></font>
<font></font>
&gt; HGET car3 model.trim<font></font>
"aero"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Redisに保存されたオブジェクトを取得するための迅速で便利な方法を提供しますが、欠点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる言語やライブラリでは、JSONPathの実装が異なる場合があり、非互換性が発生します。</font><font style="vertical-align: inherit;">この場合、1つのツールでデータをシリアル化および逆シリアル化する価値があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレイのサポート：</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スパース配列は問題を引き起こす可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列の途中に要素を挿入するなど、多くの操作を実行することは不可能です。</font></font></li>
</ul><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSONPathキーでの不要なリソース消費。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンはReJSONとほとんど同じです。</font><font style="vertical-align: inherit;">ReJSONが使用可能な場合、ほとんどの場合、それを使用することをお勧めします。</font><font style="vertical-align: inherit;">ただし、上記の方法でオブジェクトを保存することには、ReJSONよりも1つの利点があります。RedisSORTチームとの統合です。</font><font style="vertical-align: inherit;">ただし、このコマンドは計算が複雑であり、このパターンの範囲を超えた別の複雑なトピックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の最後のパートでは、時系列パターン、速度制限パターン、ブルームフィルターパターン、カウンター、RedisでのLuaの使用について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS私はこれらの記事のテキストを可能な限り「野蛮な」英語でロシア語に適応させようとしましたが、どこかでアイデアが理解できないか正しくないと思われる場合は、コメントで訂正してください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487558/index.html">ポール・グラハム：子供とスタートアップ</a></li>
<li><a href="../ja487560/index.html">バンクオブアメリカ：Yandexの時価総額は14億ドル増加します</a></li>
<li><a href="../ja487564/index.html">ポール・グラハム：「あなたの心の中の最高のアイデア」</a></li>
<li><a href="../ja487566/index.html">CSSグリッドを理解する（パート1）：グリッドコンテナー</a></li>
<li><a href="../ja487568/index.html">Case Full HP：Google Playから特集され、ASOをさまざまな国に適応させる方法</a></li>
<li><a href="../ja487574/index.html">オーディオの操作：進行状況とデータの視覚化</a></li>
<li><a href="../ja487578/index.html">静的ライブラリのCMake最適化</a></li>
<li><a href="../ja487582/index.html">鍋を燃やす神はいない</a></li>
<li><a href="../ja487584/index.html">情報セキュリティの確立</a></li>
<li><a href="../ja487588/index.html">Quarkus：超音速亜原子獣医</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>