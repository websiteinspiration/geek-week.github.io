<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☎️ 🕺🏼 🏉 Minuterie de fonction pour contrôleur industriel Simatic S7-1200 😧 🏡 🆙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Même pour les séries S7-300 et S7-400, à l'étape 7, les versions classiques des temporisateurs proposés au développeur étaient suffisantes - ce sont d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Minuterie de fonction pour contrôleur industriel Simatic S7-1200</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491200/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Même pour les séries S7-300 et S7-400, à l'étape 7, les versions classiques des temporisateurs proposés au développeur étaient suffisantes - ce sont des temporisateurs CEI standard, mis en œuvre en tant que blocs fonctionnels, et des temporisateurs S5 (qui, soit dit en passant, existent toujours pour la série S7- 1500). Cependant, dans certains cas, le développeur n'a pas utilisé d'outils standard et a implémenté ses propres temporisateurs, le plus souvent sous forme de fonctions. De telles fonctions de temporisation étaient nécessaires avec une approche «informatique» de la programmation, dans laquelle elles fonctionnaient non pas avec des instances distinctes des blocs fonctionnels de l'équipement technologique, avec la liaison correspondante des entrées et des sorties, mais avec des tableaux de structures. Par exemple, un tableau d'une structure de type d'entrée discrète. Ou un tableau d'une structure agrégée. Cette approche de la programmation a le droit d'exister, car elle vous permet d'économiser sérieusement la mémoire de travail du CPU, mais,d'autre part, rend le code du programme difficile à lire. Un programmeur tiers et avec un simple regard sur un programme CONT peut difficilement le comprendre tout de suite, mais des tas d'indices, de tableaux et de fonctions pour les traiter sont hors de question; ici, sans documentation pour le logiciel (et sans un demi-litre, bien sûr), nulle part.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces tableaux de structures étaient généralement traités dans des fonctions. En principe, rien n'empêchait le traitement des blocs fonctionnels, mais il y avait toujours une question importante - comment travailler avec des temporisateurs dans ces cas? Les temporisateurs standard supposent soit un nombre (S5) soit une instance d'un bloc fonctionnel (CEI). Je vous rappelle qu'il s'agit de traiter des tableaux de structures pour les automates Simatic classiques et de «tordre» les nombres de temporisations dans ces structures, et plus encore, les instances sont soit difficiles, soit tout simplement impossibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cette raison, nous avons créé notre propre fonction de minuterie en tant que fonction. En principe, pour le fonctionnement de n'importe quel minuteur, vous devez connaître seulement quelques éléments - l'état de l'entrée, le réglage de l'heure et le temps écoulé depuis l'activation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les séries 300 et 400, il y avait deux façons de déterminer cette heure. </font><font style="vertical-align: inherit;">La première consiste à examiner le temps d'exécution de l'OB1 principal (il existe une variable correspondante dans l'OB1 lui-même) ou des OB cycliques et d'augmenter l'accumulateur de temps interne à chaque appel de temporisateur, à condition que la «vérité» soit entrée. </font><font style="vertical-align: inherit;">Pas une bonne option, car ce temps est différent pour l'OB1 et les OB cycliques. </font><font style="vertical-align: inherit;">La deuxième méthode est la fonction système TIME_TCK, qui, à chaque appel, renvoyait une valeur unique - le compteur interne en millisecondes du processeur central. </font></font><br>
<br>
<img src="https://sun9-40.userapi.com/c855036/v855036198/1f8065/UwCQvxh507k.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, pour un temporisateur de type TON (on delay), l'algorithme de fonctionnement était le suivant:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le front montant de la demande de réponse, réinitialisez la sortie et mémorisez la valeur actuelle du temporisateur système TIME_TCK</font></font></li>
<li>       «»          ,        (   ,  TIME_TCK    0  (2 ^ 31 — 1),          ).   ,        .    ,    «»,    — «»</li>
<li>      «»,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'avènement de la "millième" série, la situation a un peu changé. Le fait est que la ligne S7-1500 a hérité de la prise en charge de l'appel système TIME_TCK et des amateurs de l'approche «debout et dans un hamac» (comment pouvez-vous appeler un programme qui traite uniquement des tableaux de structures tout en fonctionnant avec des index effrayants?) calmement continuer à utiliser leurs meilleures pratiques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La série de contrôleurs de base S7-1200 est basée sur une architecture différente et présente un certain nombre de différences par rapport au S7-1500. Y compris l'absence d'un appel système TIME_TCK. Dans les rangs des développeurs qui n'ont pas une flexibilité de pensée suffisante, l'insatisfaction a disparu - il est impossible d'exécuter des copies / pâtes d'anciens programmes. Cependant, la tâche de déterminer combien de temps s'est écoulé depuis l'appel précédent peut être effectuée à l'aide de la fonction d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exécution</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonction renvoie le temps écoulé depuis son appel précédent, en secondes, sous la forme d'un nombre réel double précision LREAL. Les détails sont décrits dans l'aide. À des fins internes, une variable MEM supplémentaire (également de type LREAL) est requise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je donnerai les sources de la première approximation de la fonction, et je donnerai quelques notes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déclaration de fonction:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_OUTPUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec les entrées / sorties, tout est clair: IN, Q et PT. J'ai mis le réglage de l'heure sous la forme d'un vrai, c'est des secondes. Je voulais juste (mais en vain, mais plus sur cela ci-dessous). Plus d'informations sur les variables de la zone InOut. Étant donné que nous avons une fonction, nous n'avons pas de zone STAT, aucune variable ne conserve sa valeur lors du prochain appel de fonction, et de telles variables sont nécessaires: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPrv - pour déterminer le bord positif de la demande </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEM - variable auxiliaire pour l'appel système au travail runtime </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimeACC - accumulateur de temps , qui stockera le nombre de microsecondes du retard en cours d'exécution.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les variables TimeACC, udiCycle et udiPT sont spécifiées au format UDINT, un entier non signé, 4 octets. </font><font style="vertical-align: inherit;">Malgré le fait que j'ai spécifié l'heure comme réelle et que la fonction d'exécution renvoie autant que la double précision, je préfère effectuer des opérations simples de sommation et de comparaison avec des opérandes entiers pour gagner du temps sur le processeur. </font><font style="vertical-align: inherit;">Le temps dans mon cas est pris en compte à la microseconde près. </font><font style="vertical-align: inherit;">La raison est simple - si vous grossissez le temps en millisecondes, puis avec un OB1 presque vide (par exemple, si un seul temporisateur est appelé dans tout le programme du contrôleur et rien de plus), des «sauts» de cycles sont possibles, le programme s'exécute parfois pendant 250 μs. </font><font style="vertical-align: inherit;">Mais dans ce cas, la valeur maximale autorisée de l'accumulateur de temps sera de 4 294 secondes, soit près de 4 295 (2 ^ 32 - 1 = 4 294 967 295). </font><font style="vertical-align: inherit;">Il n'y a rien à faire, une telle «optimisation» nécessite des sacrifices.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texte de fonction.</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
    #Q := FALSE;<font></font>
ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
    #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
    <span class="hljs-keyword">IF</span> #TimeACC &gt;=  #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
        #Q := TRUE; <span class="hljs-comment">//  ""</span>
        #TimeACC := #udiPT; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//      </span>
        #Q := FALSE; <span class="hljs-comment">// </span><font></font>
    END_IF;<font></font>
<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
    #Q := FALSE;<font></font>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
END_IF;<font></font>
<font></font>
#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
<font></font>
ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux premières lignes sont le recalcul du réglage de la minuterie du nombre de secondes spécifié dans le format REAL au nombre de microsecondes. </font><font style="vertical-align: inherit;">Le temps en microsecondes écoulé depuis l'appel de bloc de programme précédent est également déterminé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, l'algorithme est le suivant, et je l'ai déjà donné:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le front montant de l'entrée IN, réinitialiser la sortie Q et réinitialiser l'accumulateur de temps</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la «vérité» continue d'être saisie, nous augmentons l'accumulateur de temps de la valeur udiCycle déjà connue et le comparons avec le réglage de l'heure. </font><font style="vertical-align: inherit;">Si le réglage de l'heure est dépassé, la minuterie a fonctionné, donnez la sortie «vrai», sinon, donnez la sortie «faux»</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en cas d'application d'une fausse entrée à l'entrée IN, réinitialiser la sortie Q et réinitialiser l'accumulateur de temps.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la fin de la fonction, afin de déterminer le bord de l'entrée IN, rappelez-vous sa valeur précédente. </font><font style="vertical-align: inherit;">Donnez également à la sortie ENO (lors de l'utilisation d'une fonction dans des langages graphiques, comme LAD) la valeur de la sortie Q. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous assurons que la fonction fonctionne, après quoi il devient intéressant d'évaluer sa vitesse et, si nécessaire, de l'améliorer (il apparaît déjà à première vue qu'un certain nombre de calculs sont effectués inactif et perdre du temps CPU en vain). </font><font style="vertical-align: inherit;">Pour évaluer les performances, je déclare un tableau de 1000 structures de données de temporisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déclaration de la structure. </font><font style="vertical-align: inherit;">Ses champs dupliquent les variables d'entrée et de sortie de la fonction timer.</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">TYPE</span> "typePervTONdata"<font></font>
VERSION : <span class="hljs-number">0.1</span><font></font>
   STRUCT<font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//   </span>
      Q : Bool;   <span class="hljs-comment">//  </span>
      INPrv : Bool;   <span class="hljs-comment">//    </span>
      MEM : LReal;   <span class="hljs-comment">//    </span>
      TimeACC : UDInt;   <span class="hljs-comment">//  </span><font></font>
   END_STRUCT;<font></font>
<font></font>
END_TYPE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tableau de structures est déclaré dans le bloc de données global TortureTON:</font></font><br>
<br>
<pre><code class="delphi hljs">TONs : <span class="hljs-keyword">Array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">999</span>] <span class="hljs-keyword">of</span> "typePervTONdata";
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code suivant est exécuté dans le bloc d'organisation OB1:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">FOR</span> #i := <span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">999</span> <span class="hljs-keyword">DO</span>
    "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span> := "startton";<font></font>
    "PerversionTON"(<span class="hljs-keyword">IN</span> := "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span>,<font></font>
                    PT := "TortureTON".TONs[#i].PT,<font></font>
                    Q := "TortureTON".TONs[#i].Q,<font></font>
                    INPrv := "TortureTON".TONs[#i].INPrv,<font></font>
                    MEM := "TortureTON".TONs[#i].MEM,<font></font>
                    TimeACC := "TortureTON".TONs[#i].TimeACC);<font></font>
END_FOR;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Annonce de 1 000 «instances» de minuteries, chacune fixant un temps de 10 secondes. Tous les 1000 temporisateurs commencent à compter le temps par la valeur de la variable de marqueur de startton. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je lance les fonctions de diagnostic du contrôleur (S7-1214C DC / DC / DC, version FW 4.4, version Step7 - V16) et je regarde le temps de cycle de balayage du contrôleur. À «inactif» (lorsque «faux» arrive à l'entrée des temporisateurs), le millier entier est traité en moyenne pendant 36 à 42 millisecondes. Pendant le décompte de dix secondes, cette lecture augmente d'environ 6 à 8 millisecondes et se prolonge parfois pendant 50 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous regardons ce qui peut être amélioré dans le code de fonction. Tout d'abord, les lignes au tout début du bloc de programme:</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ils sont toujours appelés, que le chronomètre compte le temps, ne compte pas ou ait déjà compté. Un gros gaspillage d'argent est de charger le processeur peu puissant de la série 1200 avec des calculs impliquant des matériaux à double précision. Il est raisonnable de transférer les deux lignes dans la partie du code qui traite le compte à rebours (si la «vérité» continue de se manifester). Il est également nécessaire de dupliquer le calcul udiCycle en un code qui traite un front positif à l'entrée du temporisateur. Cela devrait soulager le «fonctionnement à vide» du temporisateur lorsque la valeur d'entrée est fausse. En pratique, les temporisateurs des contrôleurs logiques programmables fonctionnent le plus souvent «au ralenti». Par exemple, le temps de filtrage du rebond de contact est de dizaines de millisecondes. L'impulsion de commande d'une sortie discrète est de quelques centaines de millisecondes, généralement de 0,5 à 1,0 seconde.Le temps de surveillance de l'exécution de la commande de l'unité (par exemple, l'heure à laquelle la vanne s'ouvre complètement) est de quelques dizaines à plusieurs minutes. Le PLC en production fonctionne 24 heures sur 24 et 365 jours (et parfois plus!) Par an. Autrement dit, le plus souvent, l'entrée du minuteur est soit «zéro», et le minuteur ne compte rien, soit une «unité» arrive depuis longtemps, et le minuteur a déjà tout compté. Pour décharger le processeur du deuxième étage inactif (le minuteur a déjà compté), il est nécessaire de vérifier au stade "l'entrée continue de recevoir la vérité" - si le minuteur a déjà tout le temps compté et de régler la sortie sur vrai. Dans ce cas, aucun calcul ne doit être effectué.le plus souvent, l'entrée du minuteur est soit «zéro», et le minuteur ne compte rien, soit une «unité» arrive depuis longtemps, et le minuteur a déjà tout compté. Pour décharger le processeur du deuxième étage inactif (le minuteur a déjà compté), il est nécessaire de vérifier au stade "l'entrée continue de recevoir la vérité" - si le minuteur a déjà tout le temps compté et de régler la sortie sur vrai. Dans ce cas, aucun calcul ne doit être effectué.le plus souvent, l'entrée du minuteur est soit «zéro», et le minuteur ne compte rien, soit une «unité» arrive depuis longtemps, et le minuteur a déjà tout compté. Pour décharger le processeur du deuxième étage inactif (le minuteur a déjà compté), il est nécessaire de vérifier au stade "l'entrée continue de recevoir la vérité" - si le minuteur a déjà tout le temps compté et de régler la sortie sur vrai. Dans ce cas, aucun calcul ne doit être effectué.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour effectuer ces modifications, il est nécessaire de transférer la sortie du temporisateur Q de la zone OUTPUT vers la zone IN_OUT, et la valeur de sortie sera stockée dans des variables externes (dans cet exemple, dans un tableau de structures). Après raffinement, le code de fonction entier, y compris la déclaration, est le suivant:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">BEGIN</span>
	<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	    #Q := FALSE;<font></font>
	    #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">// " "  </span>
	ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
	    <span class="hljs-keyword">IF</span> (<span class="hljs-keyword">NOT</span> #Q) <span class="hljs-keyword">THEN</span>
	        #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
	        #udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span>
	        #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
	        <span class="hljs-keyword">IF</span> #TimeACC &gt;= #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
	            #Q := TRUE; <span class="hljs-comment">//  ""</span>
	            #TimeACC := #udiPT; <span class="hljs-comment">//  </span><font></font>
	        END_IF;<font></font>
	    END_IF;<font></font>
	<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
	    #Q := FALSE;<font></font>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	END_IF;<font></font>
	<font></font>
	#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
	<font></font>
	ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span><font></font>
END_FUNCTION<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, le temps d'exécution s'améliore: le traitement du temps d'inactivité des temporisateurs est de 23 ms, avec un temps de filtrage de travail de 37 à 40 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code de fonction ne vérifie pas une valeur non valide du réglage de la minuterie - une valeur négative (si le matériau est converti en un entier non signé, le réglage sera déformé) ou une valeur supérieure à 4294,9 secondes (le réglage de l'heure débordera et se déformera). Vous devez soit contrôler la valeur de la valeur PT dans le code, soit confier la tâche de vérification de la plage de réglage de l'heure (de 0 à 4294,9 secondes) au système opérateur de niveau supérieur. La vérification de la plage au moyen du programme PLC augmente le temps de traitement à environ 45-46 ms (et, en général, la manière la plus correcte est de régler le temps de la minuterie non pas au format REAL, mais au format UDINT en millisecondes et pour faire des bêtises).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet d'application avec une minuterie pour l'environnement TIA Portal Step 7 version 16 est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491188/index.html">Ce que le testeur de backend devrait savoir</a></li>
<li><a href="../fr491190/index.html">Création d'une boutique en ligne sur Nuxt.js 2 Procédure pas à pas, partie 3</a></li>
<li><a href="../fr491192/index.html">Figmiro. Faire un plugin pour Figma (et un peu pour Miro)</a></li>
<li><a href="../fr491194/index.html">Génétique d'origine. Composition de la population</a></li>
<li><a href="../fr491198/index.html">Six conseils pour créer le bon didacticiel de jeu</a></li>
<li><a href="../fr491202/index.html">Ingénieurs contre concepteurs</a></li>
<li><a href="../fr491208/index.html">7 habitudes qui feront de tout introverti un maître de la communication</a></li>
<li><a href="../fr491210/index.html">Mini-série de vidéos avec animation de personnages sur le jeu d'intimidation Monster Hustle</a></li>
<li><a href="../fr491212/index.html">Huile et vodka: comment se débarrasser des autocollants des ordinateurs portables</a></li>
<li><a href="../fr491214/index.html">9 stratégies pour commercialiser des jeux mobiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>