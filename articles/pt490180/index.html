<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😦 🖐🏽 🤑 Padrões de armazenamento Kubernetes 👶🏻 👚 🎥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 
 
 Lembramos que lançamos outro livro extremamente interessante e útil sobre os padrões do Kubernetes. Tudo começou com “ Patterns ” de Bre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Padrões de armazenamento Kubernetes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olá Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembramos que lançamos outro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">livro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> extremamente interessante e útil </font><font style="vertical-align: inherit;">sobre os padrões do Kubernetes. </font><font style="vertical-align: inherit;">Tudo começou com “ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” de </font><font style="vertical-align: inherit;">Brendan Burns e, a propósito, o trabalho nesse segmento está em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pleno andamento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hoje, convidamos você a ler um artigo do blog do MinIO que resume as tendências e especificidades dos padrões de armazenamento de dados no Kubernetes.</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes mudou fundamentalmente os padrões tradicionais de desenvolvimento e implantação de aplicativos. </font><font style="vertical-align: inherit;">Agora, a equipe pode levar dias para desenvolver, testar e implantar o aplicativo - em diferentes ambientes e tudo isso nos clusters do Kubernetes. </font><font style="vertical-align: inherit;">Esse trabalho com a tecnologia de gerações anteriores geralmente levava semanas, se não meses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa aceleração foi possível graças à abstração fornecida pelo Kubernetes - ou seja, devido ao fato de o próprio Kubernetes interagir com detalhes de baixo nível de máquinas físicas ou virtuais, permitindo que os usuários declarem, entre outros parâmetros, o processador desejado, a memória necessária, o número de instâncias de contêiner. Como o Kubernetes é suportado por uma enorme comunidade e o escopo do Kubernetes está em constante expansão, ele lidera por uma ampla margem entre todas as plataformas de orquestração de contêineres. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À medida que o uso do Kubernetes se expande, também aumenta a confusão sobre os padrões de armazenamento usados ​​nele</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a competição geral por um pedaço de torta Kubernetes (isto é, para armazenamento de dados), quando se trata de falar sobre armazenamento de dados, o sinal está se afogando em barulho alto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Kubernetes incorpora um modelo moderno para desenvolver, implantar e gerenciar aplicativos. Um modelo tão moderno desconecta o armazenamento de dados da computação. Para entender completamente esse desapego no contexto do Kubernetes, você também precisa entender o que são aplicativos com estado e sem estado e como o armazenamento de dados é combinado com isso. É aqui que a abordagem da API REST usada pelo S3 tem vantagens claras sobre a abordagem POSIX / CSI, típica de outras soluções.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, falaremos sobre padrões de armazenamento no Kubernetes e discutiremos separadamente o debate sobre aplicativos sem estado e sem estado, para que possamos entender claramente a diferença entre eles e por que é importante. </font><font style="vertical-align: inherit;">Além disso, consideraremos os aplicativos e os padrões de armazenamento de dados usados ​​neles à luz das práticas recomendadas para trabalhar com contêineres e Kubernetes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contêineres sem estado</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os contêineres são inerentemente leves e efêmeros. </font><font style="vertical-align: inherit;">Eles podem ser facilmente parados, excluídos ou implantados em outro nó - tudo isso leva alguns segundos. </font><font style="vertical-align: inherit;">Em um grande sistema de orquestração de contêineres, essas operações ocorrem continuamente e os usuários nem percebem essas alterações. </font><font style="vertical-align: inherit;">No entanto, os movimentos são possíveis apenas se o contêiner não tiver dependências no nó em que está localizado. </font><font style="vertical-align: inherit;">Diz-se que esses contêineres funcionam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem preservação do estado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Containers</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o contêiner armazenar dados em dispositivos conectados localmente (ou em um dispositivo de bloco), o armazém de dados em que está localizado terá que ser movido para um novo nó junto com o próprio contêiner - em caso de falha. Isso é importante, porque, caso contrário, o aplicativo em execução no contêiner não poderá funcionar corretamente, pois precisa acessar os dados armazenados na mídia local. Dizem que esses contêineres são </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateful</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do ponto de vista puramente técnico, os containers com estado também podem ser movidos para outros nós. Normalmente, isso é conseguido usando sistemas de arquivos distribuídos ou bloquear armazenamentos de rede conectados a todos os nós nos quais os contêineres operam. Assim, os contêineres obtêm acesso aos volumes para armazenamento persistente de dados e as informações são armazenadas em discos localizados em toda a rede. Chamarei esse método de “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abordagem de contêiner de preservação do estado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” e no restante do artigo chamarei por uma questão de uniformidade.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma abordagem típica de contêiner com estado, todos os pods de aplicativos são anexados a um sistema de arquivos distribuído - um tipo de armazenamento compartilhado é obtido, onde todos os dados do aplicativo são adquiridos. </font><font style="vertical-align: inherit;">Embora algumas variações sejam possíveis, essa é uma abordagem de alto nível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, vamos ver por que a abordagem de contêiner com estado no mundo baseado em nuvem é antipadrão.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design de aplicativo baseado em nuvem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tradicionalmente, os aplicativos usavam bancos de dados para armazenamento estruturado de informações e discos locais ou sistemas de arquivos distribuídos, onde todos os dados não estruturados ou semiestruturados eram despejados. À medida que o volume de dados não estruturados aumentou, os desenvolvedores perceberam que o POSIX era muito falador, associado a custos significativos e, por fim, interfere no aplicativo ao passar para uma escala realmente grande.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso contribuiu principalmente para o surgimento de um novo padrão para armazenamento de dados, ou seja, armazenamentos baseados em nuvem que funcionam principalmente com base na API REST e liberam o aplicativo da manutenção onerosa do armazém de dados local. Nesse caso, o aplicativo realmente entra no modo de operação sem salvar o estado (já que o estado está no armazenamento remoto). Aplicativos modernos estão sendo construídos do zero, já levando esse fator em consideração. Como regra, qualquer aplicativo moderno que processe dados de um tipo ou de outro (logs, metadados, blobs etc.) é construído em um paradigma orientado à nuvem, em que o estado é transferido para um sistema de software especialmente alocado para seu armazenamento.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma abordagem stateful de contêiner faz todo esse paradigma reverter exatamente para onde começou!</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ao usar interfaces POSIX para armazenar dados, os aplicativos funcionam da mesma maneira como se mantivessem o estado e, por isso, afastam-se dos postulados mais importantes do design baseado em nuvem, ou seja, da capacidade de variar o tamanho dos fluxos de trabalho do aplicativo, dependendo da entrada. carregar, vá para um novo nó assim que o nó atual falhar e assim por diante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma análise mais detalhada dessa situação revela que, ao escolher um data warehouse, enfrentamos repetidamente o dilema “API POSIX versus REST”, mas com agravamento adicional dos problemas do POSIX causados ​​pela natureza distribuída dos ambientes Kubernetes. Em particular,</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   «»  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto a interface de armazenamento de dados do contêiner (CSI) ajudou muito na distribuição do nível de volume do Kubernetes, passando-o parcialmente para fornecedores de data warehouse de terceiros, mas também contribuiu acidentalmente para a convicção de que a abordagem de contêiner com estado era o método recomendado de armazenamento de dados no Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O CSI foi desenvolvido como padrão para fornecer sistemas arbitrários de armazenamento de blocos e arquivos para aplicativos legados ao trabalhar com o Kubernetes. E, como foi mostrado neste artigo, a única situação em que uma abordagem de contêiner com estado (e CSI em sua forma atual) é apropriada é quando o próprio aplicativo é um sistema legado no qual é impossível adicionar suporte à API de armazenamento de dados do objeto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É importante entender que, ao usar o CSI em sua forma atual, ou seja, ao montar volumes ao trabalhar com aplicativos modernos, encontraremos aproximadamente os mesmos problemas encontrados nos sistemas em que o armazenamento de dados é organizado no estilo POSIX.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melhor abordagem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, é importante entender que a maioria dos aplicativos não é inerentemente aprimorada especificamente para trabalhar com ou sem preservação de estado. </font><font style="vertical-align: inherit;">Esse comportamento depende da arquitetura geral do sistema e das opções específicas selecionadas durante o design. </font><font style="vertical-align: inherit;">Vamos falar um pouco sobre aplicativos com estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em princípio, todos os dados do aplicativo podem ser divididos em vários tipos amplos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados de log</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados do carimbo de data / hora</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados de transação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metadados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagens de contêiner</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados de blob (blobs)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos esses tipos de dados são muito bem suportados em plataformas modernas de armazenamento de dados e existem várias plataformas baseadas na nuvem adaptadas para fornecer dados em cada um desses formatos específicos. Por exemplo, dados e metadados de transação podem residir em um banco de dados moderno baseado em nuvem, como CockroachDB, YugaByte, etc. Imagens de contêiner ou dados de blob podem ser armazenados no registro da janela de encaixe com base no MinIO. Os dados do registro de data e hora podem ser armazenados em um banco de dados de séries temporais, como o InfluxDB, etc. Não entraremos em detalhes de cada tipo de dados e aplicativos relacionados, mas a idéia geral é evitar o armazenamento persistente de dados com base na montagem do disco local.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, muitas vezes é eficaz fornecer uma camada de cache temporária, que serve como um tipo de armazenamento temporário de arquivos para aplicativos, mas os aplicativos não devem depender desse nível como fonte de verdade.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Armazenamento de aplicativos com estado</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora na maioria dos casos seja útil manter os aplicativos sem estado, os aplicativos projetados para armazenar dados - por exemplo, bancos de dados, armazenamento de objetos, armazenamento de chave e valor - devem manter o estado. </font><font style="vertical-align: inherit;">Vamos ver por que esses aplicativos são implantados no Kubernetes. </font><font style="vertical-align: inherit;">Tome o MinIO como exemplo, mas princípios semelhantes se aplicam a qualquer outro grande sistema de armazenamento baseado em nuvem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os aplicativos centralizados na nuvem são projetados para maximizar o uso da flexibilidade inerente aos contêineres. Isso significa que eles não fazem suposições sobre o ambiente em que serão implantados. Por exemplo, o MinIO usa um mecanismo de codificação de apagamento interno, que fornece ao sistema estabilidade suficiente para permanecer operacional, mesmo que metade das unidades falhe. O MinIO também gerencia a integridade e a segurança dos dados usando seu próprio hash e criptografia no servidor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esses aplicativos baseados na nuvem, os volumes persistentes locais (PV) são mais convenientes como armazenamento de backup. </font><font style="vertical-align: inherit;">O PV local fornece a capacidade de armazenar dados brutos, enquanto os aplicativos executados sobre esses PVs coletam informações de forma independente para dimensionar dados e gerenciar requisitos crescentes de dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem é muito mais simples e escalável significativamente melhor em comparação com o PV baseado em CSI, que traz seus próprios níveis de gerenciamento de dados e redundância ao sistema; </font><font style="vertical-align: inherit;">o fato é que esses níveis geralmente entram em conflito com aplicativos projetados de acordo com o princípio da preservação do estado.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimento confiante para desvincular dados da computação</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, falamos sobre como os aplicativos são reorientados para funcionar sem salvar o estado ou, em outras palavras, o armazenamento de dados é delimitado pela computação neles. Em conclusão, consideramos alguns exemplos reais dessa tendência. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a renomada plataforma de análise de dados, tem sido tradicionalmente usada com implantação e implantação com estado no sistema de arquivos HDFS. No entanto, à medida que o Spark faz a transição para um mundo baseado em nuvem, essa plataforma está sendo cada vez mais usada sem preservação de estado usando o `s3a`. O Spark usa s3a para transferir o estado para outros sistemas, enquanto os contêineres do Spark funcionam totalmente sem preservação do estado. Outros grandes players corporativos no campo da análise de big data, em particular </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> também vai trabalhar com a divisão de armazenamento de dados e computação sobre eles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Padrões semelhantes também podem ser vistos em outras grandes plataformas analíticas, incluindo Presto, Tensorflow para R, Jupyter. </font><font style="vertical-align: inherit;">O estado de upload para sistemas de armazenamento em nuvem remotos facilita muito o gerenciamento e o dimensionamento de seu aplicativo. </font><font style="vertical-align: inherit;">Além disso, ajuda a portabilidade do aplicativo para uma variedade de ambientes.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt490162/index.html">As peculiaridades da evolução: a descoberta de um organismo que vive sem oxigênio</a></li>
<li><a href="../pt490168/index.html">Análise da qualidade do chatbot no IBM Watson Assistant</a></li>
<li><a href="../pt490170/index.html">Gerente de projeto em um vício. Por que isso e o que fazer sobre isso</a></li>
<li><a href="../pt490174/index.html">Pesquisa de DNS no Kubernetes</a></li>
<li><a href="../pt490178/index.html">Enquanto todo mundo está indo para o oeste, mudei-me para a Armênia</a></li>
<li><a href="../pt490184/index.html">Alphabet tem um segundo grupo secreto de desenvolvedores de computadores quânticos</a></li>
<li><a href="../pt490186/index.html">Do que criamos o JET BI. Arquitetura Business Intelligence System sem digressões líricas</a></li>
<li><a href="../pt490190/index.html">Vou pesquisar: posicionamento geográfico do host por endereço IP na Internet global usando a troca de criptografia da Binance como exemplo</a></li>
<li><a href="../pt490194/index.html">Usando RabbitMQ com MonsterMQ Parte 4</a></li>
<li><a href="../pt490196/index.html">[Flipper Zero] recusam Raspberry Pi, fazem nossa própria prancha do zero. Encontrar o chip WiFi certo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>