<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº üë¨ üïµüèª QSerializer: L√∂sung f√ºr die einfache JSON / XML-Serialisierung üöà üå≤ üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Ich dachte, dass es irgendwie unfair ausf√§llt - in Java, C #, Go, Python usw. Es gibt Bibliotheken f√ºr die komfortable Serialisierung ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>QSerializer: L√∂sung f√ºr die einfache JSON / XML-Serialisierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496836/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich dachte, dass es irgendwie unfair ausf√§llt - in Java, C #, Go, Python usw. </font><font style="vertical-align: inherit;">Es gibt Bibliotheken f√ºr die komfortable Serialisierung von Objektdaten in jetzt modisches JSON und XML, aber in C ++ haben sie es entweder vergessen oder wollten es nicht oder brauchten es nicht wirklich, oder es ist alles kompliziert oder vielleicht alles zusammen. </font><font style="vertical-align: inherit;">Also habe ich beschlossen, dieses Problem zu beheben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Details wie gewohnt unter dem Schnitt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/cp/vw/j9cpvwvjh9gfvhqxigysyx7m78c.png" alt="Bild"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wieder einmal entschied ich mich f√ºr das n√§chste Haustierprojekt, dessen Kern der Client-Server-Austausch war, w√§hrend RaspberryPi der Lieblingsserver vieler war. Unter anderem interessierte mich das Problem der Erstellung von "Speicherpunkten" - damit ich als Teil des Prototyps den Status des Objekts so einfach wie m√∂glich speichern konnte, bevor ich es beim n√§chsten Start verlie√ü und wiederherstellte. Aufgrund meiner unvern√ºnftigen Feindseligkeit gegen√ºber Python und meiner sehr herzlichen Haltung gegen√ºber Qt habe ich mich f√ºr Qt &amp; C ++ entschieden. Das Schreiben von Kursen und Spaghetti-Funktionen zum Parsen von JSON ist immer noch ein Vergn√ºgen. Ich brauchte eine universelle und gleichzeitig einfache L√∂sung f√ºr mein Problem. "Wir m√ºssen es herausfinden", sagte ich mir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst ein wenig zu den Begriffen:</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Serialisierung wird eine Datenstruktur in eine Folge von Bits √ºbersetzt. </font><font style="vertical-align: inherit;">Die Umkehrung der Serialisierungsoperation ist die Deserialisierungsoperation (Strukturierungsoperation) - die Wiederherstellung des Anfangszustands der Datenstruktur aus einer Bitsequenz.</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go verf√ºgt √ºber ein sehr n√ºtzliches "natives" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codierungs- / JSON-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket </font><font style="vertical-align: inherit;">, mit dem Sie die Serialisierung des Objekts mithilfe der Marshal-Methode und die umgekehrte Strukturierung mit Unmarshal abschlie√üen k√∂nnen (aufgrund dieser Bibliothek hatte ich zuerst eine falsche Vorstellung vom Marshalling, aber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desine sperare qui hic intras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). . </font><font style="vertical-align: inherit;">Nach den Konzepten dieses Pakets fand ich eine weitere Bibliothek f√ºr Java - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die sich als sehr angenehmes Produkt herausstellte. Es war eine Freude, sie zu verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich √ºberlegte, was ich an diesen Bibliotheken mag und kam zu dem Schluss, dass es ihre Benutzerfreundlichkeit war. Flexible Funktionalit√§t und alles in einem Aufruf. F√ºr die Serialisierung in JSON war es ausreichend, die toJson-Methode aufzurufen und ein serialisierbares Objekt an sie zu √ºbergeben. C ++ selbst verf√ºgt jedoch standardm√§√üig nicht √ºber die richtigen Metaobjektfunktionen, um gen√ºgend Informationen zu den Feldern einer Klasse bereitzustellen, wie dies beispielsweise in Java (ClassName.class) der Fall ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mochte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QJson nur f√ºr die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt-Plattform </font><font style="vertical-align: inherit;">, aber es passte immer noch nicht ganz zu meinem Verst√§ndnis der Benutzerfreundlichkeit, die durch die oben genannten Bibliotheken generiert wurde. So erschien das Projekt, das hier diskutiert wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleiner Haftungsausschluss:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Mechanismen l√∂sen das Problem der Dateninterpretation f√ºr Sie nicht. </font><font style="vertical-align: inherit;">Alles, was Sie von ihnen erhalten k√∂nnen, ist die Konvertierung von Daten in eine f√ºr Sie bequemere Form.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializer-Projektstruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt und die Beispiele k√∂nnen auf GitHub angezeigt werden ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Dort finden Sie auch detaillierte Installationsanweisungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Vorgriff auf den Selbstmord in der Architektur werde ich einen Vorbehalt machen, dass dies nicht die endg√ºltige Version ist. </font><font style="vertical-align: inherit;">Die Arbeiten werden trotz der verlassenen Steine ‚Äã‚Äãfortgesetzt, aber unter Ber√ºcksichtigung der W√ºnsche.</font></font><br>
<img src="https://habrastorage.org/webt/lg/rp/op/lgrpopckj4waexmewif_u2zngf4.png" alt="Allgemeine strukturelle Abh√§ngigkeiten der QSerializer-Bibliothek"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptziel dieses Projekts ist es, die Serialisierung im benutzerfreundlichen Datenformat in C ++ zug√§nglich und elementar zu machen. </font><font style="vertical-align: inherit;">Der Schl√ºssel zur Qualit√§tsentwicklung und -wartung des Produkts ist seine Architektur. </font><font style="vertical-align: inherit;">Ich schlie√üe nicht aus, dass in den Kommentaren zu diesem Artikel andere Implementierungsmethoden erscheinen, deshalb habe ich ein wenig ‚ÄûRaum f√ºr Kreativit√§t‚Äú gelassen. </font><font style="vertical-align: inherit;">Wenn Sie die Implementierung √§ndern, k√∂nnen Sie entweder eine neue Implementierung der PropertyKeeper-Schnittstelle hinzuf√ºgen oder die Factory-Methoden √§ndern, sodass Sie nichts an den QSerializer-Funktionen √§ndern m√ºssen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felddeklaration</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine M√∂glichkeit, Metaobjektinformationen in Qt zu sammeln, besteht darin, sie im Metaobjektsystem von Qt selbst zu beschreiben. </font><font style="vertical-align: inherit;">Vielleicht ist dies der einfachste Weg. </font></font><abbr title="Meta-Objekt-Compiler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOC</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generiert zur Kompilierungszeit alle erforderlichen Metadaten. </font><font style="vertical-align: inherit;">Sie k√∂nnen die metaObject-Methode f√ºr das beschriebene Objekt aufrufen, die eine Instanz der QMetaObject-Klasse zur√ºckgibt, mit der wir arbeiten m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu serialisierende Felder zu deklarieren, m√ºssen Sie die Klasse von QObject erben und das Makro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_OBJECT einbinden</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um dem MOC klar zu machen, ob der Klassentyp als Basis von QObject qualifiziert werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√§chstes</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschreibt das </font><font style="vertical-align: inherit;">Makro </font><font color="#FF1493"><font style="vertical-align: inherit;">Q_PROPERTY</font></font><font style="vertical-align: inherit;"> die Mitglieder der Klasse. </font><font style="vertical-align: inherit;">Wir werden die in </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschriebene </font><font style="vertical-align: inherit;">Eigenschaft property </font><font color="#FF1493"><font style="vertical-align: inherit;">aufrufen</font></font><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">QSerializer ignoriert Eigenschaften, ohne dass das USER-Flag auf true gesetzt ist.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum USER Flagge</font></font></b>
                        <div class="spoiler_text">     , ,  QML.        . ,   <font color="#FF1493">Q_PROPERTY</font>  QML   QSerializer     .<br>
</div>
                    </div><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> :</span> <span class="hljs-keyword">public</span> QObject<font></font>
{<font></font>
Q_OBJECT<font></font>
<span class="hljs-comment">// Define data members to be serialized</span>
Q_PROPERTY(QString name MEMBER name USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">int</span> age MEMBER age USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(QString email MEMBER email USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone MEMBER phone USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">bool</span> vacation MEMBER vacation USER <span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// Make base constructor</span><font></font>
  User() { }<font></font>
 <font></font>
  QString name;<font></font>
  <span class="hljs-keyword">int</span> age{<span class="hljs-number">0</span>};<font></font>
  QString email;<font></font>
  <span class="hljs-keyword">bool</span> vacation{<span class="hljs-literal">false</span>};
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone; <font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nicht standardm√§√üige Benutzertypen im Qt- </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaobjektsystem</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu deklarieren, empfehle ich die Verwendung des </font><font color="#FF1493"><font style="vertical-align: inherit;">Makros QS_REGISTER</font></font><font style="vertical-align: inherit;"> , das in qserializer.h definiert ist. </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatisiert den Prozess der Registrierung von </font><font color="#FF1493"><font style="vertical-align: inherit;">Typvariationen</font></font><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie k√∂nnen jedoch die klassische Methode zum Registrieren von Typen mit qRegisterMetaType &lt; </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; () verwenden. </font><font style="vertical-align: inherit;">Bei einem Metaobjektsystem sind der Klassentyp ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und der Klassenzeiger ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *) v√∂llig unterschiedliche Typen, sie haben unterschiedliche Bezeichner in der allgemeinen Liste der Typen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_METATYPE(Type) qRegisterMetaType<span class="hljs-meta-string">&lt;Type&gt;(#Type) ;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_REGISTER(Type)       \
QS_METATYPE(Type)               \
QS_METATYPE(Type*)              \
QS_METATYPE(std::vector<span class="hljs-meta-string">&lt;Type*&gt;) \</span></span>
QS_METATYPE(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Type&gt;)  \
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">// define user-type in Qt meta-object system</span><font></font>
QS_REGISTER(User)<font></font>
...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializer-Namespace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie dem UML-Diagramm entnehmen k√∂nnen, enth√§lt QSerializer eine Reihe von Funktionen zur Serialisierung und Strukturierung. </font><font style="vertical-align: inherit;">Der Namespace spiegelt konzeptionell die deklarative Essenz von QSerializer wider. </font><font style="vertical-align: inherit;">Auf die eingebettete Funktionalit√§t kann √ºber den Namen QSerializer zugegriffen werden, ohne dass irgendwo im Code ein Objekt erstellt werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Beispiel des Erstellens von JSON basierend auf dem oben beschriebenen Objekt der Benutzerklasse m√ºssen Sie nur die QSerializer :: toJson-Methode aufrufen:</font></font><br>
<br>
<pre><code class="cpp hljs">User u;<font></font>
u.name = <span class="hljs-string">"Mike"</span>;<font></font>
u.age = <span class="hljs-number">25</span>;<font></font>
u.email = <span class="hljs-string">"example@exmail.com"</span>;<font></font>
u.phone.push_back(<span class="hljs-string">"+12345678989"</span>);<font></font>
u.phone.push_back(<span class="hljs-string">"+98765432121"</span>);<font></font>
u.vacation = <span class="hljs-literal">true</span>;<font></font>
QJsonObject json = QSerializer::toJson(&amp;u);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist der resultierende JSON:</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mike"</span>,
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"example@exmail.com"</span>,
    <span class="hljs-attr">"phone"</span>: [
        <span class="hljs-string">"+12345678989"</span>,
        <span class="hljs-string">"+98765432121"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"vacation"</span>: <span class="hljs-literal">true</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei M√∂glichkeiten, ein Objekt zu strukturieren:</font></font><br>
<br>
<ul>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ein Objekt √§ndern m√ºssen</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">User u;<font></font>
QJsonObject userJson;<font></font>
QSerializer::fromJson(&amp;u, userJson);</code></pre></div>
                    </div></li>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ein neues Objekt ben√∂tigen</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">QJsonObject userJson;<font></font>
User * u = QSerializer::fromJson&lt;User&gt;(userJson);</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Beispiele und Ausgaben finden Sie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielordner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewahrer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das bequeme Schreiben und Lesen deklarierter Eigenschaften zu organisieren, verwendet QSerializer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keepers-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassen </font><font style="vertical-align: inherit;">, in denen jeweils ein Zeiger auf ein Objekt (QObject-Nachkomme) und eine seiner QMetaProperty gespeichert ist. </font><font style="vertical-align: inherit;">QMetaProperty selbst ist nicht von besonderem Wert, sondern nur ein Objekt mit einer Beschreibung der Eigenschaftsklasse, die f√ºr das MOC deklariert wurde. </font><font style="vertical-align: inherit;">Zum Lesen und Schreiben ben√∂tigen Sie ein bestimmtes Klassenobjekt, in dem diese Eigenschaft beschrieben wird. Dies ist die Hauptsache, an die Sie sich erinnern m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes serialisierbare Feld w√§hrend der Serialisierung wird an die Depotbank des entsprechenden Typs √ºbergeben. </font><font style="vertical-align: inherit;">Keepers werden ben√∂tigt, um die Serialisierungs- und Strukturierungsfunktionen f√ºr eine bestimmte Implementierung f√ºr einen bestimmten Typ der beschriebenen Daten zu kapseln. </font><font style="vertical-align: inherit;">Ich habe 4 Typen hervorgehoben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaSimpleKeeper - Property Keeper mit primitiven Datentypen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaArrayKeeper - Property Keeper mit Arrays primitiver Daten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectKeeper - Bewahrer verschachtelter Objekte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectArrayKeeper - Verwalter von Arrays verschachtelter Objekte </font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/dw/ao/0d/dwao0de8yeaqdcdb5zfkbuoof-k.png" alt="Datenstrom"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Herzst√ºck primitiver Datenverwalter ist die Konvertierung von Informationen von JSON / XML nach QVariant und umgekehrt, da QMetaProperty standardm√§√üig mit QVariant arbeitet.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaSimpleKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonValue result = QJsonValue::fromVariant(prop.read(linkedObj));<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(QString(prop.name()), result);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaSimpleKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;val)</span>
</span>{<font></font>
    prop.write(linkedObj, QVariant(val));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objekthalter basieren auf der √úbertragung von Informationen von JSON / XML an eine Reihe anderer Bewahrer und umgekehrt. </font><font style="vertical-align: inherit;">Solche Depotbanken arbeiten mit ihrem Eigentum als separates Objekt, das auch eigene Depotbanken haben kann. Ihre Aufgabe besteht darin, serialisierte Daten vom Immobilienobjekt zu sammeln und das Immobilienobjekt gem√§√ü den verf√ºgbaren Daten zu strukturieren.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaObjectKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;json)</span>
</span>{<font></font>
    ...<font></font>
    QSerializer::fromJson(linkedObj, json.toObject());<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaObjectKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonObject result = QSerializer::toJson(linkedObj);;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(prop.name(),QJsonValue(result));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keepers implementieren die PropertyKeeper-Schnittstelle, von der die abstrakte Basisklasse der Keepers geerbt wird. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie Dokumente im XML- oder JSON-Format nacheinander von oben nach unten analysieren und zusammenstellen, indem Sie einfach die beschriebenen gespeicherten Eigenschaften durchgehen und tiefer in die eingebetteten Objekte (falls vorhanden) in den beschriebenen Eigenschaften eintauchen, ohne auf Details der Implementierung einzugehen.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyKeeper-Schnittstelle</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyKeeper</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~PropertyKeeper() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">toJson</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue&amp;)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QDomNode&gt; <span class="hljs-title">toXml</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromXml</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QDomNode &amp;)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
</code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§chterfabrik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da alle Depotbanken eine Schnittstelle implementieren, sind alle Implementierungen hinter einem praktischen Bildschirm verborgen, und eine Reihe dieser Implementierungen wird von der KeepersFactory-Factory bereitgestellt. </font><font style="vertical-align: inherit;">Von dem an die Factory √ºbertragenen Objekt k√∂nnen Sie √ºber sein QMetaObject eine Liste aller deklarierten Eigenschaften abrufen, anhand derer der Typ der Depotbank bestimmt wird.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KeepersFactory Factory-Implementierung</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">int</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">bool</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">double</span>&gt;(),<font></font>
        qMetaTypeId&lt;QString&gt;(),<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">array_of_simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;(),<font></font>
    };<font></font>
...<font></font>
<span class="hljs-function">PropertyKeeper *<span class="hljs-title">KeepersFactory::getMetaKeeper</span><span class="hljs-params">(QObject *obj, QMetaProperty prop)</span>
</span>{
    <span class="hljs-keyword">int</span> t_id = QMetaType::type(prop.typeName());
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">simple_t</span>.begin(), <span class="hljs-keyword">simple_t</span>.end(), t_id) != <span class="hljs-keyword">simple_t</span>.end())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaSimpleKeeper(obj,prop);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">array_of_simple_t</span>.begin(),<span class="hljs-keyword">array_of_simple_t</span>.end(), t_id) != <span class="hljs-keyword">array_of_simple_t</span>.end())<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>( t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">int</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;QString&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">double</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">bool</span>&gt;(obj, prop);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        QObject * castobj = qvariant_cast&lt;QObject *&gt;(prop.read(obj));<font></font>
        <span class="hljs-keyword">if</span>(castobj)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectKeeper(castobj,prop);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (QString(prop.typeName()).contains(<span class="hljs-string">"std::vector&lt;"</span>))<font></font>
        {<font></font>
            QString t = QString(prop.typeName()).remove(<span class="hljs-string">"std::vector&lt;"</span>).remove(<span class="hljs-string">"&gt;"</span>);
            <span class="hljs-keyword">int</span> idOfElement = QMetaType::type(t.toStdString().c_str());
            <span class="hljs-keyword">if</span>(QMetaType::typeFlags(idOfElement).testFlag(QMetaType::PointerToQObject))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectArrayKeeper(obj, prop);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">throw</span> QSException(UnsupportedPropertyType);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper *&gt; <span class="hljs-title">KeepersFactory::getMetaKeepers</span><span class="hljs-params">(QObject *obj)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper*&gt; keepers;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj-&gt;metaObject()-&gt;propertyCount(); i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(obj-&gt;metaObject()-&gt;property(i).isUser(obj))<font></font>
            keepers.push_back(getMetaKeeper(obj, obj-&gt;metaObject()-&gt;property(i)));<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> keepers;<font></font>
}<font></font>
...<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wichtiges Merkmal der Guardian-Factory ist die M√∂glichkeit, eine vollst√§ndige Reihe von Guardians f√ºr ein Objekt bereitzustellen. Sie k√∂nnen die Liste der unterst√ºtzten primitiven Typen erweitern, indem Sie konstante Sammlungen mit Typ-IDs bearbeiten. </font><font style="vertical-align: inherit;">Jede Reihe von Keepern ist eine Art Karte f√ºr Eigenschaften des Objekts. </font><font style="vertical-align: inherit;">Wenn ein KeepersFactory-Objekt zerst√∂rt wird, wird der f√ºr die von ihm bereitgestellte Reihe von Keepern zugewiesene Speicher freigegeben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschr√§nkungen und Verhalten</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situation</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verhalten</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie, ein Objekt zu serialisieren, dessen Typ nicht von QObject geerbt wurde</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilierungsfehler</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht deklarierter Typ beim Versuch der Serialisierung / Struturisierung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSException :: UnsupportedPropertyType-Ausnahme</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Versuch, ein Objekt mit einem anderen primitiven Typ als dem in den Sammlungen simple_t und array_of_simple_t beschriebenen zu serialisieren / strukturieren.</font></font></td>
<td> QSException::UnsupportedPropertyType.    ,     ‚Äî     ,   </td>
</tr>
<tr>
<td> JSON/XML   </td>
<td>  </td>
</tr>
<tr>
<td>   propertyes,    JSON/XML</td>
<td> propertyes .       ‚Äî  propertyes          </td>
</tr>
<tr>
<td>      JSON  property </td>
<td> QSException</td>
</tr>
</tbody></table></div><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach hat sich das Projekt gelohnt, da dieser Artikel geschrieben wurde. </font><font style="vertical-align: inherit;">F√ºr mich kam ich zu dem Schluss, dass es keine universellen L√∂sungen gibt, man muss immer etwas opfern. </font><font style="vertical-align: inherit;">Durch die Entwicklung flexibler Funktionen in Bezug auf Nutzung und Funktionalit√§t k√∂nnen Sie die Einfachheit zunichte machen und umgekehrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich fordere Sie nicht auf, QSerializer zu verwenden. Mein Ziel ist vielmehr meine eigene Entwicklung als Programmierer. </font><font style="vertical-align: inherit;">Nat√ºrlich verfolge ich auch das Ziel, jemandem zu helfen, aber in erster Linie - nur Freude zu haben. </font><font style="vertical-align: inherit;">Sei positiv)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496824/index.html">Ihr nordisches Arbeitsumfeld</a></li>
<li><a href="../de496826/index.html">Millionen Sprites mit mehr als 120 fps</a></li>
<li><a href="../de496828/index.html">Wo finde ich freiberufliche Mitarbeiter, die Spa√ü machen werden? (Spoiler: nicht Upwork)</a></li>
<li><a href="../de496830/index.html">Was ist Emergent Communication und warum m√ºssen Sie es wissen?</a></li>
<li><a href="../de496832/index.html">Fototour: Was machen sie im Labor f√ºr hybride Nanophotonik und Optoelektronik des New Physics Institute ITMO?</a></li>
<li><a href="../de496838/index.html">Von Slack verwendete Projektbereitstellungsmethode</a></li>
<li><a href="../de496840/index.html">Musk glaubt, dass 12.000 Satelliten die Astronomen nicht st√∂ren werden. Seine Meinung stimmt nicht mit dem Modell √ºberein</a></li>
<li><a href="../de496842/index.html">Ein einfaches Epidemiemodell mit grundlegenden Python-Tools</a></li>
<li><a href="../de496846/index.html">Sprachmechanik von Stapeln und Zeigern</a></li>
<li><a href="../de496848/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 340 (vom 6. bis 12. April)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>