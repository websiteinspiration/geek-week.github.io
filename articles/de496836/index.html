<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 👬 🕵🏻 QSerializer: Lösung für die einfache JSON / XML-Serialisierung 🚈 🌲 🔷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Ich dachte, dass es irgendwie unfair ausfällt - in Java, C #, Go, Python usw. Es gibt Bibliotheken für die komfortable Serialisierung ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>QSerializer: Lösung für die einfache JSON / XML-Serialisierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496836/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich dachte, dass es irgendwie unfair ausfällt - in Java, C #, Go, Python usw. </font><font style="vertical-align: inherit;">Es gibt Bibliotheken für die komfortable Serialisierung von Objektdaten in jetzt modisches JSON und XML, aber in C ++ haben sie es entweder vergessen oder wollten es nicht oder brauchten es nicht wirklich, oder es ist alles kompliziert oder vielleicht alles zusammen. </font><font style="vertical-align: inherit;">Also habe ich beschlossen, dieses Problem zu beheben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Details wie gewohnt unter dem Schnitt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/cp/vw/j9cpvwvjh9gfvhqxigysyx7m78c.png" alt="Bild"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wieder einmal entschied ich mich für das nächste Haustierprojekt, dessen Kern der Client-Server-Austausch war, während RaspberryPi der Lieblingsserver vieler war. Unter anderem interessierte mich das Problem der Erstellung von "Speicherpunkten" - damit ich als Teil des Prototyps den Status des Objekts so einfach wie möglich speichern konnte, bevor ich es beim nächsten Start verließ und wiederherstellte. Aufgrund meiner unvernünftigen Feindseligkeit gegenüber Python und meiner sehr herzlichen Haltung gegenüber Qt habe ich mich für Qt &amp; C ++ entschieden. Das Schreiben von Kursen und Spaghetti-Funktionen zum Parsen von JSON ist immer noch ein Vergnügen. Ich brauchte eine universelle und gleichzeitig einfache Lösung für mein Problem. "Wir müssen es herausfinden", sagte ich mir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst ein wenig zu den Begriffen:</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Serialisierung wird eine Datenstruktur in eine Folge von Bits übersetzt. </font><font style="vertical-align: inherit;">Die Umkehrung der Serialisierungsoperation ist die Deserialisierungsoperation (Strukturierungsoperation) - die Wiederherstellung des Anfangszustands der Datenstruktur aus einer Bitsequenz.</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go verfügt über ein sehr nützliches "natives" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codierungs- / JSON-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket </font><font style="vertical-align: inherit;">, mit dem Sie die Serialisierung des Objekts mithilfe der Marshal-Methode und die umgekehrte Strukturierung mit Unmarshal abschließen können (aufgrund dieser Bibliothek hatte ich zuerst eine falsche Vorstellung vom Marshalling, aber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desine sperare qui hic intras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). . </font><font style="vertical-align: inherit;">Nach den Konzepten dieses Pakets fand ich eine weitere Bibliothek für Java - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die sich als sehr angenehmes Produkt herausstellte. Es war eine Freude, sie zu verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich überlegte, was ich an diesen Bibliotheken mag und kam zu dem Schluss, dass es ihre Benutzerfreundlichkeit war. Flexible Funktionalität und alles in einem Aufruf. Für die Serialisierung in JSON war es ausreichend, die toJson-Methode aufzurufen und ein serialisierbares Objekt an sie zu übergeben. C ++ selbst verfügt jedoch standardmäßig nicht über die richtigen Metaobjektfunktionen, um genügend Informationen zu den Feldern einer Klasse bereitzustellen, wie dies beispielsweise in Java (ClassName.class) der Fall ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mochte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QJson nur für die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt-Plattform </font><font style="vertical-align: inherit;">, aber es passte immer noch nicht ganz zu meinem Verständnis der Benutzerfreundlichkeit, die durch die oben genannten Bibliotheken generiert wurde. So erschien das Projekt, das hier diskutiert wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleiner Haftungsausschluss:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Mechanismen lösen das Problem der Dateninterpretation für Sie nicht. </font><font style="vertical-align: inherit;">Alles, was Sie von ihnen erhalten können, ist die Konvertierung von Daten in eine für Sie bequemere Form.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializer-Projektstruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt und die Beispiele können auf GitHub angezeigt werden ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Dort finden Sie auch detaillierte Installationsanweisungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Vorgriff auf den Selbstmord in der Architektur werde ich einen Vorbehalt machen, dass dies nicht die endgültige Version ist. </font><font style="vertical-align: inherit;">Die Arbeiten werden trotz der verlassenen Steine ​​fortgesetzt, aber unter Berücksichtigung der Wünsche.</font></font><br>
<img src="https://habrastorage.org/webt/lg/rp/op/lgrpopckj4waexmewif_u2zngf4.png" alt="Allgemeine strukturelle Abhängigkeiten der QSerializer-Bibliothek"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptziel dieses Projekts ist es, die Serialisierung im benutzerfreundlichen Datenformat in C ++ zugänglich und elementar zu machen. </font><font style="vertical-align: inherit;">Der Schlüssel zur Qualitätsentwicklung und -wartung des Produkts ist seine Architektur. </font><font style="vertical-align: inherit;">Ich schließe nicht aus, dass in den Kommentaren zu diesem Artikel andere Implementierungsmethoden erscheinen, deshalb habe ich ein wenig „Raum für Kreativität“ gelassen. </font><font style="vertical-align: inherit;">Wenn Sie die Implementierung ändern, können Sie entweder eine neue Implementierung der PropertyKeeper-Schnittstelle hinzufügen oder die Factory-Methoden ändern, sodass Sie nichts an den QSerializer-Funktionen ändern müssen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felddeklaration</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Möglichkeit, Metaobjektinformationen in Qt zu sammeln, besteht darin, sie im Metaobjektsystem von Qt selbst zu beschreiben. </font><font style="vertical-align: inherit;">Vielleicht ist dies der einfachste Weg. </font></font><abbr title="Meta-Objekt-Compiler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOC</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generiert zur Kompilierungszeit alle erforderlichen Metadaten. </font><font style="vertical-align: inherit;">Sie können die metaObject-Methode für das beschriebene Objekt aufrufen, die eine Instanz der QMetaObject-Klasse zurückgibt, mit der wir arbeiten müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu serialisierende Felder zu deklarieren, müssen Sie die Klasse von QObject erben und das Makro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_OBJECT einbinden</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um dem MOC klar zu machen, ob der Klassentyp als Basis von QObject qualifiziert werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nächstes</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschreibt das </font><font style="vertical-align: inherit;">Makro </font><font color="#FF1493"><font style="vertical-align: inherit;">Q_PROPERTY</font></font><font style="vertical-align: inherit;"> die Mitglieder der Klasse. </font><font style="vertical-align: inherit;">Wir werden die in </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschriebene </font><font style="vertical-align: inherit;">Eigenschaft property </font><font color="#FF1493"><font style="vertical-align: inherit;">aufrufen</font></font><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">QSerializer ignoriert Eigenschaften, ohne dass das USER-Flag auf true gesetzt ist.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum USER Flagge</font></font></b>
                        <div class="spoiler_text">     , ,  QML.        . ,   <font color="#FF1493">Q_PROPERTY</font>  QML   QSerializer     .<br>
</div>
                    </div><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> :</span> <span class="hljs-keyword">public</span> QObject<font></font>
{<font></font>
Q_OBJECT<font></font>
<span class="hljs-comment">// Define data members to be serialized</span>
Q_PROPERTY(QString name MEMBER name USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">int</span> age MEMBER age USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(QString email MEMBER email USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone MEMBER phone USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">bool</span> vacation MEMBER vacation USER <span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// Make base constructor</span><font></font>
  User() { }<font></font>
 <font></font>
  QString name;<font></font>
  <span class="hljs-keyword">int</span> age{<span class="hljs-number">0</span>};<font></font>
  QString email;<font></font>
  <span class="hljs-keyword">bool</span> vacation{<span class="hljs-literal">false</span>};
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone; <font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nicht standardmäßige Benutzertypen im Qt- </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaobjektsystem</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu deklarieren, empfehle ich die Verwendung des </font><font color="#FF1493"><font style="vertical-align: inherit;">Makros QS_REGISTER</font></font><font style="vertical-align: inherit;"> , das in qserializer.h definiert ist. </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatisiert den Prozess der Registrierung von </font><font color="#FF1493"><font style="vertical-align: inherit;">Typvariationen</font></font><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie können jedoch die klassische Methode zum Registrieren von Typen mit qRegisterMetaType &lt; </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; () verwenden. </font><font style="vertical-align: inherit;">Bei einem Metaobjektsystem sind der Klassentyp ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und der Klassenzeiger ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *) völlig unterschiedliche Typen, sie haben unterschiedliche Bezeichner in der allgemeinen Liste der Typen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_METATYPE(Type) qRegisterMetaType<span class="hljs-meta-string">&lt;Type&gt;(#Type) ;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_REGISTER(Type)       \
QS_METATYPE(Type)               \
QS_METATYPE(Type*)              \
QS_METATYPE(std::vector<span class="hljs-meta-string">&lt;Type*&gt;) \</span></span>
QS_METATYPE(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Type&gt;)  \
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">// define user-type in Qt meta-object system</span><font></font>
QS_REGISTER(User)<font></font>
...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializer-Namespace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie dem UML-Diagramm entnehmen können, enthält QSerializer eine Reihe von Funktionen zur Serialisierung und Strukturierung. </font><font style="vertical-align: inherit;">Der Namespace spiegelt konzeptionell die deklarative Essenz von QSerializer wider. </font><font style="vertical-align: inherit;">Auf die eingebettete Funktionalität kann über den Namen QSerializer zugegriffen werden, ohne dass irgendwo im Code ein Objekt erstellt werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Beispiel des Erstellens von JSON basierend auf dem oben beschriebenen Objekt der Benutzerklasse müssen Sie nur die QSerializer :: toJson-Methode aufrufen:</font></font><br>
<br>
<pre><code class="cpp hljs">User u;<font></font>
u.name = <span class="hljs-string">"Mike"</span>;<font></font>
u.age = <span class="hljs-number">25</span>;<font></font>
u.email = <span class="hljs-string">"example@exmail.com"</span>;<font></font>
u.phone.push_back(<span class="hljs-string">"+12345678989"</span>);<font></font>
u.phone.push_back(<span class="hljs-string">"+98765432121"</span>);<font></font>
u.vacation = <span class="hljs-literal">true</span>;<font></font>
QJsonObject json = QSerializer::toJson(&amp;u);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist der resultierende JSON:</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mike"</span>,
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"example@exmail.com"</span>,
    <span class="hljs-attr">"phone"</span>: [
        <span class="hljs-string">"+12345678989"</span>,
        <span class="hljs-string">"+98765432121"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"vacation"</span>: <span class="hljs-literal">true</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei Möglichkeiten, ein Objekt zu strukturieren:</font></font><br>
<br>
<ul>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ein Objekt ändern müssen</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">User u;<font></font>
QJsonObject userJson;<font></font>
QSerializer::fromJson(&amp;u, userJson);</code></pre></div>
                    </div></li>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ein neues Objekt benötigen</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">QJsonObject userJson;<font></font>
User * u = QSerializer::fromJson&lt;User&gt;(userJson);</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Beispiele und Ausgaben finden Sie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielordner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewahrer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das bequeme Schreiben und Lesen deklarierter Eigenschaften zu organisieren, verwendet QSerializer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keepers-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassen </font><font style="vertical-align: inherit;">, in denen jeweils ein Zeiger auf ein Objekt (QObject-Nachkomme) und eine seiner QMetaProperty gespeichert ist. </font><font style="vertical-align: inherit;">QMetaProperty selbst ist nicht von besonderem Wert, sondern nur ein Objekt mit einer Beschreibung der Eigenschaftsklasse, die für das MOC deklariert wurde. </font><font style="vertical-align: inherit;">Zum Lesen und Schreiben benötigen Sie ein bestimmtes Klassenobjekt, in dem diese Eigenschaft beschrieben wird. Dies ist die Hauptsache, an die Sie sich erinnern müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes serialisierbare Feld während der Serialisierung wird an die Depotbank des entsprechenden Typs übergeben. </font><font style="vertical-align: inherit;">Keepers werden benötigt, um die Serialisierungs- und Strukturierungsfunktionen für eine bestimmte Implementierung für einen bestimmten Typ der beschriebenen Daten zu kapseln. </font><font style="vertical-align: inherit;">Ich habe 4 Typen hervorgehoben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaSimpleKeeper - Property Keeper mit primitiven Datentypen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaArrayKeeper - Property Keeper mit Arrays primitiver Daten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectKeeper - Bewahrer verschachtelter Objekte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectArrayKeeper - Verwalter von Arrays verschachtelter Objekte </font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/dw/ao/0d/dwao0de8yeaqdcdb5zfkbuoof-k.png" alt="Datenstrom"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Herzstück primitiver Datenverwalter ist die Konvertierung von Informationen von JSON / XML nach QVariant und umgekehrt, da QMetaProperty standardmäßig mit QVariant arbeitet.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaSimpleKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonValue result = QJsonValue::fromVariant(prop.read(linkedObj));<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(QString(prop.name()), result);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaSimpleKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;val)</span>
</span>{<font></font>
    prop.write(linkedObj, QVariant(val));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objekthalter basieren auf der Übertragung von Informationen von JSON / XML an eine Reihe anderer Bewahrer und umgekehrt. </font><font style="vertical-align: inherit;">Solche Depotbanken arbeiten mit ihrem Eigentum als separates Objekt, das auch eigene Depotbanken haben kann. Ihre Aufgabe besteht darin, serialisierte Daten vom Immobilienobjekt zu sammeln und das Immobilienobjekt gemäß den verfügbaren Daten zu strukturieren.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaObjectKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;json)</span>
</span>{<font></font>
    ...<font></font>
    QSerializer::fromJson(linkedObj, json.toObject());<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaObjectKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonObject result = QSerializer::toJson(linkedObj);;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(prop.name(),QJsonValue(result));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keepers implementieren die PropertyKeeper-Schnittstelle, von der die abstrakte Basisklasse der Keepers geerbt wird. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie Dokumente im XML- oder JSON-Format nacheinander von oben nach unten analysieren und zusammenstellen, indem Sie einfach die beschriebenen gespeicherten Eigenschaften durchgehen und tiefer in die eingebetteten Objekte (falls vorhanden) in den beschriebenen Eigenschaften eintauchen, ohne auf Details der Implementierung einzugehen.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyKeeper-Schnittstelle</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyKeeper</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~PropertyKeeper() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">toJson</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue&amp;)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QDomNode&gt; <span class="hljs-title">toXml</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromXml</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QDomNode &amp;)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
</code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wächterfabrik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da alle Depotbanken eine Schnittstelle implementieren, sind alle Implementierungen hinter einem praktischen Bildschirm verborgen, und eine Reihe dieser Implementierungen wird von der KeepersFactory-Factory bereitgestellt. </font><font style="vertical-align: inherit;">Von dem an die Factory übertragenen Objekt können Sie über sein QMetaObject eine Liste aller deklarierten Eigenschaften abrufen, anhand derer der Typ der Depotbank bestimmt wird.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KeepersFactory Factory-Implementierung</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">int</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">bool</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">double</span>&gt;(),<font></font>
        qMetaTypeId&lt;QString&gt;(),<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">array_of_simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;(),<font></font>
    };<font></font>
...<font></font>
<span class="hljs-function">PropertyKeeper *<span class="hljs-title">KeepersFactory::getMetaKeeper</span><span class="hljs-params">(QObject *obj, QMetaProperty prop)</span>
</span>{
    <span class="hljs-keyword">int</span> t_id = QMetaType::type(prop.typeName());
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">simple_t</span>.begin(), <span class="hljs-keyword">simple_t</span>.end(), t_id) != <span class="hljs-keyword">simple_t</span>.end())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaSimpleKeeper(obj,prop);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">array_of_simple_t</span>.begin(),<span class="hljs-keyword">array_of_simple_t</span>.end(), t_id) != <span class="hljs-keyword">array_of_simple_t</span>.end())<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>( t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">int</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;QString&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">double</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">bool</span>&gt;(obj, prop);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        QObject * castobj = qvariant_cast&lt;QObject *&gt;(prop.read(obj));<font></font>
        <span class="hljs-keyword">if</span>(castobj)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectKeeper(castobj,prop);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (QString(prop.typeName()).contains(<span class="hljs-string">"std::vector&lt;"</span>))<font></font>
        {<font></font>
            QString t = QString(prop.typeName()).remove(<span class="hljs-string">"std::vector&lt;"</span>).remove(<span class="hljs-string">"&gt;"</span>);
            <span class="hljs-keyword">int</span> idOfElement = QMetaType::type(t.toStdString().c_str());
            <span class="hljs-keyword">if</span>(QMetaType::typeFlags(idOfElement).testFlag(QMetaType::PointerToQObject))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectArrayKeeper(obj, prop);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">throw</span> QSException(UnsupportedPropertyType);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper *&gt; <span class="hljs-title">KeepersFactory::getMetaKeepers</span><span class="hljs-params">(QObject *obj)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper*&gt; keepers;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj-&gt;metaObject()-&gt;propertyCount(); i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(obj-&gt;metaObject()-&gt;property(i).isUser(obj))<font></font>
            keepers.push_back(getMetaKeeper(obj, obj-&gt;metaObject()-&gt;property(i)));<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> keepers;<font></font>
}<font></font>
...<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wichtiges Merkmal der Guardian-Factory ist die Möglichkeit, eine vollständige Reihe von Guardians für ein Objekt bereitzustellen. Sie können die Liste der unterstützten primitiven Typen erweitern, indem Sie konstante Sammlungen mit Typ-IDs bearbeiten. </font><font style="vertical-align: inherit;">Jede Reihe von Keepern ist eine Art Karte für Eigenschaften des Objekts. </font><font style="vertical-align: inherit;">Wenn ein KeepersFactory-Objekt zerstört wird, wird der für die von ihm bereitgestellte Reihe von Keepern zugewiesene Speicher freigegeben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen und Verhalten</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situation</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verhalten</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie, ein Objekt zu serialisieren, dessen Typ nicht von QObject geerbt wurde</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilierungsfehler</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht deklarierter Typ beim Versuch der Serialisierung / Struturisierung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSException :: UnsupportedPropertyType-Ausnahme</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Versuch, ein Objekt mit einem anderen primitiven Typ als dem in den Sammlungen simple_t und array_of_simple_t beschriebenen zu serialisieren / strukturieren.</font></font></td>
<td> QSException::UnsupportedPropertyType.    ,     —     ,   </td>
</tr>
<tr>
<td> JSON/XML   </td>
<td>  </td>
</tr>
<tr>
<td>   propertyes,    JSON/XML</td>
<td> propertyes .       —  propertyes          </td>
</tr>
<tr>
<td>      JSON  property </td>
<td> QSException</td>
</tr>
</tbody></table></div><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach hat sich das Projekt gelohnt, da dieser Artikel geschrieben wurde. </font><font style="vertical-align: inherit;">Für mich kam ich zu dem Schluss, dass es keine universellen Lösungen gibt, man muss immer etwas opfern. </font><font style="vertical-align: inherit;">Durch die Entwicklung flexibler Funktionen in Bezug auf Nutzung und Funktionalität können Sie die Einfachheit zunichte machen und umgekehrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich fordere Sie nicht auf, QSerializer zu verwenden. Mein Ziel ist vielmehr meine eigene Entwicklung als Programmierer. </font><font style="vertical-align: inherit;">Natürlich verfolge ich auch das Ziel, jemandem zu helfen, aber in erster Linie - nur Freude zu haben. </font><font style="vertical-align: inherit;">Sei positiv)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496824/index.html">Ihr nordisches Arbeitsumfeld</a></li>
<li><a href="../de496826/index.html">Millionen Sprites mit mehr als 120 fps</a></li>
<li><a href="../de496828/index.html">Wo finde ich freiberufliche Mitarbeiter, die Spaß machen werden? (Spoiler: nicht Upwork)</a></li>
<li><a href="../de496830/index.html">Was ist Emergent Communication und warum müssen Sie es wissen?</a></li>
<li><a href="../de496832/index.html">Fototour: Was machen sie im Labor für hybride Nanophotonik und Optoelektronik des New Physics Institute ITMO?</a></li>
<li><a href="../de496838/index.html">Von Slack verwendete Projektbereitstellungsmethode</a></li>
<li><a href="../de496840/index.html">Musk glaubt, dass 12.000 Satelliten die Astronomen nicht stören werden. Seine Meinung stimmt nicht mit dem Modell überein</a></li>
<li><a href="../de496842/index.html">Ein einfaches Epidemiemodell mit grundlegenden Python-Tools</a></li>
<li><a href="../de496846/index.html">Sprachmechanik von Stapeln und Zeigern</a></li>
<li><a href="../de496848/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 340 (vom 6. bis 12. April)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>