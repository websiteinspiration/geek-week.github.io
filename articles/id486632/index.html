<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤼 ⏫ 🏖️ Model Pemrograman Reaktif Mental untuk Pengawas 👨🏿‍🔧 🏂🏾 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini ditujukan untuk banyak pembaca yang ingin mengetahui apa itu Pemrograman Reaktif. Tujuan artikel ini adalah untuk membentuk Model Mental D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Model Pemrograman Reaktif Mental untuk Pengawas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini ditujukan untuk banyak pembaca yang ingin mengetahui apa itu Pemrograman Reaktif. </font><font style="vertical-align: inherit;">Tujuan artikel ini adalah untuk membentuk Model Mental Dasar Pemrograman Reaktif (MM RP) Anda tanpa membahas perincian teknis.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penolakan</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi pertama-tama, mari kita jelaskan apa hubungan model mental dan atasan yang disebutkan dalam judul artikel tentang itu ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang Model Mental</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ini bosnya ...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Pemrograman Reaktif membutuhkan proyek Anda?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak orang yang tidak terbiasa dengan RP awalnya skeptis terhadapnya, mencurigai bahwa ini hanyalah mode kosong, yang ditutupi oleh beberapa kata yang indah. </font><font style="vertical-align: inherit;">Terutama ketika mereka mengetahui bahwa Anda dapat mengevaluasi RP hanya dengan mencobanya. </font><font style="vertical-align: inherit;">Dan untuk mencobanya itu mahal, karena ambang masuk yang tinggi. </font><font style="vertical-align: inherit;">Kami hidup dan hidup dengan OOP, apa yang hilang darinya? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Izinkan saya memperkenalkan sudut pandang saya tentang hal ini.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awal Pemrograman, ketika sebagian besar program ditulis langsung dalam bahasa assembly, konsep kerja utama (elemen dari Model Mental) programmer adalah instruksi, atau perintah bahasa. Beberapa data (primitif) diumpankan ke input perintah atau instruksi. Instruksi memproses dan mengeluarkan beberapa data output. Munculnya bahasa pemrograman prosedural pertama seperti Fortran tidak mengubah esensi masalah ini. Hanya data dan operasi yang dilakukan (sebagai urutan perintah dasar) menjadi lebih rumit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seiring waktu, menjadi jelas bahwa konsep ini tidak terlalu konsisten dengan kenyataan di dunia. Mungkin ada banyak data, mereka bisa sulit terstruktur. Baik data dan fungsionalitas di sekitar mereka akan bagus untuk dibagi menjadi beberapa bagian, untuk mengembangkan dan memelihara secara terpisah, dan digunakan bersama.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP memecahkan masalah ini dengan banyak cara. Unit Model Mental programmer OOP khas adalah objek dengan data yang disembunyikan (dienkapsulasi) di dalamnya dan antarmuka akses ke data ini sebagai satu set fungsi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP telah memainkan peran besar dalam otomatisasi dan komputerisasi banyak proses manufaktur dan lainnya. Dan seiring dengan ini, kelemahannya terungkap. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, dalam OOP tidak ada konsep proses seperti itu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka mencoba memperbaiki situasi dengan berbagai cara, berkonsentrasi pada berbagai aspek. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, Event-Driven Programming [3], Dataflow-programming [4], Stream processing [5] dan beberapa paradigma lain lahir. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan berani membangkitkan aliran kritik dari para penganut dan para ahli tentang paradigma ini, mencoba menyampaikan dengan kata-kata sederhana esensi umum mereka.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan satu atau lain cara, paradigma ini beroperasi dengan arus informasi. Pada saat yang sama, Event-Driven Programming, seperti namanya, berfokus pada proses kemunculan elemen-elemen aliran informasi, pemrograman Dataflow - pada kontrol aliran (pemisahan, penggabungan, transformasi aliran) dan pemrosesan aliran pada penggunaan sumber daya yang optimal saat memproses aliran.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemrograman Reaktif adalah tentang hal yang sama, tetapi dengan fokus pada operasi dasar tertentu untuk membuat, mengelola, dan menggunakan utas. Itu RP menjelaskan bagaimana sistem Anda bereaksi (Bahasa Inggris bereaksi) terhadap elemen-elemen dari arus informasi. Dalam pengertian ini, akan lebih benar dalam bahasa Rusia untuk menggunakan istilah "Pemrograman Reagen" (dari kata "bereaksi") atau "Pemrograman Reaksi" (dari kata "reaksi terhadap sesuatu") jika bukan untuk memotong telinga, dan yang kedua tidak menyebabkan asosiasi yang salah. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berani mengungkapkan pemikiran hasutan lain. Apa yang kita sebut hari ini dalam Bahasa Inggris Pemrograman Reaktif (Pemrograman Reaktif). disebut demikian karena alasan historis dan cenderung mendukung istilah ini sebagai opini mayoritas.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paradigma ini bisa disebut berbeda. </font><font style="vertical-align: inherit;">Karena itu, jangan fokus pada nama saat ini, tetapi cobalah untuk memahami esensinya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan meskipun saya akan berbicara tentang RP pada tingkat yang cukup abstrak, saya akan mengutip API perpustakaan RxJS sebagai contoh nyata. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Singkatan RxJS adalah singkatan dari Reactive Extension for JavaScript, ekstensi JavaScript untuk fitur-fitur Pemrograman Reaktif. </font><font style="vertical-align: inherit;">Ekstensi serupa ada untuk banyak bahasa pemrograman lain, seperti dapat dilihat pada gambar di bawah ini, yang diambil dari [6].</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Ekstensi pemrograman reaktif"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Model Mental RP membutuhkan proyek Anda</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek-proyek besar tidak dilakukan sendirian. Anda dapat sering membaca atau mendengar bahwa peserta proyek harus berbicara dalam bahasa yang sama. Pengalaman saya menunjukkan bahwa ini hampir tidak perlu dan mungkin. Tetapi yang diperlukan adalah agar konsep paling dasar dari proyek dinyatakan dan dipahami oleh peserta proyek dengan setepat mungkin. Dalam hal Model Mental (MM), kita dapat mengatakan bahwa MMs tingkat atas harus semirip mungkin. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bagaimana mereka bisa serupa jika analis berpikir dalam hal Alur Kerja dan Kasus Penggunaan, arsitek dalam pola, pengembang fungsi dan struktur data, dan penguji dalam skenario pengujian?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak mendesak semua spesialis ini untuk mulai berpikir pada saat yang sama dengan kategori-kategori Pemrograman Reaktif, tetapi saya dapat menjanjikan kepada mereka bahwa berkenalan dengan kategori-kategori ini akan menyederhanakan dan meningkatkan efektivitas komunikasi profesional mereka dengan kolega. </font><font style="vertical-align: inherit;">Ini harus terjadi karena, di satu sisi, RP MM memiliki kekuatan yang diperlukan untuk menggambarkan Alur kerja yang kompleks, dan di sisi lain, RP MM dapat langsung dikonversi ke kode dalam banyak bahasa pemrograman.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kejutan, bahaya, atau bahwa dalam RP bukan seperti yang biasa kita semua lakukan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sebelum kita masuk ke deskripsi tentang apa yang Mental Model Pemrograman Reaktif terdiri dari, berdasarkan pengalaman kita sendiri, saya ingin memperingatkan pembaca tentang apa yang tidak ada di dalamnya. </font><font style="vertical-align: inherit;">Selain itu, bukan hanya tidak, tetapi harapan perilaku OOP yang sederhana dan dapat dipahami di dunia menyebabkan konsekuensi yang menyedihkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya melakukan ini bukan untuk mengintimidasi, tetapi lebih untuk membangkitkan minat pembaca.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan 1: Alih-alih model kursor, grafik komputasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berani menyarankan bahwa banyak pembaca, ketika memikirkan tugas berikutnya untuk direalisasikan, memiliki model mental di kepala mereka, yang saya sebut model kursor. </font><font style="vertical-align: inherit;">Diasumsikan bahwa algoritma langkah-demi-langkah dalam bentuk daftar linier instruksi akan ditemukan untuk memecahkan masalah. </font><font style="vertical-align: inherit;">Eksekusi algoritma dikurangi menjadi eksekusi langkah-demi-langkah dari instruksi satu demi satu. </font><font style="vertical-align: inherit;">Anda dapat membayangkan sesuatu seperti pointer ke instruksi yang sedang dijalankan. </font><font style="vertical-align: inherit;">Setelah instruksi dieksekusi, pointer (kursor) bergerak ke instruksi berikutnya dalam daftar dan mulai dijalankan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam model ini, urutan perintah ditulis dalam bahasa pemrograman berorientasi objek bersyarat</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
akan memberikan hasilnya</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model mental kursor kami memprediksi dengan sempurna dan menjelaskan hasil seperti itu. </font><font style="vertical-align: inherit;">Setelah memproses baris ketiga, nilai X3 diatur dan nilai baru untuk X1 yang ditentukan pada baris 5 tidak dapat mengubahnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam dunia RP, tergantung pada interpretasi operasi "+", hasilnya kemungkinan besar adalah ini</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di dunia ini, sebagian besar operasi menghubungkan parameter input satu sama lain, dengan demikian membuat grafik komputasi yang melaluinya perhitungan "didorong" ketika satu atau lebih parameter diubah.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan 2: Operasi asinkron</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kerangka model mental kursor perhitungan, operasi selanjutnya tidak dapat dimulai lebih awal dari yang sebelumnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan contoh berikut. </font><font style="vertical-align: inherit;">Misalkan fungsi f1 menghitung gaji pokok berdasarkan nilai pengenal pengguna, userId, dan fungsi f2 menghitung bonus berdasarkan userId dan nilai gaji. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka perhitungan gaji penuh mungkin terlihat seperti ini</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan seorang anggota staf memiliki gaji pokok 10.000. </font><font style="vertical-align: inherit;">dan bonus 1000 unit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model mental kursor kami memberi tahu Anda apa yang harus dicetak.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, di dunia RP asinkron, hasilnya mungkin, tergantung pada durasi operasi, menjadi</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Saya belum mempertimbangkan pengecualian). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa di dunia asinkron-reaktif, operasi selanjutnya tidak menunggu akhir dari yang sebelumnya, jika itu adalah yang sebelumnya) asinkron. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggambarkan hal ini, mari kita lihat beberapa detail penting menggunakan contoh realistis yang ditunjukkan pada gambar di bawah ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar menunjukkan waktu eksekusi dari empat instruksi L1, L2, L3 dan L4 yang independen satu sama lain (angka-angka mereka penting bagi kami, bukan ejaan) dalam mode sinkron (bagian atas gambar) dan asinkron (bagian bawah gambar).</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang kita lihat, dalam kasus pertama, setiap instruksi selanjutnya "menunggu" untuk akhir dari instruksi sebelumnya. </font><font style="vertical-align: inherit;">Dalam kasus asinkron, semua instruksi mulai dijalankan secara bersamaan. </font><font style="vertical-align: inherit;">Karena eksekusi paralel dan penggunaan sumber daya, sebagian besar instruksi berjalan dalam mode asinkron lebih lama daripada dalam mode sinkron. </font><font style="vertical-align: inherit;">Namun, bersama-sama mereka akan mewariskan pekerjaan mereka sebelumnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Urutan penyelesaian instruksi di kedua mode juga sangat berbeda. </font><font style="vertical-align: inherit;">Secara sinkron:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tetapi dalam asinkron: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan 3: Rantai tidak lengkap (tanpa konsumen) tidak berfungsi sama sekali</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam banyak bahasa pemrograman tradisional, adalah umum untuk mengaitkan pemanggilan fungsi atau properti objek dengan titik-titik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, rantai panggilan fungsi JavaScript berikut mengubah kata "good" menjadi "dog":</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Urutan (rantai) bisa panjang. </font><font style="vertical-align: inherit;">Untuk alasan penggunaan kembali atau kenyamanan, mereka dapat dipotong-potong dan dilakukan sebagian. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memisahkan rantai dalam RP menjadi dua bagian dan memanggil hanya satu dari mereka biasanya menyebabkan kurangnya hasil, karena hanya rantai penuh (dengan konsumen pada akhirnya) yang dilakukan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa semua ini?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin, banyak pembaca yang telah mengajukan pertanyaan kepada diri mereka sendiri, “Apakah mereka tidak menjadi gila secara kolektif, para programmer yang reaktif ini? Mengapa itu diperlukan, pemrograman seperti itu? " </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak berasumsi untuk memprediksi apa yang akan dijawab oleh pencipta dan pakar Republik Polandia, tetapi jawaban saya adalah ini: pemrograman seperti itu diperlukan, karena banyak objek di dunia nyata yang berperilaku seperti itu. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik komputasi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - inilah yang menjadi dasar dibangunnya Excel, tidak hanya dari para akuntan, tetapi juga manajer proyek yang senang. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi asinkron</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saat Anda membuat kopi atau membuat teh di dapur, apakah Anda berdiri di dapur selama ini dan melihat teko atau teko kopi Anda? Tidak. Perangkat mendidihkan air dan melakukan tugasnya, saat Anda melakukan sesuatu yang lain untuk saat ini. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantai operasi lengkap.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coba cabut lampu meja Anda dari stopkontak dan dorong saklar. </font><font style="vertical-align: inherit;">Lampu tidak menyala karena ini. </font><font style="vertical-align: inherit;">Objek ini hanya berfungsi jika ada rantai yang lengkap - dari sumber ke konsumen listrik. </font><font style="vertical-align: inherit;">Dan ada banyak, jika tidak sebagian besar, benda-benda seperti itu di dunia nyata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin meyakinkan Anda, pengetahuan Anda tentang pemrograman tradisional dan kursor MM tidak boleh dibuang ke tempat sampah karena kemunculan RP. </font><font style="vertical-align: inherit;">Pemrograman reaktif meninggalkan mereka sendiri dan memperluasnya dengan operasi baru pada objek jenis baru. </font><font style="vertical-align: inherit;">Bagaimana - kita akan membicarakannya nanti.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruang Pemrograman Model Mental dan tempat MM RP di dalamnya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berbicara tentang tempat RP dalam lanskap umum Pemrograman, penulis sering menyebutkan dua dimensi - kompleksitas objek yang diproses dan sinkronisasi / operasi sinkronisasi. </font><font style="vertical-align: inherit;">Contoh klasifikasi seperti itu dapat ditemukan dalam buku "RxJS in Action" [7], dalam bab "Kapan dan di mana harus menggunakan RxJS". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam klasifikasi ini, dimensi objek dibagi menjadi objek tunggal dan multi-objek: array, daftar, dll. </font><font style="vertical-align: inherit;">Operasi dibagi menjadi sinkron dan asinkron. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, klasifikasi ini membagi dunia pemrograman menjadi empat bidang. </font><font style="vertical-align: inherit;">RP adalah salah satu area ini yang bertanggung jawab untuk memproses multi-objek dengan operasi asinkron. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menemukan klasifikasi ini sangat menarik, tetapi saya ingin melihatnya dari sudut pandang model mental. </font><font style="vertical-align: inherit;">Tabel di bawah ini menyajikannya.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai dan Objek tunggal</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berasumsi bahwa model mental instruksi dan kursor tidak memerlukan penjelasan lebih lanjut. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siklus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah perpanjangan dari instruksi MM dan kursor karena instruksi tambahan dari siklus atau kembali ke beberapa titik. Ini memungkinkan satu set instruksi pemrosesan untuk satu objek untuk "membungkus" dalam satu lingkaran, dan dengan demikian memproses banyak objek seperti itu. Dalam hal ini, kursor bergerak di dalam siklus seperti pada model sebelumnya, dan setelah mencapai titik transisi, ia akan melompat ke awal atau pemrosesan siklus berhenti jika semua objek diproses. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbedaan antara model mental ini dan yang sebelumnya adalah bahwa kursor yang </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
menunjuk ke objek yang diproses tetap di tempatnya, dan objek itu sendiri "melindasnya".</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat ini dengan dua contoh. Jika Anda melukis pagar kayu, Anda, dengan analogi dengan model kursor, pergi dari papan ke papan. Tetapi pekerja pada konveyor tetap di tempat dan, dengan analogi dengan model jet, bagian-bagian yang akan diproses sendiri mendekatinya. Objek seperti itu sering disebut dengan istilah Stream Bahasa Inggris, misalnya, dalam bahasa Jawa. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiang sinyal.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MM ini paling mudah dikaitkan dengan lampu lalu lintas di persimpangan. Objek asinkron secara berkala melakukan polling status variabel publik dan melakukan tindakan tertentu setelah mengubah kondisinya. (Seperti pengemudi di depan lampu lalu lintas) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menunggu.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metafora yang cocok untuk Model Ekspektasi Mental ini adalah huruf di atas kertas atau Emall yang Anda harapkan saat terakhir kali mendapatkan pekerjaan Anda. Mungkin ada jawaban positif atau negatif. Perilaku Anda setelah menerima surat sangat tergantung pada isinya. Istilah Bahasa Inggris Janji sering digunakan untuk menggambarkan benda-benda semacam ini. Bahwa, dari sudut pandang pengguna adalah harapan, bagi kontraktor yang menyediakan layanan, itu adalah janji. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang kita lihat dari deskripsi, gerakan sepanjang setiap dimensi (dari atas ke bawah atau dari kanan ke kiri dalam tabel) berarti perubahan kualitatif dalam Model Mental.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti dapat dilihat dari tabel, jet dan harapan adalah tetangga di sebelah kiri dan di atas sel tenggara yang menarik bagi kita. </font><font style="vertical-align: inherit;">Apa yang baru dalam Model Mental Arus yang menghuni sel yang menarik bagi kita dibandingkan dengan mereka?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa ekstensi itu?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perluasan Streaming dibandingkan dengan Harapan adalah bahwa informasi yang diharapkan dapat tiba tidak hanya sekali, tetapi dalam banyak bagian. Dalam hal ini, proses dapat berakhir tanpa berakhir. Itu setelah serangkaian porsi sukses, kami akan menerima pemberitahuan kesalahan. Selain itu, versi lain dari informasi ditambahkan - pemberitahuan akhir proses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti, misalnya, adalah mungkin untuk menerima beberapa (tetapi tidak semua) bagian dari informasi yang diharapkan dan (tanpa pesan kesalahan) pesan tentang akhir pemrosesan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingat lagi, dengan Menunggu, kami hanya memiliki dua opsi alternatif untuk informasi yang dihasilkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model Jet Mental sangat cocok untuk memahami, mendiskusikan, dan mengimplementasikan proses mengubah urutan objek dari jenis yang sama. MM Stream memperluasnya dengan aspek-aspek berikut:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ada banyak jet dan kita bisa menggabungkannya</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet-jet itu mungkin heterogen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat membagi jet menjadi yang baru sesuai dengan kriteria yang berbeda</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat "menutup" dan / atau mengubahnya menjadi yang baru dalam kerangka satu aliran. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami menentukan tempat MM RP (Streaming) di ruang atau lansekap objek Pemrograman. </font><font style="vertical-align: inherit;">Sekarang mari kita turunkan pandangan mata burung dan melihat lebih dekat pada Streams dan Model Mental mereka.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aliran dan fase dari siklus hidup mereka</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai perkiraan pertama, aliran RP dapat dibayangkan sebagai aliran air di pipa air atau aliran listrik. </font><font style="vertical-align: inherit;">Harus diingat bahwa seperti analogi lainnya, analogi ini memiliki keterbatasan dan tidak selalu dapat diterapkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berbicara tentang aliran, aspek-aspek penting berikut dapat dibedakan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap utas entah bagaimana muncul</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia entah bagaimana bergerak menuju konsumen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sesuatu terjadi dalam perjalanan dengannya (dia bertransformasi)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu dapat dibagi menjadi beberapa aliran atau digabung dengan aliran lain</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsumen entah bagaimana menggunakan arus, tidak ada lagi.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aspek-aspek yang tercantum secara bersamaan adalah fase dari siklus hidup elemen individu dari aliran. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita pertimbangkan mereka secara lebih rinci menggunakan contoh fungsi RxJS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan utas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streaming dapat dibuat dari elemen pasif seperti array atau daftar objek dalam program Anda, byte, baris file, dll. Sumber aliran semacam ini disebut dingin (walaupun secara teknis ada definisi sumber aliran dingin yang lebih akurat). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mata air panas yang disebut "menjalani kehidupan mereka sendiri" dan jika Anda tidak terhubung ke mereka pada waktunya, informasi akan hilang. Kategori ini mencakup informasi tentang tindakan pengguna pada komputer, tablet, smartphone, misalnya, informasi tentang penekanan tombol, gerakan mouse, atau menyentuh layar. Juga dalam kategori ini adalah data yang diminta oleh berbagai protokol seperti HTTP, data dari berbagai sensor.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu dicatat bahwa ada yang disebut mata air "hangat". </font><font style="vertical-align: inherit;">Selain itu, beberapa mata air "panas" dapat "didinginkan", dan "dingin" dapat "dihangatkan". </font><font style="vertical-align: inherit;">Tetapi Anda harus membaca tentang ini dalam literatur khusus, misalnya, dalam buku [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting bagi kita untuk mengetahui bahwa semua operasi menciptakan aliran membuat objek dengan tipe yang sama, yang dapat diproses lebih lanjut oleh operasi yang sama, terlepas dari konten. </font><font style="vertical-align: inherit;">Dalam artikel ini, kami menyebut objek ini aliran. </font><font style="vertical-align: inherit;">Nama bahasa Inggris yang sesuai adalah Observable.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerakan konsumen dan transformasi aliran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operasi transformasi aliran dapat dilakukan baik dalam perjalanan ke konsumen dan sendiri. </font><font style="vertical-align: inherit;">Dalam kedua kasus, operasi pemrosesan elemen aliran secara ketat berurutan, yaitu </font><font style="vertical-align: inherit;">operasi berikutnya diluncurkan secara ketat hanya setelah yang sebelumnya selesai dan melewati hasilnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak seperti Stream, yang dalam beberapa bahasa pemrograman merupakan konstruksi bahasa dengan sintaks dan semantik mereka sendiri, ekstensi reaktif seperti RxJS dalam JavaScript dipaksa untuk menggunakan sintaks dan semantik dasar bahasa yang dapat dikembangkan. </font><font style="vertical-align: inherit;">Oleh karena itu, RxJ mengimplementasikan fungsi pipe (), di dalamnya Anda dapat menempatkan panggilan ke fungsi - pengendali aliran itu sendiri dan elemen individualnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dicatat bahwa hanya fungsi-fungsi khusus, dapat dipipihkan, yang dapat menjadi penangan aliran.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aliran tiga fase"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita melanjutkan analogi dengan listrik, maka aliran yang kita pertimbangkan dapat disebut tiga fase. Bersamaan dengan "kawat normal" yang mengirimkan informasi dasar, ada juga "kawat kesalahan" dan "kawat terminasi aliran". Operasi transformasi memungkinkan tidak hanya mengubah objek, tetapi juga mengarahkannya ke "kawat" lain. Teknik ini digunakan, misalnya, ketika memproses dugaan kesalahan dalam bekerja dengan server menggunakan protokol HTTP. Misalnya, jika satu server tidak merespons, Anda dapat mencoba meminta yang lain tanpa memberi tahu pengguna tentang kegagalan untuk meminta server pertama.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah elemen lain yang sangat penting dari Model Aliran Mental Anda. </font><font style="vertical-align: inherit;">Jika dalam paradigma pemrograman tradisional kesalahan dikembalikan dari fungsi pemrosesan sebagai kode kesalahan atau harus dicegat sebagai gangguan (pengecualian), maka dalam arus kesalahan "mengalir" tidak tergantung pada saluran utama. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sana itu bisa diproses. </font><font style="vertical-align: inherit;">Misalnya, jika pengguna memasukkan kata sandi yang salah, mereka mungkin diberi kesempatan tambahan untuk mencoba memasukkannya satu kali atau lebih.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memisahkan dan menggabungkan aliran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemisahan arus dilakukan dalam dua tahap. Pada tahap pertama, utas kosong dimulai. Kemudian, pada tahap kedua (tahap pemrosesan aliran), di salah satu fungsi pemrosesan, elemen akan dianalisis dan dialihkan ke aliran yang diinginkan. Secara teknis, ada banyak opsi untuk melakukan hal ini. Misalnya, menghapusnya dari utas saat ini atau mengkloningnya sebelum memulai dengan utas baru. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat menggabungkan beberapa aliran menjadi satu dalam banyak cara yang mengejutkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara paling sederhana yang muncul dalam pikiran adalah menggabungkan mereka dalam urutan penerimaan, atau pertama-tama semua dari aliran pertama dan kemudian semua dari yang kedua.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode yang ditunjukkan di bawah ini dalam gambar memungkinkan satu dari dua aliran untuk membentuk satu berisi pasangan objek yang diurutkan dari aliran pertama dan kedua. </font><font style="vertical-align: inherit;">Dalam hal ini, pasangan baru terbentuk jika elemen baru muncul di salah satu aliran. </font><font style="vertical-align: inherit;">A berisi sepasang elemen terakhir dari setiap aliran. </font><font style="vertical-align: inherit;">Ini mengarah pada fakta bahwa elemen yang sama dapat dimasukkan dalam beberapa pasangan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notasi grafis yang digunakan dalam contoh ini disebut diagram Marmer dan sangat efektif dalam menjelaskan semantik dari aliran yang memisahkan dan menggabungkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika topik ini menarik minat Anda, saya sarankan Anda untuk mempelajari operasi dan diagram Marmernya pada sumber daya [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan stream</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggunakan elemen aliran, pengguna atau klien harus berlangganan terlebih dahulu. Sebagai aturan, pada akhir pemrosesan, ia harus berhenti berlangganan, karena pemulung tidak selalu secara otomatis menonaktifkan langganan ketika mereka mencoba memanfaatkan pelanggan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak klien dapat berlangganan ke satu utas. Dalam RxJs, fungsi berlangganan disebut berlangganan (). Di dalamnya, dalam kebanyakan kasus, disarankan untuk menempatkan panggilan pemrosesan elemen "normal" stream, penangan kesalahan dan (relatif jarang) penangan pemutusan aliran.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap pelanggan pada aliran menerima salinan elemen atau klon dari elemen asli. </font><font style="vertical-align: inherit;">Agar tidak menimbulkan masalah, aliran diimplementasikan sedemikian rupa sehingga elemen yang diterima untuk diproses menjadi tidak berubah. </font><font style="vertical-align: inherit;">Dalam beberapa situasi, batasan ini masih bisa dielakkan, tetapi lebih baik tidak dilakukan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesona aliran sungai yang berbahaya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streaming adalah objek yang sangat rumit, agak mirip dengan integral dalam matematika. Adalah satu hal untuk mengetahui bahwa mereka ada dan bahkan secara kasar membayangkan apa itu, dan benar-benar lain untuk dapat menggunakannya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memahami logika internal fungsi mereka, perlu untuk menerapkannya dengan baik dalam praktik, membutuhkan upaya intelektual yang cukup besar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streaming secara intrinsik berkaitan erat dengan pemrograman fungsional. Untuk penggunaan aliran yang kompeten, penting untuk memahami bagaimana membangun dan menerapkan fungsi urutan kedua - fungsi yang fungsi lainnya berfungsi sebagai argumen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka keindahan dan keanggunan aliran akan sepenuhnya terungkap kepada Anda. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streaming menular. Setelah memahami kecantikan mereka, saya ingin menggunakannya dalam semua tugas, yang tentu saja tidak perlu.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam tugas apa yang disarankan untuk menggunakan aliran, dan di mana metode tradisional harus digunakan, semua orang memutuskan untuk dirinya sendiri.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meringkaskan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel ini saya mencoba untuk memberi tahu Anda tentang Model Mental Pemrograman Reaktif (MM RP) dan bahkan sebagian meletakkannya dalam Kesadaran Anda. </font><font style="vertical-align: inherit;">Mari kita ulangi poin utama lagi.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RP khusus, tidak mirip dengan Model Mental Pemrograman tradisional. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika memulai Pemrograman Reaktif, kita harus ingat bahwa beberapa mapan di bidang MM lainnya seperti kursor, rantai panggilan atau loop tidak berfungsi, atau mereka tidak bekerja seperti itu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model Mental utama RP adalah aliran "tiga saluran" dengan saluran untuk elemen "normal", kesalahan, dan informasi tentang akhir aliran.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streaming dapat terbatas dan tidak terbatas.</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tertarik dengan topik ini, Anda bisa "bermain" dengan stream menggunakan simulator yang tersedia di situs [8]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda ingin lebih memahami konsep-konsep RP, saya sarankan Anda bekerja melalui buku [7], dan tentu saja, berkenalan dengan The Reactive Manifesto [11]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda akan mencapai level berikutnya dalam pembentukan MM RP Anda sendiri dengan mengerjakan buku [9] dan [10] pada desain dan pemodelan sistem reaktif.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sastra dan referensi</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrograman adalah perwujudan gagasan. </font><font style="vertical-align: inherit;">(Artikel tentang Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: Reifikasi sebagai Paradigma Rekayasa Perangkat Lunak. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrograman berbasis acara. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486614/index.html">Mengapa eSIM dibutuhkan Cara kerjanya dan mengapa mereka banyak bicara tentang itu</a></li>
<li><a href="../id486622/index.html">Model komputasi paralel</a></li>
<li><a href="../id486626/index.html">Svelte: mengenal Tindakan</a></li>
<li><a href="../id486628/index.html">Memperbaiki jarak antara kutu pada sumbu di gnuplot</a></li>
<li><a href="../id486630/index.html">"Jangan berkedip di mata": bagaimana teknologi pencahayaan layar pembaca elektronik diatur</a></li>
<li><a href="../id486634/index.html">Pembaruan MSVC Backend di Visual Studio 2019 versi 16.3 dan 16.4</a></li>
<li><a href="../id486638/index.html">Blazor WebAssembly 3.2.0 Preview 1 sekarang tersedia</a></li>
<li><a href="../id486640/index.html">Intisari materi menarik untuk pengembang seluler # 331 (27 Januari - 2 Februari)</a></li>
<li><a href="../id486644/index.html">Antena DIY dalam 5 menit</a></li>
<li><a href="../id486646/index.html">Pergi dari jQuery ke Svelte, tanpa rasa sakit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>