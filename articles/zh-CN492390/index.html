<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛴️ ⚽️ 👩‍🏫 刹车上的战争。在React Native中优化组件渲染的数量 ⛪️ 💵 🙎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！我叫Kamo Spertsyan，我在Profi.ru从事React Native开发。如果您决定使用React Native技术快速交付产品功能并专注于开发速度，那么您很可能会遇到性能问题。至少那是我们发生的事情。经过六个月的积极开发，我们的应用程序性能降到了关键水平以下-一切都非常缓慢。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>刹车上的战争。在React Native中优化组件渲染的数量</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492390/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！我叫Kamo Spertsyan，我在Profi.ru从事React Native开发。如果您决定</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用React Native技术</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速交付产品功能并专注于开发速度，那么您很可能会遇到性能问题。至少那是我们发生的事情。经过六个月的积极开发，我们的应用程序性能降到了关键水平以下-一切都非常缓慢。因此，我们进行了优化-删除了启动过程中的所有“刹车”，屏幕之间的过渡，渲染屏幕以及对用户操作的反应。结果，他们在三个月内将用户体验提升到了原生水平。在本文中，我想谈谈我们如何在React Native上优化应用程序并解决多组件渲染的问题。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/qy/9b/tvqy9bo_jyqc4cz044_gneepvmw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我汇总了一些建议，这些建议将有助于最大程度地减少无意义的组​​件重绘次数。</font><font style="vertical-align: inherit;">为了清楚起见，在示例中，我比较了“不良”和“良好”的实现。</font><font style="vertical-align: inherit;">本文对于那些已经面临糟糕的应用程序性能的人以及不想在将来允许这样做的人很有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用与Redux配对的React Native。</font><font style="vertical-align: inherit;">一些技巧与此库有关。</font><font style="vertical-align: inherit;">同样在该示例中，我使用Redux-thunk库-模拟网络工作。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么时候考虑性能？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，从应用程序的工作开始就值得记住。但是，如果您的应用程序已经变慢了-不要失望，一切都可以修复。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大家都知道，但以防万一，我要提一下：最好检查弱设备上的性能。如果您正在使用功能强大的设备进行开发，则可能不会意识到最终用户的“过失”。自己决定将要使用的设备。</font><font style="vertical-align: inherit;">在控制图中</font><font style="vertical-align: inherit;">测量时间或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以与优化后的结果进行比较。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开箱即用的React Native提供了通过开发人员工具→显示性能监视器来测量FPS应用程序的能力。</font><font style="vertical-align: inherit;">参考值为每秒60帧。</font><font style="vertical-align: inherit;">该指标越低，应用程序“放慢速度”的作用就越强-对用户操作无响应或延迟。</font><font style="vertical-align: inherit;">对FPS的主要影响之一是渲染的数量，其“严重性”取决于组件的复杂性。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">范例说明</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将在一个带有新闻列表的简单应用程序示例中显示所有建议。</font><font style="vertical-align: inherit;">该应用程序有一个屏幕，该屏幕位于</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新闻中。</font><font style="vertical-align: inherit;">新闻是一个</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由两个较小的组成部分组成的组成部分-标题（</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和正文（</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">整个示例可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在本文的进一步内容中，有指向特定示例的存储库各个分支的链接。</font><font style="vertical-align: inherit;">该存储库用于方便希望更深入地研究示例的读者。</font><font style="vertical-align: inherit;">下面的存储库和示例中的代码并不声称是完美的-仅出于演示目的而需要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面，用链接和道具示意性地显示了所有组件。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/ng/z6/d9ngz6hldmphbkjky1a-7-38nlq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在每个组件的render方法中，我将输出添加到有关它的唯一信息的控制台中： </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_{no}<font></font>
ITEM_TITLE_{no}<font></font>
ITEM_BODY_{no}</code></pre><br><font style="vertical-align: inherit;"></font><code>{no}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新闻序列号在</font><font style="vertical-align: inherit;">
哪里</font><font style="vertical-align: inherit;">，以便区分同一新闻稿的多个新闻稿中的不同新闻稿。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了在每个</font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新闻列表</font><font style="vertical-align: inherit;">上进行测试</font><font style="vertical-align: inherit;">，将其他新闻添加到其开头。</font><font style="vertical-align: inherit;">同时，控制台中显示以下消息：</font></font><br>
<br>
<pre><code class="plaintext hljs">--------------[ REFRESHING ]--------------</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些记录将有助于了解任何特定组件是否存在问题，并在以后确定是否有可能对其进行优化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果实施正确，则启动后的日志和若干更新应如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_4<font></font>
ITEM_TITLE_4<font></font>
ITEM_BODY_4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一次开始时，将绘制屏幕本身和两个初始新闻。</font><font style="vertical-align: inherit;">更新面板时，由于其数据确实发生了更改，因此再次渲染了屏幕。</font><font style="vertical-align: inherit;">更多消息来了。</font><font style="vertical-align: inherit;">以前的所有新闻都不会重绘，因为它们的数据没有变化。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何时渲染组件？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在React和React Native中，有两个条件可以渲染组件：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改变他的道具/状态，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">父组件的呈现。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以在组件中重新定义函数</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-它接收新的Props和State作为输入，并告知是否应渲染组件。通常，为了避免不必要的重新渲染，</font><font style="vertical-align: inherit;">对Props和State对象</font><font style="vertical-align: inherit;">进行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浅层比较</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就足够了。例如，如果父组件更改不影响子组件，则这样做可以消除不必要的渲染。为了不每次都手动编写表面比较，可以从</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">封装此检查</font><font style="vertical-align: inherit;">的组件继承一个组件</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们使用connect link函数时，Redux库会创建一个“连接”到全局State的新组件。更改此状态会触发方法</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回新的道具。</font><font style="vertical-align: inherit;">接下来，开始比较旧道具和新道具，而不管组件是否被声明为</font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的示例中考虑这些细微差别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让</font><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">通过传球</font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继承</font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-从</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的示例代码</font></font></a><br>
<br>
<pre><code class="plaintext hljs">export class NewsItemTitle extends React.Component<font></font>
export class NewsItemBody extends React.PureComponent</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是更新一块板后的日志内容：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以看到新闻和标题组件已重绘。</font><font style="vertical-align: inherit;">我们将依次考虑它们。</font></font><br>
<br>
<code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用声明</font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">作为道具，此组件将接收一个标识符，随后它将通过该标识符接收以下消息</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({<font></font>
  item: state.newsMap[ownProps.itemKey],<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于更新板时，所有新闻都将再次下载，因此该对象将</font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新，然后将引用各种存储单元。换句话说，即使所有包含的字段都相同，它们也将是不同的对象。因此，比较了以前和新的State'ov组件return </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。尽管事实上数据并没有改变，但是该组件将被重新渲染。</font></font><br>
<br>
<code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是从继承的</font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此每次渲染父组件时都会重新渲染。无论新旧道具的价值如何，都会发生这种情况。</font></font><br>
<br>
<code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继承自</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此它会比较新旧道具。在新闻1和2中，它们的值是相等的，因此仅针对新闻3渲染组件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要优化渲染</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只需将其声明为即可</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，您必须</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新定义函数</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return !shallowEqual(this.props.item, nextProps.item);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的示例代码</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这</font></font><code>shallowEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Redux提供的对象的表面比较功能。</font><font style="vertical-align: inherit;">您可以这样写：</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return (<font></font>
    this.props.item.title !== nextProps.item.title ||<font></font>
    this.props.item.body !== nextProps.item.body<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我们的日志在此之后的样子： </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><div class="spoiler_text"> <code>shouldComponentUpdate</code>  <code>NewsItem</code> ,  <code>NewsItemTitle</code>   .        . <code>NewsItemTitle</code>    -         <code>NewsItem</code>,     .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo和功能组件</font></font></h2><br><font style="vertical-align: inherit;"></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法</font><font style="vertical-align: inherit;">
覆盖</font><font style="vertical-align: inherit;">功能组件。</font><font style="vertical-align: inherit;">但这并不意味着为了优化功能组件，您必须将其重写为一个类。</font><font style="vertical-align: inherit;">对于这种情况，提供了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆功能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它接受组件输入和可选的比较功能</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">调用时，它将</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得新旧道具，并应返回比较结果。</font><font style="vertical-align: inherit;">其区别</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是什么</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该返回</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果道具都是平等的，而不是相反。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">备忘录可能看起来像这样：</font></font><br>
<br>
<pre><code class="plaintext hljs">areEqual(prevProps, nextProps) {<font></font>
  return shallowEqual(prevProps, nextProps);<font></font>
}<font></font>
export OptimizedNewsItemTitle = React.memo(NewsItemTitle, areEqual)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果你不及格</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>React.memo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后道具肤浅的比较将进行，所以我们的例子可以简化为：</font></font><br>
<br>
<pre><code class="plaintext hljs">export OptimizedNewsItemTitle = React.memo(NewsItemTitle)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道具中的Lambda函数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要处理组件事件，可以将函数传递给其道具。</font><font style="vertical-align: inherit;">最醒目的例子是实现</font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常，匿名lambda函数用于此目的。</font><font style="vertical-align: inherit;">假设</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们只想显示预览，如果单击它，则显示整个文本。</font><font style="vertical-align: inherit;">为此，在渲染</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时，</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将传递以下属性：</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={() =&gt; this.props.expandBody()}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面是该日志看起来像当这个方法执行</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新闻机构1和2渲染，虽然他们的数据并没有改变，不过</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是由于以下事实：对于每个渲染</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，道具</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">价值</font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都会重新创建。</font><font style="vertical-align: inherit;">从技术上讲，</font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次渲染时，它都指向内存中的一个新区域，因此表面上的道具比较</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回false。</font><font style="vertical-align: inherit;">通过以下条目解决此问题：</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={this.props.expandBody}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
日志： </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的示例代码</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
不幸的是，匿名函数绝不能始终作为此类记录的方法或类字段重写。最常见的情况是在lambda函数内部使用声明了该函数的函数的范围变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的示例中考虑这种情况。为了从一般列表切换到一个新闻的屏幕，我们添加了单击新闻正文的处理。</font></font><code>renderItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">方法</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={() =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
匿名函数</font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能在类中声明，因为</font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转到特定新闻所需</font><font style="vertical-align: inherit;">的变量将从范围中消失</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决该问题的最简单方法是更改</font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">属性的签名，</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便在调用时将所需的参数传递给函数。</font><font style="vertical-align: inherit;">在这种情况下，这是新闻标识符。</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={item =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我们已经可以在组件类方法中删除匿名函数。</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={this.onItemBodyPress}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，这样的解决方案将需要我们更改组件</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">class NewsItemComponent extends React.Component {<font></font>
render() {<font></font>
  ...<font></font>
  return (<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={() =&gt; this.props.onBodyPress(this.props.item)}<font></font>
        ...<font></font>
      /&gt;<font></font>
      ...<font></font>
  );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次，我们回到指示的问题-对于父级的每个渲染，我们将一个新的lambda函数传递给子级组件。</font><font style="vertical-align: inherit;">直到现在我们才降到一个水平。</font><font style="vertical-align: inherit;">日志：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要从根本上消除此问题，可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useCallback</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挂钩</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它允许通过传递参数来记忆函数调用。</font><font style="vertical-align: inherit;">如果函数的参数不变，则调用结果</font></font><code>useCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将指向相同的内存区域。</font><font style="vertical-align: inherit;">在我们的示例中，这意味着在重绘相同新闻时，prop </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会更改。</font><font style="vertical-align: inherit;">挂钩只能在功能组件中使用，因此该组件的最终外观</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下：</font></font><br>
<br>
<pre><code class="plaintext hljs">function NewsItemComponent(props) {<font></font>
  ...<font></font>
  const {itemKey, onBodyPress} = props.item;<font></font>
  const onPressBody = useCallback(() =&gt; onBodyPress(itemKey), [itemKey, onBodyPress]);<font></font>
  return (<font></font>
    &lt;View&gt;<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={onPressBody}<font></font>
        ...<font></font>
      /&gt;<font></font>
    &lt;/View&gt;<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和日志： </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的示例代码</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组和对象</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在JavaScript中，函数与数组一起表示为对象。</font><font style="vertical-align: inherit;">因此，上一个块中的示例是在props中创建新对象的特例。</font><font style="vertical-align: inherit;">这很普遍，因此我将其放在单独的段落中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在props中创建任何新函数，数组或对象都会导致组件重新渲染。</font><font style="vertical-align: inherit;">在以下示例中考虑此规则。</font><font style="vertical-align: inherit;">让我们传递</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个值</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">组合样式：</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  style={[styles.body, styles.item]}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次，日志显示了额外的组件渲染器：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要解决此问题，您可以选择将</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">组合在一起的单独样式</font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，或者例如将数组的声明移动</font></font><code>[styles.body, styles.item]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到全局变量中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的示例代码</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵列减速器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑另一个与使用相关的“刹车”的流行来源</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一个经典的应用程序包含一长串来自服务器的项目，可以实现分页。</font><font style="vertical-align: inherit;">也就是说，它以第一页的形式加载一组有限的元素，当当前元素列表结束时，它加载下一页，依此类推。</font><font style="vertical-align: inherit;">项目列表缩减器可能如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当每个下一页以应用程序的样式加载时，将创建一个新的标识符数组。</font><font style="vertical-align: inherit;">如果我们稍后将此数组传递给props </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则组件渲染日志将如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于此示例，我在测试应用程序中进行了一些更改。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将页面大小设置为10条新闻。</font></font></li>
<li>   <code>item</code>   <code>NewsItem</code>  <code>FlatList</code>-,        connect. <code>NewsItem</code>    <code>React.Component</code>    .</li>
<li>     .</li>
<li>       .       №1     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该示例显示，当每个下一页加载时，将再次呈现所有旧元素，然后再次呈现旧元素和新页面的元素。对于数学爱好者：如果页面大小相等</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则在加载</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第ith页</font><font style="vertical-align: inherit;">时，</font><font style="vertical-align: inherit;">将呈现</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素，</font><font style="vertical-align: inherit;">而不是仅呈现</font><font style="vertical-align: inherit;">新元素</font></font><code>(i - 1) * X + i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
``好吧，''您说，``我理解了为什么在添加新页面后绘制所有元素的原因：reduce返回了一个新数组，一个新的内存区域以及所有这些内容。但是为什么我们需要在添加新元素之前呈现旧列表？” “好问题，”我会回答你。这是</font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其基础上</font><font style="vertical-align: inherit;">使用组件状态的结果</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我不会详细介绍它们，因为它们涉及另一篇文章。</font><font style="vertical-align: inherit;">谁在乎，我建议您深入研究</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和来源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何摆脱这种非最优性？</font><font style="vertical-align: inherit;">我们重写了reducer，以便他不为每个页面返回一个新数组，而是向现有页面添加元素：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意！</font><font style="vertical-align: inherit;">反模式！</font></font></b><div class="spoiler_text">          .     ,    , ,  <code>PureComponent</code>,          .      ,             .      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> Redux</a>.<br>
</div></div><br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    action.news.forEach(item =&gt; state.push(item.key));<font></font>
    return state;<font></font>
    // return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，我们的日志将如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将元素添加到新页面</font><b><font style="vertical-align: inherit;">之前，</font></b><font style="vertical-align: inherit;"> 
我们摆脱了旧元素的呈现</font><font style="vertical-align: inherit;">，但是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新列表</font><b><font style="vertical-align: inherit;">之后</font></b><font style="vertical-align: inherit;">仍会绘制旧元素</font><font style="vertical-align: inherit;">。现在，下一页的渲染数量相等</font></font><code>i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。公式变得更简单了，但我们不会止步于此。我们只有</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新元素，我们只想要</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新渲染。我们将使用已经熟悉的技巧来删除未更改道具的新闻呈现器。返回连接到</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;11..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;21..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细！现在我们可以对自己感到满意了。无处可优化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的示例代码</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
细心的读者将指出，</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论您如何实现reducer </font><font style="vertical-align: inherit;">，在将连接应用到</font><font style="vertical-align: inherit;">日志后，其外观都将与上一个示例相同。这是正确的-如果新闻组件在渲染之前检查其道具，那么缩减器使用旧数组还是创建新数组就没有关系。仅绘制新元素，并且仅绘制一次。但是，更改旧数组而不是创建新数组可以使我们免于</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用其中</font><font style="vertical-align: inherit;">的组件的不必要渲染</font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及道具等效性检查的不必要迭代</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。使用大量元素，这也可以提高性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在化简器中使用可变数组和对象时应格外小心。</font><font style="vertical-align: inherit;">在此示例中，这是有道理的，但是如果您有normal的话</font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么当您将元素添加到可变数组时，组件将不会呈现。</font><font style="vertical-align: inherit;">实际上，它的属性保持不变，因为更新数组之前和之后将其指向相同的存储区域。</font><font style="vertical-align: inherit;">这可能会导致意外的后果。</font><font style="vertical-align: inherit;">难怪所描述的示例违反了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">原理</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有其他</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您使用表示级别的库，建议您确保您详细了解它们的实现方式。</font><font style="vertical-align: inherit;">在我们的应用程序中，我们使用</font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库中</font><font style="vertical-align: inherit;">的组件</font></font><code>react-native-gesture-handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当您从列表中刷卡时，它允许您执行一系列附加操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在代码中，它看起来像这样：</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;Swipeable<font></font>
  ...<font></font>
  renderRightActions={this.renderRightActions}<font></font>
  ...<font></font>
&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方法</font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>renderLeftActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回在轻扫后显示的组件。我们在更换组件期间确定并更改了面板的高度，以适应必要的内容。这是一个资源密集的过程，但是如果它在滑动动画期间发生，则用户不会看到干扰。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/n1/vg/wzn1vghiy6-wjclqcy8itdy1fns.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题在于，组件</font><font style="vertical-align: inherit;">在渲染主组件时会</font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用该方法</font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。滑动之前不可见的所有计算，甚至是动作栏的渲染都预先发生。因此，将对列表中的所有卡同时执行所有这些操作。滚动面板时，这会引起严重的“刹车”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该问题已通过以下方式解决。如果操作面板是与主要组件一起绘制的，而不是由于滑动而绘制的，则该方法</font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回一个</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与主要组件大小相同的</font><font style="vertical-align: inherit;">空白</font><font style="vertical-align: inherit;">。否则，我们将像以前一样绘制其他动作面板。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我给出这个例子是因为支持库并非总是如您所愿。</font><font style="vertical-align: inherit;">而且，如果这些是表示级别的库，那么最好确保它们不会浪费不必要的资源。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在消除了本文中描述的问题之后，我们极大地加速了React Native上的应用程序。</font><font style="vertical-align: inherit;">现在，很难将其性能与本机实现的相似性能区分开。</font><font style="vertical-align: inherit;">过多的渲染会减慢单个屏幕的加载速度以及对用户操作的反应。</font><font style="vertical-align: inherit;">最重要的是，它在列表中引人注目，其中一次绘制了数十个组件。</font><font style="vertical-align: inherit;">我们还没有对所有内容进行优化，但是应用程序的主屏幕不再变慢。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面简要列出了本文的要点。</font></font><br>
<br>
<ol>
<li> React Native      :  Props/State-     .</li>
<li>,   <code>React.PureComponent</code>,     ,       .</li>
<li>    ,    <code>shouldComponentUpdate</code>      <code>React.Memo</code>   .</li>
<li>-        .      ,         (shallow compare).               ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持表示级别的库可能会导致资源意外浪费。</font><font style="vertical-align: inherit;">值得在应用中小心。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样。</font><font style="vertical-align: inherit;">我希望您能找到有用的信息。</font><font style="vertical-align: inherit;">我将很高兴收到任何反馈！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用的资料</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解React + Redux中的渲染</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在JavaScript中比较对象</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用React.memo（）提高React功能组件的性能</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discord如何通过React Native实现iOS的本机性能</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492374/index.html">实验：来自OOP世界的Redux</a></li>
<li><a href="../zh-CN492376/index.html">如何使您的文章或文档快速准确地理解</a></li>
<li><a href="../zh-CN492378/index.html">Reactjs，带有JSS的Material-UI。简短指南</a></li>
<li><a href="../zh-CN492384/index.html">哈克盒子-邮递员演练 Redis和WebMin</a></li>
<li><a href="../zh-CN492386/index.html">IT部门如何帮助世界减少食物</a></li>
<li><a href="../zh-CN492392/index.html">IntelliJ IDEA技巧和窍门：3.自定义每个文件夹的代码样式</a></li>
<li><a href="../zh-CN492394/index.html">黑暗宇宙。第2部分</a></li>
<li><a href="../zh-CN492398/index.html">我们为远程工作，播客，视频和流媒体配置设备</a></li>
<li><a href="../zh-CN492404/index.html">Flutter + Arduino Nano 33 BLE感应=非常简单的BLE传感器</a></li>
<li><a href="../zh-CN492406/index.html">极客播客：关于项目管理，技术分析和GTD的一系列成熟程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>