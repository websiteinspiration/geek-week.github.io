<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏼 🚃 📗 现代Java在处理大量数据时的性能，第1部分 ♻️ 🙍🏽 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="近年来，Java运行时的发展比以前快。15年后，我们终于有了默认的垃圾收集器-G1。另外两个正在开发中并且可以作为实验功能使用-Oracle ZGC和OpenJDK Shenandoah。我们决定测试所有这些新工具，并找出最适合Hazelcast Jet分布式开源流引擎的工作量的最佳工具。
 
 J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>现代Java在处理大量数据时的性能，第1部分</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/506706/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gy/8p/zf/gy8pzf7gjtwr9pvv1zb7rgmmjiy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近年来，Java运行时的发展比以前快。</font><font style="vertical-align: inherit;">15年后，我们终于有了默认的垃圾收集器-G1。</font><font style="vertical-align: inherit;">另外两个正在开发中并且可以作为实验功能使用-Oracle ZGC和OpenJDK Shenandoah。</font><font style="vertical-align: inherit;">我们决定测试所有这些新工具，并找出最适合Hazelcast Jet分布式开源流引擎的工作量的最佳工具。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jet用于解决具有不同延迟和带宽要求的各种任务。</font><font style="vertical-align: inherit;">任务分为三个重要类别：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无限的低延迟流。</font><font style="vertical-align: inherit;">示例：识别来自10,000个设备的传感器的数据趋势，这些设备以100 Hz的频率获取信息，并在10-20 ms内发送更正。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高带宽无限流处理。</font><font style="vertical-align: inherit;">示例：通过计算速度矢量跟踪数百万用户的GPS坐标。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经典的大数据批处理。</font><font style="vertical-align: inherit;">标准是在处理上花费的时间，这意味着需要高吞吐量。</font><font style="vertical-align: inherit;">示例：分析每天收集的股票交易数据，以更新给定资产组合的风险水平。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们可以观察以下内容：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一种情况下，延迟要求落入了垃圾收集器暂停的危险区域：100 ms。</font><font style="vertical-align: inherit;">在大多数困难的情况下，这被认为是垃圾收集的极佳结果，并且在许多情况下，它可能成为绊脚石。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种情况和第三种情况在垃圾回收要求上是相同的。</font><font style="vertical-align: inherit;">延迟要求不那么严格，但对终身代来说是很大的负担。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于延迟要求，第二种情况更加困难，即使不像第一种情况那样严格。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们尝试了以下组合：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有默认Parallel汇编程序和可选ConcurrentMarkSweep和G1的JDK 8。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有默认收集器G1和可选的Parallel的JDK 11。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有默认收集器G1和实验性ZGC和Shenandoah的JDK 14。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们得出以下结论：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用现代版本的JDK，G1构建器可以很好地工作。</font><font style="vertical-align: inherit;">它可以轻松处理数十千兆字节的堆（我们尝试了60 GB），最大暂停时间为200毫秒。</font><font style="vertical-align: inherit;">在极端负载下，G1不会进入噩梦临界模式。</font><font style="vertical-align: inherit;">而是，完全垃圾收集的暂停持续时间增加到几秒钟。</font><font style="vertical-align: inherit;">收集器的弱点是在低负载的有利条件下停顿的上限。</font><font style="vertical-align: inherit;">我们设法将其降低到20-25毫秒。</font></font></li>
<li>JDK 8 —   .    Parallel       .  G1    ,    ,       ,     .       12    20   Parallel     G1. ConcurrentMarkSweep       G1,           .</li>
<li>  ZGC    ,   G1,        ,  G1       10 . </li>
<li>Shenandoah        220    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZGC和Shenandoah在关键模式下的表现都没有像G1那样稳定。</font><font style="vertical-align: inherit;">他们的工作不可靠，在低延迟模式下，很长的停顿意外发生，甚至OOME。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文介绍了我们在两种流处理方案中的测试结果。</font><font style="vertical-align: inherit;">在第二部分中，我们将讨论批处理的结果。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流处理基准</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于流媒体基准，我们采用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这段</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码，并在两次测试之间进行了一些更改。</font><font style="vertical-align: inherit;">这是Jet管道的主要部分：</font></font><br>
<br>
<pre><code class="java hljs">StreamStage&lt;Long&gt; source = p.readFrom(longSource(ITEMS_PER_SECOND))<font></font>
                            .withNativeTimestamps(<span class="hljs-number">0</span>)<font></font>
                            .rebalance(); <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
source.groupingKey(n -&gt; n % NUM_KEYS)<font></font>
      .window(sliding(SECONDS.toMillis(WIN_SIZE_SECONDS), SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .filter(kwr -&gt; kwr.getKey() % DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR == <span class="hljs-number">0</span>)<font></font>
      .window(tumbling(SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .writeTo(Sinks.logger(wr -&gt; String.format(<span class="hljs-string">"time %,d: latency %,d ms, cca. %,d keys"</span>,<font></font>
              simpleTime(wr.end()),<font></font>
              NANOSECONDS.toMillis(System.nanoTime()) - wr.end(),<font></font>
              wr.result() * DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR)));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该管道反映了事件无限流的使用情况。引擎应使用“滑动窗口”方法汇总数据。例如，需要进行这样的汇总才能获得变化值的时间导数，从高频噪声中清除数据（平滑处理）或测量事件的发生频率（每秒事件数）。引擎可以首先将流划分为子流（例如，所有单独的物联网设备或智能手机）。然后独立跟踪每个子流的合计值。在Hazelcast Jet中，滑动窗口以不连续的步长移动，您可以指定大小。例如，以1秒钟的步长，您每秒可获得一整套结果。只需1分钟，结果将包括最后一分钟发生的一切。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些注意事项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码是完全独立的。不使用外部数据源。我们使用存根源以正确的频率模拟事件流。事件定期发生。源不生成时间戳与未来有关的事件，但会尽快生成它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果流水线滞后，则事件将被“缓冲”而不保存。在这种情况下，管道应赶上，尽快接收数据。由于我们的源未并行化，因此其带宽限制达到了每秒约220万个事件。我们模拟了100万个事件/秒，因此留出了120万个事件/秒的余量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传送带通过将滑动窗口结果的时间戳与当前时间进行比较来测量其延迟。使用了中间过滤的两个阶段的聚集。一个滑动窗口的结果包含许多元素，每个子流一个元素，我们对最后一个元素的延迟感兴趣。因此，首先我们将大部分结果过滤掉，每十分之一的元素都保留下来。然后，我们将减少的流量引导至第二阶段，并使用没有按键的“翻转”窗口。在此阶段，我们记下结果的大小并测量延迟。不使用键的聚合不会并行化，因此我们只有一个测量点。过滤阶段是并行的，并且是数据局部的，因此附加聚合阶段的影响非常小（远低于1 ms）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用了一个简单的聚合函数：计数。实际上，获得了流中事件发生频率的度量。它具有最小的结构（一种类型编号</font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），不会生成垃圾。对于任何数量的堆使用量（以GB为单位），如此小的键结构都意味着垃圾收集器的最坏情况：大量对象。收集器上的负载并不随堆的大小而增加，而是随对象的数量而增加。我们还测试了计算相同聚合函数但生成垃圾的实现不同的选项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将大多数流基准测试放在一个节点上，因为我们对内存管理对管道性能的影响感兴趣。</font><font style="vertical-align: inherit;">网络延迟只会给数据增加噪音。</font><font style="vertical-align: inherit;">为了检验集群性能不会影响我们的发现的假设，我们在一个三节点的Amazon EC2集群上重复了一些关键测试。</font><font style="vertical-align: inherit;">有关更多信息，将在第二篇文章结尾处进行描述。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从流负载结果中删除了Parallel收集器，因为在大多数实际情况下，它创建的延迟峰值是不可接受的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案1：低延迟，中等结构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
脚本选项：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenJDK的14</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM堆大小为4 GB。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于G1，给定 </font></font><code>-XX:MaxGCPauseMillis=5</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1百万个事件/秒。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50,000个个人密钥。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.1秒后30秒滑动窗口。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，使用少于1 GB的堆。</font><font style="vertical-align: inherit;">收集器上的负载很小，它有足够的时间来进行后台竞争性垃圾收集。</font><font style="vertical-align: inherit;">以下是经过测试的三个汇编器在管道运行中的最大延迟：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/053/d40/26c/053d4026c6d3eb747e3e78bbdcd46ecd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些值包括大约3毫秒的固定间隔，用于传输窗口结果。</font><font style="vertical-align: inherit;">该图说明了一切：默认的G1构建器做得很好，但是如果您需要更低的延迟，则可以使用实验性ZGC。</font><font style="vertical-align: inherit;">我们不能将延迟峰值降低到10 ms以下。</font><font style="vertical-align: inherit;">但是对于ZGC和Shenandoah而言，它们的出现并不是由于暂停垃圾收集而引起的，而是由于收集者的后台工作量增加的时间很短。</font><font style="vertical-align: inherit;">有时，Shenandoah服务进程将延迟提高到200 ms以上。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案二：更大的结构，不太严格的延迟要求</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们假设由于超出我们控制范围的原因（例如，由于蜂窝网络），延迟可能会增加到几秒钟。</font><font style="vertical-align: inherit;">这减轻了对流处理管道的要求。</font><font style="vertical-align: inherit;">另一方面，我们可能会遇到更大的数据，数以百万计或数千万个键的大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，考虑到垃圾收集器将在大堆中运行，而不是将数据分布在集群的多个节点上，我们可以准备大量使用的设备。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们以不同的组合进行了许多测试，以找出因素的组合如何影响运行时的性能。</font><font style="vertical-align: inherit;">原来，这取决于两个参数：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聚合中存储的记录数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">化妆的带宽要求。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个参数描述了终身代中的对象数。使用滑动窗口方法进行聚合时，我们会长时间（在整个窗口中）保留对象，然后释放它们。这直接与世代垃圾假说（Generational Garbage Hypothesis，世代垃圾假说）相反，该假说声称物体要么年轻就死，要么永远活着。在此模式下，将创建垃圾收集器的最大负载。而且，由于其工作强度随生物数量的增加而增加，因此生产率很大程度上取决于此参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个参数与应用程序可以分配给垃圾收集器多少资源有关。为了更清楚，让我们构建一些图表。使用滑动窗口方法进行汇总时，输送机将经历三个阶段：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生时进行实时事件处理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递滑动窗口的结果。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赶上第二阶段收到的事件。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这三个阶段可以可视化如下：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99c/d77/894/99cd778940f1596c2dd5e1dbf0933fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果窗口结果的传输花费了更长的时间，我们将处于这种情况：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/694/760/b226947608cfb3373742d02e6dc7774f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，传送带几乎没有时间了，所有时间延迟（例如暂停收集垃圾）都会增加延迟，并且恢复速度会非常缓慢。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们更改图形，仅显示通过窗口结果后事件的平均吸收率：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/cd9/ccb/d78cd9ccbf09b96c23705ae8bb0d6e38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们将黄色矩形的高度称为“拼版要求”：这是对源容量的要求。如果超过传送带的实际吞吐量，则无法应付负载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果传输窗口结果会花费太多时间，则如下所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/0ea/594/5b90ea59490f05c628401475c9849e21.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
红色和黄色矩形的区域是固定的，对应于必须通过管道的数据量。实际上，红色“挤压”黄色。但是黄色矩形的高度是有限的，在我们的例子中，上限为220万个事件/秒。并且当高度超过限制时，我们得到的输送机无法应对负载和无限增长的延迟。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们导出了用于针对事件频率，窗口大小，滑动步长和键集大小的给定组合预测矩形大小的公式。因此，无论如何我们都可以确定拼版的要求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们有两个或多或少的独立参数，这些参数是从描述每个单独组合的许多其他参数中得出的。</font><font style="vertical-align: inherit;">您可以构建一个二维图形，在其上的圆圈指示放下的基准。</font><font style="vertical-align: inherit;">根据组合的成功或失败为圆圈上色。</font><font style="vertical-align: inherit;">例如，对于一堆在笔记本电脑上运行G1的JDK 14，我们得到下图：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab2/9e6/416/ab29e641669a2666c59d506e59fce458.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们确定了三类：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“是”-传送带正在应对，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“否”-管道由于带宽不足而无法应对，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“垃圾收集器”-输送机由于频繁的长时间停顿而无法应对。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，由于竞争性的垃圾收集和频繁的短暂暂停会导致带宽不足。通常，最后两个类别之间的差异很小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以看到边框分隔图的左下方。它包含成功通过基准测试的要点。我们为JDK和垃圾收集器的其他组合绘制了相同的图，确定了区域的边界并得到以下结果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/d12/394/251d123945208cbed4806928946c4241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们有一台配备6核Intel Core i7和16GB DDR4 RAM的MacBook Pro 2018。对于JVM已经配置好了</font></font><code>-Xmx10g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，我们相信在许多其他配置上也会观察到类似的情况。该图显示了G1相对于其他收集器的优越性，与JDK 8一起使用时G1的弱点以及在这种负载下具有低延迟的实验性收集器的弱点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本延迟-窗口结果传输的持续时间-在500毫秒左右波动。</font><font style="vertical-align: inherit;">但是，由于垃圾收集的主要停顿（在G1情况下，停顿时间过长）而经常发生爆裂，在临界情况下（当传送带几乎不能工作时）长达10 s而减少到1-2 s。</font><font style="vertical-align: inherit;">我们还注意到在边界情况下JIT编译的效果：管道开始工作，并且延迟不断增加，大约两分钟后，性能有所提高，并且延迟恢复为正常值。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN506696/index.html">在Gitlab.com上管理PostgreSQL。何塞·科里斯·菲诺托</a></li>
<li><a href="../zh-CN506698/index.html">“海上发射”的安魂曲</a></li>
<li><a href="../zh-CN506700/index.html">我们为Android配置GitHub Action，并在PlayMarket中进行后续部署</a></li>
<li><a href="../zh-CN506702/index.html">根据Backblaze Q1 2020最可靠的硬盘</a></li>
<li><a href="../zh-CN506704/index.html">为什么在2020年用PHP编写？Holivarim是本周四在YouTube上的互动播客</a></li>
<li><a href="../zh-CN506708/index.html">VPN / Mikrotik两因素身份验证-简单且可扩展</a></li>
<li><a href="../zh-CN506710/index.html">在Zimbra Collaboration Suite开源版中管理多个通讯录</a></li>
<li><a href="../zh-CN506716/index.html">多线程线性列表：元素存在问题，性能改进和STL关系</a></li>
<li><a href="../zh-CN506726/index.html">使用Rutoken技术进行系统中用户注册和授权的经验（第2部分）</a></li>
<li><a href="../zh-CN506730/index.html">Snort或Suricata。第1部分：选择免费的IDS / IPS保护企业网络</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>