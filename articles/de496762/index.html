<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎓 🤪 📌 Partikelbasierte Oberflächenerosionssimulation 👩🏻‍🚒 🗼 👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis: Der vollständige Quellcode des Projekts sowie Erläuterungen zu seiner Verwendung und zum Lesen finden Sie auf Github [ hier ].
 Ich machte ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Partikelbasierte Oberflächenerosionssimulation</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496762/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/l6/kc/cfl6kcm3exssgmt2bklqvwyt1ls.gif"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Der vollständige Quellcode des Projekts sowie Erläuterungen zu seiner Verwendung und zum Lesen finden Sie auf Github [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ].</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich machte eine Pause von meiner Masterarbeit, um an dem zu arbeiten, was ich lange aufgeschoben hatte: Verbesserte Geländegenerierung für mein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Territory-Projekt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eine einfache Möglichkeit, es zu implementieren, ist die hydraulische Erosion, weshalb ich es erstellt habe! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für ein eintägiges Software-Puzzle funktionierte es ziemlich gut und war nicht so kompliziert wie ich erwartet hatte. Ergebnisse werden schnell generiert, haben eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physikalische Bedeutung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und sehen fantastisch aus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich über meine einfache C ++ - Implementierung eines partikelbasierten hydraulischen Erosionssystems mit quadratischem Netz sprechen. </font><font style="vertical-align: inherit;">Ich werde alle physikalischen Rechtfertigungen erklären, die der Implementierung zugrunde liegen, und über Mathematik sprechen. </font><font style="vertical-align: inherit;">Der Code ist extrem einfach (nur etwa 20 Zeilen für die Erosionsmathematik) und schnell zu implementieren. Ich empfehle ihn daher jedem, der den Realismus seines Geländes verbessern möchte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse werden mit einer abgespeckten Version meiner </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Homebrew OpenGl Engine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerendert </font><font style="vertical-align: inherit;">, die ich geändert habe, um ein 2D-Array von Punkten als Höhenkarte zu rendern. </font><font style="vertical-align: inherit;">Eine abgespeckte Version der Engine ist viel einfacher zu verstehen, wenn Sie OpenGL in C ++ lernen möchten.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inspiriert von vielen Quellen hydraulischer Erosion entschied ich, dass es am logischsten wäre, Partikel zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erosion auf Partikelbasis ist sehr einfach:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erzeugen ein Teilchen an einem zufälligen Punkt auf der Oberfläche.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bewegt / gleitet entlang der Oberfläche unter Verwendung der klassischen Standardmechanik (wir werden weiter unten darüber sprechen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir führen den Transfer von Materie / Sediment zwischen der Oberfläche und dem Partikel durch (dies wird auch unten erklärt).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verdampfen einen Teil des Partikels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich das Partikel außerhalb der Karte befindet oder zu klein ist, zerstören Sie es</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie den Vorgang mit der gewünschten Partikelanzahl.</font></font></li>
</ul><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Systemparameter werden im entsprechenden Abschnitt erläutert. </font><font style="vertical-align: inherit;">Am wichtigsten ist der Zeitschrittfaktor </font></font><code>dt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der alle Parameter proportional skaliert. </font><font style="vertical-align: inherit;">Dies ermöglicht es uns, die Frequenz der Simulation zu erhöhen (auf Kosten der Erhöhung des Rauschens), ohne den relativen Maßstab der Parameter zu ändern. </font><font style="vertical-align: inherit;">Dies ist im folgenden Code zu sehen.</font></font></blockquote><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partikel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu habe ich eine einfache Partikelstruktur erstellt, die alle Eigenschaften enthält, die ich benötige:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Particle</span>{</span>
  <span class="hljs-comment">//Construct particle at position _pos</span><font></font>
  Particle(glm::vec2 _pos){ pos = _pos; }<font></font>
<font></font>
  glm::vec2 pos;<font></font>
  glm::vec2 speed = glm::vec2(<span class="hljs-number">0.0</span>); <span class="hljs-comment">//Initialize to 0</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> volume = <span class="hljs-number">1.0</span>;   <span class="hljs-comment">//Total particle volume</span>
  <span class="hljs-keyword">float</span> sediment = <span class="hljs-number">0.0</span>; <span class="hljs-comment">//Fraction of volume that is sediment!</span>
};</code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Falls Sie mit der GLM-Bibliothek nicht vertraut sind: Ich verwende sie, um Vektoroperationen auszuführen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Partikel hat eine Position und Geschwindigkeit, die bestimmen, wie es sich bewegt. </font><font style="vertical-align: inherit;">Darüber hinaus hat es ein Volumen und einen Anteil, der bestimmt, wie viel des Volumens Sedimentgesteine ​​sind.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrwerk: klassische Mechanik</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bewegung der Partikel auf der Oberfläche wird mithilfe der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">klassischen Mechanik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simuliert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kurz gesagt, die Position </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilchens wird durch die Geschwindigkeit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geändert, die durch die Beschleunigung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geändert wird </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd2/b52/84b/fd2b5284b87f7ddcaf420ae80dcffffa.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a43/2cb/d0da432cb54f1e8992bffc1fc7cbe960.png"></div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Fettgedruckte Buchstaben zeigen an, dass der Wert ein Vektor ist.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen auch, dass Kraft gleich Masse mal Beschleunigung ist:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/27b/bd6/ad927bbd6bc3be37ff5873488aab2759.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Teilchen erfährt eine durch die Schwerkraft verursachte Abwärtsbeschleunigung, befindet sich jedoch an der Oberfläche, was eine Abwärtsbeschleunigung unmöglich macht. </font><font style="vertical-align: inherit;">Stattdessen wird das Teilchen stattdessen einer Kraft </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgesetzt, </font><font style="vertical-align: inherit;">die entlang der Oberfläche gerichtet und proportional zur Normalen zur Oberfläche ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher können wir sagen, dass die Beschleunigung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proportional zum Normalenvektor der Oberfläche </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geteilt durch die Masse des Teilchens ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/321/54e/15c/32154e15c0a35751375f382938b8dd37.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei ist k die Proportionalitätskonstante und m die Partikelmasse. </font><font style="vertical-align: inherit;">Wenn die Masse gleich dem Volumen multipliziert mit der Dichte ist, erhalten wir das vollständige System der Teilchenbewegung unter Verwendung der klassischen Mechanik:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//... particle "drop" was spawned above at random position</span><font></font>
<font></font>
glm::ivec2 ipos = drop.pos; <span class="hljs-comment">//Floored Droplet Initial Position</span>
glm::vec3 n = surfaceNormal(ipos.x, ipos.y);  <span class="hljs-comment">//Surface Normal</span><font></font>
<font></font>
<span class="hljs-comment">//Accelerate particle using classical mechanics</span><font></font>
drop.speed += dt*glm::vec2(n.x, n.z)/(drop.volume*density);<font></font>
drop.pos   += dt*drop.speed;<font></font>
drop.speed *= (<span class="hljs-number">1.0</span>-dt*friction);  <span class="hljs-comment">//Friction Factor</span><font></font>
<font></font>
<span class="hljs-comment">//...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Die Geschwindigkeit nach der Partikelbewegung wird durch den Reibungsvektor verringert. </font><font style="vertical-align: inherit;">Beachten Sie, dass der Zeitschrittfaktor hier enthalten ist. </font><font style="vertical-align: inherit;">Teilchen haben ihre eigene Trägheit, proportional zu ihrer Dichte, da wir ihre Bewegung mithilfe der Beschleunigung simulieren.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedimentationsprozess: Stoffübergang</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Prozess der Bildung von Sedimentgesteinen erfolgt physikalisch als Übertragung von Sedimentgesteinen von der Erde auf das Partikel und umgekehrt an dem Punkt, an dem sich das Partikel befindet (" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stoffübergang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der chemischen Technologie wird der Stoffübergang (d. H. Änderung der Masse / des Sediments über die Zeit) zwischen zwei Phasen (in diesem Fall der Erdoberfläche und einem Tropfen) üblicherweise unter Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stoffübergangskoeffizienten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschrieben </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stoffübergang ist proportional zur Differenz zwischen Konzentration c und Gleichgewichtskonzentration c_eq:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb1/a01/b90/fb1a01b906f182238079f25582725583.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei ist k die Proportionalitätskonstante (Stoffübergangskoeffizient). </font><font style="vertical-align: inherit;">Dieser Unterschied zwischen Gleichgewicht und tatsächlicher Konzentration wird oft als "treibende Kraft" bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist die Gleichgewichtskonzentration höher als der Strom, absorbiert das Partikel Sedimentgesteine. </font><font style="vertical-align: inherit;">Wenn niedriger, dann verliert sie. </font><font style="vertical-align: inherit;">Wenn sie gleich sind, werden keine Änderungen vorgenommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stoffübergangskoeffizient kann auf verschiedene Arten interpretiert werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Häufigkeit des Übergangs zwischen Phasen (hier ist es "Abscheidungsrate")</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Geschwindigkeit, mit der die Tröpfchenkonzentration zur Gleichgewichtskonzentration neigt</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das System ist vollständig von der Bestimmung der Gleichgewichtskonzentration abhängig. </font><font style="vertical-align: inherit;">Abhängig von der Definition zeigt das System eine unterschiedliche Dynamik der Sedimentgesteinsablagerung. </font><font style="vertical-align: inherit;">In meiner Implementierung ist die Gleichgewichtskonzentration höher, wenn wir uns nach unten bewegen und wenn wir uns schneller bewegen, und sie ist auch proportional zum Volumen des Partikels:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//...</span><font></font>
<font></font>
<span class="hljs-comment">//Compute Equilibrium Sediment Content</span>
<span class="hljs-keyword">float</span> c_eq = drop.volume*glm::length(drop.speed)*(heightmap[ipos.x][ipos.y]-heightmap[(<span class="hljs-keyword">int</span>)drop.pos.x][(<span class="hljs-keyword">int</span>)drop.pos.y]);<font></font>
<font></font>
<span class="hljs-keyword">if</span>(c_eq &lt; <span class="hljs-number">0.0</span>) c_eq = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
<span class="hljs-comment">//Compute Capacity Difference ("Driving Force")</span>
<span class="hljs-keyword">float</span> cdiff = c_eq - drop.sediment;<font></font>
<font></font>
<span class="hljs-comment">//Perform the Mass Transfer!</span><font></font>
drop.sediment += dt*depositionRate*cdiff;<font></font>
heightmap[ipos.x][ipos.y] -= dt*drop.volume*depositionRate*cdiff;<font></font>
<font></font>
<span class="hljs-comment">//...</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Die Änderung der Konzentration innerhalb des Partikels wird vollständig durch die Stoffübergangsgleichung beschrieben. </font><font style="vertical-align: inherit;">Die Änderung der Höhenkarte wird zusätzlich mit dem Partikelvolumen multipliziert, da wir sie proportional nicht zur Konzentration, sondern zur Masse ändern (Konzentration wird mit Volumen multipliziert).</font></font></blockquote><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Aspekte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Höhenkarte wird durch ein mehrschichtiges Perlin-Rauschen mit einem zufälligen Startwert initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende jedes Zeitschritts verliert das Partikel entsprechend der Verdampfungsrate eine kleine Masse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//...</span><font></font>
<font></font>
drop.volume *= (<span class="hljs-number">1.0</span>-dt*evapRate);<font></font>
<font></font>
<span class="hljs-comment">//...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Vorgang wird für Tausende von Partikeln wiederholt, die an zufälligen Orten erstellt und separat simuliert wurden (in meinem Fall werden die Berechnungen nacheinander in der CPU durchgeführt). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine Standardimplementierung enthält einen guten Satz von Parametern. </font><font style="vertical-align: inherit;">Nach 200.000 Partikeln sieht die Erosion sehr gut aus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der fertige Code für den Erosionsprozess besteht aus ungefähr 20 Zeilen ohne Kommentar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Vorher-Nachher-Vergleich für 10 Proben. </font><font style="vertical-align: inherit;">Die Simulation erzeugt sehr schöne Grate auf Höhen, Sedimentgesteine ​​lagern sich an den Seiten einiger Grate ab, was zur Schaffung schöner Plateaus führt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/70f/b95/98370fb957b09af4303e6c0d1df51587.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Auswahl von zehn Vorher-Nachher-Vergleichen. </font><font style="vertical-align: inherit;">Der Shader, den ich geschrieben habe, erhält am Eingang zwei Farben. </font><font style="vertical-align: inherit;">Ich habe auch Shadow Mapping, entfernungsabhängigen Nebel und Phong Shading implementiert. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind zehn weitere (verschiedene) Beispiele nur mit den Ergebnissen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de6/eab/1cb/de6eab1cb6114ec31f27d9ebbc931be1.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zehn weitere Probenergebnisse. </font><font style="vertical-align: inherit;">Sie unterscheiden sich von den vorherigen, auch wenn einige Formationen ähnlich aussehen. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem Sie den Startwert während der Karteninitialisierung unterschiedlich auswählen, können Sie kontrollierte unterschiedliche Ergebnisse erstellen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulationszeit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Simulationszeit steht in direktem Zusammenhang mit der Lebensdauer der Partikel und der Anzahl der simulierten Partikel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verschiedene Faktoren beeinflussen die Lebensdauer von Partikeln und können für jedes Partikel stark variieren, da sie an zufälligen Orten erzeugt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reibung und Trägheit: Teilchengeschwindigkeit</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gittergröße: Die Wahrscheinlichkeit, dass Partikel aus der Karte fallen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdampfungsrate: Partikelauslöschungsrate</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Standardparametern benötigt eine Simulation eines einzelnen Partikels 10 bis 100 Millisekunden, was für eine Simulation von 200.000 Partikeln 10 bis 20 Sekunden ergibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können den Erosionsgrad erhöhen und die Lebensdauer der Partikel verkürzen, indem Sie den Zeitschritt erhöhen, ohne die Anzahl der simulierten Partikel zu ändern. </font><font style="vertical-align: inherit;">Dies kann die Simulation „verrauscht“ machen. Wenn der Zeitschritt zu groß ist, besteht die Möglichkeit, dass die Simulation fehlschlägt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Simulation selbst in der Engine verursacht zusätzliche Kosten für die Neuerstellung des Oberflächennetzes für das Rendern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können den Code optimieren, indem Sie die Kosten für die Neuerstellung des Netzes senken oder die Geschwindigkeit eines Zeitschritts für ein einzelnes Partikel erhöhen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeit für die Zukunft</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Kürze werde ich diesen Code in mein Territory-Projekt einfügen, um eine Höhenkarte im Höhengenerator zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe bereits ein Framework für die vereinfachte Simulation der Fluiddynamik in Klimasystemen geschrieben, das jedoch noch nicht veröffentlicht werden kann. Dieses System erhält Klimamuster von einer Höhenkarte. Dies wird das Thema für einen zukünftigen Beitrag über physikalisch genaue prozedurale Klimasysteme sein! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem simulierten Klimasystem wird es in Zukunft möglich sein, Partikel aus der Verteilung (z. B. an Orten, an denen es regnet) zu entnehmen, anstatt sie gleichmäßig auf der Karte zu verteilen. Sie werden ideal mit der Geologie und dem Klima des Reliefs kombiniert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können Steine ​​nach dem Hinzufügen verschiedener Arten von geologischen Formationen einen unterschiedlichen Löslichkeitsgrad aufweisen. </font><font style="vertical-align: inherit;">Dies wirkt sich direkt auf den Stoffübergangskoeffizienten (Ablagerungsrate) aus und führt zu einer anderen Erosionsrate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses System kann keinen realen Flüssigkeits- und Flussfluss simulieren, kann jedoch möglicherweise an solche Aufgaben angepasst werden. </font><font style="vertical-align: inherit;">Ich werde darüber nachdenken und vielleicht werde ich in Zukunft eine Fortsetzung des Beitrags veröffentlichen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496752/index.html">Wie das Ebola-Virus uns den Umgang mit Infektionsdaten beigebracht hat und wir alle seine Lektionen vergessen haben</a></li>
<li><a href="../de496754/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 506 (24.03.2020-30.03.2020)</a></li>
<li><a href="../de496756/index.html">AWS Lambda in Aktion. Teil 2: Kennenlernen von Entwicklungs- und Testwerkzeugen</a></li>
<li><a href="../de496758/index.html">Digitale mittelalterliche Gesundheitsversorgung. Globaler technologischer Wandel nach COVID-19</a></li>
<li><a href="../de496760/index.html">Benutzerfluss: So erstellen Sie beliebte Anwendungen und Websites</a></li>
<li><a href="../de496764/index.html">Klein aber fein: DuckDuckGo vs. Ad Monsters</a></li>
<li><a href="../de496766/index.html">Was ist Azure Stack HCI und wie funktioniert es?</a></li>
<li><a href="../de496768/index.html">Vergessen Sie RGB und HEX</a></li>
<li><a href="../de496770/index.html">Automatisierte Ingenieurwohnung. Teil 1: Erklärung des Problems, Wahl des Eisens</a></li>
<li><a href="../de496772/index.html">Unbemannte Fahrzeuge sollten die Marken von Autos „im Auge behalten“, die von den härtesten Fahrern gefahren werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>