<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏾 🔚 🙆🏾 Artikel yang gagal tentang percepatan refleksi 👨🏽‍🚒 👲🏾 🚊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan segera menjelaskan judul artikel tersebut. Awalnya, ini direncanakan untuk memberikan saran yang baik dan dapat diandalkan tentang mempercep...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Artikel yang gagal tentang percepatan refleksi</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499562/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan segera menjelaskan judul artikel tersebut. Awalnya, ini direncanakan untuk memberikan saran yang baik dan dapat diandalkan tentang mempercepat penggunaan refleksi menggunakan contoh sederhana namun realistis, tetapi selama benchmarking ternyata refleksi tidak bekerja selambat yang saya pikir, LINQ bekerja lebih lambat daripada yang diimpikan dalam mimpi buruk. Tetapi pada akhirnya ternyata saya juga membuat kesalahan dalam pengukuran ... Detail kisah hidup ini di bawah potongan dan di komentar. Karena contohnya cukup sehari-hari dan pada prinsipnya diterapkan, seperti yang biasanya dilakukan di perusahaan, ternyata cukup menarik, seperti yang terlihat bagi saya, sebuah demonstrasi kehidupan: tidak ada efek nyata pada kecepatan subjek utama artikel karena logika eksternal: Moq, Autofac, EF Core, dll. "Tegap".</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memulai pekerjaan saya di bawah kesan artikel ini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Refleksi lambat</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Seperti yang Anda lihat, penulis menyarankan untuk menggunakan delegasi yang dikompilasi alih-alih secara langsung menggunakan metode tipe refleksi sebagai cara yang bagus untuk mempercepat aplikasi. Tentu saja ada emisi IL, tetapi saya ingin menghindarinya, karena ini adalah cara yang paling padat karya untuk menyelesaikan tugas, yang penuh dengan kesalahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mempertimbangkan bahwa saya selalu berpegang pada pendapat yang sama tentang kecepatan refleksi, saya tidak bermaksud untuk memberikan keraguan khusus pada kesimpulan penulis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sering menemukan penggunaan refleksi yang naif dalam suatu perusahaan. Jenis diambil. Informasi properti diambil. Metode SetValue dipanggil, dan semua orang senang. Nilai terbang ke bidang target, semua orang senang. Orang-orang yang sangat pandai - sinior dan pemimpin tim - menulis ekstensi mereka pada objek, berdasarkan pada implementasi yang naif dari pemetaan "universal" dari satu jenis ke jenis lainnya. Inti dari ini biasanya: kita mengambil semua bidang, kita mengambil semua properti, beralih di atasnya: jika nama-nama anggota bertepatan, kita mengeksekusi SetValue. Kami secara berkala menangkap pengecualian pada kesalahan ketika salah satu tipe tidak menemukan properti, tetapi ada juga jalan keluar yang mencapai kinerja. Coba tangkap.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya melihat orang-orang menciptakan parser dan pemetaan tanpa dipersenjatai sepenuhnya dengan informasi tentang bagaimana sepeda diciptakan sebelum mereka bekerja. Saya melihat orang menyembunyikan implementasi naif mereka di belakang strategi, di belakang antarmuka, di belakang suntikan, seolah-olah ini akan menjadi alasan bacchanalia berikutnya. Dari implementasi seperti itu aku menoleh. Bahkan, saya tidak mengukur kebocoran kinerja nyata, dan jika mungkin, saya hanya mengubah implementasinya menjadi lebih "optimal", jika tangan saya mencapai. Karena pengukuran pertama, yang dibahas di bawah ini, saya benar-benar malu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir banyak dari Anda, ketika membaca Richter atau ideolog lain, telah datang dengan pernyataan yang cukup adil bahwa refleksi dalam kode adalah fenomena yang memiliki efek yang sangat negatif pada kinerja aplikasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panggilan refleksi memaksa CLR untuk pergi berkeliling majelis untuk mencari yang tepat, menarik metadata-nya, menguraikannya, dll. Selain itu, refleksi selama urutan traversal mengarah ke alokasi sejumlah besar memori. Kami menghabiskan memori, CLR mengungkap HZ dan membeku berpacu. Seharusnya terasa lambat, percayalah. Sejumlah besar memori server produksi modern atau mesin cloud tidak menghemat dari penundaan pemrosesan yang tinggi. Bahkan, semakin banyak memori, semakin tinggi kemungkinan Anda AKAN PEMBERITAHUAN tentang cara kerja HZ. Refleksi, secara teori, kain merah ekstra untuknya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun demikian, kita semua menggunakan wadah IoC dan pembuat tanggal, yang prinsipnya juga didasarkan pada refleksi, namun, pertanyaan tentang kinerja mereka biasanya tidak muncul. Tidak, bukan karena pengenalan dependensi dan abstrak dari model konteks terbatas eksternal adalah hal yang sangat penting sehingga kita harus mengorbankan kinerja dalam hal apa pun. Semuanya lebih sederhana - itu benar-benar tidak mempengaruhi kinerja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya adalah bahwa kerangka kerja paling umum yang didasarkan pada teknologi refleksi menggunakan semua jenis trik untuk bekerja dengannya secara lebih optimal. Ini biasanya sebuah cache. Biasanya ini adalah Ekspresi dan delegasi yang dikompilasi dari pohon ekspresi. Auto-mapper yang sama memegang kamus kompetitif, mencocokkan jenis dengan fungsi yang dapat mereka konversi satu sama lain tanpa memanggil refleksi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana ini dicapai? Sebenarnya, ini tidak berbeda dengan logika yang digunakan platform itu sendiri untuk menghasilkan kode JIT. Ketika Anda pertama kali memanggil suatu metode, itu mengkompilasi (dan, ya, proses ini tidak cepat), dengan panggilan berikutnya, kontrol ditransfer ke metode yang sudah dikompilasi, dan tidak akan ada penurunan kinerja khusus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, Anda juga dapat menggunakan kompilasi JIT dan kemudian menggunakan perilaku yang dikompilasi dengan kinerja yang sama dengan rekan-rekan AOT-nya. Dalam hal ini, ekspresi akan membantu kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara singkat, kita dapat merumuskan prinsip tersebut sebagai berikut: Hasil </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
akhir dari refleksi harus di-cache dalam bentuk delegasi yang berisi fungsi yang dikompilasi. Masuk akal juga untuk men-cache semua objek yang diperlukan dengan informasi tentang tipe di bidang tipe Anda yang disimpan di luar objek - pekerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada logika dalam hal ini. Akal sehat memberi tahu kita bahwa jika sesuatu dapat dikompilasi dan di-cache, maka ini harus dilakukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ke depan, harus dikatakan bahwa cache dalam bekerja dengan refleksi memiliki kelebihan, bahkan jika Anda tidak menggunakan metode yang diusulkan untuk mengkompilasi ekspresi. Sebenarnya, di sini saya hanya mengulangi tesis dari penulis artikel yang saya rujuk di atas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tentang kodenya. Mari kita lihat contoh yang didasarkan pada rasa sakit saya baru-baru ini yang harus saya hadapi dalam produksi serius sebuah organisasi kredit yang serius. Semua entitas fiktif sehingga tidak ada yang akan menebak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada entitas tertentu. Biarkan itu Kontak. Ada surat-surat dengan badan standar, dari mana parser dan hydrator membuat kontak yang sama. Sebuah surat tiba, kami membacanya, membongkar pasangan nilai kunci, membuat kontak, menyimpannya dalam database.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dasar. Misalkan kontak memiliki nama, umur, dan nomor kontak dari properti. Data-data ini dikirimkan dalam bentuk surat. Selain itu, bisnis menginginkan dukungan agar dapat dengan cepat menambahkan kunci baru untuk memetakan properti entitas untuk berpasangan di badan surat. Jika seseorang mencetak dalam templat atau jika sebelum rilis akan diperlukan untuk segera memulai pemetaan dari mitra baru, menyesuaikan dengan format baru. Kemudian kita bisa menambahkan korelasi pemetaan baru sebagai perbaikan data murah. Yaitu, contoh hidup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menerapkan, membuat tes. Bekerja</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak akan memberikan kode: ada banyak sumber, dan mereka tersedia di GitHub melalui tautan di akhir artikel. Anda dapat mengunduhnya, menyiksa mereka hingga tidak dapat dikenali dan mengukurnya, karena akan memengaruhi kasus Anda. Saya hanya akan memberikan kode dua metode templat yang membedakan hydrator, yang seharusnya cepat dari hydrator, yang seharusnya lambat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logikanya adalah sebagai berikut: metode templat menerima pasangan yang dibentuk oleh logika parser dasar. Level LINQ adalah parser dan logika dasar dari hydrator, membuat permintaan ke konteks db dan mencocokkan kunci dengan pasangan dari parser (untuk fungsi-fungsi ini, ada kode tanpa LINQ untuk perbandingan). Selanjutnya, pasangan ditransfer ke metode hidrasi utama dan nilai pasangan diatur ke properti entitas yang sesuai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Cepat" (Awalan cepat dalam tolok ukur):</font></font><br>
<br>
<pre><code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Contact <span class="hljs-title">GetContact</span>(<span class="hljs-params">PropertyToValueCorrelation[] correlations</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> contact = <span class="hljs-keyword">new</span> Contact();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> setterMapItem <span class="hljs-keyword">in</span> _proprtySettersMap)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> correlation = correlations.FirstOrDefault(x =&gt; x.PropertyName == setterMapItem.Key);<font></font>
                setterMapItem.Value(contact, correlation?.Value);<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> contact;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang dapat kita lihat, koleksi statis dengan setter properti digunakan - lambda yang dikompilasi yang memanggil entitas setter. </font><font style="vertical-align: inherit;">Dihasilkan oleh kode berikut:</font></font><br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">FastContactHydrator</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span>(Contact);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> type.GetProperties())<font></font>
            {<font></font>
                _proprtySettersMap[property.Name] = GetSetterAction(property);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Action&lt;Contact, <span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetSetterAction</span>(<span class="hljs-params">PropertyInfo property</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> setterInfo = property.GetSetMethod();
            <span class="hljs-keyword">var</span> paramValueOriginal = Expression.Parameter(property.PropertyType, <span class="hljs-string">"value"</span>);
            <span class="hljs-keyword">var</span> paramEntity = Expression.Parameter(<span class="hljs-keyword">typeof</span>(Contact), <span class="hljs-string">"entity"</span>);
            <span class="hljs-keyword">var</span> setterExp = Expression.Call(paramEntity, setterInfo, paramValueOriginal).Reduce();<font></font>
            <font></font>
            <span class="hljs-keyword">var</span> lambda = (Expression&lt;Action&lt;Contact, <span class="hljs-keyword">string</span>&gt;&gt;)Expression.Lambda(setterExp, paramEntity, paramValueOriginal);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> lambda.Compile();<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, jelas. </font><font style="vertical-align: inherit;">Kami berkeliling properti, membuat delegasi untuk mereka yang memanggil setter, dan menyimpannya. </font><font style="vertical-align: inherit;">Maka kami akan menelepon jika perlu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Lambat" (Awalan lambat dalam tolok ukur):</font></font><br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Contact <span class="hljs-title">GetContact</span>(<span class="hljs-params">PropertyToValueCorrelation[] correlations</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> contact = <span class="hljs-keyword">new</span> Contact();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> _properties)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> correlation = correlations.FirstOrDefault(x =&gt; x.PropertyName == property.Name);
                <span class="hljs-keyword">if</span> (correlation?.Value == <span class="hljs-literal">null</span>)
                    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                property.SetValue(contact, correlation.Value);<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> contact;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita segera berkeliling properti dan memanggil SetValue secara langsung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kejelasan dan sebagai referensi, saya menerapkan metode naif yang menulis nilai pasangan korelasinya langsung ke bidang entitas. </font><font style="vertical-align: inherit;">Awalannya adalah Manual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami menggunakan BenchmarkDotNet dan kami mempelajari produktivitas. </font><font style="vertical-align: inherit;">Dan tiba-tiba ... (spoiler bukan hasil yang tepat, detailnya di bawah)</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v1/by/o1/v1byo1sssukfywtxg_kaylvadwu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang kita lihat di sini? Metode yang menggunakan awalan Fast ternyata lebih lambat di hampir semua lintasan daripada metode dengan awalan Lambat. Ini berlaku untuk alokasi, dan untuk kecepatan. Di sisi lain, implementasi pemetaan yang cantik dan elegan menggunakan metode LINQ yang dirancang untuk tujuan ini, sebaliknya, sangat menguras kinerja. Perbedaan pesanan. Tren tidak berubah dengan jumlah lintasan yang berbeda. Perbedaannya hanya dalam skala. Dengan LINQ 4 hingga 200 kali lebih lambat, ada lebih banyak puing pada skala yang sama. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIPERBARUI</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Saya tidak bisa mempercayai mata saya, tetapi yang lebih penting, baik mata saya maupun kode saya tidak dipercaya oleh rekan kami - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Tikhonov 0x1000000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Setelah memeriksa ulang solusi saya, ia dengan cemerlang menemukan dan menunjukkan kesalahan yang saya lewatkan karena sejumlah perubahan dalam implementasi. Setelah memperbaiki bug yang ditemukan di pengaturan Moq, semua hasil jatuh ke tempatnya. Menurut hasil pengujian ulang, tren utama tidak berubah - LINQ mempengaruhi kinerja masih lebih kuat daripada refleksi. Namun, senang bekerja dengan mengkompilasi Ekspresi tidak sia-sia, dan hasilnya terlihat dalam alokasi dan runtime. Jalankan pertama, ketika bidang statis diinisialisasi, secara alami lebih lambat dalam metode "cepat", tetapi situasi berubah lebih jauh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah hasil dari tes ulang:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0a/k-/cj/0ak-cjqtjh3okpxobsdcrhgloqa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesimpulan: ketika menggunakan refleksi di suatu perusahaan, beralih ke trik tidak terlalu diperlukan - LINQ akan melahap kinerja lebih kuat. Namun demikian, dalam metode yang sangat banyak yang memerlukan optimasi, seseorang dapat mempertahankan refleksi dalam bentuk inisialisasi dan kompiler delegasi, yang kemudian akan memberikan logika "cepat". Jadi Anda bisa menjaga fleksibilitas refleksi, dan kecepatan aplikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode dengan tolok ukur tersedia di sini. Setiap orang dapat memeriksa ulang kata-kata saya: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HabraReflectionTests</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
PS: kode menggunakan IoC dalam pengujian, dan desain eksplisit di tolok ukur. Faktanya adalah bahwa dalam implementasi akhir, saya mengelompokkan semua faktor yang dapat mempengaruhi kinerja dan membuat kebisingan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPS: Terima kasih kepada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Tikhonov @ 0x1000000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mendeteksi kesalahan saya dalam pengaturan Moq, yang memengaruhi pengukuran pertama. </font><font style="vertical-align: inherit;">Jika ada pembaca yang memiliki karma yang cukup, silakan saja. </font><font style="vertical-align: inherit;">Pria itu berhenti, pria itu membaca, pria itu memeriksa ulang dan menunjukkan kesalahan. </font><font style="vertical-align: inherit;">Saya pikir ini layak untuk dihormati dan simpati. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPPS: terima kasih kepada pembaca yang teliti itu yang berhasil mencapai dasar gaya dan desain. </font><font style="vertical-align: inherit;">Saya menginginkan keseragaman dan kenyamanan. </font><font style="vertical-align: inherit;">Diplomasi presentasi meninggalkan banyak yang harus diinginkan, tetapi saya memperhitungkan kritik. </font><font style="vertical-align: inherit;">Saya meminta shell.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499546/index.html">Pengembangan firmware untuk kamera video analog EVR-Y2022F</a></li>
<li><a href="../id499548/index.html">Topeng - merawat orang lain atau ilusi keamanan?</a></li>
<li><a href="../id499550/index.html">Solusi Kode Rendah Ekosistem</a></li>
<li><a href="../id499556/index.html">Server Game di MS Orleans - Bagian 3: Ringkasan</a></li>
<li><a href="../id499560/index.html">Korektor tata letak Xswitcher untuk linux: langkah kedua</a></li>
<li><a href="../id499564/index.html">Coronavirus dalam video dan komentar YouTube</a></li>
<li><a href="../id499566/index.html">Augmentasi on the fly - alat penting dalam pelatihan jaringan saraf</a></li>
<li><a href="../id499570/index.html">Apa yang terjadi dengan transportasi pada akhir April dan kapan harus menunggu pemulihan</a></li>
<li><a href="../id499574/index.html">Julia → Iuliia. Semua Tentang Penerjemahan</a></li>
<li><a href="../id499576/index.html">Cara bekerja dengan kata kunci negatif di Yandex.Direct dan Google Ads [dan mengotomatiskan proses]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>