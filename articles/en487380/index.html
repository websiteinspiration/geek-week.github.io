<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹 🏮 🍼 Massive PostgreSQL query optimization. Kirill Borovikov (Tensor) ⛈️ 🖌️ 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The report presents some approaches that allow you to monitor the performance of SQL queries when there are millions of them per day , and hundreds of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Massive PostgreSQL query optimization. Kirill Borovikov (Tensor)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/487380/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The report presents some approaches that allow you </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to monitor the performance of SQL queries when there are millions of them per day</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and hundreds of controlled PostgreSQL servers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What technical solutions allow us to efficiently process such a volume of information, and how it facilitates the life of an ordinary developer.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/5XKbFb-l5Do" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Who is interested in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analyzing specific problems and different techniques for optimizing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL queries and solving typical DBA problems in PostgreSQL </font><font style="vertical-align: inherit;">? You </font><font style="vertical-align: inherit;">can also </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read a series of articles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on this topic.</font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/rj/lq/ao/rjlqaolzkdl1dwerrz6q1f41exs.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My name is Kirill Borovikov, I represent the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">company "Tensor"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Specifically, I specialize in working with databases in our company. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today I’ll tell you how we are doing query optimization, when you need not to “pick up” the performance of a single request, but to solve the problem en masse. When there are millions of requests, and you need to find some </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">approaches to solving</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this big problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, “Tensor” for our million customers is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLSI - our application</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a corporate social network, video communication solutions, for internal and external document management, accounting systems for bookkeeping and storage ... That is, such a “mega-combine” for integrated business management, which is more than 100 different internal projects.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To ensure that they all work and develop normally, we have 10 development centers throughout the country, they have more than </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 developers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have been working with PostgreSQL since 2008 and have accumulated a large amount of what we process - this is client data, statistical, analytical, data from external information systems - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more than 400TB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Only “in production” there are about 250 servers, and in total the database servers that we monitor are about 1000. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dx/sb/ej/dxsbejtgor4d4qc7u1cpkmxptx8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL is a declarative language. You describe not “how” something should work, but “what” you want to receive. DBMS knows better how to make JOIN - how to connect your tablets, what conditions to impose, what will go by index, what not ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some DBMSs accept hints: “No, connect these two tablets in such and such a queue”, but PostgreSQL doesn’t. This is the conscious position of the leading developers: “Better we’ll finish the query optimizer than let the developers use some kind of hint.” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But, despite the fact that PostgreSQL does not allow “outside” to control itself, it perfectly allows you to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">see what happens “inside”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when you execute your query and where it has problems. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k_/wc/q0/k_wcq0dayliwb4tturtbl3dmyre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, with what classic problems does the developer [come to DBA] usually? “Here we have fulfilled the request, and </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">everything is slow</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , everything hangs, something happens ... Some kind of trouble!” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reasons are almost always the same:</font></font><br>
<br>
<ul>
<li><b>  </b><br>
: «   SQL  10   JOIN...» —  ,       «»,     .    ,       (10    FROM)   - . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>]</li>
<li><b> </b><br>
     PostgreSQL,     «»  ,   —     «»  .       10 ,   10 ,  PostgreSQL      ,      . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>]</li>
<li><b>«»  </b><br>
          ,     , ,   .  … -   ,       .</li>
<li><b></b><br>
 ,         (INSERT, UPDATE, DELETE) —    .</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... And for everything else, we </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need a plan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! We need to see what is happening inside the server. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c8/ni/rt/c8nirti-tkun1t6z4sxgpnwfwbw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The query execution plan for PostgreSQL is a tree of the query execution algorithm in a textual representation. It is the algorithm that, as a result of the analysis by the planner, was recognized as the most effective. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each tree node is an operation: extracting data from a table or index, building a bitmap, joining two tables, joining, intersecting, or eliminating samples. Fulfillment of the request is a passage through the nodes of this tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To get a query plan, the easiest way is to execute the statement </font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. To get with all the real attributes, that is, actually execute a query based on - </font></font><code>EXPLAIN (ANALYZE, BUFFERS) SELECT ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bad point: when you execute it, it happens “here and now”, therefore it is suitable only for local debugging. If you take some high-loaded server, which is under a strong stream of data changes, and you see: “Ay! Here we are slower to </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xia</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a request. " Half an hour, an hour ago - while you were running and getting this request from the logs, carrying it again to the server, you have all the dataset and statistics changed. You execute it to debug - and it runs fast! And you cannot understand the why, why </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it was</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slow. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y9/-t/fu/y9-tfu3qhvhayjt86xoy02qy4ju.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to understand what was exactly at the moment when the request is executed on the server, smart people wrote the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto_explain module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is present in almost all of the most common PostgreSQL distributions, and you can simply activate it in the config file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If he understands that a request is being executed longer than the border that you told him, he takes a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“snapshot” of the plan for this request and writes them together in a log</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qh/cs/c1/qhcsc15sgsaruhdj6ghcjggfz7c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything seems to be fine now, we go to the log and see there ... [text footstep]. But we can’t say anything about him, except for the fact that this is an excellent plan, because it took 11ms to complete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything seems to be fine - but nothing is clear about what really happened. Apart from the total time, we don’t see much. Because to look at such a "latuha" plain text is generally beloved. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But even if it is beloved, albeit uncomfortable, but there are more major problems:</font></font><br>
<br>
<ul>
<li>   <b>    </b>  .     ,       Index Scan    — ,     -  .    ,    «»   , CTE —     « ».</li>
<li> : ,    , —  <b>   </b>.      , ,    ,  ,      loops —   .         .    ,  ,        ,      — - « ».</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under these circumstances, understand "Who is the weakest link?" </font><font style="vertical-align: inherit;">almost unrealistic. </font><font style="vertical-align: inherit;">Therefore, even the developers themselves in the "manual" write that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Understanding the plan is an art that needs to be learned, experience ..."</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But we have 1000 developers, and each of them will not pass this experience into their heads. </font><font style="vertical-align: inherit;">I, you, he - they know, and someone over there - is no longer there. </font><font style="vertical-align: inherit;">Maybe he will learn, or maybe not, but he needs to work now - and where would he get this experience.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plan visualization</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, we realized that in order to deal with these problems, we need a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">good visualization of the plan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[article]</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/ev/nz/3g/evnz3gitzrva603ckfpd42ilzas.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
We went first “around the market” - let's look on the Internet for what exists in general. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But, it turned out that relatively “live” solutions that are more or less developed, there are very few - literally, one thing: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explain.depesz.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from Hubert Lubaczewski. </font><font style="vertical-align: inherit;">At the entrance to the field "feed" a textual representation of the plan, it shows you a plate with the parsed data:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proper node working time</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">total time over the entire subtree</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the number of records that were retrieved and which was statistically expected</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the node body itself</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This service also has the ability to share the archive of links. You threw your plan there and say: “Hey, Vasya, here’s a link for you, something is wrong there.” </font></font><br>
<br>
<img src="https://habrastorage.org/webt/od/td/ik/odtdikeo22jwnlaxmizq2jodns0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there are some minor problems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, a huge amount of copy-paste. You take a piece of the log, put it there, and again and again. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is no analysis of the amount of data read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the very buffers that it displays </font></font><code>EXPLAIN (ANALYZE, BUFFERS)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, here we do not see. He simply does not know how to disassemble, understand and work with them. When you read a lot of data and understand that you can "decompose" incorrectly on a disk and cache in memory, this information is very important. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third negative point is the very weak development of this project. The commits are very small, it’s good if every six months, and the code in Perl.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/zu/o6/d9zuo6g5etaeqqdpfsozjtzv09c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this is all “lyrics”, one could somehow live with it, but there is one thing that has turned us away from this service. These are Common Table Expression (CTE) analysis errors and various dynamic nodes like InitPlan / SubPlan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you believe this picture, then we have the total execution time of each individual node is greater than the total execution time of the entire request. It's simple - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the generation time of this CTE was not subtracted from the CTE Scan node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Therefore, we no longer know the correct answer, how much did the CTE scan itself take. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/gt/8a/ujgt8auhv331ek_visf6ew7jslq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we realized that it was time to write our own - hooray! Each developer says: “Now we will write our own, it’ll just be super!”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They took a typical web services stack: the core on Node.js + Express, pulled Bootstrap and for beautiful diagrams - D3.js. </font><font style="vertical-align: inherit;">And our expectations were justified - we received the first prototype in 2 weeks:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">own plan parser</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
That is, now we can generally parse any plan from those generated by PostgreSQL.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correct analysis of dynamic nodes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - CTE Scan, InitPlan, SubPlan</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analysis of the distribution of buffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - where pages of data from memory are read, where from the local cache, where from disk</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">received visibility</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
So that it’s not “in the log” that it’s “digging”, but that you see the “weakest link” immediately in the picture.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ou/gb/jf/ougbjf30wnktdmvhpqtjj6feqto.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We got something like this - immediately with syntax highlighting. But usually our developers are no longer working with a complete presentation of the plan, but with a shorter one. After all, we have already parsed all the digits and threw them left and right, and in the middle we left only the first line: what kind of node it is: CTE Scan, CTE or Seq Scan generation by some type of label. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This abbreviated view is what we call the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plan template</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/do/j_/zgdoj_caxmbjnyiq_gkiy0cfniw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What else would be convenient? It would be convenient to see what proportion of which node of the total time is allocated to us - and just “stuck” the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pie chart</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the side </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We point to the node and see - with us, it turns out that Seq Scan took less than a quarter of the entire time, and the remaining 3/4 took CTE Scan. Horror! This is a small remark about the “rate of fire” of CTE Scan, if you actively use them in your queries. They are not very fast - they lose even to the usual table scan. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[article] </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[article]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
But usually such diagrams are more interesting, more complicated when we immediately point to a segment, and we see, for example, that more than half of all the time some Seq Scan “ate”. Moreover, there was some kind of Filter inside, a bunch of records were dropped on it ... You can directly throw this picture to the developer and say: “Vasya, everything is bad with you here! Understand, look - something is wrong! ” </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ul/4i/2q/ul4i2q_4iasvokxfdcwp7jd9tj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturally, there was a “rake”.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing they “stepped on” is the problem of rounding. The node time of each individual in the plan is indicated with an accuracy of 1 μs. And when the number of node cycles exceeds, for example, 1000 - after execution PostgreSQL divided it “up to”, then in the reverse calculation we get the total time “somewhere between 0.95ms and 1.05ms”. When the account is spent in microseconds - nothing yet, but when already for [milli] seconds - it is necessary to take this information into account when “untying” resources on the nodes of the plan “who has how much consumed whom”. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fp/ds/f9/fpdsf9qkt6t_0q810uqhmrivc-k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second point, more complex, is the distribution of resources (those same buffers) among dynamic nodes. This cost us the first 2 weeks on the prototype plus the plus of week 4.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To get this problem is quite simple - we make a CTE and we are supposedly reading something in it. In fact, PostgreSQL is smart and won't read anything right there. Then we take the first record from it, and the first hundred from the same CTE to it. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s5/fv/rg/s5fvrgut9bky4uqjgmawpm97ks4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We look at the plan and understand - strange, we have 3 buffers (data pages) were "consumed" in Seq Scan, another 1 in CTE Scan, and 2 more in the second CTE Scan. That is, if everything is simply summed up, we get 6, but from the plate we read only 3! CTE Scan does not read anything from anywhere, but works directly with the process memory. That is, there is clearly something wrong here! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, it turns out that here all those 3 pages of data that were requested from Seq Scan, first 1 asked for the 1st CTE Scan, and then the 2nd, and they read another 2. That is, 3 pages were read in total data, not 6.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3q/5q/nh/3q5qnhygdtg3fh1os2fa-1kixhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And this picture led us to understand that the implementation of the plan is no longer a tree, but just some kind of acyclic graph. </font><font style="vertical-align: inherit;">And we got a chart like this so that we understand "what-where it came from at all." </font><font style="vertical-align: inherit;">That is, here we created a CTE from pg_class, and asked for it twice, and almost all the time it took us up the branch when we asked for it the second time. </font><font style="vertical-align: inherit;">It is clear that reading the 101st record is much more expensive than just the 1st of the tablet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yg/kx/3o/ygkx3o3reytihnn6mkhyys3j7l8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We exhaled for a while. </font><font style="vertical-align: inherit;">They said: “Now, Neo, you know kung fu! </font><font style="vertical-align: inherit;">Now our experience is right on your screen. </font><font style="vertical-align: inherit;">Now you can use it. ” </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[article]</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Log Consolidation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our 1000 developers breathed a sigh of relief. But we understood that we only have hundreds of “battle” servers, and all this “copy-paste” by the developers is not at all convenient. We realized that we needed to collect it ourselves. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/1t/od/jl1todhk17wci0h_ekudinbrruw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, there is a regular module that can collect statistics, however, it also needs to be activated in the config - this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the pg_stat_statements module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But he did not suit us. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, it assigns </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">different QueryId</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the same queries on different schemes within the same database </font><font style="vertical-align: inherit;">. That is, if you first make </font></font><code>SET search_path = '01'; SELECT * FROM user LIMIT 1;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then </font></font><code>SET search_path = '02';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the same request, then there will be different entries in the statistics of this module, and I will not be able to collect general statistics precisely in the context of this request profile, without taking into account the schemes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second point that prevented us from using it is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lack of plans</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is, there is no plan, there is only the request itself. We see what was slowing down, but we don’t understand why. And here we return to the problem of a rapidly changing dataset. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last point is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lack of "facts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><b><font style="vertical-align: inherit;">"</font></b><font style="vertical-align: inherit;"> That is, it is impossible to address a specific instance of query execution - it is not there, there are only aggregated statistics. Although it’s possible to work with it, it’s just very difficult. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/sr/ij/7xsrijw56i20-dz5oiw0hurx9aq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, we decided to fight “copy-paste” and began to write a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">collector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The collector is connected via SSH, “pulls” a secure connection to the server with the database using the certificate and </font></font><code>tail -F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“clings” to it to the log file. So in this session</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we get a complete “mirror” of the entire log file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that the server generates. The load on the server itself is minimal, because we do not parse anything there, we simply mirror the traffic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since we already started writing the interface on Node.js, we continued to write the collector on it. And this technology paid off, because it’s very convenient to use JavaScript to work with poorly formatted text data, which is the log. And the Node.js infrastructure itself as a backend platform allows you to easily and conveniently work with network connections, and indeed with some kind of data streams.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accordingly, we “pull” two connections: the first is to “listen” to the log itself and take it to ourselves, and the second is to periodically ask the database. “But in the log it arrived that the plate with oid 123 was blocked,” but it doesn’t say anything to the developer, and it would be nice to ask the base “What is OID = 123 after all?” And so we periodically ask the base for something that we don’t know at home yet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/vi/ft/gtviftgv1xepi43a7dayhn5-kxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“You just didn’t take into account, there is a kind of elephant-like bees! ..” We started to develop this system when we wanted to monitor 10 servers. The most critical in our understanding, on which there were some problems that were difficult to deal with. But during the first quarter we got a hundred for monitoring - because the system “went in”, everyone wanted it, everyone was comfortable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this must be added, the data stream is large, active. Actually, we monitor what we are able to deal with - then we use it. We also use PostgreSQL as a data warehouse. But nothing is faster to “pour” data into it than </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is no </font><font style="vertical-align: inherit;">operator </font><font style="vertical-align: inherit;">yet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But just “pouring” the data is not really our technology. Because if you have about 50k requests per second on a hundred servers, then this will generate 100-150GB of logs per day for you. Therefore, we had to carefully “saw” the base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, we did the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partitioning every day</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because, by and large, nobody is interested in the correlation between the days. What is the difference that you had yesterday, if tonight you rolled out a new version of the application - and already some new statistics.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, we learned (were forced) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to write very, very quickly using</font></font><code>COPY</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is, not just </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">because it is faster than </font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but even faster. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rm/ik/nj/rmiknjdu2ydi-yrbk7v369qe8eu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third point - I had </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to abandon the triggers, respectively, and from Foreign Keys</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is, we do not have absolutely referential integrity. Because if you have a table on which there is a pair of FK, and you say in the database structure that “here is a log entry refers to FK, for example, a group of records”, then when you insert it, PostgreSQL has nothing left how to take and honestly execute </font></font><code>SELECT 1 FROM master_fk1_table WHERE ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the identifier that you are trying to insert - just to check that this entry is there, that you are not "breaking off" this Foreign Key with your insert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We get instead of one record in the target table and its indices, another plus of reading from all the tables to which it refers. And we don’t need it at all - our task is to write down as much as possible and as quickly as possible with the least load. So FK - down! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next point is aggregation and hashing. Initially, they were implemented in the database with us - after all, it’s convenient to immediately, when the record arrives, make </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“plus one”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in some kind of plate </font><b><font style="vertical-align: inherit;">right in the trigger</font></b><font style="vertical-align: inherit;"> . It’s good, convenient, but the same thing is bad - insert one record, but you are forced to read and write something else from another table. Moreover, not only that, read and write - and also do it every time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now imagine that you have a plate in which you simply count the number of requests that passed on a particular host:</font></font><code>+1, +1, +1, ..., +1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. And you, in principle, do not need it - all this can be </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">summed up in the memory on the collector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and sent to the database at a time </font></font><code>+10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, your logical integrity may “fall apart” in case of some problems, but this is almost an unrealistic case - because you have a normal server, it has a battery in the controller, you have a transaction log, a log on the file system ... In general, not worth it. It’s not worth the loss of productivity that you get due to the work of triggers / FK, the costs that you incur at the same time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Same thing with hashing. A certain request flies to you, you compute a certain identifier from the database from it, write to the database and then tell it to everyone. All is well, until at the time of recording a second person comes to you who wants to record it - and you have a lock, and this is already bad. Therefore, if you can take out the generation of some IDs on the client (relative to the database), it is better to do this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We were just ideally suited to use MD5 from the text - a request, plan, template, ... We calculate it on the collector side, and “pour” the already prepared ID into the database. MD5 length and daily partitioning allow us not to worry about possible collisions. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3c/yz/uz/3cyzuzpcxxmshllydd9cjcclc9i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in order to record all this quickly, we needed to modify the recording procedure itself.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How do you usually write data? We have some kind of dataset, we decompose it into several tables, and then COPY - first in the first, then in the second, in the third ... It is inconvenient, because we kind of write one data stream in three steps sequentially. Unpleasant. Is it possible to do faster? Can! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, it is enough just to decompose these flows in parallel with each other. It turns out that we have errors, requests, templates, locks, flying in separate streams ... - and we write it all in parallel. To do this, just </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keep the COPY channel permanently open on each individual target table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/v_/0z/vvv_0zw3lqqoqoznvaaqpvm19wq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, the collector </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always has a stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into which I can write the data I need. But so that the database sees this data, and someone does not hang in the locks, waiting for this data to be written, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY must be interrupted at a certain frequency</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For us, a period of the order of 100ms turned out to be the most effective - close and immediately open it again on the same table. And if we don’t have one stream at some peaks, then we do pooling to a certain limit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, we found out that for such a load profile, any aggregation when records are collected in packets is evil. Classical evil is </font></font><code>INSERT ... VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beyond 1000 records. Because at this moment you have a peak recording on the media, and everyone else who is trying to write something to disk will wait.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To get rid of such anomalies, simply do not aggregate anything, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not buffer at all</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And if buffering to disk does occur (fortunately, the Stream API in Node.js allows you to find out) - postpone this connection. </font><font style="vertical-align: inherit;">That's when the event comes to you that it is free again - write to it from the accumulated queue. </font><font style="vertical-align: inherit;">In the meantime, it’s busy - take the next free one from the pool and write to it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before implementing this approach to data recording, we had approximately 4K write ops, and in this way we reduced the load by 4 times. </font><font style="vertical-align: inherit;">Now they have grown another 6 times due to new observable bases - up to 100MB / s. </font><font style="vertical-align: inherit;">And now we store logs for the last 3 months in the amount of about 10-15TB, hoping that in just three months any developer can solve any problem.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We understand the problems</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But just collecting all this data is good, useful, appropriate, but not enough - you need to understand it. </font><font style="vertical-align: inherit;">Because it’s millions of different plans per day. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j6/kw/jg/j6kwjgsvci1xw-p_vgxpnq6ynag.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But millions are uncontrollable, you must first do "less." </font><font style="vertical-align: inherit;">And, first of all, it is necessary to decide how you will organize this “smaller” one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have identified for ourselves three key points:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">who</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sent this request. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, from which application he “flew”: web-interface, backend, payment system or something else.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> did this happen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On which particular server. </font><font style="vertical-align: inherit;">Because if you have several servers under one application, and suddenly one “blunted” (because the “disk has rotted”, “memory leaked”, some other trouble), then you need to specifically address the server.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problem manifested itself in one way or another</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand “who” sent us the request, we use a regular tool - setting a session variable: </font></font><code>SET application_name = '{bl-host}:{bl-method}';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- send the host name of the business logic from which the request is made, and the name of the method or application that initiated it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After we passed the “owner” of the request, it must be displayed in the log - for this we configure the variable </font></font><code>log_line_prefix = ' %m [%p:%v] [%d] %r %a'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anyone interested can </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">see in the manual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what this all means. </font><font style="vertical-align: inherit;">It turns out that we see in the log:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process and transaction identifiers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base name</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP of the person who sent this request</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and method name</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/9d/ms/_c/9dms_cgsmfbpgjiyndalqfyadf8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we realized that it is not very interesting to look at the correlation of one request between different servers. It happens infrequently when you have one application that equally craps here and there. But even if it is the same, look at any of these servers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“one server - one day” section</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> turned out to be enough for any analysis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first analytical section is the very </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“template”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - an abbreviated form of presentation of the plan, cleared of all numerical indicators. The second section is the application or method, and the third is the specific node of the plan that caused us problems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we moved from specific instances to templates, we immediately received two advantages:</font></font><br>
<br>
<ul>
<li><b>     </b><br>
         ,    .</li>
<li><b></b><br>
 ,  «»   - ,       .     ,     -  , ,   ,    —   ,  ,     —     , ,      .    ,  ,  .</li>
</ul><br>
<br>
<img src="https://habrastorage.org/webt/_1/gb/is/_1gbissbzxhnibnhpb5kb5ebuuu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The remaining methods are based on the indicators that we extract from the plan: how many times such a template occurred, the total and average time, how much data was read from the disk, and how much from the memory ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because you, for example, come to the analytics page by host, see - something too much on the disk to read the beginning. The disk on the server does not cope - and who reads from it? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And you can sort by any column and decide what you will deal with right now - with the load on the processor or the disk, or with the total number of requests ... Sorted, looked “top”, repaired - rolled out a new version of the application. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[video lecture]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
And right away you can see different applications that come with the same template from a request like</font></font><code>SELECT * FROM users WHERE login = 'Vasya'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Frontend, backend, processing ... And you wonder why the user should read the processing if he does not interact with him. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The opposite way is to immediately see from the application what it is doing. For example, a frontend is this, this, this, and this once an hour (just the timeline helps). And immediately the question arises - it seems to be not the business of the front-end to do something once an hour ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z7/z-/4n/z7z-4nvcqjd8xktjpl1ilja63eo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After some time, we realized that we lacked aggregated </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statistics in terms of plan nodes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We isolated from the plans only those nodes that do something with the data of the tables themselves (read / write them by index or not). In fact, relative to the previous picture, only one aspect is added - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how many records this node brought to us</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and how many it dropped (Rows Removed by Filter).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You do not have a suitable index on the plate, you make a request to it, it flies past the index, falls into Seq Scan ... you have filtered out all the records except one. And why do you need 100M filtered records per day, is it better to roll the index? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/bw/j9/tkbwj9b2v1gmeifbmblipiya86q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having examined all the plans by nodes, we realized that there are some typical structures in the plans that are very likely to look suspicious. And it would be nice to tell the developer: “Friend, here you first read by index, then sort it, and then cut it off” - as a rule, there is one record. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everyone who wrote queries with this pattern probably came across: “Give me the last order for Vasya, his date” And if you do not have an index by date, or the index used does not have a date, then go exactly on such a “rake” and step on .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But we know that this is a "rake" - so why not immediately tell the developer what he should do. </font><font style="vertical-align: inherit;">Accordingly, opening the plan now, our developer immediately sees a beautiful picture with prompts, where he is immediately told: "You have problems here and here, but they are solved this way." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the amount of experience that was needed to solve problems in the beginning and now has fallen significantly. </font><font style="vertical-align: inherit;">Here we have such a tool.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/1g/g6/si1gg6ffbtpgsb3q2ew_cgudqa4.jpeg"></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en487380/">https://habr.com/ru/post/en487380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487370/index.html">Real estate market analysis based on data from msgr.ru</a></li>
<li><a href="../en487372/index.html">IBM Data Science Professional Certificate Certified</a></li>
<li><a href="../en487374/index.html">Paul Graham: Fashionable Problems</a></li>
<li><a href="../en487376/index.html">10 useful Angular features you missed</a></li>
<li><a href="../en487378/index.html">Best Small Business Servers in 2020</a></li>
<li><a href="../en487384/index.html">Profession: front-end developer</a></li>
<li><a href="../en487386/index.html">Adaptation checklist as a soft entry tool</a></li>
<li><a href="../en487388/index.html">Natural development: how to move from e-learning to knowledge management</a></li>
<li><a href="../en487390/index.html">Web components without Shadow DOM</a></li>
<li><a href="../en487392/index.html">What does Magnet want to know about its customers?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>