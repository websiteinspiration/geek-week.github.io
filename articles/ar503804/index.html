<!doctype html>
<html class="no-js" lang="ar">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱 👩‍👦‍👦 🚴🏾 حكاية عن كيفية صنع آلة الزمن لقاعدة البيانات وكتابة استغلال 📄 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🤘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="يوم جيد ، هبر. 
 
 هل تساءلت يومًا عن كيفية تغيير الوقت داخل قاعدة البيانات؟ سهل؟ حسنًا ، في بعض الحالات ، نعم ، الأمر سهل - الأمر لينكس هو التاريخ وا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>حكاية عن كيفية صنع آلة الزمن لقاعدة البيانات وكتابة استغلال</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503804/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوم جيد ، هبر. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هل تساءلت يومًا عن كيفية تغيير الوقت داخل قاعدة البيانات؟ </font><font style="vertical-align: inherit;">سهل؟ </font><font style="vertical-align: inherit;">حسنًا ، في بعض الحالات ، نعم ، الأمر سهل - الأمر لينكس هو التاريخ والنقطة في القبعة. </font><font style="vertical-align: inherit;">وإذا كنت بحاجة إلى تغيير الوقت فقط داخل مثيل واحد من قاعدة البيانات إذا كان هناك العديد منهم على الخادم؟ </font><font style="vertical-align: inherit;">ولعملية قاعدة بيانات واحدة؟ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و؟ </font><font style="vertical-align: inherit;">آه ، هذا كل شيء ، يا صديقي ، هذه هي النقطة كلها.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيقول شخص ما أن هذا هو سور آخر ، لا علاقة له بالواقع ، والذي يتم وضعه بشكل دوري على حبري. </font><font style="vertical-align: inherit;">ولكن لا ، المهمة حقيقية تمامًا وتمليها ضرورة الإنتاج - اختبار الكود. </font><font style="vertical-align: inherit;">على الرغم من أنني أوافق ، يمكن أن تكون حالة الاختبار غريبة تمامًا - تحقق من كيفية عمل الرمز في تاريخ معين في المستقبل. </font><font style="vertical-align: inherit;">في هذه المقالة ، سأفحص بالتفصيل كيف تم حل هذه المهمة ، وفي الوقت نفسه التقط القليل من عملية تنظيم الاختبار وتقف ديف على قاعدة أوراكل. </font><font style="vertical-align: inherit;">قبل القراءة الطويلة ، كن مرتاحًا واطلب قطة.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خلفية</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لنبدأ بمقدمة قصيرة لتوضيح سبب ضرورة ذلك. كما تم الإعلان عنه بالفعل ، نكتب اختبارات عند تنفيذ التعديلات في قاعدة البيانات. تم تطوير النظام الذي يتم بموجبه إجراء هذه الاختبارات في البداية (أو ربما قبل البدء بقليل) من الصفر ، لذلك يكون كل منطق الأعمال داخل قاعدة البيانات ومكتوبًا في شكل إجراءات مخزنة بلغة pl / sql. ونعم ، يجلب لنا الألم والمعاناة. لكن هذا هو الإرث ، وعليك أن تتعايش معه. في الكود والنموذج الجدولي ، من الممكن تحديد كيفية تطور المعلمات داخل النظام بمرور الوقت ، وبعبارة أخرى ، قم بتعيين النشاط من التاريخ والتاريخ الذي يمكن تطبيقه فيه. ما يجب قطعه - التغيير الأخير في معدل ضريبة القيمة المضافة هو مثال حي على ذلك. وحتى يمكن التحقق من هذه التغييرات في النظام مسبقًا ،يجب نقل قاعدة بيانات بها مثل هذه التغييرات إلى تاريخ معين في المستقبل ، وستصبح معلمات الرمز في الجداول نشطة في "اللحظة الحالية". ونظرًا لخصائص النظام المدعوم ، لا يمكنك استخدام اختبارات وهمية من شأنها ببساطة تغيير القيمة المرجعة لتاريخ النظام الحالي باللغة التي تبدأ بها جلسة الاختبار.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذا ، حددنا السبب ، ثم نحتاج إلى تحديد </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كيفية</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحقيق الهدف. </font><font style="vertical-align: inherit;">للقيام بذلك ، سأقدم عرضًا استعاديًا صغيرًا لخيارات بناء مقاعد الاختبار للمطورين وكيف بدأت كل جلسة اختبار.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العصر الحجري</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ذات مرة ، عندما كانت الأشجار صغيرة ، وكانت الأطر المركزية كبيرة ، لم يكن هناك سوى خادم واحد للتطوير وكان يجري أيضًا اختبارات. </font><font style="vertical-align: inherit;">ومن حيث المبدأ ، كان كل هذا كافياً للجميع ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">640 كيلو تكفي للجميع!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
السلبيات: لتنفيذ مهمة تغيير الوقت ، كان من الضروري إشراك العديد من الأقسام ذات الصلة - مسؤولي النظام (هل تغير الوقت على الخادم الفرعي من الجذر) ، مسؤولي DBMS (هل أعيد تشغيل قاعدة البيانات) ، المبرمجين ( كان من الضروري الإخطار بحدوث تغيير في الوقت ، لأن جزءًا من الكود توقف عن العمل ، على سبيل المثال ، توقفت الرموز المميزة على الويب التي تم إصدارها سابقًا لاستدعاء طرق واجهة برمجة التطبيقات (API) عن أن تكون صالحة وقد يكون هذا مفاجئًا) ، المختبرين (يختبرون أنفسهم) ... عندما تعيد الوقت إلى الوقت الحاضر تم تكرار كل شيء بترتيب عكسي.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العصور الوسطى</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
مع مرور الوقت ، زاد عدد المطورين في القسم وتوقف الخادم في وقت ما عن أن يكون كافيًا. يرجع ذلك بشكل أساسي إلى حقيقة أن المطورين المختلفين يريدون تغيير نفس حزمة pl / sql وإجراء اختبار لها (حتى بدون تغيير الوقت). سمع المزيد والمزيد من السخط: "إلى متى! يكفي تحمل هذا! مصانع للعمال ، أرض للفلاحين! كل مبرمج لديه قاعدة بيانات! " ومع ذلك ، إذا كان لديك عدد قليل من تيرابايت من قاعدة بيانات المنتجات ، و 50-100 مطور ، إذن بصراحة في هذا النموذج ، فإن المتطلبات ليست حقيقية للغاية. ولا يزال الجميع يرغبون في ألا يتخلف الاختبار وقاعدة التطوير كثيرًا عن المبيعات ، سواء من حيث الهيكل أو البيانات داخل الجداول. لذلك كان هناك خادم منفصل للاختبار ، دعنا نسميها مرحلة ما قبل الإنتاج. تم بناؤه من خادمين متطابقين ،حيث تم البيع لاستعادة قاعدة البيانات من باكز RMAN واستغرق الأمر حوالي 2-2.5 أيام. بعد الاسترداد ، قامت قاعدة البيانات بإخفاء هوية البيانات الشخصية وغيرها من البيانات المهمة وتم تطبيق الحمل من تطبيقات الاختبار على هذا الخادم (بالإضافة إلى عمل المبرمجين أنفسهم دائمًا مع الخادم الذي تمت استعادته مؤخرًا). تم ضمان العمل مع الخادم المطلوب باستخدام موارد ip للكتلة المدعومة من خلال corosync (جهاز تنظيم ضربات القلب). بينما يعمل الجميع مع الخادم النشط ، على العقدة الثانية ، يبدأ استرداد قاعدة البيانات مرة أخرى وبعد 2-3 أيام يغيرون الأماكن مرة أخرى.تم ضمان العمل مع الخادم المطلوب باستخدام موارد ip للكتلة المدعومة من خلال corosync (جهاز تنظيم ضربات القلب). بينما يعمل الجميع مع الخادم النشط ، على العقدة الثانية ، يبدأ استرداد قاعدة البيانات مرة أخرى وبعد 2-3 أيام يغيرون الأماكن مرة أخرى.تم ضمان العمل مع الخادم المطلوب باستخدام موارد ip للكتلة المدعومة من خلال corosync (جهاز تنظيم ضربات القلب). بينما يعمل الجميع مع الخادم النشط ، على العقدة الثانية ، يبدأ استرداد قاعدة البيانات مرة أخرى وبعد 2-3 أيام يغيرون الأماكن مرة أخرى.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من العيوب الواضحة: تحتاج إلى خادمين ومرتين من الموارد (القرص بشكل رئيسي) أكثر من المنتج. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الإيجابيات: تشغيل واختبار تغيير الوقت - يمكن إجراؤه على الخادم الثاني ، على الخادم الرئيسي في هذا الوقت يعيش المطورين ويباشرون أعمالهم. </font><font style="vertical-align: inherit;">يحدث تغيير الخادم فقط عندما تكون قاعدة البيانات جاهزة ، ويكون وقت تعطل بيئة الاختبار ضئيلاً.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عصر التقدم العلمي والتكنولوجي</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عندما انتقلنا إلى قاعدة بيانات 11g Release 2 ، قرأنا عن تقنية مثيرة للاهتمام توفرها Oracle تحت اسم CloneDB. خلاصة القول هي أن النسخ الاحتياطية لقاعدة بيانات المنتج (هناك نسخة مباشرة من ملفات بيانات المنتج) يتم تخزينها على خادم خاص ، والتي تنشر بعد ذلك هذه المجموعة من ملفات البيانات عبر DNFS (NFS المباشر) إلى أي عدد من الخوادم بشكل أساسي ، ولا تحتاج إلى وجود خادم على الخادم نفس الحجم من الأقراص ، لأنه يتم تنفيذ نهج النسخ عند الكتابة: تستخدم قاعدة البيانات مشاركة شبكة مع ملفات البيانات من خادم النسخ الاحتياطي لقراءة البيانات في الجداول ، وتكتب التغييرات على ملفات البيانات المحلية على خادم dev نفسه. بشكل دوري ، يتم "التقيد بالمواعيد النهائية" للخادم بحيث لا تنمو ملفات البيانات المحلية كثيرًا ولا ينتهي المكان. عند تحديث الخادم ، يتم أيضًا إلغاء تخصيص البيانات في الجداول ،في هذه الحالة ، تقع جميع تحديثات الجدول في ملفات البيانات المحلية وتتم قراءة هذه الجداول من الخادم المحلي ، وتتم قراءة جميع الجداول الأخرى عبر الشبكة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
السلبيات: لا يزال هناك خادمان (لضمان إجراء تحديثات سلسة مع الحد الأدنى من وقت التعطل للمستهلكين) ، ولكن الآن يتم تقليل حجم الأقراص بشكل كبير. لتخزين باكز على كرة nfs ، تحتاج إلى خادم آخر بحجم + - كمنتج ، ولكن يتم تقليل وقت تنفيذ التحديث نفسه (خاصة عند استخدام باكز إضافي). يؤدي التواصل مع كرة nfs إلى إبطاء عمليات قراءة IO بشكل ملحوظ. لاستخدام تقنية CloneDB ، يجب أن تكون القاعدة إصدار Enterprise ؛ في حالتنا ، كان علينا تنفيذ إجراء الترقية على أسس الاختبار في كل مرة. لحسن الحظ ، يتم استثناء قواعد بيانات الاختبار من سياسات ترخيص Oracle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الإيجابيات: تستغرق عملية استعادة قاعدة من bakup أقل من يوم واحد (لا أتذكر الوقت بالضبط).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تغيير الوقت: لا تغييرات رئيسية. </font><font style="vertical-align: inherit;">على الرغم من أنه بحلول هذا الوقت ، كانت البرامج النصية قد تم إجراؤها بالفعل لتغيير الوقت على الخادم وإعادة تشغيل قاعدة البيانات من أجل القيام بذلك دون جذب </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">انتباه ترتيب</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المسؤولين.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عصر التاريخ الجديد</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من أجل توفير مساحة أكبر على القرص وجعل قراءة البيانات في وضع عدم الاتصال ، قررنا تنفيذ إصدار CloneDB (مع الفلاش باك واللقطات) باستخدام نظام الملفات مع الضغط. </font><font style="vertical-align: inherit;">خلال الاختبارات الأولية ، وقع الاختيار على ZFS ، على الرغم من عدم وجود دعم رسمي لها في نواة Linux (اقتباس من </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المقالة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) للمقارنة ، نظرنا أيضًا في BTRFS (b-tree fs) ، الذي تروج له Oracle ، ولكن نسبة الضغط كانت أقل مع نفس استهلاك وحدة المعالجة المركزية وذاكرة الوصول العشوائي في الاختبارات. لتمكين دعم ZFS على RHEL5 ، تم بناء نواة خاصة به تعتمد على نواة المؤسسة غير القابلة للكسر ، وعلى محاور ونواة أحدث يمكنك ببساطة استخدام نواة UEK الجاهزة. يعتمد تنفيذ قاعدة الاختبار هذه أيضًا على آلية COW ، ولكن على مستوى لقطات نظام الملفات. يتم توفير جهازين للقرص إلى الخادم ، في أحدهما ، يتم إنشاء تجمع zfs ، حيث يتم من خلال RMAN إنشاء قاعدة بيانات احتياطية إضافية من البيع ، وبما أننا نستخدم الضغط ، فإن القسم يأخذ أقل من الإنتاج.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم تثبيت النظام على جهاز القرص الثاني والباقي ضروري للخادم وقاعدة البيانات نفسها للعمل ، على سبيل المثال ، أقسام التراجع ودرجة الحرارة. في أي وقت ، يمكنك إنشاء لقطة من تجمع zfs ، والتي تفتح بعد ذلك كقاعدة بيانات منفصلة. يستغرق إنشاء لقطة بضع ثوانٍ. انه سحر! ويمكن إمالة قواعد البيانات هذه من حيث المبدأ كثيرًا ، إذا كان الخادم فقط لديه ذاكرة وصول عشوائي كافية لجميع المثيلات وحجم تجمع zfs نفسه (لتخزين التغييرات في ملفات البيانات أثناء إزالة الشخصية وأثناء دورة حياة استنساخ قاعدة البيانات). الوقت الرئيسي لتحديث قاعدة الاختبار هو تشغيل إزالة تخصيص البيانات ، ولكنه يناسب أيضًا في 15-20 دقيقة. هناك تسارع كبير.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سلبيات: على الخادم لا يمكنك تغيير الوقت ببساطة عن طريق ترجمة وقت النظام ، لأنه بعد ذلك ستقع جميع مثيلات قاعدة البيانات التي تعمل على هذا الخادم في هذا الوقت دفعة واحدة. تم العثور على حل لهذه المشكلة وسيتم وصفه في القسم المناسب. بالمضي قدمًا ، سأقول إنه يسمح لك بتغيير الوقت داخل مثيل واحد فقط من قاعدة البيانات (نهج تغيير الوقت </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكل مثيل</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) دون التأثير على الباقي على نفس الخادم. </font><font style="vertical-align: inherit;">والوقت على الخادم نفسه لا يتغير سواء. </font><font style="vertical-align: inherit;">هذا يلغي الحاجة إلى برنامج نصي جذري لتغيير الوقت على الخادم. </font><font style="vertical-align: inherit;">أيضًا في هذه المرحلة ، يتم تنفيذ أتمتة تغيير الوقت للحالات عبر Jenkins CI ويتم منح المستخدمين (فرق التطوير التي تتحدث نسبيًا) الذين يمتلكون كشكهم حقوق الوظائف التي يمكنهم من خلالها تغيير الوقت بأنفسهم ، وتحديث المقصورة إلى الحالة الحالية مع المبيعات ، عمل لقطات واستعادة (استرجاع) القاعدة إلى اللقطة التي تم إنشاؤها سابقًا.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عصر التاريخ الحديث</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
مع ظهور Oracle 12c ، ظهرت تقنية جديدة - قواعد بيانات قابلة للتوصيل ، ونتيجة لذلك ، قواعد بيانات حاويات (cdb). باستخدام هذه التقنية ، ضمن مثيل مادي واحد ، يمكن إنشاء العديد من قواعد البيانات "الافتراضية" التي تشترك في مساحة ذاكرة مشتركة للمثيل. الإيجابيات: يمكنك حفظ الذاكرة للخادم (وزيادة الأداء العام لقاعدة البيانات الخاصة بنا ، لأن كل الذاكرة التي كانت مشغولة من قبل ، على سبيل المثال ، 5 حالات مختلفة ، يمكن مشاركتها لجميع حاويات pdb المنشورة داخل cdb ، وسوف يستخدمونها فقط عندما يحتاجون إليها حقًا ، وليس كما كان في المرحلة السابقة ، عندما "كل" حجبت الذاكرة المخصصة لها وعندما كان نشاط أحد الاستنساخ منخفضًا ، لم يتم استخدام الذاكرة بشكل فعال ، وبعبارة أخرى ، كانت خاملة).لا تزال ملفات البيانات من pdb مختلفة تكمن في تجمع zfs ، وعند نشر المستنسخات ، يستخدمون نفس آلية لقطة zfs. في هذه المرحلة ، اقتربنا بشكل كافٍ من القدرة على منح قاعدة بيانات المطورين لكل مطور تقريبًا. لا يتطلب تغيير الوقت في هذه المرحلة إعادة تشغيل قاعدة البيانات ويعمل بدقة عالية فقط لتلك العمليات التي تحتاج إلى تغيير الوقت ؛ لا يتأثر جميع المستخدمين الآخرين الذين يعملون مع قاعدة البيانات هذه بأي شكل من الأشكال.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ناقص: لا يمكنك استخدام نهج تغيير الوقت </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكل مثيل</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من المرحلة السابقة ، لأن لدينا مثيل واحد الآن. ومع ذلك ، تم العثور على حل لهذه الحالة. وكان هذا على وجه التحديد بمثابة الدافع لكتابة هذا المقال. واستشرافا للمستقبل ، سأقول أنه تغيير الوقت </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكل</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نهج </font><i><font style="vertical-align: inherit;">عملية ،</font></i><font style="vertical-align: inherit;"> أي في كل عملية قاعدة بيانات ، يمكنك تعيين وقتك الفريد بشكل عام.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في هذه الحالة ، تحدد جلسة اختبار نموذجية مباشرة بعد الاتصال بقاعدة البيانات الوقت المناسب في بداية عملها ، وتجري الاختبارات وتعيد الوقت في النهاية. يعد إرجاع الوقت ضروريًا لسبب واحد بسيط: لا تنتهي بعض عمليات قاعدة بيانات Oracle عند قطع عميل قاعدة البيانات عن الخادم ، فهذه عمليات خادم تسمى خوادم مشتركة ، والتي ، على عكس العمليات المخصصة ، يتم تشغيلها عند بدء تشغيل خادم قاعدة البيانات ويعيش إلى أجل غير مسمى (في الوضع المثالي صورة العالم). إذا تركت الوقت تغير في عملية الخادم هذه ، فإن اتصالًا آخر سيتم تقديمه في هذه العملية سيتلقى وقتًا خاطئًا.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في نظامنا ، يتم استخدام الخوادم المشتركة كثيرًا ، لأنه حتى 11 جرامًا ، لم يكن هناك أي حل مناسب لنظامنا لتحمل الحمل العالي (في 11 جرامًا ظهر DRCP - تجمع اتصال مقيم في قاعدة البيانات). وإليك السبب - يوجد حد فرعي في إجمالي عدد عمليات الخادم التي يمكن إنشاؤها في كل من الوضع المخصص والمشترك. يتم إنشاء العمليات المخصصة بشكل أبطأ مما يمكن لقاعدة البيانات إصدار عملية مشتركة جاهزة بالفعل من مجموعة العمليات المشتركة ، مما يعني أنه عندما تصل اتصالات جديدة باستمرار (خاصة إذا كانت العملية تقوم ببعض العمليات البطيئة الأخرى) ، فإن العدد الإجمالي للعمليات سيزداد. عند الوصول إلى الحد الأقصى للجلسات / العمليات ، تتوقف قاعدة البيانات عن خدمة الاتصالات الجديدة ويحدث الانهيار.أتاح لنا الانتقال إلى استخدام مجموعة من العمليات المشتركة تقليل عدد العمليات الجديدة على الخادم عند الاتصال.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذا هو المكان الذي تكتمل فيه مراجعة تقنيات بناء قواعد بيانات الاختبار ، ويمكننا أخيرًا البدء في تنفيذ خوارزميات تغيير الوقت لقاعدة البيانات نفسها.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نهج المثال المزيف</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كيف تغير الوقت داخل قاعدة البيانات؟ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كان أول ما يتبادر إلى الذهن هو إنشاء نظام يحتوي على كل كود منطق الأعمال ، ووظيفته الخاصة ، والتي تتداخل مع وظائف اللغة التي تعمل مع الوقت (sysdate ، current_date ، وما إلى ذلك) ، وفي ظل ظروف معينة ، تبدأ في إعطاء قيم أخرى ، على سبيل المثال ، يمكنك تعيين القيم من خلال سياق الجلسة في بداية التشغيل التجريبي. لم ينجح ذلك ، لم تتداخل وظائف اللغة المضمنة مع وظائف المستخدم. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بعد ذلك ، تم اختبار أنظمة المحاكاة الافتراضية الخفيفة (Vserver ، OpenVZ) والحاويات عبر عامل الميناء. لا يعمل أيضًا ، فهم يستخدمون نفس النواة التي يستخدمها النظام المضيف ، مما يعني أنهم يستخدمون نفس قيم مؤقت النظام. السقوط مرة أخرى.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وهنا لا أخشى المجيء لإنقاذ هذه الكلمة ، وهو اختراع رائع لعالم Linux - إعادة تعريف / اعتراض الوظائف في مرحلة التحميل الديناميكي للكائنات المشتركة. ومن المعروف للعديد من الحيل مع LD_PRELOAD. في متغير البيئة LD_PRELOAD ، يمكنك تحديد المكتبة التي سيتم تحميلها قبل كل الآخرين التي تحتاجها العملية ، وإذا كانت هذه المكتبة تحتوي على أحرف تحمل نفس الاسم على سبيل المثال في libc القياسي ، والذي سيتم تحميله لاحقًا ، فسيظهر جدول استيراد الرمز للتطبيق إذا كانت الوظيفة يوفر وحدة استبدال لدينا. وهذا بالضبط ما </font><i><font style="vertical-align: inherit;">تفعله</font></i><font style="vertical-align: inherit;"> مكتبة مشروع </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libfaketime</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التي بدأنا استخدامها من أجل بدء تشغيل قاعدة البيانات في وقت مختلف بشكل منفصل عن النظام. تفتقد المكتبة المكالمات التي تتعلق بالعمل مع مؤقت النظام والحصول على وقت وتاريخ النظام. للتحكم في مقدار تحركات الوقت بالنسبة لتاريخ الخادم الحالي أو من أي نقطة زمنية يجب أن يمر الوقت داخل العملية - يتم التحكم في كل شيء بواسطة متغيرات البيئة التي يجب ضبطها مع LD_PRELOAD. لتنفيذ تغيير الوقت ، قمنا بتنفيذ مهمة على خادم Jenkins ، الذي يدخل خادم قاعدة البيانات ويعيد تشغيل DBMS إما مع أو بدون متغيرات البيئة المعينة لـ libfaketime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
مثال خوارزمية لبدء قاعدة بيانات بوقت استبدال:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/<span class="hljs-built_in">local</span>/lib/faketime/libfaketime.so
<span class="hljs-built_in">export</span> FAKETIME=<span class="hljs-string">"+1d"</span>
<span class="hljs-built_in">export</span> FAKETIME_NO_CACHE=1<font></font>
<font></font>
<span class="hljs-variable">$ORACLE_HOME</span>/bin/sqlplus @/home/oracle/scripts/restart_db.sql
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وإذا كنت تعتقد أن كل شيء يعمل على الفور ، فأنت مخطئ للغاية. </font><font style="vertical-align: inherit;">لأنه ، كما اتضح ، يتحقق من تلك المكتبات التي يتم تحميلها في العملية عند بدء تشغيل DBMS. </font><font style="vertical-align: inherit;">وفي التنبيه ، يبدأ في استياء التزوير الملاحظ ، في حين أن القاعدة لا تبدأ. </font><font style="vertical-align: inherit;">الآن لا أتذكر بالضبط كيف أتخلص منه ، هناك بعض المعلمات التي يمكن أن تعطل تنفيذ عمليات التحقق من الصحة عند بدء التشغيل.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نهج وهمية لكل عملية</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بقيت الفكرة العامة لتغيير الوقت فقط خلال عملية واحدة واحدة - استخدم libfaketime. </font><font style="vertical-align: inherit;">نبدأ قاعدة البيانات بمكتبة محملة مسبقًا فيها ، ولكننا نضع إزاحة صفر عند بدء التشغيل ، والتي يتم نشرها بعد ذلك في جميع عمليات DBMS. </font><font style="vertical-align: inherit;">ثم ، داخل جلسة الاختبار ، قم بتعيين متغير البيئة لهذه العملية فقط. </font><font style="vertical-align: inherit;">Pff ، شيء تجاري.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ومع ذلك ، بالنسبة لأولئك الذين هم على دراية بلغة pl / sql ، فإن كل هذه الفكرة واضحة على الفور. لأن اللغة محدودة للغاية ومناسبة بشكل أساسي للمهام عالية المستوى. لا يمكن تنفيذ برمجة النظام هناك. على الرغم من وجود بعض العمليات ذات المستوى المنخفض (على سبيل المثال ، العمل مع شبكة ، العمل مع الملفات) في شكل حزم dbms / utl للنظام مثبتة مسبقًا. طوال الوقت الذي عملت فيه مع Oracle ، قمت بإجراء هندسة عكسية للحزم المثبتة مسبقًا عدة مرات ، وتم إخفاء رمز بعضها عن أعين الغرباء (يطلق عليهم ملفوفة). إذا تم منعك من مشاهدة شيء ما ، فإن الإغراء لمعرفة كيفية ترتيبه في الداخل يزداد فقط. ولكن في كثير من الأحيان ، حتى بعد الغلاف ، لا يوجد دائمًا شيء يمكن رؤيته ، لأن وظائف هذه الحزم يتم تنفيذها </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كواجهة c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> للمكتبات على القرص.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في المجموع ، اتصلنا بمرشح واحد للتنفيذ - التكنولوجيا </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالإجراءات الخارجية</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكن للمكتبة المصممة بطريقة خاصة تصدير الطرق ، والتي يمكن بعد ذلك استدعاء قاعدة بيانات أوراكل عبر pl / sql. يبدو واعداً. مرة واحدة فقط قابلت هذا في دورات plsql المتقدمة ، لذلك تذكرت عن بعد كيفية طهيها. وهذا يعني أنه من الضروري قراءة الوثائق. قرأته - وعلى الفور اكتئب. لأن تحميل مثل هذه المكتبة المخصصة يذهب في عملية وكيل منفصلة من خلال مستمع قاعدة البيانات ، والتواصل مع هذا الوكيل يمر عبر dlink. لذا بكت فكرتنا لتعيين متغير بيئة داخل عملية قاعدة البيانات نفسها. وكل هذا يتم لأسباب أمنية. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
صورة من الوثائق توضح كيفية عملها:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pu/1h/07/pu1h07d6fvy1wwetq4deujbpnga.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نوع مكتبة so / dll ليس مهمًا جدًا ، ولكن لسبب ما فإن الصورة مخصصة فقط لنظام التشغيل Windows. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ربما لاحظ شخص ما هنا فرصة محتملة أخرى. نعم ، نعم ، هذه جافا. تتيح لك Oracle كتابة رمز الإجراء المخزن ليس فقط في plsql ، ولكن أيضًا في java ، والتي يتم تصديرها بنفس الطريقة التي يتم بها تصدير طرق plsql. بشكل دوري ، قمت بذلك ، لذلك لا ينبغي أن تكون هناك مشكلة في ذلك. ولكن بعد ذلك تم إخفاء مأزق آخر. تعمل Java مع نسخة من البيئة ، وتسمح لك بالحصول فقط على متغيرات البيئة التي كانت عليها عملية JVM عند بدء التشغيل. يرث JVM المدمج متغيرات البيئة لعملية قاعدة البيانات ، ولكن هذا كل شيء. لقد رأيت نصائح على الإنترنت حول كيفية تغيير الخريطة للقراءة فقط من خلال التفكير ، ولكن ما هي النقطة ، لأنها لا تزال مجرد نسخة. أي أن المرأة تركت مرة أخرى بلا شيء.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ومع ذلك ، فإن Java ليست مجرد فروًا قيمًا. باستخدامه ، يمكنك إنتاج العمليات من داخل عملية قاعدة البيانات. على الرغم من أنه يجب حل جميع العمليات غير الآمنة بشكل منفصل من خلال آلية منح جافا ، والتي تتم باستخدام حزمة dbms_java. من داخل كود plsql ، يمكنك الحصول على معرف العملية الخاص بعملية الخادم الحالية التي يتم فيها تشغيل الكود ، وذلك باستخدام طريقة عرض النظام v $ session و v $ process. علاوة على ذلك ، يمكننا أن نفرز بعض عمليات الأطفال من جلستنا للقيام بشيء مع هذا pid. للبدء ، استنتجت ببساطة جميع متغيرات البيئة الموجودة داخل عملية قاعدة البيانات (لاختبار الفرضية)</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span><font></font>
<font></font>
awk <span class="hljs-string">'BEGIN {RS="\0"; ORS="\n"} $0'</span> <span class="hljs-string">"/proc/<span class="hljs-variable">$pid</span>/environ"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
استنتج جيدا ، ثم ماذا. لا يزال من المستحيل تغيير المتغيرات في ملف البيئة ، هذه هي البيانات التي تم نقلها إلى العملية عند بدئها ويتم قراءتها فقط. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لقد بحثت في الإنترنت على stackoverflow "كيفية تغيير متغير بيئة في عملية أخرى." كانت معظم الإجابات أنه كان مستحيلًا ، ولكن كان هناك إجابة واحدة وصفت هذه الفرصة بأنها اختراق مخترق وقذر. وكان هذا الجواب </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ألبرت أينشتاين</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gdb. يمكن أن يقوم المصحح بالربط بأي عملية مع معرفة معرف العملية وتنفيذ أي وظيفة / إجراء موجود فيها كرمز تم تصديره بشكل عام ، على سبيل المثال ، من بعض المكتبات. في libc ، هناك وظائف للعمل مع متغيرات البيئة ، ويتم تحميل libc في أي عملية لقاعدة بيانات Oracle (وعمليًا أي برنامج على لينكس).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذه هي الطريقة التي يتم بها تعيين متغير البيئة في عملية خارجية (تحتاج إلى تسميته من الجذر بسبب ptrace المستخدمة):</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
env_name=<span class="hljs-variable">$2</span>
env_val=<span class="hljs-string">"<span class="hljs-variable">$3</span>"</span><font></font>
<font></font>
out=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (int) setenv("'</span><span class="hljs-variable">$env_name</span><span class="hljs-string">'", "'</span><span class="hljs-string">"<span class="hljs-variable">$env_val</span>"</span><span class="hljs-string">'", 1)'</span> -ex <span class="hljs-string">"detach"</span> 2&gt;&amp;1`
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أيضا ، لرؤية متغيرات البيئة داخل عملية gdb مناسبة أيضًا. </font><font style="vertical-align: inherit;">كما ذكرنا سابقًا ، فإن ملف البيئة من / proc / pid / يعرض فقط المتغيرات التي كانت موجودة في بداية العملية. </font><font style="vertical-align: inherit;">وإذا كانت العملية قد خلقت شيئًا أثناء عملها ، فيمكن رؤية ذلك فقط من خلال المصحح:</font></font><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
var_name=<span class="hljs-variable">$2</span><font></font>
<font></font>
var_value=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (char*) getenv("'</span><span class="hljs-variable">$var_name</span><span class="hljs-string">'")'</span> -ex <span class="hljs-string">'detach'</span> | egrep <span class="hljs-string">'^\$1 ='</span>`<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> == <span class="hljs-string">'$1 = 0x0'</span> ]
<span class="hljs-keyword">then</span>
  <span class="hljs-comment"># variable empty or does not exist</span>
  <span class="hljs-built_in">echo</span> -n
<span class="hljs-keyword">else</span>
  <span class="hljs-comment"># gdb returns $1 = hex_value "string value"</span>
  var_hex=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | awk <span class="hljs-string">'{print $3}'</span>`<font></font>
  var_value=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | sed -r -e <span class="hljs-string">'s/^\$1 = '</span><span class="hljs-variable">$var_hex</span><span class="hljs-string">' //;s/^"//;s/"$//'</span>`<font></font>
  <font></font>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span>
<span class="hljs-keyword">fi</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذا ، فإن الحل موجود بالفعل في جيبنا - من خلال جافا نفرز عملية المصحح ، التي تذهب إلى العملية التي ولدت ذلك وتعيين متغير البيئة المرغوبة لها ثم ينتهي (يقوم مور بعمله - يمكن للمور المغادرة). </font><font style="vertical-align: inherit;">ولكن كان هناك شعور بأنه نوع من العكاز. </font><font style="vertical-align: inherit;">كنت أرغب في شيء أكثر أناقة. </font><font style="vertical-align: inherit;">سيكون الأمر متشابهًا إلى حد ما لإجبار عملية قاعدة البيانات نفسها على تعيين متغيرات البيئة دون هجوم خارجي.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بيضة في بطة ، بطة في أرنب ...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ثم يأتي شخص ما إلى الإنقاذ ، نعم ، لقد خمنت ذلك بشكل صحيح ، مرة أخرى جافا ، وهي JNI (واجهة جافا الأصلية). </font><font style="vertical-align: inherit;">يسمح لك JNI باستدعاء طرق C الأصلية داخل JVM. </font><font style="vertical-align: inherit;">يتم إصدار الكود بطريقة خاصة في شكل كائن مشترك للمكتبة ، والذي يقوم JVM بتحميله ، بينما يتم تعيين الطرق الموجودة في المكتبة لطرق جافا داخل الفصل المعلن عنها مع المعدل الأصلي. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
حسنًا ، حسنًا ، نحن نكتب فصلًا (في الواقع ، هذه مجرد قطعة عمل):</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Posix</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setenv</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">boolean</span> overwrite)</span></span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getenv</span><span class="hljs-params">(String key)</span></span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stub</span><span class="hljs-params">()</span> 
    </span>{<font></font>
        <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بعد ذلك ، قم بتجميعه واحصل على الملف h الذي تم إنشاؤه من المكتبة المستقبلية:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#  </span><font></font>
javac Posix.java<font></font>
<font></font>
<span class="hljs-comment">#   Posix.h        JNI</span><font></font>
javah Posix<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بعد استلام ملف الرأس ، نكتب النص لكل طريقة:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Posix.h"</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_Posix_setenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key, jstring value, jboolean overwrite)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, value, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> err = setenv(k, v, overwrite);<font></font>
<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, key, k);<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, value, v);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> err;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_Posix_getenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = getenv(k);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> (*env)-&gt;NewStringUTF(env, v);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وتجميع المكتبة</font></font><br>
<br>
<pre><code class="bash hljs">gcc -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include"</span> -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include/linux"</span> -fPIC Posix.c -shared -o libPosix.so -Wl,-soname -Wl,--no-whole-archive<font></font>
<font></font>
strip libPosix.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لكي تقوم Java بتحميل المكتبة الأصلية ، يجب أن يتم العثور عليها بواسطة النظام ld وفقًا لجميع قواعد Linux. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، تحتوي Java على مجموعة من الخصائص التي تحتوي على المسارات التي تتم فيها عمليات البحث في المكتبة. </font><font style="vertical-align: inherit;">أسهل طريقة للعمل داخل Oracle هي وضع مكتبتنا في $ ORACLE_HOME / lib. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وبعد إنشاء المكتبة ، نحتاج إلى تجميع الفصل داخل قاعدة البيانات ونشرها كحزمة plsql. </font><font style="vertical-align: inherit;">هناك خياران لإنشاء فئات Java داخل قاعدة البيانات:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحميل ملف ثنائي الطبقة عبر أداة loadjava</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تجميع كود الفئة من المصدر باستخدام sqlplus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سنستخدم الطريقة الثانية ، على الرغم من أنها متساوية في الأساس. </font><font style="vertical-align: inherit;">بالنسبة للحالة الأولى ، كان من الضروري كتابة كل كود الفئة على الفور في المرحلة 1 ، عندما تلقينا فئة كعب لملف h. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لإنشاء فئة في subd ، يتم استخدام بناء جملة خاص:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">AND</span> RESOLVE <span class="hljs-keyword">JAVA</span> <span class="hljs-keyword">SOURCE</span> NAMED <span class="hljs-string">"Posix"</span> <span class="hljs-keyword">AS</span><font></font>
...<font></font>
...<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عند إنشاء الفصل ، يجب نشره كطرق plsql ، وهنا مرة أخرى بناء الجملة الخاص:</font></font><br>
<br>
<pre><code class="sql hljs">procedure set_env(var_name varchar2, var_value varchar2)<font></font>
is<font></font>
language java name 'Posix.set_env(java.lang.String, java.lang.String)';<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عند محاولة استدعاء طرق يحتمل أن تكون غير آمنة داخل Java ، يتم رفع التنفيذ الذي ينص على أنه لم يتم إصدار منحة جافا للمستخدم. </font><font style="vertical-align: inherit;">يعد تحميل الطرق الأصلية عملية أخرى غير آمنة ، لأننا نقوم بإدخال كود غريب في عملية قاعدة البيانات مباشرة (نفس الاستغلال الذي تم الإعلان عنه في الرأس). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ولكن نظرًا لأن قاعدة البيانات هي اختبار ، فإننا نقدم منحة دون أي قلق من الاتصال بالأنظمة:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_java.grant_permission( <span class="hljs-string">'SYSTEM'</span>, <span class="hljs-string">'SYS:java.lang.RuntimePermission'</span>, <span class="hljs-string">'loadLibrary.Posix'</span>, <span class="hljs-string">''</span>);
<span class="hljs-keyword">commit</span>;
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اسم المستخدم للنظام هو الذي قمت بتجميع كود جافا وحزمة المجمع plsql. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من المهم ملاحظة أنه عند تحميل مكتبة من خلال استدعاء System.loadLibrary ، فإننا نحذف البادئة lib والامتداد (كما هو موضح في الوثائق) ولا نمرر أي مسار للبحث فيه. هناك طريقة System.load مماثلة يمكنها فقط تحميل مكتبة باستخدام مسار مطلق. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ثم تنتظرنا مفاجأتان غير سارتين - لقد هبطت في حفرة الأرنب التالية في Oracle. عند إصدار منحة ، يحدث خطأ برسالة ضبابية إلى حد ما:</font></font><br>
<br>
<pre><code class="plaintext hljs">ORA-29532: Java call terminated by uncaught Java exception: java.lang.SecurityException: policy table update
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم التعامل مع المشكلة على الإنترنت على Google ويؤدي إلى My Oracle Support (المعروف أيضًا باسم Metalink). </font><font style="vertical-align: inherit;">لان </font><font style="vertical-align: inherit;">وفقًا لقواعد أوراكل ، لا يُسمح بنشر مقالات من رابط معدني في مصادر مفتوحة ، سأذكر فقط رقم الوثيقة - 259471.1 (سيتمكن أولئك الذين لديهم حق الوصول من القراءة لأنفسهم). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
جوهر المشكلة هو أن أوراكل لن تسمح لنا فقط بتحميل كود طرف ثالث مشبوه في عمليتنا. </font><font style="vertical-align: inherit;">وهو أمر منطقي. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ولكن بما أن القاعدة هي اختبار ونحن واثقون من التعليمات البرمجية الخاصة بنا ، فإننا نسمح بالتنزيل دون مخاوف خاصة. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
فوه ، المغامرات في كل مكان.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنها حية ، حية</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من خلال التنفس المتأخر ، قررت أن أحاول أن أتنفس الحياة في فرانكنشتاين. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نبدأ قاعدة البيانات باستخدام libfaketime الذي تم تحميله مسبقًا والإزاحة 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اتصل بقاعدة البيانات وقم بإجراء مكالمة إلى الرمز الذي يعرض ببساطة الوقت قبل وبعد تغيير متغير البيئة:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_output.enable(<span class="hljs-number">100000</span>);<font></font>
dbms_java.set_output(100000);<font></font>
dbms_output.put_line('old time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
system.posix.set_env('FAKETIME','+1d');<font></font>
dbms_output.put_line('new time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يعمل ، اللعنة! </font><font style="vertical-align: inherit;">بصراحة ، كنت أتوقع المزيد من المفاجآت ، مثل أخطاء ORA-600. </font><font style="vertical-align: inherit;">ومع ذلك ، كان التنبيه يحتوي على الرقم الكامل واستمر الرمز في العمل. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من المهم ملاحظة أنه إذا تم إجراء الاتصال بقاعدة البيانات على أنها مخصصة ، فبعد اكتمال الاتصال ، سيتم تدمير العملية ولن يكون هناك أي أثر. </font><font style="vertical-align: inherit;">ولكن إذا استخدمنا اتصالات مشتركة ، ففي هذه الحالة يتم تخصيص عملية جاهزة من تجمع الخادم ، فإننا نغير الوقت فيها من خلال متغيرات البيئة ، وعندما يتم قطع الاتصال بها ، ستظل تتغير داخل العملية. </font><font style="vertical-align: inherit;">وعندما تقع بعد ذلك جلسة عمل قاعدة بيانات أخرى في نفس عملية الخادم ، فإنها ستستغرق الوقت الخاطئ لمفاجأتها الكبيرة. </font><font style="vertical-align: inherit;">لذلك ، في نهاية جلسة الاختبار ، من الأفضل دائمًا إعادة الوقت إلى صفر الإزاحة.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استنتاج</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
آمل أن تكون القصة مثيرة للاهتمام (وربما مفيدة لشخص ما). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تتوفر جميع رموز المصدر على </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وثائق libfaketime </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أيضًا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كيف تقوم باختبار؟ </font><font style="vertical-align: inherit;">وكيف تقوم بإنشاء قواعد بيانات مطورة واختبار في شركة؟</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مكافأة لأولئك الذين يقرؤون حتى النهاية</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/wd/m1/s9/wdm1s9kk6_kckj-xf5amc_o6wjq.jpeg"><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar503782/index.html">كيف تصنع طاولة تفاعلية بسطح عمل على شكل دائرة؟</a></li>
<li><a href="../ar503786/index.html">التمثيل الرقمي للصوت التناظري. برنامج تعليمي موجز</a></li>
<li><a href="../ar503788/index.html">البريد الإلكتروني الديناميكي :: الأمان</a></li>
<li><a href="../ar503790/index.html">التباديل. الصف التاسع. مهمة التكافؤ</a></li>
<li><a href="../ar503796/index.html">جعل الدعم أرخص ، محاولاً عدم فقدان الجودة</a></li>
<li><a href="../ar503812/index.html">القرصنة الرشيقة وبعض قوانين الديالكتيك</a></li>
<li><a href="../ar503826/index.html">حماية DDoS المتناظرة وغير المتماثلة - ما الفرق؟</a></li>
<li><a href="../ar503830/index.html">فتحت أمازون مأوى كبير للمشردين</a></li>
<li><a href="../ar503832/index.html">وصفات PostgreSQL: محرك قالب الشارب</a></li>
<li><a href="../ar503836/index.html">إيجابيات وسلبيات تقنيات تعديل التعليقات (+ استطلاع)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>