<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌯 💽 🗾 PEP 572（Python 3.8の代入式） 📢 🐌 🤷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル。今回は、割り当て式について説明するPEP 572を見ていきます。"：="演算子にまだ懐疑的である場合、またはその使用規則を完全に理解していない場合は、この記事が役立ちます。ここには、「なぜそうなのか」という質問に対する多くの例と回答があります。この記事はできる限り完全であることが...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572（Python 3.8の代入式）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル。</font><font style="vertical-align: inherit;">今回は、割り当て式について説明するPEP 572を見ていきます。</font><font style="vertical-align: inherit;">"：="演算子にまだ懐疑的である場合、またはその使用規則を完全に理解していない場合は、この記事が役立ちます。</font><font style="vertical-align: inherit;">ここには、「なぜそうなのか」という質問に対する多くの例と回答があります。</font><font style="vertical-align: inherit;">この記事はできる限り完全であることがわかりました。時間が足りない場合は、私が書いたセクションをご覧ください。</font><font style="vertical-align: inherit;">最初は、割り当て式を使用して快適に作業できるように、主要な「論文」が収集されます。</font><font style="vertical-align: inherit;">エラーを見つけた場合は事前にご容赦ください（エラーについて書いてください。修正します）。</font><font style="vertical-align: inherit;">はじめましょう：</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572-割り当て式</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペップ</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">題名：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当て式</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;gmail.comのrosuav&gt;、Tim Peters &lt;gmail.comのtim.peters&gt;、Guido van Rossum &lt;python.orgのGuido&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">討論：</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python.orgのdoc-sig</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け入れた</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成した：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年2月28日</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonバージョン：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿記事：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年2月28日、2018年3月2日、2018年3月23日、2018年4月4日、2018年4月17日、2018年4月25日、2018年7月9日、2019年8月5日</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準を採用する許可：</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（長い間VPNを使用していますが、ロードされます）</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注釈</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正当化</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文とセマンティクス</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装中の仕様変更</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒否された代替</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よくある反対意見</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタイルの推奨事項</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありがとう</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録A：Tim Petersの結論</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録B：ジェネレーターの大まかなコードインタープリター</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録C：スコープセマンティクスの変更なし</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著作権</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の分</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注釈</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この規則では、新しい表記NAME：= exprを使用して、式内の代入の可能性について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
革新の一環として、辞書ジェネレーター（辞書理解度）の計算手順が更新されました。これにより、キー式が値式の前に評価されることが保証されます（これにより、キーを変数にバインドし、作成した変数をキーに対応する値の計算に再利用できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このPEPの議論中に、このオペレーターは非公式にセイウチオペレーターとして知られるようになりました。構成の正式名は「割り当て式」（PEP：割り当て式の見出しによる）ですが、「名前付き式」と呼ばれることもあります。たとえば、CPythonのリファレンス実装では、まさにこの名前を使用しています。</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正当化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命名はプログラミングの重要な部分であり、長い式の代わりに「説明的な」名前を使用でき、値の再利用も簡単になります。</font><font style="vertical-align: inherit;">現在、これは命令の形式でのみ実行できるため、リストを生成するとき（リスト内包表記）、および他の式ではこの操作を使用できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、大きな式の一部に名前を付けると、プロンプトと中間結果を表示するためのツールが提供されるため、インタラクティブなデバッグに役立ちます。</font><font style="vertical-align: inherit;">ネストされた式の結果をキャプチャする機能がない場合、ソースコードを変更する必要がありますが、割り当て式を使用する場合は、「name：= expression」という形式のいくつかの「マーカー」を挿入する必要があります。</font><font style="vertical-align: inherit;">これにより、不要なリファクタリングがなくなり、デバッグ中に意図しないコードが変更される可能性が低くなり（ハイゼンバグの一般的な原因は、デバッグ中にコードのプロパティを変更するエラーであり、予期せず本番環境で表示される可能性があります]）、このコードは別の人にわかりやすくなりますプログラマーに。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のコードの重要性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このPEPの開発中、多くの人々（支持者と批評家の両方）は一方でおもちゃの例に集中しすぎ、他方で過度に複雑な例に集中しすぎていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おもちゃの例の危険性は2つあります。それらはしばしば抽象的すぎるため、誰かに「ああ、これはたまらない」と言うことはできません。過度に複雑な例の危険性は、この機能を削除することを提案する批評家に便利な環境を提供することです（「これは混乱しすぎる」とそのような人々は言います）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、そのような例にはよい使用法があります。それらは意図されたセマンティクスを明確にするのに役立ちます。したがって、それらのいくつかを以下に示します。ただし、</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説得力</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持た</font><b><i><font style="vertical-align: inherit;">せるには</font></i></b><font style="vertical-align: inherit;">、例は</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このPEPについて考えずに書かれた</font><b><font style="vertical-align: inherit;">実際の</font></b><font style="vertical-align: inherit;">コード。つまり、本当に役立つアプリケーションの一部であるコードです（違いはありません。それが大きいか小さいか）。 Tim Petersは彼の個人的なリポジトリを調べ、彼が書いたコードの例を選択することで私たちに多くの助けをしてくれました。彼の結論は次のとおりです。現在の変更は、彼のコードのいくつかのビットに控えめですが明らかな改善をもたらすでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のコードのもう1つの例は、プログラマーがコンパクトさをどのように評価するかの間接的な観察です。 Guido van RossumがDropboxコードベースをチェックしたところ、プログラマーがいくつかの小さな式を使用するよりも少ないコード行を書くことを好むという証拠がいくつか見つかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適例：Guidoは、プログラマーが副次式を繰り返したときにいくつかの例示的な点を見つけました（それによってプログラムの速度が低下しました）が、余分なコード行を節約しています。</font><font style="vertical-align: inherit;">たとえば、書く代わりに：</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーはこのオプションを好んだ：</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、プログラマーが「以前のレベル」のインデントを維持するために、より多くの作業を行う場合があることを示す別の例です。</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、pattern1がすでに一致している場合でも、pattern2を計算します（この場合、2番目のサブ条件が満たされることはありません）。</font><font style="vertical-align: inherit;">したがって、次のソリューションはより効果的ですが、魅力的ではありません。</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文とセマンティクス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonが任意の式を使用するほとんどの場合、割り当て式を使用できるようになりました。</font><font style="vertical-align: inherit;">それらの形式はNAME：= exprです。exprは括弧なしのタプルを除く有効なPython式で、NAMEは識別子です。</font><font style="vertical-align: inherit;">このような式の値は元の式と一致しますが、追加の効果として、ターゲットオブジェクトへの値の割り当てがあります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外的なケース</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザー間のあいまいさや混乱を避けるために、割り当て式を使用できない場所がいくつかあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">括弧で囲まれていない代入式は、「上位」レベルでは禁止されています。</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このルールにより、プログラマーは代入演算子と代入式のどちらかを選択しやすくなります。両方のオプションが同等である構文的な状況はありません。</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当て式は新しいスコープを導入しません。ほとんどの場合、変数が作成されるスコープは説明を必要としません。それは現在のものです。変数が以前に非ローカルまたはグローバルキーワードを使用していた場合、割り当て式はこれを考慮します。 （関数の匿名の定義である）ラムダのみが、これらの目的のための別個のスコープと見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別なケースが1つあります。リスト、セット、ディクショナリのジェネレーター、または「ジェネレーターの式」自体（以下、総称して「ジェネレーター」（内包）と呼ばれます）で発生する代入式は、変数をジェネレーターが含むスコープにバインドし、グロブ修飾子を観察します。または、存在する場合は非グローバル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特殊なケースの根拠は2つあります。</font><font style="vertical-align: inherit;">まず、any（）およびall（）という式の「メンバー」を簡単にキャプチャできます。次に例を示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ジェネレーターから変数を更新するコンパクトな方法を提供します。次に例を示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、代入式からの変数の名前は、forループが反復するためにジェネレーターですでに使用されている名前と一致することはできません。</font><font style="vertical-align: inherit;">姓は、それらが表示されるジェネレータに対してローカルです。</font><font style="vertical-align: inherit;">割り当て式がジェネレータ内のスコープも参照している場合は、一貫性がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、[i：= i + 1 for i in range（5）]は無効です。forループはiがジェネレーターに対してローカルであることを決定しますが、「i：= i + 1」の部分はiが外部からの変数であることを主張します範囲 </font><font style="vertical-align: inherit;">同じ理由で、次の例は機能しません。</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような場合に一貫したセマンティクスを割り当てることは技術的に可能ですが、このセマンティクスを理解する方法が実際のコードで機能するかどうかを判断することは困難です。そのため、リファレンス実装は、特定のハードウェア実装に応じて、未定義の動作で実行されるのではなく、そのような場合にSyntaxErrorを発生させます。この制限は、割り当て式が実行されない場合でも適用されます。</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレータ本体（最初のキーワード“ for”の前の部分）とフィルター式（“ if”の後のネストされた“ for”の前の部分）の場合、この制限は、反復変数として同時に使用される変数名にのみ適用されます。すでに述べたように、ラムダ式は関数の新しい明示的なスコープを導入するため、追加の制限なしにジェネレーター式で使用できます。 【約再び、そのような場合を除いて：[i for i in range（2、（lambda：（s：= 2）（）））]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リファレンス実装の設計上の制限により（シンボルテーブルアナライザーは、ジェネレーターの左側の名前が反復可能な式が配置されている残りの部分で使用されているかどうかを認識できません）、したがって、代入式は反復可能な部分として（各「in」の後の部分で）完全に禁止されています。後続のキーワード「if」または「for」の前）。</font><font style="vertical-align: inherit;">つまり、これらのケースはすべて受け入れられません。</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例外は、クラスのスコープ内にあるジェネレーターで割り当て式が使用される場合に発生します。</font><font style="vertical-align: inherit;">上記のルールを使用するときに、スコープで測定されるクラスを作成する必要がある場合、そのような割り当て式は無効であり、SyntaxErrorになります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（最後の例外の理由は、ジェネレーターによって作成された関数の暗黙のスコープです-現在、クラスのスコープ内にある変数を参照する関数のランタイムメカニズムはありません。そのようなメカニズムを追加したくありません。この問題が解決された場合、その後、この特殊なケースは（おそらく）割り当て式の仕様から削除されます。この問題は、クラスのスコープ内で以前に変数を作成し、ジェネレーターからの割り当て式でそれを変更しようとした場合でも発生することに注意して</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">方法の例については、付録Bを参照してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ジェネレータにある割り当て式は、同等のコードに変換されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相対的な優先度：=</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：=演算子は、可能な場合はすべての構文位置でカンマよりも強くグループ化されますが、or、and、not、および条件式（C if if else B）を含む他のすべての演算子よりも弱いです。上記の「例外的なケース」セクションからわかるように、割り当て式は、従来の割り当て=と同じ「レベル」で機能することはありません。異なる順序の操作が必要な場合は、括弧を使用してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子：=は、関数の位置引数を呼び出すときに直接使用できます。ただし、これは引数では直接機能しません。技術的に許可されていることと不可能であることを明確にするいくつかの例：</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の「有効な」例のほとんどは、ソースコードをすばやくスキャンする人がその意味を正しく理解していない可能性があるため、実際に使用することはお勧めしません。</font><font style="vertical-align: inherit;">しかし、単純なケースではこれが許可されています：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このPEPは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">絶対に常に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スペース</font><b><font style="vertical-align: inherit;">を</font></b><font style="vertical-align: inherit;">置く</font><font style="vertical-align: inherit;">ことをお勧めします</font><font style="vertical-align: inherit;">：=、クラシック割り当ての=に対するPEP 8の推奨と同様です。</font><font style="vertical-align: inherit;">（最後の推奨は、関数にキー引数を渡すために使用される=の周りのスペースを禁止するという点で異なります。）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算の順序を変更します。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確に定義されたセマンティクスを得るために、この合意では評価手順を明確に定義する必要があります。</font><font style="vertical-align: inherit;">技術的には、これは新しい要件ではありません。</font><font style="vertical-align: inherit;">Pythonにはすでに、部分式が通常左から右に評価されるというルールがあります。</font><font style="vertical-align: inherit;">ただし、割り当て式を使用すると、これらの「副作用」がより顕著になります。現在の計算順序で1つの変更を提案します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書ジェネレータ{X：Y for ...}では、Yは現在Xの前に評価されます。これを変更して、XがYの前に計算されるようにすることをお勧めします。（{X：Y}などの従来の辞書では、dictでは（（X、Y）for ...）これはすでに実装されています。したがって、辞書ジェネレーターはこのメカニズムに準拠する必要があります）</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代入式と代入命令の違い。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要なのは、 "：="が</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であること</font><font style="vertical-align: inherit;">です。これは、ラムダ関数やジェネレーターなど、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令が</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有効でない</font><font style="vertical-align: inherit;">場合に使用できることを意味します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">逆に、</font><font style="vertical-align: inherit;">代入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">代入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で使用できる拡張機能をサポートしていません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスケード割り当ては直接サポートされていません</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な変数名NAMEを除いて、個別の「ターゲット」はサポートされていません。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カンマの「前後」の機能と優先度は異なります。</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開梱と梱包の値に「純粋な」同等性がないか、まったくサポートされていない</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インライン型注釈はサポートされていません：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作の短縮形はありません。</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装中の仕様変更</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の変更は、このPEPの最初の記述後、Python 3.8のリリース前に得られた経験と追加の分析に基づいて行われました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の同様の例外との一貫性を確保し、エンドユーザーに不便な新しい名前を導入しないようにするために、SyntaxErrorのTargetScopeErrorの最初に提案されたサブクラスは削除され、通常のSyntaxErrorに削減されました。</font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython文字テーブルの解析の制限により、割り当て式のリファレンス実装では、イテレーター内でのすべての使用に対してSyntaxErrorが発生します。</font><font style="vertical-align: inherit;">以前、この例外は、作成される変数の名前が反復式ですでに使用されている名前と一致した場合にのみ発生していました。</font><font style="vertical-align: inherit;">十分に説得力のある例がある場合は、これを修正できますが、追加の複雑さは、純粋に「仮説的な」ユースケースには不適切と思われます。</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python標準ライブラリの例</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_baseは条件でのみ使用されるため、論理ブロックの「ヘッダー」として、代入をifに配置できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のコード：</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善されたコード：</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたifを回避して、1レベルのインデントを削除できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のコード：</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善されたコード：</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードはより古典的に見え、条件ステートメントの複数のネストを回避します。</font><font style="vertical-align: inherit;">（この例の起源について詳しくは、付録Aを参照してください。）</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のコード：</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善されたコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tzはs + = tzにのみ使用されます。</font><font style="vertical-align: inherit;">論理的な使用領域を示すのに役立つ場合は、内側に移動します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のコード：</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善されたコード：</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if条件でwhileループの「条件」としてfp.readline（）を呼び出す（および.match（）メソッドを呼び出す）と、理解を複雑にすることなくコードがよりコンパクトになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善されたコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストジェネレーターの簡略化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、条件を「取得」することにより、リストジェネレータを効果的にフィルタリングできます。</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、変数は別の式で再利用できます。</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらの場合でも、変数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は変数の結果やものと同じスコープに</font><font style="vertical-align: inherit;">あることに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件での「キャプチャ」値</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代入式は、ifまたはwhileステートメントの条件で効果的に使用できます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、このアプローチでは、無限ループ、割り当て、および条件チェックを作成する必要がなくなります。</font><font style="vertical-align: inherit;">また、関数呼び出しを条件として使用するサイクルと、条件をチェックするだけでなく、関数から返される実際の値を将来使用するサイクルとの間にスムーズな並列処理を描画することもできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォーク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UNIXの低レベルの世界からの例：[およそ。</font><font style="vertical-align: inherit;">Fork（）はUnixライクなオペレーティングシステムのシステムコールであり、親に関連する新しいサブプロセスを作成します。]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒否された代替</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、Pythonコミュニティでは同様の提案が非常に一般的です。</font><font style="vertical-align: inherit;">以下は、割り当て式の多くの代替構文で、具体的すぎて理解できず、上記の理由で拒否されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネレーターのスコープを変更する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このPEPの以前のバージョンでは、ジェネレーターのスコープルールに微妙な変更を加えて、クラスのスコープでの使用により適したものにすることが提案されました。</font><font style="vertical-align: inherit;">ただし、これらの提案は下位互換性を欠くため、拒否されました。</font><font style="vertical-align: inherit;">したがって、このPEPは、割り当て式のみに完全に集中することができました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替スペル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、提案された代入式は同じセマンティクスを持っていますが、書き方が異なります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前としてEXPR：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構文は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Exc構文からのレイズExcを数えない限り）</font><font style="vertical-align: inherit;">他のものと競合する可能性は低くなりますが</font><font style="vertical-align: inherit;">、それ以外はそれらに匹敵します。</font><font style="vertical-align: inherit;">ターゲットとしてexprを使用して並列処理を行う代わりに（これは便利かもしれませんが、混乱を招く可能性もあります）、このオプションには何の並列処理もありませんが、驚くほど覚えやすくなっています。</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件付きステートメントの特殊なケース</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代入式の最も一般的な使用例の1つは、ifステートメントとwhileステートメントです。</font><font style="vertical-align: inherit;">より一般的なソリューションの代わりに、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">すると、比較する値を取得する手段を追加することにより、これら2つのステートメントの構文が改善されます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは正常に機能しますが</font><font style="vertical-align: inherit;">、必要な条件が戻り値の「正確さ」に基づいている場合</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">したがって、このメソッドは特定のケース（正規表現のチェック、ソケットの読み取り、実行の終了時に空の文字列を返す）に効果的であり、より複雑なケース（たとえば、条件がf（x）&lt;0であり、 f（x）の値を保存します）。</font><font style="vertical-align: inherit;">また、これはリストジェネレーターでは意味がありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：構文のあいまいさがありません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短所</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：if / whileステートメントでのみ使用しても、一部の場合にのみ機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発電機の特別な場合</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当て式のもう1つの一般的な使用例は、ジェネレーター（リスト/セット/ dictおよびgenexps）です。</font><font style="vertical-align: inherit;">上記のように、特定のソリューションについて提案がなされました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで、聞かせるか、または与えます：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは、forループとメイン式の間のサブ式になります。</font><font style="vertical-align: inherit;">また、競合を引き起こす可能性のある追加の言語キーワードも導入されています。</font><font style="vertical-align: inherit;">3つのオプションのうち、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は最もクリーンで読みやすいですが、潜在的な競合がまだ存在します（たとえば、SQLAlchemyとnumpyにはwhereメソッドがあり、標準ライブラリにはtkinter.dnd.Iconがあります）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NAME = EXPR：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択した方法に関係なく、forループを介して、ジェネレーターとそれらのデプロイされたバージョンの間に意味上の鋭い違いが生じます。</font><font style="vertical-align: inherit;">変数を作成する段階を処理せずに、ジェネレーターでサイクルをラップすることは不可能になります。</font><font style="vertical-align: inherit;">このタスクで向きを変えることができる唯一のキーワードは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の単語</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">しかし、これによりコードの異なる部分で異なるセマンティクスが得られます。つまり、新しいキーワードを作成する必要がありますが、それには多くのコストがかかります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーターの優先順位を下げる</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：=演算子には2つの論理的な優先順位があります。または、（割り当て演算子と同等に）可能な限り低い優先度を設定する必要があります。または、比較演算子よりも優先される必要があります。比較演算子と算術演算の間に優先順位を設定する（正確には、ビット単位のORよりわずかに低い）と、ほとんどの場合、括弧を使用せずに使用できます。これは、前に何かの値を保持する可能性が高いためです。比較がどのように実行されるか：</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
find（）が-1を返すとすぐに、ループは終了します。</font><font style="vertical-align: inherit;">=が=と同じくらい自由にオペランドをバインドする場合、find（）の結果はまず比較演算子に「取り込まれ」、通常はTrueまたはFalseを返しますが、あまり有用ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作は多くの状況で実際には便利ですが、説明するのはより困難です。</font><font style="vertical-align: inherit;">そして、「演算子：=は通常の代入演算子と同じように動作します」と言うことができます。</font><font style="vertical-align: inherit;">つまり、= =の優先順位は、演算子=に可能な限り近い値を選択しました（ただし、：=はコンマよりも優先されます）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは右側にコンマを与えます</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の批評家は、2つのエントリが同等になるように、割り当て式は角括弧を追加せずにタプルを認識すべきであると主張しています：</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（標準の現在のバージョンでは、最後のレコードは式（（point：= x）、y）と同等です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この状況では、関数呼び出しで代入式を使用すると、コンマよりも優先順位が低くなるので、次の紛らわしい等価になります：</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちは混乱を少なくする唯一の方法を手に入れます:::演算子をコンマよりも低い優先順位にします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にブラケットが必要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当て式を括弧で囲むことが常に提案されています。</font><font style="vertical-align: inherit;">これにより、多くのあいまいさが解消されます。</font><font style="vertical-align: inherit;">実際、目的の値を抽出するには、括弧が必要になることがよくあります。</font><font style="vertical-align: inherit;">しかし、以下の場合、括弧の存在は明らかに不必要に思えました。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よくある反対意見</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ割り当てステートメントを式に変えないのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cおよび類似の言語では、</font><font style="vertical-align: inherit;">Pythonのように</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font><font style="vertical-align: inherit;">を命令ではなく式として</font><font style="vertical-align: inherit;">定義</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">これにより、変数が比較される場所を含む多くの状況での割り当てが可能になります。</font><font style="vertical-align: inherit;">if（x == y）とif（x = y）の構文の類似性は、それらの明確に異なるセマンティクスと矛盾します。</font><font style="vertical-align: inherit;">したがって、このPEPは演算子を導入します：=違いを明確にするため。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代入</font><i><font style="vertical-align: inherit;">命令</font></i><font style="vertical-align: inherit;">が存在する</font><font style="vertical-align: inherit;">のに、なぜ</font><font style="vertical-align: inherit;">代入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悩むの</font><font style="vertical-align: inherit;">ですか？</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら2つの形式には、異なる柔軟性があります。</font><font style="vertical-align: inherit;">演算子：=は、より大きな式の内部で使用でき、=演算子では、タイプ "+ ="の「ミニオペレーターのファミリー」が使用できます。</font><font style="vertical-align: inherit;">また、=を使用すると、属性とインデックスによって値を割り当てることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルスコープを使用して名前空間の汚染を防止しないのはなぜですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この標準の以前のバージョンには、割り当て式の実際のローカルスコープ（1つのステートメントに限定）が含まれており、名前の漏洩と名前空間の汚染を防止していました。</font><font style="vertical-align: inherit;">一部の状況ではこれが特定の利点をもたらしたという事実にもかかわらず、他の多くの状況ではタスクを複雑にし、その利点は既存のアプローチの利点によって正当化されません。</font><font style="vertical-align: inherit;">これは、言語を単純にするために行われます。</font><font style="vertical-align: inherit;">この変数はもう必要ありませんか？</font><font style="vertical-align: inherit;">解決策があります。delキーワードを使用して変数を削除するか、名前に下線を追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（著者は、PEP標準をこの方向に進めるように提案してくれたGuido van RossumとChristophe Grothに感謝します。[2]）</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタイルの推奨事項</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当て式は割り当て演算子と同等に使用できる場合があるため、疑問が生じますが、それでも何が望ましいですか？..他のスタイル規則（PEP 8など）に従って、2つの推奨事項があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方の割り当てオプションを使用できる場合は、演算子を優先します。</font><font style="vertical-align: inherit;">彼らはあなたの意図を最も明確に表現しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代入式を使用すると実行順序が不明確になる場合は、従来の演算子を使用してコードを書き直してください。</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありがとう</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この標準の作成者は、このPEPへの多大な貢献をしてくれたNick CoghlanとSteven D'Apranoに感謝し、Pythonコアメンターシップメンバーがこれを実装するのを手伝ってくれたことに感謝します。</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録A：Tim Petersの結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ティムピーターズがこのトピックについて書いた短いエッセイです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「混乱した」コードは好きではありません。また、概念的に無関係なロジックを1行に置くのも好きではありません。</font><font style="vertical-align: inherit;">したがって、たとえば、次の代わりに：</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は書くことを好む：</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、割り当て式を使用したい場所がいくつかあると思います。</font><font style="vertical-align: inherit;">すでに画面の半分に引き伸ばされている表現での使用については話したくありません。</font><font style="vertical-align: inherit;">その他の場合、次のような動作があります。</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これより大幅に良い：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つのコードには完全に異なる概念があり、それらを混在させるのはおかしいでしょう。</font><font style="vertical-align: inherit;">他の場合では、論理式を組み合わせると、コードの理解が複雑になります。</font><font style="vertical-align: inherit;">たとえば、次のように書き換えます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短い形式では、「ロジック」を失いました。</font><font style="vertical-align: inherit;">このコードがどのように機能するかを理解する必要があります。</font><font style="vertical-align: inherit;">私の脳はこれをしたくありません：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのようなケースはまれです。</font><font style="vertical-align: inherit;">結果を保持するタスクは非常に一般的であり、「スパースの方が密度よりも優れている」とは、「ほとんど空の方がスパースより優れている」という意味ではありません。</font><font style="vertical-align: inherit;">Zen Pythonへの参照]。</font><font style="vertical-align: inherit;">たとえば、Noneまたは0を返し、「何も役に立たないが、これは頻繁に発生するので、例外を設けて邪魔したくない」と返す関数がたくさんあります。</font><font style="vertical-align: inherit;">実際、このメカニズムは、一致がない場合にNoneを返す正規表現でも使用されます。</font><font style="vertical-align: inherit;">したがって、この例では、多くのコードが次のようになります。</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のオプションの方が理解しやすく、もちろん読みやすくなっています。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初はあまり重視していなかったのですが、こんな短い構造になってしまい、すぐに使えなくなって困るようになりました。</font><font style="vertical-align: inherit;">びっくりしました！</font><font style="vertical-align: inherit;">【約 </font><font style="vertical-align: inherit;">どうやらこれはPython 3.8が正式にリリースされる前に書かれたものです。] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当て式が実際に「シュート」する他のケースがあります。</font><font style="vertical-align: inherit;">私のコードをもう一度検討する代わりに、Kirill Balunovは標準のcopy.pyライブラリのcopy（）関数の優れた例を示しました。</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデントの増加は誤解を招くものです。結局のところ、ロジックはフラットです。最初に成功したテストが「成功」します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り当て式を単純に使用すると、コードの視覚的な構造でロジックの「プレーン」を強調できます。</font><font style="vertical-align: inherit;">しかし、刻み目の増加はそれを暗にしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが私のコードからの別の小さな例です。これは、内部的にリンクされたロジックを1行に配置して、煩わしい「人工的な」インデントレベルを削除することができたので、とても嬉しかったです。</font><font style="vertical-align: inherit;">これがまさにif文に求めていることであり、読みやすくなります。</font><font style="vertical-align: inherit;">次のコード：</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になって：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、変数の割り当てが行われるほとんどの行では、割り当て式を使用しません。</font><font style="vertical-align: inherit;">しかし、このデザインは非常に頻繁であるため、私がこの機会を利用する場所はまだたくさんあります。</font><font style="vertical-align: inherit;">最近のケースでは、彼らはしばしば現れたので、私は少し勝ちました。</font><font style="vertical-align: inherit;">残りのサブパートでは、これは中程度または大幅な改善につながりました。</font><font style="vertical-align: inherit;">したがって、割り当て式はトリプルの場合よりも頻繁に使用しますが、拡張割り当てよりも使用頻度は低くなります。</font><font style="vertical-align: inherit;">短いオプション：* =、/ =、+ =など]。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前に私を襲った別の例があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての変数が正の整数であり、変数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> xのn乗根より大きい場合、このアルゴリズムはxのn乗根の「より低い」丸めを返します（反復ごとの正確なビット数を約2倍にします）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理由は明らかではありませんが、このバージョンのアルゴリズムは、条件付き分岐ブレーク（ループと半分）を伴う無限ループよりも明確ではありません。数学的ステートメント（「算術平均-幾何平均不等式」）に依存せず、ネストされた丸め関数がどのように下向きに振る​​舞うかについて重要なことを知らずに、この実装の正確さを証明することも困難です。しかし、ここでは問題はすでに数学にあり、プログラミングではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これらすべてを知っている場合、代入式を使用するオプションは、「現在の推測を確認し、それが大きすぎる場合は減らす」という単純な文のように非常に簡単に読み取られ、条件により、ループ条件から中間値をすぐに保存できます。私の意見では、古典的な形は理解するのが難しいです：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録B：ジェネレーターの大まかなコードインタープリター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この付録では、ジェネレータ式で変数を作成する際の規則を明確にします（ただし、指定はしません）。</font><font style="vertical-align: inherit;">いくつかの例示的な例について、ジェネレーターを「足場」と組み合わせた同等の関数に置き換えたソースコードを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[x for ...]はlist（x for ...）と同等であるため、例は一般性を失わない。</font><font style="vertical-align: inherit;">また、これらの例は一般的なルールを明確にすることのみを目的としているため、現実的であるとは主張していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：ジェネレーターは、ネストされたジェネレーター関数（この付録に記載されているものと同様）を作成することにより実装されるようになりました。</font><font style="vertical-align: inherit;">例は、割り当て式のスコープ（割り当てが最も外部のジェネレーターを含むブロックで実行されたかのようなスコープ）を操作するための適切な機能を追加する新しい部分を示しています。</font><font style="vertical-align: inherit;">「型推論」を単純化するために、これらの例示的な例では、割り当て式がオプションであることを考慮していません（ただし、ジェネレーター内で作成された変数のスコープを考慮しています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、割り当て式のないジェネレーターの「内部」で生成されるコードを思い出してみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード（EXPRはVAR変数を最も頻繁に使用します）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換されたコード（名前の競合を心配しないでください）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な代入式を追加してみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換されたコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、グローバルTARGETステートメントをf（）関数の宣言に追加します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換されたコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
またはその逆で、非ローカルTARGETをf（）関数の宣言に追加しましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換されたコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、2つのジェネレーターを配置します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換されたコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録C：スコープセマンティクスの変更なし</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonでは、スコープのセマンティクスは変更されていません。</font><font style="vertical-align: inherit;">ローカル関数のスコープはコンパイル時に決定され、実行時（クロージャ）に不定の時間範囲があります。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念実証の実装</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当て式のセマンティクスの説明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（VPNはタイトですがロードされています）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572のTargetScopeErrorの説明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（前のものと同様に読み込まれます）</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著作権</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このドキュメントは公開されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソース：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の分</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、要約してみましょう。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「=」と「：=」の両方を使用できる多くの「古典的な」場所で</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><s><font style="vertical-align: inherit;">人々が</font></s><font style="vertical-align: inherit;">意味の二重性を取り除こ</font><s><font style="vertical-align: inherit;">うとしない</font></s><font style="vertical-align: inherit;">ように制限があります。したがって、演算子:: =は大括弧で囲む必要があります。</font><font style="vertical-align: inherit;">これらのケースは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、基本的な使用法を説明する</font></a><font style="vertical-align: inherit;">セクションで確認する必要があり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当て式の優先順位は、コンマの優先順位よりわずかに高くなっています。</font><font style="vertical-align: inherit;">このため、割り当て中にタプルは形成されません。</font><font style="vertical-align: inherit;">また、関数に引数を渡すときに=演算子を使用することもできます。</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私は新しいオペレーターが好きだったと言いたいです。</font><font style="vertical-align: inherit;">これにより、条件でよりフラットなコードを記述し、「フィルター」リストを作成し、さらに（最終的に）その前の「同じ」孤独な行を削除できます。</font><font style="vertical-align: inherit;">人々が意図した目的で代入式を使用する場合、これはコードの可読性と美しさを向上させる非常に便利なツールになります（ただし、これは関数型言語について言えることですが...）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499654/index.html">CRMをリモートサイトに実装して勝つ方法</a></li>
<li><a href="../ja499656/index.html">PID温度コントローラーのシミュレーション</a></li>
<li><a href="../ja499658/index.html">テスターの代わりに男性労働者？2020年にセレンを研究する価値はありますか？</a></li>
<li><a href="../ja499662/index.html">IoTおよびその他のIoTセキュリティトレンドに対する信頼のルート</a></li>
<li><a href="../ja499664/index.html">APIをTypeScriptに移植して問題を解決する</a></li>
<li><a href="../ja499668/index.html">JavaScriptの依存関係を地獄への道</a></li>
<li><a href="../ja499670/index.html">私はjavascriptに切り替えています</a></li>
<li><a href="../ja499674/index.html">光コンピューターへのもう一つのステップ</a></li>
<li><a href="../ja499676/index.html">Kubernetes用の90以上の便利なツール：デプロイ、管理、モニタリング、セキュリティなど</a></li>
<li><a href="../ja499680/index.html">Kubernetesの学習：基本的な5月14〜16日、上級5月18〜20日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>