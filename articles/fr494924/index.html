<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 🗻 🤹🏻 La mise en œuvre de l'effet aquarelle dans les jeux 🛄 🕝 💐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="introduction
 Quand, en janvier 2019, nous avons commencé à discuter de notre nouveau jeu de teintes. , nous avons immédiatement décidé que l'effet aq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>La mise en œuvre de l'effet aquarelle dans les jeux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494924/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9b/8bc/7c5/f9b8bc7c53c4d97ed983c428ce53926b.gif" alt="image"></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quand, en janvier 2019, nous avons commencé à discuter de notre nouveau jeu de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teintes.</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous avons immédiatement décidé que l'effet aquarelle serait l'élément le plus important. Inspirés par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette publicité </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bulgari</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous avons réalisé que la mise en œuvre de l'aquarelle devait être cohérente avec la haute qualité des ressources restantes que nous avions prévu de créer. Nous avons trouvé un article intéressant par des chercheurs d'Adobe </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La technique d'aquarelle qui y est décrite était merveilleuse et, en raison de sa nature vectorielle (plutôt que pixelisée), elle pouvait fonctionner même sur des appareils mobiles faibles. Notre implémentation est basée sur cette étude, nous en avons modifié et / ou simplifié certaines parties car nos exigences de performance étaient différentes. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teinte</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est un jeu, par conséquent, en plus du dessin lui-même, nous devions rendre l'environnement 3D entier et exécuter la logique du jeu dans une seule image. </font><font style="vertical-align: inherit;">Nous avons également cherché à nous assurer que la simulation était effectuée en temps réel et que le joueur voyait immédiatement ce qui était dessiné.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/277/d95/2e8277d95ed5a29796176e375ecf59c5.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation d'aquarelle en teinte. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous partagerons les détails individuels de la mise en œuvre de cette technique dans le moteur de jeu Unity et expliquerons comment nous l'avons adaptée pour fonctionner de manière transparente sur les appareils mobiles bas de gamme. </font><font style="vertical-align: inherit;">Nous parlerons davantage des principales étapes de cet algorithme, mais sans démontrer le code. </font><font style="vertical-align: inherit;">Cette implémentation a été créée dans Unity 2018.4.2 et mise à jour ultérieurement vers la version 2018.4.7.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la teinte.?</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teinte</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- C'est un jeu de puzzle qui permet au joueur de compléter les niveaux, en mélangeant les couleurs des aquarelles pour qu'elles correspondent aux couleurs de l'origami. </font><font style="vertical-align: inherit;">Le jeu est sorti à l'automne 2019 sur Apple Arcade pour iOS, macOS et tvOS.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/630/d46/bb0630d469679d86535ec46fd97c8f0a.png" width="2224" height="1668"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teinte de capture d'écran.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exigences</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La technique décrite dans mon article peut être divisée en trois étapes principales effectuées dans chaque cadre:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Générez de nouveaux spots en fonction de l'entrée du joueur et ajoutez-les à la liste des spots</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation de peinture pour tous les spots de la liste</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu ponctuel</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessous, nous parlerons en détail de la façon dont nous avons mis en œuvre chacune des étapes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre objectif était d'atteindre 60 FPS, c'est-à-dire que ces étapes et toute la logique décrite ci-dessous sont exécutées 60 fois par seconde.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenir des commentaires</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans chaque image, nous transformons l'entrée du joueur (selon la plate-forme, il peut s'agir d'une touche, de la position de la souris ou du curseur virtuel) en une structure </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui contient la position, le vecteur de mouvement, la couleur et la pression (2). Tout d'abord, nous vérifions la longueur de balayage du joueur à l'écran et la comparons avec une valeur de seuil donnée. Avec des balayages courts, nous générons un spot par image à la position d'entrée. Dans le cas contraire, nous remplissons la distance entre les points de début et de fin du balayage du joueur avec de nouveaux points créés avec une densité prédéterminée (cela garantit une densité de peinture constante quelle que soit la vitesse de balayage). La couleur indique la peinture actuellement utilisée et la pente du mouvement indique la direction du balayage. De nouveaux spots créés sont ajoutés à une collection appelée </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui contient également tous les spots créés précédemment. </font><font style="vertical-align: inherit;">Il est utilisé pour simuler et rendre la peinture dans les étapes suivantes. </font><font style="vertical-align: inherit;">Chaque tache individuelle dénote une «goutte» de peinture qui doit être rendue - le bloc de construction principal de la peinture à l'aquarelle. </font><font style="vertical-align: inherit;">Le dessin aquarelle fini sera le résultat du rendu de dizaines / centaines de points d'intersection. </font><font style="vertical-align: inherit;">De plus, la valeur de la durée de vie (en images) est affectée au spot nouvellement créé, ce qui détermine la durée de simulation du spot.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/e15/628/ccbe15628a553ba6ceb25af2fd2e2e36.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple d'interpolation de longs spots de balayage. </font><font style="vertical-align: inherit;">Les cercles creux indiquent des taches créées à intervalles réguliers.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toile</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme la vraie peinture, nous avons besoin d'une toile. </font><font style="vertical-align: inherit;">Pour l'implémenter, nous avons créé une zone limitée dans l'espace 3D qui ressemble à une feuille de papier. </font><font style="vertical-align: inherit;">Les coordonnées d'entrée du lecteur et toutes les autres opérations, telles que le rendu d'un maillage, sont enregistrées dans l'espace de canevas. </font><font style="vertical-align: inherit;">De même, la taille en pixels de tout tampon utilisé pour simuler le dessin dépend de la taille du canevas. </font><font style="vertical-align: inherit;">Le terme «canvas» tel qu'il est utilisé dans cet article n'est en aucun cas associé à la classe Canvas de Unity UI.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/367/1cc/6483671ccaa809a93bcf2a276cdd2471.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le rectangle vert montre la zone de toile dans le jeu</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Place</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visuellement, le spot est représenté par un maillage rond dont le bord est composé de 25 sommets. Vous pouvez le percevoir comme une «goutte» qu'un pinceau humide laisse sur un morceau de papier si vous le touchez pendant un très court instant. Nous ajoutons un petit décalage aléatoire à la position de chaque sommet, ce qui assure l'inégalité des bords des taches de peinture.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/baa/daa/9bbbaadaaf2b6d0fc1b295f5739ff083.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples de mailles maillées.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour chaque sommet, nous stockons également le vecteur de vitesse vers l'extérieur, qui est ensuite utilisé dans la phase de simulation. Nous générons plusieurs de ces maillages avec de petites variations entre les formes et stockons leurs données dans un objet skriptuemy ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objet scriptable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Chaque fois qu'un joueur dessine une place en temps réel, nous lui attribuons un maillage choisi aléatoirement dans cet ensemble. Il convient de mentionner qu'à différentes résolutions d'écran, la toile a une taille différente en pixels. Pour que sur tous les appareils le coefficient de la taille des spots soit le même, lorsque le jeu démarre, on change l'échelle en fonction de la taille de la toile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1af/f92/8de/1aff928de51a35f64351fe72f5c10d80.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de vecteurs ponctuels stockés avec de nouvelles données ponctuelles.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lorsqu'un maillage ponctuel est généré, nous enregistrons également sa «zone de mouillage», qui définit un ensemble de pixels qui se trouvent à l'intérieur des bordures ponctuelles d'origine. La zone de mouillage est utilisée pour simuler l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advection</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lors de l'exécution de l'application au moment de la création de chaque nouveau spot, nous marquons la toile en dessous comme mouillée. Lors de la simulation du mouvement de la peinture, nous lui permettons de "s'étendre" sur les zones de la toile qui sont déjà mouillées. Nous stockons la teneur en humidité de la toile dans le tampon global de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carte humide</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est mis à jour à mesure que chaque nouveau spot est ajouté. En plus de participer au mélange de deux couleurs, l'advection joue un rôle important dans l'apparence finale du trait de peinture lui-même.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/843/67e/31d84367e786d15bd7fe0f59cbe2e3a5.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplissage de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les pixels à l'intérieur de la forme du spot (cercle vert) marquent le tampon de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (grille) comme mouillé (vert). </font><font style="vertical-align: inherit;">Le tampon wetmap lui-même a une résolution beaucoup plus élevée. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, chaque tache contient également une valeur d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacité</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est fonction de sa surface; </font><font style="vertical-align: inherit;">il représente l'effet du stockage du pigment (une quantité constante de pigment sur place). </font><font style="vertical-align: inherit;">Lorsque la taille d'un point augmente pendant la simulation, son opacité diminue et vice versa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/870/a5b/a88870a5b213286e20815f3b87ecca5d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de peinture sans advection (à gauche) et avec elle (à droite).</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/069/348/341069348c265951c765843ca792b2c8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples d'advection de peinture.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cycle de simulation</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois que l'entrée du joueur dans l'image actuelle est reçue et convertie en nouveaux spots, l'étape suivante consiste à simuler les spots pour simuler la propagation des aquarelles. Au début de cette simulation, nous avons une liste de spots qui doivent être mis à jour et une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mise à jour </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans chaque image, nous parcourons la liste des spots et modifions les positions de tous les sommets des spots en utilisant l'équation suivante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6fe/91a/4b86fe91ae4f677697b43e99a3299ecc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
où: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le nouveau vecteur de mouvement, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le paramètre de correction constant (0,33), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le vecteur de pente de mouvement = direction normalisée du balayage du joueur multiplié par 0,3, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la valeur scalaire de la rugosité de la toile = Random.Range (1,1 + r), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le paramètre de rugosité global, pour la peinture standard, nous le fixons à 0,4, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le vecteur de vitesse créé à l'avance avec le maillage ponctuel, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le facteur de vitesse, la valeur scalaire que nous utilisons localement dans certaines situations pour accélérer l'advection, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nouvelle position potentielle du sommet, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - position actuelle du sommet, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est le vecteur de rugosité de la branche = (Random.Range (-r, r), Random.Range (-r, r)), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w (x)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la valeur de mouillage dans le tampon de la carte humide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat de ces équations est appelé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">marche aléatoire biaisée</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il imite le comportement des particules dans de la vraie peinture aquarelle. Nous essayons de déplacer chaque sommet du point vers l'extérieur à partir de son centre ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), en ajoutant du hasard. Ensuite, la direction du mouvement change légèrement avec la direction de la course ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et est à nouveau randomisée par une autre composante de rugosité ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ensuite, cette nouvelle position de sommet est comparée à un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si le canevas dans la nouvelle position était déjà mouillé (valeur dans le tampon de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supérieur à 0), alors nous donnons au sommet une nouvelle position </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sinon nous ne changeons pas sa position. </font><font style="vertical-align: inherit;">Par conséquent, la peinture ne se répandra que dans les zones de la toile qui étaient déjà humides. </font><font style="vertical-align: inherit;">À la dernière étape, nous recalculons la zone spot, qui est utilisée dans le cycle de rendu pour modifier son opacité.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a69/742/ae4/a69742ae4ee6d91b27bac6397bd317ff.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple à l'échelle microscopique de simulation d'advection entre deux taches de peinture actives.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cycle de rendu - Tampon humide</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir raconté les spots, vous pouvez commencer à les rendre. À la sortie après la phase d'émulation, le maillage des taches se révèle souvent déformé (par exemple, des intersections se produisent), donc, pour leur rendu correct sans coûts supplémentaires pour la triangulation répétée, nous utilisons une solution avec un tampon de pochoir à deux passes. L'interface de dessin Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est utilisée pour le rendu des spots </font><font style="vertical-align: inherit;">, et le cycle de rendu est effectué à l'intérieur de la méthode Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnPostRender</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les maillages ponctuels sont rendus pour rendre la texture ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) à l'aide d'une caméra distincte. Au début du cycle, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est effacé et défini comme cible de rendu à l'aide de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics.SetRenderTarget (wetBuffer)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Suivant pour chaque spot actif de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous exécutons la séquence montrée dans le diagramme suivant:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/a09/328/1e7a0932807463744d7fd50a40fddedc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramme du cycle de rendu. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons par nettoyer le tampon de pochoir avant chaque point afin que l'état du tampon de pochoir du point précédent n'affecte pas le nouveau point. </font><font style="vertical-align: inherit;">Ensuite, nous sélectionnons le matériau utilisé pour dessiner le spot. </font><font style="vertical-align: inherit;">Ce matériau est responsable de la couleur du spot, et nous le sélectionnons en fonction de l'indice de couleur stocké dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque le joueur a </font><em><font style="vertical-align: inherit;">dessiné le</font></em><font style="vertical-align: inherit;"> spot. </font><font style="vertical-align: inherit;">Ensuite, nous modifions l'opacité des couleurs (canal alpha) en fonction de la zone du maillage ponctuel calculée à l'étape précédente. </font><font style="vertical-align: inherit;">Le rendu lui-même est effectué à l'aide d'un shader de tampon de pochoir à deux passes. </font><font style="vertical-align: inherit;">Dans la première passe (Material.SetPass (0)), nous passons le maillage ponctuel d'origine pour enregistrer les coordonnées dans lesquelles le maillage est rempli. </font><font style="vertical-align: inherit;">Avec ce pass </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ColorMask</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assigné une valeur de 0, donc le maillage lui-même n'est pas rendu. </font><font style="vertical-align: inherit;">Dans la deuxième passe (Material.SetPass (1)), nous utilisons le quadrilatère décrit autour du maillage ponctuel. </font><font style="vertical-align: inherit;">Nous vérifions la valeur dans le tampon de pochoir pour chaque pixel du quadrilatère; </font><font style="vertical-align: inherit;">si la valeur est un, le pixel est rendu, sinon il est ignoré. </font><font style="vertical-align: inherit;">À la suite de cette opération, nous rendons la même forme que le maillage ponctuel, mais il ne contiendra certainement pas d'artefacts indésirables, par exemple, des auto-intersections.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a9/06b/beb/1a906bbeb3f003d057430f6fb28e9257.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La procédure pour effectuer la technique du tampon double stencil (de gauche à droite). </font><font style="vertical-align: inherit;">Notez que ce tampon de pochoir a une résolution beaucoup plus élevée que celle illustrée, de sorte qu'il peut conserver sa forme d'origine avec une grande précision.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/15d/3ae/ed515d3aec23cd4eb9041761913afd2c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de trois points d'intersection rendus de manière traditionnelle, ce qui a conduit à l'apparition d'artefacts (à gauche), et en utilisant la technique de tampon de pochoir en deux passes avec l'élimination de tous les artefacts (à droite).</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Après avoir rendu tous les spots dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il s'affiche dans la scène du jeu. Notre toile utilise un shader de fortune combinant un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une carte papier diffuse et une carte normale papier.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/968/db5/55a/968db555a2a477134013c355e3898e90.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canvas shader: uniquement wetBuffer (à gauche), texture du papier ajoutée (au centre), carte normale ajoutée (à droite). </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le jeu prend en charge un mode pour les personnes daltoniennes, dans lequel des motifs séparés sont superposés sur la peinture. </font><font style="vertical-align: inherit;">Pour ce faire, nous avons changé le matériau des taches en ajoutant la texture du motif avec du carrelage. </font><font style="vertical-align: inherit;">Les motifs suivent les règles de mélange des couleurs du jeu, par exemple, le bleu (barres) + le jaune (cercles) donnent le vert (cercles dans les barres) à l'intersection. </font><font style="vertical-align: inherit;">Pour mélanger les motifs de manière transparente, ils doivent être rendus dans le même espace UV. </font><font style="vertical-align: inherit;">Nous ajustons les coordonnées UV du quadrilatère utilisé dans la deuxième passe du tampon de pochoir, en divisant les positions x et y (qui sont spécifiées dans l'espace du canevas) par la largeur et la hauteur du canevas. </font><font style="vertical-align: inherit;">Par conséquent, nous obtenons les valeurs correctes de u, v dans l'espace de 0 à 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b5/057/211/7b50572119f116fae451dd321275a920.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de motifs de daltonisme.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisation - tampon de taches séchées</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionné ci-dessus, l'une de nos tâches consistait à prendre en charge les appareils mobiles à faible consommation. </font><font style="vertical-align: inherit;">Le rendu spot s'est avéré être le goulot d'étranglement de notre jeu. </font><font style="vertical-align: inherit;">Chaque point nécessite trois appels de tirage (appelez deux passes + effacez le tampon du pochoir), et comme la ligne de peinture contient des dizaines ou des centaines de points, le nombre d'appels de tirage augmente rapidement et entraîne une baisse de la fréquence d'images. </font><font style="vertical-align: inherit;">Pour y faire face, nous avons appliqué deux techniques d'optimisation: d'une part, le dessin simultané de tous les spots «séchés» dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et d'autre part, l'accélération locale du séchage des spots après avoir atteint un certain nombre de spots actifs. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est une texture de rendu supplémentaire ajoutée au cycle de rendu. Comme mentionné précédemment, chaque spot a une durée de vie (en images), qui diminue avec chaque image. Une fois que la durée de vie atteint 0, la tache est considérée comme «séchée». Les zones sèches ne sont plus simulées, leur forme ne change pas et il n'est donc pas nécessaire de les rendre à nouveau dans chaque image.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/afe/714/b44afe714c3be2aed6d853d031e2379a.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DryBuffer en action; les taches grises montrent les taches copiées sur dryBuffer.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Chaque tache dont la durée de vie atteint 0 est supprimée de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et «copiée» dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pendant le processus de copie, le cycle de rendu est réutilisé et cette fois, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est défini comme texture de rendu cible </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un mélange correct entre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut pas être obtenu en chevauchant simplement les tampons dans le shader de toile, car la texture de </font><em><font style="vertical-align: inherit;">rendu du</font></em><font style="vertical-align: inherit;"> tampon </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient des taches déjà rendues avec une valeur alpha (ce qui équivaut à un alpha prémultiplié). </font><font style="vertical-align: inherit;">Nous avons contourné ce problème en ajoutant une étape au début du cycle de rendu avant de parcourir itérativement les spots. </font><font style="vertical-align: inherit;">À ce stade, nous rendons un quadrilatère de la taille d'une pyramide de découpage de caméra qui affiche </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Grâce à cela, toute tache qui est rendue dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera déjà mélangée avec des taches sèches, préalablement peintes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/afe/417/24eafe41762bcd3e7b2363e78c8bb9c0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un mélange de taches humides et séchées. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tampon </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> accumule tous les points «secs» et n'est pas effacé entre les images. </font><font style="vertical-align: inherit;">Par conséquent, toute la mémoire associée aux taches expirées peut être effacée après avoir été «copiée» dans le tampon.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/aa0/5bd/00eaa05bd29ca5c46eb8a845accc0b75.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grâce à l'optimisation avec </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous n'avons plus de limites sur la quantité de peinture qu'un joueur peut appliquer sur la toile.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
L'utilisation de la technique </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> séparément permet au joueur de dessiner avec une quantité presque infinie de peinture, mais ne garantit pas des performances constantes. Comme mentionné ci-dessus, le trait de peinture a une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">épaisseur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constante </font><font style="vertical-align: inherit;">, qui est obtenue en dessinant en utilisant l'interpolation de nombreux points entre les points de début et de fin du balayage. Dans le cas de nombreux balayages rapides et longs, le joueur peut générer un grand nombre de spots actifs. Ces spots seront simulés et rendus sur le nombre d'images spécifié par leur durée de vie, ce qui conduit finalement à des fréquences d'images plus faibles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour garantir une fréquence d'images stable, nous avons modifié l'algorithme afin que le nombre de spots actifs soit limité par une valeur constante de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tous les points dépassant cette valeur se "dessèchent" instantanément. Ceci est réalisé en réduisant la durée de vie des taches actives les plus anciennes à 0, c'est pourquoi elles sont copiées plus tôt dans le tampon de taches séchées. Étant donné que lorsque nous raccourcissons la durée de vie, nous obtenons une place dans l'état incomplet de la simulation (qui aura l'air assez intéressant), en même temps, nous augmentons la vitesse d'étalement de la peinture. En raison de l'augmentation de la vitesse, le spot atteint presque la même taille qu'à vitesse normale avec une durée de vie standard.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/c68/4c9/907c684c9c3642f6a109b4cadcf8718c.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/fe2/72b/d79fe272b648131541bfbf423384fc29.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démonstration de 40 points actifs maximum (en haut) et 80 (en bas). </font><font style="vertical-align: inherit;">Les taches séchées copiées dans dryBuffer sont affichées en gris. </font><font style="vertical-align: inherit;">La valeur indique la «quantité» de peinture qui peut être simulée en même temps. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le paramètre de performance le plus important, il nous permet de contrôler avec précision le nombre d'appels de dessin que nous pouvons allouer au rendu aquarelle. </font><font style="vertical-align: inherit;">Nous le définissons au démarrage, en fonction de la puissance de la plate-forme et de l'appareil. </font><font style="vertical-align: inherit;">Vous pouvez également modifier cette valeur pendant l'exécution de l'application si une diminution de la fréquence d'images est détectée.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mise en œuvre de cet algorithme est devenue une tâche intéressante et difficile. </font><font style="vertical-align: inherit;">Nous espérons que les lecteurs ont apprécié l'article. </font><font style="vertical-align: inherit;">Vous pouvez poser des questions dans les commentaires à l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous voulez apprécier notre aquarelle en action, essayez de jouer à la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teinte. </font><font style="vertical-align: inherit;">sur l'Apple Arcade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/89e/fda/95989efda4d27809e1ce3923b341ac46.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capture d'écran d'un jeu fonctionnant sur Apple TV</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1) S. DiVerdi, A. Krishnaswamy, R. MÄch et D. Ito, «Painting with Polygons: A Procedural Watercolour Engine», dans IEEE Transactions on Visualization and Computer Graphics, vol. </font><font style="vertical-align: inherit;">19, non. </font><font style="vertical-align: inherit;">5, pp. </font><font style="vertical-align: inherit;">723–735, mai 2013. doi: 10.1109 / TVCG.2012.295 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(2) La pression n'est prise en compte que lors du dessin de l'Apple Pencil sur un iPad.</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr494912/index.html">Ma contribution à la protection contre Covid-19</a></li>
<li><a href="../fr494916/index.html">Comment vendre des comptes marchands et surfer sur une vague d'intérêt pour les affaires en ligne</a></li>
<li><a href="../fr494918/index.html">La troisième semaine du vol à distance - normal. Commentaires des gars de l'informatique QIWI sur le travail à temps plein à domicile</a></li>
<li><a href="../fr494920/index.html">Mauvais conseil au développeur: que faire pour «faire plaisir» à la direction</a></li>
<li><a href="../fr494922/index.html">Nizhny Novgorod pour un informaticien: perspectives de travail et opportunités de vie</a></li>
<li><a href="../fr494938/index.html">Bonne journée de sauvegarde! Ne l'oublie pas</a></li>
<li><a href="../fr494940/index.html">DevOps - qu'est-ce que c'est, pourquoi et combien est-il demandé?</a></li>
<li><a href="../fr494942/index.html">CGI à la maison avec Unreal Engine et iPhone</a></li>
<li><a href="../fr494950/index.html">Quelques tendances de stockage à surveiller</a></li>
<li><a href="../fr494956/index.html">Durée de vie des octets de données</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>