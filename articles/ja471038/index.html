<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐰 ↔️ ❌ Linux記述子ファイルと例 🤰🏾 🌦️ 👇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="あるインタビューで、ディスクの空き容量がなくなったために機能していないサービスを見つけたらどうするかと尋ねられました。
 
 もちろん、私はこの場所が何で占められているかを確認し、可能であれば、その場所を掃除すると答えました。
 次に、インタビュアーは、セクションに空きスペースがない場合はどうなるの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Linux記述子ファイルと例</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるインタビューで、ディスクの空き容量がなくなったために機能していないサービスを見つけたらどうするかと尋ねられました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、私はこの場所が何で占められているかを確認し、可能であれば、その場所を掃除すると答えました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、インタビュアーは、セクションに空きスペースがない場合はどうなるのかと尋ねましたが、場所全体を占めるファイルも表示されていませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについては、たとえばlsofコマンドを使用して開いているファイル記述子を常に確認し、どのアプリケーションがすべての使用可能なスペースを占有したかを理解でき、データが必要かどうかに応じて、状況に応じて続行できると述べました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタビュアーが最後の言葉で私に割り込み、私の質問を追加しました：「データが必要ない場合、それは単なるデバッグログですが、アプリケーションはデバッグを記録できないため機能しません」？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「わかりました。「アプリケーションの設定でデバッグをオフにして再起動できます。」</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタビュアーは反対しました：「いいえ、アプリケーションを再起動することはできません。重要なデータはメモリに保存されており、重要なクライアントはサービス自体に接続されているため、強制的に再接続することはできません。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「そうですね」と私は言いました。「アプリケーションを再起動できず、データが重要でない場合は、ファイルシステムのlsコマンドに表示されていなくても、ファイル記述子を使用してこの開いているファイルをクリアできます。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面接官は喜んだが、私はそうではなかった。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、なぜ私の知識をテストしている人はもっと深く掘り下げないのかと思いました。</font><font style="vertical-align: inherit;">しかし、データが依然として重要な場合はどうでしょうか？</font><font style="vertical-align: inherit;">プロセスを再起動できず、同時にこのプロセスが空き領域がないセクションのファイルシステムに書き込む場合はどうなりますか？</font><font style="vertical-align: inherit;">すでに記録されているデータだけでなく、このプロセスが書き込みまたは記録しようとするデータも失うことができない場合はどうなりますか？</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トゥジク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャリアの初めに、ユーザーに関する情報を保存する必要がある小さなアプリケーションを作成しようとしました。そして、どうすればユーザーを彼のデータにマッピングできるでしょうか。たとえば、私はIvan Ivanov Ivanichを持っていますが、彼はいくつかのデータを持っていますが、どうやってそれらと友達にするのですか？ 「Tuzik」という名前の犬がこのIvanに属していることを直接示すことができます。しかし、彼が自分の名前を変更し、イヴァンの代わりに、たとえばオリヤになった場合はどうなりますか？それから、我々のOlya Ivanovna Ivanovaはもはや犬を持たず、私たちのTuzikはまだ存在しないIvanに属していることがわかります。このデータベースは、各ユーザーに一意の識別子（ID）を提供するデータベースによって支援され、私のTuzikは実際には単なる序数であるこのIDに添付されていました。したがって、tuzikの所有者はID番号2でした。ある時点で、IvanはこのIDでしたが、Olyaは同じIDになりました。人類と畜産の問題は実質的に解決されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル記述子</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルとこのファイルを扱うプログラムの問題は、私たちの犬と人の問題とほぼ同じです。</font><font style="vertical-align: inherit;">ivan.txtという名前のファイルを開き、tuzikという単語の書き込みを開始したが、最初の文字「t」のみをファイルに書き込むことができ、このファイルの名前がolya.txtなどに変更されたとします。</font><font style="vertical-align: inherit;">しかし、ファイルは同じままで、私はそれでも私のエースを書きたいです。</font><font style="vertical-align: inherit;">あなたは、ファイルシステムコール開くたび</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンします</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのプログラミング言語でも、ファイルを指す一意のIDを取得します。このIDはファイル記述子です。</font><font style="vertical-align: inherit;">そして、誰もがこのファイルで次に何をするかは関係ありません、彼らはそれを削除したり、名前を変更したり、所有者を変更したり、読み取りと書き込みの権限を奪ったりすることができます。ファイルが開かれているので、私は引き続きアクセスできます。私にはそれを読んだり書いたりする権利があり、なんとか彼と一緒に仕事を始めることができました。つまり、これを続けなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxでは、実行中のアプリケーション（プロセス）3記述子ファイルごとに、0、1、2という番号のlibcライブラリが開きます。</font><font style="vertical-align: inherit;">詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">man stdio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">man stdoutの</font></a><font style="vertical-align: inherit;">リンクを参照してください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a> <br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル記述子0はSTDINと呼ばれ、アプリケーションからのデータ入力に関連付けられています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル記述子1はSTDOUTと呼ばれ、アプリケーションがデータを出力するために使用されます（印刷コマンドなど）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル記述子2はSTDERRと呼ばれ、アプリケーションがエラー報告データを出力するために使用されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムで読み取りまたは書き込み用にファイルを開いた場合、おそらく最初の無料IDが取得され、これが3番になります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。PIDがわかっている場合は、プロセスの記述子ファイルのリストを表示できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、bashでコンソールを開き、プロセスのPIDを確認します</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in">echo</span> $$<font></font>
15771<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のコンソールで、次を実行します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  7 15:42 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  7 15:42 ..<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 0 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 2 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 255 -&gt; /dev/pts/21<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事のフレームワーク内のファイル記述子番号255は無視しても問題ありません。リンクされたライブラリではなく、bash自体によって必要に応じて開かれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、3つの記述子ファイルすべてが疑似端末デバイス</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / pts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">関連付けられますが</font><font style="vertical-align: inherit;">、それらを操作することもできます。たとえば、2番目のコンソールで実行します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello world"</span> &gt; /proc/15771/fd/0
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、最初のコンソールでは、</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ hello world
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リダイレクトとパイプ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、2つのプロセスを接続するパイプを介して、bashを含む任意のプロセスでこれらの3つの記述子ファイルを簡単にオーバーライドできます。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000
</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strace -f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">
してこのコマンドを自分で実行し、</font><font style="vertical-align: inherit;">内部で何が起こるかを確認できますが、簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PID 15771の親プロセスbashはコマンドを解析し、実行するコマンドの数を正確に理解します。この例では、catとsleepの2つがあります。バッシュは、2つの子プロセスを作成し、それらを1つのパイプと組み合わせる必要があることを知っています。合計bashには2つの子プロセスと1つのパイプが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子プロセスを作成する前に、bashは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコール</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">開始</font><font style="vertical-align: inherit;">し、一時パイプバッファーの新しいファイル記述子を受け取りますが、このバッファーはまだ2つの子プロセスをバインドしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
親プロセスの場合、パイプはすでに存在しているように見え、まだ子プロセスはありません。</font></font><br>
<br>
<pre><code class="bash hljs">PID    <span class="hljs-built_in">command</span><font></font>
15771  bash<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 0 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 2 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 3 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 4 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 255 -&gt; /dev/pts/21<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、システムコールを使用して、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bashは2つの子プロセスを作成し、3つのプロセスは次のようになります。</font></font><br>
<br>
<pre><code class="bash hljs">PID    <span class="hljs-built_in">command</span><font></font>
15771  bash<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 0 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 2 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 3 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 4 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 255 -&gt; /dev/pts/21<font></font>
PID    <span class="hljs-built_in">command</span><font></font>
9004  bash<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 0 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 2 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 3 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 4 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 255 -&gt; /dev/pts/21<font></font>
PID    <span class="hljs-built_in">command</span><font></font>
9005  bash<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 0 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 2 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 3 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 4 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 255 -&gt; /dev/pts/21<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
親プロセスと子プロセスで同じになるように、cloneはすべてのファイル記述子とともにプロセスを複製することを忘れないでください。</font><font style="vertical-align: inherit;">PID 15771の親プロセスのタスクは子プロセスを監視することなので、子プロセスからの応答を待つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、彼はパイプを必要とせず、番号3と4のファイル記述子を閉じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の子プロセスであるPID 9004のbash、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコールは</font><font style="vertical-align: inherit;">、STDOUTファイルを変更します。番号1の記述子をパイプを指すファイル記述子に変更します。 3.したがって、PID 9004の最初の子プロセスがSTDOUTに書き込むすべてのものが自動的にパイプバッファーに入れられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PID 9005の2番目の子プロセスでは、bashはdup2を使用して番号0のファイル記述子STDINを変更します。これで、PID 9005の2番目のbashが読み取るすべてのものがパイプから読み取られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、番号3と4の記述子も使用されなくなったため、子プロセスでも閉じられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は故意にファイル記述子255を無視します。これは内部のニーズにbashを使用し、子プロセスでも閉じられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、PID 9004の最初の子プロセスでは、bashは、システムコール</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exec</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">してコマンドライン</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">指定した実行可能ファイルを</font><font style="vertical-align: inherit;">起動し</font><font style="vertical-align: inherit;">ます。この場合、/ usr / bin / catです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PID 9005の2番目の子プロセスでは、bashは、指定した2番目の実行可能ファイル（この場合は/ usr / bin / sleep）を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
execシステムコールは、ファイル記述子がopen呼び出し中にO_CLOEXECフラグで開かれなかった場合、ファイル記述子を閉じません。</font><font style="vertical-align: inherit;">私たちの場合、実行可能ファイルを実行した後、現在のすべてのファイル記述子が保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンソールで確認します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ pgrep -P 15771<font></font>
9004<font></font>
9005<font></font>
[user@localhost ]$ ls -lah /proc/15771/fd/<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  7 15:42 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  7 15:42 ..<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 0 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 2 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:42 255 -&gt; /dev/pts/21<font></font>
[user@localhost ]$ ls -lah /proc/9004/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  7 15:57 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  7 15:57 ..<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 0 -&gt; /dev/pts/21<font></font>
l-wx------ 1 user user 64 Oct  7 15:57 1 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 2 -&gt; /dev/pts/21<font></font>
lr-x------ 1 user user 64 Oct  7 15:57 3 -&gt; /dev/zero<font></font>
[user@localhost ]$ ls -lah /proc/9005/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  7 15:57 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  7 15:57 ..<font></font>
lr-x------ 1 user user 64 Oct  7 15:57 0 -&gt; pipe:[253543032]<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 1 -&gt; /dev/pts/21<font></font>
lrwx------ 1 user user 64 Oct  7 15:57 2 -&gt; /dev/pts/21<font></font>
[user@localhost ]$ ps -up 9004<font></font>
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<font></font>
user  9004  0.0  0.0 107972   620 pts/21   S+   15:57   0:00 cat /dev/zero<font></font>
[user@localhost ]$ ps -up 9005<font></font>
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<font></font>
user  9005  0.0  0.0 107952   360 pts/21   S+   15:57   0:00 sleep 10000<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、パイプの一意の数は両方のプロセスで同じです。</font><font style="vertical-align: inherit;">したがって、1つの親を持つ2つの異なるプロセス間の接続があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bashが使用するシステムコールに精通していない場合は、straceを使用してコマンドを実行し、たとえば次のように内部で何が発生するかを確認することを強くお勧めします。</font></font><br>
<br>
<pre><code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string">"ls | grep hello"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスク領域が不足し、プロセスを再起動せずにデータを保存しようとした場合の問題に戻りましょう。</font><font style="vertical-align: inherit;">毎秒約1メガバイトをディスクに書き込む小さなプログラムを書いてみましょう。</font><font style="vertical-align: inherit;">さらに、何らかの理由でデータをディスクに書き込めなかった場合は、それを無視して、1秒後にもう一度データを書き込もうとします。</font><font style="vertical-align: inherit;">私がPythonを使用する例では、他のプログラミング言語を使用できます。</font></font><br>
<br>
<pre><code class="python hljs">[user@localhost ]$ cat openforwrite.py 
<span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> time<font></font>
<font></font>
mystr=<span class="hljs-string">"a"</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>+<span class="hljs-string">"\n"</span>
<span class="hljs-keyword">with</span> open(<span class="hljs-string">"123.txt"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">try</span>:<font></font>
            f.write(str(datetime.datetime.now()))<font></font>
            f.write(mystr)<font></font>
            f.flush()<font></font>
            time.sleep(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">pass</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムを実行し、ファイル記述子を確認します</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp;<font></font>
[1] 3762<font></font>
[user@localhost ]$ ps axuf | grep [o]penforwrite<font></font>
user  3762  0.0  0.0 128600  5744 pts/22   S+   16:28   0:00  |   \_ python openforwrite.py<font></font>
[user@localhost ]$ ls -la /proc/3762/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  7 16:29 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  7 16:29 ..<font></font>
lrwx------ 1 user user 64 Oct  7 16:29 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  7 16:29 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  7 16:29 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  7 16:29 3 -&gt; /home/user/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、3つの標準ファイル記述子と、もう1つ開いたファイル記述子があります。</font><font style="vertical-align: inherit;">ファイルサイズを確認します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ ls -lah 123.txt <font></font>
-rw-rw-r-- 1 user user 117M Oct  7 16:30 123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データが書き込まれたら、ファイルの権限を変更してみてください：</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt<font></font>
[user@localhost ]$ ls -lah 123.txt <font></font>
-rw-rw-r-- 1 root root 168M Oct  7 16:31 123.txt<font></font>
[user@localhost ]$ ls -lah 123.txt <font></font>
-rw-rw-r-- 1 root root 172M Oct  7 16:31 123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーにはファイルに書き込む権限がありませんが、データはまだ書き込まれていることがわかります。</font><font style="vertical-align: inherit;">それを削除してみましょう：</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ sudo rm 123.txt <font></font>
[user@localhost ]$ ls 123.txt<font></font>
ls: cannot access 123.txt: No such file or directory<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データはどこに書き込まれますか？</font><font style="vertical-align: inherit;">そして、それらはまったく書かれていますか？</font><font style="vertical-align: inherit;">私たちはチェックします：</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  7 16:29 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  7 16:29 ..<font></font>
lrwx------ 1 user user 64 Oct  7 16:29 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  7 16:29 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  7 16:29 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  7 16:29 3 -&gt; /home/user/123.txt (deleted)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、記述子ファイルはまだ存在しており、この記述子ファイルを古いファイルと同じように操作できます。読み取り、クリーニング、およびコピーを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルサイズを確認します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt<font></font>
python    31083             user    3w      REG                8,5   19923457   2621522 /home/user/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルサイズ19923457。ファイルをクリアしようとしています：</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3<font></font>
[user@localhost ]$ lsof | grep 123.txt<font></font>
python    31083             user    3w      REG                8,5  136318390   2621522 /home/user/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ファイルサイズは増加するだけで、トランケートは機能しませんでした。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコールのドキュメントを参照してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ファイルを開くときにO_APPENDフラグを使用すると、オペレーティングシステムがファイルサイズを確認してデータをファイルの最後に書き込むたびに、これが自動的に行われます。</font><font style="vertical-align: inherit;">これにより、複数のスレッドまたはプロセスが同じファイルに書き込むことができます。</font><font style="vertical-align: inherit;">しかし、コードではこのフラグを使用していません。</font><font style="vertical-align: inherit;">上書き後にファイルを開いた場合にのみ、トランケート後にlsofで異なるファイルサイズを確認できます。つまり、コードではなく</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"123.txt"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは置く必要があります</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"123.txt"</span>, <span class="hljs-string">"a"</span>) <span class="hljs-keyword">as</span> f:
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「w」フラグで確認する</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt<font></font>
open(<span class="hljs-string">"123.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「a」フラグ付き</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt<font></font>
open(<span class="hljs-string">"123.txt"</span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに実行中のプロセスをプログラムする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、プログラマーはプログラムを作成およびテストするときに、デバッガー（GDBなど）またはさまざまなレベルのロギングをアプリケーションに使用します。</font><font style="vertical-align: inherit;">Linuxは、変数の値の変更、ブレークポイントの設定など、すでに実行中のプログラムを実際に作成および変更する機能を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルを書き込むのに十分なディスク容量がない状態で元の質問に戻り、問題をエミュレートしようとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のディスクとしてマウントするパーティション用のファイルを作成します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword">if</span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10<font></font>
10+0 records <span class="hljs-keyword">in</span><font></font>
10+0 records out<font></font>
10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s<font></font>
[user@localhost ~]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルシステムを作成します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd<font></font>
mke2fs 1.42.9 (28-Dec-2013)<font></font>
/home/user/tempfile_for_article.dd is not a block special device.<font></font>
Proceed anyway? (y,n) y<font></font>
...<font></font>
Writing superblocks and filesystem accounting information: <span class="hljs-keyword">done</span><font></font>
[user@localhost ~]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルシステムをマウントします。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/<font></font>
[sudo] password <span class="hljs-keyword">for</span> user: <font></font>
[user@localhost ~]$ df -h | grep mnt<font></font>
/dev/loop0      8.7M  172K  7.9M   3% /mnt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有者でディレクトリを作成します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs<font></font>
[user@localhost ~]$ sudo chown user: /mnt/logs<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムで書き込むためにのみファイルを開きます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"/mnt/logs/123.txt"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発売</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ python openforwrite.py 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数秒待ちます</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ df -h | grep mnt<font></font>
/dev/loop0      8.7M  8.0M     0 100% /mnt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この記事の冒頭で説明した問題が発生しました。</font><font style="vertical-align: inherit;">空き容量0が100％を占めています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの条件に応じて、失われない非常に重要なデータを記録しようとしていることを覚えています。</font><font style="vertical-align: inherit;">同時に、プロセスを再起動せずにサービスを修復する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクスペースはまだあるが、/ homeなどの別のパーティションにあるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを「オンザフライで再プログラミング」してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスのPIDを見て、すべてのディスク領域を消費しました。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor<font></font>
user 10078 27.2  0.0 128600  5744 pts/22   R+   11:06   0:02  |   \_ python openforwrite.py<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gdbを介してプロセスに接続します</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ gdb -p 10078<font></font>
...<font></font>
(gdb) <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開いているファイル記述子を調べます。</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:06 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:06 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:09 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:09 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:06 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:09 3 -&gt; /mnt/logs/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番のファイル記述子に関する情報を見てみましょう。</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3<font></font>
pos:    8189952<font></font>
flags:  0100001<font></font>
mnt_id: 482<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonが行うシステムコールの種類（上記を参照、straceを実行してopen呼び出しを見つけた場所）を思い出し、コードを処理してファイルを開きますが、自分のために同じことを行いますが、O_WRONLY | O_CREAT | O_TRUNCビットが必要です数値に置き換えます。</font><font style="vertical-align: inherit;">これを行うには、例えば、カーネルソースを開いて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とフラグが担当しているかを見る</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の#define O_WRONLY 00000001 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の#define O_CREAT 00000100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の#define O_TRUNC我々は00001000 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1にすべての値を組み合わせて、我々は00001101が得る</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は、GDBから私たちの呼び出しを起動します</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) call open(<span class="hljs-string">"/home/user/123.txt"</span>, 00001101,0666)
<span class="hljs-variable">$1</span> = 4
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、番号4の新しい記述子ファイルと、別のセクションにある新しいオープンファイルを取得しました。</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:06 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:06 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:09 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:09 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:06 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:09 3 -&gt; /mnt/logs/123.txt<font></font>
l-wx------ 1 user user 64 Oct  8 11:15 4 -&gt; /home/user/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプの例-bashがファイル記述子をどのように変更するかを覚えていますが、dup2システムコールについてはすでに学習しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるファイル記述子を別のファイル記述子に置き換えようとします</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) call dup2(4,3)
<span class="hljs-variable">$2</span> = 3
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはチェックします：</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:06 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:06 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:09 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:09 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:06 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:09 3 -&gt; /home/user/123.txt<font></font>
l-wx------ 1 user user 64 Oct  8 11:15 4 -&gt; /home/user/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記述子4ファイルは必要ないため、閉じます。</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) call close (4)
<span class="hljs-variable">$1</span> = 0
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてgdbを終了します</font></font><br>
<br>
<pre><code class="bash hljs">(gdb) quit<font></font>
A debugging session is active.<font></font>
<font></font>
    Inferior 1 [process 10078] will be detached.<font></font>
<font></font>
Quit anyway? (y or n) y<font></font>
Detaching from program: /usr/bin/python2.7, process 10078<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいファイルを確認します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt<font></font>
-rw-rw-r-- 1 user user 5.1M Oct  8 11:18 /home/user/123.txt<font></font>
[user@localhost ~]$ ls -lah /home/user/123.txt<font></font>
-rw-rw-r-- 1 user user 7.1M Oct  8 11:18 /home/user/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、データは新しいファイルに書き込まれます。古いファイルを確認します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt <font></font>
-rw-rw-r-- 1 user user 7.9M Oct  8 11:08 /mnt/logs/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データは失われず、アプリケーションは機能し、ログは新しい場所に書き込まれます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクを少し複雑にしましょう</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データは私たちにとって重要ですが、どのセクションにもディスク領域がなく、ディスクを接続できないと想像してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちができることは、パイプなどのどこかにデータをリダイレクトし、パイプからのデータは、netcatなどのプログラムを介してネットワークにリダイレクトすることです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mkfifoコマンドで名前付きパイプを作成できます。</font><font style="vertical-align: inherit;">空き領域がない場合でも、ファイルシステムに疑似ファイルが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを再起動して確認します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ]$ python openforwrite.py <font></font>
[user@localhost ~]$ ps axuf | grep [o]pen<font></font>
user  5946 72.9  0.0 128600  5744 pts/22   R+   11:27   0:20  |   \_ python openforwrite.py<font></font>
[user@localhost ~]$ ls -lah /proc/5946/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:27 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:27 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:27 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:28 3 -&gt; /mnt/logs/123.txt<font></font>
[user@localhost ~]$ df -h | grep mnt<font></font>
/dev/loop0      8.7M  8.0M     0 100% /mnt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクスペースはありませんが、名前付きパイプを正常に作成します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe<font></font>
[user@localhost ~]$ ls -lah /mnt/logs/megapipe <font></font>
prw-rw-r-- 1 user user 0 Oct  8 11:28 /mnt/logs/megapipe<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、このパイプに入るすべてのデータをネットワーク経由で別のサーバーにラップする必要があります。これは、すべて同じnetcatが行うためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
remote-server.example.comサーバーで、次を実行します。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題のサーバーで、別のターミナルで実行します</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、パイプに入るすべてのデータは自動的にnetcatのstdinに送られ、ポート7777でネットワークに送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なのは、この名前付きパイプにデータを書き込むことだけ</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに実行中のアプリケーションがあります：</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen<font></font>
user  5946 99.8  0.0 128600  5744 pts/22   R+   11:27 169:27  |   \_ python openforwrite.py<font></font>
[user@localhost ~]$ ls -lah /proc/5946/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:27 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:27 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:27 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:28 3 -&gt; /mnt/logs/123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのフラグの中で、O_WRONLYが必要なのは、ファイルがすでに存在し、ファイルをクリアする必要がないためです。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ gdb -p 5946<font></font>
...<font></font>
(gdb) call open(<span class="hljs-string">"/mnt/logs/megapipe"</span>, 00000001,0666)
<span class="hljs-variable">$1</span> = 4<font></font>
(gdb) shell ls -lah /proc/5946/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:27 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:27 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:27 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:28 3 -&gt; /mnt/logs/123.txt<font></font>
l-wx------ 1 user user 64 Oct  8 14:20 4 -&gt; /mnt/logs/megapipe<font></font>
(gdb) call dup2(4,3)<font></font>
<span class="hljs-variable">$2</span> = 3<font></font>
(gdb) shell ls -lah /proc/5946/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:27 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:27 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:27 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:28 3 -&gt; /mnt/logs/megapipe<font></font>
l-wx------ 1 user user 64 Oct  8 14:20 4 -&gt; /mnt/logs/megapipe<font></font>
(gdb) call close(4)<font></font>
<span class="hljs-variable">$3</span> = 0<font></font>
(gdb) shell ls -lah /proc/5946/fd<font></font>
total 0<font></font>
dr-x------ 2 user user  0 Oct  8 11:27 .<font></font>
dr-xr-xr-x 9 user user  0 Oct  8 11:27 ..<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 0 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:28 1 -&gt; /dev/pts/22<font></font>
lrwx------ 1 user user 64 Oct  8 11:27 2 -&gt; /dev/pts/22<font></font>
l-wx------ 1 user user 64 Oct  8 11:28 3 -&gt; /mnt/logs/megapipe<font></font>
(gdb) quit<font></font>
A debugging session is active.<font></font>
<font></font>
    Inferior 1 [process 5946] will be detached.<font></font>
<font></font>
Quit anyway? (y or n) y<font></font>
Detaching from program: /usr/bin/python2.7, process 5946<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リモートサーバーremote-server.example.comの確認</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt <font></font>
-rw-rw-r-- 1 user user 38M Oct  8 14:21 123.txt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データが送信され、問題のあるサーバーがチェックされます</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/<font></font>
total 7.9M<font></font>
drwxr-xr-x 2 user user 1.0K Oct  8 11:28 .<font></font>
drwxr-xr-x 4 root     root     1.0K Oct  8 10:55 ..<font></font>
-rw-rw-r-- 1 user user 7.9M Oct  8 14:17 123.txt<font></font>
prw-rw-r-- 1 user user    0 Oct  8 14:22 megapipe<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを保存し、問題を解決しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機会に、デジロの同僚に私の思いを伝えたいと思います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Radio Tポッドキャストを聴く。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてに良い。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宿題として、このコマンドを実行した場合の猫とスリーププロセスのファイル記述子の内容について考えることをお勧めします。</font></font><br>
<br>
<pre><code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000
</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja471026/index.html">TypeScript 決してパワー</a></li>
<li><a href="../ja471028/index.html">ROSトラックトロリー。パート6.ホイールエンコーダー付きのオドメトリ、ルームマップ、ライダー</a></li>
<li><a href="../ja471032/index.html">見えない写真</a></li>
<li><a href="../ja471034/index.html">Pornhub Web開発者へのインタビュー</a></li>
<li><a href="../ja471036/index.html">生活し、学びます。パート5.自己教育：一緒になって</a></li>
<li><a href="../ja471040/index.html">[ブックマーク] ReactマニュアルのPDFおよびePUBバージョン</a></li>
<li><a href="../ja471042/index.html">pwnable.kr 25による問題解決-OTP。Linuxファイルのサイズ制限</a></li>
<li><a href="../ja471044/index.html">Sass MediaScreen-CSSデバイスの定義</a></li>
<li><a href="../ja471046/index.html">スタイリッシュなアバロニア</a></li>
<li><a href="../ja471048/index.html">React + Mobx：ポイントは何ですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>