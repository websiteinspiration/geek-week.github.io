<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏻 🤦🏽 🗻 Sprachmechanik von Stapeln und Zeigern 🕜 🌀 🃏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auftakt
 Dies ist der erste von vier Artikeln in der Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analysen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sprachmechanik von Stapeln und Zeigern</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auftakt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der erste von vier Artikeln in der Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analysen und Go / Pointer-Semantik bieten. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um Stapel und Zeiger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inhaltsverzeichnis:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik auf Stapeln und Zeigern</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Fluchtanalyse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Speicherprofilerstellung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designphilosophie zu Daten und Semantik</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde nicht zerlegen - Zeiger sind schwer zu verstehen. </font><font style="vertical-align: inherit;">Bei unsachgemäßer Verwendung können Zeiger unangenehme Fehler und sogar Leistungsprobleme verursachen. </font><font style="vertical-align: inherit;">Dies gilt insbesondere beim Schreiben von Wettbewerbsprogrammen oder Multithread-Programmen. </font><font style="vertical-align: inherit;">Es überrascht nicht, dass viele Sprachen versuchen, Zeiger vor Programmierern zu verbergen. </font><font style="vertical-align: inherit;">Wenn Sie jedoch in Go schreiben, können Sie Zeigern nicht entkommen. </font><font style="vertical-align: inherit;">Ohne ein klares Verständnis der Zeiger wird es für Sie schwierig sein, sauberen, einfachen und effizienten Code zu schreiben.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rahmenränder</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionen werden innerhalb der Grenzen von Frames ausgeführt, die für jede entsprechende Funktion einen separaten Speicherplatz bereitstellen. Jeder Frame ermöglicht es der Funktion, in ihrem eigenen Kontext zu arbeiten, und bietet auch eine Flusskontrolle. Eine Funktion hat über einen Zeiger direkten Zugriff auf den Speicher innerhalb ihres Frames, der Zugriff auf den Speicher außerhalb des Frames erfordert jedoch einen indirekten Zugriff. Damit eine Funktion außerhalb ihres Frames auf Speicher zugreifen kann, muss dieser Speicher in Verbindung mit dieser Funktion verwendet werden. Die durch diese Grenzen festgelegten Mechanismen und Einschränkungen müssen zuerst verstanden und untersucht werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Funktion aufgerufen wird, tritt ein Übergang zwischen zwei Rahmen auf. Der Code geht vom Frame der aufrufenden Funktion zum Frame der aufgerufenen Funktion. Wenn die Daten zum Aufrufen der Funktion benötigt werden, müssen diese Daten von einem Frame zu einem anderen übertragen werden. Die Übertragung von Daten zwischen zwei Frames in Go erfolgt "nach Wert". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorteil der Datenübertragung nach Wert ist die Lesbarkeit. Der Wert, den Sie im Funktionsaufruf sehen, wird auf der anderen Seite kopiert und akzeptiert. Deshalb verbinde ich mit WYSIWYG „Pass by Value“, denn was Sie sehen, ist das, was Sie bekommen. All dies ermöglicht es Ihnen, Code zu schreiben, der die Kosten für das Umschalten zwischen zwei Funktionen nicht verbirgt. Dies hilft dabei, ein gutes mentales Modell dafür zu erhalten, wie sich jeder Funktionsaufruf während des Übergangs auf das Programm auswirkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich dieses kleine Programm an, das eine Funktion aufruft, indem es ganzzahlige Daten "nach Wert" übergibt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 1:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Go-Programm gestartet wird, erstellt die Laufzeit die Haupt-Goroutine, um die Ausführung des gesamten Codes einschließlich des Codes in der Hauptfunktion zu starten. Gorutin ist der Ausführungspfad, der in den Thread des Betriebssystems passt, der letztendlich auf einem Kernel ausgeführt wird. Ab Version 1.8 verfügt jede Goroutine über einen ersten Block eines kontinuierlichen Speichers mit einer Größe von 2048 Byte, der den Stapelspeicher bildet. Diese anfängliche Stapelgröße hat sich im Laufe der Jahre geändert und kann sich in Zukunft ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stapel ist wichtig, da er physischen Speicherplatz für die Rahmengrenzen bereitstellt, die jeder einzelnen Funktion zugewiesen werden. Wenn die Hauptgoroutine die Hauptfunktion in Listing 1 ausführt, sieht der Programmstapel (auf einer sehr hohen Ebene) folgendermaßen aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 1:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abbildung 1 sehen Sie, dass ein Teil des Stapels für die Hauptfunktion „gerahmt“ wurde. </font><font style="vertical-align: inherit;">Dieser Abschnitt wird als " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelrahmen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " bezeichnet, und dieser Rahmen bezeichnet die Grenze der Hauptfunktion auf dem Stapel. </font><font style="vertical-align: inherit;">Der Frame wird als Teil des Codes festgelegt, der beim Aufruf der Funktion ausgeführt wird. </font><font style="vertical-align: inherit;">Sie können auch sehen, dass der Speicher für die Zählvariable bei 0x10429fa4 innerhalb des Frames für main zugewiesen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen weiteren interessanten Punkt, der in Abbildung 1 dargestellt ist. Der gesamte Stapelspeicher unter dem aktiven Frame ist ungültig, aber der Speicher aus dem aktiven Frame und höher ist gültig. </font><font style="vertical-align: inherit;">Sie müssen die Grenze zwischen dem gültigen und dem ungültigen Teil des Stapels klar verstehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adressen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variablen werden verwendet, um einer bestimmten Speicherzelle einen Namen zuzuweisen, um die Lesbarkeit des Codes zu verbessern und um zu verstehen, mit welchen Daten Sie arbeiten. </font><font style="vertical-align: inherit;">Wenn Sie eine Variable haben, haben Sie einen Wert im Speicher, und wenn Sie einen Wert im Speicher haben, muss diese eine Adresse haben. </font><font style="vertical-align: inherit;">In Zeile 09 ruft die Hauptfunktion die integrierte Druckfunktion auf, um den "Wert" und die "Adresse" der Zählvariablen anzuzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung des kaufmännischen Und "&amp;" zum Abrufen der Adresse des Speicherorts einer Variablen ist nicht neu. Andere Sprachen verwenden diesen Operator ebenfalls. </font><font style="vertical-align: inherit;">Die Ausgabe von Zeile 09 sollte wie die folgende aussehen, wenn Sie Code auf einer 32-Bit-Architektur wie Go Playground ausführen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsaufruf</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes ruft die Hauptfunktion in Zeile 12 die Inkrementfunktion auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Funktionsaufruf bedeutet, dass das Programm einen neuen Speicherabschnitt auf dem Stapel erstellen muss. Alles ist jedoch etwas komplizierter. Um einen Funktionsaufruf erfolgreich abzuschließen, wird erwartet, dass Daten über die Rahmengrenze übertragen und während des Übergangs in einem neuen Rahmen platziert werden. Insbesondere wird erwartet, dass ein ganzzahliger Wert während des Aufrufs kopiert und übertragen wird. Sie können diese Anforderung anhand der Deklaration der Inkrementfunktion in Zeile 18 erkennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich den Aufruf der Inkrementfunktion in Zeile 12 noch einmal ansehen, werden Sie feststellen, dass der Code den „Wert“ der Variablenanzahl überschreitet. Dieser Wert wird kopiert, übertragen und für die Inkrementierungsfunktion in einen neuen Frame eingefügt. Denken Sie daran, dass die Inkrementierungsfunktion nur in einem eigenen Frame lesen und in den Speicher schreiben kann. Daher benötigt sie die Variable inc, um eine eigene Kopie des übertragenen Zählerwerts abzurufen, zu speichern und darauf zuzugreifen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz bevor der Code in der Inkrementfunktion ausgeführt wird, sieht der Programmstapel (auf einer sehr hohen Ebene) folgendermaßen aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 2:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sehen, dass sich jetzt zwei Frames auf dem Stapel befinden - einer für Main und einer unten für Inkremente. </font><font style="vertical-align: inherit;">Innerhalb des Rahmens für das Inkrement sehen Sie die inc-Variable mit dem Wert 10, die während des Funktionsaufrufs kopiert und übergeben wurde. </font><font style="vertical-align: inherit;">Die Adresse der inc-Variablen lautet 0x10429f98 und ist weniger im Speicher, da die Frames auf den Stapel verschoben werden. Dies sind nur Implementierungsdetails, die nichts bedeuten. </font><font style="vertical-align: inherit;">Wichtig ist, dass das Programm den Zählwert aus dem Frame für main abgerufen und eine Kopie dieses Werts in den Frame eingefügt hat, um ihn mithilfe der inc-Variablen zu erhöhen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest des Codes innerhalb des Inkrements erhöht und zeigt den "Wert" und die "Adresse" der inc-Variablen an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausgabe von Zeile 22 auf dem Spielplatz sollte ungefähr so ​​aussehen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7:</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht der Stapel nach dem Ausführen derselben Codezeilen aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Ausführen der Zeilen 21 und 22 endet die Inkrementierungsfunktion und gibt die Steuerung an die Hauptfunktion zurück. </font><font style="vertical-align: inherit;">Dann zeigt die Hauptfunktion erneut den „Wert“ und die „Adresse“ der lokalen Variablenanzahl in Zeile 14 an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vollständige Ausgabe des Programms auf dem Spielplatz sollte ungefähr so ​​aussehen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zählwert im Frame für main ist vor und nach dem Aufruf des Inkrements derselbe.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückkehr von Funktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert eigentlich mit dem Speicher auf dem Stapel, wenn die Funktion beendet wird und die Steuerung zur aufrufenden Funktion zurückkehrt? Die kurze Antwort ist nichts. So sieht der Stapel aus, nachdem die Inkrementfunktion zurückgegeben wurde: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 4: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stapel sieht genauso aus wie in Abbildung 3, außer dass der der Inkrementfunktion zugeordnete Frame jetzt als ungültiger Speicher betrachtet wird. Dies liegt daran, dass der Frame für main jetzt aktiv ist. Der für die Inkrementierungsfunktion erstellte Speicher blieb unberührt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Löschen des Speicherrahmens der Rückgabefunktion ist Zeitverschwendung, da nicht bekannt ist, ob dieser Speicher jemals wieder benötigt wird. </font><font style="vertical-align: inherit;">So blieb die Erinnerung so wie sie war. </font><font style="vertical-align: inherit;">Wenn bei jedem Funktionsaufruf ein Frame genommen wird, wird der Stapelspeicher für diesen Frame gelöscht. </font><font style="vertical-align: inherit;">Dies erfolgt durch Initialisieren aller Werte, die in den Frame passen. </font><font style="vertical-align: inherit;">Da alle Werte als "Nullwert" initialisiert werden, werden die Stapel bei jedem Funktionsaufruf korrekt gelöscht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wertteilung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wäre, wenn es wichtig wäre, dass die Inkrementfunktion direkt mit der Zählvariablen arbeitet, die im Frame für main vorhanden ist? </font><font style="vertical-align: inherit;">Hier kommt die Zeit für Zeiger. </font><font style="vertical-align: inherit;">Zeiger dienen einem Zweck - einen Wert mit einer Funktion zu teilen, damit die Funktion diesen Wert lesen und schreiben kann, auch wenn der Wert nicht direkt in ihrem Frame vorhanden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nicht glauben, dass Sie den Wert "teilen" müssen, müssen Sie keinen Zeiger verwenden. </font><font style="vertical-align: inherit;">Wenn Sie Zeiger lernen, ist es wichtig zu berücksichtigen, dass Sie ein sauberes Wörterbuch verwenden, keine Operatoren oder Syntax. </font><font style="vertical-align: inherit;">Denken Sie daran, dass Zeiger gemeinsam genutzt werden sollen. Ersetzen Sie beim Lesen von Code den Operator &amp; durch den Ausdruck „Freigabe“.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von Zeigern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für jeden Typ, den Sie deklariert haben oder der direkt von der Sprache selbst deklariert wurde, erhalten Sie einen kostenlosen Zeigertyp, den Sie für die Freigabe verwenden können. Es gibt bereits einen integrierten Typ namens int, daher gibt es einen Zeigertyp namens * int. Wenn Sie einen Typ mit dem Namen Benutzer deklarieren, erhalten Sie kostenlos einen Zeigertyp mit dem Namen * Benutzer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Arten von Zeigern haben zwei identische Eigenschaften. Zunächst beginnen sie mit dem Zeichen *. Zweitens haben sie alle die gleiche Größe im Speicher und eine Darstellung, die 4 oder 8 Bytes belegt, die die Adresse darstellen. Bei 32-Bit-Architekturen (z. B. auf dem Spielplatz) benötigen Zeiger 4 Byte Speicher und bei 64-Bit-Architekturen (z. B. Ihrem Computer) 8 Byte Speicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Spezifikation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigertypen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typliterale betrachtet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh es handelt sich um namenlose Typen, die aus einem vorhandenen Typ bestehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indirekter Speicherzugriff</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich dieses kleine Programm an, das einen Funktionsaufruf ausführt und die Adresse "nach Wert" übergibt. </font><font style="vertical-align: inherit;">Dadurch wird die Zählvariable mit der Inkrementfunktion vom Stapelrahmen von main getrennt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am ursprünglichen Programm wurden drei interessante Änderungen vorgenommen. </font><font style="vertical-align: inherit;">Die erste Änderung befindet sich in Zeile 12: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 11:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal kopiert der Code in Zeile 12 nicht und übergibt den "Wert" an die Zählvariable, sondern übergibt seine "Adresse" anstelle der Zählvariablen. Jetzt können Sie sagen: "Ich teile" die Anzahl der Variablen mit dem Funktionsinkrement. Dies ist, was der &amp; Betreiber sagt - "Teilen". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verstehen Sie, dass dies immer noch "Wert übergeben" ist und der einzige Unterschied darin besteht, dass der Wert, den Sie übergeben, die Adresse und nicht die Ganzzahl ist. Adressen sind auch Werte; Dies wird kopiert und über den Rahmenrand übertragen, um die Funktion aufzurufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Adresswert kopiert und übergeben wird, benötigen Sie eine Variable innerhalb des Inkrementrahmens, um diese ganzzahlige Adresse abzurufen und zu speichern. Eine Ganzzahlzeigervariablendeklaration befindet sich in Zeile 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 12:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Adresse des Werts vom Typ Benutzer übergeben haben, muss die Variable als * Benutzer deklariert werden. Trotz der Tatsache, dass alle Zeigervariablen Adresswerte speichern, können ihnen keine Adressen übergeben werden, sondern nur Adressen, die dem Zeigertyp zugeordnet sind. Das Grundprinzip beim Teilen eines Werts besteht darin, dass die Empfangsfunktion diesen Wert lesen oder darauf schreiben muss. Sie benötigen Informationen über den Typ eines Werts, um ihn lesen und schreiben zu können. Der Compiler stellt sicher, dass mit dieser Funktion nur Werte verwendet werden, die dem richtigen Zeigertyp zugeordnet sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht der Stapel nach dem Aufrufen der Inkrementfunktion aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 5:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 5 zeigt, wie der Stapel aussieht, wenn "Wert übergeben" unter Verwendung der Adresse als Wert ausgeführt wird. Die Zeigervariable innerhalb des Rahmens für die Inkrementierungsfunktion zeigt jetzt auf die Zählvariable, die sich innerhalb des Rahmens für main befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mithilfe der Zeigervariable kann die Funktion nun eine indirekte Lese- und Änderungsoperation für die Zählvariable ausführen, die sich im Rahmen für main befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal fungiert das Zeichen * als Operator und wird auf die Zeigervariable angewendet. Die Verwendung von * als Operator bedeutet "den Wert, auf den der Zeiger zeigt". Eine Zeigervariable bietet indirekten Zugriff auf den Speicher außerhalb des Rahmens der Funktion, die ihn verwendet. Manchmal wird dieses indirekte Lesen oder Schreiben als Zeiger-Dereferenzierung bezeichnet. Die Inkrementfunktion muss noch eine Zeigervariable in ihrem Frame haben, die sie direkt lesen kann, um einen indirekten Zugriff durchzuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 6 zeigt, wie der Stapel nach Zeile 21 aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 6: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die endgültige Ausgabe dieses Programms: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise stellen Sie fest, dass der „Wert“ der inc-Zeigervariablen mit der „Adresse“ der Zählvariablen übereinstimmt. </font><font style="vertical-align: inherit;">Dadurch wird eine Freigabebeziehung hergestellt, die einen indirekten Zugriff auf den Speicher außerhalb des Frames ermöglicht. </font><font style="vertical-align: inherit;">Sobald die Inkrementfunktion den Zeiger durchschreibt, ist die Änderung für die Hauptfunktion sichtbar, wenn die Steuerung an sie zurückgegeben wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigervariablen sind nichts Besonderes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeigervariablen sind nichts Besonderes, da sie dieselben Variablen wie jede andere Variable sind. </font><font style="vertical-align: inherit;">Sie haben eine Speicherzuordnung und enthalten Bedeutung. </font><font style="vertical-align: inherit;">Es ist einfach so passiert, dass alle Zeigervariablen, unabhängig von der Art des Werts, auf den sie zeigen können, immer dieselbe Größe und Darstellung haben. </font><font style="vertical-align: inherit;">Was verwirrend sein kann, ist, dass das Zeichen * als Operator innerhalb des Codes fungiert und zum Deklarieren eines Zeigertyps verwendet wird. </font><font style="vertical-align: inherit;">Wenn Sie eine Typdeklaration von einer Zeigeroperation unterscheiden können, kann dies dazu beitragen, Verwirrung zu vermeiden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Beitrag beschreibt den Zweck von Zeigern, die Funktionsweise des Stapels und die Mechanik von Zeigern in Go. </font><font style="vertical-align: inherit;">Dies ist der erste Schritt zum Verständnis der Mechanik, Konstruktionsprinzipien und Verwendungstechniken, die zum Schreiben von kohärentem und lesbarem Code erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende haben Sie Folgendes gelernt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen werden innerhalb der Rahmengrenzen ausgeführt, die für jede entsprechende Funktion einen separaten Speicherplatz bereitstellen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Funktion aufgerufen wird, tritt ein Übergang zwischen zwei Rahmen auf.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil der Datenübertragung nach Wert ist die Lesbarkeit.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Stapel ist wichtig, da er physischen Speicherplatz für die Rahmengrenzen bereitstellt, die jeder einzelnen Funktion zugewiesen werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Stapelspeicher unter dem aktiven Frame ist ungültig, aber der Speicher ab dem aktiven Frame und darüber ist gültig.</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    —    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496832/index.html">Fototour: Was machen sie im Labor für hybride Nanophotonik und Optoelektronik des New Physics Institute ITMO?</a></li>
<li><a href="../de496836/index.html">QSerializer: Lösung für die einfache JSON / XML-Serialisierung</a></li>
<li><a href="../de496838/index.html">Von Slack verwendete Projektbereitstellungsmethode</a></li>
<li><a href="../de496840/index.html">Musk glaubt, dass 12.000 Satelliten die Astronomen nicht stören werden. Seine Meinung stimmt nicht mit dem Modell überein</a></li>
<li><a href="../de496842/index.html">Ein einfaches Epidemiemodell mit grundlegenden Python-Tools</a></li>
<li><a href="../de496848/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 340 (vom 6. bis 12. April)</a></li>
<li><a href="../de496850/index.html">Maven Plugin für JPackage aus Java 14</a></li>
<li><a href="../de496852/index.html">Reibungslose Sortierung</a></li>
<li><a href="../de496856/index.html">Smart Home ohne Fernbedienungen, aber mit einem Würfel</a></li>
<li><a href="../de496858/index.html">FOSS News Nr. 11 - eine Überprüfung der freien und Open-Source-Software für den 6. bis 12. April 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>