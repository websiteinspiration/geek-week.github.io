<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèª ü§¶üèΩ üóª Sprachmechanik von Stapeln und Zeigern üïú üåÄ üÉè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auftakt
 Dies ist der erste von vier Artikeln in der Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analysen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sprachmechanik von Stapeln und Zeigern</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auftakt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der erste von vier Artikeln in der Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analysen und Go / Pointer-Semantik bieten. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um Stapel und Zeiger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inhaltsverzeichnis:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik auf Stapeln und Zeigern</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Fluchtanalyse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Speicherprofilerstellung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designphilosophie zu Daten und Semantik</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde nicht zerlegen - Zeiger sind schwer zu verstehen. </font><font style="vertical-align: inherit;">Bei unsachgem√§√üer Verwendung k√∂nnen Zeiger unangenehme Fehler und sogar Leistungsprobleme verursachen. </font><font style="vertical-align: inherit;">Dies gilt insbesondere beim Schreiben von Wettbewerbsprogrammen oder Multithread-Programmen. </font><font style="vertical-align: inherit;">Es √ºberrascht nicht, dass viele Sprachen versuchen, Zeiger vor Programmierern zu verbergen. </font><font style="vertical-align: inherit;">Wenn Sie jedoch in Go schreiben, k√∂nnen Sie Zeigern nicht entkommen. </font><font style="vertical-align: inherit;">Ohne ein klares Verst√§ndnis der Zeiger wird es f√ºr Sie schwierig sein, sauberen, einfachen und effizienten Code zu schreiben.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rahmenr√§nder</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionen werden innerhalb der Grenzen von Frames ausgef√ºhrt, die f√ºr jede entsprechende Funktion einen separaten Speicherplatz bereitstellen. Jeder Frame erm√∂glicht es der Funktion, in ihrem eigenen Kontext zu arbeiten, und bietet auch eine Flusskontrolle. Eine Funktion hat √ºber einen Zeiger direkten Zugriff auf den Speicher innerhalb ihres Frames, der Zugriff auf den Speicher au√üerhalb des Frames erfordert jedoch einen indirekten Zugriff. Damit eine Funktion au√üerhalb ihres Frames auf Speicher zugreifen kann, muss dieser Speicher in Verbindung mit dieser Funktion verwendet werden. Die durch diese Grenzen festgelegten Mechanismen und Einschr√§nkungen m√ºssen zuerst verstanden und untersucht werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Funktion aufgerufen wird, tritt ein √úbergang zwischen zwei Rahmen auf. Der Code geht vom Frame der aufrufenden Funktion zum Frame der aufgerufenen Funktion. Wenn die Daten zum Aufrufen der Funktion ben√∂tigt werden, m√ºssen diese Daten von einem Frame zu einem anderen √ºbertragen werden. Die √úbertragung von Daten zwischen zwei Frames in Go erfolgt "nach Wert". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorteil der Daten√ºbertragung nach Wert ist die Lesbarkeit. Der Wert, den Sie im Funktionsaufruf sehen, wird auf der anderen Seite kopiert und akzeptiert. Deshalb verbinde ich mit WYSIWYG ‚ÄûPass by Value‚Äú, denn was Sie sehen, ist das, was Sie bekommen. All dies erm√∂glicht es Ihnen, Code zu schreiben, der die Kosten f√ºr das Umschalten zwischen zwei Funktionen nicht verbirgt. Dies hilft dabei, ein gutes mentales Modell daf√ºr zu erhalten, wie sich jeder Funktionsaufruf w√§hrend des √úbergangs auf das Programm auswirkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich dieses kleine Programm an, das eine Funktion aufruft, indem es ganzzahlige Daten "nach Wert" √ºbergibt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 1:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Go-Programm gestartet wird, erstellt die Laufzeit die Haupt-Goroutine, um die Ausf√ºhrung des gesamten Codes einschlie√ülich des Codes in der Hauptfunktion zu starten. Gorutin ist der Ausf√ºhrungspfad, der in den Thread des Betriebssystems passt, der letztendlich auf einem Kernel ausgef√ºhrt wird. Ab Version 1.8 verf√ºgt jede Goroutine √ºber einen ersten Block eines kontinuierlichen Speichers mit einer Gr√∂√üe von 2048 Byte, der den Stapelspeicher bildet. Diese anf√§ngliche Stapelgr√∂√üe hat sich im Laufe der Jahre ge√§ndert und kann sich in Zukunft √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stapel ist wichtig, da er physischen Speicherplatz f√ºr die Rahmengrenzen bereitstellt, die jeder einzelnen Funktion zugewiesen werden. Wenn die Hauptgoroutine die Hauptfunktion in Listing 1 ausf√ºhrt, sieht der Programmstapel (auf einer sehr hohen Ebene) folgenderma√üen aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 1:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abbildung 1 sehen Sie, dass ein Teil des Stapels f√ºr die Hauptfunktion ‚Äûgerahmt‚Äú wurde. </font><font style="vertical-align: inherit;">Dieser Abschnitt wird als " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelrahmen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " bezeichnet, und dieser Rahmen bezeichnet die Grenze der Hauptfunktion auf dem Stapel. </font><font style="vertical-align: inherit;">Der Frame wird als Teil des Codes festgelegt, der beim Aufruf der Funktion ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch sehen, dass der Speicher f√ºr die Z√§hlvariable bei 0x10429fa4 innerhalb des Frames f√ºr main zugewiesen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen weiteren interessanten Punkt, der in Abbildung 1 dargestellt ist. Der gesamte Stapelspeicher unter dem aktiven Frame ist ung√ºltig, aber der Speicher aus dem aktiven Frame und h√∂her ist g√ºltig. </font><font style="vertical-align: inherit;">Sie m√ºssen die Grenze zwischen dem g√ºltigen und dem ung√ºltigen Teil des Stapels klar verstehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adressen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variablen werden verwendet, um einer bestimmten Speicherzelle einen Namen zuzuweisen, um die Lesbarkeit des Codes zu verbessern und um zu verstehen, mit welchen Daten Sie arbeiten. </font><font style="vertical-align: inherit;">Wenn Sie eine Variable haben, haben Sie einen Wert im Speicher, und wenn Sie einen Wert im Speicher haben, muss diese eine Adresse haben. </font><font style="vertical-align: inherit;">In Zeile 09 ruft die Hauptfunktion die integrierte Druckfunktion auf, um den "Wert" und die "Adresse" der Z√§hlvariablen anzuzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung des kaufm√§nnischen Und "&amp;" zum Abrufen der Adresse des Speicherorts einer Variablen ist nicht neu. Andere Sprachen verwenden diesen Operator ebenfalls. </font><font style="vertical-align: inherit;">Die Ausgabe von Zeile 09 sollte wie die folgende aussehen, wenn Sie Code auf einer 32-Bit-Architektur wie Go Playground ausf√ºhren: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsaufruf</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes ruft die Hauptfunktion in Zeile 12 die Inkrementfunktion auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Funktionsaufruf bedeutet, dass das Programm einen neuen Speicherabschnitt auf dem Stapel erstellen muss. Alles ist jedoch etwas komplizierter. Um einen Funktionsaufruf erfolgreich abzuschlie√üen, wird erwartet, dass Daten √ºber die Rahmengrenze √ºbertragen und w√§hrend des √úbergangs in einem neuen Rahmen platziert werden. Insbesondere wird erwartet, dass ein ganzzahliger Wert w√§hrend des Aufrufs kopiert und √ºbertragen wird. Sie k√∂nnen diese Anforderung anhand der Deklaration der Inkrementfunktion in Zeile 18 erkennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich den Aufruf der Inkrementfunktion in Zeile 12 noch einmal ansehen, werden Sie feststellen, dass der Code den ‚ÄûWert‚Äú der Variablenanzahl √ºberschreitet. Dieser Wert wird kopiert, √ºbertragen und f√ºr die Inkrementierungsfunktion in einen neuen Frame eingef√ºgt. Denken Sie daran, dass die Inkrementierungsfunktion nur in einem eigenen Frame lesen und in den Speicher schreiben kann. Daher ben√∂tigt sie die Variable inc, um eine eigene Kopie des √ºbertragenen Z√§hlerwerts abzurufen, zu speichern und darauf zuzugreifen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz bevor der Code in der Inkrementfunktion ausgef√ºhrt wird, sieht der Programmstapel (auf einer sehr hohen Ebene) folgenderma√üen aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 2:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen sehen, dass sich jetzt zwei Frames auf dem Stapel befinden - einer f√ºr Main und einer unten f√ºr Inkremente. </font><font style="vertical-align: inherit;">Innerhalb des Rahmens f√ºr das Inkrement sehen Sie die inc-Variable mit dem Wert 10, die w√§hrend des Funktionsaufrufs kopiert und √ºbergeben wurde. </font><font style="vertical-align: inherit;">Die Adresse der inc-Variablen lautet 0x10429f98 und ist weniger im Speicher, da die Frames auf den Stapel verschoben werden. Dies sind nur Implementierungsdetails, die nichts bedeuten. </font><font style="vertical-align: inherit;">Wichtig ist, dass das Programm den Z√§hlwert aus dem Frame f√ºr main abgerufen und eine Kopie dieses Werts in den Frame eingef√ºgt hat, um ihn mithilfe der inc-Variablen zu erh√∂hen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest des Codes innerhalb des Inkrements erh√∂ht und zeigt den "Wert" und die "Adresse" der inc-Variablen an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausgabe von Zeile 22 auf dem Spielplatz sollte ungef√§hr so ‚Äã‚Äãaussehen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7:</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht der Stapel nach dem Ausf√ºhren derselben Codezeilen aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Ausf√ºhren der Zeilen 21 und 22 endet die Inkrementierungsfunktion und gibt die Steuerung an die Hauptfunktion zur√ºck. </font><font style="vertical-align: inherit;">Dann zeigt die Hauptfunktion erneut den ‚ÄûWert‚Äú und die ‚ÄûAdresse‚Äú der lokalen Variablenanzahl in Zeile 14 an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vollst√§ndige Ausgabe des Programms auf dem Spielplatz sollte ungef√§hr so ‚Äã‚Äãaussehen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Z√§hlwert im Frame f√ºr main ist vor und nach dem Aufruf des Inkrements derselbe.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckkehr von Funktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert eigentlich mit dem Speicher auf dem Stapel, wenn die Funktion beendet wird und die Steuerung zur aufrufenden Funktion zur√ºckkehrt? Die kurze Antwort ist nichts. So sieht der Stapel aus, nachdem die Inkrementfunktion zur√ºckgegeben wurde: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 4: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stapel sieht genauso aus wie in Abbildung 3, au√üer dass der der Inkrementfunktion zugeordnete Frame jetzt als ung√ºltiger Speicher betrachtet wird. Dies liegt daran, dass der Frame f√ºr main jetzt aktiv ist. Der f√ºr die Inkrementierungsfunktion erstellte Speicher blieb unber√ºhrt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das L√∂schen des Speicherrahmens der R√ºckgabefunktion ist Zeitverschwendung, da nicht bekannt ist, ob dieser Speicher jemals wieder ben√∂tigt wird. </font><font style="vertical-align: inherit;">So blieb die Erinnerung so wie sie war. </font><font style="vertical-align: inherit;">Wenn bei jedem Funktionsaufruf ein Frame genommen wird, wird der Stapelspeicher f√ºr diesen Frame gel√∂scht. </font><font style="vertical-align: inherit;">Dies erfolgt durch Initialisieren aller Werte, die in den Frame passen. </font><font style="vertical-align: inherit;">Da alle Werte als "Nullwert" initialisiert werden, werden die Stapel bei jedem Funktionsaufruf korrekt gel√∂scht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wertteilung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was w√§re, wenn es wichtig w√§re, dass die Inkrementfunktion direkt mit der Z√§hlvariablen arbeitet, die im Frame f√ºr main vorhanden ist? </font><font style="vertical-align: inherit;">Hier kommt die Zeit f√ºr Zeiger. </font><font style="vertical-align: inherit;">Zeiger dienen einem Zweck - einen Wert mit einer Funktion zu teilen, damit die Funktion diesen Wert lesen und schreiben kann, auch wenn der Wert nicht direkt in ihrem Frame vorhanden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nicht glauben, dass Sie den Wert "teilen" m√ºssen, m√ºssen Sie keinen Zeiger verwenden. </font><font style="vertical-align: inherit;">Wenn Sie Zeiger lernen, ist es wichtig zu ber√ºcksichtigen, dass Sie ein sauberes W√∂rterbuch verwenden, keine Operatoren oder Syntax. </font><font style="vertical-align: inherit;">Denken Sie daran, dass Zeiger gemeinsam genutzt werden sollen. Ersetzen Sie beim Lesen von Code den Operator &amp; durch den Ausdruck ‚ÄûFreigabe‚Äú.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von Zeigern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr jeden Typ, den Sie deklariert haben oder der direkt von der Sprache selbst deklariert wurde, erhalten Sie einen kostenlosen Zeigertyp, den Sie f√ºr die Freigabe verwenden k√∂nnen. Es gibt bereits einen integrierten Typ namens int, daher gibt es einen Zeigertyp namens * int. Wenn Sie einen Typ mit dem Namen Benutzer deklarieren, erhalten Sie kostenlos einen Zeigertyp mit dem Namen * Benutzer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Arten von Zeigern haben zwei identische Eigenschaften. Zun√§chst beginnen sie mit dem Zeichen *. Zweitens haben sie alle die gleiche Gr√∂√üe im Speicher und eine Darstellung, die 4 oder 8 Bytes belegt, die die Adresse darstellen. Bei 32-Bit-Architekturen (z. B. auf dem Spielplatz) ben√∂tigen Zeiger 4 Byte Speicher und bei 64-Bit-Architekturen (z. B. Ihrem Computer) 8 Byte Speicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Spezifikation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigertypen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typliterale betrachtet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh es handelt sich um namenlose Typen, die aus einem vorhandenen Typ bestehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indirekter Speicherzugriff</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich dieses kleine Programm an, das einen Funktionsaufruf ausf√ºhrt und die Adresse "nach Wert" √ºbergibt. </font><font style="vertical-align: inherit;">Dadurch wird die Z√§hlvariable mit der Inkrementfunktion vom Stapelrahmen von main getrennt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am urspr√ºnglichen Programm wurden drei interessante √Ñnderungen vorgenommen. </font><font style="vertical-align: inherit;">Die erste √Ñnderung befindet sich in Zeile 12: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 11:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal kopiert der Code in Zeile 12 nicht und √ºbergibt den "Wert" an die Z√§hlvariable, sondern √ºbergibt seine "Adresse" anstelle der Z√§hlvariablen. Jetzt k√∂nnen Sie sagen: "Ich teile" die Anzahl der Variablen mit dem Funktionsinkrement. Dies ist, was der &amp; Betreiber sagt - "Teilen". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verstehen Sie, dass dies immer noch "Wert √ºbergeben" ist und der einzige Unterschied darin besteht, dass der Wert, den Sie √ºbergeben, die Adresse und nicht die Ganzzahl ist. Adressen sind auch Werte; Dies wird kopiert und √ºber den Rahmenrand √ºbertragen, um die Funktion aufzurufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Adresswert kopiert und √ºbergeben wird, ben√∂tigen Sie eine Variable innerhalb des Inkrementrahmens, um diese ganzzahlige Adresse abzurufen und zu speichern. Eine Ganzzahlzeigervariablendeklaration befindet sich in Zeile 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 12:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Adresse des Werts vom Typ Benutzer √ºbergeben haben, muss die Variable als * Benutzer deklariert werden. Trotz der Tatsache, dass alle Zeigervariablen Adresswerte speichern, k√∂nnen ihnen keine Adressen √ºbergeben werden, sondern nur Adressen, die dem Zeigertyp zugeordnet sind. Das Grundprinzip beim Teilen eines Werts besteht darin, dass die Empfangsfunktion diesen Wert lesen oder darauf schreiben muss. Sie ben√∂tigen Informationen √ºber den Typ eines Werts, um ihn lesen und schreiben zu k√∂nnen. Der Compiler stellt sicher, dass mit dieser Funktion nur Werte verwendet werden, die dem richtigen Zeigertyp zugeordnet sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht der Stapel nach dem Aufrufen der Inkrementfunktion aus: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 5:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 5 zeigt, wie der Stapel aussieht, wenn "Wert √ºbergeben" unter Verwendung der Adresse als Wert ausgef√ºhrt wird. Die Zeigervariable innerhalb des Rahmens f√ºr die Inkrementierungsfunktion zeigt jetzt auf die Z√§hlvariable, die sich innerhalb des Rahmens f√ºr main befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mithilfe der Zeigervariable kann die Funktion nun eine indirekte Lese- und √Ñnderungsoperation f√ºr die Z√§hlvariable ausf√ºhren, die sich im Rahmen f√ºr main befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal fungiert das Zeichen * als Operator und wird auf die Zeigervariable angewendet. Die Verwendung von * als Operator bedeutet "den Wert, auf den der Zeiger zeigt". Eine Zeigervariable bietet indirekten Zugriff auf den Speicher au√üerhalb des Rahmens der Funktion, die ihn verwendet. Manchmal wird dieses indirekte Lesen oder Schreiben als Zeiger-Dereferenzierung bezeichnet. Die Inkrementfunktion muss noch eine Zeigervariable in ihrem Frame haben, die sie direkt lesen kann, um einen indirekten Zugriff durchzuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 6 zeigt, wie der Stapel nach Zeile 21 aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abbildung 6: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die endg√ºltige Ausgabe dieses Programms: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√∂glicherweise stellen Sie fest, dass der ‚ÄûWert‚Äú der inc-Zeigervariablen mit der ‚ÄûAdresse‚Äú der Z√§hlvariablen √ºbereinstimmt. </font><font style="vertical-align: inherit;">Dadurch wird eine Freigabebeziehung hergestellt, die einen indirekten Zugriff auf den Speicher au√üerhalb des Frames erm√∂glicht. </font><font style="vertical-align: inherit;">Sobald die Inkrementfunktion den Zeiger durchschreibt, ist die √Ñnderung f√ºr die Hauptfunktion sichtbar, wenn die Steuerung an sie zur√ºckgegeben wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigervariablen sind nichts Besonderes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeigervariablen sind nichts Besonderes, da sie dieselben Variablen wie jede andere Variable sind. </font><font style="vertical-align: inherit;">Sie haben eine Speicherzuordnung und enthalten Bedeutung. </font><font style="vertical-align: inherit;">Es ist einfach so passiert, dass alle Zeigervariablen, unabh√§ngig von der Art des Werts, auf den sie zeigen k√∂nnen, immer dieselbe Gr√∂√üe und Darstellung haben. </font><font style="vertical-align: inherit;">Was verwirrend sein kann, ist, dass das Zeichen * als Operator innerhalb des Codes fungiert und zum Deklarieren eines Zeigertyps verwendet wird. </font><font style="vertical-align: inherit;">Wenn Sie eine Typdeklaration von einer Zeigeroperation unterscheiden k√∂nnen, kann dies dazu beitragen, Verwirrung zu vermeiden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Beitrag beschreibt den Zweck von Zeigern, die Funktionsweise des Stapels und die Mechanik von Zeigern in Go. </font><font style="vertical-align: inherit;">Dies ist der erste Schritt zum Verst√§ndnis der Mechanik, Konstruktionsprinzipien und Verwendungstechniken, die zum Schreiben von koh√§rentem und lesbarem Code erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende haben Sie Folgendes gelernt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen werden innerhalb der Rahmengrenzen ausgef√ºhrt, die f√ºr jede entsprechende Funktion einen separaten Speicherplatz bereitstellen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Funktion aufgerufen wird, tritt ein √úbergang zwischen zwei Rahmen auf.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil der Daten√ºbertragung nach Wert ist die Lesbarkeit.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Stapel ist wichtig, da er physischen Speicherplatz f√ºr die Rahmengrenzen bereitstellt, die jeder einzelnen Funktion zugewiesen werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Stapelspeicher unter dem aktiven Frame ist ung√ºltig, aber der Speicher ab dem aktiven Frame und dar√ºber ist g√ºltig.</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    ‚Äî    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496832/index.html">Fototour: Was machen sie im Labor f√ºr hybride Nanophotonik und Optoelektronik des New Physics Institute ITMO?</a></li>
<li><a href="../de496836/index.html">QSerializer: L√∂sung f√ºr die einfache JSON / XML-Serialisierung</a></li>
<li><a href="../de496838/index.html">Von Slack verwendete Projektbereitstellungsmethode</a></li>
<li><a href="../de496840/index.html">Musk glaubt, dass 12.000 Satelliten die Astronomen nicht st√∂ren werden. Seine Meinung stimmt nicht mit dem Modell √ºberein</a></li>
<li><a href="../de496842/index.html">Ein einfaches Epidemiemodell mit grundlegenden Python-Tools</a></li>
<li><a href="../de496848/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 340 (vom 6. bis 12. April)</a></li>
<li><a href="../de496850/index.html">Maven Plugin f√ºr JPackage aus Java 14</a></li>
<li><a href="../de496852/index.html">Reibungslose Sortierung</a></li>
<li><a href="../de496856/index.html">Smart Home ohne Fernbedienungen, aber mit einem W√ºrfel</a></li>
<li><a href="../de496858/index.html">FOSS News Nr. 11 - eine √úberpr√ºfung der freien und Open-Source-Software f√ºr den 6. bis 12. April 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>