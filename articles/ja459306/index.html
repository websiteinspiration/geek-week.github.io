<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏼 🤜🏽 🧑🏽‍🤝‍🧑🏼 サーバーレス環境でのサーバーレンダリング 👐🏻 🍤 👍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私たちが公開している資料の著者は、Webinyプロジェクトの創設者の1人です-React、GraphQL、およびNode.jsに基づくサーバーレスCMS。彼は、マルチテナントのサーバーレスクラウドプラットフォームのサポートは、特定のタスクを持つビジネスであると述べています。Webプロジェクトを最適化...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>サーバーレス環境でのサーバーレンダリング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちが公開している資料の著者は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webiny</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの創設者の1人です</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">-React</font></a><font style="vertical-align: inherit;">、GraphQL、およびNode.jsに基づくサーバーレスCMS。</font><font style="vertical-align: inherit;">彼は、マルチテナントのサーバーレスクラウドプラットフォームのサポートは、特定のタスクを持つビジネスであると述べています。</font><font style="vertical-align: inherit;">Webプロジェクトを最適化するための標準テクノロジーについて説明した記事はすでに多数書かれています。</font><font style="vertical-align: inherit;">その中には、サーバーレンダリング、高度なWebアプリケーション開発テクノロジーの使用、アプリケーションビルドを改善するさまざまな方法などがあります。</font><font style="vertical-align: inherit;">この記事は、一方では他の記事と似ており、他方ではそれとは異なります。</font><font style="vertical-align: inherit;">実際には、サーバーレス環境で実行されるプロジェクトの最適化に専念しています。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニング</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの問題を特定するのに役立つ測定を行うために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webpagetest.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このリソースを使用して、さまざまな操作の実行時間に関する要求を満たし、情報を収集します。</font><font style="vertical-align: inherit;">これにより、プロジェクトで作業するときにユーザーが何を見て感じるかをよりよく理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは特に「ファーストビュー」インジケーターに興味があります。つまり、初めてアクセスしたユーザーからサイトをロードするのにどのくらいの時間がかかりますか。</font><font style="vertical-align: inherit;">これは非常に重要な指標です。</font><font style="vertical-align: inherit;">実際のところ、ブラウザーのキャッシュは、Webプロジェクトの多くのボトルネックを隠すことができます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイトの読み込みの機能を反映する指標-問題の特定</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の表をご覧ください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webプロジェクトの新旧のインジケーターの分析</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここで、最も重要なインジケーターは「レンダリングの開始時間」-レンダリング開始前の時間として認識できます。このインジケーターをよく見ると、ページのレンダリングを開始するためだけに、古いバージョンのプロジェクトでは、約2秒かかっていることがわかります。この理由は、単一ページアプリケーション（SPA）の本質にあります。このようなアプリケーションのページを画面に表示するには、最初にバルクJSバンドルをダウンロードする必要があります（ページのロードのこの段階は、次の図では1とマークされています）。次に、このバンドルをメインスレッドで処理する必要があります（2）。その後、初めて、ブラウザウィンドウに何かが表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）JSバンドルをダウンロードします。 （2）メインスレッドでバンドルが処理されるのを待機しています</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ただし、これは画像の一部にすぎません。メインスレッドはJSバンドルを処理した後、ゲートウェイAPIにいくつかの要求を行います。ページ処理のこの段階で、ユーザーには回転するローディングインジケーターが表示されます。その光景は最も楽しいものではない。同時に、ユーザーはまだページコンテンツを見ていません。これは、ページの読み込みプロセスのストーリーボードです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページの読み込みこれら</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
すべては、そのようなサイトにアクセスしたユーザーが、そのサイトでの作業を特に快適に行っていないことを示唆しています。すなわち、彼は空白のページを2秒間、そしてもう1秒間、ダウンロードインジケーターを見ることを余儀なくされています。この2番目の時間は、JSバンドルAPI要求がロードおよび処理された後に実行されるため、ページ準備時間に追加されます。これらのクエリは、データを読み込み、結果として完成したページを表示するために必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページの読み込み</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロジェクトが通常のVPSでホストされている場合、これらのAPI呼び出しを完了するために必要な時間はほとんど予測可能です。ただし、サーバーレス環境で実行されているプロジェクトは、悪名高いコールドスタートの問題の影響を受けます。 Webinyクラウドプラットフォームの場合、状況はさらに悪化します。 AWS Lambda機能はVPC（Virtual Private Cloud）の一部です。つまり、そのような関数の新しいインスタンスごとに、ENI（Elastic Network Interface、Elastic Network Interface）を初期化する必要があります。これにより、関数のコールドスタート時間が大幅に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VPC内およびVPC外のAWS Lambda機能をロードするためのいくつかのタイムラインを以下に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPC内およびVPC外のAWS Lambda関数の負荷の分析（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
から</font><i><font color="#999999"><font style="vertical-align: inherit;">取得</font></font></i><i><font color="#999999"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">した</font></a></font></i><i><font color="#999999"><font style="vertical-align: inherit;">画像</font></font></i><i><font color="#999999"><font style="vertical-align: inherit;">）</font></font></i><font style="vertical-align: inherit;">これから、関数がVPC内で起動された場合、コールドスタート時間が10倍増加すると結論付けることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ここで考慮すべきもう1つの要素、ネットワークデータ送信の遅延があります。</font><font style="vertical-align: inherit;">それらの期間は、APIリクエストの実行にかかる時間にすでに含まれています。</font><font style="vertical-align: inherit;">リクエストはブラウザによって開始されます。</font><font style="vertical-align: inherit;">したがって、APIがこれらの要求に応答するまでに、ブラウザーからAPIに要求を取得するために必要な時間、およびAPIからブラウザーに応答を取得するのにかかる時間が追加されることがわかります。</font><font style="vertical-align: inherit;">これらの遅延は、各リクエスト中に発生します。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化タスク</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の分析に基づいて、プロジェクトを最適化するために解決する必要があるいくつかのタスクを作成しました。</font><font style="vertical-align: inherit;">どうぞ：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APIリクエストの作成速度を改善するか、レンダリングをブロックするAPIリクエストの数を減らします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSバンドルのサイズを縮小するか、このバンドルをページの表示に不要なリソースに変換します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインスレッドのロックを解除します。</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題のアプローチ</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが検討した問題を解決するためのいくつかのアプローチを次に示します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行を高速化するためのコード最適化。</font><font style="vertical-align: inherit;">このアプローチは多くの労力を必要とし、コストがかかります。</font><font style="vertical-align: inherit;">このような最適化の結果として得られる利点は疑わしいものです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AWS Lambda機能で使用できるRAMの量を増やします。</font><font style="vertical-align: inherit;">それは簡単で、そのようなソリューションのコストは中程度から高額の間です。</font><font style="vertical-align: inherit;">このソリューションの適用により期待できる効果はわずかです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を解決するための他の方法の使用。</font><font style="vertical-align: inherit;">確かに、その時点では、この方法が何であるかはまだわかりません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、このリストの3番目の項目を選択しました。</font><font style="vertical-align: inherit;">私たちは次のように推論しました：「API呼び出しが絶対に必要ない場合はどうなりますか？</font><font style="vertical-align: inherit;">JSバンドルなしで何ができるとしたら？</font><font style="vertical-align: inherit;">これにより、プロジェクトのすべての問題を解決できます。」</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが興味深いと思った最初のアイデアは、レンダリングされたページのHTMLスナップショットを作成し、そのスナップショットをユーザーと共有することでした。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失敗した試み</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webiny Cloudは、AWS Lambdaベースのサーバーレスインフラストラクチャで、Webinyサイトをサポートしています。私たちのシステムはボットを検出できます。リクエストがボットによって完了したことが判明すると、このリクエストは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puppeteer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンスにリダイレクトされ、</font><font style="vertical-align: inherit;">ユーザーインターフェースなしでChromeを使用してページがレンダリングされます。ページの既製のHTMLコードがボットに送信されます。多くのボットはJavaScriptの実行方法を知らないため、これは主にSEOの理由で行われました。通常のユーザー向けのページを準備するために同じアプローチを使用することにしました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、JavaScriptのサポートがない環境でうまく機能します。</font><font style="vertical-align: inherit;">ただし、事前にレンダリングされたページを、ブラウザーがJSをサポートするクライアントに提供しようとすると、ページは表示されますが、JSファイルをダウンロードした後、Reactコンポーネントはそれらをマウントする場所を知らないだけです。</font><font style="vertical-align: inherit;">これにより、コンソールに大量のエラーメッセージが表示されます。</font><font style="vertical-align: inherit;">その結果、そのような決定は私たちには合わなかった。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSRの紹介</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバー側レンダリング（SSR）の長所は、すべてのAPI要求がローカルネットワーク内で実行されることです。それらはVPC内で実行される特定のシステムまたは関数によって処理されるため、ブラウザーからリソースバックエンドへのリクエストの実行時に発生する遅延は特徴的ではありません。このシナリオでは、「コールドスタート」の問題が残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSRを使用するもう1つの利点は、そのようなHTMLバージョンのページをクライアントに提供することです。これを使用すると、JSファイルをロードした後、Reactコンポーネントのマウントに問題が発生しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、非常に大きなJSバンドルは必要ありません。</font><font style="vertical-align: inherit;">さらに、ページを表示するためのAPI呼び出しなしで行うことができます。</font><font style="vertical-align: inherit;">バンドルは非同期でロードでき、これはメインスレッドをブロックしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、サーバーレンダリングはほとんどの問題を解決したと言えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバー側のレンダリングを適用した後のサイト分析は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーレンダリングを適用した後のサイトメトリックス</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Now APIリクエストは実行されず、大きなJSバンドルが読み込まれる前にページを表示できます。</font><font style="vertical-align: inherit;">しかし、最初のリクエストをよく見ると、サーバーからドキュメントを取得するのに約2秒かかることがわかります。</font><font style="vertical-align: inherit;">では、それについて話しましょう。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TTFBの問題</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、TTFBメトリック（最初のバイトまでの時間、最初のバイトまでの時間）について説明します。最初のリクエストの詳細は次のとおりです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のリクエストに関する情報</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この</font><i><font color="#999999"><font style="vertical-align: inherit;">最初のリクエスト</font></font></i><font style="vertical-align: inherit;">を処理するには、Node.jsサーバーを起動し、サーバーレンダリングを実行し、APIリクエストを作成してJSコードを実行し、最終的な結果をクライアントに返します。ここでの問題は、このすべてに平均して1〜2秒かかることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーレンダリングを実行するサーバーは、このすべての作業を実行する必要があります。その後、初めてサーバーが応答の最初のバイトをクライアントに送信できるようになります。これは、ブラウザーが要求への応答の開始を待機するのに非常に長い時間がかかるという事実につながります。その結果、ページの出力については、以前とほぼ同じ量の作業を生成する必要があることがわかりました。唯一の違いは、この作業がクライアント側ではなくサーバー上でサーバーレンダリングのプロセスで実行されることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで「サーバー」という単語について質問があるかもしれません。これまでずっと、サーバーレスシステムについて話していました。この「サーバー」はどこから来たのですか？私たちは確かにAWS Lambda機能でサーバーレンダリングを実行しようとしました。しかし、これは非常にリソースを集中的に使用するプロセスであることが判明しました（特に、より多くのプロセッサリソースを取得するには、メモリの量を非常に増やす必要がありました）。さらに、すでに述べた「コールドスタート」問題もここに追加されます。その結果、理想的なソリューションは、Node.jsサーバーを使用することでした。このサーバーは、サイトのマテリアルを読み込み、サーバーのレンダリングに従事します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバー側レンダリングを使用した結果に戻りましょう。</font><font style="vertical-align: inherit;">次のストーリーボードを見てください。</font><font style="vertical-align: inherit;">それは、クライアントでレンダリングされたプロジェクトの調査で得られたものと特に異ならないことがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーレンダリングを使用する場合のページの読み込み</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ユーザーは、空白のページを2.5秒間</font><i><font color="#999999"><font style="vertical-align: inherit;">表示する</font></font></i><font style="vertical-align: inherit;">必要があります。</font><font style="vertical-align: inherit;">悲しいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの結果を見ると、まったく何も達成していないと思うかもしれませんが、実際にはそうではありません。</font><font style="vertical-align: inherit;">必要なすべてを含むページのHTMLスナップショットがありました。</font><font style="vertical-align: inherit;">このショットは、Reactで使用する準備ができていました。</font><font style="vertical-align: inherit;">同時に、クライアントでのページの処理中に、APIリクエストを実行する必要はありませんでした。</font><font style="vertical-align: inherit;">必要なデータはすべてHTMLに埋め込まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一の問題は、このHTMLスナップショットの作成に時間がかかりすぎることでした。</font><font style="vertical-align: inherit;">この時点で、サーバーレンダリングの最適化により多くの時間を費やすか、結果をキャッシュして、クライアントにRedisキャッシュなどのページのスナップショットを提供することができます。</font><font style="vertical-align: inherit;">私たちはまさにそれをしました。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュサーバーのレンダリング結果</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーがWebiny Webサイトにアクセスした後、まず一元化されたRedisキャッシュをチェックして、ページのHTMLスナップショットがあるかどうかを確認します。</font><font style="vertical-align: inherit;">もしそうなら、キャッシュからページをユーザーに与えます。</font><font style="vertical-align: inherit;">これにより、平均してTTFBが200〜400 msに低下しました。</font><font style="vertical-align: inherit;">プロジェクトパフォーマンスの大幅な改善に気づき始めたのは、キャッシュの導入後です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー側のレンダリングとキャッシュを使用する場合のページの読み込み</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
初めてサイトにアクセスするユーザーでも、ページのコンテンツは1秒未満で表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウォーターフォール図がどのように見えるかを見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー側のレンダリングとキャッシュを適用した後のサイトメトリック</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
赤い線は、800ミリ秒のタイムスタンプを示します。</font><font style="vertical-align: inherit;">これは、ページのコンテンツが完全に読み込まれる場所です。</font><font style="vertical-align: inherit;">また、JSバンドルが約1.3秒でロードされていることがわかります。</font><font style="vertical-align: inherit;">しかし、これはユーザーがページを表示する必要がある時間には影響しません。</font><font style="vertical-align: inherit;">同時に、ページを表示するためにAPI呼び出しを行ってメインスレッドをロードする必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSバンドルのロード、APIリクエストの実行、メインスレッドでの操作の実行に関する一時的なインジケーターが、作業用のページの準備において重要な役割を果たすことに注意してください。この時間とリソースの投資は、ページが「インタラクティブ」になるために必要です。しかし、これは、1つ目は検索エンジンボットにとって、2つ目はユーザー間で「ページをすばやく読み込む」という感覚を生み出すことには何の役割も果たしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページが「動的」であるとします。たとえば、ページを表示しているユーザーがログインした場合に、ユーザーアカウントにアクセスするためのリンクをヘッダーに表示します。サーバー側のレンダリング後、汎用ページがブラウザーに送信されます。つまり、ログインしていないユーザーに表示されるものです。このページのタイトルは、ユーザーがログインしたという事実を反映して、JSバンドルがロードされ、API呼び出しが行われた後にのみ変更されます。ここでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TTI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インジケータ</font><font style="vertical-align: inherit;">（対話までの時間、最初の対話までの時間）を</font><font style="vertical-align: inherit;">扱ってい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数週間後、サーバーレンダリングがバックグラウンドプロセスとして起動された場合に備えて、プロキシサーバーが必要なクライアントとの接続を閉じないことがわかりました。</font><font style="vertical-align: inherit;">文字通り1行のコードを修正した結果、TTFBインジケーターが50〜90ミリ秒のレベルに減少しました。</font><font style="vertical-align: inherit;">その結果、サイトは約600ミリ秒後にブラウザに表示されるようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、別の問題に直面しました...</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュ無効化の問題</font></font></font></h2><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「コンピューターサイエンスでは、キャッシュの無効化とエンティティの命名という2つの複雑なことしかありません。」</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Phil Carleton</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
キャッシュの無効化は、実際、非常に難しい作業です。それを解決するには？まず、キャッシュされたオブジェクトの保存時間を非常に短く設定することで、キャッシュを更新できることがよくあります（TTL、存続時間、ライフタイム）。これにより、ページの読み込みが通常より遅くなることがあります。次に、特定のイベントに基づいてキャッシュ無効化メカニズムを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、この問題は30秒という非常に短いTTLを使用して解決されました。しかし、さらに、キャッシュから古いデータをクライアントに提供する可能性を認識しました。クライアントがこのようなデータを受信した時点で、キャッシュの更新がバックグラウンドで実行されます。このおかげで、AWS Lambda関数によくある遅延や「コールドスタート」などの問題がなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように機能するかです。ユーザーがWebiny Webサイトにアクセスします。 HTMLキャッシュをチェックしています。ページのスナップショットがある場合は、ユーザーに提供します。画像の古さは数日になることもあります。この古いスナップショットを数百ミリ秒でユーザーに渡すことにより、新しいスナップショットの作成とキャッシュの更新のタスクを同時に開始します。このメカニズムを作成したので、このタスクを完了するには通常数秒かかります。メカニズムのおかげで、すでに実行され、動作する準備ができているAWS Lambda関数が常にいくつかあります。したがって、新しいイメージの作成中に、関数のコールドスタートに時間を費やす必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、常にキャッシュからクライアントにページが返され、キャッシュされたデータの経過時間が30秒に達すると、キャッシュの内容が更新されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシングは間違いなく私たちがまだ何かを改善できる領域です。</font><font style="vertical-align: inherit;">たとえば、ユーザーがページを公開したときにキャッシュを自動的に更新する可能性を検討しています。</font><font style="vertical-align: inherit;">ただし、このようなキャッシュ更新メカニズムも理想的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、リソースのホームページに最新の3つのブログ投稿が表示されているとします。</font><font style="vertical-align: inherit;">新しいページが発行されるときにキャッシュが更新される場合、技術的な観点から、発行後にこの新しいページのキャッシュのみが生成されます。</font><font style="vertical-align: inherit;">ホームページのキャッシュは古くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトのキャッシングシステムを改善する方法をまだ探しています。</font><font style="vertical-align: inherit;">しかし、これまでのところ、焦点は既存のパフォーマンスの問題を整理することにありました。</font><font style="vertical-align: inherit;">私たちは、これらの問題の解決という点で、かなり良い仕事をしたと信じています。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、クライアント側のレンダリングを使用しました。その後、ユーザーは平均して3.3秒でページを見ることができます。現在、この数値は約600ミリ秒に低下しています。また、ダウンロードインジケーターを省くことも重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この結果を達成するために、主にサーバーレンダリングの使用が許可されました。しかし、優れたキャッシュシステムがなければ、計算はクライアントからサーバーに単純に転送されることがわかります。そして、これは、ユーザーがページを表示するのに必要な時間はあまり変化しないという事実につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーレンダリングの使用には、前に述べなかったもう1つの良い品質があります。これは、弱いモバイルデバイスでページを表示しやすくするという事実について話しています。このようなデバイスで表示するページを準備する速度は、そのプロセッサの適度な機能に依存します。サーバーレンダリングを使用すると、負荷の一部を取り除くことができます。この問題については特別な調査は行っていませんが、携帯電話やタブレットでのサイトの表示を改善するために役立つシステムがあることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、サーバーレンダリングの実装は簡単な作業ではないと言えます。</font><font style="vertical-align: inherit;">そして、サーバーレス環境を使用しているという事実は、このタスクを複雑にするだけです。</font><font style="vertical-align: inherit;">私たちの問題の解決には、コードの変更と追加のインフラストラクチャが必要でした。</font><font style="vertical-align: inherit;">適切に設計されたキャッシングメカニズムを作成する必要がありました。</font><font style="vertical-align: inherit;">しかし、見返りに、多くの利益を得ました。</font><font style="vertical-align: inherit;">最も重要なことは、私たちのサイトのページがロードされ、以前よりはるかに速く作業の準備ができていることです。</font><font style="vertical-align: inherit;">私たちはユーザーが気に入ってくれると信じています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトを最適化するために、キャッシュおよびサーバーレンダリングテクノロジーを使用していますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459296/index.html">JavaScript価格2019</a></li>
<li><a href="../ja459298/index.html">Angular：2019年のステータス</a></li>
<li><a href="../ja459300/index.html">Quasar 1.0：Vue開発者にとってだけでなく、Vue開発者にとっても新しい便利なツール</a></li>
<li><a href="../ja459302/index.html">Angularで失敗したHTTPリクエストを再試行する</a></li>
<li><a href="../ja459304/index.html">角ピットフォールバイパスと時間節約</a></li>
<li><a href="../ja459308/index.html">SEOは2019年に機能しませんか？</a></li>
<li><a href="../ja459310/index.html">テスト自動化ツールまたはモバイルステロイドテスター</a></li>
<li><a href="../ja459312/index.html">親愛なるアジャイル、私はふりをするのにうんざりです</a></li>
<li><a href="../ja459314/index.html">Hash Match Joinを視覚化して処理します</a></li>
<li><a href="../ja459316/index.html">Hydra 2019：最初のホールの無料放送とカンファレンスでの予定について</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>