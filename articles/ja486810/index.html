<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 💔 🌠 新しいOdnoklassnikiフロントエンド：ReactをJavaで起動します。パートII 🧕🏾 👵🏽 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Odnoklassnikiの内部でGraalVMを使用して、JavaとJavaScript を使いこなして、多くのレガシーコードを備えた巨大なシステムへの移行を開始したという話を続けます。
 
 記事の第2部では、新しいスタックでのアプリケーションの起動、アセンブリ、および統合について詳しく説明し、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>新しいOdnoklassnikiフロントエンド：ReactをJavaで起動します。パートII</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/486810/"><img src="https://habrastorage.org/webt/sz/_g/7x/sz_g7xhw5t9siczpovdjhzzsgru.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odnoklassnikiの内部で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraalVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して、JavaとJavaScript </font><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">使いこなし</font></a><font style="vertical-align: inherit;">て、多くのレガシーコードを備えた巨大なシステムへの移行を開始したという</font><font style="vertical-align: inherit;">話を続け</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の第2部では、新しいスタックでのアプリケーションの起動、アセンブリ、および統合について詳しく説明し、クライアントとサーバーの両方での作業の詳細を詳しく説明し、途中で発生する問題について説明し、それらを克服するためのソリューションについて説明します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">最初の部分を</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
読んでいない場合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これを行うことを強くお勧めします。</font><font style="vertical-align: inherit;">それからOdnoklassnikiのフロントエンドの歴史について学び、その歴史的特徴に精通し、13年間のプロジェクトで蓄積された問題の解決策を見つける道を進み、最後に、私たちが行った決定のサーバー実装の技術的機能に突入します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI構成</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UIコードを作成するために、私たちは最も高度なツールを選択しました：MobX、CSSモジュール、ESLint、TypeScript、Lernaと一緒に反応します。</font><font style="vertical-align: inherit;">これらはすべてWebpackを使用して収集されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ed/tp/gx/edtpgxyuy6rxy4nvalwn_dhhkva.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の前の部分で説明したように、段階的な移行を実装するために、新しいUIスタック内で機能するカスタム名のDOM要素にサイトに新しいコンポーネントを挿入しますが、サイトの残りの部分では、次の要素を持つDOM要素のようになりますそのAPI。これらの要素のコンテンツはサーバーでレンダリングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは何ですか？内部には、Reactで実行され、外部に標準のDOM APIを提供する、クールでファッショナブルな最新のMVCアプリケーションがあります。属性、このDOM要素のメソッド、およびイベントです。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/fg/um/dw/fgumdwotb43klsvwwtlvx4x1bd4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなコンポーネントを実行するために、特別なメカニズムを開発しました。彼は何をしているの？まず、その説明に従ってアプリケーションを初期化します。次に、コンポーネントを、それが起動する特定のDOMノードにバインドします。これらのコンポーネントを見つけてレンダリングできる2つのエンジン（クライアント用とサーバー用）もあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ln/dg/wz/lndgwzg5ggcfgsnnsfdnrdmue8u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが必要なのですか？実際、サイト全体がReactで作成されると、通常、サイトコンポーネントはページのルート要素にレンダリングされます。このコンポーネントは外部に関係なく、内部にあるものだけが興味深いものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、すべてがより複雑です。多くのアプリケーションでは、サイト上のページに「私は、何かが変化している」と伝える機会が必要です。たとえば、カレンダーは、ユーザーがボタンをクリックして日付が変更されたイベントをスローする必要があります。または、カレンダーの内部で日付を変更できる機能が必要です。このため、アプリケーションエンジンは、アプリケーションの基本機能にファサードを実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントをクライアントに配信する場合、古いサイトのエンジンがこのコンポーネントを起動できる必要があります。これを行うために、ビルド中に、その起動に必要な情報が収集されます。</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"events-calendar"</span>: {
        <span class="hljs-attr">"bundleName"</span>: <span class="hljs-string">"events-calendar"</span>,
        <span class="hljs-attr">"js"</span>: <span class="hljs-string">"events-calendar-h4h5m.js"</span>,
        <span class="hljs-attr">"css"</span>: <span class="hljs-string">"events-calendar-h4h5m.css"</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントタグの属性に特別なマーカーが追加されます。つまり、このアプリケーションは新しいタイプであり、そのコードは特定のJSファイルから取得できます。</font><font style="vertical-align: inherit;">同時に、このコンポーネントを初期化するために必要な独自の属性があります。これらは、ストア内のコンポーネントの初期状態を形成します。</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">events-calendar</span>	<span class="hljs-attr">data-module</span>=<span class="hljs-string">"react-loader"</span>
			<span class="hljs-attr">data-bundle</span>=<span class="hljs-string">"events-calendar.js"</span>
			<span class="hljs-attr">date</span>=<span class="hljs-string">".."</span>
			<span class="hljs-attr">marks</span>=<span class="hljs-string">"[{..}]"</span>
			…
/&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
水分補給の場合、使用されるのはアプリケーションの状態のキャストではなく、トラフィックの節約を可能にする属性です。</font><font style="vertical-align: inherit;">それらは正規化された形式で提供され、原則として、アプリケーションが作成するストアよりも小さくなります。</font><font style="vertical-align: inherit;">同時に、クライアントの属性からストアを再作成する時間が短いため、通常は無視できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、カレンダーの場合、属性には日付のみが強調表示され、ストアには月の完全な情報を含むマトリックスが既にあります。</font><font style="vertical-align: inherit;">明らかに、それをサーバーから転送することは無意味です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを実行するには？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この概念は、サーバーに1行を与えるか、クライアントにinnerHTMLを書き込む単純な関数でテストされました。しかし、実際のコードにはモジュールとTypeScriptがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントには標準的なソリューションがあります。たとえば、Webpackを使用してコードを収集すると、それ自体がすべてを粉砕し、バンドルのバンドルの形でクライアントに提供します。そして、GralVMを使用しているときにサーバーに対して何をすべきか？</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/sr/f7/yn/srf7ynd8airmxgybkgu4wnpe82c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのオプションを考えてみましょう。 1つ目は、Node.jsの場合と同様に、JavaScriptでTypeScriptを入力することです。残念ながら、このオプションは、JavaScriptがGraalVMのゲスト言語である場合、構成では機能しません。この場合、JavaScriptにはモジュラーシステムがなく、非同期性さえありません。モジュール性と非同期での作業が特定のランタイムを提供するためです：NodeJSまたはブラウザー。そして、私たちの場合、サーバーには、コードを同期的にのみ実行できるJavaScriptがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプション-クライアント用に収集されたのと同じファイルからサーバーコードで単純に実行できます。そして、このオプションは機能します。しかし、サーバーがいくつかのメソッドのために他の実装を必要とするという問題があります。たとえば、サーバーでrenderToString（）関数を呼び出してコンポーネントをレンダリングし、クライアントでReactDOM.render（）を呼び出します。または、前の記事の別の例：サーバー上のテキストと設定を取得するために、Javaが提供する関数が呼び出され、クライアント上ではJSでの実装になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の解決策として、Webpackのエイリアスを使用できます。これらにより、必要なクラスの2つの実装（クライアントとサーバー用）を作成できます。次に、クライアントとサーバーの構成ファイルで、適切な実装を指定します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/rb/0o/carb0o0rvb1q0pw8eerxnsy4ova.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、2つの構成ファイルは2つのアセンブリです。</font><font style="vertical-align: inherit;">毎回、サーバーとクライアントのすべてを別々に収集することは長く、サポートが困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが一度に収集されるように、このような構成を考え出す必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーとクライアントでJSを実行するためのWebpack構成</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の解決策を見つけるために、プロジェクトがどの部分で構成されているかを調べます。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/zh/mi/e9/zhmie9o6zghd5vgeyd10pjonffq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、プロジェクトには、クライアントとサーバーで同じサードパーティのランタイム（ベンダー）があります。</font><font style="vertical-align: inherit;">ほとんど変わりません。</font><font style="vertical-align: inherit;">Rantimeはユーザーに与えることができ、サードパーティライブラリのバージョンを更新するまでクライアントにキャッシュされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アプリケーションの起動を保証するランタイム（コア）があります。</font><font style="vertical-align: inherit;">クライアントとサーバーの実装が異なるメソッドがあります。</font><font style="vertical-align: inherit;">たとえば、ローカリゼーションテキスト、設定などを取得します。</font><font style="vertical-align: inherit;">このランタイムもまれに変更されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三に、コンポーネントコードがあります。</font><font style="vertical-align: inherit;">これはクライアントとサーバーで同じであり、サーバーをまったく起動せずにブラウザーでアプリケーションコードをデバッグできます。</font><font style="vertical-align: inherit;">クライアントで問題が発生した場合は、ブラウザコンソールでエラーを確認し、すべてを念頭に置いて、サーバーでの起動時にエラーが発生しないことを確認してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計で、組み立てが必要な3つの部品が得られます。</font><font style="vertical-align: inherit;">私たちは欲しい：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各パーツの組み立てを個別に構成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各部分が他の部分に陥らないように、それらの間の依存関係を書き留めます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを1つのパスで収集します。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブリを構成するパーツを個別に説明する方法は？</font><font style="vertical-align: inherit;">webpackには複数の構成があります。各パーツに含まれているモジュールのエクスポートの配列を渡すだけです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = [{
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./vendors.js'</span>,<font></font>
}, {<font></font>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./core.js'</span><font></font>
}, {<font></font>
 <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span><font></font>
}];<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが大丈夫だと思うが、これらの部分のそれぞれにこの部分が依存するこれらのモジュールのコードが複製されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ut/am/ax/utamaxl7z4op6x8iivfcmufn7ec.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いなことに、WebPACKのプラグインの基本セットであり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DllPlugin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたが組み立てられた各部分のために、それに含まれるモジュールのリストを取得することができます。たとえば、ベンダーの場合、この特定のモジュールに含まれている特定のモジュールを見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コアライブラリなどの別のパーツを構築する場合、ベンダーパーツに依存していると言えます。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/nv/lu/el/nvluelzxzvy_5oofujylu4wmufk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、DllPluginは、webpackのアセンブリ中に、既にベンダーにあるライブラリに応じてコアを表示し、コアに追加せず、単にリンクを配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、一度に3つの部品が組み立てられ、相互に依存します。</font><font style="vertical-align: inherit;">最初のアプリケーションがクライアントにダウンロードされると、ランタイムライブラリとコアライブラリがブラウザキャッシュに保存されます。</font><font style="vertical-align: inherit;">Odnoklassnikiはサイトであるため、ユーザーが「永久に」開くことができるタブは、めったに表示されません。</font><font style="vertical-align: inherit;">ほとんどの場合、サイトの新しいバージョンのリリースでは、アプリケーションコードのみが更新されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソース配信</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のデータベースに格納されているローカライズされたテキストを操作する例で問題を検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーのどこかでコンポーネントのテキストが必要な場合は、関数を呼び出してテキストを取得できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> pkg = l10n(<span class="hljs-string">'smiles'</span>);<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    : { pkg.getText('title') }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーアプリケーションはデータベースにすばやくリクエストを送信したり、すべてのテキストをメモリにキャッシュしたりできるため、サーバーでテキストを取得することは難しくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GraalVMのサーバーでレンダリングされる反応のコンポーネントのテキストを取得する方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の最初の部分で説明したように、JSコンテキストでは、JavaScriptからアクセスするグローバルオブジェクトにメソッドを追加できます。</font><font style="vertical-align: inherit;">JavaScriptで使用できるすべてのメソッドを備えたクラスを作成することが決定されました。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerMethods</span> </span>{<font></font>
    …<font></font>
    <font></font>
    <span class="hljs-comment">/**
     *     
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">(String pkg, String key)</span> </span>{<font></font>
        …<font></font>
    }<font></font>
    <font></font>
    …<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このクラスのインスタンスをグローバルJavaScriptコンテキストに配置します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Java   </span>
js.putMember(<span class="hljs-string">"serverMethods"</span>, serverMethods);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として、サーバー実装のJavaScriptから、関数を呼び出すだけです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getText</span>(<span class="hljs-params">pkg: string, key: string</span>): <span class="hljs-title">string</span> </span>{
    <span class="hljs-keyword">return</span> global.serverMethods.getText(pkg, key);<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これは、要求されたテキストを返すJavaの関数呼び出しになります。直接同期相互作用とHTTP呼び出しなし。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントでは、残念ながら、HTTPを介してコンポーネントのテキスト挿入関数を呼び出すたびにテキストを受信するのに非常に長い時間がかかります。すべてのテキストをクライアントに事前ダウンロードできますが、テキストだけでも数十メガバイトあり、他のタイプのリソースもあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/6e/ij/lg6eijxb_rvzshqiyih2gyuvy5a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーはアプリケーションを開始する前にすべてがダウンロードされるまで待つのに飽きます。したがって、この方法は適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のアプリケーションで必要なテキストのみを受け取りたいのですが。テキストはパッケージに分割されています。したがって、アプリケーションに必要なパッケージを収集して、バンドルと一緒にダウンロードできます。アプリケーションの起動時、すべてのテキストはすでにクライアントキャッシュにあります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションが必要とするテキストを見つける方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード内のテキストのパッケージは、パッケージ名が文字列リテラルの形式でのみ送信されるl10n（）関数を呼び出すことによって取得されるという合意に達しました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> pkg = l10n(<span class="hljs-string">'smiles'</span>);<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    { pkg.getLMsg('title') }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントコードのASTツリーを分析して、l10n（）関数へのすべての呼び出しを見つけ、引数からパッケージ名を収集するwebpackプラグインを作成しました。</font><font style="vertical-align: inherit;">同様に、プラグインは、アプリケーションが必要とする他のタイプのリソースに関する情報を収集します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各アプリケーションのアセンブリ後の出力で、リソースを含む構成を取得します。</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"events-calendar"</span>: {
       <span class="hljs-attr">"pkg"</span>:  [
           <span class="hljs-string">"calendar"</span>,
           <span class="hljs-string">"dates"</span><font></font>
       ],<font></font>
       <span class="hljs-attr">"cfg"</span>:  [
           <span class="hljs-string">"config1"</span>,
           <span class="hljs-string">"config2"</span><font></font>
       ],<font></font>
       <span class="hljs-attr">"bundleName"</span>:  <span class="hljs-string">"events-calendar"</span>,
       <span class="hljs-attr">"js"</span>:  <span class="hljs-string">"events-calendar.js"</span>,
       <span class="hljs-attr">"css"</span>:  <span class="hljs-string">"events-calendar.css"</span>,<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもちろん、テキストの更新を忘れてはなりません。</font><font style="vertical-align: inherit;">サーバー上ではすべてのテキストが常に最新であり、クライアントにはウォッチャーやプッシュなどの個別のキャッシュ更新メカニズムが必要なためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いコードを新しいものに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スムーズに移行すると、古いコンポーネントを新しいコンポーネントで再利用するという問題が発生します。これは、大きく複雑なコンポーネント（たとえば、ビデオプレーヤー）があり、書き換えに時間がかかるため、今すぐ新しいスタックでそれらを使用する必要があるためです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jz/pg/te/jzpgtesmq75odhrqyvbg2grbw9u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は何ですか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いサイトと新しいReactアプリのライフサイクルはまったく異なります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いサンプルのコードをReactアプリケーション内に貼り付けると、Reactはそれをアクティブにする方法を知らないため、このコードは開始されません。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライフサイクルが異なるため、Reactと古いエンジンが古いコードの内容を同時に変更しようとする可能性があり、不快な副作用が発生する可能性があります。 </font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題を解決するために、古いコードを含むコンポーネントに共通の基本クラスが割り当てられました。</font><font style="vertical-align: inherit;">このクラスにより、相続人はReactと古いスタイルのアプリケーションのライフサイクルを調整できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldCodeBase</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<font></font>
<font></font>
    <span class="hljs-attr">ref</span>: React.RefObject&lt;HTMLElement&gt; = React.createRef();<font></font>
<font></font>
    componentDidMount() {<font></font>
        <span class="hljs-comment">//       DOM</span>
        <span class="hljs-keyword">this</span>.props.activate(<span class="hljs-keyword">this</span>.ref.current!); <font></font>
    }<font></font>
<font></font>
    componentWillUnmount() {<font></font>
        <span class="hljs-comment">//       DOM</span>
        <span class="hljs-keyword">this</span>.props.deactivate(<span class="hljs-keyword">this</span>.ref.current!); <font></font>
    }<font></font>
<font></font>
    shouldComponentUpdate() {<font></font>
        <span class="hljs-comment">// React     , </span>
        <span class="hljs-comment">//   React-. </span>
        <span class="hljs-comment">//     .</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.ref}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスを使用すると、古い方法で機能するコードを作成したり、同時に実行したりすることなく破棄したりできます。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーに古いコードを貼り付けます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、ラッパーコンポーネント（たとえば、ポップアップ）が必要です。その内容は、古いテクノロジを使用して作成されたものを含め、どのようなものでもかまいません。</font><font style="vertical-align: inherit;">このようなコンポーネント内のサーバーにコードを埋め込む方法を理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の記事では、属性を使用してクライアントとサーバーの新しいコンポーネントにパラメーターを渡すことについて説明しました。</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span> <span class="hljs-attr">users</span>=<span class="hljs-string">"[1,2,3]"</span> /&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、今でもそこにマークアップの一部を挿入したいのですが、これは意味的には属性ではありません。</font><font style="vertical-align: inherit;">このため、スロットのシステムを使用することが決定されました。</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ui:part</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"old-code"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>old component<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ui:part</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例でわかるように、cool-appコンポーネントのコード内には、古いコンポーネントを含む古いコードスロットが記述されています。</font><font style="vertical-align: inherit;">次に、reactコンポーネント内で、このスロットの内容を貼り付ける場所を示します。</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">UiPart</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"old-code"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    );<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーエンジンはこの反応コンポーネントをレンダリングし、&lt;ui-part&gt;タグのスロットのコンテンツをフレーム化し、data-part-id = "old-code"属性を割り当てます。 </font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ui-part</span> <span class="hljs-attr">data-part-id</span>=<span class="hljs-string">"old-code"</span>&gt;</span><font></font>
            old code<font></font>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ui-part</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GraalVMでのJSのサーバー側レンダリングがタイムアウトに適合しない場合、クライアントレンダリングにフォールバックします。</font><font style="vertical-align: inherit;">これを行うために、サーバー上のエンジンはスロットのみを提供し、ブラウザーがコードと対話しないようにテンプレートタグでそれらをフレーム化します。</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ui-part</span> <span class="hljs-attr">data-part-id</span>=<span class="hljs-string">"old-code"</span>&gt;</span><font></font>
            old code<font></font>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ui-part</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントで何が起こっていますか？</font><font style="vertical-align: inherit;">クライアントエンジンは、コンポーネントコードをスキャンし、&lt;ui-part&gt;タグを収集し、その内容を文字列の形式で受け取り、残りのパラメーターとともにレンダリング関数に渡します。</font></font><br>
 <br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> tagName = <span class="hljs-string">'cool-app'</span>;
<span class="hljs-keyword">var</span> reactComponent = components[tagName];<font></font>
reactComponent.render({<font></font>
       <span class="hljs-attr">tagName</span>: tagName,
       <span class="hljs-attr">attrs</span>: attrs,
       <span class="hljs-attr">parts</span>: parts,
       <span class="hljs-attr">node</span>: element<font></font>
});<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スロットを目的の場所に挿入するコンポーネントのコードは次のとおりです。 </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OldCodeBase</span>&lt;<span class="hljs-title">IProps</span>&gt; </span>{<font></font>
<font></font>
	render() {<font></font>
		<span class="hljs-keyword">const</span> id = <span class="hljs-keyword">this</span>.props.id;
		<span class="hljs-keyword">const</span> parts = <span class="hljs-keyword">this</span>.props.parts;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!parts.hasOwnProperty(id)) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
		}<font></font>
<font></font>
		<span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'ui-part'</span>, {
			<span class="hljs-string">'data-part-id'</span>: id,
			<span class="hljs-attr">ref</span>: <span class="hljs-keyword">this</span>.ref,
			<span class="hljs-attr">dangerouslySetInnerHTML</span>: { <span class="hljs-attr">__html</span>: parts[id] }<font></font>
		});<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、OldCodeBaseクラスから継承され、古いスタックと新しいスタック間の相互作用の問題を解決します。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/ge/cc/a3/gecca3dlxac9crp48u9pvoyc4vs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ポップアップを作成し、新しいスタックを使用してポップアップを入力するか、古いアプローチを使用してサーバーからリクエストを送信できます。</font><font style="vertical-align: inherit;">この場合、コンポーネントは正しく動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、サイトコンポーネントを新しいスタックに段階的に移行できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが新しいフロントエンドの主要な要件の1つでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もがGraalVMがどれだけ速く動作するのか疑問に思っています。</font><font style="vertical-align: inherit;">Odnoklassniki開発者は、Reactアプリケーションを使用してさまざまなテストを実施しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウォームアップ後に文字列を返す単純な関数は、約1マイクロ秒かかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネント（ウォームアップ後）-サイズに応じて0.5〜6ミリ秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GraalVMはV8よりも低速で加速します。</font><font style="vertical-align: inherit;">しかし、ウォーミングアップの期間中は、クライアントレンダリングのフォールバックにより状況はスムーズになります。</font><font style="vertical-align: inherit;">ユーザーが非常に多いため、仮想マシンは急速に熱くなります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どうにかして</font></font></h3><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClassmatesのJavaワールドのサーバーでJavaScriptを実行します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIの同型コードを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのフロントエンドベンダーが知っている最新のスタックを使用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIを作成するための共通のプラットフォームと単一のアプローチを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作を複雑にすることなく、サーバーのレンダリングを遅くすることなく、スムーズな移行を開始します。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odnoklassnikiの経験と例が皆さんのお役に立てば幸いです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja486798/index.html">サハリンにGameDevはありますか？終わり</a></li>
<li><a href="../ja486800/index.html">カサンドラ。オラクルしか知らないなら死なない方法</a></li>
<li><a href="../ja486802/index.html">人々は推薦システムに出会います。因数分解</a></li>
<li><a href="../ja486804/index.html">グローバルヘルスインフォマティクス：クラウドテクノロジー</a></li>
<li><a href="../ja486808/index.html">薬局の電子妊娠検査：仕組み</a></li>
<li><a href="../ja486814/index.html">Zabbix：ネットワークトポロジは明確で自動</a></li>
<li><a href="../ja486818/index.html">QuakeをiPod Classicに移植する</a></li>
<li><a href="../ja486820/index.html">70 Javascriptインタビューの質問</a></li>
<li><a href="../ja486822/index.html">[ドックで]フラッター。パート4. Web開発者向け</a></li>
<li><a href="../ja486824/index.html">ANTLRを使用する際の悪いアドバイス</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>