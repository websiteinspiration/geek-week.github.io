<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üîí ü•ê Skeleton Animation Compression Guide üôãüèº üë©‚Äçüë©‚Äçüëß‚Äçüë¶ ‚óÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will be a brief overview of how to implement a simple animation compression scheme and some related concepts. I am by no means an expert ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Skeleton Animation Compression Guide</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491958/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/6v/gp/o16vgpz4u-9_ntko92qweoxqzx0.png" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article will be a brief overview of how to implement a simple animation compression scheme and some related concepts. </font><font style="vertical-align: inherit;">I am by no means an expert in this matter, but there is very little information on this topic, and it is quite fragmented. </font><font style="vertical-align: inherit;">If you want to read deeper articles on this topic, then I recommend that you go to the following links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://nfrechette.github.io/2016/10/21/anim_compression_toc/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technology.riotgames.com/news/compressing-skeletal-animation-data</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2011/10/low-level-animation-part-2.html</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we get started, it's worth giving a brief introduction to skeletal animation and some of its basic concepts.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basics of Animation and Compression</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skeletal animation is a pretty simple topic, if you forget about skinning. We have a concept of a skeleton containing transformations of a character‚Äôs bones. These bone transformations are stored in a hierarchical format; in fact, they are stored as a delta between their global position and the parent's position. The terminology here is confusing, because in the game engine local is often called the model / character space, and global is the world space. In animation terminology, local is called the space of the parent of the bone, and global is either the space of the character or the world space, depending on whether there is movement of the root bone; but let's not worry about that much. The important thing is that bone transformations are stored locally relative to their parents. This has many advantages, and especially when mixing (blending):if the mixing of the two positions were global, then they would be linearly interpolated in the position, which would lead to an increase and decrease in bones and deformation of the character.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you use deltas, the mixing is performed from one difference to another, so if the delta transformation for one bone between two poses is the same, then the length of the bone remains constant. I think that it is easiest (but not entirely accurate) to take it this way: the use of deltas leads to a ‚Äúspherical‚Äù movement of bone positions during mixing, and the mixing of global transformations leads to a linear movement of bone positions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skeletal animation is just an ordered list of keyframes with a (usually) constant frame rate. The key frame is the skeleton pose. If we want to get a pose between keyframes, we sample both keyframes and mix between them, using the fraction of the time between them as the weight of the mix. The image below shows an animation created at 30fps. The animation has a total of 5 frames and we need to get the pose 0.52 s after the start. Therefore, we need to sample the pose in frame 1 and the pose in frame 2, and then mix between them with a mix weight of approximately 57%.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/f11/c43/733f11c43022b935901e6f20f8a70fab.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of an animation of 5 frames and a request for a pose at an intermediate frame time</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Having the information above and considering that memory is not a problem for us, the sequential saving of the pose would be the ideal way to store the animation, as shown below:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/7c5/f3c/d287c5f3cbfd9a8144d20432c3a258dc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple animation data storage</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is this perfect? Sampling any keyframe comes down to a simple memcpy operation. Sampling an intermediate pose requires two memcpy operations and one mixing operation. From the point of view of the cache, we copy using memcpy two data blocks in order, that is, after copying the first frame, one of the caches will already have a second frame. You can say: wait, when we do the mixing, we need to mix all the bones; What if most of them do not change between frames? Wouldn't it be better to store bones as records and mix only changed transformations? Well, if this is realized, then a little more cache misses can potentially occur when reading individual records, and then you will need to keep track of which conversions you need to mix, and so on ... Mixing may seem like a lot of time-consuming work,but in essence it is the application of one instruction to two blocks of memory that are already in the cache. In addition, the mixing code is relatively simple, often just a set of SIMD instructions without branching, and a modern processor will process them in a matter of moments.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem with this approach is that it takes an extremely large amount of memory, especially in games where the following conditions are true for 95% of the data.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bones have a constant length</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The characters in most games do not stretch the bones, therefore, within the same animation, the records of transformations are constant.</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We usually don‚Äôt scale the bones.</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scale is rarely used in game animations. </font><font style="vertical-align: inherit;">It is quite actively used in films and VFX, but very little in games. </font><font style="vertical-align: inherit;">Even when used, the same scale is usually used.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, in most of the animations I created at runtime, I took advantage of this fact and kept the entire bone transformation in 8 float variables: 4 to rotate the quaternion, 3 to move and 1 to scale. </font><font style="vertical-align: inherit;">This significantly reduces the size of the pose at run time, providing increased productivity when mixing and copying.</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With all of this in mind, if you look at the original data format, you can see how inefficient it is spending memory. </font><font style="vertical-align: inherit;">We duplicate the displacement and scale values ‚Äã‚Äãof each bone, even if they do not change. </font><font style="vertical-align: inherit;">And the situation is quickly getting out of hand. </font><font style="vertical-align: inherit;">Usually, animators create animations at a frequency of 30fps, and in AAA-level games, a character usually has about 100 bones. </font><font style="vertical-align: inherit;">Based on this amount of information and a format of 8 float, we need about 3 KB per pose and 94 KB per second of animation as a result. </font><font style="vertical-align: inherit;">Values ‚Äã‚Äãquickly accumulate and on some platforms can easily clog all the memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So let's talk about compression; </font><font style="vertical-align: inherit;">When trying to compress data, there are several aspects to consider:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression ratio</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How much we managed to reduce the amount of occupied memory</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quality</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How much information we lost from the source data</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression rate</font></font></strong><ul>
<li>     </li>
</ul></li>
<li><strong> </strong><ul>
<li>           .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am primarily concerned about quality and speed, and less concerned about memory. In addition, I work with game animations, and I can take advantage of the fact that in fact, to reduce the load on memory, we do not have to use displacement and scale in the data. Due to this, we can avoid a decrease in quality caused by a decrease in the number of frames and other solutions with losses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also extremely important to note that you should not underestimate the effect of animation compression on performance: in one of my previous projects, the sampling rate decreased by about 35%, and there were also some quality problems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we start working with compression of animation data, there are two main important areas to consider:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How quickly can we compress individual elements of information in a key frame (quaternions, float, etc.).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How can we compress the sequence of key frames to remove redundant information.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data discretization</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Almost all of this section can be reduced to one principle: discretize data. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discretization</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a difficult way to say that we want to convert a value from a continuous interval to a discrete set of values.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discretization Float</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When it comes to sampling float values, we strive to take that float value and represent it as an integer using fewer bits. The trick is that an integer may not actually represent a source number, but a value in a discrete interval mapped to a continuous interval. Usually a very simple approach is used. To sample a value, we first need an interval for the original value; Having received this interval, we normalize the initial value for this interval. Then this normalized value is multiplied by the maximum value possible for the desired given output size in bits. That is, for 16 bits we multiply the value by 65535. Then the resulting value is rounded to the nearest integer and stored. This is clearly shown in the image:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e73/827/f7be73827067126fd51c0bf6f2396b10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of sampling a 32-bit float to an unsigned 16-bit integer</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
To get the original value again, we simply perform the operations in the reverse order. It is important to note here that we need to record somewhere the initial interval of the value; otherwise, we will not be able to decode the sampled value. The number of bits in the sampled value determines the step size in the normalized interval, and therefore the step size in the original interval: the decoded value will be a multiple of this step size, which allows us to easily calculate the maximum error that occurs due to the sampling process, so we can determine the number of bits required for our application.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not give examples of the source code, because there is a fairly convenient and simple library for performing basic sampling operations, which is a good source on this topic: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/r-lyeh-archived/quant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (I would say that you should not use its quaternion discretization function, but more on this later).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quaternion Compression</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quaternion compression is a well-studied topic, so I will not repeat what other people explained better. </font><font style="vertical-align: inherit;">Here is a link to a snapshot compression post that provides the best description on this topic: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://gafferongames.com/post/snapshot_compression/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, I have something to say on the topic. </font><font style="vertical-align: inherit;">The bitsquid posts, which talk about quaternion compression, suggest compressing the quaternion to 32 bits using approximately 10 bits of data for each quaternion component. </font><font style="vertical-align: inherit;">This is exactly what Quant does, because it is based on bitsquid posts. </font><font style="vertical-align: inherit;">In my opinion, such a compression is too great and in my tests it caused strong shaking. </font><font style="vertical-align: inherit;">Perhaps the authors used less deep hierarchies of the character, but if you multiply 15-plus quaternions from my animation examples, the combined error turns out to be quite serious. </font><font style="vertical-align: inherit;">In my opinion, the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolute</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> minimum of accuracy is 48 bits per quaternion.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Downsizing due to sampling</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we begin to consider the different compression methods and arrangement of records, let's see what type of compression we get if we simply apply the discretization in the original circuit. We will use the same example as before (a skeleton of 100 bones), so if you use 48 bits (3 x 16 bits) per quaternion, 48 bits (3 √ó 16) to move and 16 bits to scale, then in total for conversion we need 14 bytes instead of 32 bytes. This is 43.75% of the original size. That is, for 1 second of animation with a frequency of 30FPS, we reduced the volume from about 94 KB to about 41 KB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is not bad at all, discretization is a relatively low-cost operation, so this will not affect the unpacking time too much. </font><font style="vertical-align: inherit;">We found a good starting point for the start, and in some cases this will even be enough to implement animations within the budget of resources and ensure excellent quality and performance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Record compression</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything becomes very complicated here, especially when developers begin to try such techniques as reducing the key frame, curve fitting, etc. </font><font style="vertical-align: inherit;">Also at this stage we are really starting to reduce the quality of the animations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In almost all such decisions, it is assumed that the characteristics of each bone (rotation, displacement, and scale) are stored as a separate record. </font><font style="vertical-align: inherit;">Therefore, we can flip the circuit, as I showed it earlier:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/752/16a/f6475216adb6ac795e1737de30aef6af.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saving data of bones as records</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Here we simply save all records sequentially, but could also group all records of rotations, displacements, and scales. The basic idea is that we move from storing data from each pose to storing records.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having done this, we can use other ways to further reduce the occupied memory. The first is to start dropping frames. Note: this does not require a record format and this method can be applied in the previous scheme. This method works, but leads to the loss of small movements in the animation, because we discard most of the data. This technique was actively used on the PS3, and sometimes we had to stoop to insanely low sampling frequencies, for example, up to 7 frames per second (usually for not very important animations). I have bad memories from this, as an animation programmer I clearly see the lost details and expressiveness, but if you look from the point of view of the system programmer, we can say that the animation is "almost" the same, because in general the movement is preserved, but at the same time we save a lot of memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's omit this approach (in my opinion, it is too destructive) and consider other possible options. Another popular approach is to create a curve for each record and perform reduction of key frames on the curve, i.e. removing duplicate keyframes. From the point of view of game animations, with this approach, the movement and scale recordings are perfectly compressed, sometimes being reduced to one keyframe. This solution is non-destructive, but requires unpacking, because every time we need to get the transformation, we have to calculate the curve, because we can no longer just go to the data in memory. The situation can be improved a little if you </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculate animations in only one direction.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and store the state of the sampler of each animation for each bone (i.e. where to get the calculation of the curve from), but you have to pay for this with an increase in memory and a significant increase in code complexity. In modern animation systems, we often do not play animations from beginning to end. Often at certain time offsets, they make transitions to new animations thanks to things like synchronized blending or phase matching. Often we sample individual but not consecutive poses to implement things like mixing aiming / looking at an object, and often animations are played in the reverse order. Therefore, I do not recommend using such a solution, it is simply not worth the hassle caused by complexity and potential bugs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is also the concept of not only deleting identical keys on curves, but also specifying a threshold at which similar keys are deleted; this leads to the fact that the animation becomes more faded, similar to the method of dropping frames, because the end result is the same in terms of data. Animation compression schemes are often used, in which compression parameters are set for each record, and animators are constantly tormented with these values, trying to maintain quality and reduce size at the same time. This is a painful and stressful workflow, but it is necessary if you work with the limited memory of older generations of consoles. Fortunately, today we have a large memory budget and we do not need such terrible things.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All these aspects are disclosed in the posts of Riot / BitSquid and Nicholas (see links at the beginning of my article). I will not talk about them in detail. Instead, I‚Äôll talk about what I decided about compressing the records ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I ... decided not to compress the records. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before you start waving, let me explain ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I save the data in the records, I store the rotation data for all frames. When it comes to movement and scale, I keep track of whether the movement and scale are static during compression, and if so, I save only one value per record. That is, if the record moves along X, but not along Y and Z, then I save all the values ‚Äã‚Äãof moving the record along X, but only one value of moving the record along Y and Z.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This situation arises for most bones in about 95% of our animations, so in the end we can significantly reduce the occupied memory, absolutely without losing quality. This requires work from the point of view of content creation (DCC): we do not want the bones to have slight movements and zooms in the animation creation workflow, but such a benefit is worth the extra cost.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our animation example, there are only two records with moving and there are no records with scale. Then for 1 second of animation, the data volume decreases from 41 KB to 18.6 KB (that is, up to 20% of the volume of the original data). The situation becomes even better when the duration of the animation increases, we spend resources only on recording turns and dynamic movements, and the costs of static recordings remain constant, which saves more in long animations. And we do not have to experience quality loss caused by sampling. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With all this information in mind, my final data schema looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f5/347/eb0/9f5347eb09718967ebacbe89d443e992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of a compressed animation data scheme (3 frames per record)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In addition, I save the offset in the data block to start the data of each bone. </font><font style="vertical-align: inherit;">This is necessary because sometimes we need to sample data for only one bone without reading the entire pose. </font><font style="vertical-align: inherit;">This provides us with a quick way to directly access record data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to the animation data stored in one memory block, I also have compression options for each record:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/b3d/7a3/4d7b3d7a3f1362c0429d72591268dbce.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example of compression parameters for records from my Kruger engine</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
These parameters store all the data I need to decode the sampled values ‚Äã‚Äãof each record. </font><font style="vertical-align: inherit;">They also monitor the static of records so that I know how to handle compressed data when I stumble upon a static record when sampling.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also notice that the discretization for each record is individual: during compression, I track the minimum and maximum values ‚Äã‚Äãof each characteristic (for example, moving along the X) of each record to ensure that the data is discretized within the minimum / maximum interval and maintain maximum accuracy. </font><font style="vertical-align: inherit;">I do not think that it is generally possible to create global sampling intervals without destroying your data (when the values ‚Äã‚Äãare outside the interval) and without making significant errors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Be that as it may, here is a brief summary of my stupid attempts to implement animation compression: in the end, I almost use compression.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491942/index.html">How we use item2vec to recommend similar products</a></li>
<li><a href="../en491944/index.html">How to combine two platforms into one and not offend users. Yandex.Kew Developers Experience</a></li>
<li><a href="../en491946/index.html">Laws of programming</a></li>
<li><a href="../en491948/index.html">Design tokens can do more: create a single source of information about UI components</a></li>
<li><a href="../en491956/index.html">Rust 1.42.0 release: slice templates and more convenient panic messages</a></li>
<li><a href="../en491960/index.html">Era when it's hard to get lost</a></li>
<li><a href="../en491962/index.html">VPN killer. Proper remote access to battle servers</a></li>
<li><a href="../en491964/index.html">Remote Code Execution in SMB v3: CVE-2020-0796</a></li>
<li><a href="../en491974/index.html">Coronavirus: why you need to act right now</a></li>
<li><a href="../en491976/index.html">We turn the UNIT economy for an online store or production</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>