<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè™ üé™ üëä Conference DEVOXX UK. Choose a framework: Docker Swarm, Kubernetes or Mesos. Part 2 üëµüèª üÜì üë¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Docker Swarm, Kubernetes and Mesos are the most popular container orchestration frameworks. In his speech, Arun Gupta compares the following aspects o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Conference DEVOXX UK. Choose a framework: Docker Swarm, Kubernetes or Mesos. Part 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/506590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker Swarm, Kubernetes and Mesos are the most popular container orchestration frameworks. </font><font style="vertical-align: inherit;">In his speech, Arun Gupta compares the following aspects of the work of Docker, Swarm, and Kubernetes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local development.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deployment Features</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicontainer applications.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service discovery service discovery.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling service.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run-once assignments.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integration with Maven.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A "rolling" update.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating a Couchbase database cluster.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, you will get a clear idea of ‚Äã‚Äãwhat each orchestration instrument has to offer, and learn how to use these platforms effectively. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arun Gupta is Amazon Web Services' premier open-source product technologist who has been developing Sun, Oracle, Red Hat, and Couchbase developer communities for over 10 years. He has extensive experience working in leading cross-functional teams involved in the development and implementation of marketing campaigns and programs. He led the Sun engineering team, is one of the founders of the Java EE team and the creator of the American branch of Devoxx4Kids. Arun Gupta is the author of more than 2 thousand posts in IT blogs and has made presentations in more than 40 countries.</font></font><a name="habracut"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conference DEVOXX UK. Choose a framework: Docker Swarm, Kubernetes or Mesos. Part 1</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Scale's concept of scaling means the ability to control the number of replicas by increasing or decreasing the number of application instances. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/gv/v3/fwgvv3n1z5ac0srlzcdfpw93qxq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example: if you want to scale the system to 6 replicas, use the docker service scale web = 6 command. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Along with the Replicated Service concept in Docker, there is the concept of shared services Global Service. Let's say I want to run an instance of the same container on each node of the cluster, in this case it is a container of the Prometheus web monitoring application. This application is used when you need to collect metrics about the operation of hosts. In this case, you use the subcommand - - mode = global - - name = prom prom / Prometheus.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/33/4b/oy334but50yvcsudtdiufymmirg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the Prometheus application will be launched on all nodes of the cluster, without exception, and if new nodes are added to the cluster, it will automatically start in the container and in these nodes. I hope you understand the difference between Replicated Service and Global Service. Usually the Replicated Service is where you start.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kn/aw/fn/knawfnwwuw8w3blgvr5u-gfrgv8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have examined the basic concepts, or basic entities of Docker, and now we will consider the entities of Kubernetes. Kubernetes is also a kind of planner, a platform for container orchestration. It must be remembered that the main concept of the scheduler is knowing how to schedule containers on different hosts. If you go to a higher level, we can say that orchestration means expanding your capabilities to manage clusters, obtain certificates, etc. In this sense, both Docker and Kubernetes are orchestration platforms, both of which have a built-in scheduler.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Orchestration is an automated management of related entities - clusters of virtual machines or containers. Kubernetes is a collection of services that implement a container cluster and its orchestration. It does not replace Docker, but significantly expands its capabilities, simplifying the management of deployment, network routing, resource consumption, load balancing and fault tolerance of running applications. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compared to Kubernetes, Docker is focused on working with containers, creating their images using a docker file. If we compare the Docker and Kubernetes objects, we can say that Docker manages the containers, while Kubernetes manages the Docker itself.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How many of you have dealt with Rocket containers? Does anyone use Rocket in production? Only one person raised his hand in the hall, this is a typical picture. This is an alternative to Docker, which still has not taken root in the developer community. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the core essence of Kubernetes is Pod. It is a related group of containers that use a common namespace, shared storage, and shared IP address. All containers in the hearth communicate with each other through the local host. This means that you will not be able to place the application and the database in the same hearth. They must be placed in different pods, because they have different scaling requirements.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/7g/39/xw7g39gpxvoahlobcyzap0-dch8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, you can place in one pod, for example, a WildFly container, login container, proxy container, or cache container, and you must responsibly approach the composition of the container components that you are going to scale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usually you wrap your container in the Replica Set, because you want to run a certain number of instances in the hearth. Replica Set tells you to start as many replicas as the Docker scaling service requires, and tells you when and how to do it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pods are similar to containers in the sense that if a pod fails on one host, it restarts on a different pod with a different IP address. As a Java developer, you know that when you create a java application and it communicates with the database, you cannot rely on a dynamic IP address. In this case, Kubernetes uses Service - this component publishes the application as a network service, creating a static permanent network name for a set of hearths, while simultaneously balancing the load between the hearths. It can be said that this is the service name of the database, and the java application does not rely on the IP address, but only interacts with the database constant name.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is achieved by the fact that each Pod is supplied with a specific Label, which is stored in the distributed storage etcd, and Service monitors these labels, providing a link between the components. That is, pods and services stably interact with each other using these labels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at how to create a Kubernetes cluster. For this, as in Docker, we need a master node and a working node. A node in a cluster is usually represented by a physical or virtual machine. Here, as in Docker, the wizard is a central control structure that allows you to control the entire cluster through the scheduler and controller manager. By default, a master node exists in the singular, but there are many new tools that allow you to create multiple master nodes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p_/vz/vt/p_vzvtatvsax9qkpzam3g6qi-yk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Master-node provides user interaction using the API server and contains the distributed storage etcd, which contains the configuration of the cluster, the status of its objects and metadata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Worker-node work nodes are designed exclusively for running containers, for this they have two Kubernetes services installed - a proxy service network router and a kubelet scheduler agent. While these nodes are running, Docker monitors them using systemd (CentOS) or monit (Debian), depending on which operating system you are using.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the Kubernetes architecture more broadly. We have a Master, which includes an API server (pods, services, etc.), managed using the CLI kubectl. Kubectl allows you to create Kubernetes resources. It sends commands to the API server such as ‚Äúcreate under‚Äù, ‚Äúcreate service‚Äù, ‚Äúcreate a set of replicas‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further here is the Scheduler, the Controller Manager, and the etcd repository. The controller manager, having received the instructions of the API server, maps replica labels to hearth labels, ensuring stable interaction between components. The scheduler, having received the task of creating under, scans the working nodes and creates it where it is provided. Naturally, he gets this information from etcd.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we have several working nodes, and the API server communicates with the Kubelet agents contained in them, telling them how the pods should be created. Here is the proxy that gives you access to an application that uses these pods. My client is shown on the right on the slide - this is an Internet request that goes to the load balancer, that one turns to the proxy, which distributes the request among the submissions and sends the response back. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/p3/ap/gd/p3apgd2pykmapgqbmvzwk5krzd0.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You see the final slide, which depicts the Kubernetes cluster and how all its components work.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's talk more about Service Discovery and the Docker load balancer. When you launch your Java application, this usually happens in multiple containers on multiple hosts. There is a component of Docker Compose, which makes it easy to run multi-container applications. It describes multicontainer applications and launches them using one or more yaml configuration files.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bs/tf/au/bstfau9gn_rprqjs1vsxljmhp5k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By default, these are docker-compose.yaml and docker-compose.override.yaml files, with multiple files specified using - f. In the first file you write the service, images, replicas, tags, etc. The second file is used to overwrite the configuration. After creating docker-compose.yaml, it deploys to the multi-host cluster that Docker Swarm previously created. You can create one basic configuration file docker-compose.yaml, in which you will add specific configuration files for different tasks, indicating specific ports, images, etc., we will talk about this later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On this slide, you see a simple example of a Service Discovery file. The first line indicates the version, and line 2 indicates that it concerns the db and web services.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b-/4y/ip/b-4yiphrszxkitrj1wsnlybscem.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want my web-service to communicate with the db-service after "raising". These are simple java applications deployed in WildFly containers. In line 11, I write the environment couchbase_URI = db. This means that my db service uses this database. In line 4, the couchbase image is indicated, and in lines 5-9 and 15-16, respectively, the ports necessary to ensure the operation of my services.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The key to understanding the service discovery process is that you create some kind of dependency. You indicate that the web container should start before the db container, but this is only at the container level. How your application reacts, how it starts - these are completely different things. For example, usually the container ‚Äúrises‚Äù in 3-4 seconds, however, the launch of the database container takes much longer. So the logic of launching your application should be ‚Äúbaked‚Äù in your java application. That is, the application must ping the database to make sure it is ready. Since the couchbase database is a REST API, you should call this API and ask, ‚ÄúHey, are you ready? If so, then I am ready to send you inquiries! ‚Äù</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, dependencies at the container level are determined using the docker-compose service, but at the application level, dependencies and viability are determined based on responsibility surveys. Then you take the docker-compose.yaml file and deploy it in the multi-host Docker using the docker stack deploy command and the subcommand - - compose-file = docker-compose.yaml webapp. So, you have a large stack in which there are several services that solve several problems. Basically, these are the tasks of launching containers.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6v/mc/1q/6vmc1qxqno204x2oaymesl-hrsc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how the load balancer works. In the above example, using the docker service create command, I created a service - the WildFly container, specifying the port number in the form 8080: 8080. This means that port 8080 on the host ‚Äî the local machine ‚Äî will be mapped to port 8080 inside the container, so you can access the application through </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localhost</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 8080. This will be the access port to all work nodes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6v/06/dc/6v06dcpdnkzfwwlb9e-_npqeqo0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remember that the load balancer is host oriented, not container oriented. It uses ports 8080 of each host, regardless of whether the containers are running on the host or not, because now the container is running on one host, and after the task is completed, it can be transferred to another host.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, client requests are received by the load balancer, he redirects them to any of the hosts, and if, using the IP address table, he gets to the host with an container not running, he automatically redirects the request to the host on which the container is running. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A single hop is not expensive, but it is completely ‚Äúseamless‚Äù in terms of scaling your services up or down. Thanks to this, you can be sure that your request will go exactly to the host where the container is running. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at how Service Discovery in Kubernetes works. As I said, a service is an abstraction in the form of a set of hearths with the same IP address and port number and a simple TCP / UDP load balancer. The following slide shows the Service Discovery configuration file.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l2/_h/ew/l2_hew4bmc8dg_bsq0he-pf9dgy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creating resources such as pods, services, replicas, etc. </font><font style="vertical-align: inherit;">happens based on the configuration file. </font><font style="vertical-align: inherit;">You see that it is divided into 3 parts using lines 17 and 37, which consist only of - - -. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at line 39 first - it says kind: ReplicaSet, that is, what we are creating. </font><font style="vertical-align: inherit;">Lines 40-43 contain metadata, with lines 44 specifying the specification for our replica set. </font><font style="vertical-align: inherit;">Line 45 indicates that I have 1 replica, its Labels are listed below, in this case the name is wildfly. </font><font style="vertical-align: inherit;">Even lower, starting from line 50, it is indicated in which containers this replica should be launched - this is wildfly-rs-pod, and lines 53-58 contain the specification of this container. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
23:05 min </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To be continued very soon ...</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/1dgUXNVQS5o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of advertising :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for staying with us. Do you like our articles? Want to see more interesting materials? Support us by placing an order or recommending to your friends, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud VPS for developers from $ 4.99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique analog of entry-level servers that was invented by us for you: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The whole truth about VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps from $ 19 or how to divide the server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 times cheaper at the Equinix Tier IV data center in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only we have </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV from $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the Netherlands!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - from $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read about</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to Build Infrastructure Bldg. </font><font style="vertical-align: inherit;">class c using Dell R730xd E5-2650 v4 servers costing 9,000 euros for a penny?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en506572/index.html">Creating a prototype SPA online store on htmlix.js</a></li>
<li><a href="../en506574/index.html">Visualization of a list of women Nobel Prize winners in the form of crystals in 3d using Vue, WebGL, three.js</a></li>
<li><a href="../en506578/index.html">Managed Lead Volume</a></li>
<li><a href="../en506586/index.html">Logical FizzBuzz</a></li>
<li><a href="../en506588/index.html">What is an algorithm! (part 2)</a></li>
<li><a href="../en506594/index.html">Redis Best Practices, Part 3</a></li>
<li><a href="../en506598/index.html">Microsoft: Rust is the 'Best Chance' in the Safe Systems Programming Industry</a></li>
<li><a href="../en506600/index.html">The contract for the development of the site in terms of project management (theory + sample)</a></li>
<li><a href="../en506604/index.html">Concurrency and Efficiency: Python vs FSM</a></li>
<li><a href="../en506606/index.html">PIXI.js clicker creation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>