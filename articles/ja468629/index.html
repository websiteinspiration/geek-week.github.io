<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗾 👏🏿 🕵️ 100万回実行しても画像が破損しないフィルターを作成する方法-パート2 😮 🧜🏻 ❄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最初の部分、この記事、私は標準halfpelフィルタの繰り返し使用が歪んだ画像を作成し、この問題を持っていない新しいフィルタを示したかについて話しました。
 
 それはもう少しぼやけていて、これは誰にでも合いません。ただし、これは他の方法より優れていました。実際、このフィルターはBink 2のオリジ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>100万回実行しても画像が破損しないフィルターを作成する方法-パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="画像"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="画像"></div><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の部分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この記事、私は標準halfpelフィルタの繰り返し使用が歪んだ画像を作成し、この問題を持っていない新しいフィルタを示したかについて話しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはもう少しぼやけていて、これは誰にでも合いません。ただし、これは他の方法より優れていました。実際、このフィルターは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bink 2の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリジナルバージョンで使用されていました</font><font style="vertical-align: inherit;">。仕事量が一定だったので、彼に戻って詳細を調べることはできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし</font><font style="vertical-align: inherit;">、このフィルターに戻って記事を書く時間を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見つけた</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、ついに質問</font><font style="vertical-align: inherit;">をします。「無限の安定性」の特性を保持している、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ぼやけ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><i><font style="vertical-align: inherit;">少ない</font></i><font style="vertical-align: inherit;">フィルター</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スポイラー警告：正解は「おそらくない」と「間違いなくそこにあります」。</font><font style="vertical-align: inherit;">しかし、この質問に2つの答えがある理由とその意味を説明する前に、テストベンチを準備してみましょう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフセット調整</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が最初にこの問題に取り組んだとき、何を探しているのかわかりませんでした。</font><font style="vertical-align: inherit;">「無限に安定した」ハーフペルフィルターのようなもの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あること</font><font style="vertical-align: inherit;">さえ知らなかった</font><font style="vertical-align: inherit;">ので、その検索でシステムを作成しませんでした。私は、画像の歪みがなく、「多くの」フィルターの繰り返しに耐えられるものを探していました。最初の部分のすべての画像はこの方法論を反映しています。画像は一度に右から左に半ピクセルずつシフトされます。つまり、フィルターを100回適用すると、結果の画像は50ピクセルずつシフトされます。</font><i><font style="vertical-align: inherit;">実際に</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
探しているもの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかった</font><font style="vertical-align: inherit;">ので、もう少し正確にすることができます。ハーフペルフィルターを2回適用して、画像を1ピクセルだけシフトします。つまり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、画像を1ピクセルだけ戻すと</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、同じスペースに残ります。このおかげで、画像が画面から「這い去る」ことを恐れずに何度でもフィルターを適用できるだけでなく</font><font style="vertical-align: inherit;">、以前のバージョンと元の画像との</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違い</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見つけることができるため、テストははるかに美しく見えます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、フィルターを自動的にテストできます。</font><font style="vertical-align: inherit;">フィルターを何度も適用して、2つのことの1つを確認します。フィルターが無限に安定していることを示す未変更の画像への収束、またはフィルターが「壊れている」ことを示す元の画像からの大幅な偏差です。</font><font style="vertical-align: inherit;">これらのテストでは、チャネル64あたりの平均エラー（255から）、または任意のチャネルの最大エラーを255までフルに選択した場合、「有意に大きい」と判断しました。 」</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の部分からフィルターを再テストする</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、これらのフィルターをテストする方法を理解したので、最初の部分からフィルターをもう一度見てみましょう。</font><font style="vertical-align: inherit;">バイリニアから始めましょう。もちろん、これはそれほど興味深いものではありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、244回の反復後の画像です。</font><font style="vertical-align: inherit;">ご想像のとおり、ピクセルは常に平均化されているため、画像は徐々に「崩れ」ます。</font><font style="vertical-align: inherit;">しかし、それでも徐々に平均誤差の限界に達します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにh.264があります：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イメージを壊すには、78回の反復で十分です。</font><font style="vertical-align: inherit;">8つのサンプルを含むHEVCフィルターの動作は少し良くなりますが、150回の反復後も壊れます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6サンプルのLanczosは、166回の反復後に中断します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが壊れたフィルターのすべてです。</font><font style="vertical-align: inherit;">残っているのは私の整数フィルターだけです：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想通り、彼</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破ったの</font><i><font style="vertical-align: inherit;">は</font></i><font style="vertical-align: inherit;">彼だけでは</font><i><font style="vertical-align: inherit;">なかった</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">208回の反復後、無限に安定した画像に収束します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私たちが知っていることは非常に注目に値します。少なくとも広範囲のテスト画像</font><font style="vertical-align: inherit;">では、</font><font style="vertical-align: inherit;">このフィルターは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限に安定しています</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、何回使用しても、アーティファクトは作成されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私たちを元の質問に戻します：彼は本当に最高ですか？</font><font style="vertical-align: inherit;">そして、あなたはすでに答えを知っています。なぜなら、記事の冒頭で私は「おそらくそうではない」と「間違いなくそうです」とも書いたからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に「おそらくない」部分を最初に見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数フィルター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、投稿の最初の部分で、私が見つけたフィルターコアは「最もよく見つかる」と述べましたが、これはその特異性です。</font><font style="vertical-align: inherit;">そしてここに特徴があります：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このフィルターを探していたとき</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最高の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルターを</font><font style="vertical-align: inherit;">探していませんでした</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に少数の整数シフト、加算、減算で表現できる</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最高のフィルター</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">探していました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">奇妙に見えるかもしれませんが、時間をかけてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
お気づきかもしれませんが、h.264、HEVC、バイリニアフィルター、およびフィルターの係数を示したとき、これらを整数分母に整数分母として次のように書き留めました。</font></font><br>
<br>
<pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number">1.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">-4.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">19.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">19.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">-4.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">32.0</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ウィンドウ化されたsincの場合、私は別の行動をとり、次のように書きました。</font></font><br>
<br>
<pre><code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number">0.02446</span>, <span class="hljs-number">-0.13587</span>, <span class="hljs-number">0.61141</span>, <span class="hljs-number">0.61141</span>, <span class="hljs-number">-0.13587</span>, <span class="hljs-number">0.02446</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ウィンドウ化されたsincは、実際には通常の整数の小数とは何の関係もない連続的な数学関数から推測されるためです。このフィルターを使用する場合、sinc関数の値に対応する浮動小数点数が（できるだけ正確に）使用されます。それらを正確に適用しようとする場合、エラーを追加するため、それらを通常の分数に丸めないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来、ビデオコーデックはそのような操作を実行する余裕がありません。動き補償などの「重い」タスクでの浮動小数点演算は、低電力または特殊な機器では使用できません。これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、低コスト、低コストの組み込みチップなど、幅広いデバイスで動作する業界標準のコーデックについて話している場合に当てはまります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、それらをCPUで実行した場合でも、最新の命令セットはSIMDに基づいています。つまり、CPUでの整数演算はより高速に実行できます。2つの16ビット整数を1つの32ビットフロートのスペースに収めることができ、基本的に演算のパフォーマンスが2倍になります。したがって、操作ごとの正確なサイクル数を考慮する場合、浮動小数点が常に最速のオプションであるとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、この機能が重要である理由がわかります。必要なのは単純な16ビット整数演算だけだったので、約2から64の累乗の除数で小さい整数として表現できるカーネルを探しました。これは、</font><font style="vertical-align: inherit;">6つの浮動小数点係数の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットを</font><font style="vertical-align: inherit;">検討していた場合と比較して、はるかに制限されたフィルターの</font><font style="vertical-align: inherit;">セットです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、効率上の理由から、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数のサンプル</font><font style="vertical-align: inherit;">は考慮しませんでした</font><font style="vertical-align: inherit;">。唯一の選択肢は6以下だったので、8または10サンプルのバージョンをテストすることもしませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私たちは最初の答えにたどり着きました：「おそらくない」。</font><font style="vertical-align: inherit;">これらの制限を遵守すると、劣化することなく無限に適用できる優れたフィルターが見つからない可能性が高くなります。</font><font style="vertical-align: inherit;">最初の部分のフィルターコアは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちが見つけることができる最高のものですが、徹底的に証明することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし</font><font style="vertical-align: inherit;">、そのような制限を守る</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要がない</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は</font><i><font style="vertical-align: inherit;">どう</font></i><font style="vertical-align: inherit;">でしょうか。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮動小数点バージョン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オリジナルのバージョンの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bink 2に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固有の制限</font><font style="vertical-align: inherit;">（現在はかなり古くなっており、多くのリビジョンがリリースされているため）を</font><font style="vertical-align: inherit;">取り除き、</font><font style="vertical-align: inherit;">任意の浮動小数点係数を使用すると、結果はどの程度改善できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、私は整数カーネルが劣化しないことを知っており、ランチョスはより鋭敏であるが劣化していることを知っているので、</font><font style="vertical-align: inherit;">劣化が始まる2つの係数セットの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場所を見つけることができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それで、私はこの特定のポイントを見つけるのを助けるプログラムを書きました、そしてここに私が見つけたカーネルがあります：</font></font><br>
<br>
<pre><code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number">0.027617</span>, <span class="hljs-number">-0.130815</span>, <span class="hljs-number">0.603198</span>, <span class="hljs-number">0.603198</span>, <span class="hljs-number">-0.130815</span>, <span class="hljs-number">0.027617</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このカーネルは収束に272回の反復が必要ですが、無限に安定しており</font><font style="vertical-align: inherit;">、整数フィルターよりも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はるかに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鋭く</font><font style="vertical-align: inherit;">見え</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、それはオリジナルとほとんど区別がつきません：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほぼ...しかし、かなりではありません。</font><font style="vertical-align: inherit;">よく見ると、コントラストの高い領域でぼやけや減衰が見られます。</font><font style="vertical-align: inherit;">これを確認する最も簡単な方法は、オレンジ色の「恐竜」の目と竹の後ろの明るい光の領域です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、6サンプルの浮動小数点フィルターは間違いなく優れていますが、完全ではありません。</font><font style="vertical-align: inherit;">まだ改善できますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルター幅を広げる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、小さな整数の分数と同じ理由で、6つのサンプルを持つフィルターが選択されました。非常に効率的なフィルターを探していました。</font><font style="vertical-align: inherit;">しかし、現在は調査中であり、すでに浮動小数点数に移行しているので、より広いフィルターを検討してみませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6サンプルの整数フィルターと6サンプルのランチョスを組み合わせると、非常に優れたフィルターが得られます。</font><font style="vertical-align: inherit;">それを8サンプルのLanczosとペアにしてみませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8サンプルのLanczosは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs">Lanczos8[] = {<span class="hljs-number">-0.01263</span>, <span class="hljs-number">0.05976</span>, <span class="hljs-number">-0.16601</span>, <span class="hljs-number">0.61888</span>, <span class="hljs-number">0.61888</span>, <span class="hljs-number">-0.16601</span>, <span class="hljs-number">0.05976</span>, <span class="hljs-number">-0.01263</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6サンプルのランチョスのように、それは非常に不安定であり、178回の反復後に崩壊します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6サンプルの整数フィルターと8サンプルのランチョスの間のより良いフィルターを探すと、このかなり注目に値する8サンプルフィルターが見つかります。</font></font><br>
<br>
<pre><code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number">-0.010547</span>, <span class="hljs-number">0.052344</span>, <span class="hljs-number">-0.156641</span>, <span class="hljs-number">0.614844</span>, <span class="hljs-number">0.614844</span>, <span class="hljs-number">-0.156641</span>, <span class="hljs-number">0.052344</span>, <span class="hljs-number">-0.010547</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
無限に安定したフィルターとして、それは驚くほどうまく機能します。</font><font style="vertical-align: inherit;">これは202回の反復後に収束し（収束は私の2つのフィルターよりも高速です）、元のものに非常に似ているため、どれがどれであるかを判別することは困難です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参考のために元のコードを次に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元の整数フィルターと比較して、大幅な改善があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限に安定したフィルターはどのように機能しますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこの投稿を次のように終了するつもり</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
でした。無限に適用可能な変換を使用して作業した他の領域では、境界数学がどのように実行され、有用な分析が作成されるかを知っています。まず、サブディビジョンサーフェスの境界面の分析が行われ、サブディビジョンマトリックスの固有値と固有ベクトルが計算されます。その後、無限次数に制限を正確に取ることができます。ただし、ハーフペルフィルターに対してこのような分析を実行した経験はありません。なぜなら、それらはピクセルを所定の位置に残さず、横にシフトするためです。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが私の計画でした。しかし、第1部と第2部の執筆の間に、改良されたフィルターの結果を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabien Giessen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charles Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にメールで送りました</font><font style="vertical-align: inherit;">。それは不思議ではありません</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼ら</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこの問題を分析的に研究するために必要な数学</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">知っ</font><i><font style="vertical-align: inherit;">て</font></i><font style="vertical-align: inherit;">いました。フィルターについては、実際には固有値とベクトルの分析が存在することが判明しましたが、その方法ではうまく機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に実行</font><i><font style="vertical-align: inherit;">でき</font></i><font style="vertical-align: inherit;">ます。実際、CAMプログラムには簡単な1ステップのプロセスとして組み込まれており、フィルターの固有値を実際に確認できます。ここでは、</font><font style="vertical-align: inherit;">各フィルタリング後に8ビット（または10ビット、または12ビット）</font><font style="vertical-align: inherit;">に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丸め</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または切り捨て）する</font><font style="vertical-align: inherit;">という事実は重要です</font><font style="vertical-align: inherit;">。なぜなら、切り捨ては、無限に正確な代数と比較してエラーを累積する方法に影響を与えるからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、これは私の専門分野ではありませんので、この分析の詳細を理解することさえできません。</font><font style="vertical-align: inherit;">彼らは（彼らは両方の技術的なブログ持っている-メールで送ってくれてよかった情報で記事を書くことができれば、私はファビアンとチャールズを尋ね</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RYGブログ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cbloom暴言を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、とファビアンが書いた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定したフィルタの数学的な基礎の上に記事の優れたシリーズを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私の2つの投稿で起こっていることの理論的な構造に興味がある場合は、このシリーズを読むことをお勧めします！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468611/index.html">.NETマルチスレッド：パフォーマンスが不足している場合</a></li>
<li><a href="../ja468621/index.html">ホームネットワークをDoHに変換するか、フィルタリングノーズをもう一度クリックします。</a></li>
<li><a href="../ja468623/index.html">Habrのレビューが欲しい</a></li>
<li><a href="../ja468625/index.html">サーバーレス：15％遅く、8倍高価</a></li>
<li><a href="../ja468627/index.html">ADAM-6200 I / Oモジュール</a></li>
<li><a href="../ja468631/index.html">Flutterアプリケーションのテスト。開始</a></li>
<li><a href="../ja468635/index.html">遷移金属ジカルコゲナイド：WS2結晶成長の秘密の解明</a></li>
<li><a href="../ja468637/index.html">パンダで大きなデータセットを処理する方法。Pythonと8GBのメモリを使用してFIASデータベースを操作します</a></li>
<li><a href="../ja468639/index.html">2019のWebコンソールの新機能</a></li>
<li><a href="../ja468645/index.html">コンピュータサイエンスの分野からの30年の仮説を証明するには、2ページで十分でした。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>