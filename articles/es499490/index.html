<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèΩ üôÖüèΩ üçñ Algoritmos Aleatorios üïØÔ∏è üçç üõ¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, ver√° los algoritmos de bicicleta m√°s diversos para generar n√∫meros aleatorios.
 
 Sobre qu√© art√≠culo
 Acerca de los algoritmos que g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmos Aleatorios</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499490/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo, ver√° los </font><font style="vertical-align: inherit;">algoritmos de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bicicleta</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s diversos </font><font style="vertical-align: inherit;">para generar n√∫meros aleatorios.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre qu√© art√≠culo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acerca de los algoritmos que generan n√∫meros pseudoaleatorios que difieren en la calidad del resultado y la velocidad de ejecuci√≥n. </font><font style="vertical-align: inherit;">El art√≠culo ser√° √∫til para aquellos que desean obtener una generaci√≥n de n√∫meros de alto rendimiento en sus programas o desarrolladores de software para microcontroladores y plataformas antiguas como ZX Spectrum o MSX.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ rand</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que un programador novato de C ++ aprende acerca de obtener una casa aleatoria es la funci√≥n rand, que genera un n√∫mero aleatorio entre 0 y RAND_MAX. </font><font style="vertical-align: inherit;">La constante RAND_MAX se describe en el archivo stdlib.h y es 32'767, pero este puede no ser el caso, por ejemplo, en Linux ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver comentario</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Si rand () en su compilador genera n√∫meros dentro de 32'767 (0x7FFF) y desea obtener un n√∫mero aleatorio de gran tama√±o, entonces el siguiente c√≥digo puede considerarse como una soluci√≥n a este problema:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int64_t</span> A = rand();<font></font>
A &lt;&lt;= <span class="hljs-number">15</span>; <span class="hljs-comment">//   15,   7FFF  15 </span><font></font>
A |= rand();<font></font>
A &lt;&lt;= <span class="hljs-number">15</span>;<font></font>
A |= rand();<font></font>
A &lt;&lt;= <span class="hljs-number">15</span>;<font></font>
A |= rand();<font></font>
A &lt;&lt;= <span class="hljs-number">3</span>;<font></font>
A |= rand() &amp; <span class="hljs-number">0b111</span>; <span class="hljs-comment">//  3  </span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementaci√≥n de la funci√≥n rand en la antigua C era simple y se ve√≠a as√≠:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand</span><span class="hljs-params">()</span>
</span>{<font></font>
  next = next * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>;
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(next / <span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta implementaci√≥n no ten√≠a una muy buena distribuci√≥n de n√∫meros y ahora est√° mejorada en C ++. </font><font style="vertical-align: inherit;">Adem√°s, la biblioteca est√°ndar de C ++ ofrece formas adicionales de obtener un n√∫mero aleatorio, que se analizan a continuaci√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11 STL aleatorio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta variedad de aleatoriedad apareci√≥ en C ++ 11 y consiste en el siguiente conjunto de clases: minstd_rand, mt19937, ranlux, knuth_b y sus diversas variaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar que la secuencia de n√∫meros aleatorios se repita cada vez que se inicia el programa, el "grano" del generador pseudoaleatorio se configura en la forma de la hora actual o, en el caso de algunos juegos retro (y no solo), los intervalos entre las pulsaciones del teclado / joystick. </font><font style="vertical-align: inherit;">La biblioteca aleatoria sugiere usar std :: random_device para obtener el grano mejor que el tiempo (NULL), sin embargo, en el caso del compilador MinGW en Windows, la funci√≥n pr√°cticamente no funciona como deber√≠a. </font><font style="vertical-align: inherit;">Todav√≠a‚Ä¶</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   :</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><font></font>
<font></font>
<span class="hljs-built_in">std</span>::mt19937 engine; <span class="hljs-comment">// mt19937    </span>
engine.seed(<span class="hljs-built_in">std</span>::time(<span class="hljs-literal">nullptr</span>));
<span class="hljs-comment">/*
 ,    UNIX--    MinGW
std::random_device device;
engine.seed(device());
*/</span>
<span class="hljs-keyword">int</span> val = engine(); <span class="hljs-comment">//   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos de los algoritmos en STL random pueden funcionar m√°s r√°pido que rand (), pero dan una secuencia de n√∫meros aleatorios de menor calidad.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PRNG - Generador de n√∫meros pseudoaleatorios</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede considerar este nombre como sin√≥nimo del m√©todo congruente lineal. </font><font style="vertical-align: inherit;">Los algoritmos PRNG son similares a la implementaci√≥n de rand en C y difieren solo en constantes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">PRNG</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> seed = <span class="hljs-number">1</span>; <span class="hljs-comment">//     0</span>
  seed = (seed * <span class="hljs-number">73129</span> + <span class="hljs-number">95121</span>) % <span class="hljs-number">100000</span>;
  <span class="hljs-keyword">return</span> seed;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los algoritmos PRNG son r√°pidos y f√°ciles de implementar en muchos idiomas, pero no tienen un per√≠odo extenso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xorshift</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo tiene muchas variaciones, que difieren entre s√≠ por el per√≠odo y los registros utilizados. </font><font style="vertical-align: inherit;">Los detalles y variedades de XorShift se pueden ver en Wikipedia o Habr√©. </font><font style="vertical-align: inherit;">Dar√© una de las opciones con una secuencia de 2 en el grado 128.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seed_t</span>
{</span>
  <span class="hljs-keyword">unsigned</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">//     </span>
  <span class="hljs-keyword">unsigned</span> y = <span class="hljs-number">123</span>;
  <span class="hljs-keyword">unsigned</span> z = <span class="hljs-number">456</span>;
  <span class="hljs-keyword">unsigned</span> w = <span class="hljs-number">768</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">XorShift128</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">seed_t</span> s;
  <span class="hljs-keyword">unsigned</span> t = s.x^(s.x&lt;&lt;<span class="hljs-number">11</span>);<font></font>
  s.x = s.y;<font></font>
  s.y = s.z;<font></font>
  s.z = s.w;<font></font>
  s.w = (s.w^(s.w&gt;&gt;<span class="hljs-number">19</span>)) ^ (t^(t&gt;&gt;<span class="hljs-number">8</span>));
  <span class="hljs-keyword">return</span> s.w;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este generador es muy bueno porque no hay operaciones de divisi√≥n y multiplicaci√≥n en absoluto; esto puede ser √∫til en procesadores y microcontroladores en los que no hay instrucciones de divisi√≥n / multiplicaci√≥n de ensamblador (PIC16, Z80, 6502).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 bits al azar en el emulador z26</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Z26 es un emulador de un antiguo prefijo Atari2600, en cuyo c√≥digo puede encontrar uno aleatorio orientado a trabajar con registros de 1 byte.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// P2_sreg - static uint8_t</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P2_Read_Random</span><span class="hljs-params">()</span>
</span>{<font></font>
  P2_sreg =<font></font>
    (((((P2_sreg &amp; <span class="hljs-number">0x80</span>) &gt;&gt; <span class="hljs-number">7</span>) ^<font></font>
       ((P2_sreg &amp; <span class="hljs-number">0x20</span>) &gt;&gt; <span class="hljs-number">5</span>)) ^<font></font>
      (((P2_sreg &amp; <span class="hljs-number">0x10</span>) &gt;&gt; <span class="hljs-number">4</span>) ^<font></font>
       ((P2_sreg &amp; <span class="hljs-number">0x08</span>) &gt;&gt; <span class="hljs-number">3</span>))) ^ <span class="hljs-number">1</span>) |<font></font>
        (P2_sreg &lt;&lt; <span class="hljs-number">1</span>);<font></font>
  DataBus = P2_sreg;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez que tuve que hacer una implementaci√≥n de este algoritmo para z80:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo de montaje</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">;    z26<font></font>
; a - output<font></font>
; rdseed - 1  <font></font>
randz26:<font></font>
    exx<font></font>
<font></font>
    ld a,(rdseed)<font></font>
    and 20h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    ld h, a<font></font>
<font></font>
    ld a,(rdseed)<font></font>
    and 80h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    xor h<font></font>
    ld l, h<font></font>
    <font></font>
    ld a,(rdseed)<font></font>
    and 08h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    ld h, a<font></font>
<font></font>
    ld a,(rdseed)<font></font>
    and 10h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    xor h<font></font>
    ld h, a<font></font>
    ld a, l<font></font>
    xor h<font></font>
    xor 1<font></font>
<font></font>
    ld h, a<font></font>
    ld a,(rdseed)<font></font>
    sla a<font></font>
    or h<font></font>
    ld (rdseed),a<font></font>
<font></font>
    exx<font></font>
    ret<font></font>
</code></pre><br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compacto aleatorio para Z80 de Joe Wingbermuehle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si est√° interesado en escribir programas para autom√≥viles con zilog, le presento un algoritmo de Joe Wingbermuehle (solo funciona en zilog):</font></font><br>
<br>
<pre><code class="plaintext hljs">; By Joe Wingbermuehle<font></font>
; a res 1 byte - out val<font></font>
; rdseed res 1 byte - need for rand. != 0<font></font>
rand8:<font></font>
        exx<font></font>
        ld      hl,(rdseed)<font></font>
        ld      a,r<font></font>
        ld      d,a<font></font>
        ld      e,(hl)<font></font>
        add     hl,de<font></font>
        add     a,l<font></font>
        xor     h<font></font>
        ld      (rdseed),hl<font></font>
        exx<font></font>
        ret<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random House Generator en DOOM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el c√≥digo fuente del juego Doom hay un archivo tan interesante llamado m_random.c </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ver c√≥digo)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que describe la funci√≥n de la aleatoriedad de la "tabla", es decir, no hay f√≥rmulas y magia con cambios de bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√© un c√≥digo m√°s compacto que muestra claramente el funcionamiento de esta funci√≥n.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> random_map[] =<font></font>
{<font></font>
  <span class="hljs-number">4</span>,  <span class="hljs-number">1</span>,   <span class="hljs-number">63</span>, <span class="hljs-number">3</span>,
  <span class="hljs-number">64</span>, <span class="hljs-number">22</span>,  <span class="hljs-number">54</span>, <span class="hljs-number">2</span>,
  <span class="hljs-number">0</span>,  <span class="hljs-number">52</span>,  <span class="hljs-number">75</span>, <span class="hljs-number">34</span>,
  <span class="hljs-number">89</span>, <span class="hljs-number">100</span>, <span class="hljs-number">23</span>, <span class="hljs-number">84</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> index = <span class="hljs-number">0</span>;<font></font>
  index = (index + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xF</span>; <span class="hljs-comment">// 0xF,      random_map</span>
  <span class="hljs-keyword">return</span> random_map[index];<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varik para z80</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">;   (  DOOM)<font></font>
; rand_table -    .  <font></font>
;                        256    .<font></font>
; a - output num<font></font>
randtab:<font></font>
    exx<font></font>
    ; index<font></font>
    ld a, (rdseed)<font></font>
    inc a<font></font>
    ;and filter ; for crop array index<font></font>
    ld (rdseed), a<font></font>
    ; calc array address<font></font>
    ld hl, rand_table<font></font>
    ld d, 0<font></font>
    ld e, a<font></font>
    add hl, de<font></font>
    ld a, (hl) ; get num from arr<font></font>
    exx<font></font>
    ret<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, esto no es aleatorio y la secuencia de n√∫meros aleatorios es f√°cil de predecir incluso a nivel de intuici√≥n durante el juego, pero todo funciona extremadamente r√°pido. </font><font style="vertical-align: inherit;">Si la fuerza criptogr√°fica no es particularmente importante para usted y desea algo que genere r√°pidamente "tipo aleatorio", entonces esta funci√≥n es para usted. </font><font style="vertical-align: inherit;">Por cierto, en Quake3, el aspecto aleatorio es simple: rand () y 0x7FFF.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RDRAND</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos procesadores modernos son capaces de generar n√∫meros aleatorios con una sola instrucci√≥n de ensamblador: RDRAND. </font><font style="vertical-align: inherit;">Para usar esta funci√≥n en C ++, puede escribir manualmente las instrucciones necesarias con insertos de ensamblador o conectar el archivo immintrin.h en GCC y seleccionar cualquiera de las variaciones de la funci√≥n _rdrandXX_step, donde XX significa el n√∫mero de bits en el registro y puede ser 16, 32 o 64.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">unsigned</span> val;<font></font>
_rdrand32_step(&amp;val);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ve un error de compilaci√≥n, significa que no activ√≥ el indicador -mrdrnd o que su compilador / procesador no es compatible con esta herramienta. </font><font style="vertical-align: inherit;">Puede ser el generador de n√∫meros aleatorios m√°s r√°pido, pero hay preguntas sobre su fuerza criptogr√°fica, as√≠ que pi√©nselo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalizando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clase std :: minstd_rand de la biblioteca aleatoria STL es m√°s r√°pida que la rand ordinaria () y puede convertirse en un reemplazo alternativo si no est√° particularmente preocupado por la duraci√≥n del per√≠odo en minstd. </font><font style="vertical-align: inherit;">Puede haber diferencias en c√≥mo funcionan estas funciones en Windows y Unix.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infa sobre el tema</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un art√≠culo sobre C ++ 11 aleatorio y algunas caracter√≠sticas de trabajar con √©l: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generaci√≥n de n√∫meros aleatorios en C ++ moderno</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°les son los generadores en STL al azar? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exilio</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art√≠culo de Wiki sobre XorShift con diferentes implementaciones: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tyk</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Git emulator z26. </font><font style="vertical-align: inherit;">C√≥digo aleatorio en el archivo c_pitfall2.c: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generador aleatorio Dumchik: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git</font></font></a></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD Mi primer art√≠culo. </font><font style="vertical-align: inherit;">Escribe lo que es superfluo, qu√© agregar / reducir</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499472/index.html">C√≥mo el coronavirus acelerar√° la cuarta revoluci√≥n industrial</a></li>
<li><a href="../es499474/index.html">C√≥mo implementar Atlassian Jira + Confluence en una corporaci√≥n. Problemas t√©cnicos</a></li>
<li><a href="../es499476/index.html">Pruebas de automatizaci√≥n de aplicaciones web llave en mano, sin registro y SMS.</a></li>
<li><a href="../es499482/index.html">C√≥mo los inversores ahorran finanzas en una crisis: enfoques para la diversificaci√≥n, selecci√≥n de activos de bajo riesgo y optimizaci√≥n de costos</a></li>
<li><a href="../es499486/index.html">La ret√≥rica como herramienta de seguridad.</a></li>
<li><a href="../es499492/index.html">¬øEs posible que un desarrollador en Silicon Valley se convierta en millonario? Ingeniero de personal analizando en Lyft</a></li>
<li><a href="../es499502/index.html">Por qu√© OceanStor Dorado V6 es el almacenamiento m√°s r√°pido y confiable</a></li>
<li><a href="../es499504/index.html">Protocolo de seguimiento de contactos Bluetooth de Apple y Google</a></li>
<li><a href="../es499506/index.html">¬øPago por hora, por el resultado o salario?</a></li>
<li><a href="../es499508/index.html">Preparando nuestro producto para escalar con las colas de Laravel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>