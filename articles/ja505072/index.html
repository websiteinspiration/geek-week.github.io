<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐷 🤞🏽 👠 プロジェクトパナマ：Javaを「ハードウェアに近づける」方法 💅🏾 🌘 👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2月にNovosibirsk Boiling Point でJUGNskの第13 回ミーティングが行われ、HotSpot仮想Javaマシン開発グループのオラクルのリードエンジニアであるVladimir Ivanov氏は、JNIがJavaコードの相互作用をネイティブコードに置き換えていると述べました。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プロジェクトパナマ：Javaを「ハードウェアに近づける」方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/leader-id/blog/505072/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2月に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novosibirsk Boiling Point </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でJUGNsk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の第13 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">回ミーティングが行わ</font></a><font style="vertical-align: inherit;">れ、HotSpot仮想Javaマシン開発グループのオラクルのリードエンジニアであるVladimir Ivanov氏は、JNIがJavaコードの相互作用をネイティブコードに置き換えていると述べました。</font><font style="vertical-align: inherit;">FFI（Foreign Function Interface）、jextract、Memory Access API、Foreign ABI（Application Binary Interface）の詳細をご覧ください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/bu/ya/kqbuyat7_blzsk5rjyobfsc80fo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事はレポートに基づいて作成されまし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">質疑応答のビデオが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ここにあります</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは単なる解読ではなく、ウラジミール自身が完成させたソース資料のバージョンです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、レポートはかなり具体的なトピック、つまりJavaからのプラットフォーム（ネイティブ）ライブラリとの相互作用に焦点を当てています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての始まり</font></font></h2><br>
<img src="https://habrastorage.org/webt/r4/fs/uj/r4fsujpiwhg7dj8qf-qsgbilfay.jpeg"><br>
<i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charles Nutter</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Java </font><i><font style="vertical-align: inherit;">を使用した</font></i><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Java Native Runtime</font></a></i><i><font style="vertical-align: inherit;">レポートのビデオ録画は</font></i></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenJDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のフレームワーク内で開発さ</font><font style="vertical-align: inherit;">れ、言語とプラットフォームのイノベーションはすべて専門のOpenJDKプロジェクトで作成されます。例：ラムダ式とStream APIはProject Lambdaから提供され、モジュールシステム（JPMS）はProject Jigsawの一部として作成され、Project Valhallaでの作業はインライン型（およびそれに関連するすべて）で行われます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトパナマ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、そのようなメガプロジェクトの1つであり、その枠組みの中で、プラットフォームライブラリを操作するための新しいメカニズム（だけでなく）が開発されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの現在の状態（または「スナップショット」）自体はそれほど興味深いものではありません。したがって、私はプロジェクトがどこにあるのかを知るだけでなく、プロジェクトがどのように始まったのか、近年何が起こっているのか、現在どこにあるのか、そしてどこへ進むのかを考えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはプロジェクトを側面から見て、この1年で何が変わったかを理解していません。 1年前に値型について話しましたが、今はそれらが異なる方法で呼び出されていると仮定します-インライン型。外から見ると、これらはすべて変化しているように見えるかもしれません。しかし、詳細を見て、年ごとの変化を追うと、作業量は印象的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パナマに戻る：Charles Nutter（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@headius</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">がプロジェクトのインスピレーションとなり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMLS 2013</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">大きな</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">違い</font></a><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">もたらしました</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JRubyがプラットフォームと連携するために積極的に使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ているJNRライブラリ</font></a><font style="vertical-align: inherit;">（Java Native Runtime）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">に関するレポート</font></a><font style="vertical-align: inherit;">。レポートでは、JNR、JNI、およびJNA（ネイティブコードと対話するための別のライブラリ）のパフォーマンスを比較しました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e64/4fb/587/e644fb587f47479011e44b3e81a88221.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（純粋なJNI、JNRなどを介した）すべての呼び出しオプションのパフォーマンスは、ネイティブ関数を直接呼び出すのとはほど遠く、サードパーティライブラリのレベルでそれを上げることができなくなりました-Java仮想マシン（JVM）からの助けが必要でした。 Charles Nutterのアイデアは、JNIを置き換える新しいAPIを作成することでした。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/933/b6c/02d/933b6c02d683f6a5c9e7342132ec52cc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、当時のJava開発はJSRに基づいていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャールズの電話が聞こえ、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">議論は</font></a><font style="vertical-align: inherit;"> 2014年3月に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">始まり</font></a><font style="vertical-align: inherit;">ました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいOpenJDKプロジェクト。提案はコミュニティで良い反応を得たので、プロジェクトの開始日は、ジョンローズがプロジェクトパナマの作成に関する公式投票を開始した2014年3月18日と見なすことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t8/tr/nd/t8trndreaf4ynbw6pv9uqgiw_ue.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトのために発表された「責任の範囲」は、チャールズが提案したよりもはるかに広く選択されました。国鉄の場合、ライブラリ関数を直接呼び出すための低レベルの方法を追加するだけで十分です。メモリへの直接アクセスはすでにsun.misc.Unsafeでした。そして、JNRにとっても、似たようなもので十分でした。あるネイティブ関数の入力アドレスでは、仮想マシンがこのアドレスへの直接呼び出しを生成するだけでした。 JRuby（POSIXインターフェースを使用）の目的では、これで十分です。しかし、JavaプラットフォームやJNIの代替と見なされるものは対象ではありません。そのため、プロジェクトの当初から野心的な目標が述べられていました。ネイティブコードで作業するだけでなく、メモリ内のデータの完全にプログラム可能な表現（メモリレイアウト）をサポートして、より緊密な相互作用を実現しました。プロジェクトは厳しい境界に限定されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パナマ海峡を連想させる「おしゃべりの」名前が選ばれたのは無駄ではありませんでした。パナマプロジェクトはJavaとネイティブコードを互いに「より近づける」ことでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hp/e5/ft/hpe5ftvhwreus8bf9afc44jczhq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パナマプロジェクトには独自のリポジトリがあります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。http</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//hg.openjdk.java.net/panama/dev/</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
現在、JNIとベクターAPIに代わる2つの主要な作業分野があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f2f/fa8/139/f2ffa81399ed5dbc5909dbecf63ad07d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFIに起因する可能性のある4つの主要な分岐を次に示します。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/aa7/5c4/298/aa75c4298dd08f7838d19929d2655c7b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、新しいFFIの詳細と機能について説明する前に、Javaでネイティブコードを使用する際の問題について説明します。失敗します。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaとネイティブコード間の相互作用</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/77d/ca5/229/77dca5229e23a95d4c6e84675378dda2.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブコードには、独自のメモリ領域とそのデータ構造があります。 JavaコードはJavaヒープで動作します。 Javaとネイティブコードを相互作用させるには、ある領域から別の領域を参照する方法を見つける必要があります。それら。ネイティブコードはJavaヒープを処理でき、Javaコードはネイティブヒープを処理できる必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0a5/e0d/be6/0a5e0dbe6b995632064edf3023dab9fd.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのような問題が発生する可能性がありますか？ネイティブコードでは、ポインターはそれ自体で「安定」しており、それらを使用するコードの知識がなければ、ポインターは変更されません。また、Javaヒープはガベージコレクター（GC）によって制御されます。オブジェクトは魔法で移動できます。つまり、メモリを解放するプロセスでは、ガベージコレクターはメモリ内のオブジェクトを移動する権利を持ち、そのオブジェクトへのすべてのポインターを正しく更新する必要があります。設計上、このような操作はJavaコードに対して完全に透過的であり、Javaコードによってまったく制御されません。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a0/80b/6a5/7a080b6a57b4c42169c4ec8cd81e6cec.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaヒープ外のメモリの場合、データ構造が移動しないため、更新は必要ありません。また、外部からJavaヒープへのリンクがある場合は、そのような変更を考慮して処理する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの解決策は、Javaヒープ内のオブジェクトの位置を修正すること（オブジェクトの固定）ですが、これはGCの実装に深刻な制限を課し、パフォーマンスの点で、多くの不愉快な結果をもたらします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（JNIで使用される）代替アプローチは、GCが認識している安定したポインター（ハンドル）のテーブルを介してJavaオブジェクトを操作することです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/16b/a78/86e/16ba7886eeb48f2babb3a0c0120f88f8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトが移動されると、ガベージコレクターは対応するテーブルスロットを更新し、ネイティブコードは新しいアドレスでの作業を開始します。</font><font style="vertical-align: inherit;">ただし、これにはネイティブコード側で特定の変更が必要です。その知識がなければ、間接レベルをさらに追加することはできず、GCとの調整が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、データレベルでのネイティブコードとJavaコードの相互作用の設計は次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/169/5b8/21b/1695b821be082933936a1a037ffcbae3.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jni</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JNIは、バージョン1.1以降、ほぼ即座に登場しました（技術的には、APIは1.0に存在しましたが、標準の一部ではありませんでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者の観点から、JNIとの対話は次のとおりです：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f38/6ee/d42/f386eed42693ca6043a9b03196cac406.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaコードでは、メソッドは特別な方法で宣言されています（キーワード「ネイティブ」） javac（javaコンパイラ）は、クラスファイルとヘッダーファイルを作成します。ヘッダーに基づいて、開発者は手動でネイティブ関数の実装を記述し、C / C ++コンパイラを使用してコンパイルし、完成したライブラリを出力として受け取ります。したがって、クラスファイルとライブラリを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、引数を取らず、現在のプロセスのIDを返すネイティブ関数getpidの簡単な例を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c04/e1d/b18/c04e1db189d0252f6201ffd830b3fd8c.png"><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LibC</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getpid</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
</code></pre><br>
<pre><code class="plaintext hljs">jlong JNICALL Java_LibC_getpid(JNIEnv* env, jclass c) {<font></font>
        return getpid();<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの悪い事はJNIについて言っているが、それにもかかわらず、それが相互作用のためのプリミティブの豊富なセットを提供し、非常に強力なAPIであることが判明した。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば、Javaのメソッドを呼び出します：</font></font><br>
<br>
<pre><code class="plaintext hljs">jlong JNICALL Java_... (JNIEnv* env,<font></font>
                        jclass cls,<font></font>
                        jobject obj) {<font></font>
        jmethodID mid = env-&gt;GetMethodID(cls, "m", "(I)J");<font></font>
        jlong result = env-&gt;CallLongMethod(obj, mid, 10);<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、Javaオブジェクトのフィールドアクセス：</font></font><br>
<br>
<pre><code class="plaintext hljs">jlong JNICALL Java_...(JNIEnv* env,<font></font>
                       jclass cls,<font></font>
                       jobject obj) {<font></font>
        jfieldID fid = env-&gt;GetFieldID(cls, "f", "J");<font></font>
        jlong result = env-&gt;GetLongField(obj, fid);<font></font>
        jlong result = env-&gt;SetLongField(obj, fid, 10);<font></font>
</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNIを介した実装の詳細の呼び出し</font></font></h4><br>
<img src="https://habrastorage.org/getpro/habr/post_images/c76/0b8/37a/c760b837a1c97e14f76ba63328a78652.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の観点からは、仮想マシンがJavaコードの呼び出し、完全に制御する実行、および一般的なケースでは制御できないネイティブコードの呼び出し（厳密に定義された場所を除いて）を区別すると便利です。 JVMの場合、ネイティブコードの呼び出しはブラックボックスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンを安定して動作させるには、いつでもアプリケーションをすばやく停止できる必要があります。この目的のために、生成されたコードのJVMは、実行を安全に停止できる場所（いわゆるセーフポイント）を選択してマークします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaコードでは、仮想マシンはこれらのポイントを必要に応じて設定できます。 JVMにはネイティブコードを変更する機能がないため、JVMが呼び出されると、スレッドは自動的に（呼び出し全体で）安全なポイントに移動します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ac2/24a/b84/ac224ab846d25b661dea4575df911ee6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安全なポイントを開始することにより、仮想マシンはJavaコードを実行するすべてのスレッドが停止するのを待ちますが、これはネイティブコードを実行するスレッドには適用されません。</font><font style="vertical-align: inherit;">ネイティブコードは、ガベージコレクターと並行して実行し続けることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約する：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに、JNIを呼び出すこともできますが、シームレスではありませんが、Javaとの統合は良好です。</font><font style="vertical-align: inherit;">このAPIは、ネイティブコードではなくJavaに焦点を当てています。</font><font style="vertical-align: inherit;">それを介して、Javaアプリケーションの大量の詳細にアクセスできます。</font></font><br>
</li>
</ul><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイナス：使用の不便。</font><font style="vertical-align: inherit;">「ラッパー」を手動で記述し、呼び出しの追加コストを考慮する必要があります。</font><font style="vertical-align: inherit;">JNI呼び出しとしてJavaヒープ外のデータへのアクセスを想像することは可能ですが、これはコストがかかりすぎます。</font><font style="vertical-align: inherit;">（これがsun.misc.Unsafeの人気の主な理由です。）</font></font><br>
</li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要なjni</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに、HotSpotでのJNI実装は拡張されました。たとえば、クリティカルJNIが登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例を見てみましょう：</font></font><br>
<br>
<pre><code class="plaintext hljs">jint JNICALL Java_…(JNIEnv *env, jclass c, jobject arr) {<font></font>
    jint len = (*env)-&gt;GetArrayLength(end, arr);<font></font>
    jbyte* a = (*env)-&gt;GetPrimitiveArrayCritical(env, arr, 0);<font></font>
    …<font></font>
    return sum;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaヒープからの配列への参照がパラメーターとして渡されるメソッドがあるとします。 JNIを通じて、この配列のコンテンツにアクセスしたいと考えています。最初にその長さを確認する必要があります。次にポインタを先頭に移動し、その後で初めてデータの操作を開始できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな配列の場合、JNIEnvを介したこれらの2つの呼び出しにより、オーバーヘッドが圧倒的に増加します。JNを介して空のメソッドを呼び出す場合と比較すると、オーバーヘッドが桁違いに増加します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/cd6/15f/ece/cd615feceb48d53aec5490e4c4eda4c1.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ネイティブコンテキストであるため、JNIEnvを介した各呼び出しで、JVMの現在の状態をチェックする必要がある（セーフポイントチェック）ためです。それ以外の場合、たとえば、ガベージコレクターが配列をどこかに移動していることが判明する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なJNIは、プリミティブ配列に関するこの問題を解決します。呼び出し中に、JVMは必要なすべての情報（長さ+ポインター）を取得し、それらを引数として明示的に渡します。</font></font><br>
<br>
<pre><code class="plaintext hljs">jint JNICALL JavaCritical_…(jint length, jbyte* first) {<font></font>
    …<font></font>
    return sum;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大幅な節約が可能です。</font><font style="vertical-align: inherit;">大量のデータでは、通常、作業量が呼び出しのオーバーヘッドを支配するため、小さな配列で最も顕著です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/bdb/9ba/dcbbdb9ba023c3c4c313147b1bd99fa5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なJNIにはいくつかの制限があります。</font><font style="vertical-align: inherit;">これは、JNI自体の一般的な問題を解決しない小さなアドイン（パブリックAPIの一部ではありません）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、JNIはJava中心のインターフェースです。</font><font style="vertical-align: inherit;">どのようにしてネイティブコードを呼び出しますか？どの呼び出しがJavaとは非常に異なりますか？</font><font style="vertical-align: inherit;">たとえば、printf：</font></font><br>
<br>
<pre><code class="plaintext hljs">int printf(const char *format, …)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaコードの側面では、vararg引数をObject []として提示できますが、すべての引数を手動で取得し、必要に応じて解凍し、システムABIに従ってスタックに配置し、その後ネイティブ関数を呼び出す必要があります。</font><font style="vertical-align: inherit;">printf用のJNIラッパーを手動で作成することは簡単ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の質問：ネイティブコードからJavaへの呼び出しをどうするか？</font><font style="vertical-align: inherit;">典型的な例はqsortです：</font></font><br>
<br>
<pre><code class="plaintext hljs">void qsort(<font></font>
    void* base,<font></font>
    size_t nel,<font></font>
    size_t width,<font></font>
    int (*cmp)(const void*, const void*));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
qsortは、要素を比較するときに使用される関数へのポインターを引数として受け取ります。</font><font style="vertical-align: inherit;">ネイティブコードはポインター呼び出しを行い、必要な引数を渡します。最後にJavaコードを実行します。</font><font style="vertical-align: inherit;">JNIを使​​用してそれを行う方法？</font><font style="vertical-align: inherit;">間違いなく重要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNRライブラリ（Java Native Runtime）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
国鉄はいくつかの問題を解決します。 JNIは、実際には仮想マシンによって提供されるツールに限定されていました。手動で行う必要のある他のすべて。 JNRは、すべての対話をJavaコードのレベルにまで引き上げます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LibC</span> </span>{
    <span class="hljs-meta">@pid_t</span> <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getpid</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<font></font>
LibC lib = LibraryLoader<font></font>
        .create(LibC.class)<font></font>
        .load("c");<font></font>
<font></font>
libc.getpid()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">getpidのユーザーは、ネイティブコードを作成する必要がなくなりました。彼はインターフェイスをスケッチし、注釈を追加しました。ライブラリはすべての作業を行います。</font><font style="vertical-align: inherit;">そして、それはかなりうまくいきます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dff/ecb/a4e/dffecba4e73e75a0b8a345ae063dacfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のとおり、JRubyはJNRを使用してプラットフォームライブラリとやり取りします。</font><font style="vertical-align: inherit;">JNRの利点は、ネイティブメソッドの自動バインディングです。</font><font style="vertical-align: inherit;">ユーザーはネイティブコードを記述する必要はありません。</font><font style="vertical-align: inherit;">彼のためのすべての「汚い」仕事は図書館によって行われます。</font><font style="vertical-align: inherit;">欠点としては、手動でインターフェースを作成する段階だけを挙げます。</font><font style="vertical-align: inherit;">うまくスケーリングしません。</font><font style="vertical-align: inherit;">実際には、ライブラリにはかなり広範なインターフェースがあり、そのJavaへの変換にはかなりの量が必要です。</font><font style="vertical-align: inherit;">さらに、JNRはJNIに基づいたライブラリです。</font><font style="vertical-align: inherit;">Charles Nutterが言ったように、私たちはJNIよりも速くなることはできません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次はどこへ？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいプロジェクトでJNIよりも速くできますか？</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/810/27f/867/81027f8679026c1499c27b92ed330d78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のライブラリ用のインターフェースを書くのは非常に時間がかかると私は上で述べました。また、新しいバージョンへの移行は、インターフェイスを最初から作成するのに比べて、さらに時間がかかります。例として、人気のあるTensorFlowライブラリを</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e4/6cd/b96/3e46cdb9629888824c35a8107a837b33.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討してください。事実上の標準と見なされて</font><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">Cインターフェースが関連しています。 TensorFlowにはJavaインターフェースもありますが、機能が制限されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数字で言うと、Cインターフェースは約250のエンティティであり、作成するだけでなく、注釈で「ラップ」する必要があります。何か間違ったことをすると、実行プロセス中に診断が困難なエラー（クラッシュ）が発生するか、さらに悪いことに、誤った結果が発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a84/b67/3fb/a84b673fbf837590bfaeac71f4398cde.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいバージョンに移行する場合、ライブラリインターフェースのすべての変更を追跡し、Javaインターフェースを適合させる必要があります。</font><font style="vertical-align: inherit;">TensorFlowが提供する限られた量のJava APIでさえ、すでに1万行を超えるネイティブコードとJavaコードです。</font><font style="vertical-align: inherit;">したがって、ライブラリを操作するための高レベルのメカニズムは、実用的な意味があります。</font><font style="vertical-align: inherit;">したがって、開発者向けのプラットフォームライブラリを使用して作業を簡略化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JNIがすべてのケースで私たちを悩ませているわけではありません。</font><font style="vertical-align: inherit;">ほとんどのシナリオでは、多くの場合十分に高速です。</font><font style="vertical-align: inherit;">しかし、インターフェースを手動で記述することは非常に時間がかかります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの最初のフェーズ（2015-2018）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFIに関する作業は2014年末に始まり、2015年に積極的に展開されました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/38f/80f/58a/38f80f58aa4e995e35d2b5d13021da17.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業の結果、ライブラリヘッダーファイルに基づいて必要なすべてのインターフェースを自動的に作成する新しいjextractツールが登場しました。それら。開発中、ヘッダーファイルを取得し、そこからインターフェイスを抽出し、これらのインターフェイスを使用して独自のJavaアプリケーションを作成し、コンパイルして実行します。そして、インターフェイスとネイティブライブラリの対応する部分とのすべてのバインディングは、実行中に「オンザフライ」で行われます。 jextractによって収集されたメタ情報に基づいて、必要な実装が作成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/cd0/13e/763/cd013e76336f1ed8eb86da60c740b103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをネイティブコードの「hello world」のアナログとしてgetpidを使用して検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
unistd.hの場合、jextractはunistd Javaインターフェース（.h-&gt; .class）を作成します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d40/66c/413/d4066c4136354bc9772aa5d778ccdaff.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注釈には必要な情報がすべて含まれているため、実行プロセス中に目的のネイティブ関数を見つけて呼び出し、返された結果を処理できます。すべてが自動的に行われます：jextractはインターフェースを生成し、実行時にインターフェースが実装されます。開発者は何もする必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは次のように使用できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Load native library</span>
Library lib = NativeLibrary.load(<span class="hljs-string">"c"</span>);<font></font>
<font></font>
<span class="hljs-comment">// Weave a class for the unistd interface,</span>
<span class="hljs-comment">// and return an instance</span><font></font>
unistd unistd = NativeLibrary.create(lib, unistd.class)<font></font>
<font></font>
// <span class="hljs-function">Call the system <span class="hljs-title">getpid</span><span class="hljs-params">()</span> function
<span class="hljs-keyword">int</span> pid </span>= unistd.getpid();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリをロードし、それに基づいて以前に作成されたインターフェースの実装を取得します。 unistdは、jextractがunistd.hから「抽出」したインターフェースです。その結果、unistd.hで宣言された関数を呼び出すことができるオブジェクトが取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブライブラリにはコードが含まれていますが、実際には、コードとのやり取りにはデータ転送が含まれます。したがって、データを操作するための新しいAPIがjextractとともに追加されました。 「型付き」ポインタであるPointerクラスも表示されました。アドレスと格納された値の型です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pointerクラスは、キャスト（別のタイプへのキャスト）、オフセット（定数へのポインターのオフセット）、取得/設定（アドレスへの読み取り/書き込み）の基本的な操作のセットを提供します。実際、Cの観点からポインタを得ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、APIには、ポインターに加えて、固定長配列を表す特別なArrayクラスが含まれています。基本的に、Cでは、配列は通常のポインターの上にある単なる構文上の砂糖です。しかし、微妙な違いがいくつかあり、それが新しいエンティティの出現の動機となりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースを管理するために、いくつかのコンテキストを表すScopeクラスが登場しました。コンテキストが閉じられるとリソースが解放され（Scope.close（））、try-with-resourcesを使用すると、字句コンテキストでリソースを簡単に操作できます。コンテキストを終了すると、このコンテキストで使用されているすべてのリソースが自動的に解放されます。さらに、各ポインターはいくつかのスコープに「バインド」されています。アクセスごとに、ポインターは対応するスコープが閉じているかどうかを確認します。そうでない場合、例外がスローされ、アクセスエラーが通知されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@NativeHeader(declarations=
    "strlen=(u64:u8)i32")</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strings</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(Pointer&lt;Byte&gt; buf)</span></span>;<font></font>
}<font></font>
…<font></font>
<span class="hljs-keyword">var</span> lib = Libraries.bind(MethodHandles.lookup(),<font></font>
                     Strings.class);<font></font>
<span class="hljs-keyword">try</span> (<span class="hljs-keyword">var</span> scope = Scope.newNativeScope()) {
    <span class="hljs-keyword">var</span> strPtr = scope.allocateCString("Hello");<font></font>
    lib.strlen(strPtr);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、Java文字列をネイティブコードに渡します。</font><font style="vertical-align: inherit;">Javaとネイティブコードでは文字列の表現が異なるため、変換が必要であり、スコープがこの機能を提供します（allocateCString（））。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプローチの見直し</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2018年までに、プロジェクトはかなり安定した状態になりました。多くの一般的なライブラリがテストされ、新しいツールが問題なく動作しました。すべてが完璧だったわけではないことは明らかですが、それは活発な実験の期間でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この文脈では、結果は非常に良好でした。使いやすさの点では、これはJNIを大幅に改善し、JNRを大幅に改善しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、プロジェクトをピラミッドとして見ると、結果はモノリシックになります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本コンポーネントと補助コンポーネントに明確に分かれていませんでした。たとえば、サードパーティのライブラリで（たとえば、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">JavaCPPで</font></a><font style="vertical-align: inherit;"> C ++をサポートするために）使用できる新しい低レベルのプラットフォームAPIはありません</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でした。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
jextractとPointer APIを除くすべてが実装の詳細でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、以降の手順に深刻な制限が課せられました。JDKへの統合の問題を提起すると、「すべてまたは何もない」ということになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスカッションでのジョンローズ（JVMアーキテクト）は、「明確なピラミッドを構築せずに、ランダムな順序ですべてを一度に取得しようとした」と説明しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、さらなる開発を構築する時が来ました。</font><font style="vertical-align: inherit;">その結果、分離が発生しました。jextractは、2つの低レベルプラットフォームAPIに基づく独立した高レベルツールとして具体化しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリを操作するためのメモリアクセスAPI。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブコード呼び出し用の外部ABI API。</font></font><br>
</li>
</ul><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a6b/ed8/2f7/a6bed82f7cbdf20f6a54e48dffa0f9c2.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者の観点から見ると、jextractの使用例は同じです</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。jextractはヘッダーファイルに基づいてJavaインターフェースを作成し、開発者はそれをプログラムの一部としてすでにコンパイルしています。</font></font><br>
 <br>
<img src="https://habrastorage.org/getpro/habr/post_images/ec3/470/37a/ec347037a6bf92c6cd2110679deffc05.png"><br>
<br>
<pre><code class="plaintext hljs">$ jextract … --source unistd.h<font></font>
$ javac … unistd_h.java Getpid.java<font></font>
$ cat Getpid.java<font></font>
… unistd_h.getpid() ...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、新しい実装では、jextractはインターフェースだけでなく、完全な実装を持つインターフェースも生成します。</font><font style="vertical-align: inherit;">unistd_h.javaを見ると、以前のように注釈のあるインターフェイスだけでなく、実行段階で以前に生成されたものと同じように実行および実行される実際のコードが表示されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">pid_t <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unistd_h</span> </span>{<font></font>
[...]<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodHandle getpid = RuntimeHelper.downcallHandle(<font></font>
        LIBRARIES, <span class="hljs-string">"getpid"</span>,
        <span class="hljs-string">"()I"</span>,<font></font>
        FunctionDescriptor.of(C_UINT),<font></font>
        <span class="hljs-keyword">false</span>);<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getpid</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)getpid.invokeExtract();<font></font>
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(ex);<font></font>
        }<font></font>
    }<font></font>
[...]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装がgetpidを呼び出す方法を検討してください。</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムabi</font></font></b> <br>
<br>
<pre><code class="java hljs">abi = SystemABI.getInstance();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MethodHandleを作成するために使用されるSystem ABIインターフェースがあり、これを使用してネイティブコードと対話できます。</font></font><br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリアドレス</font></font></b><br>
<br>
<pre><code class="java hljs">entry = LibraryLookup.ofDefault().lookup(<span class="hljs-string">"getpid"</span>);
</code></pre><br>
     LibraryLookup    entry point  ,      entry point.<br>
</li>
<li><b>MethodType</b><br>
<br>
<pre><code class="java hljs">type = MethodType.methodType(<span class="hljs-keyword">int</span>.class);
</code></pre><br>
  MethodHandle  native-,   ,       Java-.     MethodType.  MethodHandle   ,   ,      Java   .<br>
</li>
<li><b>FunctionDescriptor</b><br>
<br>
<pre><code class="java hljs">desc = FunctionDescriptor.of(MemoryLayouts.C_INT);
</code></pre><br>
   native-,    .       FunctionDescriptor.   getpid      ,     C     .<br>
</li>
<li><b>MethodHandle</b><br>
<br>
<pre><code class="java hljs">getpid = abi.downcallHandle(entry, type, desc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Javaタイプ（MethodType）、ネイティブタイプ（FunctionDescriptor）、およびネイティブ関数のアドレス（MemoryAddress）に基づいて、SystemABI.downcallHandle（）は、対応するネイティブ関数への呼び出しを実装するMethodHandleオブジェクトを構築できます。</font></font><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブメソッドハンドル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装は新しいMethodHandleタイプ（NativeMethodHandle）に基づいており、既存のjava.lang.invoke APIを拡張します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/00d/f30/ad8/00df30ad8d7e635d9301be0e22938b62.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMからのネイティブ呼び出し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」、John Rose</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Java 7では、invokedynamicという新しい命令がJVMバイトコードに追加され、Javaコードレベルでメソッドを操作するための新しいjava.lang.invoke APIが追加されました。</font><font style="vertical-align: inherit;">java.lang.invoke実装の観点から見ると、ネイティブコードとの対話はJavaコードとの対話とそれほど変わりません。</font><font style="vertical-align: inherit;">ネイティブ関数のサポートを追加するのは簡単です。</font></font><br>
<br>
<pre><code class="plaintext hljs">// int pid = mh.invokeExact();<font></font>
$ java … -XX:+PrintInlining ...<font></font>
...<font></font>
@ 8 LambdaForm$MH::invokeExact_MT (29 bytes) force inline by annotation<font></font>
    @ 11 Invokers::checkExactType (17 bytes) force inline by annotation<font></font>
        @ 1 MethodHandle::type (5 bytes) accessor<font></font>
    @ 15 Invokers::checkCustomized (23 bytes) force inline by annotation<font></font>
        @ 1 MethodHandleImpl::isCompileConstant (2 bytes) (intrinsic)<font></font>
    @ 25 LambdaForm$NMH::invokeNative_I (27 bytes) force inline by …<font></font>
        @ 7 NativeMethodHandle::internalNativeEntryPoint (8 bytes) force inline …<font></font>
        @ 23 MethodHandle::linkToNative(L)I (0 bytes) direct native call<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVMとJavaコード間のインターフェースはMethodHandle.linkToNativeです。これは、関数の引数とともに、呼び出されたネイティブ関数（ネイティブエントリポイント）のアドレスも与えられる特別なアダプターメソッドです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをパフォーマンスの観点から見てみましょう。 JVM JITコンパイラーによって生成されたマシンコードでは、MethodHandleを介した呼び出しが直接呼び出しに最適化されています。</font></font><br>
<br>
<pre><code class="plaintext hljs">callq 0x1057b2eb0; native method entry</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、Charles Nutterが要求したものを取得しました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/99b/b60/8c8/99bb608c8bce1efa3bce6a4c3fd29a10.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JNIを介してgetpid呼び出しに12〜13 nsを費やした場合、JITコンパイラからの適切なサポートにより、このlinkToNative呼び出しを直接のエントリポイント呼び出しに変えることができます。明らかに、それは安全ではありません。ただし、ネイティブコードを呼び出すときにJVMが実行する手順についてはすでに説明しました。ストリームは特別な状態にあり、仮想マシンの観点からは、安全なポイントに切り替えるときに停止しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これを直接呼び出すと、作業は発生しません。したがって、JVMはスレッドがJavaコードを実行していると見なし、スレッドが停止するのを待ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化は、getpidのような単純なケースで機能します。</font><font style="vertical-align: inherit;">しかし、より複雑な状況では、問題が発生する可能性があります。</font><font style="vertical-align: inherit;">たとえば、ネイティブコード内にブロッキング呼び出しがある場合、JVMは単に「ハング」する可能性があります。</font><font style="vertical-align: inherit;">無期限にブロックされているスレッドが停止するのを待ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ブロッキングが問題の唯一の原因ではありません。低レイテンシのGCガベージコレクターの分野では、最低限保証されているJVMの一時停止が大幅に削減されています。</font><font style="vertical-align: inherit;">この作業は、GCだけでなくJVM全体にも関係していたため、数十ミリ秒程度の一時停止を保証し、1ミリ秒未満の間隔について話すことができます。</font><font style="vertical-align: inherit;">この間、JVMは安全な状態を実現するだけでなく、一時停止の保証に違反しないように必要なすべての作業を実行する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルアダプター</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linkToNativeアダプターメソッドを使用したアプローチを検討しました。しかし並行して、代替メカニズムが開発されました-いわゆるユニバーサルアダプター。これは完全にプログラム可能なAPIであり、任意のネイティブコールを記述できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のJavaメソッドの場合、シグネチャは固定されています。メソッド宣言の場所には、受け入れる引数のタイプと返される結果のタイプが明確に記述されています。 java.lang.invokeおよびMethodHandle APIのニーズに対しては、これでは不十分です。単一のインターフェースを介して任意のメソッドを呼び出すことができる必要があります。これは通常のJavaコードでは実行できないため、言語とプラットフォームの仕様に、いわゆる署名多態メソッドが追加されています。これには、任意の署名（使用場所で決定される）を含めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linkToNativeの問題は、これもシグネチャポリモーフィックであり、その動作がJavaシグネチャによって記述されることです。可変数の引数（varargs）を持つネイティブ関数を記述したいとします。パラメータがスタックにどのように配置されているかを正確に説明する必要があります。これは、Javaシグネチャの観点から理論的には可能ですが、非常に不便です。言い換えると、Javaシグネチャは、Javaメソッドの呼び出しを記述するのに適しています。また、可変引数については、C（またはABIプラットフォーム）の観点から説明する方が適切です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Universal Adapter APIはこの問題を解決します。これは、呼び出しの前後のスタックとレジスタの状態を記述するための低レベルのメカニズムです。実際、ユニバーサルアダプターは、レジスターの完全な状態とスタックの最上位を引数として取り、呼び出しから戻った後、結果を処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Universal Adapterは非常に強力なメカニズムですが、JITコンパイラによる最適化にはあまり適していません。</font><font style="vertical-align: inherit;">JITコンパイラは、最適なコードを見つけるために、呼び出しに関する多くの低レベルの詳細を必要とします。</font><font style="vertical-align: inherit;">したがって、パフォーマンスの点では、ユニバーサルアダプターはJNIよりも桁違いに遅いものでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外国のABI：低レベルAPIを探しています</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/2ff/7e9/29e/2ff7e929e7b7e3aa8f018c44a2d37d8f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されている2つのアプローチ（linkToNativeおよびUniversal Adapter）は競合しませんが、互いに補完します。理想的には、常に最大のパフォーマンスを発揮したいと思います。ただし、実用的な観点から見ると、任意のコードを呼び出すことができるため、いくつかの一般的なケースの最適化に集中することをお勧めします。たとえば、JITコンパイラで最も頻繁に使用されるケースの90％を最適化し、残りの10％が正しく機能するように、より単純な代替メカニズムを使用しますが、呼び出し速度を犠牲にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、linkToNativeとUniversal Adapterを統合する方法はありません。</font><font style="vertical-align: inherit;">2つの完全に異なるAPIを提供します。</font><font style="vertical-align: inherit;">特定のMethodHandleでの作業中に使用するインターフェースを選択することはできません。</font><font style="vertical-align: inherit;">これは、MethodHandleの作成時に指定する必要があります。</font><font style="vertical-align: inherit;">したがって、プロジェクトで進行中の作業は、2つのメカニズム間のインターフェースを統合することを目的としています。</font><font style="vertical-align: inherit;">目標は、JITコンパイル時に特定の呼び出し実装メカニズムを選択できるようにすることです。呼び出しを最適化することは可能ですか、それともユニバーサルアダプターを使用する方が賢明ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ネイティブコードからJavaコードへの呼び出し（upcall）について説明しますが、ここでは、Memory Access APIに切り替えましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリアクセスAPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memory Access APIは、低レベルで安全かつ同時にメモリにアクセスするための効率的なAPI（Javaヒープ内とその外部の両方）です。</font><font style="vertical-align: inherit;">これは、ポインターAPIをデータと対話するためのインターフェースとして置き換え、C言語のセマンティクスに関連付けられなくなりました</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。APIは、4つの主要な抽象化を提供します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemorySegment：メモリの領域を説明します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryAddress：MemorySegmentのアドレス。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryLayout：メモリ内のデータ構造のレイアウトの説明。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryHandles：MemoryAddressを介してデータにアクセスするためのVarHandleのファクトリ。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいAPIの主要な機能は、その使用のセキュリティです。 sun.misc.Unsafeとは異なり、新しいAPIは、JVM全体の停止につながる重大なエラーを許可するべきではありません。代わりに、誤用の場合、エラーはアプリケーションレベルにとどまるか、例外的な状況（インターセプトと処理の可能性がある）につながる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、適切な同期を行わずに多くのストリームからデータにアクセスすると、アプリケーションロジックのレベルで正確にエラーが発生する可能性があります（意味的に正しくない値を読み取る場合、またはデータが誤って解釈される場合）。ランタイムの観点から見ると、これによりJavaプロセス全体が停止します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行中、Memory Access APIは2つの重要な保証を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、リソースの寿命を制御します。アクセスされているメモリが引き続き利用できることが保証されます。対応するMemorySegmentオブジェクトを閉じた後、メモリを解放できますが、それにアクセスしようとすると、例外的な状況が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アクセス制限が各呼び出しに対してチェックされます。セグメントの境界外にアクセスしようとした場合も例外が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例を見てみましょう（コメントでは、同等のCコードが示されています）。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// struct { int x; int y; } points[5];</span>
<span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { points[i].x = i; }</span><font></font>
<font></font>
VarHandle intHandle = MemoryHandles.varHandle(<span class="hljs-keyword">int</span>.class, ByteOrder.nativeOrder());<font></font>
VarHandle xHandle = MemoryHandles.withStride(intHandle, <span class="hljs-number">8</span>);<font></font>
<font></font>
<span class="hljs-keyword">try</span> (MemorySegment points = MemorySegment.allocateNative(<span class="hljs-number">4</span> * <span class="hljs-number">2</span> * <span class="hljs-number">5</span>)) {<font></font>
          MemoryAddress base = points.baseAddress();<font></font>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i++) {<font></font>
                    xHandle.set(base, i, (<span class="hljs-keyword">int</span>)i); <span class="hljs-comment">// safety checks</span><font></font>
          }<font></font>
} <span class="hljs-comment">// points.close() frees memory</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、5つの要素の配列を宣言しています。各要素は、int型（2つの座標）の2つの要素の構造です。次に、配列の要素を並べ替えると、特定の値がx座標に書き込まれます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/085/d05/6d4/085d056d4733665b3c25a194f59ccbd9.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memory Access APIに基づいて同等のコードを作成するには、まず、配列のi番目の要素にあるxコンポーネントにアクセスするVarHandleを作成します。将来的には、このVarHandleを再利用するだけです。入力では、配列内の要素のインデックスを受け取り、別の引数で渡された値をそれに書き込みます。</font></font><br>
<br>
<pre><code class="java hljs">VarHandle intHandle = MemoryHandles.varHandle(<span class="hljs-keyword">int</span>.class, ByteOrder.nativeOrder());<font></font>
VarHandle xHandle = MemoryHandles.withStride(intHandle, <span class="hljs-number">8</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VarHandleはJava 9で追加され、MethodHandleと非常によく似ています。 VarHandleを同等のMethodHandleに変換することも可能です。ただし、MethodHandleと比較すると、VarHandle APIはレベルよりもわずかに高く、4種類のメモリアクセスを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、配列要素へのインデックス付きアクセスを実装するVarHandleオブジェクトがあります。 MemoryAddressのコンビネータに基づいて、かなり複雑なオフセット計算を構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
終了すると、メモリはtry-with-resourcesによって解放されます。</font><font style="vertical-align: inherit;">作成されたMemorySegmentが何らかの形でレキシカルコンテキストを離れた場合でも、終了すると暗黙的に閉じられます。</font><font style="vertical-align: inherit;">以降のアクセス試行は例外になります。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">解放後のリソースへのアクセスの問題（解放後の使用）は、実行中に追加のチェックを行うことで解決されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリレイアウト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memory Access APIは、メモリ内のデータ構造のレイアウトを宣言的に説明する機能を提供します。</font><font style="vertical-align: inherit;">これに先立ち、例で見たように、jextractは特別な注釈を追加しました。その中には、特別な言語（LDL = Layout Definition Language）を使用してレイアウトがエンコードされています。</font><font style="vertical-align: inherit;">LDLはオンラインで構築されており、記述は十分にコンパクトでしたが、書き込みとその後の読み取りには十分に不便でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LDLは、同等の機能を持つMemoryLayoutに置き換えられました。</font></font><br>
<br>
<pre><code class="plaintext hljs">struct Point {<font></font>
          int x;<font></font>
          int y;<font></font>
} pts[5];<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今 </font></font><br>
<br>
<pre><code class="java hljs">MemoryLayout.ofSequence(<span class="hljs-number">5</span>,<font></font>
          MemoryLayout.ofStruct(<font></font>
                    MemoryLayout.ofValueBits(<span class="hljs-number">32</span>)<font></font>
                              .withName(<span class="hljs-string">"x"</span>),<font></font>
                    MemoryLayout.ofValueBits(<span class="hljs-number">32</span>)<font></font>
                              .withName(<span class="hljs-string">"y"</span>)<font></font>
          )<font></font>
);<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造（2つの要素のグループで、それぞれサイズが32ビット）は、MemoryLayout.ofStructを使用して記述されます。</font><font style="vertical-align: inherit;">便宜上、構造要素に名前を付けることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、次の説明に基づいてVarHandleを簡単に作成できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// struct { int x; int y; } points[5];</span>
SequenceLayout seq = MemoryLayout.ofSequence(<span class="hljs-number">5</span>,<font></font>
          MemoryLayout.ofStruct(<font></font>
                    MemoryLayout.ofValueBits(<span class="hljs-number">32</span>, ByteOrder.nativeOrder()).withName(<span class="hljs-string">"x"</span>),<font></font>
                    MemoryLayout.ofValueBits(<span class="hljs-number">32</span>, ByteOrder.nativeOrder()).withName(<span class="hljs-string">"y"</span>)));<font></font>
<font></font>
<span class="hljs-comment">// i -&gt; points[i].x</span>
VarHandle seqXHandle = seq.varHandle(<span class="hljs-keyword">int</span>.class,<font></font>
                              MemoryLayout.PathElement.sequenceElement(),<font></font>
                              MemoryLayout.PathElement.groupElement("x"));<font></font>
<font></font>
// <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) { points[i].x = i; }
<span class="hljs-keyword">try</span> (MemorySegment points = MemorySegment.allocateNative(seq)) {<font></font>
          MemoryAddress base = points.baseAddress();<font></font>
          <span class="hljs-keyword">long</span> size = seq.elementCount().getAsLong();
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                    seqXHandle.set(base, i, (<span class="hljs-keyword">int</span>) i);<font></font>
          }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前付きフィールドを持つこのレイアウトに基づいて、はるかに視覚的な方法で同じVarHandleを取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、Memory Access APIは、バージョン14以降、インキュベータモジュールとしてJDKですでに利用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaのネイティブコードからの呼び出し（Upcall）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前、Javaのネイティブコードを操作するためのスクリプトを調べました。</font><font style="vertical-align: inherit;">ただし、ライブラリが関数ポインタをパラメータ（コールバック）として期待することがあり、Javaコードを呼び出す必要があります。</font><font style="vertical-align: inherit;">FFIのコンテキストでは、これはアップコールと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アップコール用の「Hello world」はqsortです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// void qsort(void* base, size_t nel, size_t width,</span>
<span class="hljs-comment">//     int (*compar)(const void*, const void*));</span>
<span class="hljs-comment">// public interface stdlib_h.qsort$__compar {</span>
<span class="hljs-comment">//     int apply(MemoryAddress x0, MemoryAddress x1);</span>
<span class="hljs-comment">// }</span><font></font>
<font></font>
stdlib_h.qsort$__compar comparator =<font></font>
(addr1, addr2) -&gt; {<font></font>
<span class="hljs-keyword">int</span> e1 = (<span class="hljs-keyword">int</span>)INT_VH.get(addr1.rebase(segment));
<span class="hljs-keyword">int</span> e2 = (<span class="hljs-keyword">int</span>)INT_VH.get(addr2.rebase(segment));
<span class="hljs-keyword">return</span> e1 - e2; };<font></font>
<font></font>
MemoryAddress comparatorAddr = stdlib_h.qsort$__compar$make(comparator);<font></font>
<font></font>
stdlib_h.qsort(arrayBase,<font></font>
elementCount,<font></font>
elementSize,<font></font>
comparatorAddr);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、比較ごとに、値を比較するための特別な関数が呼び出され、C APIで関数へのポインターとして渡されます。しかし、qsortのインターフェースを構築するために、Java言語の観点から操作したいと考えています。この場合、jextractは自動的に機能インターフェースを作成します（stdlib_h.qsort $ __比較）。明示的に実装できますが、例ではラムダ式を使用しています。 2つのMemoryAddressが入力に転送され、その値を読み取り、比較して結果を返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、単に値の違いを返します。</font><font style="vertical-align: inherit;">このインターフェースを実装するオブジェクトがあります。</font><font style="vertical-align: inherit;">しかし、結果をネイティブコードに直接渡すことはできません。</font><font style="vertical-align: inherit;">ネイティブコードはポインタを期待します。この場合、それはJavaインターフェースを介した仮想呼び出しです。</font><font style="vertical-align: inherit;">ネイティブコードが呼び出しを実行できるように、オブジェクトを何らかの方法でアドレスに変換する必要があります。</font><font style="vertical-align: inherit;">この場合もjextractが役立ちます。</font><font style="vertical-align: inherit;">彼は、呼び出しに使用できるアドレスを返す特別なメソッドを追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外国のABIの観点から見た場合：</font></font><br>
<br>
<pre><code class="java hljs">MethodHandle qsort = abi.downcallHandle(lookup.lookup(<span class="hljs-string">"qsort"</span>),<font></font>
          MethodType.methodType(<span class="hljs-keyword">void</span>.class, MemoryAddress.class,
                    <span class="hljs-keyword">long</span>.class, <span class="hljs-keyword">long</span>.class,<font></font>
                    MemoryAddress.class),<font></font>
          FunctionDescriptor.ofVoid(<span class="hljs-keyword">false</span>, C_POINTER, C_ULONG, C_ULONG,<font></font>
                    C_POINTER));<font></font>
<font></font>
// <span class="hljs-function">Upcall handler
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">qsortCompare</span><span class="hljs-params">(MemoryAddress addr1, MemoryAddress addr2)</span> </span>{
          <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)intHandle.get(addr1) - (<span class="hljs-keyword">int</span>)intHandle.get(addr2);<font></font>
}<font></font>
<font></font>
MethodHandle compar = MethodHandles.lookup().findStatic(StdLibTest.class, "qsortCompare",<font></font>
          MethodType.methodType(<span class="hljs-keyword">int</span>.class, MemoryAddress.class,<font></font>
                    MemoryAddress.class));<font></font>
MemoryAddress qsortUpcallAddr = abi.upcallStub(compar, qsortFunction);<font></font>
<font></font>
// qsort call<font></font>
qsort.invokeExact(nativeArr.baseAddress(),<font></font>
          seq.elementsCount().getAsLong(),<font></font>
          C_INT.byteSize(), qsortUpcallAddr);<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、最初にインターフェースを作成し、インターフェースのメソッドにMethodHandleを作成します（これについては後で説明します）。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QsortComparator</span> </span>{ <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(MemoryAddress addr1, MemoryAddress addr2)</span></span>; }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
qsortのMethodHandleを作成します。</font></font><br>
<br>
<pre><code class="java hljs">MethodHandle qsortCompare = MethodHandles.lookup().<font></font>
findVirtual(QsortComparator.class, "compare",<font></font>
methodType(<span class="hljs-keyword">int</span>.class, MemoryAddress.class, MemoryAddress.class));<font></font>
<font></font>
MethodHandle qsort = abi.downcallHandle(library.lookup("qsort"),<font></font>
methodType(<span class="hljs-keyword">void</span>.class,<font></font>
MemoryAddress.class, <span class="hljs-keyword">long</span>.class, <span class="hljs-keyword">long</span>.class, MemoryAddress.class),<font></font>
FunctionDescriptor.ofVoid(C_POINTER, C_ULONG, C_ULONG, C_POINTER));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、比較の実装について説明します。</font></font><br>
<br>
<pre><code class="java hljs">QsortComparator comparator = (addr1, addr2) -&gt; ... <span class="hljs-comment">// user-defined comparator</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、簡単にするために、ラムダ式を使用しています。 Javaラムダ式は、いくつかの機能インターフェースを実装するオブジェクトとして表されます。次に、ネイティブコードに送信するために、オブジェクトをポインター（MemoryAddress）に変換する必要があります。</font></font><br>
<br>
<pre><code class="java hljs">MemoryAddress comparatorAddr = abi.upcallStub(<font></font>
qsortCompare.bindTo(comparator),<font></font>
FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムABIは、upcallStub（）を介してこの機能を提供します。</font><font style="vertical-align: inherit;">実際、JVMによって準備されたマシンコード（スタブ）へのポインターを返します。これにより、ストリームがJavaコードの実行コンテキストに変換され、作成時に定義されたMethodHandleが呼び出されます。</font><font style="vertical-align: inherit;">ネイティブコードは、このポインターを関数へのポインターとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
java.lang.invoke APIは、Javaセマンティクス全体をサポートしており、MethodHandleを使用すると、実行を任意のJavaコードに委任できます。</font><font style="vertical-align: inherit;">したがって、upcallStub（）は、いくつかのMethodHandleの呼び出しをポインターに変換しました。</font><font style="vertical-align: inherit;">ネイティブコードの場合、通常の関数ポインターのように見え、内部にはJavaコードの実行を準備する複雑なプロセスがあります。</font><font style="vertical-align: inherit;">理論的には、これはJNIで実行できますが、すべてを手動で行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、qsortを呼び出すことができます。</font></font><br>
<br>
<pre><code class="java hljs">qsort.invokeExact(arrayAddr, elemCount, elemSize, comparatorAddr);
</code></pre><br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3f6/f0b/e23/3f6f0be2372b2dd95f6e91c4b8f2e0bd.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">
、パフォーマンスを比較してみましょう</font><font style="vertical-align: inherit;">。最初に目を引くのは、JNIを介した比較的低い呼び出し速度です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、JNIを介してJavaコードを呼び出すモードは、JVMエンジニアの注意を十分に引き付けておらず、実装は特別なアダプターを使用したスキームを適用することで簡単に数回加速できます（Javaからネイティブコードを呼び出すのと同様）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験はlinkToNativeに対して行われました。これは、その時点で、最適化に関するすべての実験は、それに基づく実装を使用して実行されていたためです。当時の外国人は独自の呼び出しの実装を持っていました。これはユニバーサルアダプターではなく、ABIレベルで同じ表現を持つ状況でアダプターの再利用に基づく一種の「安全でないJNI」です。 JNIはJavaタイプ（int、longなど）を使用します。また、ABIレベルでは、引数はレジスターのレベル（整数、浮動小数点）で型付けされ、値はレジスター全体を占めます。つまり、たとえば、Linux x64（System V ABI）のintおよびlongタイプのパラメーターを持つJavaシグニチャー用のアダプターは同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のスキームは、Javaからネイティブコードを呼び出すために（外部ブランチで）使用されました。同様の方式が、反対方向のコールにも使用されました。彼女はJNIより高速でしたが、専用のアダプターほどではありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSI実装は、HotSpot JVMの詳細にも影響されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HotSpotでは、実行中にインタープリターといくつかのJITコンパイラーを同時に使用できます。仮想マシンは、さまざまなモードを自由に切り替えます。これを行うために、各Javaメソッドの内部表現は、実行する必要があるコードへの2つのポインターを格納します。呼び出しがインタープリターエントリーからのものと、呼び出しがJITコンパイラーによって生成されたコードから（コンパイル済みコードエントリーから）来たときです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その理由は次のとおりです。インタープリターで実行されるコードとJITコンパイラーによって生成されるコードでは、呼び出し規約が大幅に異なります。 JITコンパイラーの場合、これらはシステムABIに近いですが、インタープリターには独自の規則があります。実装が簡単（スレッドスタックがアクティブに使用されます）ですが、実行速度が遅くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタープリターからコンパイル済みコードを呼び出す場合は、呼び出し中に1つの規則から別の規則に移動する必要があります。したがって、呼び出しは特別なアダプター（インタープリターからコンパイル済みまたはコンパイル済みからインタープリター）を経由します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ネイティブコードには独自の呼び出し規約があり、特別なアダプターも必要です。 HotSpotには、他の2つのモード（インタープリターからネイティブおよびコンパイルからネイティブ）のJavaから他のネイティブコードを呼び出すための特別なアダプターがありますが、逆の方向では、アダプターはインタープリター（ネイティブからインタープリター）専用です。したがって、メソッドが以前にJITコンパイラーによってコンパイルされていた場合、Javaのネイティブコードからの呼び出しは2つのアダプターを経由します：ネイティブからインタープリターへ、そしてすぐにインタープリターからコンパイルへ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
余分な1つのステップと、ネイティブからコンパイルに特化した新しいアダプターを追加すると、不要な作業を取り除くことができることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より複雑な場合のパフォーマンスを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b55/a22/6eb/b55a226eb46ef03926546fe671b634b7.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、qsortが比較され、Javaのネイティブコードからの呼び出しの数が異なります。1つのダウンコールが行われ、Nのアップコールが行われます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の行は基本的な次元です。Javaでは呼び出しはありません。これは、1回のqsort呼び出しの「コスト」、つまり単位時間（マイクロ秒）あたりの操作数を反映しています。ご覧のように、コストはすべてのモードで同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、Javaのネイティブコードからの呼び出し数を変化させることにより、オーバーヘッドの測定を試みます。 JNIはlinkToNativeアダプターのさまざまなバリエーションと比較され、ネイティブコードを直接呼び出すモードもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最良の結果を比較すると、ネイティブコンテキストからJavaに切り替えるコストは、直接呼び出し（「Panama Raw」と「Native」の比較）の10倍の費用がかかることがわかります（ただし、前に見たように、getpidの違いはそれほど顕著ではありません）。約3〜4回です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この違いは、多くのニュアンスによって説明されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、JNIのアダプターの実装を見ると、各スレッドには実行コンテキスト（スレッドの一意のJVM内部構造へのポインター）があります。 JNIの場合、JNIEnvに保管されているため、リカバリーは非常に簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、最適化されたアダプターでは、JNIEnvへのアクセスはもうありません。 JNIEnvを介してJVMと対話するためにネイティブコードは必要なくなりました。スレッドコンテキストを復元するには、JVMに連絡して支援を求める必要があります。現時点では、追加の呼び出しが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（コンテキストを直接アダプターにエンコードするオプションがありますが、これにはその使用をこのストリームからのみ制限する必要があります。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加の作業はすべて行われますが、この特定のケースでは、Javaのネイティブコードからの呼び出し速度はJNIを使​​用する場合よりも10倍高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちは依然として直接呼び出しよりも1桁遅いので、最適化のさらなる作業のために大きな予備を残しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根本的なアイデアの1つは、Javaコードの実行コンテキストが必要なければ、それを復元できないということです。</font><font style="vertical-align: inherit;">これは、Javaヒープにアクセスできない小さなメソッドで可能です。</font><font style="vertical-align: inherit;">これにより、呼び出しが1桁速くなり、ネイティブコードへの直接呼び出しと同等のコストがかかります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaからのネイティブコード呼び出しの最適化 </font></font></h2><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/640/cf4/eca/640cf4eca15668dd6fe137615016ba08.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブコード呼び出しの場合、この種の最適化ははるかに困難です。</font><font style="vertical-align: inherit;">ネイティブコードの呼び出し中にスレッドの安全な状態に遷移を返すとすぐに、呼び出しのコストはJNIと同等になります。</font><font style="vertical-align: inherit;">このモードでは、JNI実装は十分に最適化されており、呼び出しを大幅に節約できる単純なものは残っていません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HotSpot JVM呼び出し規約</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / hotspot / cpu / x86 / sharedRuntime_x86_64.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Java呼び出し規約は、C ABIの「シフトされた」バージョンです。最初のC ABIレジスタをスキップすることで、引数をまったくシャッフルする必要なく、少数の引数で非静的jniメソッドを呼び出すことができます。私たちはJava ABIを制御しているので、少なくともそれからいくつかの利点を得る必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/218/a97/713/218a97713918693cec546013f1094ba4.png"></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブコードの規則については、JNIの機能を考慮した特別な規則が選択され、かなり少数の引数がシステムABIと一致します。つまり、アダプターの生成コードからネイティブコードを呼び出す場合は、JNIEnvへのポインターを最初の引数として指定するだけです（JNIでは、最初の引数は、仮想マシンとの対話に使用されるJNIEnv *です）。 Linux x64（System V ABI）では、渡される整数引数が6個未満の場合、すべての引数がそのまま残り</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。他に何を保存できますか？連続した課題をより効果的にすることはできますか？それぞれの呼び出しは、呼び出しの準備のために一定量の作業を行い、呼び出し自体を行い、Javaコードの実行に戻ります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
        nativeFunc1(); <span class="hljs-comment">// checks &amp; state trans.</span>
        nativeFunc2(); <span class="hljs-comment">// checks &amp; state trans.</span>
        nativeFunc3(); <span class="hljs-comment">// checks &amp; state trans.</span><font></font>
}<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/019/946/30d/01994630da1b43f58b8f1d7547717c0a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストを確認したように、メモリの固定領域から1つの値を読み取り、それを返すgetpidなどの単純なケースでは、これにより作業が約3〜4倍遅くなります。単一の呼び出しの往復のコストは約7〜8 nsです。これらが20-25サイクルであると仮定します。どうすればこれを節約できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一度だけ移行してみましょう：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
         transitionJavaToNative();<font></font>
         <span class="hljs-function">call <span class="hljs-title">nativeFunc1</span><span class="hljs-params">()</span></span>;
         <span class="hljs-function">call <span class="hljs-title">nativeFunc2</span><span class="hljs-params">()</span></span>;
         <span class="hljs-function">call <span class="hljs-title">nativeFunc3</span><span class="hljs-params">()</span></span>;<font></font>
         transitionNativeToJava();<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで類推できます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。JIT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラー（例えば、C2）には、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ロック粗大</font></a><font style="vertical-align: inherit;">化最適化があり</font><font style="vertical-align: inherit;">ます。よく呼び出される同期メソッドがあるとします。セマンティクスによれば、呼び出しごとにオブジェクトをキャプチャする必要があります。ただし、この仕様では、すべての呼び出しで正確にキャプチャを行う必要はありません。複数の呼び出しが近くにある場合は、オブジェクトを1回キャプチャし、呼び出しを行ってから、オブジェクトを解放することができます。したがって、オブジェクトをキャプチャする複数の試行を節約できます。同様のアイデアは、いくつかの連続したネイティブ呼び出しに適用できます。理論的には、ネイティブコードの実行コンテキストに一度入り、N個のネイティブ関数を直接呼び出して、Javaコードの実行コンテキストに逆移行することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようになります</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ebd/506/ecd/ebd506ecd05b3b1818b39472cda7c3d7.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。問題は、Javaヒープへのアクセスを必要とするネイティブ呼び出しの間にいくつかの操作がある場合に発生します。別の実行コンテキストにいるので、仮想マシンはプロセスで非常に多くの安全でないことを実行できます（たとえば、Javaヒープ内のオブジェクトの移動）。それら。 Javaヒープへのすべてのアクセスは、常に仮想マシンと同期する必要があります。これには（JNIのように）特別なコードが必要であるか、この状況でコンテキストの変更を取り除くことができず、コンテキストを明示的に変更してJavaコードの実行に戻す義務があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験中に、ネイティブコールはコードをそれらの周りに非常に緊密に編成し、これによりJavaヒープからオペレーションをそれらのギャップから削除することが困難になるため、このアプローチはあまりスケーリングしないことがわかりました。開発者の観点から、ネイティブ関数との相互作用は、引数の適応：通常、バイトのシーケンスではなく、より高レベルの表現を使用するため、呼び出し間で、この種の最適化を簡単に破るさまざまな変換が行われます。</font><font style="vertical-align: inherit;">その結果、JNIに比べてパフォーマンスが向上するのは容易なことではありませんでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合計の代わりに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パナマの3つの並列ミニプロジェクト（Memory Access API、Foreign ABI、jextract）は、パフォーマンスの面でも、利便性とセキュリティの面でも、非常に有望に見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスに関しては、深刻な結果が得られましたが、まだ改善の余地はたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今までのところ、プロジェクトの主な焦点はC言語とのやり取りであり、異なるランタイム環境間でやり取りするためのリンガフランカでした。</font><font style="vertical-align: inherit;">しかし、C ++も人気があり、現在</font><font style="vertical-align: inherit;">、C ++で作成されたライブラリーと対話するための</font><font style="vertical-align: inherit;">さまざまな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実験</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が進行中</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foreign-Memory Access APIは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、インキュベーターモジュールとしてJDK 14の一部になっています。</font><font style="vertical-align: inherit;">（更新：</font><font style="vertical-align: inherit;">JDK 15 </font><font style="vertical-align: inherit;">で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新さ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。）</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505058/index.html">私たちは例を見ます-健康はどのように生態学と相関しますか？</a></li>
<li><a href="../ja505060/index.html">numpy配列をPython経由でMySQLデータベースに挿入する</a></li>
<li><a href="../ja505062/index.html">ScanTech PRINCE 775および335 3Dスキャナーの概要</a></li>
<li><a href="../ja505064/index.html">Mikrotik split-dns：彼らはそれをしました</a></li>
<li><a href="../ja505070/index.html">良い文章についての知的オナニー</a></li>
<li><a href="../ja505074/index.html">ホスティングおよび専用サーバー：質問に答えます。第2部データセンターでこのような高価なインターネットを使用する理由</a></li>
<li><a href="../ja505078/index.html">顕微鏡下のBLE（ATT GATT ...）</a></li>
<li><a href="../ja505080/index.html">非同期コードの世界におけるミューテックス</a></li>
<li><a href="../ja505082/index.html">PythonのML開発者向けの10の便利な方法</a></li>
<li><a href="../ja505090/index.html">「役に立つ」/「使わない」/役に立たないという言葉の翻訳について</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>