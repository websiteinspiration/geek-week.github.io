<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèª üêê üëë Programaci√≥n asincr√≥nica en .NET: mejores pr√°cticas ‚ùÑÔ∏è üöñ üë®üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El advenimiento de async / await en C # ha llevado a una redefinici√≥n de c√≥mo escribir c√≥digo paralelo simple y correcto. A menudo, usando la programa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n asincr√≥nica en .NET: mejores pr√°cticas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El advenimiento de async / await en C # ha llevado a una redefinici√≥n de c√≥mo escribir c√≥digo paralelo simple y correcto. A menudo, usando la programaci√≥n asincr√≥nica, los programadores no solo no resuelven los problemas que estaban con los hilos, sino que tambi√©n introducen otros nuevos. Los puntos muertos y los vuelos no van a ninguna parte, simplemente se vuelven m√°s dif√≠ciles de diagnosticar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Software Analysis TeamLead en Huawei, un antiguo techlide de JetBrains Rider y desarrollador del n√∫cleo ReSharper: estructuras de datos, cach√©s, subprocesos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√∫ltiples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y un orador habitual en la conferencia </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">DotNext</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bajo la escena: grabaci√≥n de video y transcripci√≥n de texto del informe de Dmitry de la conferencia DotNext 2019 Piter.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Narraci√≥n adicional en nombre del orador.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En el c√≥digo multiproceso o as√≠ncrono, a menudo algo se rompe. La raz√≥n podr√≠a ser tanto un punto muerto como una carrera. Como regla general, una raza se bloquea una vez de cada mil, a menudo no localmente, sino solo en un servidor de compilaci√≥n, y lleva varios d√≠as atraparla. Estoy seguro de que para muchos esta es una situaci√≥n familiar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, al observar el c√≥digo asincr√≥nico incluso por desarrolladores experimentados, me encuentro pensando que algunas cosas pueden escribirse tres veces m√°s cortas y m√°s correctamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto sugiere que el problema no est√° en las personas, sino en el instrumento. </font><font style="vertical-align: inherit;">La gente simplemente usa la herramienta y quiere que resuelva su problema. </font><font style="vertical-align: inherit;">La herramienta en s√≠ tiene una gran cantidad de capacidades (a veces incluso superfluas), configuraciones, un contexto impl√≠cito, lo que lleva al hecho de que es muy f√°cil de usar incorrectamente. </font><font style="vertical-align: inherit;">Intentemos descubrir c√≥mo usar async / await y trabajar con una clase </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en .NET.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plan</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas con los enfoques que se resuelven con async / wait.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos de dise√±o controvertido.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una tarea de la vida real que resolveremos de forma asincr√≥nica.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ncrono / espera y problemas por resolver</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© necesitamos async / wait? Digamos que tenemos c√≥digo que funciona con memoria compartida compartida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comienzo del trabajo, leemos la solicitud, en este caso, el archivo de la cola de bloqueo (por ejemplo, de Internet o del disco), utilizando la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solicitud de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bloqueo </font><i><font style="vertical-align: inherit;">Dequeue</font></i><font style="vertical-align: inherit;"> (las solicitudes de bloqueo se marcar√°n en rojo en las im√°genes con ejemplos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este enfoque requiere muchos subprocesos, y cada subproceso requiere recursos, crea una carga en el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero este no es el problema principal. Supongamos que las personas pudieran reescribir los sistemas operativos para que estos sistemas admitan cientos de miles y un mill√≥n de subprocesos. Pero el problema principal es que algunos hilos simplemente no se pueden tomar. Por ejemplo, tiene un hilo de interfaz de usuario. No hay marcos de interfaz de usuario adecuados normales donde el acceso a los datos no sea solo desde un hilo, todav√≠a. El subproceso de la interfaz de usuario no se puede bloquear. Y para no bloquearlo, necesitamos un c√≥digo asincr√≥nico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora hablemos de la segunda tarea. Despu√©s de leer el archivo, debe procesarse de alguna manera. Lo haremos en paralelo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos de ustedes han escuchado que el paralelismo no es lo mismo que la asincron√≠a. En este caso, surge la pregunta: ¬øpuede la asincron√≠a ayudar a escribir c√≥digo paralelo m√°s compacto, hermoso y m√°s r√°pido?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La √∫ltima tarea es trabajar con memoria compartida. </font><font style="vertical-align: inherit;">¬øNecesitamos arrastrar este mecanismo con bloqueos, sincronizaci√≥n a c√≥digo asincr√≥nico, o se puede evitar de alguna manera? </font><font style="vertical-align: inherit;">¬øPuede </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ayuda con esto?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camino a async / esperar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos la evoluci√≥n de la programaci√≥n asincr√≥nica en general en el mundo y en .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamar de vuelta</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {‚Ä¶}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ‚Ä¶<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       ‚Ä¶<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programaci√≥n asincr√≥nica comenz√≥ con devoluciones de llamada. </font><font style="vertical-align: inherit;">Es decir, primero debe llamar a una parte del c√≥digo de forma sincr√≥nica, y la segunda parte, de forma asincr√≥nica. </font><font style="vertical-align: inherit;">Por ejemplo, lee de un archivo y, cuando los datos est√°n listos, se le entregar√°n de alguna manera. </font><font style="vertical-align: inherit;">Esta parte asincr√≥nica se pasa como una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devoluci√≥n de llamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s devoluciones de llamada</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, desde una devoluci√≥n de llamada puede registrar otra </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devoluci√≥n de llamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , desde la cual puede registrar una tercera devoluci√≥n de llamada, y al final todo se convierte en un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">infierno de devoluci√≥n de llamada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devoluci√≥n de llamada: excepciones</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo trabajar con excepciones? Por ejemplo, ReSharper, cuando responde por separado a las excepciones y a una buena ejecuci√≥n, no demuestra las piezas de c√≥digo m√°s bellas: hay devoluciones de llamada separadas para una situaci√≥n excepcional y para una continuaci√≥n exitosa. El resultado es un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">infierno de devoluci√≥n de llamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero no lineal, sino en forma de √°rbol, lo que puede ser completamente confuso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET, el primer enfoque de devoluci√≥n de llamada se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo de programaci√≥n asincr√≥nica</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM). Se llamar√° al m√©todo </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es esencialmente el mismo </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero el enfoque tiene algunas caracter√≠sticas. En primer lugar, los m√©todos deben comenzar con la palabra "Comenzar" (la lectura de un archivo es BeginRead), que devuelve algunos </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. √âl mismo</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Este es un controlador que sabe que la operaci√≥n se ha completado y que tiene un mecanismo </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puede </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar, esperando que la operaci√≥n se complete de forma asincr√≥nica. Por otro lado, puede llamar </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, hacer </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y colgar sincr√≥nicamente (que es muy similar a una propiedad </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este enfoque tiene varios problemas. En primer lugar, no nos protege del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">infierno de devoluci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">llamadas</font></i><font style="vertical-align: inherit;"> . En segundo lugar, sigue sin estar completamente claro qu√© hacer con las excepciones. En tercer lugar, no est√° claro en qu√© hilo se llamar√° esta devoluci√≥n de llamada: no tenemos control sobre la llamada. Cuarto, surge la pregunta, ¬øc√≥mo combinar fragmentos de c√≥digo con devoluciones de llamada? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo modelo se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patr√≥n asincr√≥nico basado en eventos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es un enfoque de devoluci√≥n de llamada reactivo. La idea del m√©todo es que pasemos al m√©todo </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alg√∫n objeto que tenga el evento Completado y nos suscribamos a este evento. Como notaron, los </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambios a </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La confusi√≥n puede ocurrir cuando ingresa a la clase Socket, donde se mezclan dos patrones: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que debe llamar para cancelar </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como en .NET esto no se encuentra en ning√∫n otro lugar, generalmente todos env√≠an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por lo tanto, si accidentalmente encuentra un m√©todo en la biblioteca que termina con </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, debe comprender que no necesariamente regresa </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero puede devolver una construcci√≥n similar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere un modelo que se conoce en Java como</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futuros</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en JavaScript, como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promesas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y en .NET, como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrones asincr√≥nicos de tareas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en otras palabras, "tareas". Este m√©todo supone que tiene alg√∫n objeto de c√°lculo y puede ver el estado de este objeto (en ejecuci√≥n o terminado). En .NET, existe una llamada </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separaci√≥n conveniente de dos estados: el inicio de la tarea y la finalizaci√≥n de la tarea. Se produce un error com√∫n cuando se llama a un m√©todo en una tarea </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelve una continuaci√≥n no exitosa, pero </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, el resultado de hacer clic en "Cancelar" en la aplicaci√≥n de interfaz de usuario debe diferir de la devoluci√≥n de excepciones (ejecuciones). En .NET, se ha hecho una distinci√≥n: si la ejecuci√≥n es su error que desea proteger, entonces </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- operaci√≥n forzada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET, tambi√©n se introdujo un concepto </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: es una especie de abstracci√≥n en la parte superior de los hilos que indica d√≥nde ejecutar la tarea. En este caso, el soporte de cancelaci√≥n se dise√±√≥ a nivel de dise√±o. Casi todas las operaciones en la biblioteca en .NET tienen </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se pueden pasar. Esto no funciona para todos los idiomas: por ejemplo, en Kotlin puede deshacer la tarea, pero en .NET no puede hacerlo. La soluci√≥n puede ser la divisi√≥n de responsabilidades entre quienes cancelan la tarea y la tarea misma. Cuando recibe una tarea, no puede cancelarla de otra manera que no sea expl√≠citamente, debe pasarla </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objeto especial le </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite adaptar f√°cilmente las API antiguas que est√°n asociadas con el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patr√≥n asincr√≥nico basado en eventos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo de programaci√≥n asincr√≥nica</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hay un documento que debe leer si programa en tareas. </font><font style="vertical-align: inherit;">Describe todos los acuerdos sobre tarifas. </font><font style="vertical-align: inherit;">Por ejemplo, cualquier m√©todo, que devuelve la tarea, debe devolverlo en un estado de ejecuci√≥n, lo que significa que no puede serlo </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mientras que todas esas operaciones deben terminar </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinando continuaciones</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a la combinaci√≥n, teniendo en cuenta el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">infierno de devoluci√≥n de llamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puede aparecer en una forma m√°s lineal, a pesar de la presencia de piezas de c√≥digo repetitivo con cambios m√≠nimos. </font><font style="vertical-align: inherit;">Parece que el c√≥digo est√° mejorando de esta manera, pero tambi√©n hay dificultades aqu√≠.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciar y continuar tareas</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos a tres par√°metros durante el inicio de la tarea est√°ndar: el primero son las opciones para iniciar la tarea, el segundo es </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquel en el que se inicia la tarea y el tercero - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler le dice d√≥nde comienza la tarea y es un objeto que puede anular independientemente. Por ejemplo, puede anular un m√©todo </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si lo hace </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el m√©todo de </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toma de un hilo </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y env√≠a su tarea all√≠. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se hace </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cargo del hilo principal, pone todo en una cola y las tareas se ejecutan secuencialmente en el hilo principal. Sin embargo, el problema es que en .NET puede ejecutar la tarea sin pasar </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Surge la pregunta: ¬øc√≥mo, entonces, calcula .NET qu√© tarea se le pas√≥? Cuando la tarea comienza por </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exhibido en el </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le dimos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este dise√±o parece bastante controvertido debido al contexto impl√≠cito. Hubo casos en los que </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conten√≠a c√≥digo asincr√≥nico que hered√≥ en alg√∫n lugar muy profundamente </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se superpuso con otro planificador, lo que condujo a puntos muertos. En este caso, puede usar la opci√≥n </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta es una campana de alarma que dice que tenemos alguna opci√≥n que anula la </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configuraci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo es igual con continuaciones. Surge la pregunta: ¬øde d√≥nde viene </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para las continuaciones? En primer lugar, se toma en el m√©todo en el que comenz√≥ </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tambi√©n se </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toma de ThreadStatic. Es importante que para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait, las</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuaciones funcionen de manera muy diferente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasamos a los par√°metros </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Su principal problema es que hay muchos de ellos. Algunos de estos par√°metros se cancelan entre s√≠, algunos son mutuamente excluyentes. Todos estos par√°metros se pueden usar en todas las combinaciones posibles, por lo que es dif√≠cil tener en cuenta todo lo que puede suceder con el anhelo. Algunas de estas opciones funcionan de manera completamente incomprensible. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, los par√°metros </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">representan dos posibles opciones de aplicaci√≥n, pero si la continuaci√≥n se iniciar√° de forma s√≠ncrona o as√≠ncrona depende de tantas cosas que no sabr√°. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro ejemplo: lanzamos la tarea, iniciamos la continuaci√≥n y simult√°neamente dimos dos par√°metros</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despu√©s de lo cual comenzaron la continuaci√≥n de forma asincr√≥nica. </font><font style="vertical-align: inherit;">¬øSe ejecutar√° en la misma pila donde finaliza la tarea anterior o se transferir√° </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">En este caso, habr√° una tercera opci√≥n: depende.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cuando crea una tarea, establece su resultado </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para adaptar los patrones asincr√≥nicos anteriores al mundo de la tarea. Puede </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solicitar </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y esta tarea entrar√° en estado </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando llame </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sin embargo, si ejecuta esto en el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grupo de subprocesos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , obtendr√° un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">punto muerto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La pregunta es, ¬øpor qu√© si no escribimos nada incluso sincr√≥nicamente? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creamos </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comenzamos una nueva tarea, y tenemos un segundo hilo que inicia algo en esta tarea. Pasa y cae en la expectativa de cien milisegundos. Entonces nuestro hilo principal, el verde, va a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y eso es todo. Libera la pila, la pila se cuelga, esperando ser llamada en una continuaci√≥n</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expuesto </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el hilo azul llegamos </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego el m√°s interesante. </font><font style="vertical-align: inherit;">Basado en consideraciones internas de .NET, √©l </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cree que la continuaci√≥n de esto </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede realizarse sincr√≥nicamente, es decir, directamente en la misma pila, luego esto </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se realiza sincr√≥nicamente en la misma pila. </font><font style="vertical-align: inherit;">Esto es muy extra√±o, a pesar de que ni siquiera hemos escrito en ning√∫n lado </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es probablemente el problema con la mezcla de c√≥digo s√≠ncrono y as√≠ncrono. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro problema con esto </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es que cuando llamamos </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bajo el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">candado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no puede llamar a un c√≥digo arbitrario, ya que bajo el candado solo puede realizar una peque√±a actividad granular. </font><font style="vertical-align: inherit;">Corre debajo de algunas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acciones</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es imposible venir de donde vinieron. </font><font style="vertical-align: inherit;">¬øC√≥mo resolver este problema?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale la </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pena </font><font style="vertical-align: inherit;">usar </font><font style="vertical-align: inherit;">solo para la adaptaci√≥n del </font><font style="vertical-align: inherit;">c√≥digo </font><font style="vertical-align: inherit;">no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en las bibliotecas. </font><font style="vertical-align: inherit;">Casi todo lo dem√°s se puede resolver a trav√©s de la espera. </font><font style="vertical-align: inherit;">En este caso, siempre se recomienda encarecidamente prescribir el par√°metro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Casi siempre necesita ejecutar una continuaci√≥n de forma asincr√≥nica. </font><font style="vertical-align: inherit;">En este caso, </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene algo debajo de lo cual no se iniciar√° nada. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© la continuaci√≥n debe realizarse sincr√≥nicamente? </font><font style="vertical-align: inherit;">Porque se </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refiere a lo siguiente </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y no a lo nuestro. </font><font style="vertical-align: inherit;">Para relacionarse con los nuestros, debe escribir lo siguiente: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este ejemplo muestra c√≥mo los par√°metros no son intuitivos, c√≥mo se cruzan entre s√≠, c√≥mo introducen la complejidad cognitiva; es muy dif√≠cil escribir.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jerarqu√≠a padre-hijo</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay otras opciones para usar par√°metros. Por ejemplo, una </font><font style="vertical-align: inherit;">jerarqu√≠a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padre-hijo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> surge </font><font style="vertical-align: inherit;">cuando inicia una tarea y ejecuta otra debajo de ella. En este caso, si escribe </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no esperar√° la tarea iniciada en su interior. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si escribes </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar√°. Puede usar esta propiedad en sus productos. Creo que todos pueden encontrar un ejemplo en el que haya una jerarqu√≠a de tareas, con la tarea esperando la subtarea y la subtarea para sus subtareas. No es necesario escribir en ning√∫n lado </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esta espera ocurre de forma as√≠ncrona. Es decir, el cuerpo de la tarea principal finaliza y, despu√©s de eso, la tarea principal no se considera completa, no comienza sus continuaciones hasta que las tareas secundarias funcionen.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede haber un problema en el que la tarea se transfiere en alg√∫n lugar </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces todo lo que comenz√≥ </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se agregar√° a esta tarea principal, que es una campana de alarma.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por otro lado, hay una opci√≥n que cancela la opci√≥n anterior </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tal aplicaci√≥n ocurre con bastante frecuencia.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale la pena recordar que </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta es la forma est√°ndar de comenzar, lo que por defecto implica </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El contexto impl√≠cito que pones te </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agrega complejidad. No comprende c√≥mo funciona la tarea, porque necesita conocer el contexto. Otro problema que puede surgir est√° relacionado con el estado inactivo de as√≠ncrono / espera. Eso es porque en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no tienes tareas, sino acciones. La continuaci√≥n no es tarea honesta, sino acci√≥n. Cuando escribe c√≥digo as√≠ncrono / espera, no necesita usarlo </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque vincula expl√≠citamente las tareas para esperar en espera, y este es el enfoque correcto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tiene seis opciones sobre c√≥mo comenzar una continuaci√≥n. Lanzaste tarea, lanzaste</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pregunta: ¬øQu√© estado tendr√° esta continuaci√≥n? </font><font style="vertical-align: inherit;">Hay cinco respuestas posibles:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la continuaci√≥n general se completar√° con √©xito; se ejecutar√° RunToCompletion;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la tarea estar√° en error;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se producir√° la cancelaci√≥n;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la tarea no llegar√° a completarse en absoluto, ser√° en alg√∫n tipo de limbo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opci√≥n - "depende".</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, la tarea estar√° en el estado "cancelado", aunque en ninguna parte est√° la palabra "cancelado" en ninguna parte. </font><font style="vertical-align: inherit;">Aqu√≠ tiramos la recepci√≥n y no hacemos nada. </font><font style="vertical-align: inherit;">El problema es que cuando lees el c√≥digo de otra persona con muchas opciones, incluso si conoc√≠as estas opciones hace 10 minutos, todav√≠a olvidas lo que sucede aqu√≠. </font><font style="vertical-align: inherit;">Entonces no escribas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelaci√≥n</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercer par√°metro al comienzo de la tarea es kancellation. </font><font style="vertical-align: inherit;">Usted escribe </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, una acci√≥n especial que pone la tarea en el estado "Cancelado". </font><font style="vertical-align: inherit;">En este caso, la tarea estar√° en el estado "Fallido", porque no todos </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son iguales.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que la tarea sea posible </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, debe lanzarla </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">junto con su CancellationToken. </font><font style="vertical-align: inherit;">En realidad, nunca haces esto expl√≠citamente, pero hazlo de esta manera:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øEs necesario distinguir cancelationToken? </font><font style="vertical-align: inherit;">En alg√∫n lugar dentro de la tarea, verifica que alguien lo haya eliminado: cancelaci√≥n de lanzamiento, luego la tarea entra en estado </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O alguien hizo clic en "Cancelar" en tiempo de ejecuci√≥n y cancel√≥ la tarea. </font><font style="vertical-align: inherit;">Nuestra pr√°ctica en JetBrains sugiere que no es necesario distinguir entre estos tokens. </font><font style="vertical-align: inherit;">Si obtiene una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excepci√≥n OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un tipo especial que ocurre cuando se produce alguna cancelaci√≥n, puede distinguirla. </font><font style="vertical-align: inherit;">En este caso, solo necesita completar la tarea normalmente, no inicie sesi√≥n y cuando reciba la ejecuci√≥n, inicie sesi√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pila profunda</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tienes una pila profunda. Este </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el √∫nico par√°metro expl√≠cito que discutimos. Debe transmitirse a todas partes a trav√©s de absolutamente todas las jerarqu√≠as. ¬øQu√© hacer si en presencia de una jerarqu√≠a profunda necesita cancelar su tarea en alg√∫n lugar, en el nivel m√°s bajo, para tirar la recepci√≥n? Hay un truco tan especial que usamos. El es llamado </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es lo mismo, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo el especial </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que sobrevive a los viajes de c√≥digo as√≠ncrono / en espera. </font><font style="vertical-align: inherit;">Como su c√≥digo es as√≠ncrono y tiene esta anulaci√≥n, la ingresa y, en </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alg√∫n lugar a un nivel profundo, puede decir " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Nuevamente, este es el √∫nico par√°metro </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que necesita difuminar por completo el c√≥digo completo, pero, en mi opini√≥n, para la mayor√≠a de las tareas solo necesita saber qu√© sucedi√≥ </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y de esto sacar una conclusi√≥n de qu√© estado: Cancelado o Fallido.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complejidad cognitiva</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuanto m√°s dif√≠cil sea leer el c√≥digo al iniciar la tarea, mayor ser√° el riesgo de error. Si observa el c√≥digo despu√©s de un a√±o, olvidar√° lo que hace, porque hay una gran cantidad de par√°metros. Pero tenemos la biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que ofrece vidas modernas, CancellationToken bien optimizado, con el que se reescribi√≥ el m√©todo Start y se resolvi√≥ el problema de repetir partes de c√≥digo, como con </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una peque√±a cantidad de programadores que le permiten programar una tarea en el hilo principal con bloqueo de lectura. Es decir, el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueo de lectura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no es algo que elija expl√≠citamente, es un programador especial que programa su c√≥digo en el hilo principal con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueo de lectura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ como el subproceso principal con bloqueo de escritura, subproceso de fondo, y ahora los m√©todos se vuelven muy simples para iniciar el reordenamiento. Al mismo tiempo, las vidas se cancelan autom√°ticamente </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, simplificando significativamente el c√≥digo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resuelve estos problemas y qu√© problemas presentan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, parte del c√≥digo se ejecuta sincr√≥nicamente, luego </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espera un</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥digo as√≠ncrono. En primer lugar, es bueno que haya muchos menos c√≥digos de repetici√≥n ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">placa de caldera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). En segundo lugar, es bueno que el c√≥digo as√≠ncrono sea muy similar al c√≥digo s√≠ncrono, para eso es exactamente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as√≠ncrono / espera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Puede escribir de forma asincr√≥nica de la misma manera que escribi√≥ sincr√≥nicamente, sin ocupar hilos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øEn qu√© caso se implementar√° el compilador? El c√≥digo sincr√≥nico se ejecutar√° sincr√≥nicamente, despu√©s de lo cual la tarea </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">ejecutar√° sincr√≥nicamente </font><font style="vertical-align: inherit;">, ¬øde d√≥nde viene el objeto especial GetAwaiter? En este caso, estamos interesados </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puedes escribirle a tu mesero para absolutamente cualquier objeto. Como resultado, esperamos que la tarea se complete </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la ejecute sincr√≥nicamente </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la tarea no se complet√≥, el c√≥digo de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se programa en el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificador de contexto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Puede ser que, aunque haya escrito </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguardar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , absolutamente todo se llamar√° sincr√≥nicamente.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un truco </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: esta es una tarea especial que garantiza que su camarero no siempre volver√° a usted </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En consecuencia, </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se llamar√° sincr√≥nicamente en este lugar. Para un subproceso de interfaz de usuario, esto puede ser importante porque no toma este subproceso durante un per√≠odo prolongado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo elegir un hilo para la continuaci√≥n? La filosof√≠a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as√≠ncrona / espera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la </font><font style="vertical-align: inherit;">siguiente: usted escribe c√≥digo as√≠ncrono igual que sincr√≥nico. Si tiene un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grupo de subprocesos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">hay diferencia para usted: el c√≥digo de continuaci√≥n se ejecutar√° en otro subproceso. Independientemente de si se </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complet√≥ cuando dijo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o no, necesita todo para ejecutar en el hilo de la interfaz de usuario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mecanismo para la tarea en espera es el siguiente: se toma </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se llama</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y de esto se crea </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una cosa con el m√©todo Post, que es muy similar al m√©todo </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De hecho </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que era antes, simplemente toma </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a trav√©s de Post realiza su tarea en √©l.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una manera de cambiar este comportamiento usando un par√°metro </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se llama la API m√°s desagradable que est√° en .NET </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En este caso, la API crea un camarero especial que es diferente del </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cambia la continuaci√≥n, se ejecuta en el mismo hilo, en el mismo contexto en el que termin√≥ el m√©todo </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y donde termin√≥ la tarea.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una cantidad incre√≠ble de consejos en Internet: si tiene un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">punto muerto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , manche todo su c√≥digo ConfigureAwait y todo estar√° bien. </font><font style="vertical-align: inherit;">Este es el camino equivocado. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede usar en casos en los que desea mejorar ligeramente el rendimiento, o al final del m√©todo, en algunos m√©todos de biblioteca.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puntos muertos</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">punto muerto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cl√°sico </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En el hilo de la interfaz de usuario, esperaron diez segundos y lo hicieron </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Debido a lo que ha hecho </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca se iniciar√°, </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font><font style="vertical-align: inherit;">lo </font><font style="vertical-align: inherit;">tanto </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">nunca volver√°. </font><font style="vertical-align: inherit;">Todo tiene lugar desde el principio.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagina que esta es una actividad real. Hicimos clic en el bot√≥n, lo tomamos </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo hicimos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , escribimos </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Decimos: "Por favor, no cierre nuestra transmisi√≥n de interfaz de usuario, realice la continuaci√≥n". El problema es que queremos que la segunda parte despu√©s </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n se ejecute en el hilo de la interfaz de usuario, porque esta es la filosof√≠a de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, su c√≥digo asincr√≥nico tiene el mismo aspecto que el c√≥digo s√≠ncrono y se ejecuta en el mismo contexto. En este caso, por supuesto, habr√° un error. Y adem√°s </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede haber cualquier n√∫mero de llamadas a m√©todos que tambi√©n asuman su contexto. ¬øQu√© hacer en esta situaci√≥n? Puedes hacerlo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con un subproceso de interfaz de usuario, debe prohibir hacerlo </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en subprocesos que tienen una cola de mensajes com√∫n. En lugar de hacer </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o escribir </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puede bombear esta cola de mensajes y, al mismo tiempo, tambi√©n se bombear√° el continuo. Si no puede mezclar c√≥digo s√≠ncrono y as√≠ncrono, entonces no debe mezclarlos. Pero a veces esto no se puede evitar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, tiene un c√≥digo antiguo y tiene que mezclarlos, luego bombea la transmisi√≥n de la interfaz de usuario. Visual Studio bombea el hilo de la interfaz de usuario a las expectativas, incluso </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambi√≥ un poco. Si ingresas a WaitHandle en cualquiera </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cuando cuelgas, tu flujo de interfaz de usuario se bombea. Por lo tanto, eligen entre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntos muertos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y razas a favor de la raza s. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Esta es una API no ideal, es decir, cuando realiza una continuidad aleatoria en un lugar arbitrario, puede haber matices. </font><font style="vertical-align: inherit;">No hay otra manera, desafortunadamente. </font><font style="vertical-align: inherit;">Mezcle c√≥digos s√≠ncronos y as√≠ncronos. </font><font style="vertical-align: inherit;">En todo caso, todo el Rider est√° tan organizado en los lugares antiguos, por lo que a veces tambi√©n hay matices.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar contexto</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay otra forma interesante de usar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se puede escribir </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y saltar sobre las discusiones. </font><font style="vertical-align: inherit;">Le√≠ publicaciones en Visual Studio, escribieron durante mucho tiempo que no es bueno saltar de un lado a otro en el medio del m√©todo, pero ahora lo hacen ellos mismos. </font><font style="vertical-align: inherit;">Visual Studio tiene una API que salta sobre hilos a trav√©s de programadores. </font><font style="vertical-align: inherit;">Para uso normal, hacer esto no es bueno.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concurrencia estructurada</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para una inmersi√≥n conveniente en el nuevo contexto y volver al antiguo, se debe construir cierta competencia estructural o paralelismo estructural. </font><font style="vertical-align: inherit;">Por ejemplo, en los a√±os sesenta, el operador GoTo se consideraba perjudicial porque violaba la estructuralidad. </font><font style="vertical-align: inherit;">Entonces est√° aqu√≠. </font><font style="vertical-align: inherit;">Saltar sobre hilos viola lo estructural. </font><font style="vertical-align: inherit;">Sorprendentemente, usar una m√°quina de estado as√≠ncrono parece una buena salida. </font><font style="vertical-align: inherit;">Es decir, cuando se viola su estructura habitual, salta a GoTo, puede violar la estructura del hilo: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espere</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">m√©zclelo </font><font style="vertical-align: inherit;">con etiquetas. </font><font style="vertical-align: inherit;">Esta es una situaci√≥n extremadamente extra√±a y rara cuando necesitas hacer esto. </font><font style="vertical-align: inherit;">A√∫n as√≠, es mejor cuando la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vuelve al mismo contexto. </font><font style="vertical-align: inherit;">Por lo tanto, el grupo de subprocesos no tendr√° el mismo subproceso, sino el mismo contexto que originalmente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportamiento secuencial</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">lo mismo que ejecuci√≥n paralela? </font><font style="vertical-align: inherit;">Aguardar ejecuci√≥n es ejecuci√≥n secuencial. </font><font style="vertical-align: inherit;">En este caso, comenzamos la primera tarea, la esperamos, comenzamos la segunda tarea, esperamos. </font><font style="vertical-align: inherit;">No tenemos paralelismo. </font><font style="vertical-align: inherit;">Para la mayor√≠a de los usos, el paralelismo no es necesario. </font><font style="vertical-align: inherit;">El paralelismo en s√≠ mismo es m√°s complejo que la secuencia. </font><font style="vertical-align: inherit;">El c√≥digo de serie es m√°s simple que paralelo, es un axioma. </font><font style="vertical-align: inherit;">Pero a veces necesitas ejecutar algo en c√≥digo paralelo, y lo haces as√≠:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportamiento concurrente</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ las tareas comienzan en paralelo. </font><font style="vertical-align: inherit;">Est√° claro que los m√©todos pueden devolver la tarea inmediatamente en un estado de ejecuci√≥n, entonces no habr√° paralelismo. </font><font style="vertical-align: inherit;">Digamos que ambos tasky lanzan una ejecuci√≥n. </font><font style="vertical-align: inherit;">Y esperaste la primera tarea, luego la primera espera despeg√≥. </font><font style="vertical-align: inherit;">Es decir, tan pronto como escribi√≥ </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despeg√≥ y no proces√≥ </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Curiosamente, este es un c√≥digo absolutamente v√°lido. </font><font style="vertical-align: inherit;">Y es este c√≥digo el que llev√≥ a .NET al hecho de que en la versi√≥n 4.5 el comportamiento de trabajar con ejecuciones ha cambiado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manejo de excepciones</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1‚Äôs exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don‚Äôt crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, las ejecuciones no controladas simplemente arrojaban el proceso, y si no capt√≥ alguna ejecuci√≥n </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(esto tambi√©n es algo </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que puede adjuntar a los planificadores), entonces este proceso no se ejecut√≥. Ahora este es un c√≥digo absolutamente v√°lido. Aunque .NET cambi√≥ su comportamiento, conserv√≥ la configuraci√≥n para devolver el comportamiento en la direcci√≥n opuesta.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vea c√≥mo va el procesamiento de la ejecuci√≥n. </font><font style="vertical-align: inherit;">CancellationToken-s debe transmitirse, es necesario "difuminar" CancellationToken-s todo el c√≥digo. </font><font style="vertical-align: inherit;">El comportamiento normal de as√≠ncrono es que no verifica en ninguna parte </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, trabaja con c√≥digo as√≠ncrono de la misma manera que con s√≠ncrono. </font><font style="vertical-align: inherit;">Es decir, en el caso de una cancelaci√≥n, obtiene una ejecuci√≥n y, en este caso, no hace nada cuando la recibe </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre el estado de Cancelado y Fallido es que no recibi√≥ </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino la ejecuci√≥n habitual. </font><font style="vertical-align: inherit;">Y en este caso, podemos prometerlo, solo necesita obtener una ejecuci√≥n y sacar conclusiones basadas en esto. </font><font style="vertical-align: inherit;">Si comenzaste la tarea expl√≠citamente, a trav√©s de la Tarea, hubieras volado </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y en as√≠ncrono, en el caso </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre lanzan la primera ejecuci√≥n que estaba en √©l (en este caso - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la pr√°ctica</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo sincr√≥nico</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, un demonio trabaja en ReSharper, un editor que ti√±e el archivo por usted. </font><font style="vertical-align: inherit;">Si el archivo se abre en el editor, entonces hay alguna actividad que lo coloca en una cola de bloqueo. </font><font style="vertical-align: inherit;">Nuestro proceso </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lee desde all√≠, despu√©s de lo cual realiza un mont√≥n de tareas diferentes con este archivo, lo ti√±e, analiza, compila, luego de lo cual se agregan estos archivos </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Con un </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueo, otros mecanismos ya est√°n trabajando con √©l.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo asincr√≥nico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al volver a escribir el c√≥digo en as√≠ncrono, en primer lugar lo reemplazaremos </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aseg√∫rese de escribir la palabra "Async" al final. </font><font style="vertical-align: inherit;">Todos los m√©todos asincr√≥nicos deben terminar en as√≠ncrono; esta es una convenci√≥n.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de eso, debes hacer algo con los nuestros </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Obviamente, si hay alguna primitiva s√≠ncrona, entonces debe haber alguna primitiva as√≠ncrona. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta primitiva se llama canal: los canales que viven en el paquete </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puede crear canales y colas, limitadas e ilimitadas, que puede esperar de forma as√≠ncrona. Adem√°s, puede crear un canal con un valor de "cero", es decir, no tendr√° un b√∫fer en absoluto. Dichos canales se denominan canales de encuentro y se promueven activamente en Go y Kotlin. Y, en principio, si es posible usar canales en c√≥digo as√≠ncrono, este es un patr√≥n muy bueno. Es decir, cambiamos la cola al canal donde hay m√©todos </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un mont√≥n de c√≥digo paralelo que procesa un archivo y lo convierte en</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¬øPuede async ayudarnos a escribir no as√≠ncrono, sino c√≥digo paralelo m√°s compacto?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifique el C√≥digo Paralelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo se puede reescribir de esta manera:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo se ven </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Por ejemplo, tenemos un archivo. Primero, lo dividimos en lexemas, y podemos tener dos tareas en paralelo: construir cach√©s de b√∫squeda y construir un √°rbol de sintaxis. Despu√©s de eso viene la tarea de "buscar errores sem√°nticos". Aqu√≠ es importante que todas estas tareas formen un gr√°fico ac√≠clico dirigido. Es decir, puede ejecutar algunas partes en subprocesos paralelos, otras no, y obviamente hay dependencias de qu√© tarea deber√≠a esperar otras tareas. Obtiene un gr√°fico de tales tareas, desea dispersarlas de alguna manera a lo largo de los hilos. ¬øEs posible escribirlo bellamente, sin errores? En nuestro c√≥digo, este problema se resolvi√≥ varias veces, cada una de manera diferente. Raramente ocurre cuando este c√≥digo se escribe sin errores.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definimos este gr√°fico de tareas de la siguiente manera: digamos que cada tarea tiene otras tareas de las que depende, luego, usando el diccionario ExecuteBefore, escribimos el esqueleto de nuestro m√©todo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soluciones de esqueleto</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si resuelve este problema de frente, debe hacer una clasificaci√≥n topol√≥gica de este gr√°fico. </font><font style="vertical-align: inherit;">Luego tome una tarea que no tenga tareas dependientes, ejec√∫tela, analice la estructura debajo de un candado, vea qu√© tareas no tienen dependientes. </font><font style="vertical-align: inherit;">Corre, dispersalos de alguna manera </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo escribimos un poco m√°s compacto: clasificaci√≥n topol√≥gica del gr√°fico + ejecuci√≥n de tales tareas en diferentes hilos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ncrono perezoso</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un patr√≥n llamado </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Creamos el nuestro </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que se deben ejecutar diferentes acciones. Creemos un diccionario: formatearemos cada una de nuestras etapas (Action ProcessedFile) en alguna Tarea, o m√°s bien, en Lazy desde Task y correremos a lo largo del gr√°fico original. La variable </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tendr√° la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acci√≥n en</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√≠ </font><font style="vertical-align: inherit;">, y en beforeList: aquellas acciones que deben realizarse antes que la nuestra. Luego crea </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Escribimos en Tarea </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, estamos esperando todas las tareas que deben completarse antes. En beforeList, seleccione el </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que est√° en este diccionario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que aqu√≠ no se ejecutar√° nada sincr√≥nicamente, por lo que este c√≥digo no se ejecutar√° </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Realizamos todas las tareas anteriores a la nuestra, realizando una b√∫squeda por acci√≥n</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego ejecutamos nuestra acci√≥n. </font><font style="vertical-align: inherit;">Al final, solo necesita pedir que comience cada tarea, de lo contrario, nunca se sabe si algo no comenz√≥. </font><font style="vertical-align: inherit;">En este caso, nada comenz√≥. </font><font style="vertical-align: inherit;">Esta es la soluci√≥n </font><font style="vertical-align: inherit;">Este m√©todo est√° escrito en 10 minutos, es absolutamente obvio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, el c√≥digo asincr√≥nico tom√≥ nuestra decisi√≥n, inicialmente ocup√≥ un par de pantallas con c√≥digo competitivo complejo. </font><font style="vertical-align: inherit;">Aqu√≠ √©l es absolutamente consistente. </font><font style="vertical-align: inherit;">Ni siquiera lo uso </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uso el habitual </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque no le escribimos nada de forma competitiva. </font><font style="vertical-align: inherit;">Hay un c√≥digo consistente, consistente. </font><font style="vertical-align: inherit;">Solucionamos el problema de escribir c√≥digo paralelo usando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maravillosamente, lo que significa, sin errores.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desh√°gase de las cerraduras</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øVale la pena tirar de as√≠ncrono y estas cerraduras? Ahora hay todo tipo de bloqueos as√≠ncronos, sem√°foros as√≠ncronos, es decir, un intento de usar las primitivas que est√°n en c√≥digo s√≠ncrono y as√≠ncrono. Este concepto parece estar equivocado, porque con el bloqueo protege algo de la ejecuci√≥n paralela. Nuestra tarea es traducir la ejecuci√≥n paralela en secuencial, porque es m√°s f√°cil. Y si es m√°s simple, hay menos errores.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos crear alg√∫n canal y colocar un par de archivos y archivos procesados, y </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alg√∫n otro procedimiento </font><font style="vertical-align: inherit;">procesar√° este canal </font><font style="vertical-align: inherit;">, y lo har√° de forma secuencial. El bloqueo en s√≠ mismo, adem√°s de proteger la estructura, esencialmente linealiza el acceso, un lugar donde todos los hilos consecutivos se vuelven paralelos. Y estamos reemplazando esto expl√≠citamente con el canal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La arquitectura es la siguiente: los trabajadores reciben archivos </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y los env√≠an al procesador, que tambi√©n procesa todo secuencialmente, no hay paralelismo. El c√≥digo se ve mucho m√°s simple. Entiendo que no todo se puede hacer de esta manera. Dicha arquitectura, cuando puede construir canalizaciones de datos, no siempre funciona.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede ser que tenga un segundo canal que entre en su procesador y no se forme un gr√°fico dirigido ac√≠clico a partir de los canales, sino un gr√°fico con ciclos. </font><font style="vertical-align: inherit;">Este es un ejemplo que Roman Elizarov le dijo a KotlinConf en 2018. </font><font style="vertical-align: inherit;">Escribi√≥ un ejemplo en Kotlin con estos canales, y hubo ciclos all√≠, y este ejemplo se cerr√≥. </font><font style="vertical-align: inherit;">El problema era que si tienes tales ciclos en un gr√°fico, entonces todo se vuelve m√°s complicado en el mundo asincr√≥nico. </font><font style="vertical-align: inherit;">Los puntos muertos as√≠ncronos son malos porque son mucho m√°s dif√≠ciles de resolver que los s√≠ncronos cuando tienes una pila de subprocesos, y est√° claro de qu√© depende. </font><font style="vertical-align: inherit;">Por lo tanto, es una herramienta que debe usarse correctamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite la sincronizaci√≥n en c√≥digo asincr√≥nico.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo de serie es m√°s simple que el paralelo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo asincr√≥nico puede ser simple y usar un m√≠nimo de par√°metros y un contexto impl√≠cito que cambie su comportamiento.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ha desarrollado el h√°bito de escribir c√≥digo s√≠ncrono, e incluso si el c√≥digo as√≠ncrono es muy similar al s√≠ncrono, no necesita arrastrar primitivas all√≠, a lo que est√° acostumbrado en c√≥digo s√≠ncrono como </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Utilice feeds, si es posible, y otras primitivas de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paso de mensajes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo de serie es m√°s simple que el paralelo. Si puede escribir su arquitectura para que se vea secuencialmente, sin ejecutar c√≥digo paralelo y bloqueo, entonces escriba la arquitectura secuencialmente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y lo √∫ltimo que vimos de una gran cantidad de ejemplos con tareas. </font><font style="vertical-align: inherit;">Cuando dise√±e su sistema, trate de confiar menos en el contexto impl√≠cito. </font><font style="vertical-align: inherit;">El contexto impl√≠cito conduce a un malentendido de lo que est√° sucediendo en el c√≥digo, y puede olvidarse de los problemas impl√≠citos en un a√±o. </font><font style="vertical-align: inherit;">Y si otra persona trabaja en este c√≥digo y rehace algo en √©l, esto puede conducir a dificultades que una vez conoci√≥, y el nuevo programador no lo sabe debido al contexto impl√≠cito. </font><font style="vertical-align: inherit;">Como resultado, el dise√±o deficiente se caracteriza por una gran cantidad de par√°metros, su combinaci√≥n y contexto impl√≠cito.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que leer</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documento TAP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gu√≠a de asincs</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vidas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491218/index.html">Integraci√≥n de PVS-Studio en PlatformIO</a></li>
<li><a href="../es491224/index.html">Automatizaci√≥n de un servicio de despacho, o C√≥mo una empresa de servicios puede reducir los costos de transporte en un 30%</a></li>
<li><a href="../es491230/index.html">C√≥mo fui a la escuela 21 y la revelaci√≥n de secretos.</a></li>
<li><a href="../es491232/index.html">RPA + Machine Learning = Automatizaci√≥n inteligente</a></li>
<li><a href="../es491234/index.html">Tres trucos para trabajar con SOLIDWORKS para modelar piezas para impresi√≥n 3D</a></li>
<li><a href="../es491238/index.html">An√°lisis del C√≥digo Gen√©tico II</a></li>
<li><a href="../es491240/index.html">El camino hacia las nubes: ayer y hoy Adobe</a></li>
<li><a href="../es491244/index.html">No se necesita Ableton: conecte Ableton Push 2 al bastidor VCV</a></li>
<li><a href="../es491246/index.html">Conferencia 27 de DEFCON. Tu auto es mi auto. Parte 2</a></li>
<li><a href="../es491250/index.html">L√°mparas LED Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>