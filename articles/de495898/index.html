<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåå üöë üë®‚Äçüë®‚Äçüëß‚Äçüëß Eine praktische Anleitung zum Umgang mit Speicherlecks in Node.js. üëØ üò™ üë©üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speicherlecks √§hneln Entit√§ten, die in einer Anwendung parasit√§r sind. Sie dringen leise in das System ein, ohne Schaden zu verursachen. Wenn sich jed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Eine praktische Anleitung zum Umgang mit Speicherlecks in Node.js.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/495898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherlecks √§hneln Entit√§ten, die in einer Anwendung parasit√§r sind. </font><font style="vertical-align: inherit;">Sie dringen leise in das System ein, ohne Schaden zu verursachen. </font><font style="vertical-align: inherit;">Wenn sich jedoch herausstellt, dass das Leck stark genug ist, kann dies die Anwendung in eine Katastrophe bringen. </font><font style="vertical-align: inherit;">Zum Beispiel - um es stark zu verlangsamen oder einfach um es zu "t√∂ten". </font><font style="vertical-align: inherit;">
Der Autor des Artikels, dessen √úbersetzung wir heute ver√∂ffentlichen, schl√§gt vor, √ºber Speicherlecks in JavaScript zu sprechen. </font><font style="vertical-align: inherit;">Insbesondere werden wir √ºber die Speicherverwaltung in JavaScript, das Erkennen von Speicherlecks in realen Anwendungen und den Umgang mit Speicherlecks sprechen.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ut/sj/t-/utsjt-d80r9mqkvrexbbkws-eae.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist ein Speicherverlust?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Speicherverlust ist im weitesten Sinne ein Speicher, der einer Anwendung zugewiesen ist, die diese Anwendung nicht mehr ben√∂tigt, aber nicht zur zuk√ºnftigen Verwendung an das Betriebssystem zur√ºckgegeben werden kann. </font><font style="vertical-align: inherit;">Mit anderen Worten, es handelt sich um einen Speicherblock, der von der Anwendung erfasst wird, ohne dass beabsichtigt wird, diesen Speicher in Zukunft zu verwenden.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverwaltung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Speicherverwaltung ist ein Mechanismus zum Zuweisen von Systemspeicher zu einer Anwendung, die ihn ben√∂tigt, und ein Mechanismus zum Zur√ºckgeben von unn√∂tigem Speicher an das Betriebssystem. </font><font style="vertical-align: inherit;">Es gibt viele Ans√§tze zur Speicherverwaltung. </font><font style="vertical-align: inherit;">Welcher Ansatz verwendet wird, h√§ngt von der verwendeten Programmiersprache ab. </font><font style="vertical-align: inherit;">Hier ist eine √úbersicht √ºber einige g√§ngige Ans√§tze zur Speicherverwaltung:</font></font><br>
<br>
<ul>
<li>  .           .         .       ,    .        C  C++.   ,   ,   <code>malloc</code>  <code>free</code>,      .</li>
<li>   . ,      ,   ,       .   ,  ,    ,        . ,     ,  ,      ,   .         .  ‚Äî JavaScript, ,   JVM (Java, Scala, Kotlin), Golang, Python, Ruby  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendung des Konzepts des Eigentums an der Erinnerung. </font><font style="vertical-align: inherit;">Bei diesem Ansatz sollte jede Variable einen eigenen Eigent√ºmer haben. </font><font style="vertical-align: inherit;">Sobald der Eigent√ºmer den G√ºltigkeitsbereich verl√§sst, wird der Wert in der Variablen zerst√∂rt, wodurch Speicherplatz frei wird. </font><font style="vertical-align: inherit;">Diese Idee wird in Rust verwendet.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere Ans√§tze zur Speicherverwaltung, die in verschiedenen Programmiersprachen verwendet werden. </font><font style="vertical-align: inherit;">Beispielsweise verwendet C ++ 11 das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idiom </font><font style="vertical-align: inherit;">, w√§hrend Swift den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mechanismus verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber dar√ºber zu sprechen, w√ºrde den Rahmen dieses Artikels sprengen. </font><font style="vertical-align: inherit;">Um die oben genannten Methoden der Speicherverwaltung zu vergleichen und ihre Vor- und Nachteile zu verstehen, ben√∂tigen wir einen separaten Artikel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript, eine Sprache, ohne die sich Webprogrammierer ihre Arbeit nicht vorstellen k√∂nnen, verwendet die Idee der Speicherbereinigung. </font><font style="vertical-align: inherit;">Daher werden wir mehr dar√ºber sprechen, wie dieser Mechanismus funktioniert.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript-Speicherbereinigung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, ist JavaScript eine Sprache, die das Konzept der Speicherbereinigung verwendet. </font><font style="vertical-align: inherit;">W√§hrend des Betriebs von JS-Programmen wird regelm√§√üig ein Mechanismus gestartet, der als Garbage Collector bezeichnet wird. </font><font style="vertical-align: inherit;">Er findet aus dem Anwendungscode heraus, auf welche Teile des zugewiesenen Speichers zugegriffen werden kann. </font><font style="vertical-align: inherit;">Das hei√üt, auf welche Variablen verwiesen wird. </font><font style="vertical-align: inherit;">Wenn der Garbage Collector feststellt, dass √ºber den Anwendungscode nicht mehr auf ein Speicherelement zugegriffen wird, wird dieser Speicher freigegeben. </font><font style="vertical-align: inherit;">Der obige Ansatz kann unter Verwendung von zwei Hauptalgorithmen implementiert werden. </font><font style="vertical-align: inherit;">Der erste ist der sogenannte Mark and Sweep-Algorithmus. </font><font style="vertical-align: inherit;">Es wird in JavaScript verwendet. </font><font style="vertical-align: inherit;">Die zweite ist die Referenzz√§hlung. </font><font style="vertical-align: inherit;">Es wird in Python und PHP verwendet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/8ac/c60/3ee8acc608afe85e6a4c6f202cb1e8fe.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phasen Markierung (Markierung) und Sweep (Bereinigung) des Markierungs- und Sweep-</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Algorithmus Bei der Implementierung des Markierungsalgorithmus wird zuerst eine Liste von Wurzelknoten erstellt, die durch globale Umgebungsvariablen dargestellt werden (dies ist ein Objekt im Browser</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), und dann wird der resultierende Baum von Wurzel zu Blattknoten gecrawlt, die mit allen markiert sind auf dem Weg Objekte getroffen. </font><font style="vertical-align: inherit;">Der Speicher auf dem Heap, der von unbeschrifteten Objekten belegt wird, wird freigegeben.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherlecks in Node.js-Anwendungen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir gen√ºgend theoretische Konzepte in Bezug auf Speicherlecks und Speicherbereinigung analysiert. </font><font style="vertical-align: inherit;">Also - wir sind bereit zu sehen, wie alles in realen Anwendungen aussieht. </font><font style="vertical-align: inherit;">In diesem Abschnitt schreiben wir einen Node.js-Server mit einem Speicherverlust. </font><font style="vertical-align: inherit;">Wir werden versuchen, dieses Leck mit verschiedenen Werkzeugen zu identifizieren und es dann zu beseitigen.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Vertrautheit mit einem Code, der einen Speicherverlust aufweist</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Demonstrationszwecken habe ich einen Express-Server geschrieben, der eine Speicherverlustroute aufweist. </font><font style="vertical-align: inherit;">Wir werden diesen Server debuggen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Array </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das au√üerhalb des Bereichs des Verarbeitungscodes f√ºr API-Anforderungen liegt. </font><font style="vertical-align: inherit;">Infolgedessen werden jedes Mal, wenn der entsprechende Code ausgef√ºhrt wird, einfach neue Elemente zum Array hinzugef√ºgt. </font><font style="vertical-align: inherit;">Das Array wird niemals gel√∂scht. </font><font style="vertical-align: inherit;">Da die Verkn√ºpfung zu diesem Array nach dem Beenden des Anforderungshandlers nicht verschwindet, gibt der Garbage Collector den von ihm verwendeten Speicher niemals frei.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñçCall Memory Leak</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier kommen wir zu den interessantesten. Es wurden viele Artikel dar√ºber geschrieben, wie </font></font><code>node --inspect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Server-Speicherlecks beim Debuggen verwendet werden, nachdem der Server mit Anfragen wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artillerie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gef√ºllt wurde </font><font style="vertical-align: inherit;">. Dieser Ansatz hat jedoch einen wichtigen Nachteil. Stellen Sie sich vor, Sie haben einen API-Server mit Tausenden von Endpunkten. Jeder von ihnen ben√∂tigt viele Parameter. Der jeweilige Code, der aufgerufen wird, h√§ngt von dessen Funktionen ab. Wenn der Entwickler unter realen Bedingungen nicht wei√ü, wo sich der Speicherverlust befindet, muss er daher mehrmals auf jede API zugreifen und dabei alle m√∂glichen Kombinationen von Parametern verwenden, um den Speicher zu f√ºllen. F√ºr mich ist das nicht einfach. Die L√∂sung dieses Problems wird jedoch durch die Verwendung von so etwas erleichtert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goreplay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ein System, mit dem Sie echten Datenverkehr aufzeichnen und "abspielen" k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um unser Problem zu l√∂sen, werden wir das Debuggen in der Produktion durchf√ºhren. </font><font style="vertical-align: inherit;">Das hei√üt, wir erlauben unserem Server, den Speicher w√§hrend seiner tats√§chlichen Verwendung zu √ºberlaufen (da er eine Vielzahl von API-Anforderungen empf√§ngt). </font><font style="vertical-align: inherit;">Und nachdem wir einen verd√§chtigen Anstieg der zugewiesenen Speichermenge festgestellt haben, werden wir das Debuggen durchf√ºhren.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Heap Dump</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, was ein Heap-Dump ist, m√ºssen wir zuerst die Bedeutung des Konzepts eines Heaps herausfinden. Wenn Sie dieses Konzept so einfach wie m√∂glich beschreiben, stellt sich heraus, dass der Heap der Ort ist, an den alles f√§llt, was dem Speicher zugewiesen ist. All dies befindet sich auf dem Haufen, bis der Garbage Collector alles entfernt, was als unn√∂tig erachtet wird. Ein Heap-Dump ist eine Momentaufnahme des aktuellen Status des Heaps. Der Speicherauszug enth√§lt alle internen Variablen und Variablen, die vom Programmierer deklariert wurden. Es repr√§sentiert den gesamten Speicher, der zum Zeitpunkt des Empfangs des Speicherauszugs auf dem Heap zugewiesen war.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also den Heap-Dump des gerade gestarteten Servers mit dem Dump des Server-Heaps vergleichen k√∂nnten, der seit langer Zeit ausgef√ºhrt wird und √ºberf√ºllten Speicher verf√ºgt, k√∂nnten wir verd√§chtige Objekte identifizieren, die die Anwendung nicht ben√∂tigt, aber vom Garbage Collector nicht gel√∂scht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie die Konversation fortsetzen, wollen wir uns mit dem Erstellen von Heap-Dumps befassen. </font><font style="vertical-align: inherit;">Um dieses Problem zu l√∂sen, verwenden wir den npm-Paket- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heapdump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit dem Sie programmgesteuert einen Dump des Server-Heaps </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">abrufen</font></a><font style="vertical-align: inherit;"> k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installieren Sie das Paket:</font></font><br>
<br>
<pre><code class="bash hljs">npm i heapdump
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden einige √Ñnderungen am Servercode vornehmen, mit denen wir dieses Paket verwenden k√∂nnen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> heapdump = <span class="hljs-built_in">require</span>(<span class="hljs-string">"heapdump"</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.get(<span class="hljs-string">'/heapdump'</span>, (req, res) =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDump-<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a bloated server written to"</span>, filename);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">msg</span>: <span class="hljs-string">"successfully took a heap dump"</span>})<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDumpAtServerStart.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a fresh server written to"</span>, filename);<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir dieses Paket verwendet, um einen frisch gestarteten Server zu sichern. </font><font style="vertical-align: inherit;">Wir haben auch eine API erstellt </font></font><code>/heapdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der beim Zugriff ein Heap erstellt werden kann. </font><font style="vertical-align: inherit;">Wir werden uns dieser API in dem Moment zuwenden, in dem wir feststellen, dass der Server zu viel Speicher belegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Server in einem Kubernetes-Cluster ausgef√ºhrt wird, k√∂nnen Sie sich nicht ohne zus√§tzlichen Aufwand an den Pod wenden, dessen Server ausgef√ºhrt wird und auf dem zu viel Speicher belegt ist. </font><font style="vertical-align: inherit;">Zu diesem Zweck k√∂nnen Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portweiterleitung verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Da Sie keinen Zugriff auf das Dateisystem haben, das Sie zum Herunterladen von Dump-Dateien ben√∂tigen, ist es au√üerdem besser, diese Dateien in einen externen Cloud-Speicher (wie S3) hochzuladen.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Speicherverlusterkennung</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt wird der Server bereitgestellt. Er arbeitet seit mehreren Tagen. Es werden viele Anfragen empfangen (in unserem Fall nur Anfragen desselben Typs), und wir haben auf die Zunahme des vom Server verbrauchten Arbeitsspeichers geachtet. Ein Speicherverlust kann mithilfe von √úberwachungstools wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Express Status Monitor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clinic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erkannt werden </font><font style="vertical-align: inherit;">. Danach rufen wir die API auf, um den Heap zu sichern. Dieser Speicherauszug enth√§lt alle Objekte, die der Garbage Collector nicht l√∂schen konnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Abfrage aus, um einen Speicherauszug zu erstellen:</font></font><br>
<br>
<pre><code class="bash hljs">curl --location --request GET <span class="hljs-string">'http://localhost:3000/heapdump'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Heap-Dump erstellt wird, muss der Garbage Collector ausgef√ºhrt werden. Infolgedessen m√ºssen wir uns keine Gedanken √ºber die Objekte machen, die m√∂glicherweise in Zukunft vom Garbage Collector entfernt werden, sich aber noch auf dem Heap befinden. Das hei√üt - √ºber die Objekte, mit denen bei der Arbeit keine Speicherlecks auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir beide Dumps zur Verf√ºgung haben (einen Dump eines frisch gestarteten Servers und einen Dump eines Servers, der seit einiger Zeit funktioniert hat), k√∂nnen wir beginnen, sie zu vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Abrufen eines Speicherauszugs ist ein Blockierungsvorgang, f√ºr dessen Ausf√ºhrung viel Speicher erforderlich ist. Daher muss es mit Vorsicht durchgef√ºhrt werden. Weitere Informationen zu m√∂glichen Problemen bei diesem Vorgang finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starten Sie Chrome und dr√ºcken Sie die Taste.</font></font><code>F12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies wird zur Entdeckung von Entwicklertools f√ºhren. </font><font style="vertical-align: inherit;">Hier m√ºssen Sie zur Registerkarte gehen </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und beide Snapshots des Speichers laden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/252/992/5c125299224be08bb5bb73f74842f0b8.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher Download - </font><font style="vertical-align: inherit;">Dumps auf der Registerkarte Speicher der Chrome - </font><font style="vertical-align: inherit;">Entwickler - </font><font style="vertical-align: inherit;">Tools</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem beide Schnappsch√ºsse herunterzuladen, m√ºssen Sie √§ndern</font></font><code>perspective</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu</font></font><code>Comparison</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und klicken Sie auf den Snapshot des Speichers des Servers,</font><font style="vertical-align: inherit;">f√ºr einige Zeit gearbeitet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/7c7/224/a997c7224ac3d053651be9e848380e75.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen Sie Snapshots.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hier k√∂nnen Sie die Spalte analysieren</font></font><code>Constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nach Objekten suchen, die der Garbage Collector nicht entfernen kann. </font><font style="vertical-align: inherit;">Die meisten dieser Objekte werden durch interne Links dargestellt, die von Knoten verwendet werden. </font><font style="vertical-align: inherit;">Hier ist es n√ºtzlich, einen Trick zu verwenden, der darin besteht, die Liste nach Feldern zu sortieren</font></font><code>Alloc. Size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch werden schnell die Objekte gefunden, die den meisten Speicher belegen. </font><font style="vertical-align: inherit;">Wenn Sie den Block erweitern</font></font><code>(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann -</font></font><code>(object elements)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehen Sie ein Array</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer gro√üen Anzahl von Objekten, die mit dem Garbage Collector nicht gel√∂scht werden k√∂nnen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e85/02c/0a2/e8502c0a2dcd1cf635f229eaef8d9e90.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse eines verd√§chtigen Arrays Mit</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
dieser Technik k√∂nnen wir zum Array gehen</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verstehen, dass es die falsche Operation ist, die einen Speicherverlust verursacht.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñçSpeicherverlust beheben</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da wir wissen, dass der "T√§ter" ein Array ist </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen wir den Code analysieren und herausfinden, dass das Problem darin besteht, dass das Array au√üerhalb des Anforderungshandlers deklariert ist. </font><font style="vertical-align: inherit;">Infolgedessen stellt sich heraus, dass der Link dazu niemals gel√∂scht wird. </font><font style="vertical-align: inherit;">Das Problem zu beheben ist ganz einfach: √úbertragen Sie einfach die Deklaration des Arrays an den Handler:</font></font><br>
<br>
<pre><code class="javascript hljs">app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Wirksamkeit der ergriffenen Ma√ünahmen zu √ºberpr√ºfen, reicht es aus, die obigen Schritte zu wiederholen und die Heap-Bilder erneut zu vergleichen.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speicherlecks treten in verschiedenen Sprachen auf. </font><font style="vertical-align: inherit;">Insbesondere in - solchen, die Garbage Collection-Mechanismen verwenden. </font><font style="vertical-align: inherit;">Zum Beispiel in JavaScript. </font><font style="vertical-align: inherit;">Es ist normalerweise nicht schwierig, ein Leck zu beheben - die wirklichen Schwierigkeiten treten nur auf, wenn Sie danach suchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben Sie sich mit den Grundlagen der Speicherverwaltung und der Organisation der Speicherverwaltung in verschiedenen Sprachen vertraut gemacht. </font><font style="vertical-align: inherit;">Hier haben wir ein reales Szenario eines Speicherverlusts reproduziert und eine Methode zur Fehlerbehebung beschrieben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liebe Leser! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind in Ihren Webprojekten Speicherlecks aufgetreten?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495888/index.html">PyCon Russia hat die GFP f√ºr zuk√ºnftige Redner ge√∂ffnet. Teilnahmeformulare und erwartete Themen</a></li>
<li><a href="../de495890/index.html">Konfigurieren eines Nginx / LetsEncrypt-Bundles in Docker Swarm</a></li>
<li><a href="../de495892/index.html">Wissen Sie wirklich, was Arrays sind?</a></li>
<li><a href="../de495894/index.html">Javascript-Leistungsmessung</a></li>
<li><a href="../de495896/index.html">Use-Sound-Paket: Soundeffekte in React-Anwendungen</a></li>
<li><a href="../de495902/index.html">CAPTCHA: Bekehrung t√∂ten</a></li>
<li><a href="../de495904/index.html">Kann eine Epidemie vorhergesagt werden?</a></li>
<li><a href="../de495908/index.html">Der Weg zur Belohnung</a></li>
<li><a href="../de495910/index.html">Installieren von ROS in einem Ubuntu Single-Board IMG-Image</a></li>
<li><a href="../de495912/index.html">Intelligente Wiederholungsaufkleber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>