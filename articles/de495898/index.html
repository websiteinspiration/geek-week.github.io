<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌌 🚑 👨‍👨‍👧‍👧 Eine praktische Anleitung zum Umgang mit Speicherlecks in Node.js. 👯 😪 👩🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speicherlecks ähneln Entitäten, die in einer Anwendung parasitär sind. Sie dringen leise in das System ein, ohne Schaden zu verursachen. Wenn sich jed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Eine praktische Anleitung zum Umgang mit Speicherlecks in Node.js.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/495898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherlecks ähneln Entitäten, die in einer Anwendung parasitär sind. </font><font style="vertical-align: inherit;">Sie dringen leise in das System ein, ohne Schaden zu verursachen. </font><font style="vertical-align: inherit;">Wenn sich jedoch herausstellt, dass das Leck stark genug ist, kann dies die Anwendung in eine Katastrophe bringen. </font><font style="vertical-align: inherit;">Zum Beispiel - um es stark zu verlangsamen oder einfach um es zu "töten". </font><font style="vertical-align: inherit;">
Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, schlägt vor, über Speicherlecks in JavaScript zu sprechen. </font><font style="vertical-align: inherit;">Insbesondere werden wir über die Speicherverwaltung in JavaScript, das Erkennen von Speicherlecks in realen Anwendungen und den Umgang mit Speicherlecks sprechen.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ut/sj/t-/utsjt-d80r9mqkvrexbbkws-eae.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist ein Speicherverlust?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Speicherverlust ist im weitesten Sinne ein Speicher, der einer Anwendung zugewiesen ist, die diese Anwendung nicht mehr benötigt, aber nicht zur zukünftigen Verwendung an das Betriebssystem zurückgegeben werden kann. </font><font style="vertical-align: inherit;">Mit anderen Worten, es handelt sich um einen Speicherblock, der von der Anwendung erfasst wird, ohne dass beabsichtigt wird, diesen Speicher in Zukunft zu verwenden.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverwaltung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Speicherverwaltung ist ein Mechanismus zum Zuweisen von Systemspeicher zu einer Anwendung, die ihn benötigt, und ein Mechanismus zum Zurückgeben von unnötigem Speicher an das Betriebssystem. </font><font style="vertical-align: inherit;">Es gibt viele Ansätze zur Speicherverwaltung. </font><font style="vertical-align: inherit;">Welcher Ansatz verwendet wird, hängt von der verwendeten Programmiersprache ab. </font><font style="vertical-align: inherit;">Hier ist eine Übersicht über einige gängige Ansätze zur Speicherverwaltung:</font></font><br>
<br>
<ul>
<li>  .           .         .       ,    .        C  C++.   ,   ,   <code>malloc</code>  <code>free</code>,      .</li>
<li>   . ,      ,   ,       .   ,  ,    ,        . ,     ,  ,      ,   .         .  — JavaScript, ,   JVM (Java, Scala, Kotlin), Golang, Python, Ruby  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendung des Konzepts des Eigentums an der Erinnerung. </font><font style="vertical-align: inherit;">Bei diesem Ansatz sollte jede Variable einen eigenen Eigentümer haben. </font><font style="vertical-align: inherit;">Sobald der Eigentümer den Gültigkeitsbereich verlässt, wird der Wert in der Variablen zerstört, wodurch Speicherplatz frei wird. </font><font style="vertical-align: inherit;">Diese Idee wird in Rust verwendet.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere Ansätze zur Speicherverwaltung, die in verschiedenen Programmiersprachen verwendet werden. </font><font style="vertical-align: inherit;">Beispielsweise verwendet C ++ 11 das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idiom </font><font style="vertical-align: inherit;">, während Swift den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mechanismus verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber darüber zu sprechen, würde den Rahmen dieses Artikels sprengen. </font><font style="vertical-align: inherit;">Um die oben genannten Methoden der Speicherverwaltung zu vergleichen und ihre Vor- und Nachteile zu verstehen, benötigen wir einen separaten Artikel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript, eine Sprache, ohne die sich Webprogrammierer ihre Arbeit nicht vorstellen können, verwendet die Idee der Speicherbereinigung. </font><font style="vertical-align: inherit;">Daher werden wir mehr darüber sprechen, wie dieser Mechanismus funktioniert.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript-Speicherbereinigung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, ist JavaScript eine Sprache, die das Konzept der Speicherbereinigung verwendet. </font><font style="vertical-align: inherit;">Während des Betriebs von JS-Programmen wird regelmäßig ein Mechanismus gestartet, der als Garbage Collector bezeichnet wird. </font><font style="vertical-align: inherit;">Er findet aus dem Anwendungscode heraus, auf welche Teile des zugewiesenen Speichers zugegriffen werden kann. </font><font style="vertical-align: inherit;">Das heißt, auf welche Variablen verwiesen wird. </font><font style="vertical-align: inherit;">Wenn der Garbage Collector feststellt, dass über den Anwendungscode nicht mehr auf ein Speicherelement zugegriffen wird, wird dieser Speicher freigegeben. </font><font style="vertical-align: inherit;">Der obige Ansatz kann unter Verwendung von zwei Hauptalgorithmen implementiert werden. </font><font style="vertical-align: inherit;">Der erste ist der sogenannte Mark and Sweep-Algorithmus. </font><font style="vertical-align: inherit;">Es wird in JavaScript verwendet. </font><font style="vertical-align: inherit;">Die zweite ist die Referenzzählung. </font><font style="vertical-align: inherit;">Es wird in Python und PHP verwendet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/8ac/c60/3ee8acc608afe85e6a4c6f202cb1e8fe.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phasen Markierung (Markierung) und Sweep (Bereinigung) des Markierungs- und Sweep-</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Algorithmus Bei der Implementierung des Markierungsalgorithmus wird zuerst eine Liste von Wurzelknoten erstellt, die durch globale Umgebungsvariablen dargestellt werden (dies ist ein Objekt im Browser</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), und dann wird der resultierende Baum von Wurzel zu Blattknoten gecrawlt, die mit allen markiert sind auf dem Weg Objekte getroffen. </font><font style="vertical-align: inherit;">Der Speicher auf dem Heap, der von unbeschrifteten Objekten belegt wird, wird freigegeben.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherlecks in Node.js-Anwendungen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir genügend theoretische Konzepte in Bezug auf Speicherlecks und Speicherbereinigung analysiert. </font><font style="vertical-align: inherit;">Also - wir sind bereit zu sehen, wie alles in realen Anwendungen aussieht. </font><font style="vertical-align: inherit;">In diesem Abschnitt schreiben wir einen Node.js-Server mit einem Speicherverlust. </font><font style="vertical-align: inherit;">Wir werden versuchen, dieses Leck mit verschiedenen Werkzeugen zu identifizieren und es dann zu beseitigen.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Vertrautheit mit einem Code, der einen Speicherverlust aufweist</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Demonstrationszwecken habe ich einen Express-Server geschrieben, der eine Speicherverlustroute aufweist. </font><font style="vertical-align: inherit;">Wir werden diesen Server debuggen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Array </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das außerhalb des Bereichs des Verarbeitungscodes für API-Anforderungen liegt. </font><font style="vertical-align: inherit;">Infolgedessen werden jedes Mal, wenn der entsprechende Code ausgeführt wird, einfach neue Elemente zum Array hinzugefügt. </font><font style="vertical-align: inherit;">Das Array wird niemals gelöscht. </font><font style="vertical-align: inherit;">Da die Verknüpfung zu diesem Array nach dem Beenden des Anforderungshandlers nicht verschwindet, gibt der Garbage Collector den von ihm verwendeten Speicher niemals frei.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Call Memory Leak</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier kommen wir zu den interessantesten. Es wurden viele Artikel darüber geschrieben, wie </font></font><code>node --inspect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Server-Speicherlecks beim Debuggen verwendet werden, nachdem der Server mit Anfragen wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artillerie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gefüllt wurde </font><font style="vertical-align: inherit;">. Dieser Ansatz hat jedoch einen wichtigen Nachteil. Stellen Sie sich vor, Sie haben einen API-Server mit Tausenden von Endpunkten. Jeder von ihnen benötigt viele Parameter. Der jeweilige Code, der aufgerufen wird, hängt von dessen Funktionen ab. Wenn der Entwickler unter realen Bedingungen nicht weiß, wo sich der Speicherverlust befindet, muss er daher mehrmals auf jede API zugreifen und dabei alle möglichen Kombinationen von Parametern verwenden, um den Speicher zu füllen. Für mich ist das nicht einfach. Die Lösung dieses Problems wird jedoch durch die Verwendung von so etwas erleichtert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goreplay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ein System, mit dem Sie echten Datenverkehr aufzeichnen und "abspielen" können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um unser Problem zu lösen, werden wir das Debuggen in der Produktion durchführen. </font><font style="vertical-align: inherit;">Das heißt, wir erlauben unserem Server, den Speicher während seiner tatsächlichen Verwendung zu überlaufen (da er eine Vielzahl von API-Anforderungen empfängt). </font><font style="vertical-align: inherit;">Und nachdem wir einen verdächtigen Anstieg der zugewiesenen Speichermenge festgestellt haben, werden wir das Debuggen durchführen.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Heap Dump</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, was ein Heap-Dump ist, müssen wir zuerst die Bedeutung des Konzepts eines Heaps herausfinden. Wenn Sie dieses Konzept so einfach wie möglich beschreiben, stellt sich heraus, dass der Heap der Ort ist, an den alles fällt, was dem Speicher zugewiesen ist. All dies befindet sich auf dem Haufen, bis der Garbage Collector alles entfernt, was als unnötig erachtet wird. Ein Heap-Dump ist eine Momentaufnahme des aktuellen Status des Heaps. Der Speicherauszug enthält alle internen Variablen und Variablen, die vom Programmierer deklariert wurden. Es repräsentiert den gesamten Speicher, der zum Zeitpunkt des Empfangs des Speicherauszugs auf dem Heap zugewiesen war.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also den Heap-Dump des gerade gestarteten Servers mit dem Dump des Server-Heaps vergleichen könnten, der seit langer Zeit ausgeführt wird und überfüllten Speicher verfügt, könnten wir verdächtige Objekte identifizieren, die die Anwendung nicht benötigt, aber vom Garbage Collector nicht gelöscht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie die Konversation fortsetzen, wollen wir uns mit dem Erstellen von Heap-Dumps befassen. </font><font style="vertical-align: inherit;">Um dieses Problem zu lösen, verwenden wir den npm-Paket- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heapdump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit dem Sie programmgesteuert einen Dump des Server-Heaps </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">abrufen</font></a><font style="vertical-align: inherit;"> können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installieren Sie das Paket:</font></font><br>
<br>
<pre><code class="bash hljs">npm i heapdump
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden einige Änderungen am Servercode vornehmen, mit denen wir dieses Paket verwenden können:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> heapdump = <span class="hljs-built_in">require</span>(<span class="hljs-string">"heapdump"</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.get(<span class="hljs-string">'/heapdump'</span>, (req, res) =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDump-<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a bloated server written to"</span>, filename);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">msg</span>: <span class="hljs-string">"successfully took a heap dump"</span>})<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDumpAtServerStart.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a fresh server written to"</span>, filename);<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir dieses Paket verwendet, um einen frisch gestarteten Server zu sichern. </font><font style="vertical-align: inherit;">Wir haben auch eine API erstellt </font></font><code>/heapdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der beim Zugriff ein Heap erstellt werden kann. </font><font style="vertical-align: inherit;">Wir werden uns dieser API in dem Moment zuwenden, in dem wir feststellen, dass der Server zu viel Speicher belegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Server in einem Kubernetes-Cluster ausgeführt wird, können Sie sich nicht ohne zusätzlichen Aufwand an den Pod wenden, dessen Server ausgeführt wird und auf dem zu viel Speicher belegt ist. </font><font style="vertical-align: inherit;">Zu diesem Zweck können Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portweiterleitung verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Da Sie keinen Zugriff auf das Dateisystem haben, das Sie zum Herunterladen von Dump-Dateien benötigen, ist es außerdem besser, diese Dateien in einen externen Cloud-Speicher (wie S3) hochzuladen.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Speicherverlusterkennung</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt wird der Server bereitgestellt. Er arbeitet seit mehreren Tagen. Es werden viele Anfragen empfangen (in unserem Fall nur Anfragen desselben Typs), und wir haben auf die Zunahme des vom Server verbrauchten Arbeitsspeichers geachtet. Ein Speicherverlust kann mithilfe von Überwachungstools wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Express Status Monitor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clinic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erkannt werden </font><font style="vertical-align: inherit;">. Danach rufen wir die API auf, um den Heap zu sichern. Dieser Speicherauszug enthält alle Objekte, die der Garbage Collector nicht löschen konnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Abfrage aus, um einen Speicherauszug zu erstellen:</font></font><br>
<br>
<pre><code class="bash hljs">curl --location --request GET <span class="hljs-string">'http://localhost:3000/heapdump'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Heap-Dump erstellt wird, muss der Garbage Collector ausgeführt werden. Infolgedessen müssen wir uns keine Gedanken über die Objekte machen, die möglicherweise in Zukunft vom Garbage Collector entfernt werden, sich aber noch auf dem Heap befinden. Das heißt - über die Objekte, mit denen bei der Arbeit keine Speicherlecks auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir beide Dumps zur Verfügung haben (einen Dump eines frisch gestarteten Servers und einen Dump eines Servers, der seit einiger Zeit funktioniert hat), können wir beginnen, sie zu vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Abrufen eines Speicherauszugs ist ein Blockierungsvorgang, für dessen Ausführung viel Speicher erforderlich ist. Daher muss es mit Vorsicht durchgeführt werden. Weitere Informationen zu möglichen Problemen bei diesem Vorgang finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starten Sie Chrome und drücken Sie die Taste.</font></font><code>F12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies wird zur Entdeckung von Entwicklertools führen. </font><font style="vertical-align: inherit;">Hier müssen Sie zur Registerkarte gehen </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und beide Snapshots des Speichers laden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/252/992/5c125299224be08bb5bb73f74842f0b8.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher Download - </font><font style="vertical-align: inherit;">Dumps auf der Registerkarte Speicher der Chrome - </font><font style="vertical-align: inherit;">Entwickler - </font><font style="vertical-align: inherit;">Tools</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem beide Schnappschüsse herunterzuladen, müssen Sie ändern</font></font><code>perspective</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu</font></font><code>Comparison</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und klicken Sie auf den Snapshot des Speichers des Servers,</font><font style="vertical-align: inherit;">für einige Zeit gearbeitet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/7c7/224/a997c7224ac3d053651be9e848380e75.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen Sie Snapshots.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hier können Sie die Spalte analysieren</font></font><code>Constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nach Objekten suchen, die der Garbage Collector nicht entfernen kann. </font><font style="vertical-align: inherit;">Die meisten dieser Objekte werden durch interne Links dargestellt, die von Knoten verwendet werden. </font><font style="vertical-align: inherit;">Hier ist es nützlich, einen Trick zu verwenden, der darin besteht, die Liste nach Feldern zu sortieren</font></font><code>Alloc. Size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch werden schnell die Objekte gefunden, die den meisten Speicher belegen. </font><font style="vertical-align: inherit;">Wenn Sie den Block erweitern</font></font><code>(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann -</font></font><code>(object elements)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehen Sie ein Array</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer großen Anzahl von Objekten, die mit dem Garbage Collector nicht gelöscht werden können.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e85/02c/0a2/e8502c0a2dcd1cf635f229eaef8d9e90.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse eines verdächtigen Arrays Mit</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
dieser Technik können wir zum Array gehen</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verstehen, dass es die falsche Operation ist, die einen Speicherverlust verursacht.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Speicherverlust beheben</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da wir wissen, dass der "Täter" ein Array ist </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können wir den Code analysieren und herausfinden, dass das Problem darin besteht, dass das Array außerhalb des Anforderungshandlers deklariert ist. </font><font style="vertical-align: inherit;">Infolgedessen stellt sich heraus, dass der Link dazu niemals gelöscht wird. </font><font style="vertical-align: inherit;">Das Problem zu beheben ist ganz einfach: Übertragen Sie einfach die Deklaration des Arrays an den Handler:</font></font><br>
<br>
<pre><code class="javascript hljs">app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Wirksamkeit der ergriffenen Maßnahmen zu überprüfen, reicht es aus, die obigen Schritte zu wiederholen und die Heap-Bilder erneut zu vergleichen.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speicherlecks treten in verschiedenen Sprachen auf. </font><font style="vertical-align: inherit;">Insbesondere in - solchen, die Garbage Collection-Mechanismen verwenden. </font><font style="vertical-align: inherit;">Zum Beispiel in JavaScript. </font><font style="vertical-align: inherit;">Es ist normalerweise nicht schwierig, ein Leck zu beheben - die wirklichen Schwierigkeiten treten nur auf, wenn Sie danach suchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben Sie sich mit den Grundlagen der Speicherverwaltung und der Organisation der Speicherverwaltung in verschiedenen Sprachen vertraut gemacht. </font><font style="vertical-align: inherit;">Hier haben wir ein reales Szenario eines Speicherverlusts reproduziert und eine Methode zur Fehlerbehebung beschrieben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liebe Leser! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind in Ihren Webprojekten Speicherlecks aufgetreten?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495888/index.html">PyCon Russia hat die GFP für zukünftige Redner geöffnet. Teilnahmeformulare und erwartete Themen</a></li>
<li><a href="../de495890/index.html">Konfigurieren eines Nginx / LetsEncrypt-Bundles in Docker Swarm</a></li>
<li><a href="../de495892/index.html">Wissen Sie wirklich, was Arrays sind?</a></li>
<li><a href="../de495894/index.html">Javascript-Leistungsmessung</a></li>
<li><a href="../de495896/index.html">Use-Sound-Paket: Soundeffekte in React-Anwendungen</a></li>
<li><a href="../de495902/index.html">CAPTCHA: Bekehrung töten</a></li>
<li><a href="../de495904/index.html">Kann eine Epidemie vorhergesagt werden?</a></li>
<li><a href="../de495908/index.html">Der Weg zur Belohnung</a></li>
<li><a href="../de495910/index.html">Installieren von ROS in einem Ubuntu Single-Board IMG-Image</a></li>
<li><a href="../de495912/index.html">Intelligente Wiederholungsaufkleber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>