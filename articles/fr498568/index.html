<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏭 🗯️ 👩🏾‍💼 À l'intérieur du microprocesseur sectionnel multipuce AM2901 des années 1970 d'AMD 🤶🏾 👨🏿‍🎓 🍻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À l'intérieur du microprocesseur sectionnel multipuce AMD Am2901 des années 1970, 
 
 vous connaissez peut-être les processeurs avancés fabriqués par ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>À l'intérieur du microprocesseur sectionnel multipuce AM2901 des années 1970 d'AMD</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498568/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'intérieur du microprocesseur sectionnel multipuce AMD Am2901 des années 1970, </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vous connaissez peut-être les processeurs avancés fabriqués par Advanced Micro Devices. Mais AMD a commencé à produire des processeurs en 1975 lorsqu'il a présenté pour la première fois son Am2901. C'était le soi-disant processeur sectionnel multi-puces: chaque puce a traité 4 bits, et pour augmenter la taille des mots, plusieurs puces ont été utilisées simultanément. Cette approche a été utilisée dans les années 1970 et 1980 pour créer des processeurs 16, 32 ou 64 bits (par exemple), alors qu'ils ne pouvaient pas placer l'ensemble du processeur sur une seule puce rapide. Il y avait des processeurs sur la même puce, mais leur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les transistors fonctionnaient plus lentement. Au fil du temps, les processeurs CMOS sont devenus plus rapides que les processeurs à transistors bipolaires, et lorsque leur vitesse a suffisamment augmenté, presque tous les fabricants sont passés à eux. </font><i><font style="vertical-align: inherit;">Photo d'un cristal avec une puce Am2901. Les couches métalliques de la puce sont visibles; le silicium est au fond. Aux bords du cristal, de minuscules conducteurs relient la puce à des contacts externes.</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/pu/kb/yt/pukbytzadj8mboqwhicko7mpdia.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La puce Am2901 a gagné en popularité, elle a été utilisée dans une variété de systèmes, du jeu vidéo Battlezone au mini-ordinateur VAX-11/730, de la station de travail Xerox Star à l'ordinateur de bord Magic 372 du F-16 Fighter. Une version plus rapide de ce processeur, l'Am2901C, a utilisé la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logique couplée à l'émetteur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ESL) pour améliorer les performances. Dans cet article, je dissèque l'Am2901C, examine son cristal au microscope et explique comment les circuits ESL permettent de mettre en œuvre une unité arithmétique et logique (ALU).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, dans la documentation d'Atari Battlezone, il n'est pas fait mention d'un modèle spécifique de la puce Am2901, mais il y a une note de bas de page pour la référence 137004-001, qu'ils appellent le «réseau de transistors». </font><font style="vertical-align: inherit;">De plus, des distorsions intentionnelles ont été faites dans le diagramme de brochage donné de la puce, et 20 broches d'adresse et 8 broches de données sont représentées pour donner à la puce un aspect ROM (contrairement, par exemple, aux puces de la série 7400 décrites exactement). </font><font style="vertical-align: inherit;">Atari a peut-être tenté d'empêcher le clonage de ses jeux vidéo en cachant les modèles de certaines puces clés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La puce </font><font style="vertical-align: inherit;">ALU </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74181</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> était une alternative populaire à l'Am2901 dans de nombreux micro-ordinateurs </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il fournissait les mêmes fonctions arithmétiques et logiques que l'Am2901, mais pas ses registres.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microprocesseur sectionnel à puces multiples</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous vous demandez peut-être comment plusieurs puces de processeur peuvent fonctionner ensemble et prendre en charge des mots de longueur arbitraire. L'essentiel est que la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">section</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">microprocesseur</font></a><font style="vertical-align: inherit;"> (MS) est une brique de construction, pas le processeur entier, et qu'elle a besoin de circuits séparés pour décoder les instructions et contrôler le système. Le MS avait des registres, ils effectuaient des opérations arithmétiques et logiques avec les données, et la puce de contrôle (comme Am2901) disait au MS quoi faire. Chaque instruction machine a été divisée en étapes plus petites, des micro-instructions stockées dans le microcode ROM. Dans ce cas, l'ensemble d'instructions a été déterminé par le microcode et non par Am2901, donc </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presque n'importe quel ensemble d'instructions a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pu être pris en charge </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Du fait que les sections d'un tel processeur ne sont pas complètement indépendantes les unes des autres, certaines difficultés surviennent lors du fonctionnement du processeur. Par exemple, lors de l'ajout de deux numéros, le transfert d'une section doit être transféré vers une autre. De plus, le travail conjoint de plusieurs sections nécessite des opérations telles que la vérification d'un signe ou la recherche d'un résultat nul. La puce Am2901 possède des sorties spéciales pour prendre en charge ces fonctions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'Am2901 est-il un microprocesseur? De mon point de vue, l'Am2901 n'est qu'une partie du processeur, mais tout dépend de la façon de déterminer le «microprocesseur» (j'ai décrit mes réflexions à ce sujet en détail dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article séparé</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Fait intéressant, en URSS, ils étaient plus enclins aux microprocesseurs sectionnels qu'aux États-Unis. Et si en Occident le mot «microprocesseur» signifie généralement un processeur sur une seule puce, en URSS, les processeurs sur une seule puce ou de plusieurs sections n'étaient </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">généralement pas distingués</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les microprocesseurs sectionnels à puces multiples (MSM) se situaient quelque part entre les puces de microprocesseur et un ordinateur fabriqué à partir de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">TTL</font></a><font style="vertical-align: inherit;"> simples</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chips. </font><font style="vertical-align: inherit;">À cette époque, assembler un ordinateur à partir de puces TTL était beaucoup plus rapide que de fabriquer un microprocesseur, mais cela nécessitait beaucoup de cartes avec des puces. </font><font style="vertical-align: inherit;">L'utilisation de MSM a permis de conserver l'avantage en vitesse, tout en réduisant le nombre de puces utilisées. </font><font style="vertical-align: inherit;">MSM a également fourni une plus grande flexibilité par rapport au microprocesseur, permettant au concepteur de personnaliser l'ensemble d'instructions et d'autres caractéristiques architecturales.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Présentation de Crystal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La photo ci-dessous montre le cristal Am2901 et met en évidence les principaux blocs fonctionnels. Pour cette photo, j'ai retiré les couches métalliques pour que le silicium et les transistors soient visibles. Le bloc fonctionnel le plus grand de la puce est la mémoire de registre au centre. La puce possède 16 registres 4 bits (vous pouvez voir 16 colonnes et 4 lignes dans la matrice mémoire). À gauche et à droite du bloc de mémoire se trouvent les circuits pilotes de mémoire qui contrôlent l'écriture et la lecture. </font><i><font style="vertical-align: inherit;">Cristal photo Am2901; Les blocs fonctionnels clés sont marqués. Les circuits externes se composent principalement de tampons qui convertissent les signaux entre les TTL externes et les ESL internes. </font></i><i><font style="vertical-align: inherit;">Organigramme complet de l'Am2901</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/yo/3q/wx/yo3qwxlpuizsyweaio3_r95owtm.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/dp/m4/x8/dpm4x8wwtf1uv6-_6-shxaqnpzk.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le dispositif logique arithmétique (ALU) de la puce est engagé dans des opérations arithmétiques (addition et soustraction) et logiques (ET, OU, à l'exclusion de OU). La première section de l'ALU est un grand bloc en bas à gauche; il se compose de quatre lignes, car il s'agit d'une ALU 4 bits. ALU possède également une logique qui génère une sortie de report à ajouter, et utilise une technique rapide appelée «lookahead de report». Ensuite, l'ALU utilise les valeurs transférées pour générer la somme en parallèle. Enfin, les circuits de sortie traitent et tamponnent la quantité, et l'envoient au contact de sortie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un transfert avec prévisualisation utilise les signaux Générer et Propager pour déterminer si un bit à chaque position produit son propre transfert ou passe le signal entrant. Par exemple, si vous ajoutez 0 + 0 + C (C est le transfert), le transfert ne peut pas être éliminé de cet ajout, quelle que soit sa taille. En revanche, si vous ajoutez 1 + 1 + C, le transfert apparaîtra de toute façon, quel que soit C. Enfin, dans les cas 0 + 1 + C (ou 1 + 0 + C), le transfert sera transféré plus loin si C était différent de zéro. Par conséquent, des portes logiques simples créent un signal G (Générer) pour chaque bit si les deux bits sont égaux à 1 et un signal P (Propager) si les deux bits ne sont pas égaux à 0.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La formule de transfert dépend de l'emplacement du bit. Par exemple, envisagez de transférer du bit 0 au bit 1. Cela se produira si l'indicateur P0 est défini (c'est-à-dire que le transfert est apparu ou est en cours de transmission), et si son transfert est apparu dans ce bit, ou s'il lui est parvenu à partir d'autres bits. Alors C1 = P0 ET (Cin OU G0). Dans la césure d'ordre supérieur, le nombre d'options augmente et leur complexité augmente constamment. Par exemple, considérons un transfert vers le bit 2. Premièrement, P1 doit être armé pour que le transfert passe du bit 1. De plus, le transfert a été créé par le bit 1 ou transféré du bit 0. Enfin, le premier transfert devait également provenir de quelque part prenez-le: c'était soit un transfert provenant du bit 0, soit un transfert généré par le bit 1. Si vous mettez tout cela dans une formule, vous obtenez la fonction utilisée dans Am2901: C2 = P1 ET (G1 OU P0) ET (C0 OU G0 OU G1).Les formules des différents transferts et des P et G externes sont données dans</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spécifications</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , fig. </font><font style="vertical-align: inherit;">9. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les rectangles vides sur les bords de la puce sont des zones de connexion de la puce au monde extérieur. </font><font style="vertical-align: inherit;">À côté d'eux se trouvent des schémas d'envoi et de réception de signaux. </font><font style="vertical-align: inherit;">En particulier, puisque la puce communique avec des circuits externes en utilisant des signaux TTL, mais utilise ESL en interne, ces circuits convertissent entre les tensions TTL et ESL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La puce possède deux registres à décalage capables de décaler le mot d'un bit vers la droite ou la gauche. </font><font style="vertical-align: inherit;">Register Q - Un registre 4 bits basé sur des déclencheurs. </font><font style="vertical-align: inherit;">Enfin, le circuit de tension de référence génère les tensions de référence exactes nécessaires au fonctionnement de l'ESL.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment voir un cristal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour regarder à l'intérieur de la puce, vous devez généralement dissoudre son boîtier en plastique dans des acides dangereux. Cependant, je n'ai pas acheté la puce Am2901 dans un boîtier en plastique, mais dans un boîtier en céramique. Je viens de marcher le long de la couture de la puce avec un ciseau et de déconnecter les deux moitiés, ce qui m'a permis d'accéder au cristal à l'intérieur. Un cristal de silicium est un petit rectangle au centre de la puce. Des conducteurs minces relient les pastilles de cristal au cadre conducteur, ce qui conduit à 40 contacts de puce externes. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/99c/129/fc7/99c129fc7bb08492909208f99eac8fea.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am2901 après avoir déconnecté les deux moitiés du corps en céramique.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour obtenir des photos haute résolution de la puce, j'ai utilisé un microscope métallographique spécial. Sur la photo ci-dessous, vous pouvez voir le logo AMD. Ci-dessus, un conducteur soudé au site. La puce a deux couches métalliques qui créent un circuit électrique, visible sur la photo de droite.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a44/50c/7ed/a4450c7edec0f7da45e3ae37c0feedd6.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photo en gros plan de la puce - l'inscription 4301X (probablement le numéro de pièce) et "1983 AMD" sont visibles.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
J'ai collecté une grande photo haute résolution à partir de plusieurs petites images de microscope (en savoir plus sur le processus de création de photos de cristal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ensuite, j'ai retiré les couches métalliques et pris une autre série de photographies au silicium. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La photo en gros plan ci-dessous montre quatre transistors et trois résistances. Différentes zones de silicone ont des impuretés différentes, ce qui leur confère des propriétés différentes, et ces zones sont visibles au microscope. La puce est basée sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bipolaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transistors NPN différents des transistors MOS des ordinateurs modernes. </font><font style="vertical-align: inherit;">Le transistor de base (silicium de type p), l'émetteur (silicium de type n) et le collecteur (silicium de type n) sont marqués sur le transistor gauche [B, E, C]. </font><font style="vertical-align: inherit;">Les rectangles légers sont les contacts du silicium et de la couche de métal qui étaient au-dessus. </font><font style="vertical-align: inherit;">Les deux transistors à droite ont un grand collecteur commun. </font><font style="vertical-align: inherit;">Sur cette puce, on trouve souvent des transistors avec un collecteur commun. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/93f/bb8/ea9/93fbb8ea97a759777c91b35f81cac472.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici trois résistances. </font><font style="vertical-align: inherit;">Une résistance est obtenue en ajoutant des impuretés au silicium qui augmentent sa résistance. </font><font style="vertical-align: inherit;">La précision des résistances dans les circuits intégrés est généralement médiocre. </font><font style="vertical-align: inherit;">Ils s'avèrent également être relativement grands - ici, ils sont de la même taille avec des transistors, tandis que d'autres sont beaucoup plus grands. </font><font style="vertical-align: inherit;">Par conséquent, lors de la conception de circuits intégrés, ils essaient de minimiser le nombre de résistances.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logique liée à l'émetteur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les schémas logiques peuvent être créés de différentes manières. Presque tous les ordinateurs modernes utilisent le système logique CMOS (une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structure complémentaire métal-oxyde-semi-conducteur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), où les valves sont constituées de transistors MOS. À l'ère des mini-ordinateurs, le TTL était très populaire. L'ESL était un schéma plus rapide mais moins courant. L'inconvénient de l'ESL était une plus grande consommation d'énergie (le supercalculateur Cray-2 de 1985 utilisait des vannes ESL pour augmenter sa vitesse, mais il devait être refroidi avec du fréon liquide).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des avantages de l'ESL en termes de vitesse étaient dus au fait que les transistors n'étaient pas complètement allumés. Cela a permis aux transistors de changer très rapidement les chemins de courant. En outre, la différence entre la tension pour les valeurs 0 et 1 était faible (de l'ordre de 0,8 V), de sorte que les signaux pouvaient basculer assez rapidement. Par exemple, dans les vannes TTL, la différence de tension est d'environ 3,2 V (les signaux peuvent commuter à une vitesse d'environ 1 V par nanoseconde, donc avec une grande différence de tension, il y a des retards de plusieurs nanosecondes). En revanche, une petite différence de tension a entraîné une augmentation de la sensibilité de l'ESL au bruit électrique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les premières versions de l'Am2901 utilisaient le TTL, mais en 1979 AMD a présenté sa version plus rapide, l'Am2901C. L'Am2901C utilisait ESL en interne pour la vitesse, mais à l'extérieur, il supportait la tension TTL, ce qui le rend facile à utiliser dans les ordinateurs TTL. Cet article décrit la variante Am2901C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESL est basé sur un système à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paires différentielles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les amplificateurs opérationnels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionnent de manière similaire </font><font style="vertical-align: inherit;">. L'idée d'une paire différentielle (voir ci-dessous) est qu'un sens fixe s'écoule selon le schéma. Si la tension à l'entrée de gauche est supérieure à celle de droite, alors le transistor gauche s'allumera et la majeure partie du courant passera par la branche gauche. Et vice versa (notez que les émetteurs à transistors sont connectés - d'où le nom de la logique couplée à l'émetteur.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6a8/0d4/cd6/6a80d4cd63452c64136a0eccfbd6f019.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paire différentielle. Si la tension à l'entrée gauche (rouge) est plus élevée, la majeure partie du courant ira le long du chemin de gauche, et vice versa.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Certaines modifications vous permettent de transformer une paire différentielle en une vanne ESL. Tout d'abord, la tension dans une branche est fixe et devient référence, quelque part dans l'intervalle entre les niveaux 0 et 1. Ensuite, si l'entrée est supérieure à la tension de référence, elle sera considérée comme 1, et si elle est inférieure - comme 0. Ensuite, la sortie est connectée à la branche transistor (vert), qui donne le signal de sortie en tamponnant la tension de la branche. Le circuit inverseur est illustré ci-dessous, car si la tension d'entrée est élevée, le courant traversant la résistance de gauche entraînera la sortie vers le bas. Pour augmenter les performances, la résistance inférieure a été remplacée par un drain (magenta), composé d'un transistor et d'une résistance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le drain en bas de la vanne ESL donne, en effet, un courant constant contrôlé par la tension entrante V </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette option est meilleure qu'une simple résistance, car le courant traversant la résistance varie en fonction de la tension, en fonction des tensions d'entrée. En outre, un tel circuit économise de l'espace, car il utilise une résistance plus petite. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a50/362/b74/a50362b747b4d72ac7a32878ea505b38.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onduleur ESL. La résistance supérieure droite peut être omise car elle n'est connectée nulle part.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez construire une vanne ESL plus complexe en ajoutant plus d'entrées. Dans le schéma ci-dessous, un deuxième transistor d'entrée (2) est ajouté parallèlement au premier (1). Le courant passera par la résistance R1 s'il y a 1 à l'entrée A ou B (c'est-à-dire que la tension sera supérieure à la référence). Dans ce cas, la sortie est abaissée et nous obtenons la valve NOR. En utilisant d'autres configurations, vous pouvez créer des vannes AND, XOR ou des circuits plus complexes. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c59/97e/883/c5997e883d922023dc92fc0984dfbb74.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vanne ESL NOR</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le diagramme ci-dessus montre une porte NOR - telle qu'elle est implémentée sur une puce. La photo ci-dessous montre le schéma physique correspondant de la vanne. À gauche se trouve une couche de cristal de silicium, où les transistors et les résistances sont visibles. À droite, des pistes métalliques dans la même partie de la puce. Au-dessus se trouvent les transistors 1 et 2, recevant un signal d'entrée. Chacun d'eux a une base sur le dessus et un émetteur au milieu. Les transistors ont un collecteur commun - un rectangle blanc en dessous. Les résistances R1 et R2 sont des rectangles de silicium. Tous les transistors du milieu (y compris 3 et 4) ont un collecteur commun connecté deux fois au plus (les transistors et résistances non numérotés appartiennent à d'autres vannes). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/838/b90/f81/838b90f8170aa8d5b1be9d84a55fa103.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valve NOR implémentée sur le cristal Am2901</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut voir sur les conducteurs de droite que la couche supérieure assure la connexion des conducteurs horizontaux aux bornes plus, tensions de référence, drain VCS et moins (on voit que les points plus et moins sont élargis pour supporter des courants élevés). </font><font style="vertical-align: inherit;">En dessous se trouvent les conducteurs reliant les transistors. </font><font style="vertical-align: inherit;">Par le haut, les entrées A et B sont connectées aux bases des transistors. </font><font style="vertical-align: inherit;">Le reste du câblage est plus difficile à tracer, car il est recouvert par la couche supérieure. </font><font style="vertical-align: inherit;">Mais vous pouvez, par exemple, voir la connexion entre le transistor 4, le collecteur des transistors 1 et 2, et R1. </font><font style="vertical-align: inherit;">En étudiant attentivement les photographies du cristal, vous pouvez comprendre tout le câblage et inverser la logique de la puce.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unité de logique arithmétique (ALU)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'unité logique arithmétique (ALU) de la puce Am2901 effectue des opérations arithmétiques ou logiques sur 4 bits. Il prend en charge 8 opérations différentes: addition, soustraction et opérations logiques au niveau du bit (il ne traite pas de la multiplication et de la division). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le schéma de principe ci-dessous montre la structure de l'AL29 Am2901. Tout d'abord, le sélecteur (multiplexeur) sélectionne deux entrées à partir de sources potentielles. La valeur de D est transmise aux contacts de données de la puce, généralement au bus de données du processeur. A - il s'agit de la valeur de l'une des 16 entrées du fichier de registre à puce, sélectionnée par les contacts A0-A3; B fonctionne de manière similaire. Une valeur constante de 0 peut être envoyée à ALU. Enfin, Q est le contenu du registre Q (registre séparé optionnel). De nombreuses sources de données offrent plus de flexibilité à la puce.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d9a/9aa/586/d9a9aa586257e3e6db1eae6c243ac345.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma fonctionnel de l'ALU Am2901 d'après les spécifications de la puce. ALU exécute l'une des huit fonctions sur deux entrées 4 bits, R et S. Sur la droite se trouvent diverses sorties de la puce: G, P, sortie de transport, signe, débordement, test zéro.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Deux valeurs sélectionnées, R et S, sont envoyées à l'ALU, qui effectue l'opération sélectionnée et envoie le résultat à F. De plus, l'ALU accepte le montant de report et transfère la valeur de report (CN + 4) ; cela vous permet de combiner plusieurs ALU pour gérer des mots plus longs. Les sorties G et P sont utilisées pour le transfert avec un aperçu, et le signe, le débordement et le test des zéros peuvent être utilisés comme codes de processeur conditionnels.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Décrivez brièvement le circuit ALU, en commençant par le sélecteur. Les deux premières cases du sélecteur ci-dessous (D et A) sélectionnent le premier argument d'ALU, et les trois dernières (A, Q et B) sélectionnent le deuxième argument. Chaque sélecteur implémente la fonction Select • (Value ⊕ Invert), où Value est la valeur d'entrée potentielle, Select est 1 pour sélectionner cette valeur, et Invert est 1 pour inverser la valeur (puisque ALU est 4 bits, 4 bits sont sélectionnés; chaque sélecteur est implémenté à l'aide de quatre Vannes ESL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur souhaitée est sélectionnée en incluant l'une des lignes de sélection. Si aucun d'entre eux n'est activé, la valeur arrivant à ALU sera 0. De plus, le sélecteur peut inverser l'entrée; la puce effectue une soustraction en ajoutant la valeur inversée. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/323/a63/462/323a6346266c7a1116638ebd7e18f7fe.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première partie d'ALU se compose de quatre couches horizontales, une par bit</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le schéma ci-dessous montre le circuit AND-XOR utilisé dans ALU AM2901, qui implémente l'opération A '• (B ⊕ C). Je vais décrire brièvement comment cela fonctionne. Si la tension à l'entrée A est élevée, le courant traverse les transistors de gauche, tirant la sortie vers le bas. Si B et C sont à haute tension, le courant à travers les transistors gauche B et C entraîne la sortie vers le bas. Si la tension sur V et C est faible, le courant à travers les transistors V </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tire la sortie vers le bas. Si B et C ont une tension différente, le courant passe des transistors + et la sortie reste haute tension. L'essentiel est qu'une seule vanne ESL peut implémenter des fonctionnalités complexes. Avec la plupart des portes logiques, XOR est plus difficile à mettre en œuvre. Pour moi personnellement, la logique ESL ressemble au relais des années 1920, car elle bascule entre les deux voies de courant, et pas seulement s'allume et s'éteint.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3j/oq/iu/3joqiu-d6qnv7rewldbmxg0m000.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir sélectionné deux entrées pour l'ALU, il calcule les bits «Propager» (P) et «Générer» (G) pour chaque paire de bits entrants. Cela fait partie de la procédure de transfert d'aperçu utilisée pour un ajout rapide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La photo ci-dessous montre les parties restantes du circuit ALU (pour changer, cette photo a une couche métallique, contrairement aux photos précédentes, où il n'y avait que du silicium). Les signaux P et G du circuit précédent passent dans deux blocs de calcul de transfert. L'unité de transfert inférieure calcule le signal externe P, G et de transfert avec un aperçu pour plusieurs puces; cela vous permet d'ajouter rapidement de longs mots.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La technique de transfert avec prévisualisation peut être implémentée sur plusieurs puces pour ajouter rapidement des nombres supérieurs à 4 bits. Chaque puce génère des signaux de génération et de propagation, indiquant si elle va générer un transfert ou transmettre un transfert entrant. Ces signaux sont combinés avec une puce de générateur de transfert avec un aperçu - comme celui d'Am2902. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'unité de transfert supérieure calcule les transferts internes. Le schéma de «somme» calcule la somme de chaque bit en utilisant la césure et les valeurs de P et G. Il est important qu'en raison de la césure de césure, la somme de chaque bit puisse être calculée en parallèle. Enfin, le circuit de sortie convertit les signaux ESL internes en signaux TTL et contrôle les quatre contacts de sortie. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f4c/aff/c1f/f4caffc1fc927034efc1e722d61e98a2.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le reste du circuit ALU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La puce utilise des techniques intéressantes qui vous permettent d'utiliser l'additionneur pour huit opérations. Le circuit sélecteur décrit précédemment peut éventuellement compléter son entrée. Ceci est utilisé pour la soustraction, ainsi que pour certaines des fonctions logiques. Lors du calcul des fonctions logiques (au lieu d'ajouter / soustraire), le calcul du transfert est désactivé. Pendant les opérations logiques, les bits ne sont pas affectés par ce qui arrive aux autres bits. Enfin, le circuit XOR de l'additionneur se transforme en circuit ET en augmentant au maximum les signaux P. Ainsi, au lieu d'utiliser huit circuits différents pour huit opérations ALU, la puce utilise un seul circuit avec quelques réglages soigneusement sélectionnés.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La puce utilise les valeurs de P et G pour générer la somme des entrées R et S avec le report C. La somme (R ⊕ S ⊕ C) ', est calculée comme ((P' ∨ G) ⊕ C) ', où P = R∨S, et G = R • S. Si P est égal à 1, alors (P '∨ G) se réduit à G égal à R • S. Il s'avère qu'en changeant P, le même circuit peut être utilisé pour calculer ET à partir des valeurs d'entrée de R et S.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau ci-dessous présente les 8 opérations effectuées par ALU. Trois bits d'instructions sont introduits dans la puce et utilisés pour sélectionner l'opération: I5, I4 et I3. La colonne «fonction» montre les fonctions selon la documentation, et la colonne «calcul» montre comment chacun des bits est calculé. Notez que toutes les opérations sont finalement réduites à OU exclusif (⊕) ou ET (∧). L'addition se fait par le XOR au niveau du bit des deux arguments et des bits de portage. La soustraction est effectuée par l'addition de l'argument et l'addition ultérieure. Par exemple, l'ajout du complément R (R ') équivaut à la soustraction de R. Le bit I3 complète R et le bit I4 complète S. Les opérations avec OU exclusif (EXOR et EXNOR) utilisent les mêmes éléments que l'addition, mais avec verrou de calcul de transfert. L'opération ET est effectuée en bloquant le signal G. Enfin, OR est calculé selon la loi de Morgan, R '∧ S'= (R ∨ S) ». Le fait est que Am2901 ne nécessite pas d'éléments séparés pour l'addition, la soustraction, ET, OU et EXOR - la plupart des éléments sont utilisés dans chacune des opérations.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notation symbolique</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I5</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I4</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I3</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fonction</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcul</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AJOUTER</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R plus s</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R ⊕ S ⊕ Porter</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SUBR</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S moins r</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R '⊕ S ⊕ Porter</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SUBS</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R moins s</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R ⊕ S '⊕ Porter</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OU</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R OR S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(R '∧ S') ⊕ 1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ET</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R ET S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R ∧ S</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NOTRS</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R 'ET S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R '∧ S</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXOR</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R EX OU S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R ⊕ S '⊕ 1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXNOR</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R EX NOR S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R '⊕ S' ⊕ 1</font></font></td>
</tr>
</tbody></table></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La puce Am2901C présente un intérêt en tant qu'exemple d'ESL haute vitesse, une famille logique relativement rare. </font><font style="vertical-align: inherit;">La puce ALU est distribuée au bas de la puce, implémente huit fonctions différentes et utilise un transfert d'aperçu pour accélérer le travail. </font><font style="vertical-align: inherit;">Bien que la puce soit assez complexe, un examen minutieux au microscope permet de comprendre son travail.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les processeurs multi-puces sectionnels, comme l'Am2901, ont été utilisés dans les micro-ordinateurs et de nombreux autres systèmes dans les années 1970 et 1980. </font><font style="vertical-align: inherit;">Cependant, au final, les améliorations de la technologie CMOS ont permis la mise en œuvre d'un processeur rapide sur une seule puce, ce qui a rendu cette technologie obsolète. </font><font style="vertical-align: inherit;">Et tandis que l'Am2901 contient probablement environ un millier de transistors et qu'il fonctionne à 16 MHz, AMD fabrique aujourd'hui des processeurs contenant des milliards de transistors et fonctionnant à 4 GHz.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498556/index.html">Hans Peter Lun et la naissance de l'algorithme de hachage</a></li>
<li><a href="../fr498560/index.html">Composants Web dans un vrai projet</a></li>
<li><a href="../fr498562/index.html">Contrairement à la quarantaine: comment nous avons transféré nos stages dans un format distant</a></li>
<li><a href="../fr498564/index.html">Optimisation du rendu pour mobile, partie 2. Les principales familles de GPU mobiles modernes</a></li>
<li><a href="../fr498566/index.html">Ingénierie de la résilience: notes de la conférence REDeploy</a></li>
<li><a href="../fr498572/index.html">Des réductions bizarres? Parts des fournisseurs de CRM à l'occasion de la transition vers udalenka</a></li>
<li><a href="../fr498574/index.html">Pourquoi ai-je décidé de développer des jeux, ou un voyage nostalgique pour zéro</a></li>
<li><a href="../fr498576/index.html">Comment nous avons développé le champ de saisie de nouveaux messages dans notre messager (Gem4me)</a></li>
<li><a href="../fr498580/index.html">Quantification de "l'effet bol" sur les images tomographiques</a></li>
<li><a href="../fr498582/index.html">Obtenez et changez les sous-titres WebVTT dans ExoPlayer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>