<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌴 🙎 👶🏿 Lebih lanjut tentang Coroutine di C ++ ⛹🏻 🤘 👥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo kolega. 
 
 Sebagai bagian dari pengembangan tema C ++ 20, kami pernah menemukan artikel yang agak lama (September 2018) dari hublog Yandex, yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lebih lanjut tentang Coroutine di C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo kolega. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai bagian dari pengembangan tema C ++ 20, kami pernah menemukan artikel yang agak lama (September 2018) dari hublog Yandex, yang disebut “ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bersiap untuk C ++ 20. Coroutines TS dengan Contoh Nyata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”. Itu berakhir dengan pemungutan suara yang sangat ekspresif berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Mengapa tidak," kami memutuskan dan menerjemahkan sebuah artikel oleh David Pilarski dengan judul "Pengantar Coroutines". Artikel ini diterbitkan sedikit lebih dari setahun yang lalu, tetapi mudah-mudahan Anda akan menemukannya sangat menarik.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begitulah yang terjadi. Setelah banyak keraguan, kontroversi, dan persiapan fitur ini, WG21 memperoleh pendapat umum tentang seperti apa coroutine di C ++ - dan sangat mungkin mereka akan dimasukkan ke dalam C ++ 20. Karena ini adalah fitur utama, saya pikir ini saatnya untuk menyiapkan dan mempelajarinya. sekarang (seperti yang Anda ingat, masih ada lebih banyak modul, konsep, rentang untuk dipelajari ...) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak yang masih menentang coroutine. Seringkali mereka mengeluh tentang kompleksitas perkembangan mereka, banyak poin penyesuaian dan, mungkin, kinerja yang kurang optimal karena, mungkin, alokasi memori dinamis yang kurang optimal (mungkin;)).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejalan dengan pengembangan spesifikasi teknis (TS) yang disetujui (dipublikasikan), bahkan upaya telah dilakukan untuk pengembangan paralel mekanisme lain dari corutin. </font><font style="vertical-align: inherit;">Di sini kita akan berbicara tentang coroutine yang dijelaskan dalam TS ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi teknis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Pendekatan alternatif, pada gilirannya, milik Google. </font><font style="vertical-align: inherit;">Akibatnya, ternyata pendekatan Google mengalami banyak masalah, solusinya sering membutuhkan fitur tambahan aneh dari C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, diputuskan untuk mengadopsi versi Corutin yang dikembangkan oleh Microsoft (disponsori oleh TS). </font><font style="vertical-align: inherit;">Ini tentang coroutine yang akan dibahas dalam artikel ini. </font><font style="vertical-align: inherit;">Jadi, mari kita mulai dengan pertanyaan ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu coroutine?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutine sudah ada dalam banyak bahasa pemrograman, misalnya, dalam Python atau C #. </font><font style="vertical-align: inherit;">Coroutine adalah cara lain untuk membuat kode asinkron. </font><font style="vertical-align: inherit;">Bagaimana mereka berbeda dari aliran, mengapa coroutine harus diimplementasikan sebagai fitur bahasa khusus dan, akhirnya, apa penggunaannya akan dijelaskan di bagian ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada kesalahpahaman serius tentang apa coroutine itu. </font><font style="vertical-align: inherit;">Tergantung pada lingkungan di mana mereka digunakan, mereka dapat dipanggil:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stoutless Coroutines</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tumpukan coroutine</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aliran hijau</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serat</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutin</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berita baiknya: tumpukan corutin, aliran hijau, serat, dan gorutin adalah satu hal yang sama (tetapi kadang-kadang digunakan dengan cara yang berbeda). Kita akan membicarakannya nanti di artikel ini dan kita akan menyebutnya serat atau tumpukan coroutine. Tetapi coroutine stackless memiliki beberapa fitur yang perlu dibahas secara terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami coroutine, termasuk pada level intuitif, mari kita secara singkat mengenal fungsinya dan (mari kita begini) "API mereka". Cara standar untuk bekerja dengan mereka adalah menelepon dan menunggu sampai selesai:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah memanggil fungsi, sudah tidak mungkin untuk menjeda, atau melanjutkan pekerjaannya. Anda hanya dapat melakukan dua operasi pada fungsi: </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ketika fungsi diluncurkan, Anda harus menunggu sampai selesai. Jika fungsi dipanggil lagi, eksekusinya akan berjalan dari awal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan coroutine, situasinya berbeda. Anda tidak hanya dapat memulai dan menghentikannya, tetapi juga menjeda dan melanjutkannya. Mereka masih berbeda dari aliran inti, karena coroutine itu sendiri tidak berkerumun (di sisi lain, coroutine biasanya merujuk pada aliran, dan aliran berkerumun keluar). Untuk memahami hal ini, pertimbangkan generator yang didefinisikan dalam Python. Biarkan hal seperti itu disebut generator dengan Python, dalam C ++ itu akan disebut coroutine. Contoh diambil dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah cara kerja kode ini: panggilan fungsi </font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengarah ke pembuatan objek coroutine. </font><font style="vertical-align: inherit;">Pada setiap langkah penghitungan objek coroutine, coroutine itu sendiri kembali berfungsi dan berhenti hanya setelah kata kunci </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kode; </font><font style="vertical-align: inherit;">kemudian bilangan bulat berikutnya dari urutan dikembalikan (loop for adalah sintaksis gula untuk memanggil fungsi </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang melanjutkan coroutine). </font><font style="vertical-align: inherit;">Kode mengakhiri loop dengan menemukan pernyataan break. </font><font style="vertical-align: inherit;">Dalam hal ini, corutin tidak pernah berakhir, tetapi mudah untuk membayangkan situasi di mana corutin mencapai ujung dan ujung. </font><font style="vertical-align: inherit;">Seperti yang kita lihat, untuk operasi yang berlaku korutine </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan akhirnya,</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Catatan: C ++ juga menyediakan operasi penciptaan dan penghancuran, tetapi mereka tidak penting dalam konteks pemahaman intuitif coroutine].</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines sebagai perpustakaan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, sekarang sudah hampir jelas apa coroutine itu. </font><font style="vertical-align: inherit;">Anda mungkin tahu bahwa ada perpustakaan untuk membuat objek serat. </font><font style="vertical-align: inherit;">Pertanyaannya adalah, mengapa kita perlu coroutine dalam bentuk fitur bahasa khusus, dan bukan hanya perpustakaan yang akan bekerja dengan coroutine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kami mencoba untuk menjawab pertanyaan ini dan menunjukkan perbedaan antara coroutine stacked dan stackless. </font><font style="vertical-align: inherit;">Perbedaan ini adalah kunci untuk memahami corutin sebagai bagian dari bahasa.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tumpukan coroutine</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita bahas dulu apa itu stack coroutine, bagaimana cara kerjanya, dan mengapa mereka bisa diimplementasikan sebagai perpustakaan. </font><font style="vertical-align: inherit;">Menjelaskannya relatif sederhana, karena mereka menyerupai aliran dalam hal desain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fibre atau stack corutin memiliki stack terpisah yang dapat digunakan untuk menangani panggilan fungsi. </font><font style="vertical-align: inherit;">Untuk memahami dengan tepat bagaimana coroutine dari jenis ini bekerja, kita secara singkat melihat frame fungsi dan panggilan fungsi dari sudut pandang tingkat rendah. </font><font style="vertical-align: inherit;">Tapi pertama-tama, mari kita bicara tentang sifat serat.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka memiliki tumpukan mereka sendiri,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masa pakai serat tidak tergantung pada kode yang memanggilnya (biasanya mereka memiliki penjadwal yang ditentukan pengguna),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serat dapat terlepas dari satu utas dan melekat pada lainnya,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perencanaan koperasi (serat harus memutuskan untuk beralih ke serat / penjadwal lain),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak dapat bekerja secara bersamaan di utas yang sama.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Efek berikut ini dihasilkan dari sifat-sifat di atas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalihkan konteks serat harus dilakukan oleh pengguna serat, dan bukan OS (selain itu, OS dapat melepaskan serat, melepaskan benang tempat kerjanya),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada ras data nyata antara kedua serat, karena pada waktu tertentu hanya satu dari mereka yang bisa aktif,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perancang serat harus dapat memilih tempat dan waktu yang tepat, di mana dan kapan waktu yang tepat untuk mengembalikan daya komputasi ke penjadwal atau pemanggil yang mungkin.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi input / output dalam serat harus asinkron, sehingga serat lain dapat melakukan tugasnya tanpa saling menghalangi.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita melihat lebih dekat pada operasi serat dan pertama-tama menjelaskan bagaimana tumpukan berpartisipasi dalam pemanggilan fungsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, stack adalah blok memori berkelanjutan yang diperlukan untuk menyimpan variabel lokal dan argumen fungsi. Tetapi, yang lebih penting, setelah setiap pemanggilan fungsi (dengan beberapa pengecualian), informasi tambahan didorong ke tumpukan yang memberi tahu fungsi yang dipanggil cara untuk kembali ke pemanggil dan mengembalikan register prosesor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa register ini memiliki tugas khusus, dan ketika memanggil fungsi, mereka disimpan di stack. Ini adalah register (dalam kasus arsitektur ARM): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SP - stack pointer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LR - </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC </font><font style="vertical-align: inherit;">register komunikasi </font><font style="vertical-align: inherit;">- program counter </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stack pointer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(SP) adalah register yang berisi alamat awal tumpukan yang terkait dengan panggilan fungsi saat ini. Berkat nilai yang ada, Anda dapat dengan mudah merujuk argumen dan variabel lokal yang disimpan di tumpukan. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register komunikasi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (LR) sangat penting saat memanggil fungsi. Ini menyimpan alamat pengirim (alamat pihak yang menelepon), di mana kode akan dieksekusi setelah eksekusi fungsi saat ini selesai. Ketika fungsi dipanggil, PC disimpan dalam LR. Ketika fungsi kembali, PC dikembalikan menggunakan LR. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penghitung Program</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PC) adalah alamat dari instruksi yang sedang dijalankan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap kali suatu fungsi dipanggil, daftar tautan disimpan, sehingga fungsi tersebut tahu di mana program harus kembali setelah selesai.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku PC dan LR mendaftar saat memanggil dan mengembalikan fungsi</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ketika menjalankan stack coroutine, fungsi yang dipanggil menggunakan stack yang sebelumnya dialokasikan untuk menyimpan argumen dan variabel lokalnya. </font><font style="vertical-align: inherit;">Karena semua informasi pada setiap fungsi yang dipanggil pada stack corutin disimpan di stack, fiber dapat menangguhkan fungsi apa pun di dalam corutin itu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat apa yang terjadi pada gambar ini. </font><font style="vertical-align: inherit;">Pertama, setiap serat dan ulir memiliki tumpukan terpisah. </font><font style="vertical-align: inherit;">Warna hijau menunjukkan nomor seri yang menunjukkan urutan tindakan.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan fungsi reguler di dalam utas. </font><font style="vertical-align: inherit;">Memori dialokasikan pada tumpukan.</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> –     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat bekerja dengan stack coroutine, tidak perlu fitur bahasa khusus yang akan memastikan penggunaannya. </font><font style="vertical-align: inherit;">Seluruh tumpukan korutiny diimplementasikan dengan baik menggunakan perpustakaan, dan perpustakaan sudah ada yang dirancang khusus untuk tujuan ini: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost .Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari semua perpustakaan ini, hanya Peningkatan adalah C ++, dan sisanya adalah C. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk penjelasan rinci tentang cara kerja perpustakaan ini, </font><font style="vertical-align: inherit;">lihat </font><font style="vertical-align: inherit;">dokumentasi. </font><font style="vertical-align: inherit;">Tetapi, secara umum, semua pustaka ini memungkinkan Anda untuk membuat tumpukan terpisah untuk serat dan memberikan kesempatan untuk melanjutkan coroutine (atas inisiatif si penelepon) dan menjeda (dari dalam).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan sebuah contoh </font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , perpustakaan memiliki </font><b><font style="vertical-align: inherit;">penjadwal bawaan</font></b><font style="vertical-align: inherit;"> untuk coroutine. </font><font style="vertical-align: inherit;">Semua serat bekerja di utas yang sama. </font><font style="vertical-align: inherit;">Karena perencanaan corutin kooperatif, serat pertama-tama harus memutuskan kapan harus mengembalikan kontrol ke penjadwal. </font><font style="vertical-align: inherit;">Dalam contoh ini, ini terjadi ketika fungsi hasil dipanggil, yang menjeda coroutine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena tidak ada serat lain, perencana serat selalu memutuskan untuk melanjutkan coroutine.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stoutless Coroutines</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutine stackless sedikit berbeda dalam properti dari stack. </font><font style="vertical-align: inherit;">Namun, mereka memiliki karakteristik dasar yang sama, karena coroutine non-stack juga dapat dimulai, dan setelah suspensi mereka dapat dilanjutkan. </font><font style="vertical-align: inherit;">Coroutine dari jenis ini kemungkinan besar akan kita temukan di C ++ 20. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita berbicara tentang sifat-sifat serupa dari corutin - coroutine dapat:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin berhubungan erat dengan peneleponnya: ketika coroutine dipanggil, eksekusi ditransfer kepadanya, dan hasil coroutine ditransfer kembali ke penelepon.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masa hidup stack corutin sama dengan umur stacknya. </font><font style="vertical-align: inherit;">Umur coroutine tanpa tumpukan sama dengan umur objeknya.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, dalam kasus coroutine tanpa tumpukan, tidak perlu mengalokasikan seluruh tumpukan. Mereka mengkonsumsi memori jauh lebih sedikit daripada yang stack, tetapi ini justru karena beberapa keterbatasan mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memulainya, jika mereka tidak mengalokasikan memori untuk stack, lalu bagaimana cara kerjanya? Di mana dalam kasus mereka semua data yang disimpan harus disimpan di stack ketika bekerja dengan stack coroutine. Jawab: di atas tumpukan pemanggil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rahasia untuk coroutine tanpa tumpukan adalah bahwa mereka hanya dapat menangguhkan diri mereka sendiri dari fungsi paling atas. Untuk semua fungsi lainnya, datanya terletak pada tumpukan sisi yang dipanggil, jadi semua fungsi yang dipanggil dari corutin harus diselesaikan sebelum pekerjaan corutin ditunda. Semua data yang dibutuhkan oleh coroutine untuk mempertahankan statusnya dialokasikan secara dinamis di heap. Ini biasanya memerlukan beberapa variabel dan argumen lokal, yang jauh lebih kompak daripada seluruh tumpukan yang harus dialokasikan sebelumnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihatlah bagaimana cara kerja stackless corutins: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menantang stackless corutin</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, sekarang hanya ada satu tumpukan - ini adalah tumpukan utama utas. </font><font style="vertical-align: inherit;">Mari kita selangkah demi selangkah melihat apa yang diperlihatkan dalam gambar ini (kerangka aktivasi coroutine di sini adalah dua warna - hitam menunjukkan apa yang disimpan di stack, dan biru - apa yang disimpan di heap).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan fungsi reguler yang bingkainya disimpan di tumpukan</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini menciptakan coroutine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Yaitu, itu mengalokasikan bingkai aktivasi untuk suatu tempat di heap.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan fungsi normal.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggil Corutin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tubuh Corutin menonjol dalam tumpukan reguler. </font><font style="vertical-align: inherit;">Program dijalankan dengan cara yang sama seperti dalam kasus fungsi biasa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan fungsi reguler dari coroutine. </font><font style="vertical-align: inherit;">Sekali lagi, semuanya masih terjadi pada stack [Catatan: Anda tidak dapat menjeda coroutine dari titik ini, karena ini bukan fungsi teratas di coroutine]</font></font></li>
<li>       [:     .]</li>
<li>  –  ,        ,     .</li>
<li>  </li>
<li><b>  </b> –      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, jelas bahwa dalam kasus kedua perlu mengingat data jauh lebih sedikit untuk semua operasi menangguhkan dan melanjutkan pekerjaan corutin, namun, coroutine dapat melanjutkan dan hanya menangguhkan sendiri, dan hanya dari fungsi paling atas. Semua panggilan fungsi dan coroutine terjadi dengan cara yang sama, namun beberapa data tambahan harus disimpan di antara panggilan, dan fungsi tersebut harus dapat melompat ke titik suspensi dan mengembalikan keadaan variabel lokal. Tidak ada perbedaan lain antara bingkai coroutine dan bingkai fungsi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin juga dapat menyebabkan coroutine lain (tidak diperlihatkan dalam contoh ini). </font><font style="vertical-align: inherit;">Dalam kasus coroutine stackless, setiap panggilan menghasilkan alokasi ruang baru untuk data corutin baru (dengan panggilan coroutine berulang, memori dinamis juga dapat dialokasikan beberapa kali). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasan mengapa coroutine perlu menyediakan fitur bahasa khusus adalah karena kompilator perlu memutuskan variabel mana yang menggambarkan keadaan coroutine dan membuat kode stereotip untuk melompat ke titik suspensi.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan praktis dari corutin</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutine dalam C ++ dapat digunakan dengan cara yang sama seperti dalam bahasa lain. </font><font style="vertical-align: inherit;">Coroutine akan menyederhanakan ejaan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode input / output asinkron </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komputasi malas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi berbasis acara</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harap dengan membaca artikel ini Anda akan menemukan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengapa di C ++ Anda perlu mengimplementasikan coroutine sebagai fitur bahasa khusus</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa perbedaan antara coroutine stacked dan stackless?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengapa coroutine dibutuhkan</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491986/index.html">RemoteLoRa - Lebih Dari ON / OFF</a></li>
<li><a href="../id491988/index.html">Apa yang Baru di Red Hat OpenShift 4.2 dan 4.3?</a></li>
<li><a href="../id491990/index.html">Bekerja dengan chip Cina ADC Hx711 (kesimpulan)</a></li>
<li><a href="../id491992/index.html">Pengembangan Analis</a></li>
<li><a href="../id491994/index.html">Bermigrasi dari Cocoapods ke Manajer Paket Swift</a></li>
<li><a href="../id492000/index.html">Produk pertama. Habis terbakar</a></li>
<li><a href="../id492002/index.html">Sayap Penyerap Cahaya: Rahasia untuk Kupu-kupu Super Hitam</a></li>
<li><a href="../id492004/index.html">Cara tumbuh dari seorang programmer ke seorang manajer ("Saya ingin menjadi nyonya laut")</a></li>
<li><a href="../id492006/index.html">Kekuatan PWA: Sistem pengawasan video dengan kode JS 300-neural network neural</a></li>
<li><a href="../id492008/index.html">Hasil penelitian motivasi TI: apakah pengembang senang dengan pekerjaan mereka?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>