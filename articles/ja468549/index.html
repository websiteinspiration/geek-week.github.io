<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏆 💱 💅 GPUバウンド。すべてをビデオカードに転送する方法など。アニメーション ⛺️ 👓 🔶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="むかしむかし、マルチテクスチャユニットまたはハードウェアトランスフォーメーション＆ライティング（T＆L）がGPUに登場したのは、大きなイベントでした。固定機能パイプラインの設定は不思議なシャーマニズムでした。そして、D3D9 APIハックを通じて特定のチップの高度な機能を有効にして使用する方法を知っ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPUバウンド。すべてをビデオカードに転送する方法など。アニメーション</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468549/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">むかしむかし、マルチテクスチャユニットまたはハードウェアトランスフォーメーション＆ライティング（T＆L）がGPUに登場したのは、大きなイベントでした。固定機能パイプラインの設定は不思議なシャーマニズムでした。そして、D3D9 APIハックを通じて特定のチップの高度な機能を有効にして使用する方法を知っている人たちは、Zenを学んだと考えていました。しかし、時間が経つと、シェーダーが現れました。最初は、機能と長さの両方が強く制限されていました。さらに、より多くの機能、より多くの指示、より多くの速度。コンピューティング（CUDA、OpenCL、DirectCompute）が登場し、ビデオカードの容量の範囲が急速に拡大し始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシリーズの（うまくいけば）記事では、グラフィック効果に加えて、ゲームの開発時に最新のGPUの機能を「異常に」適用する方法を説明し、示すようにします。</font><font style="vertical-align: inherit;">最初の部分はアニメーションシステムに専念します。</font><font style="vertical-align: inherit;">記載されている内容はすべて、実際の経験に基づいており、実際のゲームプロジェクトで実装および機能します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああ、またアニメーションです。</font><font style="vertical-align: inherit;">それについてはすでに百回も書かれ、説明されています。</font><font style="vertical-align: inherit;">何がそんなに複雑ですか？</font><font style="vertical-align: inherit;">ボーンのマトリックスをバッファ/テクスチャにパックし、頂点シェーダーでスキニングに使用します。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Gems 3（Chapter 2. Animated Crowd Rendering）で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして最近の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unite Tech Presentationに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装されました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">別の方法で可能ですか？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityのTechnodemka</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誇大広告がたくさんありますが、それは本当にクールですか？この</font><font style="vertical-align: inherit;">テクノデモで骨格アニメーションがどのように作成され、機能するかを詳しく説明して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いる記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がハブにあります。並列処理はすべて良好であり、考慮しません。しかし、レンダリングに関して、何がどのように行われるかを知る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大規模な戦闘では、それぞれが1つのタイプのユニットで構成される2つの軍隊が戦います。左側がスケルトン、右側が騎士。バラエティはまあまあです。各ユニットは3つのLOD（それぞれ〜300、〜1000、〜4000の頂点）で構成され、2つのボーンのみが頂点に影響を与えます。アニメーションシステムは、ユニットのタイプごとに7つのアニメーションのみで構成されています（すでに2つあることを思い出します）。アニメーションは調和しませんが、プレゼンテーションで強調されるjob'axで実行される単純なコードから個別に切り替わります。ステートマシンはありません。 2種類のメッシュがある場合、2つのインスタンス化された描画呼び出しで群集全体を描画できます。私がすでに書いたように、骨格アニメーションは2009年に説明されたテクノロジーに基づいています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
革新的ですか？うーん...画期的な？ええと...現代のゲームに適していますか？まあ、おそらく、ユニット数に対するFPSの比率は自慢です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの主な欠点（テクスチャのプリマトリックス）：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームレートに依存。</font><font style="vertical-align: inherit;">アニメーションの2倍のフレームが必要でした-2倍のメモリを割り当ててください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションのブレンドの欠如。</font><font style="vertical-align: inherit;">もちろん、それらは作成できますが、スキンシェーダーでは、ブレンドロジックから複雑な混乱が形成されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Animatorステートマシンへのバインドの欠如。</font><font style="vertical-align: inherit;">キャラクターの動作をカスタマイズするための便利なツールで、任意のスキニングシステムに接続できますが、この場合、ポイント2により、すべてが非常に複雑になります（ネストされたBlendTreeをブレンドする方法を想像してください）。</font></font></li>
</ol><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPAS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUパワードアニメーションシステム。</font><font style="vertical-align: inherit;">名前がついたばかりです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいアニメーションシステムにはいくつかの要件がありました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速で作業します（よくわかります）。</font><font style="vertical-align: inherit;">何万もの異なるユニットをアニメーション化する必要があります。</font></font></li>
<li>  ( )    Unity.     ,         .    built-in CPU  GPU .     .   «»,       :    ,  / .</li>
<li>    Unity Animator. , ,     , .       .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションの準備とベイキングについて考えてみましょう。行列は使用しません。最新のビデオカードはループで適切に動作し、floatに加えてintをネイティブでサポートしているため、CPUのようにキーフレームで動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションビューアユニットでアニメーションの例を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_4/yw/bg/_4ywbgkzw8frqb3pjng98db5zwm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーフレームは、位置、スケール、回転に対して個別に設定されていることがわかります。ボーンによっては、たくさん必要なものもあれば、ほんの少ししか必要ないものもあります。個別にアニメーション化されていないボーンの場合は、最初と最後のキーフレームだけが設定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
位置-Vector3、四元数-Vector4、スケール-Vector3。</font><font style="vertical-align: inherit;">キーフレーム構造には共通点が1つあるため（簡略化のため）、上記のタイプのいずれかに適合するために4つの浮動小数点が必要です。</font><font style="vertical-align: inherit;">曲率に応じてキーフレーム間を適切に補間するには、InTangentとOutTangentも必要です。</font><font style="vertical-align: inherit;">そうそう、正規化された時間は忘れないでください：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyFrame</span>
{</span><font></font>
	float4 v;<font></font>
	float4 inTan, outTan;<font></font>
	<span class="hljs-keyword">float</span> time;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのキーフレームを取得するには、AnimationUtility.GetEditorCurve（）を使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、hcpデータを準備する段階で、スケルトンのボーンにアニメーションのボーンを再マップする必要があるため（一致しない場合もあるため）、ボーンの名前を覚えておく必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーフレームの配列で線形バッファを埋め、必要なアニメーションに関連するものを見つけるために、それらのオフセットを記憶します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今面白い。</font><font style="vertical-align: inherit;">GPUスケルトンアニメーション。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きな（「アニメートされたスケルトンの数」X「スケルトンのボーンの数」X「アニメーションブレンドの最大数の経験的係数」）バッファーを準備します。</font><font style="vertical-align: inherit;">その中にアニメーションの瞬間のボーンの位置、回転、スケールを保存します。</font><font style="vertical-align: inherit;">そして、このフレームで計画されているすべてのアニメートされたボーンに対して、計算シェーダーを実行します。</font><font style="vertical-align: inherit;">各スレッドはそのボーンをアニメーション化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各キーフレームは、それが属するサイズ（移動、回転、スケール）に関係なく、まったく同じ方法で補間されます（線形検索による検索、Knuthが許してくれます）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InterpolateKeyFrame</span><span class="hljs-params">(inout float4 rv, <span class="hljs-keyword">int</span> startIdx, <span class="hljs-keyword">int</span> endIdx, <span class="hljs-keyword">float</span> t)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIdx; i &lt; endIdx; ++i)<font></font>
	{<font></font>
		KeyFrame k0 = keyFrames[i + <span class="hljs-number">0</span>];<font></font>
		KeyFrame k1 = keyFrames[i + <span class="hljs-number">1</span>];<font></font>
<font></font>
		<span class="hljs-keyword">float</span> lerpFactor = (t - k0.time) / (k1.time - k0.time);
		<span class="hljs-keyword">if</span> (lerpFactor &lt; <span class="hljs-number">0</span> || lerpFactor &gt; <span class="hljs-number">1</span>)
			<span class="hljs-keyword">continue</span>;<font></font>
<font></font>
		rv = CurveInterpoate(k0, k1, lerpFactor);<font></font>
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
曲線は3次ベジェ曲線であるため、補間関数は次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">float4 <span class="hljs-title">CurveInterpoate</span><span class="hljs-params">(KeyFrame v0, KeyFrame v1, <span class="hljs-keyword">float</span> t)</span>
</span>{
	<span class="hljs-keyword">float</span> dt = v1.time - v0.time;<font></font>
	float4 m0 = v0.outTan * dt;<font></font>
	float4 m1 = v1.inTan * dt;<font></font>
<font></font>
	<span class="hljs-keyword">float</span> t2 = t * t;
	<span class="hljs-keyword">float</span> t3 = t2 * t;<font></font>
<font></font>
	<span class="hljs-keyword">float</span> a = <span class="hljs-number">2</span> * t3 - <span class="hljs-number">3</span> * t2 + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">float</span> b = t3 - <span class="hljs-number">2</span> * t2 + t;
	<span class="hljs-keyword">float</span> c = t3 - t2;
	<span class="hljs-keyword">float</span> d = <span class="hljs-number">-2</span> * t3 + <span class="hljs-number">3</span> * t2;<font></font>
<font></font>
	float4 rv = a * v0.v + b * m0 + c * m1 + d * v1.v;<font></font>
	<span class="hljs-keyword">return</span> rv;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
局所骨位置（TRS）が計算されました。次に、別の計算シェーダーを使用して、このボーンに必要なすべてのアニメーションをブレンドします。これを行うために、最終的なブレンドのアニメーションインデックスと各アニメーションの重みを含むバッファーがあります。この情報は状態マシンから取得します。 BlendTree内のBlendTreeの状況は、次のように解決されます。たとえば、そのようなツリーがあります</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yg/n6/_4/ygn6_4arygdkgbnigucbv0tz0fe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。BlendTreeWalkのウェイトは0.35、Run-0.65です。したがって、ボーンの最終的な位置は、Walk1、Walk2、Run1、Run2の4つのアニメーションで決定する必要があります。それらの重みは、値（0.35 * 0.92、0.35 * 0.08、0.65 * 0.92、0.65 * 0.08）=（0.322、0.028、0.598、0.052）をそれぞれ持ちます。重みの合計は常に1でなければならないことに注意してください。そうしないと、魔法のバグが提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブレンド関数の「中心」：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> bw = animDef.blendWeight;<font></font>
			<font></font>
BoneXForm boneToBlend = animatedBones[srcBoneIndex];<font></font>
float4 q = boneToBlend.quat;<font></font>
float3 t = boneToBlend.translate;<font></font>
float3 s = boneToBlend.scale;<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dot(resultBone.quat, q) &lt; <span class="hljs-number">0</span>)<font></font>
	q = -q;<font></font>
<font></font>
resultBone.translate += t * bw;<font></font>
resultBone.quat += q * bw;<font></font>
resultBone.scale += s * bw;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、変換マトリックスに変換できます。</font><font style="vertical-align: inherit;">やめる。</font><font style="vertical-align: inherit;">完全に忘れられた骨の階層について。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケルトンからのデータに基づいて、インデックスの配列を作成します。ここで、ボーンインデックスを持つセルには、その親のインデックスが含まれています。</font><font style="vertical-align: inherit;">ルートで、-1を書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/8v/tl/c08vtlrw1w80dsczyczusebox34.jpeg"><br>
<br>
<pre><code class="cpp hljs">float4x4 animMat = IdentityMatrix();<font></font>
float4x4 mat = initialPoses[boneId];<font></font>
<font></font>
<span class="hljs-keyword">while</span> (boneId &gt;= <span class="hljs-number">0</span>)<font></font>
{<font></font>
	BoneXForm b = blendedBones[boneId];<font></font>
	float4x4 xform = MakeTransformMatrix(b.translate, b.quat, b.scale);<font></font>
	animMat = mul(animMat, xform);<font></font>
<font></font>
	boneId = bonesHierarchyIndices[boneId];<font></font>
}<font></font>
<font></font>
mat = mul(mat, animMat);<font></font>
resultSkeletons[id] = mat;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、原則として、アニメーションのレンダリングとブレンドのすべての主要なポイントです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPSM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUパワードステートマシン（ご想像どおり）。上記のアニメーションシステムは、Unityアニメーションステートマシンで問題なく機能しますが、すべての努力は無駄になります。フレームごとに数万（数百ではないにしても）数千のアニメーションを計算する可能性があるため、UnityAnimatorは同時に動作する数千の状態マシンを引き出しません。うーん... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityのステートマシンとは何ですか？これは、状態と遷移の閉じたシステムであり、単純な数値プロパティによって制御されます。各ステートマシンは、互いに独立して、同じ入力データのセットで動作します。ちょっと待って。これは、GPUとコンピューティングシェーダーにとって理想的なタスクです。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベーキング段階</font></font></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、すべてのステートマシンデータを収集し、GPU対応の構造に配置する必要があります。</font><font style="vertical-align: inherit;">そしてこれ：状態（状態）、遷移（遷移）およびパラメーター（パラメーター）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべてのデータは線形バッファに配置され、インデックスによってアドレス指定されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各計算スレッドはその状態マシンを考慮します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatorController</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、必要なすべての内部状態マシン構造へのインターフェースを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートマシンの主な構造：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span>
{</span>
	<span class="hljs-keyword">float</span> speed;
	<span class="hljs-keyword">int</span> firstTransition;
	<span class="hljs-keyword">int</span> numTransitions;
	<span class="hljs-keyword">int</span> animDefId;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Transition</span>
{</span>
	<span class="hljs-keyword">float</span> exitTime;
	<span class="hljs-keyword">float</span> duration;
	<span class="hljs-keyword">int</span> sourceStateId;
	<span class="hljs-keyword">int</span> targetStateId;
	<span class="hljs-keyword">int</span> firstCondition;
	<span class="hljs-keyword">int</span> endCondition;<font></font>
	uint properties;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StateData</span>
{</span>
	<span class="hljs-keyword">int</span> id;
	<span class="hljs-keyword">float</span> timeInState;
	<span class="hljs-keyword">float</span> animationLoop;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionData</span>
{</span>
	<span class="hljs-keyword">int</span> id;
	<span class="hljs-keyword">float</span> timeInTransition;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CurrentState</span>
{</span><font></font>
	StateData srcState, dstState;<font></font>
	TransitionData transition;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimationDef</span>
{</span><font></font>
	uint animId;<font></font>
	<span class="hljs-keyword">int</span> nextAnimInTree;
	<span class="hljs-keyword">int</span> parameterIdx;
	<span class="hljs-keyword">float</span> lengthInSec;<font></font>
	uint numBones;<font></font>
	uint loop;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParameterDef</span>
{</span><font></font>
	float2 line0ab, line1ab;<font></font>
	<span class="hljs-keyword">int</span> runtimeParamId;
	<span class="hljs-keyword">int</span> nextParameterId;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Condition</span>
{</span>
	<span class="hljs-keyword">int</span> checkMode;
	<span class="hljs-keyword">int</span> runtimeParamIndex;
	<span class="hljs-keyword">float</span> referenceValue;<font></font>
};<font></font>
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態には、状態が再生される速度と、状態マシンによる他の状態への遷移条件のインデックスが含まれます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遷移には、状態インデックス「from」と「to」が含まれています。</font><font style="vertical-align: inherit;">遷移時間、終了時間、およびこの状態に入る条件の配列へのリンク。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentStateは、ステートマシンの現在の状態に関するデータを含むランタイムデータブロックです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimationDefには、BlendTreeによってアニメーションに関連する他のオブジェクトへのリンクを含むアニメーションの説明が含まれています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParameterDefは、ステートマシンの動作を制御するパラメーターの説明です。</font><font style="vertical-align: inherit;">Line0abおよびLine1abは、パラメーターの値によってアニメーションの重みを決定するための直線の方程式の係数です。</font><font style="vertical-align: inherit;">ここから：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ge/dl/wd/gedlwdz-u4iiyqciuy-lewx8xnm.jpeg"><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件-パラメーターのランタイム値と参照値を比較するための条件の指定。</font></font></li>
</ul><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムフェーズ</font></font></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
各ステートマシンのメインループは、次のアルゴリズムを使用して表示できます</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/cu/gc/q_cugcb1tr2krdkztmuxbr1yds8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Unityアニメーターには、float、int、bool、およびトリガー（bool）の4種類のパラメーターがあります。</font><font style="vertical-align: inherit;">それらすべてをフロートとして表示します。</font><font style="vertical-align: inherit;">条件を設定する際に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">種類の比較の中</font><font style="vertical-align: inherit;">から1つを選択できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">==等しい場合。</font><font style="vertical-align: inherit;">IfNot == NotEqual。</font><font style="vertical-align: inherit;">したがって、4のみを使用します。演算子インデックスは、Condition構造のcheckModeフィールドに渡されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t.firstCondition; i &lt; t.endCondition; ++i)<font></font>
{<font></font>
	Condition c = allConditions[i];<font></font>
	<span class="hljs-keyword">float</span> paramValue = runtimeParameters[c.runtimeParamIndex];
	<span class="hljs-keyword">switch</span> (c.checkMode)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:	<span class="hljs-keyword">if</span> (paramValue &lt; c.referenceValue) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:	<span class="hljs-keyword">if</span> (paramValue &gt; c.referenceValue) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(paramValue - c.referenceValue) &gt; <span class="hljs-number">0.001f</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(paramValue - c.referenceValue) &lt; <span class="hljs-number">0.001f</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
	}<font></font>
}<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移行を開始するには、すべての条件が満たされている必要があります。</font><font style="vertical-align: inherit;">奇妙なケースのラベルは、（int）AnimatorConditionModeだけです。</font><font style="vertical-align: inherit;">中断ロジックは、遷移を中断してロールバックするトリッキーなロジックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートマシンの状態を更新し、delta tフレームのタイムスタンプをスクロールした後、このフレームで読み取るアニメーションとそれに対応する重みに関するデータを準備します。</font><font style="vertical-align: inherit;">ユニットモデルがフレーム内にない場合（錐台カリング）、この手順はスキップされます。</font><font style="vertical-align: inherit;">見えないもののアニメーションを考慮する必要があるのはなぜですか？</font><font style="vertical-align: inherit;">ブレンドツリーのソース状態、ブレンドツリーの宛先状態を調べ、それらからすべてのアニメーションを追加し、ソースから宛先への遷移の正規化された時間（遷移に費やされた時間）によって重みを計算します。</font><font style="vertical-align: inherit;">準備されたデータを使用して、GPASが登場し、ゲーム内のアニメーション化されたエンティティごとにアニメーションをカウントします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニット制御パラメータは、ユニット制御ロジックから取得されます。</font><font style="vertical-align: inherit;">たとえば、実行を有効にし、CharSpeedパラメーターを設定する必要があります。正しく構成されたステートマシンは、「ウォーキング」から「ランニング」への移行アニメーションをスムーズにブレンドします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、Unity Animatorとの完全な類似性は機能しませんでした。</font><font style="vertical-align: inherit;">文書に記載されていない場合、作業の内部原則を逆転させ、類似物を作成する必要がありました。</font><font style="vertical-align: inherit;">一部の機能はまだ完了していません（完了していない可能性があります）。</font><font style="vertical-align: inherit;">たとえば、BlendTreeのBlendTypeは1Dのみをサポートします。</font><font style="vertical-align: inherit;">他のタイプを作ることは、原則として、難しくはありませんが、今は必要ありません。</font><font style="vertical-align: inherit;">GPUでリードバックを行う必要があるため、アニメーションイベントはありません。「正しい」リードバックは数フレーム遅れますが、これは常に許容できるわけではありません。</font><font style="vertical-align: inherit;">しかし、それも可能です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニットのレンダリングはインスタンス化によって行われます。</font><font style="vertical-align: inherit;">SV_InstanceIDによると、頂点シェーダーで、頂点に影響を与えるすべてのボーンのマトリックスを取得して変換します。</font><font style="vertical-align: inherit;">絶対に異常なことは絶対にありません：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">float4 <span class="hljs-title">ApplySkin</span><span class="hljs-params">(float3 v, uint vertexID, uint instanceID)</span>
</span>{<font></font>
	BoneInfoPacked bip = boneInfos[vertexID];<font></font>
	BoneInfo bi = UnpackBoneInfo(bip);<font></font>
<font></font>
	SkeletonInstance skelInst = skeletonInstances[instanceID];<font></font>
	<span class="hljs-keyword">int</span> bonesOffset = skelInst.boneOffset;<font></font>
<font></font>
	float4x4 animMat = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<font></font>
	{<font></font>
		<span class="hljs-keyword">float</span> bw = bi.boneWeights[i];
		<span class="hljs-keyword">if</span> (bw &gt; <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			uint boneId = bi.boneIDs[i];<font></font>
			float4x4 boneMat = boneMatrices[boneId + bonesOffset];<font></font>
			animMat += boneMat * bw;<font></font>
		}<font></font>
	}<font></font>
	float4 rv = float4(v, <span class="hljs-number">1</span>);<font></font>
	rv = mul(rv, animMat);<font></font>
	<span class="hljs-keyword">return</span> rv;<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このファームは高速で動作しますか？マトリックスでテクスチャをサンプリングするよりも明らかに遅いですが、それでも、いくつかの数値を表示できます（GTX 970）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに50,000のステートマシンがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cw/bv/4o/cwbv4oww0dles0lwgt-xlsqxg5m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに280,000のアニメーションボーン</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pe/lt/pv/peltpvbyztjsutrkxmhxyjbimbs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
があります。これらすべてを設計およびデバッグするのは本当に大変です。バッファとオフセットの束。たくさんのコンポーネントとそれらの相互作用。数日間問題について頭を打ったときに手が落ちたときがありましたが、問題が何であるかを見つけることができません。テストデータですべてが正常に機能する場合は特に「快適」ですが、実際の「戦闘」状況では、アニメーションの不具合は発生しません。 Unityステートマシンの動作とそれらの動作の不一致もすぐには表示されません。一般的に、自分でアナログを作成することに決めた場合、私はあなたをうらやましく思いません。実際、GPUでの開発全体はそのようなものであり、文句を言うのです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unite TechDemo開発者の庭に石を投げたいと思います。</font><font style="vertical-align: inherit;">彼らはステージ上に廃墟と橋の多数の同一のモデルを持っています、そして彼らはどのようにも彼らのレンダリングを最適化しませんでした。</font><font style="vertical-align: inherit;">むしろ、彼らは「静的」にチェックを入れてみました。</font><font style="vertical-align: inherit;">現在、16ビットインデックスでは、モデルが非常に多角形であるため、多くのジオメトリを詰め込むことはできず（2017年の3倍）、何も集まっていません。</font><font style="vertical-align: inherit;">すべてのシェーダーに「インスタンス化を有効にする」をオンにし、「静的」をオフにします。</font><font style="vertical-align: inherit;">目に見えるブーストはありませんでしたが、くそー、テクノデモをやっていて、すべてのFPSのために戦っています。</font><font style="vertical-align: inherit;">あなたはそのようにくだらないことはできません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そうだった</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">*** Summary ***<font></font>
<font></font>
Draw calls: 2553<font></font>
Dispatch calls: 0<font></font>
API calls: 8378<font></font>
	Index/vertex bind calls: 2992<font></font>
	Constant bind calls: 648<font></font>
	Sampler bind calls: 395<font></font>
	Resource bind calls: 805<font></font>
	Shader set calls: 682<font></font>
	Blend set calls: 230<font></font>
	Depth/stencil set calls: 92<font></font>
	Rasterization set calls: 238<font></font>
	Resource update calls: 1017<font></font>
	Output set calls: 74<font></font>
API:Draw/Dispatch call ratio: 3.28163<font></font>
<font></font>
298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB.<font></font>
Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32)<font></font>
216 Buffers - 180.11 MB total 17.54 MB IBs 159.81 MB VBs.<font></font>
1528.06 MB - Grand total GPU buffer + texture load.<font></font>
<font></font>
*** Draw Statistics ***<font></font>
<font></font>
Total calls: 2553, instanced: 2, indirect: 2<font></font>
<font></font>
Instance counts:<font></font>
   1:  <font></font>
   2:  <font></font>
   3:  <font></font>
   4:  <font></font>
   5:  <font></font>
   6:  <font></font>
   7:  <font></font>
   8:  <font></font>
   9:  <font></font>
  10:  <font></font>
  11:  <font></font>
  12:  <font></font>
  13:  <font></font>
  14:  <font></font>
&gt;=15: ******************************************************************************************************************************** (2)<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になった</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">*** Summary ***<font></font>
<font></font>
Draw calls: 1474<font></font>
Dispatch calls: 0<font></font>
API calls: 11106<font></font>
	Index/vertex bind calls: 3647<font></font>
	Constant bind calls: 1039<font></font>
	Sampler bind calls: 348<font></font>
	Resource bind calls: 718<font></font>
	Shader set calls: 686<font></font>
	Blend set calls: 230<font></font>
	Depth/stencil set calls: 110<font></font>
	Rasterization set calls: 258<font></font>
	Resource update calls: 1904<font></font>
	Output set calls: 74<font></font>
API:Draw/Dispatch call ratio: 7.5346<font></font>
<font></font>
298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB.<font></font>
Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32)<font></font>
427 Buffers - 93.30 MB total 9.81 MB IBs 80.51 MB VBs.<font></font>
1441.25 MB - Grand total GPU buffer + texture load.<font></font>
<font></font>
*** Draw Statistics ***<font></font>
<font></font>
Total calls: 1474, instanced: 391, indirect: 2<font></font>
<font></font>
Instance counts:<font></font>
   1:  <font></font>
   2: ******************************************************************************************************************************** (104)<font></font>
   3: ************************************************* (40)<font></font>
   4: ********************** (18)<font></font>
   5: ****************************** (25)<font></font>
   6: ********************************************************************************************* (76)<font></font>
   7: *********************************** (29)<font></font>
   8: ************************************************** (41)<font></font>
   9: ********* (8)<font></font>
  10: ************** (12)<font></font>
  11:  <font></font>
  12: ****** (5)<font></font>
  13: ******* (6)<font></font>
  14: ** (2)<font></font>
&gt;=15: ****************************** (25)<font></font>
</code></pre><br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に、ゲームは主にCPUバウンドでした。</font><font style="vertical-align: inherit;">CPUがGPUに対応していません。</font><font style="vertical-align: inherit;">論理と物理が多すぎる。</font><font style="vertical-align: inherit;">ゲームロジックの一部をCPUからGPUに転送し、最初のものをアンロードして2番目のものをロードします。</font><font style="vertical-align: inherit;">GPUバインドの状況をより可能にします。</font><font style="vertical-align: inherit;">したがって、記事のタイトル。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468537/index.html">DevOpsの基本。プロジェクトへの最初からの参入</a></li>
<li><a href="../ja468541/index.html">ドラッグ＆＆-視覚障害者向けのコンポーネントをドロップしますか？冗談ですか？</a></li>
<li><a href="../ja468543/index.html">平日プログラム委員会フロントエンド会議。セルゲイ・ポポフとのインタビュー</a></li>
<li><a href="../ja468545/index.html">「アリス、フロントエンドに行こう！」</a></li>
<li><a href="../ja468547/index.html">FrontendConfでの英語圏、CSS、グリッド、およびアクセシビリティ</a></li>
<li><a href="../ja468553/index.html">バージョン管理システムと同様のビジネスアプリケーションでのパラメーター管理</a></li>
<li><a href="../ja468555/index.html">C / C ++の確定的アセンブリの紹介。パート2</a></li>
<li><a href="../ja468557/index.html">WEB 3.0-発射物への2番目のアプローチ</a></li>
<li><a href="../ja468559/index.html">クラウドのバックアップ、友達</a></li>
<li><a href="../ja468561/index.html">セキュリティウィーク39：セキュリティと一般的なミス</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>