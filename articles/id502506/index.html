<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ² ğŸ›£ï¸ ğŸ”‡ Penjadwal GO: Sekarang Bukan Koperasi? ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ”ƒ ğŸ‘¯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda membaca catatan rilis untuk versi GO 1.14, Anda mungkin memperhatikan beberapa perubahan yang cukup menarik pada runtime bahasa. Jadi saya s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Penjadwal GO: Sekarang Bukan Koperasi?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda membaca catatan rilis untuk versi GO 1.14, Anda mungkin memperhatikan beberapa perubahan yang cukup menarik pada runtime bahasa. </font><font style="vertical-align: inherit;">Jadi saya sangat tertarik pada item tersebut: "Goroutine sekarang lebih dulu tidak sinkron." </font><font style="vertical-align: inherit;">Ternyata penjadwal GO (scheduler) sekarang tidak kooperatif? </font><font style="vertical-align: inherit;">Nah, setelah membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposal yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sesuai secara diagonal, </font><font style="vertical-align: inherit;">rasa penasaran pun puas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, setelah beberapa saat saya memutuskan untuk meneliti inovasi secara lebih rinci. </font><font style="vertical-align: inherit;">Saya ingin membagikan hasil studi ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/ur/hn/s0urhnlqgwhwtkwumpnyd2hfmyy.png" alt="gambar"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persyaratan sistem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal-hal yang diuraikan di bawah ini diperlukan dari pembaca, selain pengetahuan tentang bahasa GO, pengetahuan tambahan, yaitu:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memahami prinsip-prinsip penjadwal (walaupun saya akan mencoba menjelaskan di bawah ini, "dengan jari")</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memahami cara kerja pengumpul sampah</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memahami apa itu GO assembler </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, saya akan meninggalkan beberapa tautan yang, menurut pendapat saya, membahas topik-topik ini dengan baik.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara singkat tentang perencana</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, izinkan saya mengingatkan Anda apa multitasking kooperatif dan non-kooperatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan multitasking non-kooperatif, kita semua terbiasa dengan contoh penjadwal OS. Penjadwal ini berfungsi di latar belakang, membongkar utas berdasarkan berbagai heuristik, dan alih-alih waktu CPU yang dibongkar, utas lain mulai menerima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perencana kooperatif ditandai oleh perilaku yang berbeda - ia tidur sampai salah satu goroutin jelas membangunkannya dengan sedikit kesiapan untuk memberikan tempatnya kepada yang lain. Perencana kemudian akan memutuskan sendiri apakah perlu menghapus goroutine saat ini dari konteksnya, dan jika demikian, siapa yang akan menggantikannya. Begitulah cara penjadwal GO bekerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, kami mempertimbangkan landasan yang dioperasikan penjadwal:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prosesor P - logis (kita dapat mengubah angka mereka dengan fungsi runtime.GOMAXPROCS), pada setiap prosesor logis satu goroutine dapat dieksekusi secara mandiri pada satu waktu. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utas M - OS. </font><font style="vertical-align: inherit;">Setiap P berjalan pada utas dari M. Perhatikan bahwa P tidak selalu sama dengan M, misalnya, utas dapat diblokir oleh syscall dan kemudian utas lainnya akan dialokasikan untuk P. </font><font style="vertical-align: inherit;">Dan ada CGO dan nuansa lainnya dan lainnya.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G - gorutins. </font><font style="vertical-align: inherit;">Nah di sini jelas, G harus dijalankan pada setiap P dan scheduler memonitor ini.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan hal terakhir yang perlu Anda ketahui, dan kapan penjadwal benar-benar memanggil goroutine? </font><font style="vertical-align: inherit;">Ini sederhana, biasanya instruksi untuk memanggil dimasukkan oleh kompiler di awal tubuh (prolog) dari fungsi (sedikit kemudian kita akan membicarakan hal ini secara lebih rinci).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan apa masalahnya sebenarnya?</font></font></h3><br>
<img src="https://habrastorage.org/webt/8o/fa/qt/8ofaqt_aquvkvzoskizadsuzfyw.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari awal artikel, Anda sudah mengerti bahwa prinsip pekerjaan penjadwal telah berubah di GO, mari kita lihat alasan mengapa perubahan ini dilakukan. </font><font style="vertical-align: inherit;">Lihatlah kodenya:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di bawah spoiler</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
		<span class="hljs-keyword">for</span> {<font></font>
			u -= <span class="hljs-number">2</span>
			<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
				<span class="hljs-keyword">break</span><font></font>
			}<font></font>
		}<font></font>
	}()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>) <span class="hljs-comment">//    main   ,         </span><font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda mengompilasinya dengan versi GO &lt;1.14, maka baris "go 1.13 belum pernah ke sini" Anda tidak akan melihat di layar. </font><font style="vertical-align: inherit;">Ini terjadi karena, segera setelah penjadwal memberi waktu prosesor kepada goroutine dengan loop tak terbatas, ia sepenuhnya menangkap P, tidak ada panggilan fungsi yang terjadi di dalam goroutine ini, yang berarti kita tidak akan membangunkan penjadwal lagi. </font><font style="vertical-align: inherit;">Dan hanya panggilan eksplisit ke runtime.Gosched () akan membiarkan program kami berakhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini hanyalah salah satu contoh di mana goroutine menangkap P dan untuk waktu yang lama mencegah goroutine lain dari mengeksekusi pada P. ini. Opsi lain ketika perilaku ini menyebabkan masalah dapat ditemukan dengan membaca proposal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usulkan proposal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi untuk masalah ini cukup sederhana. Mari kita lakukan hal yang sama seperti pada penjadwal OS! Biarkan GO kehabisan goroutine dari P dan letakkan yang lain di sana, dan untuk ini kita akan menggunakan alat OS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, bagaimana cara mengimplementasikannya? Kami akan mengizinkan runtime untuk mengirim sinyal ke aliran tempat goroutine bekerja. Kami akan mendaftarkan prosesor sinyal ini pada setiap aliran dari M, tugas prosesor adalah untuk menentukan apakah goroutine saat ini dapat digantikan. Jika demikian, kami akan menyimpan status saat ini (register dan status tumpukan) dan memberikan sumber daya ke yang lain, jika tidak kami akan terus menjalankan goroutine saat ini. Perlu dicatat bahwa konsep dengan sinyal adalah solusi untuk sistem berbasis UNIX, sementara, misalnya, implementasi untuk Windows sedikit berbeda. Omong-omong, SIGURG dipilih sebagai sinyal untuk pengiriman.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian tersulit dari implementasi ini adalah menentukan apakah goroutine dapat dipaksa keluar. </font><font style="vertical-align: inherit;">Faktanya adalah bahwa beberapa tempat dalam kode kita harus berupa atom, dari sudut pandang pengumpul sampah. </font><font style="vertical-align: inherit;">Kami menyebut tempat-tempat semacam itu tidak aman. </font><font style="vertical-align: inherit;">Jika kita menekan goroutine pada saat eksekusi kode dari titik yang tidak aman, dan kemudian GC mulai, maka itu akan menangkap keadaan goroutine kita yang diambil di titik yang tidak aman dan dapat melakukan hal-hal. </font><font style="vertical-align: inherit;">Mari kita lihat lebih dekat konsep aman / tidak aman.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Anda pergi ke sana, GC?</font></font></h3><br>
<img src="https://habrastorage.org/webt/yw/ao/mw/ywaomwcstazbytzl9gwewm9agy8.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam versi sebelum 1.12, runtime Gosched menggunakan titik aman di tempat-tempat di mana Anda pasti dapat memanggil penjadwal tanpa takut bahwa kita akan berakhir di bagian atom kode untuk GC. </font><font style="vertical-align: inherit;">Seperti yang telah kami katakan, data titik aman terletak di prolog suatu fungsi (tetapi tidak untuk setiap fungsi, ingatlah). </font><font style="vertical-align: inherit;">Jika Anda membongkar assembler go-shn, Anda bisa keberatan - tidak ada panggilan penjadwal yang terlihat di sana. </font><font style="vertical-align: inherit;">Ya, tetapi Anda dapat menemukan instruksi panggilan runtime.morestack di sana, dan jika Anda melihat ke dalam fungsi ini, panggilan penjadwal akan ditemukan. </font><font style="vertical-align: inherit;">Di bawah spoiler, saya akan menyembunyikan komentar dari sumber GO, atau Anda dapat menemukan assembler untuk morestack sendiri.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditemukan dalam sumber</font></font></b>
                        <div class="spoiler_text">Synchronous safe-points are implemented by overloading the stack bound check in function prologues. To preempt a goroutine at the next synchronous safe-point, the runtime poisons the goroutine's stack bound to a value that will cause the next stack bound check to fail and enter the stack growth implementation, which will detect that it was actually a preemption and redirect to preemption handling.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas, ketika beralih ke konsep crowding-out, sinyal crowding-out dapat menangkap gorutin kita di mana saja. Tetapi penulis GO memutuskan untuk tidak meninggalkan titik aman, tetapi menyatakan titik aman di mana-mana! Yah, tentu saja, ada tangkapan, hampir di mana-mana sebenarnya. Seperti disebutkan di atas, ada beberapa poin tidak aman di mana kami tidak akan memaksa siapa pun. Mari kita menulis poin sederhana yang tidak aman.</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
j := &amp;someStruct{}<font></font>
p := unsafe.Pointer(j)<font></font>
<span class="hljs-comment">// unsafe-point start</span>
u := <span class="hljs-keyword">uintptr</span>(p)
<span class="hljs-comment">//do some stuff here</span><font></font>
p = unsafe.Pointer(u)<font></font>
<span class="hljs-comment">// unsafe-point end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami apa masalahnya, mari kita coba pada pengumpul sampah. Setiap kali kita pergi bekerja, kita perlu mencari tahu node root (pointer pada stack dan register), yang dengannya kita akan mulai menandai. Karena tidak mungkin untuk mengatakan dalam runtime apakah 64 byte dalam memori adalah sebuah pointer atau hanya sebuah angka, kita beralih ke tumpukan dan mendaftar kartu (beberapa cache dengan informasi meta), disediakan kepada kami oleh kompiler GO. Informasi dalam peta ini memungkinkan kami untuk menemukan petunjuk. Jadi, kami terbangun dan dikirim ke kantor ketika GO menampilkan nomor 4. Tiba di tempat dan melihat kartu-kartu, kami menemukan bahwa itu kosong (dan ini benar, karena uintptr dari sudut pandang GC adalah angka dan bukan penunjuk). Nah, kemarin kita mendengar tentang alokasi memori untuk j, karena sekarang kita tidak bisa mendapatkan memori ini - kita perlu membersihkannya, dan setelah melepas memori kita pergi tidur.Apa berikutnya? Nah, pihak berwenang bangun, pada malam hari, berteriak, yah, Anda sendiri mengerti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu semua dengan teori, saya mengusulkan untuk mempertimbangkan dalam praktek bagaimana semua sinyal ini, poin yang tidak aman dan kartu register dan tumpukan bekerja.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lanjutkan berlatih</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menjalankan dua kali (pergi 1,14 dan pergi 1,13) contoh dari awal artikel oleh profiler perf untuk melihat apa panggilan sistem yang terjadi dan membandingkannya. </font><font style="vertical-align: inherit;">Syscall yang diperlukan dalam versi ke-14 ditemukan dengan cukup cepat:</font></font><br>
<br>
<pre><code class="plaintext hljs">15.652 ( 0.003 ms): main/29614 tgkill(tgid: 29613 (main), pid: 29613 (main), sig: URG                ) = 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, tentu saja runtime mengirim SIGURG ke utas tempat goroutine berputar. </font><font style="vertical-align: inherit;">Mengambil pengetahuan ini sebagai titik awal, saya pergi untuk melihat komit di GO untuk menemukan di mana dan untuk alasan apa sinyal ini dikirim, serta untuk menemukan tempat di mana pengendali sinyal dipasang. </font><font style="vertical-align: inherit;">Mari kita mulai dengan mengirim, kita akan menemukan fungsi pengiriman sinyal di runtime / os_linux.go</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">signalM</span><span class="hljs-params">(mp *m, sig <span class="hljs-keyword">int</span>)</span></span> {<font></font>
	tgkill(getpid(), <span class="hljs-keyword">int</span>(mp.procid), sig)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami menemukan tempat di kode runtime, dari mana kami mengirim sinyal:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat goroutine ditangguhkan, jika sedang dalam kondisi berjalan. </font><font style="vertical-align: inherit;">Permintaan penangguhan berasal dari pengumpul sampah. </font><font style="vertical-align: inherit;">Di sini, mungkin, saya tidak akan menambahkan kode, tetapi dapat ditemukan di file runtime / preempt.go (suspendG)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika penjadwal memutuskan bahwa goroutine bekerja terlalu lama, runtime / proc.go (retake)</font></font><br>
<pre><code class="go hljs">
<span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now {<font></font>
	signalM(_p_)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
forcePreemptNS - konstan sama dengan 10ms, pd.schedwhen - waktu ketika scheduler untuk aliran pd disebut terakhir kali</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> serta semua aliran sinyal ini dikirim selama kepanikan, StopTheWorld (GC) dan beberapa kasus lainnya (yang harus saya bypass, karena ukuran artikel sudah akan melampaui batas)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menemukan cara dan kapan runtime mengirim sinyal ke M. </font><font style="vertical-align: inherit;">Sekarang mari kita cari pawang untuk sinyal ini dan lihat apa yang dilakukan arus ketika diterima.</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> {
	<span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) {
		<span class="hljs-comment">// Inject a call to asyncPreempt.</span><font></font>
		ctxt.pushCall(funcPC(asyncPreempt))<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari fungsi ini jelas bahwa untuk "mengunci" Anda harus melalui 2 pemeriksaan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wantAsyncPreempt - kami memeriksa apakah G ingin dipaksa keluar, di sini, misalnya, validitas status goroutine saat ini akan diperiksa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint - periksa apakah itu bisa ramai sekarang. </font><font style="vertical-align: inherit;">Yang paling menarik dari cek di sini adalah apakah G berada di titik aman atau tidak aman. </font><font style="vertical-align: inherit;">Selain itu, kita harus yakin bahwa utas yang menjalankan G juga siap untuk mendahului G.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kedua pemeriksaan dilewatkan, instruksi akan dipanggil dari kode yang dapat dieksekusi yang menyimpan status G dan memanggil penjadwal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan lebih lanjut tentang tidak aman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengusulkan untuk menganalisis contoh baru, itu akan menggambarkan kasus lain dengan poin tidak aman:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">program tanpa akhir lainnya</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">infiniteLoop</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> {<font></font>
		u -= <span class="hljs-number">2</span>
		<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
			<span class="hljs-keyword">break</span><font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> infiniteLoop()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>)<font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 and 1.14 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda tebak, tulisan "go 1.13 dan 1.14 tidak pernah ada di sini" tidak akan kita lihat di GO 1.14. </font><font style="vertical-align: inherit;">Ini karena kami telah secara eksplisit melarang untuk mengganggu fungsi infiniteLoop (go: nosplit). </font><font style="vertical-align: inherit;">Larangan semacam itu diterapkan hanya menggunakan titik tidak aman, yang merupakan seluruh tubuh fungsi. </font><font style="vertical-align: inherit;">Mari kita lihat apa yang dikompilasi oleh kompiler untuk fungsi infiniteLoop.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler Perhatian</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   TEXT    <span class="hljs-string">""</span>.infiniteLoop(SB), NOSPLIT|ABIInternal, $<span class="hljs-number">0</span><span class="hljs-number">-0</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">0</span>, gclocalsÂ·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">1</span>, gclocalsÂ·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">2</span>, gclocalsÂ·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   XORL    AX, AX
        <span class="hljs-number">0x0002</span> <span class="hljs-number">00002</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">12</span>)   JMP     <span class="hljs-number">8</span>
        <span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>)   ADDQ    $<span class="hljs-number">-2</span>, AX
        <span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   CMPQ    AX, $<span class="hljs-number">3</span>
        <span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   JNE     <span class="hljs-number">4</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   RET
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, instruksi PCDATA menarik. </font><font style="vertical-align: inherit;">Ketika tautan melihat instruksi ini, itu tidak mengubahnya menjadi assembler "nyata". </font><font style="vertical-align: inherit;">Sebaliknya, nilai argumen 2 dengan kunci sama dengan penghitung program yang sesuai (angka yang dapat diamati di sebelah kiri nama fungsi + baris) akan ditempatkan di register atau tumpukan peta (ditentukan oleh argumen 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang kita lihat pada baris 10 dan 15, kita menempatkan nilai masing-masing $ 2 dan -1 di peta $ 0 dan $ 1. </font><font style="vertical-align: inherit;">Mari kita ingat momen ini dan melihat ke dalam fungsi isAsyncSafePoint, yang saya telah menarik perhatian Anda. </font><font style="vertical-align: inherit;">Di sana kita akan melihat baris berikut:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
	smi := pcdatavalue(f, _PCDATA_RegMapIndex, pc, <span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> smi == <span class="hljs-number">-2</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
	}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di tempat inilah kami memeriksa apakah goroutine saat ini berada di titik aman. </font><font style="vertical-align: inherit;">Kami membuka peta register (_PCDATA_RegMapIndex = 0), dan meneruskannya ke pc saat ini kami memeriksa nilainya, jika -2 maka G tidak dalam safe-point'e, yang berarti tidak bisa dihilangkan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menghentikan "penelitian" saya tentang ini, saya harap artikel itu bermanfaat bagi Anda juga. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memposting tautan yang dijanjikan, tetapi harap berhati-hati, karena beberapa informasi dalam artikel ini dapat kedaluwarsa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penjadwal GO - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekali</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua kali</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler GO.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id502494/index.html">7 kesalahan satu Black Friday dan bagaimana Magento Cloud bekerja - video</a></li>
<li><a href="../id502496/index.html">Akses Web Mudah ke Aplikasi PHP LabVIEW VI melalui ActiveX Server</a></li>
<li><a href="../id502498/index.html">Praktik terbaik untuk meningkatkan kinerja dalam C #</a></li>
<li><a href="../id502500/index.html">Evolusi pemindai paspor: dari kerajinan kayu lapis ke bisnis nyata</a></li>
<li><a href="../id502504/index.html">Kelilingi digit pengguna</a></li>
<li><a href="../id502508/index.html">Robot Troli 2.0. Bagian 2. Manajemen dalam rviz dan tanpa Elemen kecantikan di rviz</a></li>
<li><a href="../id502510/index.html">Apa yang harus disimpan di cloud</a></li>
<li><a href="../id502512/index.html">Hasil dari kontes ahli sofa: aturan poking ilmiah</a></li>
<li><a href="../id502518/index.html">Cara memanjat pohon</a></li>
<li><a href="../id502520/index.html">Laporan video dari laporan mitap tentang analitik produk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>