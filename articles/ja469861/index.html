<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 👼🏾 🏢 ゲームプログラマー向けのデータ構造：バルクデータ 👐 👩🏼‍🚀 🗃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プログラマーは、さまざまなデータ構造とそのパフォーマンスを分析する方法を理解することでメリットを得られます。しかし、実際には、AVLツリー、赤黒ツリー、プレフィックスツリー、スキップリストなどには便利ではありません。私は1つの特定のアルゴリズムのために、より何のためにいくつかのデータ構造を使用する（...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ゲームプログラマー向けのデータ構造：バルクデータ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーは、さまざまな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とそのパフォーマンスを分析する方法を</font><font style="vertical-align: inherit;">理解することでメリットを得られ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">しかし、実際には、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVLツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">赤黒</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレフィックスツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキップリスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などに</font><font style="vertical-align: inherit;">は便利ではありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私は1つの特定のアルゴリズムのために、より何のためにいくつかのデータ構造を使用する（例えば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装するための</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライオリティキューを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *経路探索アルゴリズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
日常の仕事では、通常、驚くほど少ないデータ構造で作業します。</font><font style="vertical-align: inherit;">ほとんどの場合、これらは私にとって便利です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有データ配列（バルクデータ）-多数のオブジェクトを効果的に格納する方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱い参照（または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハンドル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-オブジェクトが削除された場合にプログラムがクラッシュすることなく、バルクデータ内のオブジェクトにアクセスする方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスは、バルクデータの個々のサブセットにすばやくアクセスする方法です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列の配列は、動的サイズのバルクデータオブジェクトを格納する方法です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての構造を通常どのように実装するかについて、いくつかの記事を取り上げます。</font><font style="vertical-align: inherit;">最も簡単で最も便利なバルクデータから始めましょう。</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バルクデータ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この概念に共通の用語はありません（または私はそれについて知りません）。</font><font style="vertical-align: inherit;">類似オブジェクトの大規模なコレクションを</font><font style="vertical-align: inherit;">「</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バルクデータ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">と呼び</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">たとえば、次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内のすべての弾丸。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内のすべての木。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内のすべてのコイン。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、より高い抽象化レベルでコードを記述している場合は、次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内のすべてのエンティティ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内のすべてのメッシュ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内のすべての音。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、ゲームの各システム（レンダリング、サウンド、アニメーション、物理など）には、追跡する必要のあるいくつかの異なるタイプのオブジェクトがあります。</font><font style="vertical-align: inherit;">たとえば、サウンドシステムの場合は次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再生</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できる</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのサウンドリソース</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再生中のすべてのサウンド</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サウンドに適用されるすべてのエフェクト（減衰、トーンの変更など）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バルクデータの場合は、次のように想定します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの格納順序は重要ではありません。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">配列は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">として認識され</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各オブジェクトは、</font><font style="vertical-align: inherit;">を使用して移動または複製できる固定サイズの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なデータ構造（POD構造体）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として表されます</font></font><code>memcpy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、順序が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である状況を思い付くことができます</font><font style="vertical-align: inherit;">。たとえば、オブジェクトがレンダリングの要素を表す場合、レンダリングの前に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再描画</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の量を減らすためにオブジェクトを前から後ろにソートする必要がある場合があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ほとんどの場合</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">赤黒木</font></a><font style="vertical-align: inherit;">や</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">B </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ツリー</font></a><font style="vertical-align: inherit;">などの並べ替えられたコンテナにデータを保存するよりも、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用された</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とおりにデータを並べ替えることが望ましいと思います。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、レンダラーに渡す前にレンダリングされたオブジェクトを前から後ろに並べ替えたり、ファイルをリストとして画面に表示する前にファイルをアルファベット順に並べ替えたりできます。各フレームのデータのソートはコストがかかるように見えるかもしれませんが、多くの場合、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">基数ソート</font></a><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）で</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行われ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なデータ構造のみを使用しているので、メモリ内で何が起こっているのかを理解し、そのパフォーマンスを評価するのが簡単なので、C ++オブジェクトよりもC ++オブジェクトを好みます。</font><font style="vertical-align: inherit;">ただし、固定サイズではないデータを大量に格納する必要がある場合があります。</font><font style="vertical-align: inherit;">たとえば、子オブジェクトの名前またはリスト。</font><font style="vertical-align: inherit;">これらのケースについては、別の投稿で説明します。ここでは、「配列の配列」について説明します。</font><font style="vertical-align: inherit;">ここでは、すべてのオブジェクトが単純な固定サイズのデータ​​構造であると仮定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、架空のサウンドシステムのバルクデータ構造は次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">resource_t</span> *resource;       <span class="hljs-comment">// Resource manager data</span>
    <span class="hljs-keyword">uint64_t</span> bytes;             <span class="hljs-comment">// Size of data</span>
    <span class="hljs-keyword">uint64_t</span> format;            <span class="hljs-comment">// Data format identifier</span>
} <span class="hljs-keyword">sound_resource_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">sound_resource_t</span> *resource; <span class="hljs-comment">// Resource that's playing</span>
    <span class="hljs-keyword">uint64_t</span> samples_played;    <span class="hljs-comment">// Number of samples played</span>
    <span class="hljs-keyword">float</span> volume;               <span class="hljs-comment">// Volume of playing sound</span>
} <span class="hljs-keyword">playing_sound_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">playing_sound_t</span> *sound;     <span class="hljs-comment">// Faded sound</span>
    <span class="hljs-keyword">float</span> fade_from;            <span class="hljs-comment">// Volume to fade from</span>
    <span class="hljs-keyword">float</span> fade_to;              <span class="hljs-comment">// Volume to fade to</span>
    <span class="hljs-keyword">double</span> fade_from_ts;        <span class="hljs-comment">// Time to start fade</span>
    <span class="hljs-keyword">double</span> fade_to_ts;          <span class="hljs-comment">// Time to end fade</span>
} <span class="hljs-keyword">playing_fade_t</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バルクデータを保存する方法を検討する場合、いくつかの目標を考慮する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの追加と削除は高速です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、キャッシュ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">便利な</font></strong><font style="vertical-align: inherit;">形式</font><strong><font style="vertical-align: inherit;">で</font></strong><font style="vertical-align: inherit;">配置する必要があります。これにより、データを</font><font style="vertical-align: inherit;">すばやく繰り返してシステムを更新できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはサポートしている必要があり</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リンク機構を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -送信情報への道がなければならない</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程度</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のバルクデータ内の特定のオブジェクト。</font><font style="vertical-align: inherit;">上記の例では、フェードで減衰するサウンドを指定できる必要があります。</font><font style="vertical-align: inherit;">この例では、リンクをポインタとして記述しましたが、それらの実装は、バルクデータの配置方法によって異なります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アロケータである</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要があり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">フレンドリ</font></strong><font style="vertical-align: inherit;"> -いくつかの大きなメモリ割り当てを使用し、ヒープに個々のオブジェクトを割り当てないでください。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バルクデータを表す最も簡単な2つの方法は、静的配列またはC ++ベクトルです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Static array</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_PLAYING_SOUNDS 1024</span>
<span class="hljs-keyword">uint32_t</span> num_playing_sounds;
<span class="hljs-keyword">playing_sound_t</span> playing_sounds[MAX_PLAYING_SOUNDS];<font></font>
<font></font>
<span class="hljs-comment">// C++ vector</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">playing_sound_t</span>&gt; playing_sounds;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列の操作は非常に簡単であり、アプリケーションで必要なオブジェクトの数が正確にわかっている場合は、問題なく機能します。</font><font style="vertical-align: inherit;">これがわから</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は</font><font style="vertical-align: inherit;">、メモリを浪費するか、オブジェクトが不足します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベクトル</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も非常に価値がありシンプルなソリューションですが、ここではいくつかの側面を考慮する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual Studioから</font><font style="vertical-align: inherit;">の標準実装</font><font style="vertical-align: inherit;">は、デバッグイテレータが原因で、デバッグモードでは遅くなります。</font><font style="vertical-align: inherit;">これらは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_ITERATOR_DEBUG_LEVEL = 0に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設定する必要があります</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンストラクタとデストラクタ</font><font style="vertical-align: inherit;">を使用してオブジェクトを作成および破棄します</font></font><code>memcpy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">場合によっては、</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">よりもはるかに遅くなることがあります</font><font style="vertical-align: inherit;">。</font></font></li>
<li><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「伸縮性バッファ」を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装するよりも分析がはるかに困難</font><font style="vertical-align: inherit;">です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、追加のメジャーがない場合、通常の配列もベクトルも個々のオブジェクトへの参照をサポートしません。</font><font style="vertical-align: inherit;">このトピックと、バルクデータシステムの作成に関連する他の重要な設計上の決定を見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除去戦略</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の重要な決定：オブジェクトを削除するときにどうするか</font></font><code>a[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">主なオプションは次の3つです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後続のすべての要素</font></font><code>a[i+1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;→&nbsp; </font></font><code>a[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、&nbsp; </font></font><code>a[i+2]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;→&nbsp; </font></font><code>a[i+1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、など</font><font style="vertical-align: inherit;">をシフトして</font><font style="vertical-align: inherit;">、空のスロットを閉じる</font><font style="vertical-align: inherit;">ことができ</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のスロットの最後の要素を移動できます：</font></font><code>a[i] = a[n-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、配列に穴を作成して、スロットを空のままにすることもできます。</font><font style="vertical-align: inherit;">この穴は、後で新しいオブジェクトを配置するために使用できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のオプションはひどいです</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O（n）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれらすべての要素の移動に費やされます</font><font style="vertical-align: inherit;">。最初の方法の唯一の利点は、配列がソートされている場合、配列の順序が保持されることです。しかし、上記のように、注文は私たちを気にしません。を使用</font></font><code>a.erase()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してアイテムを削除する</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、これが発生</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプションは、しばしば「スワップアンドポップ」と呼ばれます。どうして？ C ++ベクトルを使用する場合、このオプションは通常、削除する要素を最後の要素に置き換える（スワップする）ことによって実装され、最後の要素を削除またはポップします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::swap(a[i], a[a.size() - <span class="hljs-number">1</span>]);<font></font>
a.pop_back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれがすべて必要なのですか？ C ++では、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代入</font></font></em> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実行する場合</font></font><code>a[i] = a[n-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、まず</font></font><code>a[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デストラクタを呼び出して</font><font style="vertical-align: inherit;">削除</font><font style="vertical-align: inherit;">し、次にコピーコンストラクターを呼び出して</font></font><code>a[n-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その位置に</font><font style="vertical-align: inherit;">コピーを作成し、</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後</font></font><code>a[n-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にベクトルがシフトされたときに</font><font style="vertical-align: inherit;">デストラクタを呼び出す必要</font><font style="vertical-align: inherit;">があります。コピーコンストラクターがメモリを割り当ててデータをコピーする場合、これはかなり悪い場合があります。割り当ての代わりに使用する場合</font></font><code>std::swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンストラクターのmoveでのみ実行でき、メモリを割り当てる必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しになりますが、C ++は単純なデータ構造とC演算を好む理由です。C++には多くのパフォーマンスの落とし穴があり、内部で何が起こっているのかわからない場合に陥る可能性があります。 Cでは、swap-erase操作は非常に簡単です。</font></font><br>
<br>
<pre><code class="cpp hljs">a.data[i] = a.data[--a.n];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
swap-and-popを使用すると、オブジェクトは密にパックされたままになります。新しいオブジェクトを配置するには、単にそれを配列の最後にアタッチします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「穴あり」オプションIを使用する場合、新しいオブジェクトを配置するときは、まず、使用できる空き「穴」があるかどうかを確認する必要があります。空き「穴」がない場合にのみ、配列のサイズを大きくする価値があります。そうしないと、オブジェクトを削除して作成するプロセスで、オブジェクトが無制限に大きくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
穴の位置を追跡するために別のものを使用できますが、</font></font><code>std::vector&lt;uint32_t&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加のメモリを必要としないより良い解決策があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「穴」内のオブジェクトのデータは何にも使用されないため、次の空き穴へのポインタを格納するために使用できます。したがって、配列内のすべての穴は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純に接続されたリストを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形成し、</font><font style="vertical-align: inherit;">必要に応じて、そこに要素を追加および削除できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプのデータ構造は、未使用のメモリを使用して空き要素をバインドするものであり、通常</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は空きリスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来のリンクリストでは、特別なリスト</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダー要素</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はリストの最初のノードを指し、最後のリスト要素はNULLを指します。これはリストの終わりを意味します。代わりに、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">循環リンクリスト</font></a><font style="vertical-align: inherit;">を使用することを好み</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タイトルは単なる特別なリストアイテムであり、リストの最後のアイテムはタイトルアイテムを指します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">従来のリストとリングリンクリスト。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このアプローチの利点は、リストの最初と最後の特殊なケースの数を減らすことにより、コードがはるかに単純になることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレージ</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">オブジェクトを使用する場合</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">オブジェクトへの</font><font style="vertical-align: inherit;">ポインターはベクターの再配布ごとに変化する</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。これは、ポインターが常に変化しているため、リンクリストへの通常のポインターを使用できないことを意味します。この問題を回避するには、インデックスをリンクリストの「ポインタ」として使用できます。これは、配列を再配布する場合でも、インデックスは常に特定のスロットを指すためです。再割り当てについては、次のセクションで詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常に配列0のスロットに格納することにより、リストタイトルの特別な要素にスペースを割り当てることができます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。この場合、コードは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// The objects that we want to store:</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>...} <span class="hljs-keyword">object_t</span>;<font></font>
<font></font>
<span class="hljs-comment">// An item in the free list points to the next one.</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">uint32_t</span> next_free;<font></font>
} <span class="hljs-keyword">freelist_item_t</span>;<font></font>
<font></font>
<span class="hljs-comment">// Each item holds either the object data or the free list pointer.</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> {
    <span class="hljs-keyword">object_t</span>;
    <span class="hljs-keyword">freelist_item_t</span>;<font></font>
} <span class="hljs-keyword">item_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">item_t</span>&gt; items;<font></font>
} <span class="hljs-keyword">bulk_data_t</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_item</span><span class="hljs-params">(<span class="hljs-keyword">bulk_data_t</span> *bd, <span class="hljs-keyword">uint32_t</span> i)</span> </span>{
    <span class="hljs-comment">// Add to the freelist, which is stored in slot 0.</span>
    bd-&gt;items[i].next = bd-&gt;items[<span class="hljs-number">0</span>].next;<font></font>
    bd-&gt;items[<span class="hljs-number">0</span>].next = i;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">allocate_slot</span><span class="hljs-params">(<span class="hljs-keyword">bulk_data_t</span> *bd)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> slot = bd-&gt;items[<span class="hljs-number">0</span>].next;<font></font>
    bd-&gt;items[<span class="hljs-number">0</span>].next = bd-&gt;items[slot].next;
    <span class="hljs-comment">// If the freelist is empty, slot will be 0, because the header</span>
    <span class="hljs-comment">// item will point to itself.</span>
    <span class="hljs-keyword">if</span> (slot) <span class="hljs-keyword">return</span> slot;<font></font>
    bd-&gt;items.resize(bd-&gt;items.size() + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> bd-&gt;items.size() - <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最良の除去戦略は何ですか？</font><font style="vertical-align: inherit;">最後の要素を空のスロットに移動して、配列のタイトなパッキングを確保するか、削除された要素の代わりに配列に「穴」を作成してすべての要素をその場所に保持しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
決定を行う際には、2つの側面を考慮する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密にパックされた配列を繰り返し処理すると、バイパスするメモリが少なくなり、空のスロットをスキップするのに多くの時間を費やす必要がないため、高速になります。</font></font></li>
<li>     ,   .  ,               .                ID    .      -   <code>std::vector</code>  ,    (  ).      ,              .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適なオプションの選択は、プロジェクトによって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（システムを更新するための）すべての要素に対する反復は、外部リンクのマッチングよりも頻繁に発生するため、密にパックされた配列を格納する方が良いと言えます。一方、「穴のある配列」のパフォーマンスは、穴の数が多い場合にのみ悪化すると言えます。ゲーム開発では、通常、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最悪の場合の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスに注意します</font><font style="vertical-align: inherit;">（ゲームで最大の操作が実行されている場合でも、フレームレートを60 Hzにしたい）。 。最悪の場合、実際のオブジェクトの最大数になり、この場合、配列に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">穴がなくなり</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ホールは、オブジェクトの数が減ったときにのみ発生します。これらのオブジェクトの一部を削除したときに発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多数の穴がある配列の処理を高速化するために使用できる戦略もあります。</font><font style="vertical-align: inherit;">たとえば、要素ごとではなく、穴のシーケンス全体を一度にスキップするために、穴の連続シーケンスの長さを追跡できます。</font><font style="vertical-align: inherit;">このデータは「穴」にのみ必要であり、通常の要素には必要ないため、リリースリストのポインタと共にそれらをオブジェクトの未割り当てメモリに格納でき、余分なメモリを無駄にしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、高速反復のためにコードを最適化する必要がない場合は、おそらく「ホール付き配列」オプションを使用するのが最善です。</font><font style="vertical-align: inherit;">これはより単純で、追加の検索構造を必要とせず、オブジェクトインデックスをIDとして使用できるため、非常に便利です。</font><font style="vertical-align: inherit;">さらに、移動するオブジェクトがないため、起こり得るバグが排除されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一括データ削除戦略。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱いポインタ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注として、バルクデータオブジェクトの「弱いポインタ」または「記述子」のサポートを実装するのは簡単だと言えます。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィークポインター</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オブジェクトへの参照であり、参照先のオブジェクトが削除されたことを何らかの方法で判断できます。</font><font style="vertical-align: inherit;">弱いポインタでは、誰がオブジェクトを参照できるかを気にせずにオブジェクトを削除できるので便利です。</font><font style="vertical-align: inherit;">オブジェクトを削除するための弱いポインタがなければ、個々のリンクを検索して無効であると宣言する必要があります。</font><font style="vertical-align: inherit;">リンクがスクリプトコード、ネットワーク上の他のコンピューターなどに格納されている場合、これは特に困難です。</font><em><font style="vertical-align: inherit;">既存のもの</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を一意に識別するIDがすでにあることに注意してください</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト。 「穴あり」オプションでは、このIDは単に要素のインデックスです（要素は決して移動しないため）。密にパックされた配列の場合、このオブジェクトインデックスは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索配列の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコード</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDは再利用できるため、ID自体をウィークポインターとして使用することはできません。要素が削除され、新しい要素が同じスロットに作成された場合、IDだけではそれを把握できません。弱いポインタを取得するには、IDとフィールド</font></font><code>generation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（「世代」）</font><font style="vertical-align: inherit;">を組み合わせる必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">uint32_t</span> id;
    <span class="hljs-keyword">uint32_t</span> generation;<font></font>
} <span class="hljs-keyword">weak_pointer_t</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールド</font></font><code>generation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、バルクデータ配列のスロットが再利用された回数を追跡するオブジェクトの構造体のフィールドです。</font><font style="vertical-align: inherit;">（タイトなパッケージングの場合、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列でスロットが再利用された回数が追跡され</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイテムが削除されると、そのスロットの世代番号が増加します。</font><font style="vertical-align: inherit;">ウィークポインターがまだ有効かどうかを確認するには</font></font><code>generation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、構造体のウィークポインターがそれによって示されるスロット</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">世代と</font><font style="vertical-align: inherit;">一致するかどうかを確認します</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それらが一致する場合、参照しているソースオブジェクトはまだ存在しています。</font><font style="vertical-align: inherit;">そうでない場合、それはそれが削除され、そのスロットがリリースリストにあるか、再利用されたことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールド以降</font></font><code>generation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 「穴」と既存のオブジェクトの両方に必要な場合は、プールの外に保存する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">uint32_t</span> generation;
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">object_t</span>;
        <span class="hljs-keyword">freelist_item_t</span>;<font></font>
    };<font></font>
} <span class="hljs-keyword">item_t</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流通戦略</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を使用して要素のデータを格納する</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、配列がいっぱいで増加する必要がある場合、要素の配列全体が再配布されます。</font><font style="vertical-align: inherit;">既存の要素が新しい配列にコピーされます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;">幾何学的に</font></em></a></font><br>
<br>
<code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">増加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、ベクトルを増やす必要があるたびに、分散要素の数に何らかの係数（通常は×2）が乗算されることを意味します。</font><font style="vertical-align: inherit;">幾何学的な（指数関数的な）成長は、アレイを増やすコストを一定に保つために重要です。</font><font style="vertical-align: inherit;">
配列を再配布するときは、すべての要素を移動する必要があります。これには</font><em><font style="vertical-align: inherit;">O（n）</font></em><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ただし、配列が大きくなるにつれて、別の</font><em><font style="vertical-align: inherit;">nの</font></em><font style="vertical-align: inherit;">スペースを追加します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"></font></em></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズを2倍にするためです。つまり、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">を追加するまで、配列を再度増やす必要はありません</font><font style="vertical-align: inherit;">。つまり、増加コストは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同じ</font><font style="vertical-align: inherit;">ですが、配列への書き込みのn回目にのみ実行します。つまり、平均すると、1つの要素を書き込むコストは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）/ O（n）=です。 O（1）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実行されているすべてのレコードを平均するとコストが固定されるため</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、アイテムを記録するコストは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">償却定数</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ば</font><font style="vertical-align: inherit;">れます。しかし、平均する前に、コストが非常にけいれん的であることが判明することを忘れてはなりません。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコード</font><font style="vertical-align: inherit;">ごとに</font><font style="vertical-align: inherit;">、高さ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピークが得られます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記録コストc </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
また、幾何学的成長を使用しないとどうなるかを見てみましょう。拡張中にメモリを2倍にするのではなく、128スロットを追加するだけだとしましょう。古いデータの移動には依然として</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がかかりますが、追加する128アイテムごとに行う必要があります。つまり、平均コストは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）/ O（128）= O（n）になり</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。要素を配列に書き込むコストは配列のサイズに比例するため、配列が大きくなると、タートルの速度で動作し始めます。おっとっと！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配布戦略</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ほとんどの場合に機能する優れた標準オプションですが、いくつかの問題があります。</font></font><br>
<br>
<ul>
<li>« »        .       , ,    ,              .      ,       .  ,    ,        ,   .</li>
<li>,            . ,      16         .      32 .       16  ,    .         .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に、再割り当てはメモリ内のオブジェクトを移動し、オブジェクトへのすべてのポインタを無効にします。</font><font style="vertical-align: inherit;">これは、追跡が困難なバグの原因となる可能性があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のコードは、オブジェクトを移動するときに発生する可能性があるバグの例です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Create two items and return the sum of their costs. </span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">bulk_data_t</span> *bd)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> slot_1 = allocate_slot(bd);
    <span class="hljs-keyword">item_t</span> *item_1 = &amp;bd-&gt;items[slot_1];
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> slot_2 = allocate_slot(bd);
    <span class="hljs-keyword">item_t</span> *item_2 = &amp;bd-&gt;items[slot_2];
    <span class="hljs-keyword">return</span> item_1-&gt;cost + item_2-&gt;cost;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの問題は、関数</font></font><code>allocate_slot()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がのスペースを作成するために配列を再配布する必要</font><font style="vertical-align: inherit;">がある場合</font><font style="vertical-align: inherit;">があることです</font></font><code>item_2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この場合、それ</font></font><code>item_1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメモリに移動され、ポインタは</font></font><code>item_1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有効でなくなります。この特定のケースでは、割り当てを移動すること</font></font><code>item_1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">エラーを取り除くことができますが</font><font style="vertical-align: inherit;">、そのようなバグはより目立たないように見えることもあります。個人的に、彼らは私を何度も噛みました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような状況は、配列が配布時に正確に再配布された場合にのみバグが発生するという事実により、危険</font></font><code>slot_2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。プログラムは、何かが配布パターンを変更するまで長期間正しく機能し、その後バグが機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題はすべて、別の配布戦略を使用して解決できます。オプションの一部を次に示します。</font></font><br>
<br>
<ul>
<li>      : 16, 32, 64, …,  <em></em>     . ,  16     ,  32   ,  .…     ,         <code>std::vector</code>.</li>
<li>          ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code>,        .</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">       </a>,      ,   ,     ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、それぞれの方法には独自の長所と短所があります。後者は、要素がメモリ内に隣り合って保存されており、1つのバッファを追跡する必要があるため、追加のベクトルやリストを必要としないため、優れています。配列の最大サイズを設定する必要がありますが、仮想アドレスのスペースは非常に大きいため、通常は少しの問題もなく任意の巨大な数を指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想メモリを使用したソリューションを使用できない場合は、固定サイズまたは幾何学的に増加するブロックのどちらのアプローチが適していますか？配列が非常に小さい場合、固定サイズは多くの余分なメモリを消費します。たとえば、ブロックのサイズが16千要素の場合、配列に要素が1つしかない場合でも、これらの16千要素すべてを使用します。一方、幾何学的な拡張では、平均して最後の分散ブロックが50％満たされるため、非常に大きな配列でメモリを浪費します。大規模なアレイの場合、これは数メガバイトになる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度言いますが、ゲームの開発では、</font><em><font style="vertical-align: inherit;">最悪の場合の</font></em><font style="vertical-align: inherit;">ためにコードを最適化することがより重要です。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なので、大きな配列が常に優れたパフォーマンスを発揮するのであれば、小さな配列でメモリを浪費することについて心配する必要はありません。浪費されるメモリの総量が* 16 K * n *を超えることは決してありません。ここで、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はプロジェクト内の個別のバルクデータ配列の数であり、多くの異なる配列（各システムに数個のみ）があるとは思いません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
固定サイズのブロックには、他に2つの利点があります。まず、インデックスで要素を検索する計算がより簡単になりました</font></font><code>blocks\[i / elements_per_block\][i % elements_per_block]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは単なる</font><font style="vertical-align: inherit;">です。第2に、仮想メモリから直接メモリを割り当てる方が、断片化がないため、動的アロケータ（ヒープアロケータ）にアクセスするよりもはるかに効率的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、データストレージに「with hole」オプションを使用する場合</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、オブジェクトが変化しない定数ポインターを受け取るように</font><font style="vertical-align: inherit;">、分散戦略から離れる価値があると私は言いたいと思います</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ほとんどの場合、仮想メモリの大きな配列が最適なソリューションになりますが、それを実装できない場合、2番目に最適なオプションは、固定サイズの一連のブロックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチではオブジェクトへのポインターが永続的になるため、IDに加えて、オブジェクトへのポインターを使用してオブジェクトを参照できることに注意してください。</font><font style="vertical-align: inherit;">これの利点は、インデックス検索を実行せずにオブジェクトに直接アクセスできることです。</font><font style="vertical-align: inherit;">一方、ポインタは64ビットのメモリを必要とし、通常32ビットでインデックスに十分です（40億のオブジェクトは大量です）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流通戦略</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造の配列と配列構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一つの重要な設計上の決定は、のどちらかを選択することで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、構造体の配列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（構造体の配列、AOS）と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列構造</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（配列の構造、SOA）。</font><font style="vertical-align: inherit;">違いは例によって最もよく示されます。</font><font style="vertical-align: inherit;">パーティクルに寿命、位置、速度、色がある1つのパーティクルシステムがあるとします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">float</span> t;
    <span class="hljs-keyword">vec3_t</span> pos;
    <span class="hljs-keyword">vec3_t</span> vel;
    <span class="hljs-keyword">vec3_t</span> col;<font></font>
} <span class="hljs-keyword">particle_t</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを格納する通常の方法は、これらの構造体の多くを配列に入れることです。</font><font style="vertical-align: inherit;">これが「構造の配列」と呼ばれる理由です。</font><font style="vertical-align: inherit;">つまり：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> num_particles;
<span class="hljs-keyword">particle_t</span> *particles;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、通常の配列の代わりに、上記の戦略のいずれかを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列構造（SoA）バリアントでは、構造体フィールドごとに個別の配列を使用します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> num_particles;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">float</span> *t;
    <span class="hljs-keyword">vec3_t</span> *pos;
    <span class="hljs-keyword">vec3_t</span> *vel;
    <span class="hljs-keyword">vec3_t</span> *col;<font></font>
} particles;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、</font></font><code>vec3_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ自体が構造体</font><font style="vertical-align: inherit;">であるため</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">さらに先に進むことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> num_particles;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">float</span> *t;
    <span class="hljs-keyword">float</span> *pos_x;
    <span class="hljs-keyword">float</span> *pos_y;
    <span class="hljs-keyword">float</span> *pos_z;
    <span class="hljs-keyword">float</span> *vel_x;
    <span class="hljs-keyword">float</span> *vel_y;
    <span class="hljs-keyword">float</span> *vel_z;
    <span class="hljs-keyword">float</span> *col_r;
    <span class="hljs-keyword">float</span> *col_g;
    <span class="hljs-keyword">float</span> *col_b;<font></font>
} particles;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、元のAoSスキームよりもはるかに複雑に見えますが、なぜそれが本当に必要なのでしょうか。</font><font style="vertical-align: inherit;">このアプローチをサポートする2つの引数があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のアルゴリズムは、フィールドのサブセットでのみ機能します。</font><font style="vertical-align: inherit;">たとえば、アルゴリズム</font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はフィールドにのみ影響します</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">アルゴリズム</font></font><code>simulate_physics()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はフィールド</font></font><code>pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とに</font><font style="vertical-align: inherit;">のみ影響します</font></font><code>vel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">SoAスキームでは、構造体の特定の部分のみがメモリにロードされます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリに制限され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている場合</font><font style="vertical-align: inherit;">（最近のプロセッサではよくあることです）、これは大きな影響を与える可能性があります。</font><font style="vertical-align: inherit;">たとえば、関数</font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメモリの1/10にのみ影響します。つまり、10倍の加速が得られます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoAスキームを使用すると、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レジスタに直接データをロード</font><font style="vertical-align: inherit;">して処理できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPUに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限されている場合、これは大きな影響を与える可能性があり</font><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用する</font><font style="vertical-align: inherit;">と、一度に8つの浮動小数点数を処理できるため、8倍の加速が得られます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、これらの加速</font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により80倍速くなる</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">意味し</font><font style="vertical-align: inherit;">ますか？</font><font style="vertical-align: inherit;">番号。</font><font style="vertical-align: inherit;">最初の10倍の加速は、メモリによって完全に制限されている場合にのみ得られます。また、メモリによって完全に制限されている場合、SIMDはより高速に作業できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SoAアプローチの欠点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードは難しくなっています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1ポイントではなく10の個別のアレイを配布する必要があるため、ディストリビューターへのプレッシャーがさらに大きくなります。</font></font></li>
<li>          <code>particle_t *</code>,         .      .</li>
<li>          ,           </li>
<li>            ( ),  <em></em>   .     <em>  </em>,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュで発生する可能性のある問題の例として、上記の構造体パーティクルを思い出して、VMを使用してすべての配列を割り当てたと想像してください（つまり、4キロバイトページの境界に配置されています）。この配置により、構造体パーティクルの10個のフィールドすべてが1つのキャッシュブロックにバインドされます。キャッシュが8チャネルのマ​​ルチアソシアティブである場合、これは、パーティクルのすべてのフィールドを同時にキャッシュに入れることができないことを意味します。おっとっと！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決する1つの方法は、SIMDベクトルのサイズによって粒子をグループ化することです。たとえば、次のことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> num_particles;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">float</span> t[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> position_x[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> position_y[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> position_z[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> velocity_x[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> velocity_y[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> velocity_z[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> color_r[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> color_g[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">float</span> color_b[<span class="hljs-number">8</span>];<font></font>
} <span class="hljs-keyword">eight_particles_t</span>;
<span class="hljs-keyword">eight_particles_t</span> *particles;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスキームでは、SIMD命令を使用して一度に8つのパーティクルを処理できますが、1つのパーティクルのフィールドはメモリ内でかなり近く、以前に表示されたキャッシュラインの衝突の問題はありません。粒子の配列全体に対して1つの分布に戻るため、これは分布システムに適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、アルゴリズム</font></font><code>tick()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は32バイトに影響し、288バイトをスキップし、32バイトに影響します。これは、別のアレイの場合のように、完全な10倍の加速が得られないことを意味します</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。まず、キャッシュラインのサイズは通常64バイトで、半分しか使用しないため、5倍を超える高速化はできません。また、キャッシュライン全体を処理した場合でも、バイトのスキップに関連するコストが発生する可能性がありますが、100％確実ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、グループのサイズを試すことができます。たとえば、</font></font><code>[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュライン全体を埋める1つの浮動小数点フィールドに</font><font style="vertical-align: inherit;">グループのサイズを変更できます</font><font style="vertical-align: inherit;">。または、ブロック割り当て方法を使用する場合は、グループのサイズをブロックに適合する任意の値に設定するだけです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AoSおよびSoA。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
削除戦略に関しては、「穴あり」オプションのSoAは最良の選択ではありません。SIMDを使用して8つの要素を同時に処理すると、8つの要素がすべて「穴」でない限り、穴を逃すことができないためです。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD命令は「穴」を実際のデータと同じ方法で処理するため、穴に「安全な」データが含まれていることを確認する必要があります。たとえば、穴操作によって</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮動小数点演算で例外が発生し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たり、</font><font style="vertical-align: inherit;">パフォーマンスを低下させる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非正規数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">たりする</font><font style="vertical-align: inherit;">ことは望ましくありません</font><font style="vertical-align: inherit;">。また、ポインタを保持する必要はありません</font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMD操作で上書きされるため、unionを使用したリリースリスト。</font><font style="vertical-align: inherit;">代わりに、構造体フィールドを使用してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
密にパックされたオプションを使用する場合、構造体全体を一度に移動するのではなく、各フィールドを個別に移動する必要があるため、削除は少しコストがかかります。</font><font style="vertical-align: inherit;">しかし、削除は更新よりもはるかに難しいので、これは大きな問題にはなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AoSとSoAを比較すると、ほとんどの場合、パフォーマンスを向上させることは、より面倒なコードを書く面倒に見合うものではありません。</font><font style="vertical-align: inherit;">私はそれをAoSシステムの「標準」ストレージフォーマットとして使用し、クリッピングシステムやパーティクルなどのSIMD計算速度を必要とするシステムではSoAに切り替えます。</font><font style="vertical-align: inherit;">そのような場合、速度を最大にするために、おそらく密にパックされた配列を選択します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のオプションを検討する価値があります-AoSにデータを保存し、何らかのアルゴリズムで処理するための一時的なSoAデータを生成します。</font><font style="vertical-align: inherit;">たとえば、AoSデータに1つのパスを渡して、それらを一時的なSoAバッファーに書き込み、このバッファーを処理して、結果をAoSとして書き戻します（必要な場合）。</font><font style="vertical-align: inherit;">この場合、このデータを処理するアルゴリズムが確実にわかっているので、そのストレージフォーマットを最適化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、「ブロックストレージ」オプションでうまく機能することに注意してください。</font><font style="vertical-align: inherit;">一度に16分の1ブロックを処理し、それをSoAに変換し、アルゴリズムを実行して、結果を書き戻すことができます。</font><font style="vertical-align: inherit;">一時データを保存するには、16千要素のスクラッチバッファーが必要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのアプローチにも長所と短所がありますが、「デフォルトでは」、次のように新しいシステムのバルクデータを保存することをお勧めします。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「穴」と定数ポインタを備えた構造の配列。VMで1つの大きな予約ボリュームとして（可能であれば）、または固定サイズのブロックの配列として（それぞれ16,000またはデータに最適なサイズで）分散されます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの値の非常に高速な計算が必要な場合：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMD処理用に8でグループ化され、VM内の1つの大きな予約ボリュームとして、または固定サイズのブロックの配列として分散された、密にパックされたオブジェクトの配列の構造。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次回は、このデータのインデックス作成のトピックについて検討します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469839/index.html">ピカブスパムの脆弱性</a></li>
<li><a href="../ja469843/index.html">「私たちを地球の表面から拭き取る若いパンクはどこにあるのですか？」</a></li>
<li><a href="../ja469849/index.html">ゲーム「攻撃51％」：Obyteプラットフォームでシンプルなスタンドアロンゲームを作成する</a></li>
<li><a href="../ja469855/index.html">Gradle + LLVM</a></li>
<li><a href="../ja469859/index.html">メソッド受信者の定義におけるポインターと値のセマンティクス</a></li>
<li><a href="../ja469867/index.html">それがどのように男子生徒になるのか（そしてボードゲームがそれとどう関係するのか）</a></li>
<li><a href="../ja469869/index.html">ランダムアクセスメモリをオーバークロックする理由（簡単です！）</a></li>
<li><a href="../ja469871/index.html">キーボードがテーブルだったとき</a></li>
<li><a href="../ja469875/index.html">2019年にパスワードを保護する方法</a></li>
<li><a href="../ja469877/index.html">ああ、このニュートンの方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>