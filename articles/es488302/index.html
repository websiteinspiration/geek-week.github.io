<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏻 👩🏾‍🤝‍👨🏿 💃🏼 ¿Qué esperar de Java en 2020? 📽️ 👇🏼 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2020 ya está en su apogeo, discutamos qué cambios en el mundo de Java nos esperan este año. Este artículo enumerará las principales tendencias de Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¿Qué esperar de Java en 2020?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/488302/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020 ya está en su apogeo, discutamos qué cambios en el mundo de Java nos esperan este año. </font><font style="vertical-align: inherit;">Este artículo enumerará las principales tendencias de Java y JDK. </font><font style="vertical-align: inherit;">Y estaré contento con las adiciones de los lectores en los comentarios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inmediatamente haga una reserva de que el artículo es más un personaje de investigación. </font><font style="vertical-align: inherit;">Los detalles sobre cada tema discutido se pueden encontrar en el sitio web del proyecto correspondiente o en publicaciones en fuentes abiertas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ss/xa/se/ssxaserudinczxpy3cusjxcilzu.jpeg" alt="imagen"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a empezar. </font><font style="vertical-align: inherit;">Desafortunadamente, inmediatamente tendrá que decepcionar a aquellos que no siguen demasiado el ciclo de lanzamiento de Java, pero que esperan un programa de soporte largo (LTS). </font><font style="vertical-align: inherit;">Este año estamos esperando lanzamientos con solo un corto ciclo de vida de soporte (STS). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero consideraremos el próximo lanzamiento de JDK 14, que debería lanzarse a mediados de marzo. </font><font style="vertical-align: inherit;">En este ciclo de lanzamiento, se reclaman hasta 16 JEP. </font><font style="vertical-align: inherit;">Aquí está la lista completa:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">305:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coincidencia de patrones por ejemplo de (Vista previa)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">343:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herramienta de embalaje (incubadora)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">345:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignación de memoria compatible con NUMA para G1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">349:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transmisión de eventos JFR</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">352:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Búferes de bytes mapeados no volátiles</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">358:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullPointerExceptions útiles</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">359:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros (vista previa)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">361:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar expresiones (estándar)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">362:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desaprobar los puertos Solaris y SPARC</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">363:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retire el recolector de basura de barrido de marcas concurrentes (CMS)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">364:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZGC en macOS</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">365:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZGC en Windows</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">366:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desaprobar la combinación ParallelScavenge + SerialOld GC</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">367:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar las herramientas y API de Pack200</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">368:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloques de texto (segunda vista previa)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">370:</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API de acceso a memoria externa (incubadora)</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos JEP de esta lista fueron ampliamente cubiertos en la conferencia Joker 2019. Me centraré en los que me parecen más interesantes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coincidencia de patrones por ejemplo de (Vista previa)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El largo JEP finalmente saldrá en Vista previa. </font><font style="vertical-align: inherit;">Creo que si eres un programador en ejercicio que ha estado escribiendo código Java durante muchos años, entonces has encontrado este dolor más de una vez:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) {<font></font>
    String s = (String) obj;<font></font>
    System.out.println(s.toUpperCase());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si escribió o está escribiendo código también en Kotlin, entonces el dolor de ver el código Java es un poco peor. </font><font style="vertical-align: inherit;">Los participantes del proyecto Amber nos presentarán su visión de la coincidencia de patrones en Java, lo que debería reducir este dolor. </font><font style="vertical-align: inherit;">Con la llegada de Java 14, podemos reescribir el ejemplo de la siguiente manera:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) {<font></font>
   System.out.println(s.toUpperCase());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que el complemento no es tan valioso: guardamos una línea de código. </font><font style="vertical-align: inherit;">Pero supongamos que queremos hacer lo siguiente:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) {<font></font>
    String s = (String) obj;<font></font>
    <span class="hljs-keyword">if</span> (s.contains(“prefix_”)) {
       <span class="hljs-keyword">return</span> s.toUpperCase();<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ve voluminoso, ¿no? </font><font style="vertical-align: inherit;">Probemos lo mismo, pero con Pattern Matching.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">return</span> (obj <span class="hljs-keyword">instanceof</span> String s) &amp;&amp; s.contains(“prefix_”) ? s.toUpperCase() : <span class="hljs-keyword">null</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces obviamente será mejor. </font><font style="vertical-align: inherit;">Pero recuerde que el estado de esta funcionalidad es Vista previa. </font><font style="vertical-align: inherit;">Veamos qué cambia con el tiempo. </font><font style="vertical-align: inherit;">Para mí, definitivamente mejorará mi vida.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullPointerExceptions útiles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2020 está en el patio, ¿y todavía escribes para que NullPointerExceptions vuele por ti? </font><font style="vertical-align: inherit;">No te preocupes, probablemente no seas el único. </font><font style="vertical-align: inherit;">Goetz Lindenmaier y Ralf Schmelter no sugirieron una nueva forma de alejarse de NullPointerExceptions (Opcional todavía está con nosotros), pero propusieron mejorar el proceso de depuración de la aplicación para comprender exactamente dónde se encuentra nulo. </font><font style="vertical-align: inherit;">Entonces, imaginemos que escribimos el código a las cinco en punto ... por la noche, por supuesto. </font><font style="vertical-align: inherit;">Y escribimos esta función:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStreetFromRequest</span><span class="hljs-params">(Request request)</span> </span>{
   <span class="hljs-keyword">return</span> request.getAddress().getStreet().toUpperCase();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No está mal, pero se olvidaron por completo de poner anotaciones @Nullable y @Nonnull y verificar la dirección en los campos transmitidos. </font><font style="vertical-align: inherit;">Obtuve una NullPointerException. </font><font style="vertical-align: inherit;">¿Qué nos dice la excepción?</font></font><br>
<br>
<pre><code class="java hljs">Exception in thread <span class="hljs-string">"main"</span> java.lang.NullPointerException<font></font>
	at Program.getStreetFromRequest(Program.java:<span class="hljs-number">10</span>)<font></font>
	at Program.main(Program.java:<span class="hljs-number">6</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por desgracia, solo vemos una fila, una clase y una pila. </font><font style="vertical-align: inherit;">¿A dónde exactamente regresó nulo? </font><font style="vertical-align: inherit;">Tal vez esto es una solicitud? </font><font style="vertical-align: inherit;">Tal vez getAddress () devuelto nulo? </font><font style="vertical-align: inherit;">O tal vez getStreet ()? </font><font style="vertical-align: inherit;">Bueno, las cadenas de llamadas a veces duelen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los autores de JEP proponen una solución: al lanzar una excepción, se supone que debe pasar por alto la pila para determinar dónde regresó exactamente nulo y luego mostrar el nombre de las variables / métodos. </font><font style="vertical-align: inherit;">Probemos con Java 14 con la opción -XX: + ShowCodeDetailsInExceptionMessages. </font><font style="vertical-align: inherit;">Comenzamos y nos ponemos un poco diferentes:</font></font><br>
<br>
<pre><code class="java hljs">Exception in thread <span class="hljs-string">"main"</span> java.lang.NullPointerException: Cannot invoke <span class="hljs-string">"String.toUpperCase()"</span> because the <span class="hljs-keyword">return</span> value of <span class="hljs-string">"Address.getStreet()"</span> is <span class="hljs-keyword">null</span>
	at Program.getStreetFromRequest(Program.java:<span class="hljs-number">10</span>)<font></font>
	at Program.main(Program.java:<span class="hljs-number">6</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora sabemos que la programación nocturna no es buena (pero a veces conduce a la finalización de las tareas a tiempo), y en nuestro programa olvidamos que la dirección no es un campo obligatorio.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros (vista previa)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Sigue generando getters / setters / equals / hashCode con idea? </font><font style="vertical-align: inherit;">¡Entonces este JEP viene a ti! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las clases de datos están lejos del último lugar en la vida de un desarrollador de software de aplicación. </font><font style="vertical-align: inherit;">Cada vez tenemos que generar métodos de clases de datos usando nuestro IDE favorito, o usar varios complementos en tiempo de compilación para generar los métodos necesarios, como lombok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, tenemos mucho código similar a este:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>{
    <span class="hljs-keyword">private</span> Address address;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> address;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>{
       <span class="hljs-keyword">this</span>.address = address;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
        Request request = (Request) o;<font></font>
        <span class="hljs-keyword">return</span> Objects.equals(address, request.address);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(address);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Request{"</span> +
                <span class="hljs-string">"address="</span> + address +
                <span class="hljs-string">'}'</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tal:</font></font><br>
<pre><code class="java hljs"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>{
    <span class="hljs-keyword">private</span> Address address;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java 14, los miembros del proyecto Amber proponen una nueva sintaxis para crear clases de datos. </font><font style="vertical-align: inherit;">Para hacer esto, use el nuevo registro de palabras clave. </font><font style="vertical-align: inherit;">La sintaxis para Record es ligeramente diferente a la de las descripciones de clase o enumeración, y es ligeramente similar a Kotlin. </font><font style="vertical-align: inherit;">El código anterior se puede reescribir de la siguiente manera:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Request</span><span class="hljs-params">(Address address)</span> </span>{<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los campos de registro tienen modificadores privados y finales por defecto. </font><font style="vertical-align: inherit;">El registro en sí es una clase final y no se puede heredar de otra clase, pero puede implementar interfaces. </font><font style="vertical-align: inherit;">En las clases de registro del cuadro obtenemos: métodos getters, un constructor público, cuyos parámetros son todos campos de registro en el orden de descripción, equals / hashCode y toString. </font><font style="vertical-align: inherit;">De lo desagradable: no podemos agregar campos al registro, excepto los especificados después del nombre de la clase. </font><font style="vertical-align: inherit;">Por ejemplo, este código generará un error:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Request</span><span class="hljs-params">(Address address)</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String anotherParameter; <span class="hljs-comment">// compilation error</span><font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloques de texto (segunda vista previa)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los bloques de texto se lanzaron como vistas previas en Java 13. Los usuarios giramos, giramos y retroalimentamos (creo sinceramente que ya está utilizando Java 13 con vista previa). </font><font style="vertical-align: inherit;">Como resultado, los creadores de Java hicieron cambios menores en los bloques de texto. </font><font style="vertical-align: inherit;">Primero, ahora podemos indicar explícitamente dónde termina la línea, colocando la secuencia de escape \ s en nuestra línea. </font><font style="vertical-align: inherit;">Aquí hay un ejemplo:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> test = <span class="hljs-string">""</span><span class="hljs-string">"
                This is the long text block with escape string \s
                that is really well done            \s
                "</span><span class="hljs-string">""</span>;<font></font>
        System.out.println(test);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora establecemos explícitamente todos los espacios en el carácter \ s y todos los caracteres de espacio se guardarán en el carácter \ s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, ahora podemos ajustar largas líneas de un bloque de texto sin recibir \ n caracteres en la línea final. </font><font style="vertical-align: inherit;">Para hacer esto, solo necesitamos agregar \ en el salto de línea. </font><font style="vertical-align: inherit;">Cómo se ve:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> test = <span class="hljs-string">""</span><span class="hljs-string">"
                This is the long text block with escape string \
                that is really well-done functional            
                "</span><span class="hljs-string">""</span>;<font></font>
System.out.println(test);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de la ejecución, obtenemos la siguiente línea: "Este es el bloque de texto largo con cadena de escape que está realmente bien hecho funcional". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una buena adición, me parece. </font><font style="vertical-align: inherit;">Realmente espero traducir esta funcionalidad a estándar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es probable que todas las características que revisamos sean discutidas ampliamente en las próximas conferencias. </font><font style="vertical-align: inherit;">Algunos de ellos ya se discutieron en Joker 2019. Asegúrese de consultar la charla Joker 2019 sobre "Evolución de características en Java 13 y más allá" de Cay Horstmann.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y algunas cosas más interesantes.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos elementos interesantes en la lista JEP en la incubadora. Para empezar, tendremos una herramienta universal que creará instaladores para diferentes sistemas operativos (bueno, finalmente, quiero decirles a los que bailaron alrededor de la instalación de programas en Windows). Jpacker podrá crear instaladores msi / exe para Windows, paquetes macOS y rpm / deb para Linux. Veamos qué sucede con esto, pero en esos raros casos en que hice algo para escritorio, personalmente sufrí el hecho de que no tenía una herramienta regular para ensamblar el instalador.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aún más prometedor es la nueva API para acceder a "Memoria extranjera", es decir </font><font style="vertical-align: inherit;">Cualquier tipo de memoria nativa o persistente. </font><font style="vertical-align: inherit;">Esta API es principalmente útil para creadores de bases de datos Java o creadores de framework como Netty, por ejemplo. </font><font style="vertical-align: inherit;">Ellos, utilizando Unsafe y ByteBuffer, optimizan el acceso a la memoria con el montón fuera de lo posible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Próximo lanzamiento. </font><font style="vertical-align: inherit;">Alegría y frustración</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En septiembre, estamos esperando otra versión de soporte a corto plazo en el número 15. La lista de JEP que se incluirá en la versión final aún está abierta. </font><font style="vertical-align: inherit;">Hasta ahora, puede ver muchos cambios diferentes en el lenguaje en sí, en la biblioteca estándar y la máquina virtual. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está la lista de candidatos (puede cambiar rápidamente, mira aquí: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bugs.openjdk.java.net/secure/Dashboard.jspa?selectPageId=19114</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111:</font></font></td>
<td>Additional Unicode Constructs for Regular Expressions</td>
</tr>
<tr>
<td>116:</td>
<td>Extended Validation SSL Certificates</td>
</tr>
<tr>
<td>134:</td>
<td>Intuitive Semantics for Nested Reference Objects</td>
</tr>
<tr>
<td>152:</td>
<td>Crypto Operations with Network HSMs</td>
</tr>
<tr>
<td>198:</td>
<td>Light-Weight JSON API</td>
</tr>
<tr>
<td>218:</td>
<td>Generics over Primitive Types</td>
</tr>
<tr>
<td>300:</td>
<td>Augment Use-Site Variance with Declaration-Site Defaults</td>
</tr>
<tr>
<td>301:</td>
<td>Enhanced Enums</td>
</tr>
<tr>
<td>302:</td>
<td>Lambda Leftovers</td>
</tr>
<tr>
<td>303:</td>
<td>Intrinsics for the LDC and INVOKEDYNAMIC Instructions</td>
</tr>
<tr>
<td>306:</td>
<td>Restore Always-Strict Floating-Point Semantics</td>
</tr>
<tr>
<td>338:</td>
<td>Vector API (Incubator)</td>
</tr>
<tr>
<td>339:</td>
<td>Compiler Intrinsics for Java SE APIs</td>
</tr>
<tr>
<td>348:</td>
<td>Compiler Intrinsics for Java SE APIs</td>
</tr>
<tr>
<td>356:</td>
<td>Enhanced Pseudo-Random Number Generators</td>
</tr>
<tr>
<td>360:</td>
<td>Sealed Types (Preview)</td>
</tr>
<tr>
<td>371:</td>
<td>Hidden Classes</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, la lista todavía no tiene muchas cosas esperadas. En primer lugar, para mí es Project Loom. La idea del paralelismo estructural ha sido muy popular en los últimos años. Las rutinas pueden simplificar enormemente la tarea de la computación paralela competitiva y la ejecución asincrónica de tareas. Se pueden ver excelentes ejemplos de implementación de esta idea, por ejemplo, en los idiomas Kotlin (corutinas) y Go (goroutinas). Java también está explorando la idea del paralelismo estructural, y ya hay primeros resultados. Por ahora, solo puede verlos al recopilar el JDK del repositorio del proyecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valhalla, un proyecto muy prometedor, todavía no nos ha complacido con ningún avance. En Joker 2019 se presentó un informe interesante sobre este proyecto ("¿Requiere Java tipos" en línea "? Una visión limitada del ingeniero de rendimiento en el proyecto Valhalla" por Sergey Kuksenko).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué se presenta en la lista? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que llama la atención es la API JSON. La pregunta surge de inmediato: ¿por qué? Claramente no hay una respuesta definitiva. La sección JEP sobre motivación dice que JSON se ha convertido en un estándar para los servicios web, y ahora es el momento de adaptar Java SE para interactuar con JSON (a pesar de que ahora hay un montón de bibliotecas para analizar JSON). La explicación más probable es la capacidad de los desarrolladores de software de utilizar una pequeña API central para reducir el tamaño del paquete sin tener que arrastrar al pesado Jackson hacia ellos. No veo ninguna otra explicación, porque ni siquiera tendrá enlace de datos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También vemos una serie de mejoras relacionadas con la API criptográfica. Para comenzar, los desarrolladores de JDK desean expandir el proceso de validación de certificados SSL agregando soporte para certificados EVSSL. Con esta API en Java, puede determinar si un certificado EV (Validación Extendida) confía en una conexión SSL. El certificado EVSSL de acuerdo con la directriz será totalmente compatible. También se agregará un nuevo algoritmo criptográfico EdDSA y se mejorará la verificación de la criptografía HSM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De las cosas del lenguaje, destacaría la implementación de genéricos en primitivas. Todos los que alguna vez programaron en C # y cambiaron a Java, probablemente podrían hacer la pregunta, ¿por qué no pueden hacer tipos genéricos en primitivas? La respuesta es simple: los genéricos solo funcionan con objetos, y las primitivas no son objetos y, en particular, no heredan una clase Object. No es el primer año que se ha librado una guerra sobre este tema, y ​​Brian Goetz está volviendo a ella nuevamente. No hay nada especial para describir hasta ahora. La tarea es clara: admitir construcciones como List. Pero incluso en este momento hay 13 preguntas abiertas que deben resolverse antes de implementar esta funcionalidad. Honestamente, me pregunto cómo terminará esta serie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y lo último que quiero tocar son los tipos sellados. </font><font style="vertical-align: inherit;">Este es el siguiente paso hacia la coincidencia de patrones. </font><font style="vertical-align: inherit;">Tipos Sellados es una extensión de lenguaje que implementa el sellado (modificador) y permite palabras clave para una clase o interfaz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando la clase sellada, limitamos el número de descendientes a solo aquellas clases que se especifican en los permisos (una restricción explícita) o en la misma unidad de compilación (archivo). </font><font style="vertical-align: inherit;">Descripción de ejemplo de una clase sellada:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// </span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>{}
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>{}<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">public</span> sealed <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseInterface</span> <span class="hljs-title">permits</span> <span class="hljs-title">ChildC</span>, <span class="hljs-title">ChildD</span></span>{<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseInterface</span> </span>{<font></font>
}<font></font>
<span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseInterface</span> </span>{<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El modificador sellado asegura que solo un conjunto limitado de descendientes pueda extender la clase base o implementar una interfaz. </font><font style="vertical-align: inherit;">Esta propiedad se puede usar al procesar objetos de estas clases. </font><font style="vertical-align: inherit;">Y, por supuesto, este es un gran candidato para usar en una declaración de cambio con coincidencia de patrones.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analizamos las diversas innovaciones de JDK este año. </font><font style="vertical-align: inherit;">Algunos de ellos dispararán, otros no. </font><font style="vertical-align: inherit;">Pero sobre todo en los nuevos JDK, espero nuevas optimizaciones pequeñas (o no tan) que aceleren nuestros programas con cada lanzamiento de forma gratuita. </font><font style="vertical-align: inherit;">Y si estuvo en el último Joker 2019 y visitó el informe de Tagir Valeev Java 9-14: Pequeñas optimizaciones, entonces lo más probable, como yo, quedó impresionado por el trabajo que hacen los colaboradores para optimizar JDK. </font><font style="vertical-align: inherit;">Sus resultados no son visibles a primera vista y no se reflejan en más de un JEP, pero los usamos todos los días. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Buenos lanzamientos de Java para todos nosotros. </font><font style="vertical-align: inherit;">Explore las nuevas características de la plataforma, vaya a conferencias y siga las tendencias.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488278/index.html">Las primeras lámparas de la serie con energía solar del mundo.</a></li>
<li><a href="../es488280/index.html">Cómo mirar Oracle WebLogic Server usando un monitor grande y una utilidad WLSDM de consola</a></li>
<li><a href="../es488284/index.html">Amor + lienzo = corazón</a></li>
<li><a href="../es488288/index.html">Nada sobre código cultural</a></li>
<li><a href="../es488298/index.html">Noticias del mundo de OpenStreetMap No. 498 (28/01 / 2020-03.02.2020)</a></li>
<li><a href="../es488304/index.html">Sistema operativo Sivelkiriya: tecnologías</a></li>
<li><a href="../es488308/index.html">El brazalete que Putin vio: Healbe Gobe sigue siendo el único dispositivo que cuenta las calorías entrantes</a></li>
<li><a href="../es488310/index.html">Cómo mi desafío se convirtió en un desafío de equipo</a></li>
<li><a href="../es488316/index.html">Epson EH-TW7100: proyector 4K HDR y pensamientos sobre lo que hacen los proyectores listos para HDR y 4K</a></li>
<li><a href="../es488320/index.html">Deadlock Empire: un juego para desarrolladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>