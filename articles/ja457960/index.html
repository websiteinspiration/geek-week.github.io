<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏩 👮 🐂 会議室L̶i̶t̶t̶l̶e̶ヘルパーv 2 👩🏽‍🔬 ▪️ 👨🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、Meeting Room Helperモバイルアプリケーションの開発段階（アイデアの開始からリリースまで）について詳しく説明します。アプリケーションはKotlinで記述され、データバインディングを使用せずに、簡略化されたMVVMアーキテクチャに基づいて構築されています。UI部分は、Li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>会議室L̶i̶t̶t̶l̶e̶ヘルパーv 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/457960/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、Meeting Room Helperモバイルアプリケーションの開発段階（アイデアの開始からリリースまで）について詳しく説明します。</font><font style="vertical-align: inherit;">アプリケーションはKotlinで記述され、データバインディングを使用せずに、簡略化されたMVVMアーキテクチャに基づいて構築されています。</font><font style="vertical-align: inherit;">UI部分は、LiveDataオブジェクトを使用して更新されます。</font><font style="vertical-align: inherit;">データバインディングを拒否する理由について詳しく説明します。</font><font style="vertical-align: inherit;">このアーキテクチャは、いくつかの興味深いソリューションを使用して、プログラムを論理的に小さなファイルに分割し、最終的にコードサポートを簡素化します。</font></font><br>
<img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<img src="https://habrastorage.org/webt/ii/at/pf/iiatpf_m3syq_8mzu08bkaqiy4u.jpeg"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの説明 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3年前、私たちの会社では、会議室の即時予約のための小さなプロジェクトを開発するというアイデアが思い付きました。</font><font style="vertical-align: inherit;">ほとんどの人事マネージャーとアルカディアは、そのような目的のためにOutlookカレンダーを使用することを好みますが、残りはどうでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者の人生から2つの例を挙げます</font></font><br>
<br>
<ol>
<li><i>           5-10 .         , ,      ,  (   )    .      (      ),  « »,       .      .        ,          .  ,  . </i></li>
<li><i>   .          ,       ( )   .     - ,       .  ,      (   )      . ,          Outlook.   ?  ,  ,      ?       Outlook Express    ,      ?    . </i> </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、2.5年前、各会議室には独自のタブレットが装備されていました</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kp/2i/ao/kp2iao0nromcb1wa-iewgzxurw0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。このプロジェクトのために、私の同僚はアプリケーションの最初のバージョンであるMeeting Room Little Helperを開発しました（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで読むことができます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">MRLHは予約の予約、キャンセル、および更新を許可し、残りの会話のステータスを示しました。</font><font style="vertical-align: inherit;">（Microsoft Face APIクラウドサービスと内部アナライザーを使用して）従業員のIDを認識することは、革新的な「トリック」になりました。</font><font style="vertical-align: inherit;">アプリケーションは堅実であることが判明し、2.5年間会社に忠実にサービスを提供しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、時は経ちました...新しいアイデアが現れました。</font><font style="vertical-align: inherit;">新鮮なものが欲しかったので、アプリケーションを書き直すことにしました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技術的なタスク </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よくあることですが、残念ながら常にではありませんが、開発は技術仕様の準備から始まりました。</font><font style="vertical-align: inherit;">まず、予約にタブレットを最もよく使用する男性に電話をかけました。</font><font style="vertical-align: inherit;">たまたまそうなったのは、そのほとんどが、以前はOutlookを独占的に使用していた人事部長やマネージャーに依存していたからです。</font><font style="vertical-align: inherit;">彼らから次のフィードバックを受け取りました（要件から、人事部が何を要求し、マネージャーが何を要求したかがすぐにわかります）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのタブレットからでも会議室を予約する機能を追加する必要があります（以前は、各タブレットで自分の部屋のみを予約できました）; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終日の会議のラリーのスケジュールを確認するのはクールです（理想的には、いつでも）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発サイクル全体を短時間（6〜7週間）で実行する必要があります。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
お客様の要望はすべて明確ですが、技術的な要件と将来についてはどうでしょうか。</font><font style="vertical-align: inherit;">開発者のギルドからプロジェクトにいくつかの要件を追加します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムは既存のタブレットと新しいタブレットの両方で動作するはずです。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムのスケーラビリティ-50回以上の会話（システムが複製を開始する場合、ほとんどの顧客にとってこれで十分です）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前の機能を維持しました（アプリケーションの最初のバージョンはJava APIを使用してOutlookサービスと通信しましたが、専用のMicrosoft Graph APIに置き換えることを計画していたため、機能を失わないことが重要でした）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エネルギー消費の最小化（ビジネスセンターでは壁に穴を開けてワイヤーを敷設することを許可していなかったため、タブレットは外部バッテリーから電力を供給されています）; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人間工学的にすべての革新を反映した新しいUX / UIデザイン。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計8点。</font><font style="vertical-align: inherit;">要件はかなり公平です。</font><font style="vertical-align: inherit;">さらに、一般的な開発ルールを規定します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度なテクノロジーのみを使用します（これにより、チームは専門家として開発し、1か所に停滞することなく、予測可能な将来のプロジェクトサポートを簡素化できます）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベストプラクティスに従いますが、当たり前のようにそれらを当たり前のように考えないでください。</font><font style="vertical-align: inherit;">すべての専門家（およびこれに取り組む開発者）の主なルールは、すべてを批判的に評価することです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリーンできちんとしたコードを記述します（おそらく、革新と厳しい開発時間を組み合わせようとすると、これが最も困難になります）。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタート。</font><font style="vertical-align: inherit;">いつものように、それは熱狂的です！</font><font style="vertical-align: inherit;">次に何が起こるか見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設計 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UXデザインアプリケーションデザイン：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gm/n9/eo/gmn9eox4exzhczkq0zdbkiwrgt8.png"><br>
<img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはメイン画面です。</font><font style="vertical-align: inherit;">ほとんどの場合表示されます。</font><font style="vertical-align: inherit;">必要な情報はすべて人間工学的にここにあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部屋の名前とその番号。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の状態; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の会議までの時間（またはその終了まで）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面下部の残りの部屋のステータス。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：ダイヤルには12時間しか表示されません。</font><font style="vertical-align: inherit;">システムは会社のニーズに合わせて構成されています（アルカディアタブレットは午前8時から午後8時まで機能し、自動的に電源を入れたり切ったりします）</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cg/r_/92/cgr_9220jaeqzpjtu4godm1vojw.gif"><br>
<img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font><font style="vertical-align: inherit;">残りの部屋を予約する手順も同様です。部屋のアイコンをクリックすることから始めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/qr/wm/d7qrwmogkdzvjtdea0y80vjlti4.jpeg"><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の時間に会議をスケジュールする場合は、今日会議室で開催される会議のリストで次のタブに移動し、空き時間をクリックします。</font><font style="vertical-align: inherit;">さらに、すべてが最初のケースと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全な遷移ツリーは次のようになります</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p8/ex/lb/p8exlbbiuflfbasflet3vsepzdu.png"><br>
<img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。これを適切に実装してみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技術スタック </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発手法はかなり急速に発展し、変化しています。</font><font style="vertical-align: inherit;">さらに2年間、Javaは公式のAndroid開発言語でした。</font><font style="vertical-align: inherit;">誰もがJavaで書き込み、データバインディングを使用しました。</font><font style="vertical-align: inherit;">さて、私には、リアクティブプログラミングとKotlinに向かっているようです。</font><font style="vertical-align: inherit;">Javaは優れた言語ですが、KotlinやAndroidXが提供するものと比較すると、いくつかの欠点があります。</font><font style="vertical-align: inherit;">KotlinとAndroidXは、データバインディングの使用を完全に排除しない場合でも、最小限に抑えることができます。</font><font style="vertical-align: inherit;">以下に私の見解を説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コトリン </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのAndroid開発者はすでにKotlinに切り替えていると思います。そのため、2019年に新しいAndroidプロジェクトをKotlin以外の言語で書くことは海との戦いに似ていると私は同意します。もちろん論争はできますが、フラッターとダートはどうでしょうか。 C ++、C＃、さらにはCordovaについてはどうですか？私が答えるところ：選択は常にあなた次第です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
紀元前480年ペルシャのクセルクセス王は嵐の間に彼の軍隊の一部を破壊した罰として彼の兵士に海を渡るように命じました、そして、5世紀後、ローマ皇帝カリグラはポセイドンに対する戦争を宣言しました。好みの問題。 10プロジェクトのうち9プロジェクトの場合、Kotlinは良いですが、10プロジェクトの場合は悪いかもしれません。それはすべてあなた、あなたの欲望と願望にかかっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kotlinは私の選択です。</font><font style="vertical-align: inherit;">言語はシンプルで美しいです。</font><font style="vertical-align: inherit;">それを書くことは簡単で快適であり、最も重要なのは、データクラス、オブジェクト、オプションのセッターとゲッター、単純なラムダ式と拡張関数など、多くを書く必要がないことです。</font><font style="vertical-align: inherit;">これは、この言語が提供するもののほんの一部です。</font><font style="vertical-align: inherit;">Kotlinにまだ切り替えていない場合-遠慮なくご利用ください。</font><font style="vertical-align: inherit;">実践のセクションでは、この言語の利点のいくつかを紹介します（広告の提供ではありません）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルビュービューモデル </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVVMは現在、Googleが推奨するアプリケーションアーキテクチャです。</font><font style="vertical-align: inherit;">開発中は、この特定のパターンを順守しますが、MVVMはデータバインディングの使用を推奨しているため、完全には監視しませんが、拒否します。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVVMの長所</font></font></b> </i><br>
<br>
<ul>
<li><i> -  UI. </i>   MVVM  ViewModel      import android,   LiveData-   AndroidX  Jetpack.        UI  fragments  activities.   , ? </li>
<li><i>  .</i>    :              .      ,    ViewModel,     Repository. </li>
<li><i>MVVM     unit-. </i>      .          UI,     . </li>
<li><i>    .</i>      ,     ,    MVVM (..    ViewModel).       (VK, Telegram, -Online  Aviasales),  ,         .        ,     . </li>
</ul><br>
<i><b>  MVVM?</b></i><br>
<br>
<ul>
<li><i> . </i>   ,      LiveData  observer.        . </li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">広大なViewModel。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのビジネスロジックをViewModelに適合させようとすると、コードが読めなくなります。</font><font style="vertical-align: inherit;">この状況を回避する方法は、ViewModelを階層に分割するか、Presenterを使用することです。</font><font style="vertical-align: inherit;">それがまさに私がしたことです。</font></font></li>
</ul><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVVMを使用するためのルール</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最も失敗しているものから始め、失敗しが少ないものに移動しましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストの本文はViewModel内に存在しないでください（リポジトリ内のみ）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveDataオブジェクトはViewModelで定義されており、Repository内にスローされません。</font><font style="vertical-align: inherit;">リポジトリ内のリクエストは、Rx-Java（またはコルーチン）を使用して処理されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての処理関数は、ViewModelが乱雑になったり、本質に気を取られたりしないように、サードパーティのクラスとファイル（「プレゼンター」）に移動する必要があります。 </font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブデータ </font></font></h4><br>
<blockquote>LiveData is an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.</blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.android.com/topic/libraries/architecture/livedata</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
定義から、簡単な結論を出すことができます。LiveDataは、信頼性の高いリアクティブプログラミングツールです。これを使用して、データバインディングなしでUIパーツを更新します。何故ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLファイルの構造では、&lt;data&gt; ... &lt;/ data&gt;から取得したデータを簡潔に配布できません。小さなファイルですべてがはっきりしている場合、大きなファイルはどうでしょうか？複雑な画面、複数のインクルード、複数のフィールドの受け渡しをどうするか？どこでもモデルを使用しますか？固いフィールドバインディングを取得しますか？フィールドをフォーマットする必要がある場合は、Javaパッケージからメソッドを呼び出しますか？これは、コードをスパゲッティに変える絶望的な最終段階です。 MVVMが約束したことはまったくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データバインディングを拒否すると、UIパーツへの変更が透過的になります。</font><font style="vertical-align: inherit;">すべての更新はオブザーバー内で直接行われます。</font><font style="vertical-align: inherit;">なぜなら </font><font style="vertical-align: inherit;">コリンのコードは簡潔で簡単なので、肥大化したオブザーバーの問題は発生しません。</font><font style="vertical-align: inherit;">コードの作成と保守が容易になります。</font><font style="vertical-align: inherit;">XMLファイルは設計にのみ使用され、内部にはプロパティはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データバインディングは強力なツールです。</font><font style="vertical-align: inherit;">これは、いくつかの問題を解決するのに最適であり、Javaとうまく調和しますが、Kotlinと調和します... Kotlinでは、ほとんどの場合、データバインディングは初歩的なものです。</font><font style="vertical-align: inherit;">データバインディングはコードを複雑にするだけで、競争上の利点はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでは、データバインディングを使用するか、多くの醜いコードを書くかを選択できました。</font><font style="vertical-align: inherit;">Kotlinでは、findViewById（）とそのプロパティをバイパスして、ビュー要素に直接アクセスできます。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// Instead of TextView textView = findViewById&lt;TextView&gt;(R.id.textView) </span>
textView.text = <span class="hljs-string">"Hello, world!"</span><font></font>
textView.visibility = View.VISIBLE <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理的な問題が発生します。XMLファイル内のガーデニングモデル、XMLファイル内のJavaメソッドの呼び出し、XML部分のロジックのオーバーロードをすべて回避できるのに、なぜ煩わしいのでしょうか。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread（）およびRx-Javaの代わりのコルーチン</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンは信じられないほど軽量で使いやすいです。</font><font style="vertical-align: inherit;">クエリ結果の処理、UIの更新など、最も単純な非同期タスクに最適です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンは、高いパフォーマンスが要求されない場合に、Thread（）およびRx-Javaを効果的に置き換えることができます。</font><font style="vertical-align: inherit;">彼らはスピードで軽さを支払います。</font><font style="vertical-align: inherit;">間違いなくRx-Javaはより機能的ですが、単純なタスクの場合、そのすべてのアセットは必要ありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロソフトとその他 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outlookサービスを操作するには、Microsoft Graph APIを使用します。</font><font style="vertical-align: inherit;">適切な権限があれば、それを介して、従業員、会議室、イベントAH（集会）に関する必要な情報をすべて取得できます。</font><font style="vertical-align: inherit;">顔認識には、Microsoft Face APIクラウドサービスが使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今後、スケーラビリティの問題を解決するために、Firebaseクラウドストレージが使用されたと言います。</font><font style="vertical-align: inherit;">これについては以下で説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建築 </font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーラビリティの問題 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムを完全または部分的にスケーラブルにすることは非常に困難です。これは、アプリケーションの最初のバージョンがスケーラブルではなく、2番目のバージョンがスケーラブルになる必要がある場合は特に困難です。アプリケーションv1は、すべての部屋に一度にリクエストを送信しました。各タブレットは定期的にサーバーにリクエストを送信して、すべてのデータを更新しました。同時に、デバイスは互いに同期しませんでした。プロジェクトには、独自のサーバーがありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、同じ経路をたどり、N個のタブレットのそれぞれからN個のリクエストを送信する場合、ある時点でMicrosoft Graph APIを覆すか、システムをフリーズさせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーがグラフをポーリングし、データを蓄積し、要求に応じてタブレットに情報を提供するクライアントサーバーソリューションを使用するのは理にかなっていますが、ここでは現実に対応しています。プロジェクトチームは2人（Android開発者とデザイナー）で構成されています。彼らは7週間の締め切りを満たす必要があり、バックエンドはありません。スケーリングは開発者の要件です。しかし、これはアイデアが放棄されなければならないという意味ではありませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、この状況での唯一の正しい解決策は、クラウドストレージの使用でしょう。 Firebaseはサーバーを置き換え、バッファとして機能します。次に、次のことが</font><i><font style="vertical-align: inherit;">わかり</font></i><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各タブレットは、Microsoft Graph APIからのアドレスのみをポーリングし、必要に応じて、クラウドストレージ内のデータを同期します。データは、他のデバイスから読み取ることができます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装の利点は、迅速な対応です。</font><font style="vertical-align: inherit;">Firebaseはリアルタイムモードで動作します。</font><font style="vertical-align: inherit;">サーバーに送信されるリクエストの数をN倍に減らします。つまり、デバイスはバッテリーで少し長く動作します。</font><font style="vertical-align: inherit;">財務的な観点から、プロジェクトの価格は上昇しませんでした。</font><font style="vertical-align: inherit;">このプロジェクトでは、無料バージョンのFirebaseで十分です。複数の予約があります。1GBのストレージ、1か月あたり1万回の認証、一度に100接続です。</font><font style="vertical-align: inherit;">不利な点には、サードパーティのフレームワークへの依存が含まれる可能性がありますが、Firebaseは私たちに自信を呼び起こします。</font><font style="vertical-align: inherit;">これは、Googleによって維持および開発された安定した製品です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいシステムの一般的な考え方は次のとおりです：Nタブレットとリアルタイムのデータ同期のためのクラウドプラットフォーム。</font><font style="vertical-align: inherit;">アプリケーション自体の設計を始めましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ内のLiveData </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は最近、良い形のルールを確立し、すぐにそれらの1つに違反したように思えます。 ViewModel内でのLiveDataの推奨される使用法とは異なり、このプロジェクトでは、LiveDataオブジェクトはリポジトリで初期化され、すべてのリポジトリはシングルトンとして宣言されます。何故ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のソリューションがアプリケーションモードに関連付けられています。タブレットは午前8時から午後8時までご利用いただけます。これまでずっと、ミーティングルームヘルパーだけが起動されていました。その結果、多くのオブジェクトは長期間存続することができ、存続する必要があります（そのため、すべてのリポジトリがシングルトンとして設計されています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業の過程で、UIコンテンツは定期的に切り替えられます。そのため、ViewModelオブジェクトの作成と再作成が必要になります。結局のところ、ViewModel内でLiveDataを使用すると、作成されたフラグメントごとに、指定された一連のLiveDataオブジェクトを使用して独自のViewModelが作成されます。異なるViewModelと共通のBase-ViewModelを使用して、2つの類似のフラグメントが同時に画面に表示される場合、初期化中に、Base-ViewModelからのLiveDataオブジェクトが重複します。将来、これらの複製は、「ガベージコレクター」によって破棄されるまでメモリ領域を消費します。なぜならシングルトン形式のリポジトリがすでにあり、画面を再作成するコストを最小限にしたい場合は、シングルトンリポジトリ内でLiveDataオブジェクトを転送すると、ViewModelオブジェクトが容易になり、アプリケーションの速度が向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これはすべてのLiveDataをViewModelからリポジトリに転送する必要があるという意味ではありませんが、この問題にもっと慎重に取り組み、意識的に選択する必要があります。</font><font style="vertical-align: inherit;">このアプローチの欠点は、長命のオブジェクトの数が増えることです。</font><font style="vertical-align: inherit;">すべてのリポジトリはシングルトンとして定義され、それぞれにLiveDataオブジェクトが格納されます。</font><font style="vertical-align: inherit;">ただし、特定のケースでは、Meeting Room Helperはマイナスではありません。</font><font style="vertical-align: inherit;">アプリケーションは、コンテキストを他のアプリケーションに切り替えることなく、終日ノンストップで実行されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果のアーキテクチャ </font></font></h4><br>
<img src="https://habrastorage.org/webt/yf/db/uo/yfdbuo8--ygtmrgxsybvuiuyeme.png"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのリクエストはリポジトリで実行されます。</font><font style="vertical-align: inherit;">すべてのリポジトリ（Meeting Room Helperには11個あります）はシングルトンとして設計されています。</font><font style="vertical-align: inherit;">それらは返されたオブジェクトのタイプによって分けられ、ファサードの後ろに隠されています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスロジックはViewModelにあります。</font><font style="vertical-align: inherit;">「Presenters」を使用したおかげで、すべてのViewModel（プロジェクトには6つあります）の合計サイズは120行未満であることがわかりました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティビティとフラグメントは、ViewModelから返されたオブザーバーとLiveDataを使用して、UIパーツの変更にのみ関与します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを処理および生成するための関数は「プレゼンター」に格納されます。</font><font style="vertical-align: inherit;">データ処理のためにKotlinのアクティブに使用される許可関数。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックグラウンドロジックがIntent-Serviceに移動されました。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント更新サービス。</font><font style="vertical-align: inherit;">FirebaseとGraph APIで現在の部屋のデータを同期するサービス。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー認識サービス。</font><font style="vertical-align: inherit;">マスタータブレットでのみ実行されます。</font><font style="vertical-align: inherit;">システムに新しいスタッフを追加する責任があります。</font><font style="vertical-align: inherit;">Active Directoryのリストを使用して、すでに訓練された人のリストをチェックします。</font><font style="vertical-align: inherit;">新しい人が現れた場合、サービスはそれらをFace APIに追加し、ニューラルネットワークを再トレーニングします。</font><font style="vertical-align: inherit;">操作が完了すると、オフになります。</font><font style="vertical-align: inherit;">アプリケーションの起動時に開始されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Online-Notification-Serviceは、このタブレットが機能していることを他のタブレットに通知します。</font><font style="vertical-align: inherit;">外部バッテリーが消耗していません。</font><font style="vertical-align: inherit;">Firebaseで機能します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、責任の分散という観点から見ると、かなり柔軟で正しいアーキテクチャとなり、現代の開発のすべての要件を満たしています。</font><font style="vertical-align: inherit;">将来、Microsoft Graph API、Firebase、またはその他のモジュールを放棄した場合、アプリケーションの残りの部分に干渉することなく、新しいモジュールに簡単に置き換えることができます。</font><font style="vertical-align: inherit;">「プレゼンター」の広範なシステムの存在により、コアを超えてすべてのデータ処理機能を利用することが可能になりました。</font><font style="vertical-align: inherit;">その結果、アーキテクチャは非常に明確になりました。これは大きなプラスです。</font><font style="vertical-align: inherit;">大きくなり過ぎたViewModelの問題は完全になくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、開発したアプリケーションで一般的に使用されるバンドルの例を示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">練習。</font><font style="vertical-align: inherit;">アップデートを見る</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
会議室の状態に応じて、ダイヤルには次のいずれかの状態が表示されます</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sa/o2/to/sao2towzwxh0qqlp1gvxd_s2qjg.png"><br>
<img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。さらに、ダイヤルのアウトラインに沿って一時的な集会のアーチがあり、センターは会議の終わりまで、または次のラリーが始まるまでカウントダウンします。</font><font style="vertical-align: inherit;">これはすべて、私たちが開発したキャンバスライブラリによって行われます。</font><font style="vertical-align: inherit;">会議のグリッドが変更された場合は、ライブラリのデータを更新する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LiveDataはリポジトリで発表されるため、それらから始めるのが最も論理的です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirebaseRoomRepository</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Roomモデルに関連するFirebaseでのリクエストの送信と処理を担当するクラス。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// 1. </span>
<span class="hljs-keyword">object</span> FirebaseRoomRepository { 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> database = FirebaseFactory.database 
    <span class="hljs-keyword">val</span> rooms: MutableList&lt;Room&gt; = ArrayList()<font></font>
<font></font>
    <span class="hljs-comment">// 2. </span>
    <span class="hljs-keyword">var</span> currentRoom: MutableLiveData&lt;Room?&gt; = MutableLiveData() 
    <span class="hljs-keyword">val</span> onlineStatus: MediatorLiveData&lt;HashMap&lt;String, <span class="hljs-built_in">Boolean</span>&gt;&gt; = MediatorLiveData() 
    <span class="hljs-keyword">var</span> otherRooms: MutableLiveData&lt;List&lt;Room&gt;&gt; = MutableLiveData() 
    <span class="hljs-keyword">var</span> ownRoom: MutableLiveData&lt;Room&gt; = MutableLiveData() <font></font>
<font></font>
    <span class="hljs-comment">// 3. </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> roomsListener = <span class="hljs-keyword">object</span> : ValueEventListener { 
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataChange</span><span class="hljs-params">(dataSnapshot: <span class="hljs-type">DataSnapshot</span>)</span></span> { <font></font>
            updateRooms(dataSnapshot) <font></font>
        } <font></font>
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(error: <span class="hljs-type">DatabaseError</span>)</span></span> {} <font></font>
    } <font></font>
<font></font>
    <span class="hljs-keyword">init</span> { 
        <span class="hljs-comment">// 4. </span><font></font>
        database.getReference(ROOMS_CURRENT_STATES)<font></font>
                            .addValueEventListener(roomsListener) <font></font>
    } <font></font>
 <font></font>
    <span class="hljs-comment">// 5. </span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRooms</span><span class="hljs-params">(dataSnapshot: <span class="hljs-type">DataSnapshot</span>)</span></span> { <font></font>
        rooms.updateRooms(dataSnapshot) <font></font>
        otherRooms.updateOtherRooms(rooms) <font></font>
        ownRoom.updateOwnRoom(rooms) <font></font>
        currentRoom.updateCurrentRoom(rooms, ownRoom) <font></font>
    } <font></font>
} <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実例を示すために、リスナーのfirebase初期化コードがわずかに簡略化されました（再接続機能は削除されました）。</font><font style="vertical-align: inherit;">ここで何が起こっているのかを見てみましょう：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリはシングルトンとして設計されています（Kotlinでは、このため、classキーワードをオブジェクトに置き換えるだけで十分です）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveDataオブジェクトの初期化。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueEventListenerは、再接続の場合に匿名クラスの再作成を回避するために変数として宣言されています（切断の場合に再接続を削除することで初期化を簡略化したことを思い出してください）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueEventListenerの初期化（Firebaseのデータが変更された場合、リスナーはLiveDataオブジェクトのデータをすぐに実行および更新します）; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LiveDataオブジェクトの更新。 </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数自体は別のFirebaseRoomRepositoryPresenterファイルに移動され、拡張関数として装飾されます。 </font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> MutableLiveData<span class="hljs-type">&lt;List&lt;Room&gt;</span>&gt;.<span class="hljs-title">updateOtherRooms</span><span class="hljs-params">(rooms: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Room</span>&gt;)</span></span> { 
    <span class="hljs-keyword">this</span>.postValue(rooms.filter { !it.isOwnRoom() }) <font></font>
} <font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirebaseRoomRepositoryPresenterの拡張関数の例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
また、画像の一般的な理解のために、Roomオブジェクトのリストを示します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// 1. </span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span></span>(<span class="hljs-keyword">var</span> number: String = <span class="hljs-string">""</span>, 
                <span class="hljs-keyword">var</span> nickName: String = <span class="hljs-string">""</span>, 
                <span class="hljs-keyword">var</span> email: String? = <span class="hljs-literal">null</span>, 
                <span class="hljs-keyword">var</span> imgSmall: String? = <span class="hljs-literal">null</span>, 
                <span class="hljs-keyword">var</span> imgOffline: String? = <span class="hljs-literal">null</span>, 
                <span class="hljs-keyword">var</span> imgFree: String? = <span class="hljs-literal">null</span>, 
                <span class="hljs-keyword">var</span> imgWait: String? = <span class="hljs-literal">null</span>, 
                <span class="hljs-keyword">var</span> imgBusy: String? = <span class="hljs-literal">null</span>, 
                <span class="hljs-keyword">var</span> events: List&lt;Event.<span class="hljs-built_in">Short</span>&gt; = emptyList()) <span class="hljs-comment">// 2. </span>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データクラス。</font><font style="vertical-align: inherit;">この修飾子は、toString（）、HashCode（）、およびequal（）メソッドを自動的に生成してオーバーライドします。</font><font style="vertical-align: inherit;">それらを自分で再定義する必要はもうありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roomオブジェクトのイベントリスト。</font><font style="vertical-align: inherit;">ダイヤルライブラリのデータを更新するために必要なのはこのリストです。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのリポジトリクラスは、ファサードクラスの背後に隠されています。 </font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">object</span> Repository { 
    <span class="hljs-comment">// 1.  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> firebaseRoomRepository = FirebaseRoomRepository 
    <span class="hljs-comment">// ......... </span><font></font>
     <font></font>
    <span class="hljs-comment">/** 
     * Rooms queries 
     */</span> 
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOtherRooms</span><span class="hljs-params">()</span></span> = firebaseRoomRepository.otherRooms <font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOwnRoom</span><span class="hljs-params">()</span></span> = firebaseRoomRepository.ownRoom <font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAllRooms</span><span class="hljs-params">()</span></span> = firebaseRoomRepository.rooms 
    <span class="hljs-comment">// 2. </span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCurrentRoom</span><span class="hljs-params">()</span></span> = firebaseRoomRepository.currentRoom <font></font>
     <font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-comment">// ....... </span><font></font>
}<font></font>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上部には、使用されているすべてのリポジトリクラスと第2レベルのファサードのリストが表示されます。</font><font style="vertical-align: inherit;">これにより、コードの一般的な理解が簡素化され、接続されているすべてのリポジトリクラスのリストが示されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirebaseRoomRepositoryからLiveDataオブジェクトへの参照を返すメソッドのリスト。</font><font style="vertical-align: inherit;">Kotlinのセッターとゲッターはオプションなので、不必要にそれらを記述する必要はありません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような組織では、1つのルートリポジトリに20〜30のリクエストを快適に収めることができます。</font><font style="vertical-align: inherit;">アプリケーションのリクエストが多い場合は、ルートファサードを2つ以上に分割する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewModel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewModelは、すべてのViewModelが継承されるベースViewModelです。</font><font style="vertical-align: inherit;">これには、普遍的に使用される単一のcurrentRoomオブジェクトが含まれています。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// 1. </span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewModel</span> : <span class="hljs-type">ViewModel</span></span>() { 
    <span class="hljs-comment">// 2. </span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCurrentRoom</span><span class="hljs-params">()</span></span> = Repository.getCurrentRoom() <font></font>
} <font></font>
</code></pre><br>
<ol>
<li> open ,     .    Kotlin      final, ..    ,    .         .  . <br>
<br>
<i>    .  -              - .  ,     . …     ,     - ,   ,              .    Kotlin      final,      «open». </i><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getCurrentRoom（）メソッドは、リポジトリから現在のルームのLiveDataオブジェクトへのリンクを返します。リポジトリは、FirebaseRoomRepositoryから取得されます。</font><font style="vertical-align: inherit;">このメソッドが呼び出されると、Roomオブジェクトは、イベントのリストを含む、部屋に関するすべての情報を含む返されます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データをあるフォーマットから別のフォーマットに変換するために、変換を使用します。</font><font style="vertical-align: inherit;">これを行うには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MainFragmentViewModel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BaseViewModel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から継承し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MainFragmentViewModel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、BaseViewModelからの</font><i><font style="vertical-align: inherit;">派生</font></i><font style="vertical-align: inherit;">クラスです。</font><font style="vertical-align: inherit;">このViewModelはMainFragmentでのみ使用されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// 1. </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainFragmentViewModel</span>: <span class="hljs-type">BaseViewModel </span></span>() { 
    <span class="hljs-comment">// 2. </span>
    <span class="hljs-keyword">var</span> currentRoomEvents = Transformations.switchMap(getCurrentRoom()) { 
        <span class="hljs-keyword">val</span> events: MutableLiveData&lt;List&lt;Event.<span class="hljs-built_in">Short</span>&gt;&gt; = MutableLiveData()
        <span class="hljs-comment">// some business logic</span><font></font>
        events.postValue(it?.eventsList) <font></font>
        events <font></font>
    } <font></font>
<font></font>
    <span class="hljs-comment">// 3. </span>
    <span class="hljs-keyword">val</span> currentRoomEvents2 = MediatorLiveData&lt;List&lt;Event.<span class="hljs-built_in">Short</span>&gt;&gt;().apply { <font></font>
        addSource(getCurrentRoom()) { room -&gt; <font></font>
            <span class="hljs-comment">// some business logic </span><font></font>
            postValue(room?.eventsList) <font></font>
        } <font></font>
    } <font></font>
} <font></font>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open修飾子がないことに注意してください。</font><font style="vertical-align: inherit;">これは、誰もクラスから継承しないことを意味します。</font></font></li>
<li>currentRoomEvents — ,    .      ,     currentRoomEvents . </li>
<li>MediatorLiveData.    (  ). </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のオプションはデータをあるタイプから別のタイプに変換するために使用されます。これは私たちが必要とするものであり、2番目のオプションはビジネスロジックを実行するために必要です。</font><font style="vertical-align: inherit;">ただし、データ変換は行われません。</font><font style="vertical-align: inherit;">ViewModelでのAndroidインポートは無効であることを忘れないでください。</font><font style="vertical-align: inherit;">したがって、ここから追加のリクエストを開始するか、必要に応じてサービスを再起動します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要なお知らせ！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換またはメディエーターが機能するためには、フラグメントまたはアクティビティーから誰かがサブスクライブする必要があります。</font><font style="vertical-align: inherit;">それ以外の場合、コードは実行されません。</font><font style="vertical-align: inherit;">誰も結果を期待しません（これらはオブザーバーオブジェクトです）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインフラグメント </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを結果に変換する最後のステップ。</font><font style="vertical-align: inherit;">MainFragmentには、画面の下部にダイヤルライブラリとView-Pagerが含まれています。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainFragment</span> : <span class="hljs-type">BaseFragment</span></span>() { 
    <span class="hljs-comment">// 1. </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: MainFragmentViewModel <font></font>
<font></font>
    <span class="hljs-comment">// 2. </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> currentRoomObserver = Observer&lt;List&lt;Event.<span class="hljs-built_in">Short</span>&gt;&gt; { <font></font>
        clockView.updateArcs(it) <font></font>
    } <font></font>
 <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>?)</span></span> { 
        <span class="hljs-keyword">super</span>.onAttach(context) 
        <span class="hljs-comment">// 3. </span>
        viewModel = ViewModelProviders.of(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(MainFragmentViewModel::<span class="hljs-keyword">class</span>.java) <font></font>
    } <font></font>
 <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onCreateView(inflater: LayoutInflater, container: ViewGroup?, <font></font>
                              savedInstanceState: Bundle?): View? { <font></font>
        return inflater.inflate(R.layout.fragment_main, container, <span class="hljs-literal">false</span>) <font></font>
    } <font></font>
     <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onActivityCreated(savedInstanceState: Bundle?) { 
        <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState) <font></font>
        // <span class="hljs-number">4</span>. <font></font>
        viewModel.currentRoomEvents.observe(viewLifecycleOwner, currentRoomObserver) <font></font>
    } <font></font>
} <font></font>
</code></pre><br>
<ol>
<li>  MainFragmentViewModel.  lateinit   ,       ,  ,   . Kotlin       ,      ,     null,   lateinit.    ViewModel     . </li>
<li>Observer-listener   . </li>
<li> ViewModel.  ,     ,     activity. </li>
<li>   activity  ,      currentRoomEvents.  ,         (this),    viewLifecycleOwner.   ,   support library 28.0.0  AndroidX 1.0.0    «» observer.          viewLifecycleOwner,  Google     .    -observer-,   ,  observer  .      this,     viewLifecycleOwner. </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、データバインディングを使用せずに、MVVMとLiveDataのシンプルさと美しさを実証したいと思います。</font><font style="vertical-align: inherit;">このプロジェクトでは、プロジェクトの詳細のために、LiveDataをリポジトリに配置することで、一般に受け入れられているルールに違反していることに注意してください。</font><font style="vertical-align: inherit;">ただし、それらをViewModelに移動した場合、全体像は変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケーキのチェリーとして、デモ付きの短いビデオを用意しました（名前はセキュリティ要件に従って塗り付けられています。お詫び申し上げます）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/E9zUc0vaGck" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の月のアプリケーションの結果として、クロスラリーの表示にいくつかのバグが明らかになりました（Outlookでは、複数のイベントを同時に作成できますが、システムではできません）。</font><font style="vertical-align: inherit;">現在、システムは3か月間稼働しています。</font><font style="vertical-align: inherit;">エラーや障害は観察されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PSありがとう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jericho_code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメントのために。</font><font style="vertical-align: inherit;">Kotlinでは、モデルのList &lt;&gt;をemptyList（）を使用して初期化できます。そうすると、余分なオブジェクトは作成されません。</font></font><br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">var</span> events: List&lt;Event.<span class="hljs-built_in">Short</span>&gt; = emptyList() <span class="hljs-comment">//      EmptyList</span>
<span class="hljs-keyword">var</span> events: List&lt;Event.<span class="hljs-built_in">Short</span>&gt; = ArrayList()  <span class="hljs-comment">//   </span>
</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457948/index.html">頭をぶち壊さなければならないボードゲーム</a></li>
<li><a href="../ja457952/index.html">プロセッサの設計と製造方法：チップ製造</a></li>
<li><a href="../ja457954/index.html">Swiftがディープラーニングの大きなイベントになる理由</a></li>
<li><a href="../ja457956/index.html">自分の足を撃たずにストレージを選択する方法</a></li>
<li><a href="../ja457958/index.html">平日MT_FREE：公共Wi-Fiの動作に対するサードパーティサービスの影響についてのいくつかのストーリー</a></li>
<li><a href="../ja457962/index.html">スラッシュアーキテクチャの条件やスクラムのスキル不足のように、クロスコンポーネントチームを作成しました</a></li>
<li><a href="../ja457964/index.html">真の仮想性：ワークステーション++</a></li>
<li><a href="../ja457966/index.html">「私はロシア南部に特別なITゾーンを開設します」-プログラマー向けの10の質問＃11。新しい季節</a></li>
<li><a href="../ja457968/index.html">交差する類似点-通信省は一晩で数十億の予算を消費しました</a></li>
<li><a href="../ja457970/index.html">Go in Linter。それらを調理する方法。デニス・イサエフ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>