<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 👩🏼‍🍳 🛬 Packer, Terraform et Ansible: déploiement du cluster Kubernetes en une heure 😫 ✋🏼 🐥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je m'appelle Andrey Schukin, j'aide les grandes entreprises à migrer leurs services et systèmes vers le cloud CROC. En collaboration avec des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Packer, Terraform et Ansible: déploiement du cluster Kubernetes en une heure</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/492616/"><img src="https://habrastorage.org/webt/0m/2c/zt/0m2cztx1saqv1v7e8a3mrliht_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bonjour, je m'appelle Andrey Schukin, j'aide les grandes entreprises à migrer leurs services et systèmes vers le cloud CROC. En collaboration avec des collègues de Southbridge, qui organise des cours Kubernetes au centre de formation Slerm, nous avons récemment organisé un webinaire pour nos clients. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai décidé de prendre des documents d'une excellente conférence de Pavel Selivanov et d'écrire un article pour ceux qui commencent tout juste à travailler avec des outils de provisioning cloud et ne savent pas par où commencer. Par conséquent, je vais parler de la pile de technologies utilisées dans notre formation et notre production de CROC Cloud. Parlons des approches modernes de la gestion de l'infrastructure, d'un tas de composants Packer, Terraform et Ansible, ainsi que de l'outil Kubeadm avec lequel nous allons installer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la coupe, il y aura beaucoup de texte et de configurations. </font><font style="vertical-align: inherit;">Il y a beaucoup de matériel, j'ai donc ajouté la navigation post. </font><font style="vertical-align: inherit;">Nous avons également préparé un petit référentiel où nous avons mis tout ce dont nous avions besoin pour notre déploiement de formation. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne donnez pas de noms aux poulets. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les gâteaux au four sont plus sains que les frits. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allumons le four. </font><font style="vertical-align: inherit;">Packer </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - infrastructure en tant que code </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lancez la </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structure du cluster </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Terraform </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Kubernetes </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository avec tous les fichiers</font></font></a><br>
 <a name="habracut"></a><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne donnez pas de noms aux poulets</font></font></h2><br>
<img src="https://habrastorage.org/webt/j0/0w/v1/j00wv1h7pcevviakk2iocfleqjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe de nombreux concepts différents de gestion des infrastructures. L'un d'eux s'appelle Pets vs. Le bétail, c'est-à-dire "les animaux de compagnie contre le bétail". Ce concept décrit deux approches opposées de l'infrastructure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez que nous avons un chien préféré. Nous prenons soin d'elle, l'emmenons chez le vétérinaire, peignons la fourrure, et en général, elle est unique parmi de nombreux autres chiens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans un autre cas, nous avons un poulailler. Nous prenons également soin des poulets, nourrissons, chauffons et essayons de créer les conditions les plus confortables. Néanmoins, les poulets sont une ressource plutôt sans visage pour nous, qui remplit sa fonction de ponte, et au mieux nous les désignons comme "ce noir en poudre qui picore toujours le ciment". Si le poulet cesse de pondre des œufs ou se casse la patte, il est fort probable qu'il nous fournira simplement un délicieux bouillon pour le déjeuner. En fait, nous ne nous soucions pas du sort d'un poulet en particulier, mais du poulailler dans son ensemble en tant que chaîne de production. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En informatique, une approche similaire a commencé à être appliquée dès l'apparition des outils qui abaissaient le seuil d'entrée pour les ingénieurs et permettaient de déployer et de maintenir des clusters complexes en mode entièrement automatique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, nous avions un petit nombre de serveurs qui étaient surveillés, réglés manuellement et entretenus de toutes les manières possibles. Lors de la surveillance, les journaux des serveurs Cthulhu, Aylith et Dagon ont clignoté. Traditions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la virtualisation est fermement entrée dans nos vies, et les noms des œuvres de Lovecraft et Star Trek ont ​​cédé la place au «vlg-vlt-vault01.company.ru» plus utilitaire. Il y a beaucoup de serveurs, mais nous avons quand même augmenté les services plus ou moins manuellement, éliminant les problèmes sur chaque machine si nécessaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Désormais, l'approche de la maintenance de l'infrastructure coïncide complètement avec la programmation. </font><font style="vertical-align: inherit;">Nous ajoutons un autre niveau d'abstraction et cessons de nous soucier des nœuds individuels. </font><font style="vertical-align: inherit;">Chacun a un index sans visage au lieu d'un nom, et en cas de problème, la machine virtuelle tue et monte simplement à partir de l'instantané de travail. </font><font style="vertical-align: inherit;">Il existe des outils qui vous permettent de mettre en œuvre cette approche. </font><font style="vertical-align: inherit;">Dans notre cas, le premier outil est le CROC Cloud, le second est Terraform.</font></font><br>
<br>
<a name="2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les gâteaux au four sont plus sains que frits</font></font></h2><br>
<img src="https://habrastorage.org/webt/hs/pp/oa/hsppoaujv0lhrk0u3dt6ust0rry.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la gestion des infrastructures, il existe un contraste entre les deux approches Fried vs Cuit, c'est-à-dire «frit contre cuit». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche de Fried implique que vous avez une image vanilla du système d'exploitation, par exemple, CentOS 7. Ensuite, après le déploiement du système d'exploitation, nous utilisons le système de gestion de la configuration afin d'amener le système à l'état cible. Par exemple, en utilisant Ansible, Chef, Puppet ou SaltStack.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout fonctionne bien, surtout quand il n'y a pas beaucoup de serveurs. Lorsqu'un déploiement massif est nécessaire, nous sommes confrontés à des problèmes de performances. Des centaines de serveurs commencent à dévorer de manière synchrone les ressources réseau, le CPU, la RAM et les IOPS dans le processus de déploiement de nombreux nouveaux packages. De plus, ce processus peut être retardé assez longtemps. Bref, le circuit est absolument opérationnel, mais pas si intéressant du point de vue de la minimisation des temps d'arrêt lors d'accidents.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche Baked implique que vous avez des images OS prêtes à l'emploi sur lesquelles vous avez déjà installé tous les packages nécessaires, configuré la configuration et tout le reste. </font><font style="vertical-align: inherit;">À la sortie, nous avons un modèle d'instantané abstrait, affiné pour les performances de certaines fonctions. </font><font style="vertical-align: inherit;">Le déploiement de l'infrastructure à partir de ces images cuites prend beaucoup moins de temps et réduit les temps d'arrêt au minimum. </font><font style="vertical-align: inherit;">Une idéologie très similaire est utilisée dans les images Docker multicouches, dans lesquelles personne ne se tape inutilement les mains. </font><font style="vertical-align: inherit;">Cloué le conteneur - en a soulevé un nouveau.</font></font><br>
<br>
<a name="3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous démarrons le four. </font><font style="vertical-align: inherit;">Emballeur</font></font></h2><br>
<img src="https://habrastorage.org/webt/xw/mr/im/xwmrimtkl-6qvfcrae3xo4zdf7q.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre infrastructure, nous utilisons plusieurs produits Hashicorp, dont certains se sont avérés extrêmement réussis. Commençons notre magie avec la préparation et la cuisson d'une image à l'aide de l'outil Packer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Packer utilise un modèle JSON, c'est-à-dire des fichiers de modèle qui contiennent une description de ce qui doit être obtenu en tant que machine virtuelle (VM) «cuite». Après avoir créé le modèle, le fichier est transféré vers Packer et les autorisations nécessaires pour créer le serveur dans le cloud sont configurées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Packer vous permet de générer des VM localement dans KVM, VirtualBox, Vagrant, AWS, GCP, Alibaba Cloud, OpenStack, etc. Il est pratique de travailler avec Packer dans le cloud CROC, car il implémente des interfaces AWS, c'est-à-dire tous les outils qui sont écrits pour AWS, travaillez avec le CROC Cloud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir défini les modèles nécessaires, Packer lève VM CROC dans le Cloud, attend qu'il démarre, puis le «fournisseur» entre dans le travail - provisioner: un utilitaire qui doit terminer la préparation de l'image. </font><font style="vertical-align: inherit;">Dans notre cas, il s'agit d'Ansible, bien que Packer puisse fonctionner avec d'autres options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la machine virtuelle est prête, Packer crée son image et la place dans le cloud CROC afin que d'autres machines virtuelles puissent être lancées à partir de la même image.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure Base.json</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début du fichier, il y a une section dans laquelle les variables sont déclarées:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"variables" : {<font></font>
 "source_ami_name": "{{env SOURCE_AMI_NAME}}",<font></font>
 "ami_name": "{{env AMI_NAME}}",<font></font>
 "instance_type": "{{env INSTANCE_TYPE}}",<font></font>
 "kubernetes_version": "{{env KUBERNETES_VERSION}}",<font></font>
 "docker_version": "{{env DOCKER_VERSION}}",<font></font>
 "subnet_id": "",<font></font>
 "availability_zone": "",<font></font>
},</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ensemble principal de ces variables sera défini à partir du fichier settings.json. </font><font style="vertical-align: inherit;">Et ces variables qui changent fréquemment sont plus pratiques à définir à partir de la console lors du démarrage de Packer et de la création d'une nouvelle image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la section Builders:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"builders" : [<font></font>
 {<font></font>
  "type": "amazon-ebs",<font></font>
  "region": "croc",<font></font>
  "skip_region_validation": true,<font></font>
  "custom_endpoint_ec2": "https://api.cloud.croc.ru",<font></font>
  "source_ami": "",<font></font>
  "source_ami_filter": {<font></font>
   "filters": {<font></font>
    "name": "{{user `source_ami_name`}}"<font></font>
    "state": "available",<font></font>
    "virtualization-type": "kvm-virtio"<font></font>
     },<font></font>
...</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les nuages ​​cibles et la méthode de démarrage de la machine virtuelle sont décrits ici. Veuillez noter que dans ce cas, le type amazon-ebs est déclaré, mais pour le fonctionnement de Packer avec le CROC Cloud, l'adresse correspondante dans custom_endpoint_ec2 est définie. Notre infrastructure dispose d'une API qui est presque entièrement compatible avec Amazon Web Services, donc si vous avez des développements prêts à l'emploi pour cette plate-forme, vous n'aurez pour la plupart à spécifier qu'un point d'entrée d'API personnalisé - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">api.cloud.croc.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans notre exemple.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter séparément la section source_ami_filter. </font><font style="vertical-align: inherit;">Ici, l'image initiale de la VM est définie, dans laquelle les modifications nécessaires seront apportées. </font><font style="vertical-align: inherit;">Cependant, Packer nécessite une AMI pour cette image, c'est-à-dire son identifiant aléatoire. </font><font style="vertical-align: inherit;">Étant donné que cet identifiant est rarement connu à l'avance et change à chaque mise à jour, l'AMI source n'est pas définie comme une valeur spécifique, mais comme une variable source_ami_filter. </font><font style="vertical-align: inherit;">Dans ce cas, le paramètre déterminant du filtre est le nom de l'image. </font><font style="vertical-align: inherit;">Ce nom est défini dans les variables via le fichier settings.json. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, les paramètres de la VM sont définis: le type d'instance, le processeur, la taille de la mémoire, l'espace alloué, etc. sont spécifiés:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"instance_type": "{{user `instance_type`}}",<font></font>
"launch_block_device_mappings": [<font></font>
 {<font></font>
  "device_name": "disk1",<font></font>
  "volume_type": "io1",<font></font>
  "volume_size": "8",<font></font>
  "iops": "1000",<font></font>
  "delete_on_termination": "true"<font></font>
 }<font></font>
],</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici les paramètres de connexion à cette machine virtuelle dans base.json:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"availability_zone": "{{user `availability_zone`}}",<font></font>
"subnet_id": "{{user `subnet_id`}}",<font></font>
"associate_public_ip_address": true,<font></font>
"ssh_username": "ec2-user",<font></font>
"ami_name": "{{user `ami_name`}}"<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de noter ici le paramètre subnet_id. </font><font style="vertical-align: inherit;">Il doit être défini manuellement, car sans spécifier le sous-réseau VM dans le CROC Cloud, il est impossible de créer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre paramètre qui nécessite une préparation préalable est associ_public_ip_address. </font><font style="vertical-align: inherit;">Vous devez sélectionner une adresse IP blanche, car après avoir créé le VM Packer commencera à appliquer les paramètres nécessaires via Ansible. </font><font style="vertical-align: inherit;">Dans ce cas, Ansible se connecte à la machine virtuelle via SSH, ce qui nécessite une adresse IP blanche ou un VPN. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière section est les Provisioners:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"provisioners": [<font></font>
 {<font></font>
  "type": "ansible",<font></font>
  "playbook_file": "playbook.yml",<font></font>
  "extra_arguments": [<font></font>
   "--extra-vars",<font></font>
   "kubernetes_version={{user `kubernetes_version`}}",<font></font>
   "--extra-vars",<font></font>
   "docker_version={{user `docker_version`}}"<font></font>
   ]<font></font>
  }<font></font>
]</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce sont les fournisseurs, c'est-à-dire les utilitaires avec lesquels Packer configure le serveur. </font><font style="vertical-align: inherit;">Dans ce cas, un fournisseur de type ansible est utilisé. </font><font style="vertical-align: inherit;">Voici le paramètre playbook_file, qui définit les rôles Ansible et les hôtes sur lesquels les rôles spécifiés seront appliqués. </font><font style="vertical-align: inherit;">Des options supplémentaires extra_arguments sont présentées ci-dessous, qui, au démarrage d'Ansible, transmettent les versions de Kubernetes et Docker.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préparation du CROC Cloud</font></font></h3><br>
 <img src="https://habrastorage.org/webt/23/_s/uo/23_suoef0us5ia6kjgn8xteomba.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de nos fichiers de configuration, nous devons faire quelques choses depuis le côté du panneau de contrôle du cloud pour que toute la magie fonctionne. </font><font style="vertical-align: inherit;">Nous devons sélectionner une IP blanche et créer un sous-réseau de travail, que nous utiliserons lors du déploiement.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cliquez sur Mettre en surbrillance l'adresse. </font><font style="vertical-align: inherit;">Packer trouvera automatiquement l'adresse IP blanche souhaitée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cliquez sur Créer un sous-réseau et spécifiez un sous-réseau et un masque. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copiez l'ID de sous-réseau. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insérez cette valeur dans le paramètre subnet_id de la commande de démarrage Packer. </font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/24/0w/gp/240wgpvzi8oyy6ixwzdj8cougqk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exécutez ensuite Packer. </font><font style="vertical-align: inherit;">Il trouve l'image de la machine virtuelle d'origine, la déploie dans le cloud CROC et y exécute le rôle Ansible. </font><font style="vertical-align: inherit;">La nouvelle VM est visible dans le CROC Cloud dans la section "Instances". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ol/aj/ui/olajuiprqljv50bi2opn4xlqcvs.png"> <br>
 <br>
<img src="https://habrastorage.org/webt/rq/0d/ri/rq0drint5cwvddjxbd7czcyfp9a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir terminé le travail, Packer supprime la machine virtuelle du cloud et laisse une image prête à l'emploi à sa place, qui se trouve dans la section "Modèles". </font><font style="vertical-align: inherit;">L'ensemble de l'infrastructure Kubernetes sera créée à partir de cette image.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansible</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionné précédemment, le paramètre playbook est passé dans les paramètres du fournisseur Ansible. </font><font style="vertical-align: inherit;">Le fichier playbook.yml lui-même ressemble à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">- hosts: all<font></font>
  become: true<font></font>
<font></font>
  roles:<font></font>
  | - base</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier transfère à Ansible que sur tous les hôtes il est nécessaire de remplir le rôle de base. </font><font style="vertical-align: inherit;">S'il existe d'autres rôles, vous pouvez les ajouter au même fichier qu'une liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rôle de base vous permet d'obtenir un cluster prêt à l'emploi avec une seule commande. </font><font style="vertical-align: inherit;">Le fichier main.yml montre ce que fait exactement ce rôle:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoute un référentiel Docker au modèle système. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoute le référentiel Kubernetes au modèle système. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installe les packages nécessaires. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crée un répertoire pour configurer le démon Docker. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configure la machine en fonction du fichier de configuration daemon.json.j2. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charge le noyau br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inclut les options nécessaires pour br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprend les composants Docker et Kubelet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exécute Docker dans VM.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exécute une commande qui télécharge les images Docker nécessaires au fonctionnement de Kubernetes.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, les packages installés sont définis dans le fichier main.yml du répertoire vars. </font><font style="vertical-align: inherit;">Dans notre cas, nous installons le package docker-ce, ainsi que les trois packages nécessaires au fonctionnement de Kubernetes: kubelet, kubeadm et kubectl.</font></font><br>
<br>
<a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - l'infrastructure comme code</font></font></h2><br>
<img src="https://habrastorage.org/webt/o4/um/wi/o4umwitq-qh_zpwr0thmcmejis0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform est un outil très fonctionnel de HashiCorp pour l'orchestration cloud. Il possède son propre langage HCL spécifique, qui est souvent utilisé dans d'autres produits de la société, par exemple, dans HashiCorp Vault et Consul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principe de base est similaire à tous les systèmes de gestion de configuration. Vous indiquez simplement l'état cible dans le format souhaité et le système calcule l'algorithme pour y parvenir. Une autre chose est que, contrairement au même Ansible, qui fonctionne comme une boîte noire sur les playbooks complexes, Terraform peut émettre un plan d'actions futures sous une forme pratique pour l'analyse. Ceci est important lors de la planification de changements d'infrastructure complexes. Après avoir planifié les actions nécessaires, exécutez la commande </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraform apply</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et Terraform déploiera l'infrastructure décrite dans les fichiers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme Packer, cet outil prend en charge AWS, GCP, Alibaba Cloud, Azure, OpenStack, VMware, etc.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous décrivons le projet</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le répertoire Terraform contient un ensemble de fichiers avec l'extension .tf. </font><font style="vertical-align: inherit;">Ces fichiers décrivent les composants de l'infrastructure avec lesquels nous travaillerons. </font><font style="vertical-align: inherit;">Divisez le projet en modules fonctionnels. </font><font style="vertical-align: inherit;">Une telle structure facilite le contrôle des versions et l'assemblage de chaque projet à partir de blocs pratiques prêts à l'emploi. </font><font style="vertical-align: inherit;">Pour notre option, la structure suivante convient:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">security_groups.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tpl</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure du fichier Main.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par le fichier main.tf, dans lequel l'accès au cloud est configuré. </font><font style="vertical-align: inherit;">En particulier, plusieurs paramètres sont annoncés qui configurent Terraform pour fonctionner avec le CROC Cloud:</font></font><br>
<br>
<pre><code class="plaintext hljs">provider "aws" {<font></font>
 endpoints {<font></font>
  ec2 = "https://api.cloud.croc.ru"<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, le fichier décrit que Terraform doit créer indépendamment une clé privée et télécharger sa partie publique sur tous les serveurs. </font><font style="vertical-align: inherit;">La clé privée elle-même est émise à la fin de Terraform:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "tls_private_key" "ssh" {<font></font>
 algorithm = "RSA"<font></font>
}<font></font>
resource "aws_key_pair" "kube" {<font></font>
 key_name = "terraform"<font></font>
 public_key = "${tls_private_key.ssh.public_key_openssh}"<font></font>
}<font></font>
output "ssh" {<font></font>
value = "${tls_private_key.ssh.private_key_pem}"<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La structure du fichier network.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce fichier décrit les composants réseau nécessaires pour démarrer la machine virtuelle:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">data "aws_availability_zones" "az" {<font></font>
 state = "available"<font></font>
}<font></font>
resource "aws_vpc" "kube" {<font></font>
 cidr_block = "${var.vpc_cidr}"<font></font>
}<font></font>
resource "aws_eip" "master" {<font></font>
 count = "1"<font></font>
 vpc = true<font></font>
}<font></font>
resource "aws_subnet" "private" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 count = "${length(data.aws_availability_zones.az.names)}"<font></font>
 cidr_block = "${var.private_subnet_cidr_list[count.index]}"<font></font>
 availability_zone = "${data.aws_availability_zones.az.names[count.index]}"<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform utilise deux types de composants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressource - ce qui doit être créé;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données - ce que vous devez obtenir.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, le paramètre de données indique que Terraform doit recevoir les zones de disponibilité du cloud spécifié, qui sont à l'état disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première ressource de paramètre décrit la création d'un cloud privé virtuel et le paramètre suivant décrit la création d'une adresse IP élastique. Pour le cluster Kubernetes, nous commandons cette adresse IP via Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, dans chacune des zones d'accessibilité, et au moment où CROC dispose de deux services cloud, son propre sous-réseau est créé. Une ressource de type aws_subnet est déclarée et l'ID de aws_vpc généré est transmis dans le cadre de ce paramètre. Mais, puisque l'ID de cette ressource est encore inconnu, nous spécifions le paramètre aws_vpc.kube.id, qui fait référence à la ressource créée et substitue la valeur du champ ID.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que le nombre de sous-réseaux créés est déterminé par le nombre de zones de disponibilité du cloud et que ce nombre peut changer au fil du temps, ce paramètre est spécifié via la variable de longueur (data.aws_availability_zones.az.names), c'est-à-dire la longueur de la liste des zones d'accès reçues via le paramètre de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux derniers paramètres sont cidr_block (le sous-réseau alloué) et la zone de disponibilité dans laquelle ce sous-réseau est créé. </font><font style="vertical-align: inherit;">Le dernier paramètre est également défini via une variable qui prend une valeur dans la liste de données en fonction de l'index de la boucle déclaré par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[count.index]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure du fichier Security_groups.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les groupes de sécurité sont une sorte de pare-feu pour les clouds, qui peuvent être créés non pas à l'intérieur de la machine virtuelle elle-même, mais par le cloud. </font><font style="vertical-align: inherit;">Dans ce cas, le pare-feu décrit deux règles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première règle crée un groupe de sécurité appelé kube. </font><font style="vertical-align: inherit;">Ce groupe de sécurité est nécessaire pour autoriser tout le trafic sortant des nœuds Kubernetes, permettant aux nœuds d'accéder librement à Internet. </font><font style="vertical-align: inherit;">Le trafic entrant vers les nœuds Kubernetes à partir des sous-réseaux des nœuds eux-mêmes est également autorisé. </font><font style="vertical-align: inherit;">Ainsi, les nœuds Kubernetes peuvent fonctionner entre eux sans restrictions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxième règle crée le groupe de sécurité ssh. </font><font style="vertical-align: inherit;">Il permet la connexion SSH depuis n'importe quelle adresse IP vers le port 22 de la machine virtuelle du cluster Kubernetes:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_security_group" "kube" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "kubernetes"<font></font>
 # Allow all outbound<font></font>
 egress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
 # Allow all internal<font></font>
 ingress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["${var.vpc_cidr}"]<font></font>
 }<font></font>
}<font></font>
resource "aws_security_group" "ssh" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "ssh"<font></font>
<font></font>
 # Allow all inbound<font></font>
 ingress {<font></font>
  from_port = 22<font></font>
  to_port = 22<font></font>
  protocol = "tcp"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noeud maître. </font><font style="vertical-align: inherit;">Structure du fichier Master.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier master.tf décrit la création de plusieurs modèles et instances. </font><font style="vertical-align: inherit;">En particulier, une instance maître Kubernetes est en cours de création. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La variable ami définit l'AMI de l'image source pour la machine virtuelle. </font><font style="vertical-align: inherit;">Ce qui suit décrit le type de machine virtuelle et le sous-réseau dans lequel elle est créée. </font><font style="vertical-align: inherit;">Lors de la définition d'un sous-réseau, un cycle est à nouveau utilisé pour créer des machines virtuelles dans chaque zone de disponibilité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, les groupes de sécurité utilisés et la clé spécifiée dans le fichier main.tf sont déclarés. </font><font style="vertical-align: inherit;">Le champ user_data contient l'exécution d'un ensemble de scripts cloud-init, dont les résultats seront implémentés dans la VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgacher</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_instance" "master" {<font></font>
 count = "1"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"<font></font>
 disable_api_termination = false<font></font>
 instance_initiated_shutdown_behavior = "terminate"<font></font>
 source_dest_check = false<font></font>
 subnet_id = "${aws_subnet.private.*.id[count.index % length(data.aws_availability_zones.az.names)]}"<font></font>
 associate_public_ip_address = true<font></font>
 vpc_security_group_ids = [<font></font>
  "${aws_security_group.ssh.id}",<font></font>
  "${aws_security_group.kube.id}",<font></font>
 ]<font></font>
 key_name = "${aws_key_pair.kube.key_name}"<font></font>
 user_data = "${data.template_cloudinit_config.master.rendered}"<font></font>
 monitoring = "true"<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noeud maître. </font><font style="vertical-align: inherit;">Cloud init</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un outil que Canonical développe. </font><font style="vertical-align: inherit;">Il vous permet d'exécuter automatiquement dans une infrastructure cloud un certain ensemble de commandes après le démarrage d'une machine virtuelle. </font><font style="vertical-align: inherit;">Terraform dispose de mécanismes pour l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intégrer à l'aide de modèles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'il est impossible de "cuire" tout ce qui est nécessaire dans la VM, après avoir démarré, selon son type, elle doit soit rejoindre le cluster Kubernetes soit initialiser le cluster Kubernetes. </font><font style="vertical-align: inherit;">Dans le modèle de fichier cloud-init appelé master.tpl, plusieurs actions sont effectuées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Les fichiers de configuration pour Kubeadm sont enregistrés:</font></font><br>
<br>
<pre><code class="plaintext hljs">#cloud-config<font></font>
<font></font>
    write_files:<font></font>
    - path: etc/kubernetes/kubeadm.conf<font></font>
      owner: root:root<font></font>
      content:<font></font>
    ...</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Un ensemble de commandes est exécuté:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'adresse IP de l'assistant est écrite dans le fichier de configuration généré;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le maître du cluster Kubernetes est initialisé avec la commande kubeadm init;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le cluster Kubernetes, le réseau de calques Calico est installé avec la commande kubectl apply.</font></font></li>
</ul><br>
 <pre><code class="plaintext hljs">runcmd:<font></font>
         - sed -i "s/CONTROL_PLANE_IP/$(curl http://169.254.169.254/latest/meta-data-local-ipv4)/g" /etc/kubernetes/kubeadm.conf<font></font>
         - kubeadm init --config /etc/kubernetes/kubeadm.conf<font></font>
         - mkdir -p $HOME/.kube<font></font>
         - sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<font></font>
         - sudo chown $(id -u):$(id -g) $HOME/.kube/config<font></font>
         - kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir exécuté les commandes lors du démarrage de la machine virtuelle, un cluster Kubernetes fonctionnel est obtenu à partir d'un nœud maître. </font><font style="vertical-align: inherit;">Les nœuds restants rejoindront ce nœud maître.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noeuds ordinaires. </font><font style="vertical-align: inherit;">node.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier node.tf est similaire au fichier master.tf. </font><font style="vertical-align: inherit;">Des ressources sont également créées ici, qui dans ce cas sont appelées nœud. </font><font style="vertical-align: inherit;">La seule différence est que le nœud maître est créé dans une seule instance, et le nombre de nœuds de travail créés est défini via la variable nodes_count:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "aws_instance" "node" {<font></font>
 count = "${var.nodes_count}"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier cloud-init pour les nœuds de travail exécute une seule commande - kubeadm join. </font><font style="vertical-align: inherit;">Cette commande attache la machine terminée au cluster Kubernetes à l'aide du jeton d'autorisation que nous envoyons.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lancer Terraform</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lancement, Terraform utilise plusieurs modules:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module AWS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module de modèle;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module TLS responsable de la génération des clés. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces modules doivent être installés sur la machine locale:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform init terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette commande, le répertoire dans lequel se trouvent tous les fichiers nécessaires est indiqué. </font><font style="vertical-align: inherit;">Lors de l'initialisation, Terraform télécharge tous les modules spécifiés, après quoi vous devez exécuter la commande terraform plan:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform plan -var-file terraform/vars/dev.tfvars terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter qu'en plus du répertoire avec les fichiers Terraform, le fichier var est indiqué, qui contient les valeurs des variables utilisées dans les fichiers Terraform. </font><font style="vertical-align: inherit;">Le répertoire vars peut contenir plusieurs fichiers .tfvars, ce qui vous permet de gérer différents types d'infrastructures avec un seul ensemble de fichiers Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier dev.tfvars lui-même contient les variables importantes suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_version (version installable de Kubernetes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_ami (image AMI créée par Packer). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir défini les valeurs nécessaires des variables, exécutez la commande terraform plan, après quoi Terraform présentera une liste d'actions nécessaires pour atteindre l'état décrit dans les fichiers Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir vérifié cette liste, appliquez les modifications proposées: à </font></font><br>
<br>
<code>terraform apply -auto-approve -var-file terraform/vars/dev.tfvars terraform/</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
partir de la commande terraform plan, elle se distingue par la présence d'une clé - auto-approuver, ce qui élimine la nécessité de confirmer les modifications apportées. </font><font style="vertical-align: inherit;">Vous pouvez omettre cette clé, mais chaque action devra ensuite être confirmée manuellement.</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure du cluster Kubernetes</font></font></h2><br>
<img src="https://habrastorage.org/webt/zs/i-/c3/zsi-c326-ips2acfurg_trunzhm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cluster Kubernetes se compose d'un nœud maître qui exécute des fonctions de gestion et de nœuds de travail qui exécutent les applications installées dans le cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quatre composants sont installés sur le nœud maître qui assurent le fonctionnement de ce système:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETCD, c'est-à-dire la base de données Kubernetes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serveur API, à travers lequel nous stockons des informations dans Kubernetes et en obtenons des informations;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestionnaire de contrôleur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planificateur </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux composants supplémentaires sont installés sur les nœuds de travail:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-proxy (responsable de la génération des règles de réseau dans le cluster Kubernetes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubelet (responsable de l'envoi de la commande au démon Docker pour exécuter des applications dans le cluster Kubernetes). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entre les nœuds, le plug-in de réseau Calico fonctionne.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramme de flux de travail de cluster</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/oz/ew/f3/ozewf310dnhdmnx2gg4ozhzb1rc.png"><br>
,      Kubernetes    replicaset.<br>
<br>
<ol>
<li>     API-,     ETCD.        .</li>
<li>API-      .</li>
<li>Controller-manager   API-   ,    «»,    .</li>
<li>Scheduler       .       ETCD  API-.</li>
<li>Kubelet  API-  Docker    .</li>
<li>Docker   .</li>
<li>Kubelet   API-   ,     .</li>
</ol><br>
 ,    Kubernetes  ,      .       ,           ,     YAML-.  ,   ,    API-.       .<br>
</div></div><br>
<a name="7"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm</font></font></h2><br>
<img src="https://habrastorage.org/webt/wd/sw/cu/wdswcujzvnx4ynnrbi_ec9c1gr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le dernier élément à mentionner est Kubeadm. </font><font style="vertical-align: inherit;">Le déploiement d'un nouveau cluster Kubernetes est toujours un processus minutieux. </font><font style="vertical-align: inherit;">À chaque étape, il existe des risques d'erreurs dues au facteur humain, et de nombreuses tâches sont tout simplement très routinières et longues. </font><font style="vertical-align: inherit;">Par exemple, verser des certificats pour le chiffrement TLS entre les nœuds et les maintenir à jour. </font><font style="vertical-align: inherit;">C'est là que les utilitaires pour l'automatisation de base des modèles viennent à la rescousse. </font><font style="vertical-align: inherit;">L'astuce de Kubeadm est qu'il est officiellement certifié pour fonctionner avec Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il vous permet de:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installer, configurer et exécuter tous les principaux composants du cluster</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gérer les certificats, y compris les faire pivoter et en écrire de nouveaux;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gérer les versions des composants du cluster (mise à niveau et rétrogradation). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En même temps, Kubeadm n'est pas un système de gestion de cluster Kubernetes complet, mais est une sorte de bloc de construction qui vous permet de configurer Kubernetes sur le nœud sur lequel l'utilitaire Kubeadm s'exécute. </font><font style="vertical-align: inherit;">Cela signifie qu'un système d'orchestration est nécessaire pour exécuter toutes les machines virtuelles nécessaires, les configurer et exécuter Kubeadm sur tous les nœuds. </font><font style="vertical-align: inherit;">C'est à ces fins que Terraform est utilisé.</font></font><br>
<br>
<a name="8"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Référentiel avec tous les fichiers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous mettons tous les fichiers et configurations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au même endroit, afin que cela vous soit plus pratique. </font><font style="vertical-align: inherit;">Si vous n'avez pas de cloud privé à portée de main, mais que vous souhaitez passer par toutes ces étapes vous-même et tester le déploiement dans la pratique, écrivez-nous à cloud@croc.ru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous vous donnerons une version de démonstration pour les tests et vous conseillerons sur tous les problèmes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et bientôt, il y aura un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau Slurm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où vous pourrez créer votre propre cluster. </font><font style="vertical-align: inherit;">Le code promo CROC a une remise de 10%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui travaillent déjà avec Kubernetes, il existe un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cours avancé</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La remise est la même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chers collègues, Habraparser rompt le balisage du code. </font><font style="vertical-align: inherit;">Veuillez prendre la source de GitHub à partir du lien ci-dessus.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492600/index.html">Guide semi-scientifique pour l'hébergement d'un routeur WiFi</a></li>
<li><a href="../fr492604/index.html">Utilisation de View de manière asynchrone à l'aide de coroutine</a></li>
<li><a href="../fr492606/index.html">Problèmes liés à la boîte à outils dans les grands projets</a></li>
<li><a href="../fr492608/index.html">Caractéristiques de livraison dans les grands projets</a></li>
<li><a href="../fr492612/index.html">Plafonnier décoratif Leek Celebrity</a></li>
<li><a href="../fr492628/index.html">Intervalle de confiance pour le nombre de patients atteints de coronavirus (calcul de la mortalité)</a></li>
<li><a href="../fr492632/index.html">Petites entreprises en quarantaine: la panique est l'ennemi de la raison</a></li>
<li><a href="../fr492636/index.html">Que signifie être efficace?</a></li>
<li><a href="../fr492638/index.html">Faire évoluer une application Redux avec des canards</a></li>
<li><a href="../fr492642/index.html">Créez une architecture évolutive et résiliente avec des microservices dynamiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>