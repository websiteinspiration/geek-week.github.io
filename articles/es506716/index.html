<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüî¨ üïé üï¥üèº Lista lineal multiproceso: problema de existencia de elementos, mejora de la productividad y relaci√≥n STL üôãüèø ü•á ü¶É</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola, queridos visitantes de Habr! 
 
 Este art√≠culo se centrar√° en una lista vinculada, subprocesos m√∫ltiples y C ++. Noto de inmediato que hab√≠a muc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lista lineal multiproceso: problema de existencia de elementos, mejora de la productividad y relaci√≥n STL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola, queridos visitantes de Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo se centrar√° en una lista vinculada, subprocesos m√∫ltiples y C ++. Noto de inmediato que hab√≠a muchas posibilidades de poner este trabajo en el estante y usarlo en una peque√±a cantidad de proyectos personales. En cambio, todav√≠a decid√≠ ponerlo en la cancha del p√∫blico; de repente, parece realmente √∫til o interesante para alguien. Adem√°s, si resulta que alguien ya ha logrado hacer algo como esto, ind√≠queme estos materiales, por favor. Sin embargo, no importa c√≥mo intent√© buscar en Google sobre este tema, todos los intentos no tuvieron √©xito.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n noto que esto no se tratar√° de la cl√°sica lista vinculada, sino de mi replanteamiento creativo del uso de esta estructura de datos en un entorno multiproceso. Estaba considerando un escenario de acceso a la lista de m√∫ltiples subprocesos intensivo sin orden. Esto significa que cualquier hilo en cualquier momento, independientemente de otros, puede acceder a la lista y realizar las operaciones requeridas. Si solo agrega o cambia elementos, esto no es tan malo. Si tambi√©n elimina los elementos, pueden surgir varias caracter√≠sticas interesantes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este proyecto, en el que particip√© como pasatiempo y autodesarrollo, por varias razones dur√≥ mucho tiempo. </font><font style="vertical-align: inherit;">Adem√°s, mientras trabajaba en √©l, estudi√© intensamente: el proyecto comenz√≥ sin el conocimiento y la comprensi√≥n de STL y fue dise√±ado en consecuencia, utilizando solo los medios internos del lenguaje C ++. </font><font style="vertical-align: inherit;">Sin embargo, luego lo modifiqu√© muy seriamente teniendo en cuenta STL e incluso bajo STL. </font><font style="vertical-align: inherit;">Lo que obtuve de esto, juzguen ustedes, queridos lectores.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para una comprensi√≥n m√°s completa del material descrito aqu√≠, deber√° leer los siguientes libros:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - "Dise√±o moderno en C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - "Windows a trav√©s de C / C ++, Programaci√≥n Visual C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - ‚ÄúBiblioteca est√°ndar de C ++. </font><font style="vertical-align: inherit;">Guia de referencia. </font><font style="vertical-align: inherit;">Segunda edici√≥n "o libro similar sobre STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de l√≠neas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una lista lineal es una estructura de datos bien conocida que se ha utilizado desde la √©poca del lenguaje C y antes. Su elemento es un cierto objeto en la memoria que tiene conexiones con uno o dos elementos similares vecinos: aqu√≠ hay un ejemplo para una lista doblemente vinculada:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;‚Ä¶   ‚Ä¶&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En consecuencia, la lista en s√≠ es un cierto (sub) programa que realiza manipulaciones con estos elementos. </font><font style="vertical-align: inherit;">Como regla general, se conoce un puntero al principio y, opcionalmente, al final de la lista: esto es suficiente para, a partir del primer elemento, pasar por todos sus elementos hasta el final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, estoy describiendo informaci√≥n ya bien estudiada y conocida: era un programa educativo para aquellos que desconoc√≠an por completo. </font><font style="vertical-align: inherit;">Para obtener detalles, por ejemplo, puede contactar aqu√≠: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista lineal (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La biblioteca STL tiene un contenedor tan maravilloso std :: list (lista doblemente enlazada), as√≠ como su twin - std :: forward_list (lista individualmente enlazada). </font><font style="vertical-align: inherit;">Es decir, si no est√° interesado en c√≥mo est√° organizada la lista y c√≥mo funciona en su interior, y desea usarla solo para sus tareas, los contenedores propuestos son su opci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay una cosa pero ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de subprocesos m√∫ltiples</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Repito que cuando comenc√© a analizar este tema, iba a hacer todo, confiando solo en las herramientas internas de C ++ sin ning√∫n soporte de STL. </font><font style="vertical-align: inherit;">El valor de lo que suceder√≠a ser√≠a menor si a√∫n decidiera hablar de eso aqu√≠. </font><font style="vertical-align: inherit;">Pero por otro lado, estaba completamente libre de cualquier concepto o limitaci√≥n de la biblioteca, y por lo tanto no estaba conectado por nada y buscaba enfoques con una mente abierta e independencia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, en el pasado distante, la gran mayor√≠a de las computadoras eran de un solo n√∫cleo y un solo procesador. La lista lineal era una estructura de datos relativamente simple y transparente, y trabajar con ella no caus√≥ ninguna dificultad particular. Ahora, incluso los tel√©fonos inteligentes se han convertido en multin√∫cleo. En condiciones de subprocesos m√∫ltiples, incluso una estructura tan simple como una lista vinculada es muy complicada. Garantizar el funcionamiento correcto en modo de subprocesos m√∫ltiples generalmente complica seriamente cualquier programa, este es un hecho conocido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tome un escenario abstracto de trabajo intensivo con una lista de diferentes hilos: cada uno de ellos puede agregar, eliminar, cambiar elementos, etc. en un momento completamente arbitrario. Por un lado, el trabajo con la lista en este caso debe ser principalmente seguro: si hay violaciones de datos y un comportamiento indefinido del programa, esta ser√° una soluci√≥n completamente inapropiada. Por otro lado, me gustar√≠a mucho trabajar con √©l lo m√°s r√°pido posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver el primer problema, la lista obviamente tendr√° que bloquearse de alguna manera, as√≠ como sincronizar el acceso a ella. El segundo problema, el rendimiento, se aplaza por ahora.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo solo considera el bloqueo de la lista completa por una secuencia para el acceso exclusivo de la secuencia a ella. Otras opciones parec√≠an dudosas, por ejemplo, por las siguientes razones. Supongamos que tenemos una lista doblemente vinculada y decidimos eliminar el elemento de ella. Para hacer esto, debe bloquear el nodo en s√≠, as√≠ como el anterior y el siguiente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este mismo momento, antes del inicio de la operaci√≥n, otro subproceso elimina solo, por ejemplo, el nodo anterior. Bloqueamos el eliminado y dejamos de esperar la liberaci√≥n del nodo anterior bloqueado por otro hilo. Y est√° bloqueado esperando el pr√≥ximo para √©l, es decir. nuestro nodo eliminado. Eso es, es un callej√≥n sin salida. Entonces este m√©todo no es confiable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si sus hilos no almacenan ning√∫n puntero (o iterador) a nodos espec√≠ficos, entonces la tarea se simplifica extremadamente. De hecho, solo puede hacerlo con las herramientas STL. La secuencia bloquea la lista, se refiere a cualquier elemento en ella (por ejemplo, desde el principio, desde el final o al buscar en ella seg√∫n algunos criterios), procesa o elimina este elemento, agrega cualquier elemento nuevo sin guardar enlaces, y luego completa la lista. Todo esto: bloqueo exclusivo del acceso a la lista en un subproceso, propiedad de la duraci√≥n de las operaciones requeridas. En este caso, es perfectamente l√≥gico usar std :: list y las funciones de bloqueo de la biblioteca. Por todo esto, debe tenerse en cuenta que mientras su hilo hace todo el trabajo requerido, otros hilos dejar√°n de esperar, es decir El trabajo con la lista se realizar√° en modo de subproceso √∫nico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere otro escenario m√°s complejo, cuando un hilo almacena un puntero o iterador al elemento que necesita. </font><font style="vertical-align: inherit;">Por ejemplo, su programa trabaja en algunos c√°lculos complejos, tomando los datos iniciales del elemento de la lista y luego, despu√©s del procesamiento, actualiza su valor y agrega los resultados del c√°lculo all√≠. </font><font style="vertical-align: inherit;">Sin embargo, otros hilos tambi√©n tienen acceso a la misma lista. </font><font style="vertical-align: inherit;">No hice suposiciones sobre la naturaleza de la aplicaci√≥n: otro hilo puede eliminar f√°cilmente este elemento por alguna raz√≥n. </font><font style="vertical-align: inherit;">O mu√©velo a otro lugar. </font><font style="vertical-align: inherit;">Por lo tanto, trabajar con una lista se vuelve problem√°tico no solo por las razones habituales de multihilo y sincronizaci√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema de la existencia de un elemento.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øCu√°l es la diferencia fundamental entre una lista y, por ejemplo, una matriz? En una </font><font style="vertical-align: inherit;">disposici√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distribuida</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de elementos de la lista. Todos los elementos de la matriz est√°n ubicados en un √°rea de memoria √∫nica. Incluso si almacena un puntero a algunos de sus elementos, est√° seguro de que el acceso a su direcci√≥n ser√° correcto (por supuesto, si la matriz no se movi√≥ en la memoria a otra ubicaci√≥n con una extensi√≥n de su tama√±o, por ejemplo). Si el elemento que necesita se elimina o se mueve a otro hilo, simplemente vaya a la direcci√≥n anterior, comprender√° por algunos signos que el elemento que necesita no est√° aqu√≠, luego intente buscarlo, etc. Por supuesto, el programa debe apoyar esa oportunidad de antemano. Pero, en cualquier caso, su funcionamiento seguir√° siendo correcto siempre que est√© en los l√≠mites de memoria correctos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una situaci√≥n completamente diferente es en el caso de una lista (as√≠ como en el caso de un √°rbol, gr√°fico, cualquier estructura de datos con elementos distribuidos). Si un elemento de acuerdo con su puntero se elimin√≥ en otro hilo, ni siquiera lo sabr√°, y si intenta acceder a su direcci√≥n, recibir√° una infracci√≥n de acceso (en el mejor de los casos). Incluso si no se elimina realmente de la memoria (por ejemplo, si se utilizan punteros inteligentes), se eliminar√° de la lista, es decir, No ser√° parte de ello. Tampoco sabr√°s sobre esto. El trabajo correcto con la lista est√° roto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al mismo tiempo, el trabajo intensivo de m√∫ltiples subprocesos con la lista crea escenarios absolutamente fant√°sticos. Incluso puede estar seguro de que todo est√° bien con su elemento y un puntero a √©l, hasta acceder a alguna funci√≥n de lista para trabajar con √©l.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejemplo. Deje que haya una parte de la lista, y un puntero al nodo, que denotamos como (#), se pasa a alg√∫n m√©todo de lista de funciones, mientras que los nodos asociados con √©l se denotar√°n con n√∫meros relativos relativos a √©l. En el momento en que se llama a la funci√≥n, se sabe que este elemento existe y el puntero al mismo es correcto, es decir, el estado de la lista en esta √°rea es: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, deje que el nodo (#) se pase como par√°metro a alguna funci√≥n de la lista. Esta funci√≥n, como de costumbre, est√° bloqueada mientras espera el acceso a ella. Mientras esperaba, tres hilos trabajaron antes que ella, eliminando el nodo (#) junto con los adyacentes para que sucediera: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
luego otros 5 hilos insertaron 5 elementos m√°s en la lista, comenzando con (-2). Denotamos los nuevos elementos como (nN), donde N es el n√∫mero relativo entre los cinco, comenzando desde cero:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, finalmente, se llama a nuestra secuencia, que se llam√≥ con (#). La pregunta es: ¬øqu√© deber√≠a hacer en este caso, despu√©s de todo (#) se ha ido hace mucho? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Respuesta: todo depende de la operaci√≥n, as√≠ como del escenario para usar la lista. Sin embargo, dado que estamos considerando el caso m√°s general sin restricciones, se pueden hacer algunas suposiciones generales.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se trata de una operaci√≥n de eliminaci√≥n, es suficiente simplemente verificar si el elemento especificado est√° presente en la lista. De lo contrario, ya se ha eliminado y no se necesita hacer nada m√°s. En caso afirmativo, elimine. Del mismo modo, para la operaci√≥n de leer / cambiar el contenido del nodo: si el nodo se elimina, entonces ya no hay nada que leer / modificar. Pero los mayores problemas surgen con las operaciones de insertar un nuevo nodo, as√≠ como cuando se pasa al siguiente / anterior. Por un lado, el nodo especificado ya no est√° all√≠ y se puede devolver la falla. Por otro lado, el nodo debe insertarse, y tal situaci√≥n puede ocurrir en cualquier momento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que la prioridad (para el caso general) sigue siendo la seguridad y la confiabilidad, y solo entonces la velocidad, es obvio que cuando el hilo finalmente obtuvo el tiempo de funcionamiento dentro de la funci√≥n, debe establecer el hecho de la presencia de un elemento en la lista: ¬øexiste all√≠ o no? Esto resuelve un problema: al menos no interrumpiremos la lista completa si no hay un nodo solicitado all√≠ y evitaremos errores de acceso a la memoria a este respecto. Pero no resuelve el problema de inserci√≥n y transiciones: no est√° claro d√≥nde insertar un nuevo nodo y pasar de uno ya eliminado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n al problema de la existencia del elemento se discutir√° en detalle a continuaci√≥n. </font><font style="vertical-align: inherit;">La pregunta de qu√© hacer cuando descubrimos que el elemento ya no est√° all√≠, pero realmente es necesario, est√° m√°s all√° del alcance de este art√≠culo, ya que depende completamente del algoritmo del trabajo que utiliza el programa de lista. </font><font style="vertical-align: inherit;">Por supuesto, debe incluir tales escenarios y las reacciones correspondientes a ellos: por ejemplo, si no hay ning√∫n elemento, vaya al principio de la lista o realice alguna otra operaci√≥n. </font><font style="vertical-align: inherit;">Lo principal que debe garantizarse en esta situaci√≥n es el funcionamiento correcto y seguro de la lista, as√≠ como la notificaci√≥n de tales situaciones.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√∫squeda directa de art√≠culos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El enfoque m√°s simple y directo es verificar la presencia de un elemento en la lista pas√°ndolo secuencialmente en busca de un elemento dado. Aquellos. solo buscando el elemento dado. Si √©l est√° en la lista, trabajamos con √©l. Si no, entonces, dependiendo de la funci√≥n, salimos con √©xito o fracaso, y dejamos que el programa que llama decida qu√© hacer en esta situaci√≥n. Lo principal es que el trabajo con la lista en cualquier caso ser√° correcto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este m√©todo es seguro y completamente funcional, pero, especialmente para listas grandes, conduce a una ca√≠da catastr√≥fica en el rendimiento. De hecho, trabajar con una lista resulta ser de un solo subproceso: la lista est√° bloqueada mientras dura la b√∫squeda de un elemento determinado y otros subprocesos no pueden acceder a ella. En segundo lugar, los gastos generales aumentan bruscamente, en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las operaciones con la lista tienen que verificar si hay un elemento que se necesita en el momento de la operaci√≥n, y una gran parte del tiempo se gasta no en trabajo √∫til, sino en verificar la presencia de un elemento. </font><font style="vertical-align: inherit;">Sin embargo, este enfoque simple y directo es bastante adecuado para listas de peque√±o volumen y operaciones no demasiado intensivas con √©l, as√≠ como una primera aproximaci√≥n para resolver el problema de la existencia de un elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¬øqu√© pasa si tenemos una lista con una gran cantidad de elementos y trabajamos con ella de manera muy intensiva: muchos hilos constantemente agregan, cambian y eliminan elementos de ella? </font><font style="vertical-align: inherit;">¬øHay alguna manera de acelerarlo de alguna manera?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memoria o rendimiento</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe un hecho bien conocido de que un aumento en la memoria utilizada por el programa puede aumentar la velocidad del programa. Por ejemplo, un programa hace un uso intensivo de los resultados de algunos c√°lculos. En lugar de ejecutarlos nuevamente, puede calcular todo por adelantado y guardar sus resultados en alguna tabla o matriz. Luego, el programa simplemente accede a la celda deseada en la tabla e inmediatamente recibe el valor deseado, lo que acelera significativamente su trabajo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es este enfoque el que utilic√© en el caso de la lista. Crea un mapa de bits. Agregue a la informaci√≥n de servicio de cada uno de sus elementos, adem√°s del puntero requerido al siguiente y, opcionalmente, al elemento anterior, dos campos nuevos m√°s: el primero es su n√∫mero √∫nico dentro de esta lista, y el segundo es un puntero a la lista misma. Ahora, cuando se crea un elemento, se le asigna un n√∫mero √∫nico y establece la unidad en el mapa de bits en el √≠ndice correspondiente. Cuando se elimina un elemento, este bit se restablece. El n√∫mero del elemento creado aumenta constantemente cada vez que se crea un nuevo elemento; los bits ya puestos a cero no se reutilizan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, cuando se requiere verificar la presencia de un elemento dado, en lugar de buscarlo linealmente en toda la lista, simplemente se accede a un mapa de bits mediante el √≠ndice de este elemento en √©l, y el hecho de su presencia se establece de inmediato, y por un tiempo constante, independientemente del tama√±o de la lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este m√©todo le permite alcanzar el m√°ximo rendimiento, sin embargo, tiene sus serios inconvenientes. Primero, tendr√° que asignar memoria para toda la matriz a la vez, parte de la cual puede no ser necesaria durante el programa, pero esta memoria podr√≠a usarse para otras necesidades. Este problema y una forma de suavizar los desbordamientos de memoria se analizar√°n a continuaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo inconveniente es m√°s serio e interesante: cada nuevo elemento de la lista se crea mediante un n√∫mero cada vez mayor. Esto significa que tarde o temprano los bits libres de la matriz se agotar√°n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este punto, desafortunadamente, debe detenerse, bloquear la lista y comenzar a servirla. Aquellos. comprima los bits de esta matriz, eliminando todos los bits cero de los elementos de lista intermedios previamente eliminados, dejando solo bits para los elementos que realmente existen en este momento, desplazando todos estos bits al comienzo de la matriz. Tendremos que revisar toda la lista nuevamente, y en modo de subproceso √∫nico, reescribir todos los √≠ndices para cada elemento. El beneficio obvio de esto en comparaci√≥n con el enfoque anterior es que en este caso solo </font><b><font style="vertical-align: inherit;">se</font></b><font style="vertical-align: inherit;"> har√° </font><b><font style="vertical-align: inherit;">uno</font></b><font style="vertical-align: inherit;"> .</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veces durante un largo per√≠odo de tiempo. </font><font style="vertical-align: inherit;">Adem√°s, la lista puede continuar funcionando como antes en modo extremadamente r√°pido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, no quiero decir que los nodos solo se agregaron a la lista, porque </font><font style="vertical-align: inherit;">en este caso, todos los bits de la matriz ser√°n √∫nicos. </font><font style="vertical-align: inherit;">Estoy considerando un escenario en el que los elementos se eliminan y agregan de manera intensiva y arbitraria. </font><font style="vertical-align: inherit;">Aquellos. </font><font style="vertical-align: inherit;">El n√∫mero total de elementos de la lista desde el comienzo de su trabajo puede cambiar ligeramente. </font><font style="vertical-align: inherit;">Naturalmente, la cuesti√≥n de elegir el tama√±o de la matriz depende de la naturaleza del programa. </font><font style="vertical-align: inherit;">Tambi√©n puede crear siempre una nueva matriz de un volumen mayor si el tama√±o del actual no es suficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar cero bits de elementos eliminados previamente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede hacerlo de otra manera: al crear un elemento, busque el primer bit cero desde el comienzo del mapa de bits. Esto optimiza el consumo de memoria, pero dar√° lugar a una ca√≠da en el rendimiento: ahora, una vez m√°s, cada vez que cree un nuevo elemento, tendr√° que hacer un trabajo adicional: mire a trav√©s de la matriz en busca de un bit libre. Pero en comparaci√≥n con la verificaci√≥n de la presencia de un elemento al ver directamente la lista, la ganancia es obvia: veremos la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos adyacentes, y cada elemento de dicha matriz contiene muchos bits, es decir </font><font style="vertical-align: inherit;">procesamos muchos nodos de lista a la vez (64 bits para sistemas modernos o incluso 128/256/512 si se usa SSE / AVX). </font><font style="vertical-align: inherit;">Estamos buscando la primera palabra que no es igual a la palabra con todos los bits unitarios, luego estamos buscando el primer bit cero en esta palabra. </font><font style="vertical-align: inherit;">De hecho, este m√©todo tiene una velocidad intermedia entre el anterior y el m√©todo de visualizaci√≥n directa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaci√≥n del consumo de memoria para bits de matriz desocupados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que asumimos un trabajo largo e intensivo con la lista, asignando una gran variedad de bits para ello. Pero sucedi√≥ que, de hecho, el programa funcion√≥ de manera diferente: raramente acced√≠a a la lista, realizaba otras operaciones que tambi√©n requer√≠an memoria. Como resultado, obtenemos una variedad casi inusitada de bits de gran volumen y problemas de memoria en otras partes del programa. ¬°Puro inconveniente! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux, por lo que puedo decir, resuelve autom√°ticamente este problema (aunque los desarrolladores experimentados de Linux me permiten solucionarlo, si es as√≠). Usted asigna memoria para la matriz, pero de hecho el sistema </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no transfiere</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esta memoria a la matriz </font><font style="vertical-align: inherit;">hasta que realmente se necesita. Hay una optimizaci√≥n del uso de la memoria. Windows no permite esto. M√°s bien, lo permite, pero tienes que hacerlo t√∫ mismo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aquellos que no est√°n actualizados, les explicar√©: su aplicaci√≥n (m√°s precisamente, el proceso correspondiente), el sistema asigna un </font><font style="vertical-align: inherit;">gran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espacio de direcciones virtuales</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , hasta 8 TB para Windows de 64 bits. La memoria f√≠sica en el sistema puede ser mucho menor: 8 o 16 GB en este momento para computadoras masivas. </font><b><font style="vertical-align: inherit;">Pantallas del</font></b><font style="vertical-align: inherit;"> sistema operativo</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direcciones de su espacio de proceso virtual a direcciones de memoria f√≠sica, haciendo esto de manera transparente sin su participaci√≥n directa. Naturalmente, la mayor parte de la memoria virtual libre de un proceso generalmente est√° desocupada. Entonces, cuando le pide a Windows que asigne memoria por medios convencionales, simult√°neamente asigna esta memoria tanto en su espacio virtual como en la memoria f√≠sica. Si asigna un mapa de bits de gran volumen, corre el riesgo de ocupar inmediatamente toda la memoria disponible en su m√°quina sin garantizar que esta memoria sea necesaria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, uno puede actuar de manera diferente: marque una gran parte de la memoria en el espacio virtual del proceso, pero transfi√©ralo f√≠sicamente solo cuando sea realmente necesario. </font><font style="vertical-align: inherit;">Esto se puede hacer a trav√©s del manejo de excepciones estructurales en Windows, para m√°s detalles, consulte el libro de Richter D., Nazar K. - "Windows a trav√©s de C / C ++, Programaci√≥n Visual C ++".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto ser√≠a solo una idea y una teor√≠a, si no hubiera puesto en pr√°ctica todas estas ideas, y no en la forma de un simple programa experimental: lo hice con el mayor cuidado posible para la producci√≥n, con la intenci√≥n de usarlo en mis proyectos reales, por lo tanto, es en esta forma que lo necesita. e imagina. </font><font style="vertical-align: inherit;">Pens√© que ser√≠a injusto y demasiado ego√≠sta aplicar lo que se hizo en mi limitado n√∫mero de proyectos si esto pudiera ser √∫til o al menos simplemente interesante para un amplio c√≠rculo de desarrolladores. </font><font style="vertical-align: inherit;">Por otro lado, los creadores de la biblioteca Boost y otras bibliotecas m√°s especializadas ofrecen su trabajo a todos absolutamente gratis. </font><font style="vertical-align: inherit;">¬øPor qu√© no puedo hacer lo mismo?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstracci√≥n: una lista sin datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Divid√≠ la lista en dos niveles l√≥gicos. El primer nivel es una lista, cada elemento del cual no contiene ning√∫n dato √∫til, pero contiene solo informaci√≥n auxiliar: punteros a elementos vecinos y, opcionalmente, esos dos campos adicionales para acelerar la verificaci√≥n de la presencia de un elemento en la lista. Sin embargo, ya en este nivel es posible realizar todas las operaciones b√°sicas en una lista: agregar y eliminar elementos, dividir y fusionar listas, etc. De hecho, me enfoqu√© principalmente en este nivel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo nivel es agregar datos reales al elemento de la lista, as√≠ como agregar nuevas operaciones a la lista para trabajar con estos datos. Todo esto se proporciona en C ++ por herencia. Pero los detalles se discutir√°n a continuaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal desglose de la implementaci√≥n en dos niveles ten√≠a sentido: ¬øpor qu√© tener en cuenta la disponibilidad de datos espec√≠ficos si una serie de operaciones son completamente independientes de estos datos? Para cualquier elemento de la lista, a√∫n debe eliminarlos y agregar otros nuevos a la lista, as√≠ como realizar otras operaciones t√≠picas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenc√© con un concepto extremadamente simple y sin complicaciones, tomado de la construcci√≥n del lenguaje C al comienzo del art√≠culo. Ambos punteros internos C y C ++ se usan tanto dentro como fuera de la lista. La √∫nica diferencia fue que la adici√≥n de datos, como se indic√≥ anteriormente, se pospuso para una fecha posterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deje que haya un elemento de la lista sin datos, que contenga solo un puntero (o punteros) a los elementos vecinos. Luego, el c√≥digo correspondiente puede representarse esquem√°ticamente de la siguiente manera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;‚Ä¶m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un elemento para una lista vinculada individualmente contiene dentro de s√≠ mismo un puntero al siguiente elemento, y nada m√°s. La clase de lista se parametriza por el tipo de este elemento, lo que implica que este tipo se cambiar√° en la etapa de agregar datos. Contiene punteros al primer y √∫ltimo elemento dentro. Como originalmente apunt√© a este proyecto solo para Windows, tambi√©n se incluye una secci√≥n cr√≠tica como SRWLock para bloquear la lista. A continuaci√≥n, se definen los constructores, el destructor, as√≠ como todas las funciones necesarias para trabajar con la lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta implementaci√≥n contiene dos problemas a la vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero es el acceso abierto al contenido de la informaci√≥n de servicio del elemento. Esto significa que, habiendo obtenido acceso a alg√∫n nodo, es decir teniendo un puntero a este nodo, podemos referirnos directamente al elemento siguiente o anterior.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es inaceptable principalmente porque esta transici√≥n est√° pasando por alto el bloqueo y, por lo tanto, protegiendo la lista. De hecho, suponga que al tener un puntero a alg√∫n elemento pCurr, guardamos el valor en el siguiente elemento relativo a √©l en el puntero pNext de la siguiente manera: pNext = pCurr-&gt; pNext. Despu√©s de eso, realizamos una operaci√≥n larga en este nodo pCurr. Al mismo tiempo, otros hilos eliminaron los siguientes elementos de la lista con respecto a pCurr. Despu√©s de terminar de trabajar con pCurr, el subproceso actual se mueve al siguiente elemento usando el valor anterior almacenado en el pNext local y recibe un error de acceso o un comportamiento indefinido, ya que el elemento en la direcci√≥n local de pNext ya no existe y necesita acceder al valor actualizado pCurr-&gt; pNext, si el elemento actual en pCurr, a su vez,Tambi√©n todav√≠a existe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De este ejemplo se pueden sacar dos conclusiones para prevenir esta situaci√≥n:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde fuera de la lista, vaya al nodo siguiente / anterior y generalmente haga cualquier trabajo con elementos de la lista solo a trav√©s de funciones (m√©todos) de la clase de lista que bloquean la lista y hacen que el acceso a la lista sea seguro;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceda a los elementos lo antes posible inmediatamente antes de acceder a ellos (por ejemplo, obtenga un puntero al siguiente elemento pNext = list.GetNext (pCurr) no por adelantado, sino inmediatamente antes de que aparezca la necesidad de pasar al siguiente nodo).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es por eso que para implementar la conclusi√≥n del primer p√°rrafo, debe prohibirse el acceso a los punteros a elementos adyacentes desde el exterior:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo problema es un poco m√°s delicado. Para entenderlo, la estructura de clases deber√≠a describirse con m√°s detalle. La clase de lista se define como plantilla y no funciona con elementos del tipo ListElement_OneLinked, sino con el tipo ListElement, que se pasa como un par√°metro de plantilla. Esto se hace para poder crear nuevos nodos con datos dentro de la clase. Para hacer esto, necesita saber el tipo exacto de nodo que se est√° creando. Todav√≠a no se conoce el tipo exacto del nodo de la lista: se determinar√° m√°s adelante junto con los datos. La funci√≥n de creaci√≥n de elementos le asigna memoria, inicializa punteros y luego devuelve un puntero al elemento creado en la funci√≥n de llamada. Entonces, en la funci√≥n de llamada de la clase derivada, ser√° posible inicializar otras propiedades del elemento que son espec√≠ficas de esta clase y que luego se definen. En otras palabras,Una definici√≥n exacta del tipo de nodo de la lista se deja para el futuro, y para que la lista funcione correctamente, solo es importante que sus elementos contengan el puntero pNext, el resto no importa hasta ahora.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, basado en ListElement_OneLinked, posteriormente por herencia, se crear√° una nueva clase para el elemento con datos espec√≠ficos y se pasar√° a la clase List_OneLinked a trav√©s del par√°metro de plantilla. Al mismo tiempo, se crear√° una nueva clase derivada basada en List_OneLinked que define a√∫n m√°s las operaciones con estos nuevos datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, incluso esta opci√≥n no es del todo correcta. En versiones anteriores de la clase de lista, se us√≥ varias veces una operaci√≥n de conversi√≥n expl√≠cita del tipo reinterpret_cast &lt;ListElement *&gt; (...). El hecho es que la clase de plantilla funciona con el tipo de par√°metro de plantilla ListElement, que se deriva de ListElement_OneLinked / ListElement_TwoLinked. Y en las funciones de clase, las variables se crean en expresiones del tipo: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y pCurr-&gt; pNext aqu√≠ es un puntero a ListElement_OneLinked / ListElement_TwoLinked, como miembros de las clases base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salida: declare una variable que indique el tipo base expl√≠cito ListElement_OneLinked / ListElement_TwoLinked, o bien, vu√©lvala al tipo derivado expl√≠citamente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, incluso una definici√≥n expl√≠cita del tipo base no es correcta, por ejemplo, en la funci√≥n de eliminaci√≥n (limpieza) de la lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cambia el tipo de punteros:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
esto significar√° que ser√°n eliminados por la operaci√≥n</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
solo las partes base de cada nodo en la lista, lo cual est√° mal. </font><font style="vertical-align: inherit;">O, como opci√≥n, el puntero pCurr deber√° convertirse a su tipo derivado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, en cualquier caso, uno no puede deshacerse de la transformaci√≥n expl√≠cita reinterpret_cast con dicha estructura de clase, que no es la mejor soluci√≥n (m√°s precisamente, lo que es realmente malo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por esta raz√≥n, para deshacerse de tales transformaciones expl√≠citas, se decidi√≥ cambiar la clase base para el elemento (para una lista doblemente vinculada, de manera similar):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brevemente, esto se puede describir de la siguiente manera: el elemento b√°sico de la lista contiene un puntero a otro elemento, pero el tipo de este puntero a√∫n no se conoce, porque lo pasa el par√°metro de plantilla (se deja una definici√≥n exacta de este tipo para el futuro). En otras palabras: en esta etapa, el tipo de nodo de lista (es decir, cu√°l ser√° al final) a√∫n no se ha determinado, se determinar√° m√°s adelante. Pero ahora mantenemos el puntero a un elemento del futuro, tipo a√∫n no conocido. El tipo resultante del nodo de lista se pasa aqu√≠ como un par√°metro de plantilla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, no se necesitan conversiones, ya que los punteros del mismo tipo ListElement se usan en todas partes, tanto en la clase de lista como en la clase de nodos. El ListElement aqu√≠ y en la clase de lista es la clase final para el elemento con datos espec√≠ficos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que ahora la clase de lista se ha vuelto lo m√°s abstracta posible a partir de su contenido espec√≠fico: solo se sabe que sus nodos contienen punteros a otros nodos y, utilizando esta informaci√≥n, todas las operaciones b√°sicas en ellos con el bloqueo de subprocesos m√∫ltiples correspondiente se realizan en la clase de lista.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolver el problema de la existencia de un elemento: una b√∫squeda simple (versi√≥n 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera versi√≥n fue extremadamente simple y directa y no fue m√°s all√° del marco descrito anteriormente. </font><font style="vertical-align: inherit;">Se utilizaron punteros internos de C ++, se asign√≥ memoria para elementos mediante la nueva operaci√≥n y se elimin√≥ mediante eliminar, la lista se bloque√≥ en la secci√≥n cr√≠tica contenida en ella. </font><font style="vertical-align: inherit;">No sab√≠a ni sospechaba sobre los medios de la biblioteca STL, y tambi√©n sobre el nivel al que traen la programaci√≥n en C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya en esta etapa, en la pr√°ctica, me encontr√© con el problema de la existencia de un elemento descrito anteriormente y me di cuenta de que simplemente bloquear la lista no es suficiente. </font><font style="vertical-align: inherit;">Navegu√© por la lista usando las funciones apropiadas con todas las precauciones, la lista fue bloqueada correctamente, pero el programa todav√≠a se bloque√≥ con √©xito a diferentes intervalos. </font><font style="vertical-align: inherit;">Fue entonces cuando descubr√≠ que habr√≠a que verificar la presencia de un elemento, lo que condujo a un cambio en la l√≥gica de las funciones clave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perm√≠tanme dar un ejemplo de la funci√≥n de agregar un elemento despu√©s de uno dado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ve que antes de crear un nuevo elemento, verifica si el elemento especificado est√° presente en la lista llamando a la funci√≥n FindElement (...):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mayor complicaci√≥n de las clases de lista multiproceso - clases de estrategia (versi√≥n 18.02.2019, 27.11.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, el proyecto estaba dirigido estrictamente a Windows. Pero en alg√∫n momento pens√©, ¬øpor qu√© no agregarle flexibilidad? ¬øPor qu√© solo ventanas? Despu√©s de todo, la lista se implement√≥ esencialmente en C ++ puro, desde Windows solo ten√≠a una cosa: la secci√≥n cr√≠tica de SRWLock. Para entonces, ya me hab√≠a familiarizado con el concepto de clases de estrategia. Puede leer sobre esto en detalle en el libro Alexandrescu A. - "Dise√±o moderno en C ++". Describe muchas cosas inusuales y sorprendentes que pueden ser √∫tiles incluso ahora, a pesar de que el libro ya tiene 12 a√±os. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de ellas son las clases de estrategias. Las clases de estrategias, de hecho, son cambios en el comportamiento de una clase a trav√©s de plantillas, como B. Straustrup mencion√≥ en su famoso libro. Solo en el libro de Alexandrescu, este tema se divulga ampliamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponga que su clase realiza una acci√≥n espec√≠fica. </font><font style="vertical-align: inherit;">Puede tomar la definici√≥n de esta acci√≥n fuera de la clase, crear una clase separada basada en esta acci√≥n y pasarla a su clase de origen como un par√°metro de plantilla. </font><font style="vertical-align: inherit;">Esto complica el c√≥digo, su lectura y comprensi√≥n, pero agrega significativamente flexibilidad a su clase: para reemplazar esta acci√≥n particular con otra similar, solo necesita escribir otra estrategia similar y pasarla a su clase como un par√°metro de plantilla. </font><font style="vertical-align: inherit;">El resto del trabajo lo realizar√° el compilador.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrategia de bloqueo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicando esto a la lista descrita, tom√© el bloqueo a trav√©s de SRWLock en una estrategia separada, y luego escrib√≠ varias otras estrategias: a trav√©s de la secci√≥n cr√≠tica habitual de Windows, a trav√©s de mutexes STL de C ++, etc. </font><font style="vertical-align: inherit;">Entonces ser√° posible agregar m√©todos puramente espec√≠ficos de Linux. </font><font style="vertical-align: inherit;">Por lo tanto, la clase se ha vuelto adecuada no solo para Windows, sino que siempre puedo reconfigurarla r√°pidamente para Windows de una manera √≥ptima, simplemente especificando la estrategia deseada.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrategia de memoria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alrededor de este punto, tambi√©n comenc√© seriamente a estudiar STL y entre las primeras herramientas de esta biblioteca me familiaric√© con los punteros inteligentes. </font><font style="vertical-align: inherit;">Y luego pens√©: ¬øpor qu√© no puedo agregar soporte de puntero inteligente a mi lista? </font><font style="vertical-align: inherit;">Luego elimin√© el tipo de puntero, as√≠ como tambi√©n cre√© y elimin√© los datos del elemento de la lista en una estrategia separada:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una estrategia similar para punteros inteligentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La estrategia de memoria toma tres par√°metros: el tipo del objeto Type, as√≠ como tambi√©n un asignador y eliminador de memoria. Seg√∫n el tipo de objeto, la estrategia crea un tipo de puntero a este tipo, ya sea Type * o std :: shared_ptr, seg√∫n la estrategia, y tambi√©n ofrece las funciones correspondientes para crear y eliminar el objeto. Estas funciones, si hablamos de distribuidores y deletors por defecto, crean un objeto mediante la nueva operaci√≥n Type o mediante la funci√≥n std :: make_shared (...). Todo esto funciona debido al hecho de que la desreferenciaci√≥n del puntero es la misma tanto para el puntero incorporado C ++ como para el std :: shared_ptr inteligente. Por supuesto, en el caso de una lista doblemente enlazada y punteros inteligentes, para evitar la caracter√≠stica desagradable de los punteros en bucle, std :: weak_ptr se usa para punteros al elemento anterior,y en tiempo de compilaci√≥n para una lista doblemente vinculada, dependiendo de la estrategia de memoria seleccionada, usted elige c√≥mo desreferenciarla (esta es una nueva caracter√≠stica de C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, ahora la lista no crea sus propios elementos: redirige la llamada a la estrategia correspondiente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrategia de disponibilidad de art√≠culos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, hice una soluci√≥n al problema de la existencia de un elemento en una estrategia separada: si la lista necesita verificar la presencia de algunos de sus elementos, simplemente redirige la llamada a la estrategia correspondiente. El primer enfoque directo y torpe se ha convertido en una estrategia de b√∫squeda directa de DirectSearch. A continuaci√≥n, desarroll√© dos estrategias m√°s basadas en los dos enfoques descritos anteriormente con un mapa de bits en el orden de su descripci√≥n: SearchByIndex_BitArray y SearchByIndex_BitArray2. Para Windows, para la posibilidad de ocupar gradualmente la memoria con un mapa de bits a medida que se llena, tambi√©n agreg√≥ dos estrategias m√°s: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal y SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se se√±al√≥ anteriormente, para que estas estrategias avanzadas funcionen, el elemento de la lista debe contener un √≠ndice en un mapa de bits y un puntero a la clase base de la lista (ver m√°s abajo), es decir. </font><font style="vertical-align: inherit;">se defini√≥ de la siguiente manera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlaci√≥n entre estrategias de memoria y estrategias de verificaci√≥n de elementos.</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tras un examen detallado, result√≥ que existe una trampa en la relaci√≥n entre las estrategias de memoria y las estrategias para verificar la presencia de un elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponga que usa punteros inteligentes como estrategia de memoria, as√≠ como una estrategia que usa un mapa de bits para verificar r√°pidamente un elemento en una lista. Si elimina un elemento, la estrategia de memoria restablece su puntero. Sin embargo, este elemento no se elimina realmente de la memoria, ya que tiene otro puntero inteligente en su programa de llamada. En el futuro, recurre a la lista con este elemento, y realiza la verificaci√≥n correctamente, haciendo referencia a sus datos: el √≠ndice en el mapa de bits y el puntero a la lista. En realidad, un elemento se elimina de la memoria solo cuando ya no hay ning√∫n enlace.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este no es el caso cuando se utilizan punteros integrados en C ++. En este caso, la estrategia de la memoria </font><font style="vertical-align: inherit;">ser√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eliminar este elemento de la memoria utilizando la operaci√≥n de eliminaci√≥n. En el futuro, usted, como en el caso anterior, se refiere a la lista con este elemento, e intentar√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al elemento en esta direcci√≥n para leer el √≠ndice del mapa de bits y un puntero a la lista. Pero no puede hacer esto: ¬°un elemento ya se ha eliminado de la memoria! En el mejor de los casos, recibir√° una infracci√≥n de acceso, en el peor comportamiento indefinido, cuando la biblioteca de C ++, la biblioteca de tiempo de ejecuci√≥n o simplemente el sistema operativo escribe all√≠ un valor completamente arbitrario que la lista considera e intenta establecer a partir de ellos el hecho de la presencia de un elemento en la lista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, resulta que los punteros internos son compatibles solo con la estrategia de verificaci√≥n directa de DirectSearch, y los punteros inteligentes en este caso ofrecen no solo su seguridad inherente, sino tambi√©n un aumento del rendimiento: solo con su uso pueden usarse matrices de bits que aumentan significativamente el trabajo de la lista en modo multiproceso! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantizar la coherencia y eliminar configuraciones de estrategia incompatibles, inclu√≠ la siguiente verificaci√≥n en cada clase de lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compara las clases de estrategia pasadas a la lista y, si son incompatibles, detiene la compilaci√≥n con la salida del mensaje de error correspondiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excepciones o devoluciones de error</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, el manejo de errores de la lista se realiz√≥ solo a trav√©s de excepciones. </font><font style="vertical-align: inherit;">Pero de alguna manera, en alg√∫n foro que no recuerdo, le√≠ que las excepciones ralentizan el programa, y ‚Äã‚Äãpara obtener el m√°ximo rendimiento, debe usar el retorno de error tradicional. </font><font style="vertical-align: inherit;">Lo hizo creando dos nuevas clases basadas en las originales, solo reescribi√©ndolas para devolver errores.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de clase base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementaci√≥n de las estrategias anteriores para verificar la presencia de elementos ha revelado un problema importante. El elemento de la lista, como recordamos, contiene, adem√°s del n√∫mero √∫nico en esta lista, tambi√©n un puntero a esta lista: despu√©s de todo, podemos tener dos o m√°s listas en el programa, cada una de las cuales contiene su propia matriz de bits para la presencia del elemento. ¬øC√≥mo asegurarse de que este elemento pertenece a esta lista en particular y no a otra? Solo almacenando un puntero a la lista completa dentro de cada elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema es que ahora, al agregar una variedad de estrategias a nuestra clase de lista, hemos complicado significativamente su </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Supongamos que tenemos dos listas diferentes con el mismo tipo de elemento y las mismas estrategias de memoria, pero con diferentes estrategias para bloquear y verificar la presencia de elementos en ellas. Para el compilador, estos ser√°n dos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferentes </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> listas. ¬øPuntero a qu√© tipo almacenar en el elemento? Adem√°s, la clase para el elemento no sabe de antemano qu√© estrategia se aplicar√°, debe tener en cuenta </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ellas </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde tambi√©n que la estrategia de bloqueo, la estrategia para verificar la presencia de un elemento e incluso la conectividad (simplemente conectada o doblemente conectada) de la lista se refieren solo al comportamiento de la lista en s√≠, pero de ninguna manera se relacionan con los </font><b><font style="vertical-align: inherit;">datos</font></b><font style="vertical-align: inherit;"> que almacena</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¬°Pero nosotros, como usuarios finales de esta clase, estamos interesados ‚Äã‚Äãen los datos! </font><font style="vertical-align: inherit;">Entonces, por un lado, usando las clases de estrategias, agregamos flexibilidad a nosotros mismos y, por otro lado, complicamos nuestras vidas y agregamos problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øEs posible de alguna manera hacer que los lobos se llenen y las ovejas est√©n a salvo? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lata. </font><font style="vertical-align: inherit;">Puede inferir punteros a datos de una clase (es decir, de un tipo) de una lista. </font><font style="vertical-align: inherit;">Adem√°s de los dos niveles de organizaci√≥n de la lista indicados anteriormente, apareci√≥ uno m√°s: cero:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora porque </font><font style="vertical-align: inherit;">Las clases reales de listas se heredan de √©l, si queremos acceder a los datos de la lista independientemente de su tipo real, debemos referirnos a su clase base ListBase. </font><font style="vertical-align: inherit;">Tenemos acceso al principio y al final de la lista, y luego trabajamos con sus datos como queramos. </font><font style="vertical-align: inherit;">El tipo espec√≠fico de lista, as√≠ como la combinaci√≥n de estrategias utilizadas en ella, no importa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteradores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya en plena marcha trabajando estrechamente con STL en un proyecto real (no el m√≠o :)), adem√°s de continuar estudi√°ndolo en libros, llam√© la atenci√≥n sobre el ciclo for en la colecci√≥n. </font><font style="vertical-align: inherit;">Despu√©s de todo, este ciclo no es solo parte del STL, ya se ha convertido en una parte interna del lenguaje. </font><font style="vertical-align: inherit;">Pens√© que tambi√©n podr√≠a agregarle soporte en mi proyecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, debe agregar soporte para iteradores, abstraerse de la forma espec√≠fica de trabajar con punteros y navegar a trav√©s de la lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo de iterador:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora es posible escribir de la siguiente manera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(‚Ä¶)<font></font>
{<font></font>
      ‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue tiene un tipo de puntero a un elemento de la lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, inclu√≠ soporte de iterador solo en listas compatibles con excepciones. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raz√≥n era simple: dado que el c√≥digo dentro del bucle no est√° disponible, no es posible manejar correctamente los errores. </font><font style="vertical-align: inherit;">Todo lo que queda es manejar las excepciones envolviendo el bucle en un bloque de prueba. </font><font style="vertical-align: inherit;">En general, recorrer la lista de tal manera que otros hilos trabajen intensamente con ella no es una buena idea: es mejor bloquear la lista usted mismo y luego pasar tranquilamente por ella en modo de subproceso √∫nico. </font><font style="vertical-align: inherit;">Pero a√∫n as√≠, si por alguna raz√≥n desea hacer exactamente lo mismo que en el ejemplo anterior, ahora hay una oportunidad para esto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una generalizaci√≥n de la estrategia para verificar la presencia de un elemento en un contenedor arbitrario; </font><font style="vertical-align: inherit;">iteradores para listas sin excepciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, originalmente plane√© (y a√∫n planifico) hacer no solo una lista multiproceso, sino tambi√©n un √°rbol. Para algunas de sus necesidades. El gr√°fico tambi√©n es posible, pero en primer lugar, no lo necesitaba, y en segundo lugar, el gr√°fico es algo complicado con algoritmos muy triviales, y no quer√≠a sumergirme en √©l sin ninguna necesidad especial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la versi√≥n inicial, la estrategia para verificar la presencia de un elemento estaba orientada solo a la lista, y sus funciones aceptaban un puntero a un elemento y un puntero a la clase base de la lista (ListBase *). Posteriormente, pens√©: ¬°pero en el caso de un √°rbol, tienes que hacer exactamente lo mismo! ¬øHacer una estrategia separada, pero esencialmente la misma?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n fue simple: ignorar la lista. </font><font style="vertical-align: inherit;">Esto significaba que ahora la entrada ser√≠a recibida no por punteros a elementos, sino por iteradores. </font><font style="vertical-align: inherit;">Y las funciones se convertir√°n en repeticiones para aceptar punteros a un contenedor de cualquier tipo adecuado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ahora la funci√≥n original, por ejemplo, registrar una lista en un mapa de bits</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Convertido en una funci√≥n de registro de contenedores:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La transici√≥n a trav√©s de la lista por punteros se transform√≥ en una transici√≥n a trav√©s de un contenedor abstracto utilizando iteradores. </font><font style="vertical-align: inherit;">Ahora ser√° suficiente para que el √°rbol implemente sus iteradores, y su soporte con estas estrategias ya se proporcionar√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto requer√≠a regresar iteradores a las listas sin excepciones, pero haci√©ndolos inaccesibles desde el exterior y destinados solo para uso interno.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptador de datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de haber trabajado bastante intensamente con STL, adem√°s de escribir, lanzar y estudiar programas de capacitaci√≥n de libros, llam√© la atenci√≥n sobre la simplicidad de trabajar con contenedores STL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, preste atenci√≥n al siguiente c√≥digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo un vector pas√°ndole el tipo int que necesito, ¬°y eso es todo! El contenedor est√° inmediatamente listo para funcionar, si no necesito cambiar algunos par√°metros adicionales que est√°n configurados de manera predeterminada, ¬°lo que a menudo no sucede! Para m√≠, procediendo de la organizaci√≥n de tres niveles de la lista, en cada caso tendr√≠a que crear primero una nueva clase para el elemento y luego escribir una clase para la lista con datos, implementando operaciones espec√≠ficas para la lista final. ¬°Imagina cu√°nto trabajo! Y si necesita crear otra lista para otros datos, debe hacerlo de nuevo o, en casos extremos, copiar el c√≥digo anterior, cambi√°ndolo ligeramente. Esto ya se parece al mismo alboroto con el lenguaje C y la API de Windows, donde para cada acci√≥n elemental debe completar todos los datos necesarios para la estructura y luego llamar a la funci√≥n deseada. Y o tenlo todo en mente¬°O tambi√©n lea constantemente MSDN, estudiando argumentos de cada nueva funci√≥n! ¬°Rutina y terriblemente inc√≥moda!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenc√© a buscar formas de tener la oportunidad de crear mi lista por analog√≠a con contenedores STL para no tener que hacer la misma tarea cada vez: crear una clase separada para cualquier elemento nuevo, y luego una clase de lista separada para trabajar con elementos de este tipo. </font><font style="vertical-align: inherit;">Entonces hab√≠a un adaptador para una lista con datos de datos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un adaptador para una lista con datos es una clase, en los par√°metros de plantilla de los cuales pasa inmediatamente el tipo de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que necesita </font><font style="vertical-align: inherit;">, y no el elemento. </font><font style="vertical-align: inherit;">El tipo de elemento, que llam√© el tipo compuesto del elemento, sobre la base de estos datos que crea por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√≠ solo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un punto aparte que vale la pena mencionar es el acceso a los datos del elemento. </font><font style="vertical-align: inherit;">El tipo de elemento contiene la operaci√≥n "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que si hay un puntero al elemento pElement, para acceder a los datos almacenados en √©l, se debe desreferenciar dos veces:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez, para acceder a un objeto de tipo ListElementCompound_OneLinked por su puntero: ListElementCompound_OneLinked &amp; le = * pCurrElement, y una segunda vez, para acceder a los datos a trav√©s de la operaci√≥n '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece muy extra√±o y at√≠pico, pero se supone que no funcionar√° a trav√©s de punteros (para esto, la versi√≥n inicial ya estaba lista), sino a trav√©s de iteradores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, al crear una lista basada en el adaptador, especifique las estrategias que necesita, como era antes. </font><font style="vertical-align: inherit;">Seg√∫n todos sus par√°metros, el adaptador crea autom√°ticamente los tipos necesarios y los pasa a la lista interna base, de la que se hereda. </font><font style="vertical-align: inherit;">Definici√≥n general de clase:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Especializaci√≥n para la lista con excepciones:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ve muy voluminoso, de varios pisos y feo. Lo s√©. Pero entonces esta definici√≥n autom√°ticamente hace todo lo que se necesita, sin la participaci√≥n directa del programador que planea usarla. Con la ayuda de std :: conditional_t ‚Äã‚Äãy std :: is_same_v, la estrategia de verificar la presencia de un elemento que envi√≥ se compara con las estrategias de b√∫squeda directa y, seg√∫n el resultado, se selecciona el tipo correspondiente del elemento de lista: con un √≠ndice en el mapa de bits y un puntero a la lista o sin . Esto le ahorrar√° memoria debido a datos adicionales innecesarios dentro de cada nodo si utiliza una estrategia de b√∫squeda directa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro de la clase, solo se implementan los iteradores espec√≠ficos, as√≠ como las funciones push_back () / push_front () requeridas por analog√≠a con STL, que redirigen las llamadas a la lista de subprocesos m√∫ltiples. </font><font style="vertical-align: inherit;">Puede agregar otras funciones m√°s adelante, para que la lista se vuelva muy similar a la de las STL. </font><font style="vertical-align: inherit;">Pero, al mismo tiempo, contar√° con todas las protecciones y opciones necesarias para aumentar la productividad en un entorno multiproceso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabajar con un adaptador de datos comenz√≥ a verse as√≠. </font><font style="vertical-align: inherit;">Crear objetos de lista:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si est√° satisfecho con todas las estrategias y par√°metros predeterminados, crear una lista se vuelve muy breve:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, externamente no hay absolutamente ninguna diferencia en comparaci√≥n con los STL, excepto que el nombre de la clase de lista es diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora puede trabajar con √©l como antes, a trav√©s de las funciones de la clase base:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠, los n√∫meros del 0 al 3 se agregan secuencialmente al final de la lista.Para llegar al argumento pasado al constructor del tipo creado cuando se crea, debe anotar expl√≠citamente los valores de los primeros tres argumentos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√≠, hay un cierto inconveniente en indicar expl√≠citamente el tipo, pero esto es consecuencia de un intento de acceder a la lista nuevamente a trav√©s de la funci√≥n anterior para trabajar con punteros. </font><font style="vertical-align: inherit;">Si agrega la funci√≥n back () al adaptador, que devuelve un iterador, trabajar a trav√©s de √©l no tendr√° ese problema:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de ajustar los iteradores a los requisitos de STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
es posible usar la lista en algoritmos de biblioteca:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
‚Ä¶<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, tendr√° que organizar la intercepci√≥n y el manejo de excepciones: todos los ejemplos anteriores son para trabajar en un hilo para probar la compatibilidad con STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso de algoritmos STL hace posible un punto interesante: puede usar varios algoritmos a la vez, ejecut√°ndolos en varios hilos en paralelo. Esto no puede hacerse por medios convencionales (por ejemplo, usando std :: list y medios de bloqueo) sin tener acceso a los contenidos internos de la clase list. Solo fue posible bloquear la lista completa durante todo el algoritmo. Por supuesto, esto acelerar√° el trabajo para el hilo que ejecuta el algoritmo, pero har√° que la lista sea inaccesible para otros hilos. Sin embargo, si aplica el mismo bloqueo SRWLock "delgado", puede ejecutar varios algoritmos en la lista al mismo tiempo, si no modifican esta lista. Pero el primer hilo para escribir se mantendr√° en espera de que todos los otros hilos completen la operaci√≥n de lectura de la lista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La opci√≥n de lista propuesta le permite organizar el trabajo con m√°s flexibilidad. </font><font style="vertical-align: inherit;">Por ejemplo, puede organizar el trabajo con una lista de tal manera que ejecute algoritmos no modificadores en la primera mitad de la lista por varios hilos al mismo tiempo, mientras que otros hilos pueden agregar o cambiar algo en la segunda mitad de la lista. </font><font style="vertical-align: inherit;">El hecho de que la lista est√© bloqueada durante la duraci√≥n de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operaci√≥n, y no el algoritmo completo, permitir√° la "escritura" de las operaciones de escritura a trav√©s de la secuencia de operaciones de lectura de la lista, lo que har√° que trabajar con ella sea m√°s flexible, productivo y eficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinando dos variantes de clases de lista con y sin excepci√≥n soporte en una con un par√°metro booleano</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, las listas eran solo con excepciones. </font><font style="vertical-align: inherit;">Luego agregu√© nuevos, sin excepciones de devoluci√≥n de errores, y cambi√© el nombre de los antiguos con la adici√≥n de la letra "E" en el nombre de la clase: List_OneLinked_E y List_TwoLinked_E. </font><font style="vertical-align: inherit;">Esto requer√≠a indicar cuatro declaraciones de la clase de lista en todas partes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces decid√≠ que era inconveniente por muchas razones. </font><font style="vertical-align: inherit;">¬øPor qu√© necesitamos dos clases completamente diferentes si esta es la misma lista con o sin soporte de excepci√≥n? </font><font style="vertical-align: inherit;">Combin√© ambas listas de cada tipo en una sola clase con un par√°metro booleano adicional, y su implementaci√≥n espec√≠fica con y sin excepciones son dos especializaciones de una sola clase para el par√°metro booleano especificado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operaci√≥n de fusi√≥n de lista de plantillas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La operaci√≥n de plantilla de combinar listas anteriormente funcionaba solo con listas del mismo tipo. Combinaba solo listas conectadas individualmente o solo listas doblemente conectadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, si lo piensa, realmente no importa qu√© tipo de listas est√©n involucradas en la operaci√≥n: simplemente conectadas o doblemente conectadas. Sus estrategias de bloqueo tampoco son importantes, cu√°l es su estrategia para verificar la existencia de elementos y si admiten el manejo de excepciones o no. Todo esto se aplica solo a la organizaci√≥n de la lista, pero no a los datos que contiene. Es importante que solo coincidan el tipo de datos y la estrategia de memoria para los elementos. En consecuencia, ahora, despu√©s de combinar listas con un par√°metro booleano con respecto a excepciones, la operaci√≥n de entrada acepta listas de cualquier tipo con todas las variantes de sus par√°metros:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, como resultado del tipo de lista, el compilador selecciona, dependiendo de la configuraci√≥n del par√°metro externo ce_bGetMinLinksList, una lista con conectividad m√≠nima o m√°xima y, dependiendo de esta soluci√≥n, se utilizan sus par√°metros correspondientes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En funci√≥n de los par√°metros seleccionados, se crea una lista de resultados:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, en esta lista, los punteros se establecen al principio de la primera y al final de la segunda lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, se borran las listas anteriores y se cierra la funci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El punto d√©bil de esta funci√≥n es el doble bloqueo de listas con posibles puntos muertos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede introducir alguna funci√≥n para bloquear simult√°neamente dos listas en una sola operaci√≥n at√≥mica como std :: lock (mutex1, mutex2), sin embargo, no todas las estrategias de bloqueo admiten el bloqueo simult√°neo de dos objetos de sincronizaci√≥n, como std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, dos listas pueden tener diferentes estrategias de bloqueo. </font><font style="vertical-align: inherit;">La soluci√≥n a este problema (si es que existe) se deja para el futuro.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilaci√≥n de Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compilaci√≥n se verific√≥ a trav√©s del proyecto ListDataAdapterTest, originalmente escrito en C ++ puro sin caracter√≠sticas espec√≠ficas de Windows, en Linux Ubuntu 16.04 LTS, el compilador g ++ 8.2.0. La mayor√≠a de los peque√±os matices fueron f√°ciles de solucionar, y el proyecto se compil√≥ con √©xito, y la salida del programa coincidi√≥ con la misma salida en Windows. Sin embargo, este es el caso si comenta la l√≠nea de combinaci√≥n de listas mediante la operaci√≥n "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si lo deja como est√°, se producir√° un error de compilaci√≥n en la operaci√≥n "+" descrita anteriormente, como si no hubiera sido declarado privilegiado en la clase del elemento compuesto de la lista. Se produce un error similar en la estrategia de verificaci√≥n directa de la presencia del elemento DirectSearch. En Visual C ++, todo est√° bien aqu√≠, sin embargo, estos mismos errores aparecen si en la clase de elemento compuesto y en la clase de lista se comenta el comentario al declarar la operaci√≥n de combinar listas y DirectSearch como privilegiadas. Parece que g ++ simplemente omite estas declaraciones y se queja de los miembros privados / protegidos de las clases correspondientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(En g ++ versi√≥n 9 (Ubuntu 20.04), los mismos errores).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por qu√© se omiten los anuncios de privilegios y c√≥mo solucionarlos, no lo entend√≠. </font><font style="vertical-align: inherit;">No soy bueno en las caracter√≠sticas del compilador GCC. </font><font style="vertical-align: inherit;">Dej√≥ este momento tambi√©n para el futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Excepto por este matiz, no hay otros errores graves de compilaci√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripci√≥n de la estructura del archivo de encabezado</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estimados lectores, publiqu√© un proyecto completo bajo la licencia LGPL 3.0 en GitHub en: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esta es una soluci√≥n que consta de varios proyectos de prueba. </font><font style="vertical-align: inherit;">El c√≥digo principal de una lista multiproceso, en virtud de su implementaci√≥n a trav√©s de plantillas, se encuentra en varios archivos de encabezado:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h: la clase base de una lista sin datos, que implementa todas las operaciones b√°sicas con una lista, posible sin definir datos espec√≠ficos, as√≠ como adaptadores STL similares para datos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h: versiones de la lista con soporte de excepci√≥n.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h: definici√≥n de clases base para un elemento de la lista.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h: definici√≥n de c√≥digos y clases de error para excepciones.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de los archivos principales enumerados, tambi√©n se implementan los siguientes:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h: estrategias para trabajar con memoria;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h: estrategias de bloqueo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h: estrategias para verificar la presencia de un elemento en la lista, descrita de forma abstracta para cualquier contenedor con iteradores.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s del proyecto final, tambi√©n agregu√© tres versiones antiguas en la carpeta "Versiones anteriores", para que pueda evaluar brevemente c√≥mo cambi√≥ el proyecto a medida que se desarrollaba.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pruebas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proyecto principal, llamado List, es un programa con una interfaz para Windows que se implementa de manera extrema a trav√©s de la API de Windows (no s√© de qu√© otra manera). En este programa, selecciona el tipo de lista (simplemente conectado o doblemente conectado), y tambi√©n indica el n√∫mero inicial de elementos y el n√∫mero deseado de hilos. Los elementos de la lista contienen un √∫nico valor de 64 bits. Despu√©s de crear una lista, el programa en cada hilo del bucle salta hacia adelante o hacia atr√°s a trav√©s de la lista a un n√∫mero aleatorio de elementos, y luego agrega o elimina un elemento. No se realiza ning√∫n trabajo √∫til real a trav√©s de esta lista, y toda la energ√≠a se gasta en calentar la atm√≥sfera, pero esto no es necesario: solo necesitamos evaluar la operatividad y el rendimiento de la lista en un entorno intensivo de subprocesos m√∫ltiples.La medida del rendimiento es el n√∫mero de iteraciones del ciclo anterior por segundo, realizadas por todos los hilos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lista se configura indicando las estrategias apropiadas en el c√≥digo del programa y luego volviendo a compilar. Todas las estrategias para el programa principal se especifican en el m√≥dulo principal ListMain.cpp, la estrategia de memoria se selecciona en ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En t√©rminos generales, experiment√© un poco con los experimentos. Sinceramente lo admito. Principalmente porque en varios casos la lista de art√≠culos cambia significativamente. Para la pureza del experimento, para medir el rendimiento, ser√≠a necesario realizar una prueba de tal manera que el n√∫mero de elementos en promedio no cambie durante el per√≠odo de estudio o cambie de manera extremadamente insignificante. Solo bajo tales condiciones ser√≠a justo evaluar el valor de la productividad con base en el valor promedio. Si alguien est√° interesado, propongo organizar tales experimentos por su cuenta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No corrig√≠ la organizaci√≥n inicial de las pruebas por los siguientes motivos. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, solo era vago.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En primer lugar, en mi opini√≥n, a nadie le interesan los valores cuantitativos exactos del rendimiento.</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con error calculado</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : es importante evaluar el rendimiento y el rendimiento de la lista de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manera de calidad</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En segundo lugar, esto le permite evaluar el cambio en el rendimiento de la lista con el crecimiento de su volumen, que tambi√©n es una informaci√≥n bastante importante e interesante. </font><font style="vertical-align: inherit;">Por estas razones, no cambi√© los experimentos originales. </font><font style="vertical-align: inherit;">En tercer lugar, se realiza el mismo c√≥digo de prueba en todas las variantes de la lista, lo que en este sentido las pone en las mismas condiciones: el hecho de que se comporten de manera diferente en este caso nos permite juzgar la calidad de los cambios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para habilitar la medici√≥n del rendimiento, establezca el indicador ce_bPerformanceMeasure en el m√≥dulo ListMain.cpp en verdadero. </font><font style="vertical-align: inherit;">El programa crear√° un archivo "PerformanceMeasure.txt" con pares "n√∫mero de elementos - n√∫mero de ciclos / seg", separados por un s√≠mbolo ":".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de medici√≥n de desempe√±o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, no realic√© pruebas para todas las configuraciones posibles de la lista, porque hay muchas. </font><font style="vertical-align: inherit;">Me concentr√© solo en las claves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pruebas se llevaron a cabo en mi pedido de la ya obsoleta, pero todav√≠a muy din√°mica configuraci√≥n Intel Core i7-3930K, DDR3-1333, controlador de memoria de 4 canales. </font><font style="vertical-align: inherit;">La compilaci√≥n se realiz√≥ a trav√©s de Visual Studio 2019 para el modo Release x64, el sistema operativo Windows 7 x64. </font><font style="vertical-align: inherit;">No jugu√© con el n√∫mero de subprocesos, por lo que en todas las pruebas, siempre se usaron los 12 subprocesos m√°ximos disponibles en este sistema. </font><font style="vertical-align: inherit;">Siempre se ha creado una lista con 10,000 elementos seleccionados al azar, con la excepci√≥n de la √∫ltima prueba.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prueba de estrategia de memoria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando punteros integrados, como mencion√© anteriormente, solo se puede usar una estrategia de b√∫squeda directa para verificar la presencia de un elemento en la lista. En consecuencia, para que la comparaci√≥n sea correcta, y para los punteros inteligentes, solo esta estrategia se aplicar√° en esta prueba. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como estrategia de bloqueo, se seleccion√≥ una secci√≥n cr√≠tica con un bloqueo delgado como la m√°s productiva en Windows (ver a continuaci√≥n): ThreadLockingWin_SRWLock. El manejo de errores se lleva a cabo devolviendo un c√≥digo de error, es decir opci√≥n sin excepciones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este gr√°fico muestra el n√∫mero de ciclos realizados por todos los hilos en total por segundo, dependiendo de la duraci√≥n de la prueba (en segundos). Obviamente, el rendimiento es inconsistente debido a la naturaleza aleatoria de los hilos que acceden a la lista.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo gr√°fico muestra c√≥mo cambia el n√∫mero de elementos de la lista durante la prueba. No har√© ninguna declaraci√≥n reflexiva sobre este programa, excepto lo obvio: est√° claro que funcionan de maneras ligeramente diferentes, y la conectividad de la lista junto con la estrategia de memoria tiene un efecto. Una lista doblemente vinculada con punteros internos es la √∫nica que inesperadamente no cambia en tama√±o promedio durante toda la duraci√≥n de la prueba. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Productividad promedio (ciclos / s) para el per√≠odo medido:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al menos se puede argumentar que la opci√≥n de lista con punteros inteligentes es m√°s lenta que la versi√≥n con punteros integrados, lo cual es de esperar. </font><font style="vertical-align: inherit;">En ambos casos, de alguna manera resulta que uno conectado individualmente es m√°s r√°pido que uno doblemente conectado, lo que una vez m√°s muestra que en el modo multiproceso, muchas cosas familiares pueden cambiar.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prueba de estrategias de disponibilidad de art√≠culos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo m√°s interesante es probar estrategias para verificar la presencia de un elemento. Como estrategia de memoria, los punteros inteligentes se indican naturalmente por los motivos descritos anteriormente. El resto es igual: bloqueo con ThreadLockingWin_SRWLock y manejo de errores al devolver un c√≥digo de error. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos decir con certeza que todas las estrategias funcionan aproximadamente igual. Esto es comprensible: en una lista vinculada individualmente, cuando elimina su elemento, debe mirar la lista cada vez que encuentre el elemento que indica el elemento que se va a eliminar. Esto anula todos los esfuerzos para optimizar el acceso a la lista y acelerar la comprobaci√≥n de la presencia de un elemento en ella. Por lo tanto, una lista enlazada individualmente no es la mejor opci√≥n para el trabajo intensivo con m√∫ltiples subprocesos con ella.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No dar√© un gr√°fico sobre el n√∫mero de elementos: no hay nada interesante all√≠. Solo noto que ahora el n√∫mero de elementos en todas las listas est√° aumentando. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una situaci√≥n completamente diferente surge para una lista doblemente vinculada. Para hacer que los gr√°ficos se vean hermosos, incluso exclu√≠ la estrategia de visualizaci√≥n directa de la lista de DirectSearch, porque por los resultados claramente "se cae" del resto. Adem√°s, aument√© el n√∫mero l√≠mite de elementos en 4 veces, llegando a lo cual, la prueba se detiene.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, ¬°el rendimiento de acceder a la lista (as√≠ como la carga del procesador, que se convierte en 99-100%) ha aumentado dram√°ticamente y significativamente! En segundo lugar, un par de estrategias con relleno secuencial de bits de matriz tienen aproximadamente el mismo rendimiento que no cambia durante la prueba. La velocidad del segundo par de estrategias disminuye de forma no lineal. Por qu√© es as√≠, quedar√° claro en el gr√°fico el n√∫mero de nodos en la lista.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las listas con el primer par de estrategias crecen en el n√∫mero de elementos y de forma lineal. El segundo par da un crecimiento significativamente no lineal, y cuanto mayor es el n√∫mero de elementos que tiene una lista, m√°s lento crece. Esto es comprensible ya que Con un aumento en el n√∫mero de elementos al crear uno nuevo, en promedio es necesario mirar a trav√©s de un mayor n√∫mero de bits de la matriz en busca de libre. El primer par de estrategias no se ocupa de esto, usa un bit nuevo para cada elemento nuevo. Por lo tanto, una lista con dicha estrategia tiene un rendimiento de acceso m√°ximo y est√° m√°s cerca de la lista cl√°sica: tanto la creaci√≥n como la eliminaci√≥n de elementos se realizan en un tiempo constante, independientemente del n√∫mero de elementos. Sin embargo, proporciona algunas garant√≠as de integridad y seguridad en un entorno multiproceso, aunque a costa de una cierta cantidad de memoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lista con el segundo par de estrategias, por supuesto, es notablemente m√°s lenta. Sin embargo, todav√≠a es significativamente m√°s r√°pido que las opciones de verificaci√≥n directa. Por lo tanto, realmente puede recomendarlo como un rendimiento intermedio, pero m√°s √≥ptimo en t√©rminos de consumo de memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, las listas con una estrategia de b√∫squeda directa tambi√©n funcionar√°n m√°s lentamente con un aumento en el n√∫mero de elementos en ellas: habr√° que ver un mayor n√∫mero de elementos cada vez. Es solo que durante la prueba, la lista no logra crecer tanto que se hace notable a pesar de las ca√≥ticas fluctuaciones de rendimiento.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los valores de rendimiento promedio muestran que las estrategias con un mapa de bits durante su llenado secuencial permitieron aumentar la productividad de acceso a la lista en aproximadamente 200 veces, es decir. </font><font style="vertical-align: inherit;">2 √≥rdenes de magnitud en comparaci√≥n con las estrategias de b√∫squeda directa. </font><font style="vertical-align: inherit;">Este es un cambio muy radical. </font><font style="vertical-align: inherit;">El rendimiento de las opciones con relleno de bits √≥ptimo para la memoria, como se se√±al√≥ anteriormente, es por supuesto notablemente m√°s lento, pero a√∫n mucho m√°s r√°pido que las opciones con verificaci√≥n directa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n vale la pena se√±alar que el uso de un mecanismo de transferencia de memoria bajo demanda ralentiza un poco el acceso a la lista. </font><font style="vertical-align: inherit;">No es demasiado cr√≠tico, pero el efecto est√° presente y es notable, especialmente en la variante con el uso econ√≥mico de la memoria (l√≠nea amarilla en los gr√°ficos).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prueba de estrategia de bloqueo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos c√≥mo cambiar√° el rendimiento de la lista al elegir diferentes estrategias de bloqueo. </font><font style="vertical-align: inherit;">Us√© tres tipos de bloqueos: bloqueo "delgado" SRWLock, secci√≥n cr√≠tica normal de Windows y mutex STL. </font><font style="vertical-align: inherit;">Para el resto de la configuraci√≥n, se utiliz√≥ la versi√≥n m√°s r√°pida de la lista: punteros inteligentes, bicon√©ctados, la estrategia para verificar la presencia de un elemento: SearchByIndex_BitArray, una variante sin excepciones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como era de esperar, un bloqueo "delgado" aumenta el rendimiento en casi un 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La velocidad de trabajo con la secci√≥n cr√≠tica de Windows y el mutex STL es casi la misma.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excepciones</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evaluar el impacto de las excepciones en el rendimiento, realic√© tres pruebas. </font><font style="vertical-align: inherit;">Los dos primeros utilizaron una lista doblemente vinculada, punteros inteligentes, una estrategia de verificaci√≥n de presencia de elementos: SearchByIndex_BitArray, y una secci√≥n cr√≠tica de SRWLock. </font><font style="vertical-align: inherit;">Se us√≥ la misma prueba para la √∫ltima prueba, solo se reemplaz√≥ el bloqueo con la secci√≥n cr√≠tica habitual para la comparaci√≥n. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se puede ver que el soporte para excepciones realmente puede reducir la velocidad del trabajo, especialmente si utiliza una opci√≥n de bloqueo m√°s "burda". </font><font style="vertical-align: inherit;">Sin embargo, recuerde que en este caso, el soporte para STL y para los bucles en la colecci√≥n no estar√° disponible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fue un experimento a gran escala para m√≠. No me refiero a las pruebas anteriores, sino a todo el proyecto. No esperaba que lo arrastraran tanto. Sin embargo, lo llev√© a cabo por completo y en la medida en que lo plane√©. Por supuesto, al final, esta todav√≠a no es la versi√≥n final, sino solo un prototipo funcional, la implementaci√≥n de las ideas descritas al comienzo del art√≠culo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acuerdo con los resultados de la prueba, est√° claro que en Windows result√≥ ser la lista doblemente enlazada m√°s r√°pida con punteros inteligentes, una estrategia para verificar la presencia del elemento SearchByIndex_BitArray, una secci√≥n cr√≠tica de SRWLock y sin excepciones. En esta configuraci√≥n, la lista proporciona el m√°ximo rendimiento con acceso ca√≥tico intensivo desde varios subprocesos y el comportamiento es el m√°s cercano a la lista cl√°sica con garant√≠as de seguridad en modo multiproceso. La opci√≥n con un consumo de memoria m√°s econ√≥mico tambi√©n es muy productiva (en comparaci√≥n con DirectSearch directo), pero sigue siendo notablemente m√°s lenta que la anterior, y su rendimiento disminuye con un aumento en el n√∫mero de elementos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si crees que voy a hacer campa√±a aqu√≠ por lo genial que hice y lo bueno que es usarlo, entonces no: de hecho, comenzar√© por desanimarte. </font><font style="vertical-align: inherit;">En efecto:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piense si es posible usar un contenedor con una disposici√≥n diferente de elementos: por ejemplo, una matriz. </font><font style="vertical-align: inherit;">No tiene problemas como una lista.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    ‚Äì       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   ‚Äì     .    . ,   ‚Äì          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las estrategias para transferir memoria a una matriz de bits a pedido tambi√©n aproximan al menos parcialmente una lista multiproceso a la cl√°sica: al menos hasta que la matriz de memoria est√© completamente llena, tomar√° exactamente lo que realmente se necesita. </font><font style="vertical-align: inherit;">Sin embargo, esto implica una reducci√≥n en el rendimiento.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Desventajas del proyecto:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La posibilidad previamente se√±alada de bloqueo mutuo en la operaci√≥n de combinar listas.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que esto haya sido interesante. Los principiantes pueden ser √∫tiles, porque todo se considera de simple a complejo. Pido a los profesionales que digan cu√°nto, en su opini√≥n, las ideas descritas aqu√≠ son aplicables en la pr√°ctica en proyectos reales. ¬øHa habido un caso en su actividad cuando, de acuerdo con el significado, necesitaba una lista o √°rbol, y no otro contenedor, pero se convirti√≥ en un cuello de botella en su programa debido a los problemas descritos aqu√≠? O ten√≠a que cambiar o complicar mucho el programa. Si ya conociste esto, ¬øc√≥mo lo resolviste?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, en esencia, este proyecto es solo la realizaci√≥n de mi propio punto de vista sobre la soluci√≥n de este problema. </font><font style="vertical-align: inherit;">Es probable que haya alguna opci√≥n mejor. </font><font style="vertical-align: inherit;">Repito desde el principio la idea de que lo hice inicialmente por m√≠ mismo y no pensaba ponerlo en exhibici√≥n p√∫blica. </font><font style="vertical-align: inherit;">Pero a√∫n as√≠, lo hice por las razones descritas all√≠, por lo que me alegrar√° recibir cr√≠ticas constructivas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con una revisi√≥n cuidadosa del c√≥digo, puede encontrar un dise√±o de este tipo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta magia negra merece un art√≠culo aparte. </font><font style="vertical-align: inherit;">Es cierto que esto es una cosa a√∫n menos pr√°ctica que la lista multiproceso que se describe aqu√≠, pero tiene sus propias caracter√≠sticas curiosas. </font><font style="vertical-align: inherit;">Si est√° interesado en saber de d√≥nde vino y por qu√© apareci√≥, y quiere que le hable m√°s tarde en detalle, escriba los comentarios.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es506702/index.html">Los discos duros m√°s fiables seg√∫n Backblaze Q1 2020</a></li>
<li><a href="../es506704/index.html">¬øPor qu√© escribir en PHP en 2020? Holivarim es un podcast interactivo en Youtube este jueves</a></li>
<li><a href="../es506706/index.html">El rendimiento de Java moderno cuando se trabaja con grandes cantidades de datos, parte 1</a></li>
<li><a href="../es506708/index.html">Autenticaci√≥n de dos factores VPN / Mikrotik: simple y escalable</a></li>
<li><a href="../es506710/index.html">Administre varias libretas de direcciones en la edici√≥n de c√≥digo abierto Zimbra Collaboration Suite</a></li>
<li><a href="../es506726/index.html">Experiencia en el uso de la tecnolog√≠a Rutoken para el registro y autorizaci√≥n de usuarios en el sistema (parte 2)</a></li>
<li><a href="../es506730/index.html">Snort o Suricata. Parte 1: elija un IDS / IPS gratuito para proteger la red corporativa</a></li>
<li><a href="../es506732/index.html">Reutilizaci√≥n de componentes de la interfaz de usuario en toda la organizaci√≥n</a></li>
<li><a href="../es506734/index.html">C√°lculos transitorios en redes el√©ctricas.</a></li>
<li><a href="../es506736/index.html">¬øCu√°ntos m√©todos deber√≠a haber en una clase?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>