<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™Œ ğŸ± â° Redis Praktik Terbaik, Bagian 3 ğŸŒ  ğŸ›¡ï¸ ğŸ”„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan akhir bagian Praktik Terbaik Redis dari situs web resmi Redis Labs. Yang paling tidak biasa dan menarik hari ini di bawah cut!
 
 
 Bagian ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redis Praktik Terbaik, Bagian 3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terjemahan akhir bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktik Terbaik Redis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari situs web resmi Redis Labs. </font><font style="vertical-align: inherit;">Yang paling tidak biasa dan menarik hari ini di bawah cut!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian pertama ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan yang kedua ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini berisi topik-topik berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan waktu pada set diurutkan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan waktu pada set yang diurutkan secara leksikografis;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan waktu pada bidang bit;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pola pembatasan bandwidth dasar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filter mekar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melawan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pola penghitungan bit;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skrip Lua.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Urutan Waktu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data urutan waktu, atau data dengan urutan waktu alami, dapat dimodelkan dalam Redis dalam beberapa cara, tergantung pada data itu sendiri dan cara Anda ingin mengaksesnya. </font><font style="vertical-align: inherit;">Kami akan melihat beberapa pola ini:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan waktu pada set diurutkan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan waktu pada set yang diurutkan secara leksikografis;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan waktu pada bidang bit;</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan waktu pada set yang diurutkan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Urutan waktu pada set yang diurutkan (zsets) adalah cara khas untuk memodelkan urutan waktu dalam Redis. </font><font style="vertical-align: inherit;">Set yang diurutkan terdiri dari objek unik yang skornya disimpan di bawah satu kunci. </font><font style="vertical-align: inherit;">Menggunakan tipe data ini untuk set yang diurutkan berarti bahwa hitungan berperilaku sebagai semacam indikator waktu (seringkali itu adalah cap waktu yang akurat untuk milidetik), dan elemen tersebut dicatat data. </font><font style="vertical-align: inherit;">Satu-satunya keuntungan adalah karena ini adalah bentuk set, hanya elemen unik yang diizinkan, dan mencoba merekam urutan waktu dengan nilai yang sama hanya akan menyegarkan skor. </font><font style="vertical-align: inherit;">Untuk mengilustrasikan masalah ini, kami mengambil contoh berikut dari pencatatan suhu secara berkala:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stempel waktu</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suhu, c</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda hanya menambahkannya ke set yang diurutkan menggunakan ZADD, Anda mungkin kehilangan beberapa nilai: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
POLA ANTI</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa panggilan ketiga ke ZADD mengembalikan 0, yang menunjukkan bahwa item baru belum ditambahkan ke set. Kemudian di ZRANGEBYSCORE kita melihat bahwa hanya ada dua catatan dalam set yang diurutkan. Mengapa? Karena yang pertama dan ketiga berbagi objek yang sama, dan kami baru saja memperbarui akun untuk objek ini. Ada beberapa cara untuk mengatasi masalah ini. Salah satunya adalah memasukkan beberapa data acak dengan variasi yang cukup, sehingga memastikan keunikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, buat bilangan real pseudo-acak dari 0 hingga 1, inklusif, lalu tambahkan ke stempel waktu kami. Dalam contoh kita, kita akan membiarkannya dalam bentuk desimal agar mudah dibaca (pada kenyataannya, akan lebih bijaksana jika hanya mengkonversi ke string 8-byte untuk menghemat ruang).</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, semua ZADD mengembalikan 1, menunjukkan penambahan yang berhasil, dan ZRANGEBYSCORE mengembalikan semua nilai. </font><font style="vertical-align: inherit;">Ini adalah metode kerja, namun, itu tidak terlalu efisien karena pemborosan byte untuk memastikan keunikan, yang menambah overhead ke penyimpanan. </font><font style="vertical-align: inherit;">Dalam kebanyakan kasus, keunikan hanya akan tersapu oleh aplikasi Anda. </font><font style="vertical-align: inherit;">Perlu dicatat bahwa menambahkan keunikan tidak diperlukan jika data Anda sudah unik (misalnya, data termasuk UUID). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan metode ini, Anda memiliki akses ke semua metode set diurutkan untuk analisis dan kontrol:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYSCORE memungkinkan Anda untuk mendapatkan irisan tertentu antara dua stempel waktu (ZREVRANGEBYSCORE akan mengembalikan potongan dalam urutan menurun);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYSCORE memungkinkan Anda menghapus rentang cap waktu tertentu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT - jumlah elemen antara rentang cap waktu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE - memungkinkan Anda mendapatkan persimpangan dua bagian data dan menyimpannya di bawah kunci baru;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE - memungkinkan Anda untuk mendapatkan gabungan dua bagian data dan juga menyimpannya di bawah kunci baru. </font><font style="vertical-align: inherit;">Anda juga dapat menggunakan ini untuk menduplikasi set yang diurutkan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operasi ZINTERSTORE dan ZUNIONSTORE yang bekerja dengan beberapa tombol. </font><font style="vertical-align: inherit;">Saat bekerja dengan lingkungan yang dibagikan, Anda harus berhati-hati untuk memeriksa bahwa kunci baru Anda berada di segmen yang sama, jika tidak maka perintah ini akan menyebabkan kesalahan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan waktu pada set yang diurutkan secara leksikografis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara lain untuk bekerja dengan urutan waktu adalah dengan menggunakan properti leksikografis dari set yang diurutkan untuk menyimpan stempel waktu dan nilai. Jika Anda belum terbiasa dengan ini, maka sudah waktunya untuk membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagian ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan metode ini, kami menyimpan semuanya dengan jumlah yang sama dan terlebih dahulu menyandikan timestamp, lalu menambahkan nilainya sebagai elemen. Ambil sebuah contoh:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam tiga panggilan ZADD ini, stempel waktu dipisahkan dari nilai oleh titik dua, dan kita dapat melihat bahwa 1 dikembalikan setiap kali, yang berarti ketiganya telah ditambahkan. Di ZRANGE kita melihat pesanan yang disimpan. Mengapa? Dalam set yang diurutkan, jika skornya sama, hasil dengan skor yang sama diurutkan berdasarkan sortir biner. Karena cap waktu dalam periode ini memiliki jumlah digit yang sama, semuanya akan diurutkan dengan benar (jika cap waktu Anda sebelum tahun 2002 atau setelah 2285, Anda akan membutuhkan lebih banyak digit untuk diisi). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendapatkan rentang nilai dari tipe ini, gunakan perintah ZRANGEBYLEX:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumen kedua memiliki awalan (menunjukkan eksklusivitas nilai (inklusivitas dilambangkan dengan [). Dalam praktiknya, format ini membuat inklusivitas dan eksklusivitas tidak relevan, karena cap waktu akan selalu diikuti oleh data tambahan. Argumen ketiga + menunjukkan ketidakterbatasan batas atas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cobalah untuk mendapatkan tanggal antara 1589392160001 dan 1589392165001 inklusif:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa data stempel waktu 1589392165001 tidak masuk ke sampel, meskipun awalan inklusif? </font><font style="vertical-align: inherit;">Saya ingin percaya bahwa Redis entah bagaimana mengerti bahwa ini adalah cap waktu. </font><font style="vertical-align: inherit;">Faktanya, Redis hanya melihat penyortiran biner. </font><font style="vertical-align: inherit;">Dalam penyortiran biner, 1589392165001: 21 lebih besar dari 1589392165001 inklusif atau eksklusif. </font><font style="vertical-align: inherit;">Cara yang benar untuk memasukkan ini dalam batas atas adalah menambahkan 1 milidetik ke batas atas yang diinginkan dan menggunakan eksklusivitas:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Urutan sementara dengan set yang diurutkan secara leksikografis memiliki serangkaian perintah yang berguna, seperti urutan sementara dengan set yang hanya diurutkan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX - Mendapat rentang nilai dalam urutan naik atau turun;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX - menghapus rentang nilai yang diurutkan tertentu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT - Mendapat jumlah elemen dalam rentang nilai yang diurutkan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE dan ZUNIONSTORE dapat digunakan pada set yang diurutkan secara leksikografis, tetapi ada risiko hilangnya data, karena kombinasi duplikat stempel waktu dan nilai tidak akan diduplikasi dalam hasil yang dikembalikan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin bertanya-tanya mengapa memilih set yang diurutkan dengan stempel waktu alih-alih menyandikan set yang diurutkan secara leksikografis. </font><font style="vertical-align: inherit;">Sebagai aturan, lebih baik bekerja dengan set yang diurutkan secara leksikografis untuk urutan waktu - jika nilainya tidak selalu unik, cap waktu akan lebih efektif.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit Field Temporal Sequences</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis dapat secara efektif menyimpan urutan waktu dalam bidang bit. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda harus terlebih dahulu memilih titik referensi sembarang dan format numerik. </font><font style="vertical-align: inherit;">Ambil contoh pengukuran suhu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita ingin mengukur suhu setiap menit, dan kita akan menetapkan titik awal untuk tengah malam setiap hari. </font><font style="vertical-align: inherit;">Kami mengukur suhu kamar dalam derajat Celcius. </font><font style="vertical-align: inherit;">Anda dapat menyusun data sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 menit = byte 0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suhu ditulis dalam angka unsigned 8-bit (0-255).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama sehari, data diketik sekitar 1,44 kb. </font><font style="vertical-align: inherit;">Anda dapat merekam suhu dengan perintah BITFIELD:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, menggunakan kunci bit-ts, nilai suhu 22 ditulis ke angka 8-bit yang tidak ditandatangani (u8) pada tengah malam (# 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Field bit tidak terbatas pada nilai-nilai 8-bit yang tidak ditandatangani. </font><font style="vertical-align: inherit;">Perhatikan tanda pound sebelum offset. </font><font style="vertical-align: inherit;">Ini berarti bahwa perataan akan terjadi pada jenis yang dipilih. </font><font style="vertical-align: inherit;">Misalnya, jika Anda menentukan "# 79" - ini berarti byte ke-79, "79" - bit ke-79 (lihat bantuan BITFIELD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offset dapat disejajarkan dengan jenis nomor yang disimpan, mulai dari 0. Misalnya, jika kita ingin menulis 1 pagi, dengan mempertimbangkan slot nol, kita menggunakan offset # 59 atau offset # 719 untuk siang hari.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh ini juga menunjukkan bahwa BITFIELD adalah variabel, mis. </font><font style="vertical-align: inherit;">Anda dapat bekerja dengan banyak nilai dalam satu panggilan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambahkan beberapa nilai lagi:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang kita akan mengekstrak:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tanda tangan dari sub-perintah bit GET mirip dengan tanda tangan SET, dengan satu-satunya perbedaan adalah bahwa ia tidak menerima nilai sebagai argumen ketiga. </font><font style="vertical-align: inherit;">Itu normal ketika kita tahu semua indeks yang perlu diperoleh, tetapi kadang-kadang kita membutuhkan rentang nilai, dan setiap byte secara individual akan terlalu menegangkan. </font><font style="vertical-align: inherit;">Kita dapat menggunakan perintah GETRANGE. </font><font style="vertical-align: inherit;">Dalam situasi normal, ini digunakan untuk mendapatkan byte dari sebuah string, tetapi BITFIELD hanyalah cara lain untuk menangani data yang sama.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perintah mengembalikan byte 59 hingga 61 dalam heksadesimal (23, 21, dan 20 dalam desimal. Bahasa klien menangani data biner lebih baik daripada redis-cli, dan biasanya bisa mendapatkan array byte khusus bahasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh kami, kami menggunakan byte 0 , 59-61 dan 719. Apa yang terjadi jika kami meminta byte yang belum ditetapkan?</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis mengembalikan byte yang tidak ditentukan sebagai 0. Ini dapat menyebabkan kesulitan ketika bekerja dengan data urutan waktu - logika aplikasi perlu membedakan antara 0 dan nilai yang tidak ditentukan. </font><font style="vertical-align: inherit;">Pembulatan dan penghilangan nilai 0 dimungkinkan, terutama saat menggunakan bilangan bulat yang ditandatangani, karena ini mungkin nilai yang valid di tengah rentang Anda. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panjang sebenarnya dari urutan waktu sebenarnya tergantung pada byte terakhir. </font><font style="vertical-align: inherit;">Dalam contoh, byte yang disimpan terakhir adalah 719, sehingga panjang data adalah 720 byte.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Urutan waktu berbasis BITFIELD adalah pola yang kuat dan ringkas untuk menyimpan data numerik atau biner. </font><font style="vertical-align: inherit;">Namun, solusi ini tidak mencakup semua kasus penggunaan, dan penggunaannya harus dipertimbangkan dengan cermat sesuai dengan kebutuhan Anda.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola Batas Bandwidth Dasar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membuat pembatas bandwidth dengan Redis mudah berkat perintah INCR dan EXPIRE. </font><font style="vertical-align: inherit;">Idenya adalah Anda ingin membatasi permintaan ke layanan tertentu untuk jangka waktu tertentu. </font><font style="vertical-align: inherit;">Misalkan kita memiliki layanan di mana pengguna diidentifikasi dengan kunci API. </font><font style="vertical-align: inherit;">Layanan memiliki batas 20 permintaan per menit. </font><font style="vertical-align: inherit;">Untuk mengimplementasikan ini, kami ingin membuat kunci Redis pada kunci API setiap menit. </font><font style="vertical-align: inherit;">Agar tidak membuang sampah ke database, periode validitas kunci juga diatur ke 1 menit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kunci API - zA21X31, tebal - batas tercapai:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunci Redis</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua puluh</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua puluh</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kadaluarsa dalam</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kuncinya terdiri dari kunci API dan angka menit melalui titik dua. </font><font style="vertical-align: inherit;">Karena kunci selalu kedaluwarsa, cukup bagi kami untuk hanya menggunakan angka menit - dengan permulaan jam baru kami dapat yakin bahwa tidak ada 59 kunci lainnya (mereka kedaluwarsa 59 menit yang lalu). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat cara kerjanya:</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika hasilnya kurang dari 20 atau tidak disetel, lanjutkan ke langkah 4, jika tidak, lanjutkan ke langkah 3;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilkan pesan kesalahan, tutup koneksi dan akhiri;</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lanjutkan program.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua poin utama:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INCR pada kunci yang tidak ada akan selalu menjadi 1;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIRE terletak di dalam transaksi MULTI bersama dengan INCR, yang berarti bahwa itu akan menjadi satu operasi atom.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skenario kasus terburuk adalah jika, karena alasan yang sangat aneh dan tidak mungkin, server Redis mati antara INCR dan EXPIRE. </font><font style="vertical-align: inherit;">Ketika mengembalikan data baik dari AOF atau replika di dalam memori, INCR tidak akan dikembalikan karena transaksi tidak selesai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menggunakan pola ini, ada kemungkinan bahwa satu pengguna memiliki dua kunci: satu yang sedang digunakan, dan yang lainnya, yang berakhir pada saat ini. </font><font style="vertical-align: inherit;">Namun, polanya sangat efektif.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filter mekar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Filter Bloom adalah struktur data probabilistik yang menarik yang dapat Anda gunakan untuk memeriksa apakah suatu item telah ditambahkan sebelumnya. Ini adalah kata-kata yang disengaja. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemungkinannya adalah hanya ada respons positif palsu, tetapi bukan negatif palsu. Filter Bloom menyediakan cara yang jauh lebih ringkas dan cepat untuk memeriksa ketersediaan daripada menyimpan semua elemen ke dalam satu set dan memanggil SISMEMBER.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Filter Bloom bekerja dengan melewatkan elemen melalui fungsi hash cepat, memilih bit dari itu dan mengaturnya ke 1 dan 0 pada interval tertentu di bidang bit. Untuk memeriksa keberadaan filter, bit yang sama dipilih. Banyak elemen mungkin memiliki bit yang tumpang tindih, tetapi karena fungsi hash menciptakan pengidentifikasi unik, jika satu bit dari hash masih 0, maka kita tahu bahwa itu belum ditambahkan sebelumnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis telah menggunakan filter selama bertahun-tahun sebagai pustaka klien yang menggunakan GETBIT dan SETBIT untuk bekerja dengan bidang bit. Untungnya, modul ReBloom tersedia dari Redis 4.0, yang menghilangkan kebutuhan untuk membuat implementasi filter Bloom Anda sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasing penggunaan yang baik untuk filter ini adalah untuk memeriksa apakah nama pengguna telah digunakan. </font><font style="vertical-align: inherit;">Tidak ada masalah dengan ukuran data kecil, tetapi ketika layanan tumbuh, permintaan basis data bisa mahal. </font><font style="vertical-align: inherit;">Ini mudah diperbaiki dengan ReBloom. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambahkan beberapa nama untuk ujian:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang uji filter Bloom:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang diharapkan, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kembali 0. Ini berarti nama seperti itu tidak digunakan. </font><font style="vertical-align: inherit;">Meskipun tidak mungkin untuk mengatakan dengan pasti, karena bit bisa saja tumpang tindih antara beberapa elemen. </font><font style="vertical-align: inherit;">Pada dasarnya, peluang false positive adalah rendah, tetapi tidak 0. Ketika filter Bloom mengisi, peluang meningkat, tetapi Anda dapat menyesuaikan tingkat kesalahan dan ukuran awal (masing-masing secara default adalah 0,01 dan 100).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melawan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penghitung di Redis dapat diimplementasikan dengan beberapa cara. </font><font style="vertical-align: inherit;">Yang paling jelas adalah INCR et al (INCRBY, INCRBYFLOAT, HINCRBY, HINCRBYFLOAT, ZINCRBY), yang dapat ditemukan dengan hanya membaca dokumentasi. </font><font style="vertical-align: inherit;">Yang kurang jelas adalah penggunaan BITCOUNT dan PFADD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola Penghitungan Bit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNT menghitung jumlah bit yang diatur ke 1 di bidang bit dengan kunci. </font><font style="vertical-align: inherit;">Ini dapat digunakan untuk menghitung serangkaian kegiatan selama periode waktu yang sewenang-wenang (mirip dengan pola urutan waktu pada bidang bit). </font><font style="vertical-align: inherit;">Prosesnya adalah memilih titik waktu, dan setiap bit mewakili satuan periode. </font><font style="vertical-align: inherit;">Setiap kali tindakan dilakukan selama periode ini, jalankan SETBIT pada jarak 1 unit dari titik terakhir.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[titik pangkal]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bertindak</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bertindak</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bertindak</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghitung pada menit apa dari 12: 00-12: 30 aktivitas terjadi, Anda dapat melakukan ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, pola ini menjawab pertanyaan "Seberapa sering?" Daripada "Berapa kali?". </font><font style="vertical-align: inherit;">Misalnya, pengguna dapat aktif 20 kali dalam satu menit, tetapi ini akan dihitung sebagai 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keuntungan sebenarnya dari templat ini adalah memberikan skor minimum yang mungkin untuk periode waktu tertentu, karena bit adalah blok penyimpan yang paling dasar. </font><font style="vertical-align: inherit;">Ini benar-benar repositori terkecil (tidak terkompresi) untuk penghitungan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menghitung barang-barang unik bisa rumit. Ini biasanya berarti menyimpan setiap elemen unik dan kemudian memohon informasi ini dalam beberapa cara. Di Redis, ini dapat dilakukan dengan menggunakan banyak dan satu tim, namun, volume yang ditempati dan kompleksitas waktu ini akan sangat besar. HyperLogLog memberikan alternatif probabilistik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperLogLog secara internal mirip dengan filter Bloom, itu juga memberi makan elemen melalui fungsi hash non-kriptografis dan menetapkan bit dalam bidang bit. Tapi, tidak seperti filter Bloom, HyperLogLog menyimpan penghitung elemen yang bertambah ketika elemen baru ditambahkan yang belum ditambahkan sebelumnya. Ini memberikan tingkat kesalahan rendah saat menghitung elemen unik dalam satu set. HyperLogLog dibangun langsung ke Redis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada 3 perintah HyperLogLog di Redis: PFADD, PFCOUNT, dan PFMERGE. </font><font style="vertical-align: inherit;">Katakanlah kita membuat pemindai web dan ingin menghitung jumlah URL unik halaman yang dilihat pada siang hari. </font><font style="vertical-align: inherit;">Untuk setiap halaman, jalankan perintah berikut:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap kunci di atas diindeks berdasarkan hari. </font><font style="vertical-align: inherit;">Untuk melihat berapa banyak halaman yang dilihat pada 13/06/2020, Anda dapat melakukan ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melihat jumlah halaman untuk 06/13/2020 dan 06/14/2020, gunakan perintah PFMERGE untuk membuat kunci baru dengan nilai yang menggabungkan dua penghitung. </font><font style="vertical-align: inherit;">Harap dicatat bahwa, karena </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disimpan di kedua set, itu akan dihitung sekali:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operasi ini dapat bekerja dengan beberapa tombol, jadi berhati-hatilah dalam lingkungan yang terbagi, sehingga kunci berada pada beling yang sama.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skrip Lua</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis dapat melakukan hal-hal luar biasa hanya dari "redis-cli" dan bahkan lebih lagi antara Redis dan bahasa pemrograman Anda. Tetapi kadang-kadang, perilaku yang tidak dapat diperoleh dalam arsitektur client-server karena masalah efisiensi atau keamanan mungkin diperlukan - logika perlu dijalankan di lapisan database. Dalam kasus seperti itu, Lua datang untuk menyelamatkan. Lua bekerja di Redis sebagai bahasa scripting. Dengannya, Anda dapat mengeksekusi kode di Redis, tanpa biaya transportasi ke dan dari klien.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasus uji menambahkan nilai ke bidang hash. </font><font style="vertical-align: inherit;">Sementara Redis dapat dengan mudah menambahkan nilai ke kunci string menggunakan APPEND, tidak ada perintah untuk menambahkan nilai ke bidang hash. </font><font style="vertical-align: inherit;">Anda bisa mencoba untuk mendapatkan ini dengan mengekstraksi nilai dari klien, menambahkan baris baru ke nilai dan menjatuhkan bidang hash, tetapi ini adalah ide yang buruk. </font><font style="vertical-align: inherit;">Karena ini non-atomik, ada kemungkinan bahwa saat Anda menambahkan nilai, klien lain dapat mengubahnya lebih awal, dan kemudian Anda akan menimpa nilai baru.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelanggan 1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klien 2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[halo kembali]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[menambahkan "dunia" ke "halo"]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat pada baris 2, pembaruan akan hilang. </font><font style="vertical-align: inherit;">Anda dapat menggunakan skrip Lua untuk mengatasi masalah ini dan menghapus biaya pengiriman / penerimaan nilai dari klien. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di editor teks apa pun, buat skrip dan sebut itu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terjadi.lua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di baris pertama, buat variabel lokal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asli</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana kami menyimpan nilai kunci hash saat ini dari argumen pertama yang diteruskan, dan bidang adalah argumen non-kunci pertama. Penting untuk memahami bahwa skrip runtime Lua membedakan antara kunci dan argumen non-kunci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada baris kedua, HSET dipanggil untuk kunci dan bidang yang sama, kemudian kami menggabungkan nilai asli dengan argumen non-kunci kedua. Ini kembali ke Redis, jadi kami akan menyimpan nilai pengembalian HSET asli.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eksekusi skrip Lua secara langsung dengan perintah EVAL dapat membingungkan dan tidak efisien. </font><font style="vertical-align: inherit;">Redis memiliki cache skrip bawaan yang memungkinkan Anda untuk memuat skrip, lalu mengaksesnya menggunakan hash SHA1 dari skrip utama. </font><font style="vertical-align: inherit;">Anda dapat mengunduh skrip ini dari baris perintah menggunakan "cat" dan "redis-cli". </font><font style="vertical-align: inherit;">Harap perhatikan bahwa jika skrip Anda berbeda setidaknya oleh satu karakter, skrip tersebut akan memiliki hash yang sama sekali berbeda.</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda dapat menggunakan EVALSHA untuk menjalankan skrip dan menambahkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumen pertama ke perintah EVALSHA adalah hash dari skrip yang dihasilkan oleh SCRIPT LOAD. Argumen kedua adalah jumlah kunci. Dalam kasus kami, kuncinya adalah satu. Argumen ketiga adalah kunci di mana kami melakukan tindakan. Dan akhirnya, yang keempat adalah nilai yang kita tambahkan ke bidang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena penambahan terjadi di dalam skrip Lua, skrip di atas akan dibatalkan karena skrip Lua dijalankan secara serempak dan secara atomis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun Lua bisa sangat membantu dalam menyelesaikan masalah, Anda harus menggunakannya dengan hati-hati. Skrip memblokir server dan dapat mengarah ke database yang tidak responsif. Dalam situasi beling, skrip mencoba untuk menyimpan semua operasi pada satu server untuk menghindari kesalahan silang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sinilah bagian Praktik Terbaik Redis berakhir. </font><font style="vertical-align: inherit;">Jangan takut untuk mencoba dan bereksperimen, Redis sangat kaya akan fungsi. </font><font style="vertical-align: inherit;">Tinggalkan case use yang menarik di komentar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berharap bahwa teknik yang dijelaskan akan membantu Anda jika tidak secara langsung, maka setidaknya dengan menunjuk ke jalan yang benar untuk menyelesaikan masalah!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id506574/index.html">Visualisasi daftar perempuan pemenang Hadiah Nobel dalam bentuk kristal di 3d menggunakan Vue, WebGL, three.js</a></li>
<li><a href="../id506578/index.html">Volume Timbal yang Dikelola</a></li>
<li><a href="../id506586/index.html">FizzBuzz Logis</a></li>
<li><a href="../id506588/index.html">Apa itu algoritma! (bagian 2)</a></li>
<li><a href="../id506590/index.html">ĞšĞ¾Ğ½Ñ„ĞµÑ€ĞµĞ½Ñ†Ğ¸Ñ DEVOXX UK. Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€Ğº: Docker Swarm, Kubernetes Ğ¸Ğ»Ğ¸ Mesos. Ğ§Ğ°ÑÑ‚ÑŒ 2</a></li>
<li><a href="../id506598/index.html">Microsoft: Rust ÑĞ²Ğ»ÑĞµÑ‚ÑÑ 'Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¼ ÑˆĞ°Ğ½ÑĞ¾Ğ¼' Ğ² Ğ¾Ñ‚Ñ€Ğ°ÑĞ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ñ… ÑĞ¸ÑÑ‚ĞµĞ¼</a></li>
<li><a href="../id506600/index.html">Kontrak untuk pengembangan situs dalam hal manajemen proyek (teori + sampel)</a></li>
<li><a href="../id506604/index.html">Konkurensi dan Efisiensi: Python vs FSM</a></li>
<li><a href="../id506606/index.html">Pencipta clicker PIXI.js</a></li>
<li><a href="../id506610/index.html">WAL-G: Pencadangan dan Pemulihan Basis Data PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>