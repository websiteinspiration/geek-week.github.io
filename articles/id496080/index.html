<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÜ ‚úãüèº üë¶üèø Membuat interaksi AI sederhana dengan objek lingkungan ü§õüèø üêö üë©üèæ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat membuat kecerdasan buatan untuk video game, salah satu aspek terpenting adalah lokasinya. Posisi karakter AI dapat sepenuhnya mengubah jenis peri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Membuat interaksi AI sederhana dengan objek lingkungan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496080/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membuat kecerdasan buatan untuk video game, salah satu aspek terpenting adalah lokasinya. Posisi karakter AI dapat sepenuhnya mengubah jenis perilakunya dan keputusan di masa depan. Dalam tutorial ini kita akan memahami bagaimana lingkungan game dapat memengaruhi AI dan bagaimana menggunakannya dengan benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini diambil dari buku </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktis Game AI Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang ditulis oleh Michael Dagrack dan diterbitkan oleh Packt Publishing. Buku ini memungkinkan Anda mempelajari cara membuat game AI dan dari awal menerapkan algoritma AI paling canggih.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interaksi visual adalah hal mendasar, mereka tidak secara langsung memengaruhi gameplay, tetapi memungkinkan Anda untuk meningkatkan permainan video dan karakternya dengan menjadikannya bagian dari lingkungan yang kita buat, yang sangat memengaruhi perendaman pemain dalam permainan. </font><font style="vertical-align: inherit;">Ini membuktikan kepada kita pentingnya lingkungan menjadi bagian dari permainan, dan tidak hanya membantu mengisi ruang di layar. </font><font style="vertical-align: inherit;">Interaksi serupa semakin banyak ditemukan dalam permainan, dan pemain berharap melihatnya. </font><font style="vertical-align: inherit;">Jika ada objek dalam permainan, maka itu harus memenuhi beberapa fungsi, meskipun bukan yang paling penting.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu contoh pertama interaksi dengan lingkungan dapat ditemukan di Castlevania pertama, yang dirilis pada tahun 1986 untuk Nintendo Entertainment System. </font><font style="vertical-align: inherit;">Sejak awal, pemain dapat menggunakan cambuk untuk menghancurkan lilin dan api, yang awalnya merupakan bagian dari latar belakang.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/a93/19c/90ca9319cffa8e665c51bc56297876a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dan beberapa permainan pada waktu itu membuka banyak pintu dan peluang dalam hal persepsi modern tentang latar belakang dan lingkungan karakter dalam permainan. </font><font style="vertical-align: inherit;">Jelas, karena keterbatasan perangkat keras dari generasi konsol itu, itu jauh lebih sulit untuk membuat hal-hal sederhana yang umumnya diterima oleh standar saat ini. </font><font style="vertical-align: inherit;">Tetapi setiap generasi konsol menghadirkan fitur baru dan pengembang menggunakannya untuk membuat game yang luar biasa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, contoh pertama kami interaksi visual adalah objek di latar belakang yang dapat dihancurkan tanpa secara langsung mempengaruhi gameplay. </font><font style="vertical-align: inherit;">Jenis interaksi ini ditemukan di banyak permainan. </font><font style="vertical-align: inherit;">Menerapkannya sederhana, hanya menghidupkan objek ketika diserang. </font><font style="vertical-align: inherit;">Setelah itu, kita dapat memutuskan apakah ada poin atau benda yang harus dijatuhkan dari benda yang memberi hadiah kepada pemain untuk menjelajahi permainan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita bisa beralih ke contoh berikutnya - objek dalam game yang dianimasikan atau dipindahkan ketika karakter melewatinya. Prinsipnya di sini sama dengan benda-benda yang dapat dirusak, tetapi kali ini interaksinya lebih halus - memerlukan karakter untuk bergerak ke titik di mana objek itu berada. Ini dapat diterapkan pada berbagai elemen permainan, mulai dari pergerakan rumput, debu atau air, hingga burung terbang atau orang yang membuat gerakan lucu; kemungkinannya tidak terbatas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika menganalisis interaksi ini, kita dapat dengan mudah menentukan bahwa mereka tidak perlu menggunakan AI, dan dalam kebanyakan kasus itu hanya fungsi Boolean yang diaktifkan sesuai dengan beberapa tindakan yang diberikan. Tetapi mereka adalah bagian dari lingkungan dan karenanya harus diperhitungkan ketika menerapkan interaksi berkualitas tinggi antara lingkungan dan AI.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat interaksi sederhana dengan lingkungan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang telah kita lihat, lingkungan pernah menjadi bagian dari gameplay, dan ini memunculkan banyak konsep dan ide baru untuk game masa depan. </font><font style="vertical-align: inherit;">Langkah selanjutnya adalah integrasi perubahan kecil ini dalam gameplay dan penggunaannya untuk mengubah perilaku pemain dalam game. </font><font style="vertical-align: inherit;">Hal ini jelas memengaruhi sejarah video game, karena semua elemen adegan secara bertahap mulai hidup kembali dan pemain mulai menyadari betapa kaya lingkungannya. </font><font style="vertical-align: inherit;">Menggunakan lingkungan untuk mencapai tujuan dalam game telah menjadi bagian dari gameplay.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0c6/39f/ad20c639fd190d338f6e2e72847338b1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menunjukkan satu contoh lingkungan yang secara langsung memengaruhi gameplay, kami akan mengambil contoh yang bagus - franchise Tomb Raider. Dalam contoh ini, karakter kita, Lara Croft, harus mendorong kubus hingga mendarat di area yang ditandai. Ini akan mengubah lingkungan dan membuka jalur baru, memungkinkan pemain untuk bergerak lebih jauh dalam level. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teka-teki semacam itu dapat ditemukan di banyak permainan: Anda harus melakukan suatu tindakan pada titik tertentu di peta sehingga sesuatu terjadi di bagian lain dari itu, dan ini dapat digunakan untuk mencapai beberapa tujuan dalam permainan. Biasanya kita perlu mengubah lingkungan itu sendiri untuk maju lebih jauh di level. Oleh karena itu, ketika pengembang merencanakan peta atau level, mereka mempertimbangkan ini dan membuat semua aturan yang terkait dengan setiap interaksi. Contohnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(cube.transform.position == mark.transform.position)<font></font>
{<font></font>
  openDoor = <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang bayangkan sejenak bahwa Lara Croft memiliki karakter sekutu yang tugas utamanya adalah membantunya meletakkan kotak ini di tempatnya. </font><font style="vertical-align: inherit;">Dan dalam bab ini kita akan mempertimbangkan jenis interaksi ini saja: karakter AI memahami bagaimana lingkungan bekerja dan bagaimana menggunakannya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkungan Pindah di Tomb Raider</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita langsung ke skenario ini dan mencoba untuk menciptakan kembali situasi di mana ada karakter AI yang dapat membantu pemain mencapai tujuannya. </font><font style="vertical-align: inherit;">Dalam contoh ini, kita akan membayangkan bahwa seorang pemain terjebak dari mana ia tidak bisa mendapatkan akses ke objek interaktif yang dapat membebaskannya. </font><font style="vertical-align: inherit;">Karakter yang kita buat harus dapat menemukan kubus dan mendorongnya ke arah yang benar.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi sekarang kita memiliki semua karakter dan objek. Mari kita rencanakan bagaimana karakter AI seharusnya berperilaku dalam situasi ini. Pertama, ia harus melihat bahwa pemainnya dekat, sehingga ia dapat mulai mencari dan memindahkan kubus ke posisi yang diinginkan. Asumsikan bahwa jika kubus berada di sasaran, maka blok baru muncul dari pasir, memungkinkan pemain untuk maju lebih jauh dalam level. Karakter AI dapat mendorong kubus ke empat arah: kiri, kanan, maju dan mundur, sehingga cocok dengan tanda posisi.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/463/982/8044639827005d84bcf50014f095b46e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karakter AI harus memverifikasi dan memvalidasi setiap tindakan yang ditampilkan di pohon perilaku ini. Hal pertama dan paling penting untuk melanjutkan tugas adalah bahwa karakter harus yakin bahwa pemain berada pada tandanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika pemain belum sampai di sana, maka karakter kita harus menunggu dan tetap di tempatnya. Jika pemain telah tiba di sasaran, maka karakter AI melanjutkan eksekusi dan bertanya pada dirinya sendiri seberapa jauh dia dari objek kubus. Jika tidak, maka karakter harus bergerak ke arah kubus, dan setelah tindakan ini dikonfirmasi, ia harus mengajukan pertanyaan yang sama. Ketika jawabannya menjadi positif dan karakter berada di sebelah kubus, ia harus mencari tahu ke mana Anda harus mendorong kubus terlebih dahulu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian dia mulai mendorong kubus sepanjang sumbu Y atau X sampai cocok dengan posisi menandai dan tugas selesai.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mulai menambahkan informasi ke kode yang memungkinkan karakter untuk memeriksa apakah pemain di sebelah posisi yang ditandai. Untuk melakukan ini, kami membuat semua variabel yang diperlukan untuk menghitung jarak antara pemain dan posisi di mana ia seharusnya berada. </font></font><code>playerMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengacu pada model 3D pemain, dari mana kami mengekstrak posisinya dan menggunakannya sebagai </font></font><code>currentPlayerPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengetahui apakah itu dekat dengan tanda, kita perlu variabel yang mewakili posisi tanda, dan dalam contoh kita, kita membuat variabel </font></font><code>playerMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana kita dapat menulis posisi di mana pemain seharusnya berada. Kemudian kami menambahkan tiga variabel yang memberi tahu kami jika ada pemain di dekatnya. </font></font><code>proximityValueX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menghitung jarak antara pemain dan tanda sumbu X. </font></font><code>proximityValueY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghitung jarak antara pemain dan tanda sumbu Y.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita miliki </font></font><code>nearValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana kita dapat menentukan seberapa jauh pemain bisa dari posisi tanda, ketika karakter AI dapat mulai bekerja untuk mencapai tujuan. Begitu pemain mendekati tanda, variabel Boolean </font></font><code>playerOnMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengubah nilai menjadi </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghitung jarak antara pemain dan tanda, kami menggunakan yang berikut: jarak antara pemain dan tanda-nya, serupa </font></font><code>(mark.position - player.position)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, untuk menentukan apakah karakter AI dekat kubus, kita menghitung persamaan yang sama dengan menghitung jarak antara AI dan kubus. Selain itu, kami menambahkan kode dengan posisi pada kedua nilai (pemain dan kubus):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang karakter AI kita tahu apakah dia ada di sebelah kubus, ini memungkinkan kita untuk menjawab pertanyaan dan menentukan apakah dia bisa pindah ke cabang berikutnya yang kita rencanakan. </font><font style="vertical-align: inherit;">Tetapi apa yang terjadi ketika karakter tidak di sebelah kubus? </font><font style="vertical-align: inherit;">Dia harus mendekati kubus. </font><font style="vertical-align: inherit;">Karena itu, kami akan menambahkan ini ke kode:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
   speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  { <font></font>
      playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
     PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
     Finding = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh ini, karakter AI kami dapat menghitung jarak antara dirinya dan kubus; </font><font style="vertical-align: inherit;">jika mereka terlalu jauh, maka dia akan pergi ke kubus. </font><font style="vertical-align: inherit;">Setelah menyelesaikan tugas ini, ia dapat melanjutkan ke fase berikutnya dan mulai mendorong kubus. </font><font style="vertical-align: inherit;">Hal terakhir yang perlu ia hitung adalah seberapa jauh kubus dari posisi tanda, setelah itu ia memutuskan cara mendorong, dengan mempertimbangkan sisi kubus mana yang lebih dekat dengan tanda itu.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/be5/bf7/de1be5bf7e65540dfaeb6ab186a8e3c8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubus hanya dapat didorong sepanjang sumbu X dan Z, dan rotasinya belum penting bagi kami, karena tombol diaktifkan ketika kubus dipasang di atasnya. Mengingat semua ini, karakter AI harus menghitung seberapa jauh kubus dari posisi tanda pada X dan posisi tanda pada Z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian ia membandingkan dua nilai pada dua sumbu dan memilih mana yang lebih jauh dari posisi yang diinginkan, dan kemudian mulai mendorong sepanjang ini sumbu. Karakter akan terus mendorong ke arah ini sampai kubus disejajarkan dengan posisi tanda, dan kemudian beralih ke sisi lain, dan akan mendorongnya sampai benar-benar melewati posisi tanda:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityZ;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
        Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
        nearValue = <span class="hljs-number">0.5f</span>;<font></font>
        nearCube = <span class="hljs-number">0.5f</span>;<font></font>
        speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
      PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
      Finding = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
   cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<font></font>
   cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &gt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushX();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &lt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushZ();<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menambahkan tindakan terbaru ke kode, karakter harus belajar untuk menentukan tujuannya, menemukan dan mendorong kubus ke posisi yang diinginkan sehingga pemain dapat melewati dan menyelesaikan level. </font><font style="vertical-align: inherit;">Dalam contoh ini, kami fokus pada cara menghitung jarak antara objek adegan dan karakter. </font><font style="vertical-align: inherit;">Ini akan membantu kita untuk membuat jenis interaksi serupa di mana kita perlu menempatkan objek game di posisi tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh tersebut menunjukkan karakter AI yang ramah yang membantu pemain, tetapi prinsip yang sama dapat diterapkan jika kita membutuhkan efek sebaliknya (jika karakter tersebut adalah musuh), di mana karakter perlu menemukan kubus sesegera mungkin untuk menghentikan pemain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rintangan benda-benda di lingkungan menggunakan contoh Age of Empires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang kita lihat sebelumnya, Anda dapat menggunakan atau memindahkan objek dalam permainan untuk mencapai tujuan, tetapi apa yang terjadi jika beberapa objek menghalangi jalur karakter? Objek dapat ditempatkan oleh pemain atau hanya terletak oleh perancang di posisi peta ini. Bagaimanapun, karakter AI harus dapat menentukan apa yang perlu dilakukan dalam situasi ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat mengamati perilaku ini, misalnya, dalam strategi yang disebut Age of Empires II yang dikembangkan oleh Ensemble Studios. Setiap kali karakter permainan tidak dapat mencapai wilayah musuh karena fakta bahwa itu dikelilingi oleh tembok yang diperkuat, AI beralih ke menghancurkan bagian dinding untuk melanjutkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis interaksi ini juga sangat cerdas dan penting, karena jika tidak, karakter hanya akan berkeliaran di sepanjang dinding untuk mencari pintu masuk, dan ini tidak akan terlihat seperti perilaku yang masuk akal. </font><font style="vertical-align: inherit;">Karena dinding yang diperkuat dibuat oleh pemain, itu dapat ditempatkan di mana saja dan memiliki bentuk apa pun. </font><font style="vertical-align: inherit;">Karena itu, Anda perlu memikirkan hal ini ketika mengembangkan AI musuh.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/137/655/f44137655e3220988033bcb97db85b96.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh ini juga berhubungan dengan topik artikel kami, karena pada tahap perencanaan, ketika kita membuat pohon perilaku, kita perlu berpikir tentang apa yang akan terjadi jika sesuatu menghalangi karakter dan dia tidak dapat memenuhi tujuannya. </font><font style="vertical-align: inherit;">Kami akan mempertimbangkan aspek ini secara rinci dalam bab-bab selanjutnya dari buku ini, tetapi untuk saat ini kami menyederhanakan situasi dan menganalisis bagaimana karakter AI seharusnya berperilaku jika objek lingkungan mencegahnya dari memenuhi tujuannya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/464/89b/dfb46489b482f383bc95662246308536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh kita, karakter AI harus memasuki rumah, tetapi ketika dia mendekat, dia menyadari bahwa dia dikelilingi oleh pagar kayu, yang melaluinya kamu tidak bisa melewatinya. Kami ingin karakter untuk memilih target pada tahap ini dan mulai menyerang sampai bagian pagar ini dihancurkan dan dia dapat memasuki rumah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, kita perlu menghitung pagar mana yang harus diserang karakter, mengingat jarak dan status kesehatan pagar saat ini. Pagar dengan HP rendah harus memiliki prioritas serangan yang lebih tinggi daripada pagar dengan HP penuh, jadi kami akan memperhitungkan ini dalam perhitungan kami.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/23f/ac4/22323fac4373a3556b58383bfb6b36fe.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami ingin mengatur lingkungan di sekitar karakter, di mana pagar terdekat mengirimkan informasi mereka ke kecerdasan buatan sehingga dapat memutuskan mana yang lebih mudah dihancurkan. Ini dapat diimplementasikan dengan berbagai cara, baik menggunakan pengakuan tabrakan pagar dengan pemain, atau memaksa mereka untuk menghitung jarak antara pagar / objek dan pemain; kami menetapkan nilai jarak di mana pemain mulai memahami kondisi pagar. Dalam contoh kami, kami akan menghitung jarak dan menggunakannya untuk memberi tahu karakter tentang pagar HP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan membuat kode yang akan diterapkan pada objek pagar; semuanya akan memiliki skrip yang sama:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-comment">// Use this for initialization</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  HP = <span class="hljs-number">100f</span>;<font></font>
  distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Find the Character Mesh</span>
  characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Update is called once per frame</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
  characterPosition = characterMesh.transform;<font></font>
<font></font>
  <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
  proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  nearValue = proximityValueX + proximityValueY;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skrip ini, kami menambahkan informasi dasar tentang HP dan jarak, yang akan digunakan untuk terhubung dengan karakter AI. Kali ini kami menambahkan skrip penghitung jarak tidak ke karakter, tetapi ke objek lingkungan; ini memberi objek lebih banyak dinamisme dan memungkinkan kita menciptakan lebih banyak peluang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, jika karakter permainan juga terlibat dalam pembuatan pagar, maka mereka akan memiliki status yang berbeda, misalnya, "sedang dibangun", "selesai" atau "rusak"; maka karakter akan dapat menerima informasi ini dan menggunakannya untuk tujuan mereka sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mengatur karakter yang berinteraksi dengan objek lingkungan. Tujuan utamanya adalah untuk mendapatkan akses ke rumah, tetapi ketika dia mendekatinya, dia menyadari bahwa dia tidak bisa masuk karena fakta bahwa dia dikelilingi oleh pagar kayu. Kami ingin itu, setelah menganalisis situasinya, karakter kami akan menghancurkan pagar untuk memenuhi tujuannya dan masuk ke rumah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skrip karakter, kami akan menambahkan fungsi statis, ke input yang mana pagar akan dapat mengirimkan informasi tentang "kesehatan" mereka saat ini; ini akan membantu karakter memilih pagar yang paling cocok untuk dihancurkan.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> lowerFenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fencesAnalyzed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject bestFence;<font></font>
<font></font>
<span class="hljs-keyword">private</span> Transform House;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeWasted;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        fenceHP = <span class="hljs-number">100f</span>;<font></font>
        lowerFenceHP = fenceHP;<font></font>
        fencesAnalyzed = <span class="hljs-number">0</span>;<font></font>
        speed = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
        Vector3 House = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">300.2f</span>, <span class="hljs-number">83.3f</span>, <span class="hljs-number">-13.3f</span>);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        timeWasted += Time.deltaTime;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(fenceHP &gt; lowerFenceHP)<font></font>
        {<font></font>
            lowerFenceHP = fenceHP;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(timeWasted &gt; <span class="hljs-number">30f</span>)<font></font>
        {<font></font>
            GoToFence();  <font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoToFence</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
        Vector3 positionB = bestFence.transform.position;<font></font>
        <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/970/af0/7a8970af0c9b5aa303ba32d6dc021ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami telah menambahkan informasi paling mendasar ke karakter. </font></font><code>fenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menjadi variabel statis di mana setiap pagar yang berada dalam radius lingkungan karakter akan mencatat informasi tentang HP saat ini. Kemudian karakter AI menganalisis informasi yang diterima dan membandingkannya dengan pagar dengan HP paling sedikit disajikan </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karakter memiliki variabel yang </font></font><code>timeWasted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mewakili jumlah detik yang telah dihabiskannya mencari pagar yang sesuai untuk dihancurkan. </font></font><code>fencesAnalyzed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan digunakan untuk mencari tahu apakah sudah ada pagar dalam kode, dan jika tidak, pagar pertama yang ditemukan oleh karakter ditambahkan; dalam kasus pagar memiliki nilai HP yang sama, karakter menyerang mereka terlebih dahulu. Sekarang mari kita tambahkan kode pagar sehingga mereka dapat mengakses skrip karakter dan memasukkan informasi yang berguna.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        HP = <span class="hljs-number">100f</span>;<font></font>
        distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Find the Character Mesh</span>
        characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
        characterPosition = characterMesh.transform;<font></font>
<font></font>
        <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
        proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
        proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
        nearValue = proximityValueX + proximityValueY;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(nearValue &lt;= distanceValue){
            <span class="hljs-keyword">if</span>(AICharacter.fencesAnalyzed == <span class="hljs-number">0</span>){<font></font>
                AICharacter.fencesAnalyzed = <span class="hljs-number">1</span>;<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
<font></font>
            AICharacter.fenceHP = HP;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(HP &lt; AICharacter.lowerFenceHP){<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akhirnya melengkapi contoh ini. </font><font style="vertical-align: inherit;">Sekarang pagar membandingkan HP saat ini dengan data karakter ( </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dan jika HPnya lebih rendah dari nilai terendah yang dimiliki karakter, maka pagar ini akan dipertimbangkan </font></font><code>bestFence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh ini menunjukkan bagaimana mengadaptasi karakter AI ke berbagai objek dinamis dalam game; </font><font style="vertical-align: inherit;">prinsip yang sama dapat diperluas dan digunakan untuk berinteraksi dengan hampir semua objek. </font><font style="vertical-align: inherit;">Itu juga berlaku dan berguna ketika menggunakan objek untuk berinteraksi dengan karakter, menghubungkan informasi di antara mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam posting ini, kami mengeksplorasi berbagai cara berinteraksi dengan lingkungan. </font><font style="vertical-align: inherit;">Teknik yang diperlihatkan dalam bab ini dapat diperluas ke berbagai genre permainan dan digunakan untuk melakukan interaksi sederhana dan kompleks antara karakter AI dan lingkungan.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496044/index.html">Peluncuran pesawat ruang angkasa dan ... cuaca di wilayah tersebut</a></li>
<li><a href="../id496046/index.html">Grafik 3D pada STM32F103</a></li>
<li><a href="../id496050/index.html">Harimau dan Singa mendapatkan coronavirus di New York</a></li>
<li><a href="../id496052/index.html">Bagaimana perusahaan jasa dapat menghindari denda dari pelanggan? Beberapa keunggulan otomatisasi proses yang tidak terlihat</a></li>
<li><a href="../id496056/index.html">Digital: bagaimana angka dan istilah menipu kita</a></li>
<li><a href="../id496082/index.html">Insinyur Data dan Ilmuwan Data: apa bedanya?</a></li>
<li><a href="../id496084/index.html">Toko Online Sisi Klien Blazor: Bagian 6 - Membuat Pesanan dan Bekerja dengan Tindakan Kompensasi</a></li>
<li><a href="../id496086/index.html">Mengatur Pekerjaan Jarak Jauh dengan Pekerjaan Digital Zextras</a></li>
<li><a href="../id496088/index.html">21 April Langsung! Pertemuan lokalisasi Badoo</a></li>
<li><a href="../id496090/index.html">Dihapus dengan Zyxel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>