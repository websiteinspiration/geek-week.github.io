<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏯 📳 🔜 在第一年编写游戏引擎：轻松！（几乎） 🦂 🤢 👨🏻‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好！我的名字叫Gleb Maryin，我在圣彼得堡HSE大学学习“应用数学和计算机科学”的第一年。在第二学期，我们程序中的所有新生都将使用C ++进行团队项目。我和我的队友决定编写一个游戏引擎。 
 
 阅读我们从猫身上得到的东西。
 
 
 团队中共有三个人：我，Alexei Luchinin和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在第一年编写游戏引擎：轻松！（几乎）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/504776/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你好！</font><font style="vertical-align: inherit;">我的名字叫Gleb Maryin，我在圣彼得堡HSE大学学习“应用数学和计算机科学”的第一年。</font><font style="vertical-align: inherit;">在第二学期，我们程序中的所有新生都将使用C ++进行团队项目。</font><font style="vertical-align: inherit;">我和我的队友决定编写一个游戏引擎。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
阅读我们从猫身上得到的东西。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10e/b22/0c4/10eb220c409aac5feac61a2164b42886.gif"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
团队中共有三个人：我，Alexei Luchinin和Ilya Onofriychuk。</font><font style="vertical-align: inherit;">我们谁都不是游戏开发专家，更不用说创建游戏引擎了。</font><font style="vertical-align: inherit;">这对我们来说是第一个大项目：在此之前，我们只做家庭作业和实验室工作，因此计算机图形学领域的专业人员不太可能在这里找到自己的新信息。</font><font style="vertical-align: inherit;">如果我们的想法对那些也想创建自己的引擎的人有所帮助，我们将感到非常高兴。</font><font style="vertical-align: inherit;">但是，这个主题是复杂且多方面的，并且本文决不声称是完整的专业文献。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其他对学习我们的实施感兴趣的人-请阅读！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平面艺术</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个窗口，鼠标和键盘</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了创建窗口，处理鼠标和键盘输入，我们选择了SDL2库。</font><font style="vertical-align: inherit;">这是一个随机选择，但到目前为止我们还没有后悔。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始的第一阶段，很重要的一点是在库上编写一个方便的包装器，这样您就可以创建一个包含几行的窗口，并对其进行操作，例如移动光标和进入全屏模式并处理事件：击键，光标移动。</font><font style="vertical-align: inherit;">任务并不困难：我们迅速制作了一个可以关闭和打开窗口的程序，当您单击RMB时，显示“ Hello，World！”。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后出现了主要的游戏周期：</font></font><br>
<br>
<pre><code class="cpp hljs">Event ev;
<span class="hljs-keyword">bool</span> running = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">while</span> (running):<font></font>
	ev = pullEvent();<font></font>
	<span class="hljs-keyword">for</span> handler in handlers[ev.type]:<font></font>
		handler.handleEvent(ev);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个事件处理程序都附加了- </font></font><code>handlers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如</font></font><code>handlers[QUIT] = {QuitHandler()}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他们的任务是处理相应的事件。</font></font><code>QuitHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在示例中，它将暴露</font></font><code>running = false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从而停止游戏。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你好，世界</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了绘制引擎，我们使用</font></font><code>OpenGL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">第</font></font><code>Hello World</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个，我认为，在许多项目中，是一个白色正方形的黑色背景：&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">glBegin(GL_QUADS);<font></font>
glVertex2f(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">1.0f</span>);<font></font>
glVertex2f(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<font></font>
glVertex2f(<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>);<font></font>
glVertex2f(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>);<font></font>
glEnd();</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/ed8/fbe/612ed8fbe433abd35b12b59e72aac0c7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们学习了如何绘制二维多边形，并在单独的类中进行图形处理</font></font><code>GraphicalObject2d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这些</font><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">可以随旋转</font></font><code>glRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，随和</font></font><code>glTranslate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拉伸</font></font><code>glScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们使用设置四个通道的颜色</font></font><code>glColor4f(r, g, b, a)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此功能，您已经可以制作出漂亮的正方形喷泉。</font><font style="vertical-align: inherit;">创建一个</font></font><code>ParticleSystem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有对象数组的</font><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在主循环的每次迭代中，粒子系统都会更新旧的正方形并收集一些新的正方形，它们以随机方向开始：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10e/b22/0c4/10eb220c409aac5feac61a2164b42886.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是编写可以移动并朝不同方向看的相机。</font><font style="vertical-align: inherit;">要了解如何解决此问题，我们需要线性代数的知识。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果这对您来说不是很有趣，则可以跳过本节，查看gif，然后继续阅读</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们想在屏幕的坐标中绘制一个顶点，知道它相对于其所属对象中心的坐标。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们需要找到相对于对象所在的世界中心的坐标。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，在知道摄像机的坐标和位置的情况下，找到顶点在摄像机底部的位置。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后将顶点投影到屏幕平面上。&nbsp;</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，共有三个阶段。</font><font style="vertical-align: inherit;">与三个矩阵相乘对应于它们。</font><font style="vertical-align: inherit;">我们称这些矩阵</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Projection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从获得世界基准的对象的坐标开始。</font><font style="vertical-align: inherit;">一个对象可以完成三种转换：缩放，旋转和移动。</font><font style="vertical-align: inherit;">通过将原始向量（基于对象的坐标）乘以相应的矩阵，可以指定所有这些操作。</font><font style="vertical-align: inherit;">然后矩阵</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将如下所示：&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">Model = Translate * Scale * Rotate. 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，知道摄像机的位置后，我们要确定其坐标：将先前获得的坐标乘以矩阵</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在C ++中，可以使用以下函数方便地进行计算：</font></font><br>
<br>
<pre><code class="cpp hljs">
glm::mat4 View = glm::lookAt(cameraPosition, objectPosition, up);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从字面上看：</font></font><code>objectPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从一个位置看</font></font><code>cameraPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，向上方向是“向上”。为什么需要这个方向？想象一下拍摄茶壶。您将相机对准他，然后将水壶放在框架中。此时，您可以准确说出框架在顶部的位置（最可能是水壶有盖的位置）。该程序无法为我们找出如何布置框架，这就是为什么必须指定“向上”向量的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在相机的基础上获得了坐标，剩下的就是将获得的坐标投影到相机的平面上。矩阵与此有关</font></font><code>Projection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当从我们移除对象时，它会产生减少对象的效果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要获得屏幕上顶点的坐标，您需要将向量乘以矩阵至少五次。</font><font style="vertical-align: inherit;">所有矩阵的大小均为4 x 4，因此您必须执行许多乘法运算。</font><font style="vertical-align: inherit;">我们不想为处理器核心加载许多简单的任务。</font><font style="vertical-align: inherit;">为此，具有必要资源的视频卡更好。</font><font style="vertical-align: inherit;">因此，您需要编写一个着色器：视频卡的一条小指令。</font><font style="vertical-align: inherit;">OpenGL具有类似于C的特殊GLSL着色器语言，可以帮助我们实现这一目标。</font><font style="vertical-align: inherit;">让我们不讨论编写着色器的详细信息，最好最后看看发生了什么：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c0/9f3/3cd/6c09f33cd1fb76ea4446b1c4a79f056a.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
说明：有十个正方形，彼此相距不远。</font><font style="vertical-align: inherit;">在他们的右边是旋转和移动相机的玩家。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是没有物理学的游戏？为了处理物理交互，我们决定使用Box2d库，并创建了一个</font></font><code>WorldObject2d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继承自</font><font style="vertical-align: inherit;">的类</font></font><code>GraphicalObject2d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不幸的是，Box2d不能立即使用，因此勇敢的Ilya为b2Body和该库中的所有物理连接编写了包装。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/68a/807/1fa68a80750c650cb3d3f947a6f58d54.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在那一刻之前，我们一直认为要使引擎中的图形绝对是二维的，并且如果要决定添加灯光，请使用光线投射技术。</font><font style="vertical-align: inherit;">但是我们手上有一台很棒的相机，可以显示所有三个维度的物体。</font><font style="vertical-align: inherit;">因此，我们为所有二维对象增加了厚度-为什么不呢？</font><font style="vertical-align: inherit;">另外，在将来，这将使您能够制作出非常漂亮的照明，从而不会留下厚实物体的阴影。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
案件之间出现了照明。</font><font style="vertical-align: inherit;">要创建它，必须编写用于绘制每个像素的适当指令-片段着色器。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/460/faf/f88/460faff88bbc07d7b466c0c9d7a12f4b.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">贴图</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用DevIL库上传图像。</font><font style="vertical-align: inherit;">每个都</font></font><code>GraphicalObject2d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适合作为该类的一个实例</font></font><code>GraphicalPolygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-对象的前部分-和</font></font><code>GraphicalEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-侧面部分。</font><font style="vertical-align: inherit;">在每个上，您都可以拉伸纹理。</font><font style="vertical-align: inherit;">第一个结果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8db/847/a6f/8db847a6fddf768afc0cd175a7368b98.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图形所需的一切都准备就绪：绘图，一个光源和纹理。</font><font style="vertical-align: inherit;">图形-仅此而已。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态机，设置对象的行为</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个对象，无论它可能是什么-状态机中的状态，图形或物理状态-都必须“滴答”，也就是说，游戏循环的每次迭代都会更新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以更新的对象继承自我们创建的Behavior类。它具有的功能</font></font><code>onStart, onActive, onStop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可让您在启动时，生命周期和活动结束时覆盖继承人的行为。现在我们需要创建一个</font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从所有对象调用这些函数</font><font style="vertical-align: inherit;">的最高</font><font style="vertical-align: inherit;">对象。执行此操作的循环函数如下：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span>:
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-title">onAwake</span><span class="hljs-params">()</span></span>;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;awake = <span class="hljs-literal">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span> (awake):<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onStart();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running = <span class="hljs-literal">true</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span> (running):<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onActive();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onStop();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;onDestroy();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在</font></font><code>running == true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，有人可以调用一个函数</font></font><code>pause()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，做</font></font><code>running = false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果有人呼叫</font></font><code>kill()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font></font><code>awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>running</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转向</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，和活动完全停止。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们想暂停一组对象，例如一个粒子系统和其中的粒子系统。在当前状态下，您需要手动调用</font></font><code>onPause</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个对象，这不是很方便。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个人</font></font><code>Behavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都有一个</font></font><code>subBehaviors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要更新</font><font style="vertical-align: inherit;">的数组</font><font style="vertical-align: inherit;">，即：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span>:
	<span class="hljs-title">onStart</span><span class="hljs-params">()</span> 		<span class="hljs-comment">//     </span>
	<span class="hljs-keyword">for</span> sb in subBehaviors:
		sb.<span class="hljs-title">onStart</span><span class="hljs-params">()</span>	<span class="hljs-comment">//       Behavior</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">onActive</span><span class="hljs-params">()</span>:
	<span class="hljs-title">onActive</span><span class="hljs-params">()</span>
	<span class="hljs-keyword">for</span> sb in subBehaviors:
		sb.<span class="hljs-title">onActive</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依此类推，针对每个功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，并非每种行为都可以通过这种方式设置。例如，如果一个敌人在平台上行走，那么该敌人很可能具有不同的状态：他站立</font></font><code>idle_stay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在平台上行走而没有注意到我们</font></font><code>idle_walk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且随时可以注意到我们并进入攻击状态</font></font><code>attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我还想方便地设置状态之间转换的条件，例如：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTransitionActivated</span><span class="hljs-params">()</span>: 		<span class="hljs-comment">//  idle_walk-&gt;attack</span>
	<span class="hljs-keyword">return</span> <span class="hljs-title">canSee</span><span class="hljs-params">(enemy)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所需的模式是状态机。</font><font style="vertical-align: inherit;">我们还让她成为继承人</font></font><code>Behavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为每次打勾时都需要检查是否已经到了切换状态的时间。</font><font style="vertical-align: inherit;">这不仅对游戏中的对象有用。</font><font style="vertical-align: inherit;">例如，</font></font><code>Level</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个state </font></font><code>Level Switcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，控制器机器内部的转换是游戏中切换关卡的条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状态分为三个阶段：开始，滴答作响，停止。</font><font style="vertical-align: inherit;">您可以在每个阶段添加一些动作，例如，将纹理附加到对象，对其施加脉冲，设置速度等等。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望能够在编辑器中创建一个关卡，并且游戏本身应该能够从已保存的数据中加载关卡。因此，所有需要保存的对象都从class继承</font></font><code>NamedStoredObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它存储带有名称，类名的字符串，并具有</font></font><code>dump()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将有关对象的数据转储到字符串中的功能。&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要进行保存，只需</font></font><code>dump()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每个对象</font><font style="vertical-align: inherit;">覆盖即可</font><font style="vertical-align: inherit;">。加载是从包含有关对象的所有信息的字符串构成的构造函数。当为每个对象创建这样的构造函数时，下载完成。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，游戏和编辑器几乎是同一类，只是在游戏中，级别是在读取模式下加载的，而在编辑器中是记录模式的。该引擎使用rapidjson库从json写入和读取对象。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形用户界面</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某个时候，问题摆在我们面前：让图形，状态机以及所有其他东西都被编写。</font><font style="vertical-align: inherit;">用户如何使用它编写游戏？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在原始版本中，他将必须继承</font></font><code>Game2d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并重写</font></font><code>onActive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并在类的字段中创建对象。</font><font style="vertical-align: inherit;">但是在创建过程中，他看不到自己正在创建的内容，并且还需要编译程序并链接到我们的库。</font><font style="vertical-align: inherit;">恐怖！</font><font style="vertical-align: inherit;">会有好处-人们可能会问到人们可能想像到的如此复杂的行为：例如，移动这块土地与玩家的生活一样多，并且前提是天王星位于金牛座并且欧元不超过40卢布。</font><font style="vertical-align: inherit;">但是，我们仍然决定制作图形界面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图形界面中，可以对一个对象执行的动作数量将受到限制：在动画幻灯片中翻页，施加力，设置一定的速度等等。状态机中的过渡情况相同。在大型引擎中，通过将当前程序与另一个程序链接来解决有限动作的问题-例如，Unity和Godot使用C＃绑定。通过此脚本，您可以执行任何操作：查看天王星所在的星座以及当前的欧元汇率是多少。目前我们尚无此功能，但我们的计划包括将引擎与Python 3连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了实现图形界面，我们决定使用Dear ImGui，因为它非常小（与著名的Qt相比）并且编写起来非常简单。</font><font style="vertical-align: inherit;">ImGui-创建图形界面的范例。</font><font style="vertical-align: inherit;">在其中，主循环的每次迭代，所有窗口小部件和窗口都仅在必要时重绘。</font><font style="vertical-align: inherit;">一方面，这减少了消耗的内存量，但另一方面，它很可能花费比执行复杂功能创建和保存必要信息以进行后续绘制所需的时间更长的时间。</font><font style="vertical-align: inherit;">仅保留实现用于创建和编辑的接口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文发布时的GUI如下所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/e87/f8e/09ae87f8eea964d382f07b411991d6d4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关卡编辑器</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/b2e/1bd/93bb2e1bd41ab656341a78fd3dd04102.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态机编辑器</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们仅创建了您可以挂起更多有趣内容的基础。换句话说，还有增长的空间：您可以实现阴影渲染，可以创建多个光源，可以将引擎与Python 3解释器连接以编写游戏脚本。我想完善该界面：使其更美观，添加更多不同的对象，支持热键... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仍有很多工作要做，但我们对目前的状况感到满意。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在创建项目的过程中，我们获得了很多不同的经验：使用图形，创建图形界面，使用json文件，大量C库的包装。还有编写团队中第一个大项目的经验。我们希望我们能够讲述它的有趣之处和处理它的有趣之处:)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
链接到gihab项目：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/Glebanister/ample</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN504766/index.html">我们如何参观阿沙的冶金厂</a></li>
<li><a href="../zh-CN504768/index.html">Yandex中的分析师实习：测试任务分析</a></li>
<li><a href="../zh-CN504770/index.html">Linux游戏发行版</a></li>
<li><a href="../zh-CN504772/index.html">6月1日至7日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN504774/index.html">IT管​​理人员有关IT服务需求变化的调查</a></li>
<li><a href="../zh-CN504780/index.html">NSA，Ghidra和独角兽</a></li>
<li><a href="../zh-CN504784/index.html">Sectigo的AddTrust根证书于2020年5月30日到期，这在OpenSSL 1.0.x和GnuTLS客户端中引起了问题</a></li>
<li><a href="../zh-CN504786/index.html">您需要了解的有关缓存的所有信息</a></li>
<li><a href="../zh-CN504790/index.html">机器学习文章精选：2020年5月的案例，指南和研究</a></li>
<li><a href="../zh-CN504792/index.html">值班宿舍。NSPK如何从冠状病毒中拯救其值班室</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>