<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚒 🔍 🏀 コロナウイルスとスティックからのZXスペクトラム（実際には、実際にはそうではない） 👩🏿‍💼 🏭 ✋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自己分離は現代人類の惨劇です。ここでは、たとえば、金曜と土曜の近隣の街で、午後8時の伝統的な拍手の後、バルコニーコンサートを開催しています。彼らは気分が良く、家は高く、隣人は若い。私たちの隣人は高齢者であり、彼らはコンサートを望んでいません。そして、家は低く、それも怠惰の一因にはなりません。したがっ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コロナウイルスとスティックからのZXスペクトラム（実際には、実際にはそうではない）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己分離は現代人類の惨劇です。ここでは、たとえば、金曜と土曜の近隣の街で、午後8時の伝統的な拍手の後、バルコニーコンサートを開催しています。彼らは気分が良く、家は高く、隣人は若い。私たちの隣人は高齢者であり、彼らはコンサートを望んでいません。そして、家は低く、それも怠惰の一因にはなりません。したがって、できる限り助かります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
午後、リモートサイトで、それほど悪くない。夜のように、子供たちが眠りに落ちるまで。最初の数日のように、本がなくなり、シリーズが退屈するまで。しかし、1か月が経過し、次の月が続きます。魂は古い鉄を必要とします。だけでなく、倒錯も伴います。そして、ゴミ箱をくまなく調べたところ、Zilog Z80プロセッサが見つかりました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f1/fe7/7c9/7f1fe77c9972b2270ad8478702521555.jpg" alt="画像"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は言わなければならない、私はこのプロセッサーが本当に好きだ。おそらく私が彼について気に入っている唯一のものは486番目のチップですが、ブレッドボードに挿入するのは難しく無意味なので、私の手はすぐには届きません。はんだ付けする必要があります。でも、まだはんだ付けしたくないです。 Z80本体よりもさらに、私はそれをベースに構築されたZX Spectrumコンピュータが大好きです。しかし、ネイティブのスペクトラムはULAカスタムロジックチップの形で災害に見舞われており、その緩やかな側のクローンは、構築や改良が特に難しいわけではありませんが、それでもブレッドボードモデルには向いていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここのスマートでバランスのとれた適切なリーダーは、停止する前に読み取りを停止するか、「1つのFPGAマイクロ回路がSpectrumコンピュータクラスに対応する」などの何かを投げます。バランスは取れていますが、私は賢くなく、十分ではありませんが、FPGAについてはクールだということしか知りません。 arduinoしかできない。しかし、本当にZ80のワイヤーを突いたいと思っています。非常に。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はじめましょう</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん始めましょう。しかし、最初に、免責事項。</font></font><b>,   ,   ,    .  —       .      ,    , .      ,    (,   ?), ,   ,   ,     ,  .       ,    ,  ,   ,   ,    .</b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、適切な8ビットコンピュータとは何ですか。これは実際にはROMとRAMに接続されたプロセッサであり、側面には複合画面に表示するための2つのカウンターがあります。時々、きしむタイマー。 ZXスペクトラムは、1つを除いて、従来の方式と同じです。 ULAがあります。これは実際、スペクトラムの「チップセット」です。 ULAは、テープレコーダー、ツイーター、キーボード（一部）などの周辺機器を管理し、画面に出力します（そうです、統合されたビデオカードは、主流になる前からSpectrumチップセットに表示されていました）。共有メモリアル、つまり最初の16 KiBのRAM（アドレスは0x4000から0x5B00）もありました。それから、ULAは画面上にコンポジットを描画し、必要のないときにZ80がそこに手を出さないようにするため、ZAのクロック信号がULAから送られてきたため、必要に応じてULAはプロセッサを停止できました。つまり、ULAがメモリを操作して検出された場合、プロセッサもこのメモリに忍び込みます（このため、MREQとA15とA14のラインを常に監視しています）。プロセッサが必要な処理を完了するまで、プロセッサのクロックを停止しました。ちなみに、バス上のデータ破損を回避するために、プロセッサ側とULA側のバスの一部は...抵抗器によって区切られていました。さらに、メモリはULA側からバス上に置かれていたため、衝突が発生した場合、プロセッサ側からのデータとアドレスは完全に無視されました。プロセッサからのデータとアドレスを完全に無視しました。プロセッサからのデータとアドレスを完全に無視しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、SpectrumにはROM（アドレス0x0000-0x3FFF）と独自のプロセッサメモリ（0x8000-0xFFFF）があり、ULAはアクセスできず、プロセッサはこの領域のULAに干渉しなかったため、16 KiBの共有メモリよりも高速に動作しました。 。しかし、それはコンピュータの48Kバージョンでのみでした。基本バージョンでは、ROMとULAと互換性のある16 KiBしかありませんでした。私たちは彼女から始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Z80プロセッサがDRAMを再生成できるのは便利ですが、SRAMは見つけやすく、マルチプレクサがない（または見つからない）ため、どうしても気になりたくありません。したがって、SRAMを使用します。まず、メインスケルトンを組み立てます。メインスケルトンの上に、他のすべてのものを掛けることができます。スケルトンはプロセッサ、ファームウェア付きのROM、SpectrumのアドレスにマップされたRAM、RAMの後に最初の16 KiBにマップされ、すべてをラップするためのチップといくつかのチップ...中国語のレイアウトがあるため、長い間回転したくなかったと言わなければなりません。 ibeeの2個入り$ 1。しかし、私にとって、大騒ぎはそれだけの価値があります。長い間いじりたくない場合は、適切なレイアウトを使用してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Z80をインストールします。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">データシート</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
からわかるように</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/n6/i0/een6i0aw3zjgv2b4gah5oo9t2ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサには、アドレスバス、データバス、システム制御、プロセッサ制御、プロセッサバス制御、ウェル、電力、クロックのグループに分けられた40ピンがあります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">図からわかる</font></a><font style="vertical-align: inherit;">ように、これらの結論のすべてがZXスペクトラムなどの実際のシステムで使用されるわけではありません</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。スペクトラムの「プロセッサ制御」グループのうち、INT信号とRESET信号のみが使用されます。信号M1は「システム制御」グループからは使用されず、「バス制御」グループはまったく使用されません。これには理由があります。古い8ビットシステムは非常にシンプルで、Spectrumはできるだけシンプルであるという考えで作成され、無視できるものはすべて無視されました。もちろん、周辺機器メーカーは割り込み（INTおよびNMI信号）を使用でき、それらは拡張スロットにルーティングされましたが、NMIはスペクトル自体では使用されませんでした。上の図からわかるように、NMI、WAIT、BUSREQ信号は低レベルでアクティブ化された入力であるため（これは信号名の上のバーで示されます）、論理ユニット（つまり、+ 5V）が存在する必要があるため、電源抵抗によってプルアップされます。神は不必要な合図を禁止しました。そしてここに調査結果があります、BUSACK、HALT、M1。何にも接続されていない空中にぶら下がっています。ちなみに、スペクトラムには​​リセットボタンがないことに注意してください。リセットピンは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データシートによると、RESETをオンにした後、プロセッサが動作モードに入るには少なくとも3クロックサイクルがアクティブである必要があるため、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">RCチェーン</font></a><font style="vertical-align: inherit;">から電源へ（RESETもローレベルでアクティブ化されます）。このRC回路は、コンデンサが抵抗器を介して高レベルに充電されるまで、低レベルを維持します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの信号について簡単に説明しましょう：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M1。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは必要としていない。彼はプロセッサが次の命令を実行し始めたことを報告します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MREQ。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それが必要。プロセッサがメモリにアクセスしていることを報告します。この信号が低くなる（つまり、電源グランドに接続される）場合、プロセッサに接続されているメモリをアクティブにする必要があります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それが必要。プロセッサが周辺機器にアクセスしていることを報告します。たとえば、キーボードに。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それが必要。プロセッサがメモリ（MREQがアクティブの場合）またはペリフェラル（IOREQ）からデータを読み取ることを通知します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それが必要。プロセッサがメモリ/周辺機器にデータを書き込むことを報告します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFSH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それが必要。一般に、この信号はダイナミックメモリ（DRAM）に必要です。アドレッシングがより困難であるため（マトリックスではなく、リニアではない、つまり、マルチプレクサーをインストールする必要があるため）、私はそれを使用する予定はありません。また、一般的に、現在の状況では、低容量のSRAMマイクロ回路の方が簡単です。ただし、プロセッサ自体がメモリバス上のアドレスを並べ替えることによってDRAMを再生成するため、この信号により、再生成サイクルを無視して、アクティブなRFSHでメモリをアクティブ化することができなくなります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HALT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。必要ありません。プロセッサが停止していることを示します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待つ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。必要ありません。この信号は、プロセッサに少し停止して待機するように要求するために必要です。通常、低速のペリフェラルまたはメモリで使用されます。しかし、スペクトルではありません。 Spectrum周辺機器（ULA）でプロセッサを停止することを決定すると、プロセッサへのクロック信号の送信が停止されます。 WAITを受信した後、プロセッサがすぐに停止しないため、これはより信頼性が高くなります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。割り込み。まだはっきりしていません。まだ必要ではないものとします。次に、それを理解します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NMI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。マスクできない中断。スーパー割り込み。必要はありません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リセット</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それがなければ飛行しません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。必要ありません。データ/アドレスバスおよび制御信号から切断するようプロセッサに要求します。一部のデバイスがバスを制御したい場合に必要です。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブサック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。必要ありません。 BUSREQを実行したデバイスに、バスが空いていることを通知する働きをします。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時計</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。クロック信号。明らかに、彼は必要です。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">食事</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も必要です。 + 5V / GNDのみの開発者への栄光。あなたのための3つのストレスはありません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A0〜A15</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はアドレスバスです。プロセッサは、適切な呼び出し時に、メモリアドレス（MREQアクティブ）またはI / Oポートアドレス（IOREQアクティブ）を出力します。ご覧のとおり、バスの幅は16ビットで、64 KiBのメモリを直接アドレス指定できます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D0-D7-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データバス。プロセッサはそれに要求を出力する（WRアクティブ）、またはそこから読み取る（RDアクティブ）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、ブレッドボードにプロセッサーを配置します。だから彼の結論は物理的に位置しています：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/b3f/2c4/dcbb3f2c401007d7aa3e1083e403f301.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電源を接続します（ピン11および29）。念のため、これらの脚の間に10 pFのコンデンサも挿入しました。しかし、彼は結局私を助けませんでした。ピン27、23、18は、何にも接続されていないままにすることができます。ピン26、25、24、17、16は、抵抗器（私は10 kOhmを使用）を介して電源に接続されています。アドレスバス（ピン1〜5および30〜40）をブレッドボードの反対側に、データバス（ピン7〜10および12〜15）をプロトタイプの電源バスから作られた別のデータバスに接続しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピン6（クロック信号）と26（リセット）はArduinに接続（後で）して、Arduinからプロセッサを制御できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはこのように判明しました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/in/rx/jminrxjfjixmm4pod6jhxw3kzfy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上からワイヤーに注意を払うまで、それらはROMからのものですが、後でそれについて説明します。また、プロセッサの横の写真には、もう1つのチップが表示されています。アドレスの上位ビットをデコードするために必要です。上で述べたように、Spectrumには3種類のメモリがあります。アドレス空間の下位16 KiBはROMです。したがって、端子A14とA15が低状態（0ボルト）の場合、ROMチップ以外のすべてをバスから切断する必要があります。次は16 KiBの共有メモリです。したがって、出力A15が低く、A14が高い（+5ボルト）場合は、このメモリをバスに接続する（そして残りを切断する）必要があります。さて、32 KiBの高速メモリが登場します。このメモリは後で接続し、出力A15がハイ状態の場合にアクティブにします。さらに、アクティブなときのみメモリをアクティブにすることを忘れないでください（ここでは、アクティブ-低、0ボルト）MREQおよび非アクティブ（ここでは、非アクティブ-高、+ 5V）RFSH。これはすべて、74HC00やOrthodox K155LA3などの同じNANDで標準ロジックに実装するのは非常に簡単です。このタスクは幼稚園の準備グループを対象としていることを理解していますが、真実の表では自由と監禁のみで考えることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに完全なハーレクイン図</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。そこからU4が描かれている部分を簡単に取ることができます（74HC138、幸いにも私はそれらを約100個持っています）。</font><font style="vertical-align: inherit;">上位32KiBは今のところ対象外なので、明確にするためにU11は無視します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続は非常に簡単です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">簡単な説明</font></a></font><br>
<br>
<img src="https://habrastorage.org/webt/2h/my/p2/2hmyp2xuiiuejpixie4e1mnoo1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
からわかる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ように</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、マイクロ回路は、端子1〜3で000〜111の2進数を受信し、この番号に対応する8つの出力（レッグ7および9〜15）の1つをアクティブにするデコーダーです。</font><font style="vertical-align: inherit;">3ビットに格納できるのは8つの異なる数値のみであるため、8つの出力しかありません。</font><font style="vertical-align: inherit;">ご覧のとおり、結論は逆になっています。つまり、アクティブになる結論は0Vのレベルになり、その他すべてのレベルは5Vになります。</font><font style="vertical-align: inherit;">さらに、タイプ「I」の3入力ゲートの形式のキーがチップに組み込まれており、3つの入力のうち2つも反転されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、デコーダ自体を次のように接続します。最上位ビット（3番目のレグ）をグラウンドに接続すると、常に0になります。中央のビットはラインA15にあります。プロセッサがメモリの上位32KiB（アドレス0x8000-0xFFFF、またはバイナリで1000000000000000-1111111111111111、最上位ビットが常に1に設定されている場合）にアクセスする場合のみ、1が存在します。最下位ビットをA14行に接続します。高レベルは、最初の16 KiBの後、上位32 KiB（アドレス0x4000-0x7FFF、または0100000000000000-0111111111111111のバイナリ形式）またはアドレスの最新の16 KiBのいずれかにアクセスする場合です。スペース（アドレス0xB000-0xFFFF、またはバイナリ形式の1100000000000000-1111111111111111）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれの場合の出力を見てみましょう。</font></font><br>
<br>
<ul>
<li>  14  15    ,       16  ,    ,     000,  0    (    ),     Y0 (15 ).      ,      .</li>
<li>  14   ,   15 —  ,         16 ,   32 ,    001,  1   ,     Y1 (14 ).      ,  16 ,       .</li>
<li>  14   ,   15 —  ,     -  32   48 ,    010,     Y2 (13 ).      ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方のライン（A14とA15）がアクティブな場合、プロセッサはメモリの上位16 KiB（48から64 KiB）にアクセスしますが、それがないため、Y3ピン（12番目のピン）も空中にあります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、別の要素のおかげで、入力4と5が低く、6が高い場合にのみ、マイクロ回路はその結果をアクティブにします。</font><font style="vertical-align: inherit;">4番目の入力は常にLow状態です（直接グランドに接続されています）。5番目の入力は、プロセッサがメモリにアクセスしているときにのみLowになります（Low状態のMREQはメモリにアクセスすることを意味します）。6番目の入力は、プロセッサが更新サイクルを実行していないときにHighになります。 DRAM（SRAMがあるため、DRAMの更新サイクルは無視するだけの最も安全な方法です）。</font><font style="vertical-align: inherit;">それは素晴らしいことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次にROMを入れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はW27C512を選びました。なぜなら、それは安くて、明るくて、すべてが収まって、あなたはまた銀行に預けることができるからです。 64KiB！ 4つのファームウェアをアップロードできます。まあ、私はこれらのマイクロ回路の約100万を持っています。ハーレクインではA15レッグが+ 5Vに接続されており、A14はジャンパーで調整可能であるため、私は上半分だけを縫うことにしました。このようにして、Harlequinのファームウェアをテストして、長い間混乱しないようにできます。 Smorim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データシート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ブレッドボードにチップを置きます。ここでも、右隅に配置して、アドレスバスを左側に配置します。脚A15を電源に引き、A14配線を地面に引きます。配線-これは、メモリバンクを変更できるようにするためのものです。 A15は常に高レベルであるため、上位32 KiBフラッシュドライブのみが利用可能になります。これらのうち、A14ラインは上部（+ 5V）または下部（グランド）16 KiBを選択します。それらで、私</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">は</font></a><font style="vertical-align: inherit;">プログラマーで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">テスト画像</font></a><font style="vertical-align: inherit;">を塗りました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48K BASIC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファームウェア</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの14本のアドレスライン（A0〜A13）は、左側のアドレスバスに接続されています。データバス（Q0〜Q7）を、ブレッドボードモデルからのパワーバスの形の即席バスに接続します。食べ物もお忘れなく！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に制御信号です。</font><font style="vertical-align: inherit;">OEは出力イネーブルです。</font><font style="vertical-align: inherit;">プロセッサがデータを読み取るときに、データバスにデータを送信するためにROMが必要です。</font><font style="vertical-align: inherit;">したがって、RDプロセッサの出力に直接接続します。</font><font style="vertical-align: inherit;">都合のよいことに、ROM上のOEとプロセッサ上のRDの両方のピンがLow状態でアクティブです。</font><font style="vertical-align: inherit;">これは重要です。何も反転させる必要はありません。</font><font style="vertical-align: inherit;">さらに、ROMにはCS入力があり、ロー状態でもアクティブです。</font><font style="vertical-align: inherit;">この入力がアクティブでない場合、ROMは他のすべての信号を無視し、データバスに何も出力しません。</font><font style="vertical-align: inherit;">この入力を74HC138チップのY0ピン（15ピン）に接続します。これはLow状態でもアクティブです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハーレクイン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回路では、</font><font style="vertical-align: inherit;">この信号は何らかの理由で抵抗を介して接続されます。</font><font style="vertical-align: inherit;">同じことをします。</font><font style="vertical-align: inherit;">なぜかわかりません。</font><font style="vertical-align: inherit;">たぶん賢い人たちはコメントで教えてくれます... </font><i><font style="vertical-align: inherit;">彼らは</font></i><font style="vertical-align: inherit;">私に</font><i><font style="vertical-align: inherit;">言い</font></i><font style="vertical-align: inherit;">ました</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">感謝、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">： </font></font><blockquote>  .       ,    «» .            .</blockquote></i><br>
<br>
<img src="https://habrastorage.org/webt/1k/n7/h3/1kn7h3nfgruh121jefz2qfhucts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今RAM。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサーだけでなくULA、または私たちの場合はArduinoもRAM（16 KiBを使用）で動作するため、これはさらに困難です。画面に表示されているものを読む必要があるので。したがって、制御信号とRAMアドレスバスをプロセッサから切断できる必要があります。データバスは切断せず、元のスペクトル（およびハーレクイン）のように動作します。バスを抵抗（470〜500オーム）で分割します。一方では、抵抗はプロセッサとROM、他方ではRAMとArduinoになります。したがって、データバスで競合が発生した場合、2つの独立したバスとして機能します。ただし、残りの部分では</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">現在のSpeccy</font></a><font style="vertical-align: inherit;">では</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ハーレクイン</font></a><font style="vertical-align: inherit;">（図のU43、U44）の</font><font style="vertical-align: inherit;">ように</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ますが</font></a><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抵抗もありました（一方でIC1の間、これはULAで、他方でIC3、IC4）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は8ビットバスバッファです。しかし、2つの制御信号（RD-メモリからの読み取りとRAM自体をアクティブにするCEの場合）とアドレスの14ビットがあります：上記の74HC138のみを使用してメモリへの信号をすでに生成していることに注意してくださいプロセッサがA14を非アクティブにしてA14をアクティブにした場合、アドレスの追加のデコードを行う必要はありません。メモリは、ROMの後の最初の16 KiBにアクセスするときにのみ機能します。もちろん、16 KiBをアドレス指定するには、14行のアドレス行（A0〜A13）が必要です。合計で16の信号が取得されるため、2つの74HC245マイクロ回路が必要です。それらをアドレスバスの代わりに左側のブレッドボードに接続します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
74HC245のデータシートから、一般に、マイクロ回路をどちらに接続するかは問題ではないことは明らかですが、レイアウトを下から上に構築し始め、他のすべてのマイクロ回路は最初のピンを左にしてインストールされているため、アドレスバスはサイドA（ピン2 -9チップは、データシートではA0〜A7と指定されています。 RAMがアドレスを設定することはなく、アドレスを受信するだけなので、転送方向は常にプロセッサからRAMです。 74HC245では、ピン1（DIR）が送信の方向を担当します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">データシートに</font></a><font style="vertical-align: inherit;">よると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B側でA側の入力と等しい出力が存在するようにするには、DIRをHIGHに設定する必要があります。したがって、両方の回路の1番目のピンを+ 5Vに接続します。 OE（20ピン、ローレベルでアクティブ化）は、配線を使用してグランドに接続されているため、すばやく+ 5Vに切り替えてプロセッサから切り離すことができます。さらにシンプル。両方のチップの電源を接続します。右のマイクロ回路の右端のピン（8番目と9番目のピン、入力A6とA7）が制御信号になります。 A7をプロセッサのRD端子に接続し、A6を74HC138チップのY1ピンに接続しました。これは、プロセッサがRAMにアクセスするときにのみローレベルになるためです。両方のマイクロ回路のサイドAからの残りの結論（左側はレッグ2〜9、右側はレッグ2〜7）をアドレスバスの端子A13〜A0に接続しました。 74HC138からの信号ですでにデコードされているため、アドレスの上位2ビットは必要ありません。次に、RAM自体について説明します。当然、私はすでに持っていたもの、つまり古いマザーボードのキャッシュチップを使用しました。私は遭遇しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IS61C256</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は20 nsですが、どれでも</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">かまい</font></a><font style="vertical-align: inherit;">ません。 Speccyは3.5 MHzの周波数で動作しましたが、今のところは通常、Arduinkiを扱います。 100kHzが出れば幸せがあります！それで、接続します。もちろん、食べ物も忘れないでください。結論I / O0-I / O7は、抵抗の後、データバスのブレッドボードに接続されます。私は幸運でした（実際、そうではありませんでした）。私の中国のモックアップでは、電力バスは真ん中で分割されています。この機能を使用して、バスを抵抗で分離しました。あなたのレイアウトが間違っている場合、あなたは</font><s><font style="vertical-align: inherit;">倒錯</font></s><font style="vertical-align: inherit;">する必要があります</font></font><s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のデータバスを作り、それを抵抗器で最初のものに接続します。 A0-A13の結論は、74HC245チップの対応するB-結論に投げられます。右端のチップがデータバスではなく制御信号に接続されていることを忘れないでください。 A14-選択により、グランドまたは+ 5Vのいずれか。 32 KiBチップなので、この結論により、どちらを使用するかが決まります。 16 KiB SRAMが見つかった場合、その中にA14ラインはありません。出力は、WE（書き込みイネーブル）、CE（チップイネーブル）、およびOE（出力イネーブル）です。すべてがアクティブになっています。 OEはプロセッサのRDに接続する必要がありますが、直接ではなく、右側の74HC245を介して接続する必要があります。この場合、RDはA7フットに到達し、それに応じてB7フット（11番目のピン）からも到達します。そこに接続します。 CEは、アドレスをデコードする74HC138からY1に接続する必要があります。彼女の信号は、それぞれ右のチップ74HC245のA6で届きます。足B6（12ピン）から出てきます。 WRプロセッサの出力に直接接続しました。また、OE信号からのジャンパー線を取り付けて、ブレッドボードの未使用部分に貼り付けました。このワイヤーを電源グランドに接続することで、ArduinkaからRAMを読み取るときにRAMを強制的にアクティブにすることができます。それでも、10 kOhmの抵抗を使用して、RAMのすべての制御信号を+ 5 Vに引き上げました。念のため。それはこのように判明しました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/0k/3h/9y0k3ht6ehvrsvzoehp70h428mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、ここで、そして仮にそうであったとしても、最初に、タイヤの信号のタイミングに関する教育プログラムがあるはずです。私よりもはるかにインテリジェントな人々によってネットワーク上で何度も行われているので、私はこれをしません。興味がある人のために、私はこのビデオをお勧めします：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i_wrxBdXTgM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、このチャンネルに登録しておらず、プロではなくアマチュアとしてエレクトロニクスに興味がある場合は、ぜひお勧めします。これは非常に高品質なコンテンツです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的には、これでほぼすべてです。 ArduinoでRAMからデータを読み取る方法を理解する必要があるだけです。まず、必要なArduinkiの結論の数を計算してみましょう。クロック信号を与えてRESETを制御する必要があります。これらは2つのピンです。データバスの8ビット-別の8ピン。さらに、13ビットのアドレス、合計23ピン。さらに、Arduinkaと通信する必要があります。これは彼女のシリアルインターフェイスを介して行います。これは別の2ピンです。残念ながら、私のDNAに関する結論は20しかありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、それは問題ではありません。 Arduinoを持っていて、74HC595を持っていない人を私は知りません。キットのみで販売されているようです。少なくとも私は595x以上の74HC00チップしか持っていません。したがって、それらを使用します。さらに、Arduinoを使用した595xの作業は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ここ</font></a><font style="vertical-align: inherit;">で完全に説明されて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">いる</font></a><font style="vertical-align: inherit;">ため、記事のスペースを節約し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 595mi住所を生成します。チップには2個が必要です（アドレスの13ビットがあり、595番目には8つのピンがあるため）。バス拡張のためにいくつかの595xを接続する方法は、上記のリンクで詳細に説明されています。そのリンクの例では、OE（ピン13）595xがグランドに接続されていることにのみ注意します。 595xピンはRAMアドレスバスに直接接続されるため、そこにArduinkiから信号を送信しますが、そこにスプリアス信号は必要ありません。 595xピンをRAMアドレスバスに接続した後、モックアップでこれ以上行う必要はありません。 arduinkaを接続する時間です。しかし、最初にスケッチを書きます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_CLOCK_PIN 2</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_RESET_PIN 3</span><font></font>
<font></font>
<span class="hljs-comment">// RAM defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_OUTPUT_ENABLE_PIN 4</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_WRITE_ENABLE_PIN 5</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_CHIP_ENABLE_PIN 6</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_BUFFER_PIN 7</span><font></font>
<font></font>
<span class="hljs-comment">// Shift Register defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_DATA_PIN 8</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_OUTPUT_ENABLE_PIN 9</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_LATCH_PIN 10</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_CLOCK_PIN 11</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{<font></font>
  <span class="hljs-comment">// All CPU and RAM control signals need to be configured as inputs by default</span><font></font>
  <span class="hljs-comment">// and only changed to outputs when used.</span><font></font>
  <span class="hljs-comment">// Shift register control signals may be preconfigured</span><font></font>
<font></font>
  <span class="hljs-comment">// CPU controls seetup</span><font></font>
  DDRC = B00000000;<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, INPUT);<font></font>
<font></font>
  <span class="hljs-comment">// RAM setup</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_BUFFER_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_BUFFER_PIN, LOW);<font></font>
<font></font>
  <span class="hljs-comment">// SR setup</span><font></font>
  pinMode(SR_LATCH_PIN, OUTPUT);<font></font>
  pinMode(SR_CLOCK_PIN, OUTPUT);<font></font>
  pinMode(SR_DATA_PIN, OUTPUT);<font></font>
  pinMode(SR_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
<font></font>
  <span class="hljs-comment">// common setup</span><font></font>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
  Serial.println(<span class="hljs-string">"Hello"</span>);<font></font>
}<span class="hljs-comment">// setup</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shiftReadValueFromAddress</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> address, <span class="hljs-keyword">uint8_t</span> *value)</span> </span>{<font></font>
  <span class="hljs-comment">// disable RAM output</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_WRITE_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// set address</span><font></font>
  digitalWrite(SR_LATCH_PIN, LOW);<font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address&gt;&gt;<span class="hljs-number">8</span>); <font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address);  <font></font>
  digitalWrite(SR_LATCH_PIN, HIGH);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// write value to RAM</span><font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span><font></font>
  delay(<span class="hljs-number">1</span>);<font></font>
  DDRC = B00000000;<font></font>
  *value = PINC;<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// disable SR</span><font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// shiftWriteValueToAddress</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runClock</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> cycles)</span> </span>{<font></font>
  <span class="hljs-keyword">uint32_t</span> currCycle = <span class="hljs-number">0</span>;<font></font>
  pinMode(CPU_CLOCK_PIN, OUTPUT);<font></font>
  <span class="hljs-keyword">while</span>(currCycle &lt; cycles) {<font></font>
    digitalWrite(CPU_CLOCK_PIN, HIGH);<font></font>
    digitalWrite(CPU_CLOCK_PIN, LOW);<font></font>
    currCycle++;<font></font>
  }<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
}<span class="hljs-comment">// runClock</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trySpectrum</span><span class="hljs-params">()</span> </span>{<font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, OUTPUT);<font></font>
  digitalWrite(CPU_RESET_PIN, LOW);<font></font>
  runClock(<span class="hljs-number">30</span>);<font></font>
  digitalWrite(CPU_RESET_PIN, HIGH);<font></font>
  runClock(<span class="hljs-number">12500000</span>);<font></font>
}<span class="hljs-comment">// trySpectrum</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readDisplayLines</span><span class="hljs-params">()</span> </span>{<font></font>
  <span class="hljs-keyword">uint8_t</span> value;<font></font>
  digitalWrite(RAM_BUFFER_PIN, HIGH);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_CHIP_ENABLE_PIN, LOW);<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint16_t</span> i=<span class="hljs-number">16384</span>; i&lt;<span class="hljs-number">16384</span>+<span class="hljs-number">6144</span>;i++) {<font></font>
    shiftReadValueFromAddress(i, &amp;value);<font></font>
    Serial.println(value);<font></font>
  }<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// readDisplayLines</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  trySpectrum();<font></font>
  Serial.println(<span class="hljs-string">"Hope we are ok now. Please set up memory for reading"</span>);<font></font>
  delay(<span class="hljs-number">40000</span>);<font></font>
  Serial.println(<span class="hljs-string">"Reading memory"</span>);<font></font>
  readDisplayLines();<font></font>
  Serial.println(<span class="hljs-string">"Done"</span>);<font></font>
  delay(<span class="hljs-number">100000</span>);<font></font>
}<span class="hljs-comment">// loop</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケッチからわかるように（実際には、突然、誰かがそれを読んだ）、ポートCへのデータバスを読み取りました。Arduischikが覚えているように、CIDのポートCは6ピンです。つまり、6ビットしか読み取っていません。はい、プロセスを簡単にするために、画面バッファの各バイトの2つの上位ビットは無視します。これにより、6の後の2ピクセルごとに常に背景色が存在することになります。乗りながら、それを修正します。これがスケルトンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に接続自体についてです。原則として、すべてがスケッチの最上部に描かれます。</font></font><br>
<br>
<pre><code class="plaintext hljs">// CPU defines<font></font>
#define CPU_CLOCK_PIN 2 -  2     6  ( )<font></font>
#define CPU_RESET_PIN 3 -  3     26  (RESET)<font></font>
<font></font>
// RAM defines<font></font>
#define RAM_OUTPUT_ENABLE_PIN 4 -  4     22  (OE)<font></font>
#define RAM_WRITE_ENABLE_PIN 5 -  5    .     .<font></font>
#define RAM_CHIP_ENABLE_PIN 6 -  6     .        ,        .   - ,   -  .   ,   .<font></font>
#define RAM_BUFFER_PIN 7 -  ,    6,    .<font></font>
<font></font>
// Shift Register defines<font></font>
#define SR_DATA_PIN 8   -  8     14 "" 595.        9 ,     .<font></font>
#define SR_OUTPUT_ENABLE_PIN 9 -   13  595<font></font>
#define SR_LATCH_PIN 10 -   12  595<font></font>
#define SR_CLOCK_PIN 11 -   11  595.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが簡単です。以下は、私がすべて組み立てられた様子です（arduinoは写真で切り取られていますが、特別なことは何もありません）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/q5/si/pjq5siebaxafimb_nqnjxyry6_u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起動時に、Arduinoは元気にコンピューターのシリアルポート（仮想ではあります）にHelloと言って、プロセッサーを苦しめ始めます。彼を徹底的に拷問した後（数分）、プログラムは貧しい男を停止し、ブレッドボード上のペンでジャンパーを再配置し、メモリをアドレスバスおよびプロセッサ制御信号から切断するように提案します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ハンドルを使用して、両方の74HC245のピン19に接続されている配線をグラウンドから+ 5Vに再配置する必要があります。したがって、プロセッサをRAMから切断します。 RAMチップ自体のピン22は、アースに接続する必要があります（これまで、ブレッドボードの未使用の場所に貼り付けたばかりの配線については上で書きました）。したがって、RAMを強制的にオンにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、少し待ってから、Arduinkaはメモリの内容を読み取り、シリアルポートに列として出力し始めます。非常に多くの数があります。これで、このデータをそこからコピーしてテキストファイルに貼り付けることができるようになりました。不要なテキストをすべてクリーンアップすることを忘れずに（上部に数行、下部に「完了」）、数字だけが必要です。これは、Speccyがビデオメモリに記録したものです。ビデオメモリに何があったかを確認するだけです。そして、スペクトラムのビデオメモリは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はあり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ません</font></a><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ピクセル自体は色とは別に保存されています。ここでは色を無視します。ピクセル自体のみを読み取りましょう。ただし、デコードはそれほど簡単ではありません。 Visual Studioでの苦労の末、私はこのエレガントなソリューションにたどり着きました。</font></font><br>
<br>
<pre><code class="cpp hljs"><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span></span>;<font></font>
<span class="hljs-keyword">uint8_t</span> *scrData;<font></font>
<font></font>
<span class="hljs-function">VOID <span class="hljs-title">OnPaint</span><span class="hljs-params">(HDC hdc)</span> </span>{<font></font>
	<span class="hljs-keyword">size_t</span> arrSize = <span class="hljs-number">6144</span>;<span class="hljs-comment">//sizeof(scrData) / sizeof(scrData[0]);</span><font></font>
	<span class="hljs-comment">//int currRow = 0, currX = 0, currBlock = 0, currY = 0, currBase = 0;</span><font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> arrPos = <span class="hljs-number">0</span>; arrPos &lt; arrSize; arrPos++) {<font></font>
		<span class="hljs-keyword">int</span> blockPos = arrPos % <span class="hljs-number">2048</span>;<font></font>
		<span class="hljs-keyword">int</span> currBase = (blockPos % <span class="hljs-number">256</span>) / <span class="hljs-number">32</span>;<font></font>
		<span class="hljs-keyword">int</span> currX = blockPos % <span class="hljs-number">32</span>;<font></font>
		<span class="hljs-keyword">int</span> currBlock = arrPos / <span class="hljs-number">2048</span>;<font></font>
		<span class="hljs-keyword">int</span> currRow = blockPos / <span class="hljs-number">256</span>;<font></font>
		<span class="hljs-keyword">int</span> currY = currBlock * <span class="hljs-number">64</span> + currBase * <span class="hljs-number">8</span> + currRow;<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> trueX = <span class="hljs-number">0</span>; trueX &lt; <span class="hljs-number">8</span>; trueX++) {<font></font>
			<span class="hljs-keyword">char</span> r = ((scrData[arrPos] &gt;&gt; trueX) &amp; <span class="hljs-number">1</span>)*<span class="hljs-number">255</span>;<font></font>
			SetPixel(hdc, currX * <span class="hljs-number">8</span> + (<span class="hljs-number">8</span>-trueX), currY, RGB(r, r, r));<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>{<font></font>
	FILE *file;<font></font>
	<span class="hljs-keyword">errno_t</span> err;<font></font>
	<span class="hljs-keyword">if</span> ((err = fopen_s(&amp;file, <span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>))) {<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L"Unable to oopen the file"</span>, <span class="hljs-string">L"Error"</span>, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
	scrData = (<span class="hljs-keyword">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6144</span>);<font></font>
	<span class="hljs-keyword">int</span> currDataPos = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];<font></font>
	<span class="hljs-keyword">char</span> currChar = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int</span> currLinePos = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">while</span> (currChar != EOF) {<font></font>
		currChar = getc(file);<font></font>
		buffer[currLinePos++] = currChar;<font></font>
		<span class="hljs-keyword">if</span> (currChar == <span class="hljs-string">'\n'</span>) {<font></font>
			buffer[currLinePos] = <span class="hljs-number">0</span>;<font></font>
			scrData[currDataPos++] = (<span class="hljs-keyword">uint8_t</span>)atoi(buffer);<font></font>
			currLinePos = <span class="hljs-number">0</span>;<font></font>
		}<font></font>
	}<font></font>
	fclose(file);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">INT WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PSTR, INT iCmdShow)</span> </span>{<font></font>
	HWND                hWnd;<font></font>
	MSG                 msg;<font></font>
	WNDCLASS            wndClass;<font></font>
	wndClass.style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wndClass.lpfnWndProc = WndProc;<font></font>
	wndClass.cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.hInstance = hInstance;<font></font>
	wndClass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wndClass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wndClass.lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wndClass.lpszClassName = TEXT(<span class="hljs-string">"GettingStarted"</span>);<font></font>
	RegisterClass(&amp;wndClass);<font></font>
	hWnd = CreateWindow(<font></font>
		TEXT(<span class="hljs-string">"GettingStarted"</span>),   <span class="hljs-comment">// window class name</span><font></font>
		TEXT(<span class="hljs-string">"Getting Started"</span>),  <span class="hljs-comment">// window caption</span><font></font>
		WS_OVERLAPPEDWINDOW,      <span class="hljs-comment">// window style</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x position</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y position</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x size</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y size</span><font></font>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// parent window handle</span><font></font>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// window menu handle</span><font></font>
		hInstance,                <span class="hljs-comment">// program instance handle</span><font></font>
		<span class="hljs-literal">NULL</span>);                    <span class="hljs-comment">// creation parameters</span><font></font>
	loadData();<font></font>
	ShowWindow(hWnd, iCmdShow);<font></font>
	UpdateWindow(hWnd);<font></font>
	<span class="hljs-keyword">while</span> (GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) {<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> msg.wParam;<font></font>
}  <span class="hljs-comment">// WinMain</span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{<font></font>
	HDC          hdc;<font></font>
	PAINTSTRUCT  ps;<font></font>
	<span class="hljs-keyword">switch</span> (message) {<font></font>
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hdc = BeginPaint(hWnd, &amp;ps);<font></font>
		OnPaint(hdc);<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">default</span>:<font></font>
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);<font></font>
	}<font></font>
} <span class="hljs-comment">// WndProc</span><font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムは、ディレクトリからdata.txtファイルを開きます。</font><font style="vertical-align: inherit;">このファイルでは、（上記のようにすべての余分な行を削除した後の）arduinoのテキスト出力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果のファイルをフィードし、結果として：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/ai/3f/tvai3fcvvg-y53dlrcxogjo9o-c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、結果は理想からはほど遠いものの、間違いなく画面への出力です。</font><font style="vertical-align: inherit;">また、必要なもの。</font><font style="vertical-align: inherit;">診断ファームウェア付きのROMから。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、コンピュータスケルトンの準備が整いました。</font><font style="vertical-align: inherit;">はい、まだ使用することは不可能ですが、古い8ビットコンピュータが非常にシンプルに配置されていることがわかります。</font><font style="vertical-align: inherit;">私はまだブレッドボードを少し叩きましたが、結論はさらに悪化しました。</font><font style="vertical-align: inherit;">次のステップは、通常のはんだ付けされていないブレッドボードに、通常の電力ではんだ付けすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それは必要ですか？</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja498208/index.html">セキュリティウィーク17：Linuxサーバー攻撃の影響</a></li>
<li><a href="../ja498214/index.html">マリア・ポポワ：「マップにハクウィードをマークしたという事実のために、OpenStreetMapについて最初に知った人もいます」</a></li>
<li><a href="../ja498216/index.html">HTMLとReactでのテキストのカラーリング</a></li>
<li><a href="../ja498218/index.html">宇宙線から音楽を書いたとき</a></li>
<li><a href="../ja498220/index.html">Как коронавирус (COVID-XX) может помочь 1С захватить мир?</a></li>
<li><a href="../ja498224/index.html">.NET、Azure Functions、およびコグニティブサービスの魔法でインタラクティブな展示を作成する</a></li>
<li><a href="../ja498226/index.html">分解。事前評価のために巨大なプロジェクトを理解可能なセグメントに分解する方法</a></li>
<li><a href="../ja498234/index.html">DevOpsに関する実際の管理神話</a></li>
<li><a href="../ja498238/index.html">導電性ポリマー：科学者が金属からプラスチックを作る方法</a></li>
<li><a href="../ja498242/index.html">メディアコンテンツでのストレージの使用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>