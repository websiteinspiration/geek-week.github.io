<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏻 🤤 👩🏾‍🍳 Flattern unter der Haube 🎮 🥥 👩🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo alle zusammen! Mein Name ist Mikhail Zotiev, ich arbeite als Flutter-Entwickler bei Surf. Ich, wie wahrscheinlich die Mehrheit der anderen Entwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flattern unter der Haube</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/501862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo alle zusammen! Mein Name ist Mikhail Zotiev, ich arbeite als Flutter-Entwickler bei Surf. Ich, wie wahrscheinlich die Mehrheit der anderen Entwickler, die mit Flutter arbeiten, mag vor allem, wie einfach es ist, mit seiner Hilfe schöne und bequeme Anwendungen zu erstellen. Es dauert sehr wenig Zeit, um in die Flutter-Entwicklung einzusteigen. Ich habe kürzlich in der Spieleentwicklung gearbeitet und bin jetzt vollständig auf die plattformübergreifende mobile Entwicklung von Flutter umgestiegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist die Einfachheit? </font><font style="vertical-align: inherit;">Mit einem Dutzend grundlegender Widgets können Sie recht anständige Benutzeroberflächen erstellen. </font><font style="vertical-align: inherit;">Und im Laufe der Zeit, wenn das verwendete Gepäck recht anständig ist, ist es unwahrscheinlich, dass eine Aufgabe Sie zum Stillstand bringt: sei es ein ungewöhnliches Design oder eine raffinierte Animation. </font><font style="vertical-align: inherit;">Und das Interessanteste - höchstwahrscheinlich können Sie es verwenden, ohne über die Frage nachzudenken: "Wie funktioniert es überhaupt?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Flutter Open Source hat, habe ich beschlossen, herauszufinden, was sich unter der Haube befindet (auf der Dart-Seite der Macht) und es mit Ihnen zu teilen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/ln/q6/lglnq6t8sbc8gq-emifhx1dxjwu.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir alle haben den Satz vom Framework-Entwicklungsteam mehr als einmal gehört: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Alles in Flutter ist Widgets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">" </font></i><font style="vertical-align: inherit;">Mal sehen, ob das wirklich so ist. </font><font style="vertical-align: inherit;">Dazu wenden wir uns der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">(im Folgenden - Widget) zu und beginnen, uns allmählich mit dem Inhalt vertraut zu machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was wir in der Dokumentation für die Klasse lesen werden:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibt die Konfiguration für ein [Element].</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass das Widget selbst nur eine Beschreibung eines </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elements ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (im Folgenden - das Element).</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets sind die zentrale Klassenhierarchie im Flutter-Framework. </font><font style="vertical-align: inherit;">Ein Widget ist eine unveränderliche Beschreibung eines Teils einer Benutzeroberfläche. </font><font style="vertical-align: inherit;">Widgets können in Elemente aufgeblasen werden, die den zugrunde liegenden Renderbaum verwalten.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend ist der Ausdruck </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Alles in Flutter ist ein Widget"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Mindestmaß an Verständnis dafür, wie alles angeordnet ist, um Flutter zu verwenden. </font><font style="vertical-align: inherit;">Das Widget ist die Mittelklasse in der Flutter-Hierarchie. </font><font style="vertical-align: inherit;">Gleichzeitig gibt es viele zusätzliche Mechanismen, die dem Framework helfen, seine Aufgabe zu bewältigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir noch ein paar Fakten gelernt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget - eine unveränderliche Beschreibung eines Teils der Benutzeroberfläche;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Widget ist einer erweiterten Ansicht zugeordnet, die als Element bezeichnet wird. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Element steuert eine Entität des Renderbaums.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen eine seltsame Sache bemerkt haben. </font><font style="vertical-align: inherit;">Die Benutzeroberfläche und die Unveränderlichkeit passen sehr schlecht zusammen, ich würde sogar sagen, dass dies völlig inkompatible Konzepte sind. </font><font style="vertical-align: inherit;">Wir werden jedoch darauf zurückkommen, wenn ein vollständigeres Bild des Geräts der Flutter-Welt erstellt wird. Im Moment werden wir uns jedoch weiterhin mit der Dokumentation des Widgets vertraut machen.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets selbst haben keinen veränderlichen Status (alle Felder müssen endgültig sein). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie einem Widget einen veränderlichen Status zuordnen möchten, sollten Sie ein [StatefulWidget] verwenden, das ein [State] -Objekt (über [StatefulWidget.createState]) erstellt, wenn es in ein Element aufgeblasen und in den Baum integriert wird.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Absatz ergänzt der erste Absatz etwas: wenn wir eine veränderbare Konfiguration benötigen, verwenden wir die spezielle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">staatliche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheit </font><font style="vertical-align: inherit;">( im </font><font style="vertical-align: inherit;">folgenden als Zustand bezeichnet), die den aktuellen Zustand dieses Widgets beschreibt. </font><font style="vertical-align: inherit;">Der Status ist jedoch nicht dem Widget zugeordnet, sondern seiner elementaren Darstellung.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bestimmtes Widget kann null oder mehrmals in den Baum aufgenommen werden. </font><font style="vertical-align: inherit;">Insbesondere kann ein bestimmtes Widget mehrmals in den Baum eingefügt werden. </font><font style="vertical-align: inherit;">Jedes Mal, wenn ein Widget in den Baum eingefügt wird, wird es in ein [Element] aufgeblasen. Dies bedeutet, dass ein Widget, das mehrmals in den Baum integriert wird, mehrmals aufgeblasen wird.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gleiche Widget kann viele Male oder gar nicht in den Widget-Baum aufgenommen werden. </font><font style="vertical-align: inherit;">Jedes Mal, wenn ein Widget in den Widget-Baum aufgenommen wird, wird ihm ein Element zugeordnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Stadium sind die Widgets also fast fertig. Fassen wir zusammen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget - die zentrale Klasse der Hierarchie;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget ist eine Konfiguration; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget - eine unveränderliche Beschreibung eines Teils der Benutzeroberfläche; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Widget ist einem Element zugeordnet, das das Rendern auf irgendeine Weise steuert. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der sich ändernde Status des Widgets kann von einer Entität beschrieben werden, ist jedoch nicht mit dem Widget verbunden, sondern mit dem Element, das dieses Widget darstellt.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem, was wir gelernt haben, stellt sich die Frage: "Was sind diese Elemente, die alles regieren?" </font><font style="vertical-align: inherit;">Machen Sie dasselbe - öffnen Sie die Dokumentation für die Element-Klasse.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Instanziierung eines [Widgets] an einer bestimmten Stelle im Baum.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Element ist eine Darstellung eines Widgets an einer bestimmten Stelle in einem Baum.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets beschreiben, wie ein Teilbaum konfiguriert wird. Mit demselben Widget können jedoch mehrere Teilbäume gleichzeitig konfiguriert werden, da Widgets unveränderlich sind. </font><font style="vertical-align: inherit;">Ein [Element] repräsentiert die Verwendung eines Widgets zum Konfigurieren eines bestimmten Speicherorts in der Baumstruktur. </font><font style="vertical-align: inherit;">Im Laufe der Zeit kann sich das einem bestimmten Element zugeordnete Widget ändern, wenn das übergeordnete Widget beispielsweise neu erstellt und ein neues Widget für diesen Speicherort erstellt.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Widget beschreibt die Konfiguration eines Teils der Benutzeroberfläche. Wie wir jedoch bereits wissen, kann dasselbe Widget an verschiedenen Stellen des Baums verwendet werden. Jeder dieser Orte wird durch ein entsprechendes Element dargestellt. Im Laufe der Zeit kann sich jedoch das dem Element zugeordnete Widget ändern. Dies bedeutet, dass die Elemente zäher sind und weiterhin verwendet werden, wobei nur ihre Verbindungen aktualisiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine ziemlich rationale Entscheidung. Wie wir oben bereits definiert haben, sind Widgets eine unveränderliche Konfiguration, die lediglich einen bestimmten Teil der Benutzeroberfläche beschreibt, was bedeutet, dass sie sehr leicht sein müssen. Und die Elemente, in deren Bereich die Kontrolle viel schwerer ist, werden aber nicht unnötig neu erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, wie dies geschieht, betrachten Sie den Lebenszyklus eines Elements:</font></font><br>
<br>
<ul>
<li>     Widget.createElement    ,     .</li>
<li>   mount        .              .</li>
<li>       .</li>
<li>   ,    (,    ),     .       runtimeType  key,     .   ,     ,           .</li>
<li> ,       ,    ,             ,      (  deactivate).</li>
<li>   ,     .           ,       ,   (unmount),           .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Elemente erneut in den Baum aufnehmen, z. B. wenn das Element oder seine Vorfahren einen globalen Schlüssel haben, wird dieser aus der Liste der inaktiven Elemente entfernt, die Aktivierungsmethode wird aufgerufen und das diesem Element zugeordnete gerenderte Objekt wird erneut in den Renderbaum eingebettet. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Element erneut auf dem Bildschirm angezeigt werden soll.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Klassendeklaration sehen wir, dass das Element die BuildContext-Schnittstelle implementiert. </font><font style="vertical-align: inherit;">Ein BuildContext steuert die Position eines Widgets in einem Widget-Baum, wie aus der Dokumentation hervorgeht. </font><font style="vertical-align: inherit;">Entspricht fast genau der Artikelbeschreibung. </font><font style="vertical-align: inherit;">Diese Schnittstelle wird verwendet, um eine direkte Manipulation des Elements zu vermeiden und gleichzeitig Zugriff auf die erforderlichen Kontextmethoden zu gewähren. </font><font style="vertical-align: inherit;">Beispiel: findRenderObject, mit dem Sie das Renderbaumobjekt finden können, das diesem Element entspricht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderderbject</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt der letzte Link dieser Triade - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RenderObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wie der Name schon sagt, ist dies ein Objekt des Visualisierungsbaums. Es verfügt über ein übergeordnetes Objekt sowie ein Datenfeld, in dem das übergeordnete Objekt bestimmte Informationen zu diesem Objekt selbst speichert, z. B. seine Position. Dieses Objekt ist für die Implementierung grundlegender Rendering- und Layoutprotokolle verantwortlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RenderObject beschränkt das Modell der Verwendung untergeordneter Objekte nicht: Möglicherweise gibt es keine, eine oder mehrere. </font><font style="vertical-align: inherit;">Das Positionierungssystem ist auch nicht beschränkt auf: das kartesische System, Polarkoordinaten, all dies und vieles mehr steht zur Verfügung. </font><font style="vertical-align: inherit;">Es gibt keine Einschränkungen für die Verwendung von Standortprotokollen: Anpassen der Breite oder Höhe, Begrenzen der Größe, Angeben der Größe und des Standorts des übergeordneten Objekts oder ggf. Verwenden der Daten des übergeordneten Objekts.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flattern Weltbild</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, ein Gesamtbild davon zu erstellen, wie alles zusammenarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben oben bereits erwähnt, dass das Widget eine unveränderliche Beschreibung ist, aber die Benutzeroberfläche ist überhaupt nicht statisch. </font><font style="vertical-align: inherit;">Diese Diskrepanz wird durch Aufteilung in 3 Objektebenen und Aufteilung der Verantwortungszonen beseitigt.</font></font><br>
<br>
<ul>
<li> ,          . </li>
<li> ,               . </li>
<li>  ,   — ,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/j_/n_/og/j_n_ogui1a0iawbuoq5vxclsnne.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen </font></font><br>
<br>
<img src="https://habrastorage.org/webt/u7/0o/wk/u70owkgirs6krcos85rwn-acli8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wir uns anhand </font><font style="vertical-align: inherit;">eines einfachen Beispiels an, wie diese Bäume aussehen: </font><font style="vertical-align: inherit;">In diesem Fall haben wir ein StatelessWidget in ein Padding-Widget eingeschlossen, das Text enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen wir uns an die Stelle von Flutter - wir haben diesen Widget-Baum erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hey, Padding, ich brauche dein Element"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Natürlich, halte SingleChildRenderObjectElement"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/jj/u7/zn/jju7znfat7skocfex74adc4cu7o.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Element, hier ist dein Platz, beruhige dich"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leute </font><i><font style="vertical-align: inherit;">, alles ist in Ordnung, aber ich brauche RenderObject"</font></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Padding, wie um dich überhaupt zu zeichnen? "</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hold it, RenderPadding"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Großartig,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mach </font><i><font style="vertical-align: inherit;">dich an die Arbeit"</font></i></font><br>
<br>
<img src="https://habrastorage.org/webt/zk/ty/se/zktyse7pgo6jdd6x7impyivfhy0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flattern:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Also wer ist der nächste?" StatelessWidget, jetzt können Sie das Element lassen »</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessWidget: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Hier StatelessElement»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«StatelessElement, du untertan SingleChildRenderObjectElement sein wird, hier ist der Ort, einsteigen»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«OK»</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7w/tb/ke/7wtbkebtfn_xeq1ieqxqbarpkro.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Der Rich - </font><font style="vertical-align: inherit;">Text, elementik Present, bitte»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Rich - </font><font style="vertical-align: inherit;">Text gibt MultiChildRenderObjectElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"MultiChildRenderObjectElement, los geht's"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ich brauche ein Rendering für die Arbeit"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"RichText, wir brauchen ein</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Renderobjekt </font><i><font style="vertical-align: inherit;">"</font></i><font style="vertical-align: inherit;"> RichText: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hier ist ein RenderParagraph"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"RenderParagraph erhalten Sie Anweisungen RenderPadding, und Sie steuern MultiChildRenderObjectElement"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Jetzt ist alles in Ordnung, ich bin bereit"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/s4/24/fn/s424fnivo4j2tb4sv9pcirmxov0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sicher werden Sie eine berechtigte Frage stellen: "Wo ist das Rendering-Objekt für StatelessWidget, warum ist es nicht da, wir haben oben entschieden, dass die Elemente Konfigurationen binden mit Display? " </font><font style="vertical-align: inherit;">Achten wir auf die grundlegende Implementierung der Mount-Methode, die in diesem Abschnitt der Lebenszyklusbeschreibung erläutert wurde.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> mount(Element parent, dynamic newSlot) {<font></font>
    assert(_debugLifecycleState == _ElementLifecycle.initial);<font></font>
    assert(widget != <span class="hljs-literal">null</span>);<font></font>
    assert(_parent == <span class="hljs-literal">null</span>);<font></font>
    assert(parent == <span class="hljs-literal">null</span> || parent._debugLifecycleState == _ElementLifecycle.active);<font></font>
    assert(slot == <span class="hljs-literal">null</span>);<font></font>
    assert(depth == <span class="hljs-literal">null</span>);<font></font>
    assert(!_active);<font></font>
    _parent = parent;<font></font>
    _slot = newSlot;<font></font>
    _depth = _parent != <span class="hljs-literal">null</span> ? _parent.depth + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<font></font>
    _active = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>)<font></font>
        _owner = parent.owner;<font></font>
    <span class="hljs-keyword">if</span> (widget.key is GlobalKey) {<font></font>
        final GlobalKey key = widget.key;<font></font>
        key._register(<span class="hljs-keyword">this</span>);<font></font>
    }<font></font>
    _updateInheritance();<font></font>
    assert(() {<font></font>
        _debugLifecycleState = _ElementLifecycle.active;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden darin nicht die Erstellung eines Rendering-Objekts sehen. </font><font style="vertical-align: inherit;">Das Element implementiert jedoch den BuildContext, der über eine Suchmethode für das Visualisierungsobjekt findRenderObject verfügt, die uns zum folgenden Getter führt:</font></font><br>
<br>
<pre><code class="javascript hljs">RenderObject get renderObject {<font></font>
    RenderObject result;<font></font>
    <span class="hljs-keyword">void</span> visit(Element element) {<font></font>
        assert(result == <span class="hljs-literal">null</span>); 
        <span class="hljs-keyword">if</span> (element is RenderObjectElement)<font></font>
            result = element.renderObject;<font></font>
        <span class="hljs-keyword">else</span><font></font>
            element.visitChildren(visit);<font></font>
    }<font></font>
    visit(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Basisfall erstellt ein Element möglicherweise kein Rendering-Objekt. Dazu sind nur RenderObjectElement und seine Nachkommen erforderlich. In diesem Fall muss ein Element auf einer Verschachtelungsebene ein untergeordnetes Element mit einem Rendering-Objekt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, warum all diese Schwierigkeiten. Bis zu 3 Bäume, verschiedene Verantwortungsbereiche usw. Die Antwort ist ganz einfach - hier wird die Leistung von Flutter aufgebaut. Widgets sind unveränderliche Konfigurationen, daher werden sie häufig neu erstellt, sind aber gleichzeitig recht leicht, was die Leistung nicht beeinträchtigt. Aber Flutter versucht, schwere Elemente so weit wie möglich wiederzuverwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispiel. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Text in der Mitte des Bildschirms. Der Code in diesem Fall sieht ungefähr so ​​aus:</font></font></i><br>
<br>
<pre><code class="javascript hljs">body: Center(<font></font>
    child: Text(“Hello world!”)<font></font>
),</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall sieht der Widget-Baum folgendermaßen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/wt/fa/lcwtfazdhkpaprcu9tqvhssvck4.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Flutter alle drei Bäume erstellt hat, wird das folgende Bild </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/vx/ph/ucvxphu5r2ds-6_kmoizgyoczo8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
angezeigt </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Was passiert, wenn wir den anzuzeigenden Text ändern? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/8b/do/_u8bdowthfzx9jshpbprfnpj1ai.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben jetzt einen neuen Widget-Baum. Oben haben wir über die maximal mögliche Wiederverwendung von Elementen gesprochen. Schauen Sie sich die Widget-Klassenmethode unter dem sprechenden Namen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canUpdate an</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">static</span> bool canUpdate(Widget oldWidget, Widget newWidget) {
    <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir überprüfen den Typ des vorherigen und des neuen Widgets sowie deren Schlüssel. Wenn sie gleich sind, muss der Artikel nicht geändert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor dem Upgrade ist das erste Element also Center, nach dem Upgrade auch Center. Beide haben keine Schlüssel, ein völliger Zufall. Wir können den Elementlink auf ein neues Widget aktualisieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/tr/s4/hetrs4cgzrimhibqeilfoja5xzi.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu Typ und Schlüssel ist das Widget eine Beschreibung und Konfiguration, und die Werte der Parameter, die für die Anzeige erforderlich sind, können sich ändern. Aus diesem Grund sollte das Element nach dem Aktualisieren des Links zum Widget Aktualisierungen des Rendering-Objekts initiieren. Im Fall von Center hat sich nichts geändert, und wir vergleichen weiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Typ und der Schlüssel sagen uns erneut, dass es keinen Sinn macht, das Element neu zu erstellen. Der Text ist ein Nachkomme von StatelessWidget und hat kein direktes Anzeigeobjekt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/yy/6m/dpyy6mckv6cddryb0_yu5asy_uy.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen Sie zu RichText. Das Widget hat auch seinen Typ nicht geändert, es gibt keine Unstimmigkeiten in den Schlüsseln. Das Element aktualisiert seine Zuordnung zum neuen Widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/vh/95/hwvh952jekjwhudyj6czju3hq6a.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verbindung wird aktualisiert, es bleiben nur die Eigenschaften zu aktualisieren. Infolgedessen zeigt RenderParagraph den neuen Textwert an. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/_p/g-/lv_pg-n6wlmcmlunokumb60nqw0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und sobald die Zeit für den nächsten Zeichenrahmen gekommen ist, werden wir das erwartete Ergebnis sehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank dieser Art von Arbeit erreicht Flutter eine so hohe Leistung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das obige Beispiel beschreibt den Fall, in dem sich die Widget-Struktur selbst nicht geändert hat. Aber was passiert, wenn sich die Struktur ändert? Flutter wird natürlich weiterhin versuchen, die Verwendung vorhandener Objekte zu maximieren, wie wir aus der Beschreibung des Lebenszyklus verstanden haben, aber für alle neuen Widgets werden neue Elemente erstellt und alte und unnötigere werden am Ende des Frames gelöscht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns einige Beispiele an. </font><font style="vertical-align: inherit;">Um dies zu gewährleisten, verwenden wir das Android Studio-Tool - Flutter Inspector.</font></font><br>
<br>
<pre><code class="javascript hljs">@override<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> Scaffold(<font></font>
        body: Center(<font></font>
            child: _isFirst ? first() : second(),<font></font>
        ),<font></font>
        <span class="hljs-attr">floatingActionButton</span>: FloatingActionButton(<font></font>
            child: Text(<span class="hljs-string">"Switch"</span>),
            <span class="hljs-attr">onPressed</span>: () {<font></font>
                setState(() {<font></font>
                    _isFirst = !_isFirst;<font></font>
                });<font></font>
            },<font></font>
        ),<font></font>
    );<font></font>
}<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">SizedBox</span>(<span class="hljs-params">
            width: <span class="hljs-number">5</span>,
        </span>),
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);<font></font>
<font></font>
<span class="hljs-title">Widget</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"one more test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Padding</span>(<span class="hljs-params">
            padding: EdgeInsets.only(left: <span class="hljs-number">5</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ändert sich durch Klicken auf die Schaltfläche eines der Widgets. </font><font style="vertical-align: inherit;">Mal sehen, was der Inspektor uns zeigt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/vt/vt/wivtvtojhv4uq3l7ouoje3le-u0.png" alt="Bild"><br>
<br>
<img src="https://habrastorage.org/webt/f4/rb/0a/f4rb0avn7pombux2ct6pkap2edi.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir sehen können, hat Flutter den Render nur für Padding neu erstellt, der Rest wurde nur wiederverwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie eine weitere Option, bei der sich die Struktur globaler ändert - wir ändern die Verschachtelungsebenen.</font></font><br>
<br>
<pre><code class="javascript hljs">Wid<span class="hljs-keyword">get</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Container</span>(<span class="hljs-params">child: first(</span>),);</code></pre><br>
<img src="https://habrastorage.org/webt/yt/8i/gs/yt8igsxt3r3b-ofhkrlcyjaqryc.png" alt="Bild"><br>
<br>
<img src="https://habrastorage.org/webt/j7/na/qw/j7naqwq6060sh-tw_atxna_umpa.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass sich der Baum visuell überhaupt nicht geändert hat, wurden die Elemente und Objekte des Rendering-Baums neu erstellt. </font><font style="vertical-align: inherit;">Dies geschah, weil Flutter nach Ebenen vergleicht (in diesem Fall spielt es keine Rolle, dass sich der größte Teil des Baums nicht geändert hat). Das Sieben dieses Teils erfolgte zum Zeitpunkt des Vergleichs von Container und Zeile. </font><font style="vertical-align: inherit;">Man kann jedoch aus dieser Situation herauskommen. </font><font style="vertical-align: inherit;">Dies wird uns GlobalKey helfen. </font><font style="vertical-align: inherit;">Fügen Sie einen solchen Schlüssel für Row hinzu.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> _key = GlobalKey(debugLabel: <span class="hljs-string">"testLabel"</span>);<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    key: _key,
    …
</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/gg/jp/zj/ggjpzjlpox-ijhgtwxy-i6rvcsk.png" alt="Bild"><br>
<br>
<img src="https://habrastorage.org/webt/zy/br/zy/zybrzywy-_ixs_apl7j1fiqsrco.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald wir Flutter sagten, dass das Teil wiederverwendet werden könne, nutzte er die Gelegenheit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns ein wenig mit Flutter-Magie vertraut gemacht und jetzt wissen wir, dass es sich nicht nur um Widgets handelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter ist ein gut durchdachter, gut koordinierter Mechanismus mit einer eigenen Hierarchie und Verantwortungsbereichen, mit dem Sie nicht nur schöne, sondern auch produktive Anwendungen erstellen können. </font><font style="vertical-align: inherit;">Natürlich haben wir nur einen kleinen, wenn auch ziemlich wichtigen Teil seines Geräts untersucht, daher werden wir in zukünftigen Artikeln weiterhin verschiedene Aspekte der internen Funktionsweise des Frameworks analysieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, die Informationen in diesem Artikel sind hilfreich, um zu verstehen, wie Flutter intern funktioniert, und helfen Ihnen, während der Entwicklung elegante und produktive Lösungen zu finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihre Aufmerksamkeit!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressourcen</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter </font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Wie Flutter Widgets rendert" von Andrew Fitz Gibbon, Matt Sullivan</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501850/index.html">Wir zerlegen den EM-Algorithmus in kleine Steine</a></li>
<li><a href="../de501854/index.html">So beenden Sie die Programmierung und beginnen mit der Ausführung</a></li>
<li><a href="../de501856/index.html">Tarantool: Analysten-Look</a></li>
<li><a href="../de501858/index.html">Setzen Sie alle Punkte auf das "psi"</a></li>
<li><a href="../de501860/index.html">15. Mai RU-Center kann Ihnen ohne Ihre Teilnahme einen kostenpflichtigen Service hinzufügen</a></li>
<li><a href="../de501864/index.html">Assistent oder Inspektor: Für wen ruft der Roboter?</a></li>
<li><a href="../de501866/index.html">Wie viele Jobs werden Roboter zerstören?</a></li>
<li><a href="../de501868/index.html">Wie man den Buchhalter sich nicht werfen lässt oder Wir übertragen 1C in die Cloud. Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de501870/index.html">Maximale Anzahl von Werten in Aufzählung Teil II</a></li>
<li><a href="../de501872/index.html">Studienort in kybernetischen Systemen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>