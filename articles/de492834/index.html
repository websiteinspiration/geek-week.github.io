<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß† ü§Ωüèª ‚ò¢Ô∏è Was ist zwischen LVM und Matroschka gemeinsam? üìò ‚úåÔ∏è üëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sch√∂nen Tag. 
 Ich m√∂chte mit der Community praktische Erfahrungen beim Aufbau eines Speichersystems f√ºr KVM mit md RAID + LVM teilen. 
 
 Das Program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Was ist zwischen LVM und Matroschka gemeinsam?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492834/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√∂nen Tag. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte mit der Community praktische Erfahrungen beim Aufbau eines Speichersystems f√ºr KVM mit md RAID + LVM teilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Programm wird:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie md RAID 1 von einer NVMe-SSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie md RAID 6 von einer SATA-SSD und normalen Laufwerken.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen des TRIM / DISCARD auf SSD RAID 1/6.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen eines bootf√§higen MD RAID 1/6 Arrays auf einem gemeinsamen Satz von Festplatten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installieren des Systems auf NVMe RAID 1, wenn im BIOS keine NVMe-Unterst√ºtzung vorhanden ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von LVM-Cache und LVM Thin.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von BTRFS-Snapshots und Senden / Empfangen zur Sicherung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von LVM Thin Snapshots und Thin_Delta f√ºr Backups im BTRFS-Stil.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Interesse bitte unter Katze.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aussage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Autor √ºbernimmt keine Verantwortung f√ºr die Folgen der Verwendung oder Nichtverwendung der Materialien / Beispiele / Codes / Tipps / Daten aus diesem Artikel. </font><font style="vertical-align: inherit;">Wenn Sie dieses Material lesen oder in irgendeiner Weise verwenden, √ºbernehmen Sie die Verantwortung f√ºr alle Konsequenzen dieser Handlungen. </font><font style="vertical-align: inherit;">M√∂gliche Folgen sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knusprig gebratene NVMe SSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndig verbrauchte Aufzeichnungsressource und Ausfall von SSD-Laufwerken.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndiger Verlust aller Daten auf allen Laufwerken, einschlie√ülich Backups.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlerhafte Computerhardware.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbrachte Zeit, Nerven und Geld.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle anderen oben nicht aufgef√ºhrten Effekte.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eisen</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf Lager war:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Motherboard ist um 2013 auf dem Z87-Chipsatz mit Intel Core i7 / Haswell.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU 4 Kerne, 8 Threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 Gigabyte DDR3-RAM</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 x 16 oder 2 x 8 PCIe 3.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 x 4 + 1 x 1 PCIe 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SATA 3-Anschl√ºsse mit 6 x 6 GBit / s </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SAS-Adapter LSI SAS9211-8I wurde in den IT / HBA-Modus geflasht. </font><font style="vertical-align: inherit;">RAID-f√§hige Firmware wurde absichtlich durch HBA-Firmware ersetzt, um:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war jederzeit m√∂glich, diesen Adapter zu werfen und durch einen anderen ersten zu ersetzen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRIM / Discard funktionierte normal auf Festplatten, wie </font><font style="vertical-align: inherit;">In der RAID-Firmware werden diese Befehle √ºberhaupt nicht unterst√ºtzt, und HBA ist es im Allgemeinen egal, welche Befehle auf dem Bus gesendet werden sollen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Festplatten - 8 St√ºck HGST Travelstar 7K1000 mit einem Volumen von 1 TB im Formfaktor 2,5, wie bei Laptops. </font><font style="vertical-align: inherit;">Diese Laufwerke befanden sich zuvor in einem RAID 6-Array. </font><font style="vertical-align: inherit;">Im neuen System finden sie auch Anwendung. </font><font style="vertical-align: inherit;">Zum Speichern lokaler Backups.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich wurde hinzugef√ºgt:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 St√ºck SATA SSD Modell Samsung 860 QVO 2 TB. </font><font style="vertical-align: inherit;">Diese SSDs erforderten eine gro√üe Menge, das Vorhandensein eines SLC-Cache, Zuverl√§ssigkeit ist w√ºnschenswert und einen niedrigen Preis. </font><font style="vertical-align: inherit;">Obligatorisch war die Unterst√ºtzung f√ºr Discard / Zero, die durch eine Zeile in dmesg √ºberpr√ºft wird: </font></font><br>
<br>
<code>kernel: ata1.00: Enabling discard_zeroes_data</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 St√ºck NVMe SSD-Modell Samsung SSD 970 EVO 500 GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diese SSDs sind zuf√§llige Lese- / Schreibgeschwindigkeit und eine Ressource f√ºr Ihre Anforderungen wichtig. </font><font style="vertical-align: inherit;">K√ºhler zu ihnen. </font><font style="vertical-align: inherit;">Verpflichtend. </font><font style="vertical-align: inherit;">Absolut notwendig. </font><font style="vertical-align: inherit;">Andernfalls braten Sie sie w√§hrend der ersten RAIDa-Synchronisation knusprig.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StarTech PEX8M2E2-Adapter f√ºr 2 x NVMe-SSDs mit PCIe 3.0 8x-Steckplatz. Dies ist wiederum nur HBA, aber f√ºr NVMe. Es unterscheidet sich von billigen Adaptern dadurch, dass keine PCIe-Bifurkationsunterst√ºtzung vom Motherboard erforderlich ist, da ein integrierter PCIe-Switch vorhanden ist. Es funktioniert auch im √§ltesten System, in dem PCIe vorhanden ist, selbst wenn es sich um einen x1 PCIe 1.0-Steckplatz handelt. Nat√ºrlich mit der entsprechenden Geschwindigkeit. Es gibt dort keine RAIDs. Es ist kein integriertes BIOS an Bord. Ihr System lernt also nicht auf magische Weise, von NVMe zu booten, geschweige denn NVMe-RAID dank dieses Ger√§ts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Komponente wurde ausschlie√ülich durch das Vorhandensein von nur einem freien 8x PCIe 3.0 im System verursacht und kann mit 2 freien Steckpl√§tzen leicht durch zwei billige PEX4M2E1 oder Analoga ersetzt werden, die √ºberall zu einem Preis von 600 Rubel erh√§ltlich sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ablehnung aller Arten von Hardware oder integrierten RAID-Chips√§tzen / BIOS wurde bewusst vorgenommen, um das gesamte System mit Ausnahme der SSD / HDD selbst vollst√§ndig ersetzen zu k√∂nnen und alle Daten zu speichern. </font><font style="vertical-align: inherit;">Im Idealfall ist es m√∂glich, auch das installierte Betriebssystem beizubehalten, wenn auf eine v√∂llig neue / andere Hardware umgestellt wird. </font><font style="vertical-align: inherit;">Hauptsache, es gibt SATA- und PCIe-Ports. </font><font style="vertical-align: inherit;">Es ist wie eine Live-CD oder ein bootf√§higes Flash-Laufwerk, nur sehr schnell und etwas √ºbergro√ü.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humor</font></font></b><div class="spoiler_text"> ,   , ‚Äî          .     .            5.25  .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, und nat√ºrlich, um mit verschiedenen Methoden des SSD-Caching unter Linux zu experimentieren.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware-Raids, es ist langweilig. </font><font style="vertical-align: inherit;">Anschalten. </font><font style="vertical-align: inherit;">Es funktioniert entweder oder nicht. </font><font style="vertical-align: inherit;">Und mit mdadm gibt es immer Optionen.</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sanft</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor war Debian 8 Jessie auf der Hardware installiert, die EOL nahe kommt. </font><font style="vertical-align: inherit;">RAID 6 von den oben genannten Festplatten wurde mit LVM gekoppelt. </font><font style="vertical-align: inherit;">Es wurden virtuelle Maschinen in kvm / libvirt ausgef√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
weil </font><font style="vertical-align: inherit;">Der Autor verf√ºgt √ºber die entsprechende Erfahrung bei der Erstellung von tragbaren bootf√§higen SATA / NVMe-Flash-Laufwerken. Um die √ºbliche apt-Vorlage nicht zu besch√§digen, wurde Ubuntu 18.04 als Zielsystem ausgew√§hlt, das sich bereits ausreichend stabilisiert hat, aber auch in Zukunft 3 Jahre Unterst√ºtzung bietet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem genannten System sind alle Hardwaretreiber vorhanden, die wir sofort ben√∂tigen. </font><font style="vertical-align: inherit;">Wir ben√∂tigen keine Software und Treiber von Drittanbietern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorbereitung f√ºr die Installation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Installation des Systems ben√∂tigen wir Ubuntu Desktop Image. </font><font style="vertical-align: inherit;">Das Serversystem verf√ºgt √ºber eine Art leistungsstarkes Installationsprogramm, das eine √ºberm√§√üige, nicht trennbare Unabh√§ngigkeit aufweist und die UEFI-Systempartition immer auf eine der Festplatten schiebt, die die ganze Sch√∂nheit beeintr√§chtigen. </font><font style="vertical-align: inherit;">Dementsprechend wird es nur im UEFI-Modus installiert. </font><font style="vertical-align: inherit;">Es werden keine Optionen angeboten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das passt nicht zu uns.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum?</font></font></b><div class="spoiler_text"> , UEFI        RAID, ..   UEFI ESP     .    ,    ESP     USB , ,   .      mdadm RAID 1    0.9    UEFI BIOS   , ,       BIOS       -  ESP     .<br>
<br>
 ,  UEFI   NVRAM,         , ..    .<br>
<br>
 ,      .     ,       Legacy/BIOS boot,    CSM  UEFI- .      , ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Desktop-Version von Ubuntu wei√ü auch nicht, wie man normal mit dem Legacy-Bootloader installiert, aber hier gibt es, wie sie sagen, zumindest Optionen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sammeln Sie also die Hardware und laden Sie das System vom bootf√§higen Ubuntu Live-Flash-Laufwerk. </font><font style="vertical-align: inherit;">Wir m√ºssen Pakete herunterladen, also richten wir das Netzwerk ein, das Sie verdient hat. </font><font style="vertical-align: inherit;">Wenn dies nicht funktioniert, k√∂nnen Sie die erforderlichen Pakete vorab auf das USB-Flash-Laufwerk herunterladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen in die Desktop-Umgebung, f√ºhren den Terminalemulator aus und gehen:</font></font><br>
<br>
<code>#sudo bash</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie...?</font></font></b><div class="spoiler_text">       sudo.  <b></b>    <b></b> .   ,       .     sudo   ,     . :<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W-tPTmdnc7E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br>
<code>#apt-get install mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht ZFS ...?</font></font></b><div class="spoiler_text">       , ‚Äî  ,         . <br>
        , ‚Äî        ,   -  .<br>
<br>
    ZFS ‚Äî  ,  mdadm+lvm    .<br>
<br>
           .      .   .  .  .  .      ,       . <br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum dann BTRFS ...?</font></font></b><div class="spoiler_text">            Legacy/BIOS GRUB  , ,  ,   -.      /boot .  ,       / ()   ,           LVM     . <br>
<br>
   ,          .<br>
                       send/recieve.<br>
<br>
 ,                        GPU  PCI-USB Host-  KVM  IOMMU.<br>
<br>
    ‚Äî  ,    .<br>
<br>
    ZFS, ,  ,     .<br>
<br>
  ,       / RAID      ZFS, BRTFS  LVM.<br>
<br>
   , BTRFS       ,         /    HDD.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Scannen Sie alle Ger√§te erneut: Schauen wir uns um </font></font><br>
<br>
<code>#udevadm control --reload-rules &amp;&amp; udevadm trigger</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
:</font></font><br>
<br>
<code>#lsscsi &amp;&amp; nvme list<br>
[0:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sda <br>
[1:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdb <br>
[2:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdc <br>
[3:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdd <br>
[4:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sde <br>
[5:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdf <br>
[6:0:0:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdg <br>
[6:0:1:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdh <br>
[6:0:2:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdi <br>
[6:0:3:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdj <br>
[6:0:4:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdk <br>
[6:0:5:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdl <br>
[6:0:6:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdm <br>
[6:0:7:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdn <br>
Node SN Model Namespace Usage Format FW Rev <br>
---------------- -------------------- ---------------------------------------- --------- -------------------------- ---------------- --------<br>
/dev/nvme0n1 S466NXXXXXXX15L Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
/dev/nvme1n1 S5H7NXXXXXXX48N Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partitionierung von "Laufwerken"</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber in keiner Weise werden wir sie markieren. </font><font style="vertical-align: inherit;">Trotzdem sieht unser BIOS diese Laufwerke nicht. </font><font style="vertical-align: inherit;">Sie werden also vollst√§ndig auf Software-RAID umsteigen. </font><font style="vertical-align: inherit;">Wir werden dort nicht einmal Partitionen erstellen. </font><font style="vertical-align: inherit;">Wenn Sie nach dem "Kanon" oder "Prinzip" m√∂chten, erstellen Sie eine gro√üe Partition wie eine Festplatte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA-Festplatte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nichts Besonderes zu erfinden. </font><font style="vertical-align: inherit;">Wir werden f√ºr alles einen Abschnitt erstellen. </font><font style="vertical-align: inherit;">Wir werden den Abschnitt erstellen, da das BIOS diese Datentr√§ger sieht und m√∂glicherweise sogar versucht, von ihnen zu booten. </font><font style="vertical-align: inherit;">Wir werden GRUB sp√§ter sogar auf diesen Festplatten installieren, damit das System pl√∂tzlich erfolgreich ist.</font></font><br>
<br>
<code>#cat &gt;hdd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sdg<br>
unit: sectors<br>
<br>
/dev/sdg1 : start= 2048, size= 1953523120, type=fd, bootable<br>
EOF<br>
#sfdisk /dev/sdg &lt; hdd.part<br>
#sfdisk /dev/sdh &lt; hdd.part<br>
#sfdisk /dev/sdi &lt; hdd.part<br>
#sfdisk /dev/sdj &lt; hdd.part<br>
#sfdisk /dev/sdk &lt; hdd.part<br>
#sfdisk /dev/sdl &lt; hdd.part<br>
#sfdisk /dev/sdm &lt; hdd.part<br>
#sfdisk /dev/sdn &lt; hdd.part<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA SSD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir die interessantesten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens haben wir 2 TB-Laufwerke. </font><font style="vertical-align: inherit;">Dies liegt innerhalb der zul√§ssigen Grenzen f√ºr MBR, die wir verwenden werden. </font><font style="vertical-align: inherit;">Kann bei Bedarf durch GPT ersetzt werden. </font><font style="vertical-align: inherit;">GPT-Festplatten verf√ºgen √ºber eine Kompatibilit√§tsschicht, mit der MBR-kompatible Systeme die ersten 4 Partitionen anzeigen k√∂nnen, wenn sie sich innerhalb der ersten 2 Terabyte befinden. </font><font style="vertical-align: inherit;">Die Hauptsache ist, dass die Boot-Partition und die bios_grub-Partition auf diesen Festplatten am Anfang stehen sollten. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie sogar vom GPT Legacy / BIOS-Laufwerk booten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist jedoch nicht unser Fall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier erstellen wir zwei Abschnitte. </font><font style="vertical-align: inherit;">Die erste ist 1 GB gro√ü und wird f√ºr RAID 1 / Boot verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite wird f√ºr RAID 6 verwendet und belegt den gesamten verbleibenden freien Speicherplatz mit Ausnahme eines kleinen nicht zugewiesenen Bereichs am Ende des Laufwerks.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der nicht zugewiesene Bereich?</font></font></b><div class="spoiler_text">     SATA SSD      SLC    6  78 . 6    ¬´¬ª     ¬´¬ª  ¬´¬ª   .  72      . <br>
<br>
  ,     SLC,      4 bit MLC.     ,    4       1  SLC .<br>
<br>
 72   4   288 .           ,       SLC .<br>
<br>
 ,     312  SLC     .    2    RAID  .<br>
<br>
            ,      .        QLC , ‚Äî          .      , ,       ,    SSD     TBW  .<br>
</div></div><br>
<code>#cat &gt;ssd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sda<br>
unit: sectors<br>
<br>
/dev/sda1 : start= 2048, size= 2097152, type=fd, bootable<br>
/dev/sda2 : start= 2099200, size= 3300950016, type=fd<br>
EOF<br>
#sfdisk /dev/sda &lt; ssd.part<br>
#sfdisk /dev/sdb &lt; ssd.part<br>
#sfdisk /dev/sdc &lt; ssd.part<br>
#sfdisk /dev/sdd &lt; ssd.part<br>
#sfdisk /dev/sde &lt; ssd.part<br>
#sfdisk /dev/sdf &lt; ssd.part<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays erstellen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst m√ºssen wir das Auto umbenennen. </font><font style="vertical-align: inherit;">Dies ist erforderlich, da der Hostname irgendwo innerhalb von mdadm Teil des Array-Namens ist und irgendwo etwas beeinflusst. </font><font style="vertical-align: inherit;">Arrays k√∂nnen nat√ºrlich sp√§ter umbenannt werden, dies sind jedoch unn√∂tige Aktionen.</font></font><br>
<br>
<code>#mcedit /etc/hostname <br>
#mcedit /etc/hosts<br>
#hostname<br>
vdesk0<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md0 --level=1 --raid-devices=2 /dev/nvme[0-1]n1</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum - sauber machen ...?</font></font></b><div class="spoiler_text">   .    RAID 1  6  .      ,    .  ,   SSD   ‚Äî     TBW.   TRIM/DISCARD      SSD   ¬´¬ª.<br>
<br>
  SSD RAID 1 DISCARD   .<br>
<br>
  SSD RAID 6 DISCARD      . <br>
<br>
      ,    SSD     4/5/6       discard_zeroes_data.    ,       , , -,  ,     .       , ,       .     DISCARD -   RAID 6.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achtung, der folgende Befehl zerst√∂rt alle Daten auf NVMe-Laufwerken, indem das Array mit "Nullen" "initialisiert" wird. </font></font><br>
<br>
<code>#blkdiscard /dev/md0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn etwas schief gelaufen ist, geben Sie einen Schritt an.</font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md0</code><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA SSD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md1 --level=1 --raid-devices=6 /dev/sd[a-f]1</code><br>
<code>#blkdiscard /dev/md1</code><br>
<code>#mdadm --create --verbose --assume-clean /dev/md2 --chunk-size=512 --level=6 --raid-devices=6 /dev/sd[a-f]2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum so gro√ü ...?</font></font></b><div class="spoiler_text"> chunk-size         chunk-size .   ,              . , IOPS    .   99% IO   512K.<br>
<br>
 RAID 6 IOPS   <b></b>    IOPS   .      IOPS          ,       . <br>
           RAID 6 by-design     ,   RAID 6   .<br>
   RAID 6      NVMe    thin-provisioning.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben DISCARD f√ºr RAID 6 noch nicht aktiviert. Daher werden wir dieses Array noch nicht "initialisieren". </font><font style="vertical-align: inherit;">Wir werden es sp√§ter nach der Installation des Betriebssystems tun.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA-Festplatte</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md3 --chunk-size=512 --level=6 --raid-devices=8 /dev/sd[g-n]1</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM auf NVMe RAID</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Gr√ºnden der Geschwindigkeit m√∂chten wir den Root-FS auf NVMe RAID 1 platzieren, das / dev / md0 ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotzdem ben√∂tigen wir dieses schnelle Array f√ºr andere Anforderungen wie Swap, Metadaten und LVM-Cache sowie LVM-Thin-Metadaten. Daher werden wir auf diesem Array LVM VG erstellen. </font><font style="vertical-align: inherit;">
Erstellen Sie eine Partition f√ºr den Root-FS. </font><font style="vertical-align: inherit;">
Erstellen Sie einen Abschnitt, um die Gr√∂√üe des Arbeitsspeichers zu √§ndern.</font></font><br>
<br>
<code>#pvcreate /dev/md0<br>
#vgcreate root /dev/md0</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 128G --name root root</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 32G --name swap root</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation des Betriebssystems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt haben wir alles Notwendige, um das System zu installieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starten Sie den Installationsassistenten in der Ubuntu Live-Umgebung. </font><font style="vertical-align: inherit;">Normale Installation. </font><font style="vertical-align: inherit;">Erst in der Phase der Auswahl der Laufwerke f√ºr die Installation m√ºssen Sie Folgendes angeben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / md1, - Mountpunkt / Boot, FS - BTRFS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / root (auch bekannt als / dev / mapper / root-root), - Mountpunkt / (root), FS - BTRFS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / swap (auch bekannt als / dev / mapper / root-swap), - als Swap-Partition verwenden</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bootloader-Installation unter / dev / sda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie BTRFS als Root-FS ausw√§hlen, erstellt das Installationsprogramm automatisch zwei BTRFS-Volumes mit den Namen "@" f√ºr / (root) und "@home" f√ºr / home. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten die Installation ... Die </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installation endet mit einem modalen Dialogfeld, das √ºber den Installationsfehler des Bootloaders informiert. </font><font style="vertical-align: inherit;">Leider schl√§gt es fehl, diesen Dialog regelm√§√üig zu verlassen und die Installation fortzusetzen. </font><font style="vertical-align: inherit;">Wir melden uns vom System ab und wieder an, um auf den sauberen Ubuntu Live-Desktop zu gelangen. </font><font style="vertical-align: inherit;">√ñffnen Sie das Terminal und erneut: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie eine Chroot-Umgebung, um die Installation fortzusetzen: Richten Sie das </font><font style="vertical-align: inherit;">
Netzwerk und den Hostnamen in Chroot ein: Wechseln </font><font style="vertical-align: inherit;">
Sie zur Chroot-Umgebung: Liefern Sie </font><font style="vertical-align: inherit;">
zuerst die Pakete: </font><font style="vertical-align: inherit;">
√úberpr√ºfen und reparieren Sie alle Pakete, die aufgrund der unvollst√§ndigen Installation des Systems schief gelaufen sind:</font></font><br>
<br>
<code>#mkdir /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@ /dev/mapper/root-root /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@home /dev/mapper/root-root /mnt/chroot/home<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard /dev/md1 /mnt/chroot/boot<br>
#mount --bind /proc /mnt/chroot/proc <br>
#mount --bind /sys /mnt/chroot/sys<br>
#mount --bind /dev /mnt/chroot/dev<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat /etc/hostname &gt;/mnt/chroot/etc/hostname<br>
#cat /etc/hosts &gt;/mnt/chroot/etc/hosts<br>
#cat /etc/resolv.conf &gt;/mnt/chroot/etc/resolv.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#chroot /mnt/chroot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>apt-get install --reinstall mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc debsums hdparm</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#CORRUPTED_PACKAGES=$(debsums -s 2&gt;&amp;1 | awk '{print $6}' | uniq)<br>
#apt-get install --reinstall $CORRUPTED_PACKAGES<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn etwas nicht zusammenw√§chst, m√ºssen Sie m√∂glicherweise vorher /etc/apt/sources.list </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bearbeiten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√Ñndern Sie die Parameter f√ºr das RAID 6-Modul, um TRIM / DISCARD zu aktivieren: Wir werden </font><font style="vertical-align: inherit;">
unsere Arrays leicht anpassen:</font></font><br>
<br>
<code>#cat &gt;/etc/modprobe.d/raid456.conf &lt;&lt; EOF<br>
options raid456 devices_handle_discard_safely=1<br>
EOF<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;/etc/udev/rules.d/60-md.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/stripe_cache_size", ATTR{md/stripe_cache_size}="32768"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_min", ATTR{md/sync_speed_min}="48000"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_max", ATTR{md/sync_speed_max}="300000"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/62-hdparm.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/hdparm -B 254 /dev/%k"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/63-blockdev.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/blockdev --setra 1024 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="nvme[0-9]n1", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="dm-*", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="md*", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was war das..?</font></font></b><div class="spoiler_text">   udev     :<br>
<br>
<ul>
<li>    2020-      RAID 6.  -, ,      Linux,     .</li>
<li>    /   IO.  ,           .</li>
<li>    /   IO.  ,  / SSD RAID-       .    NVMe. (   ?    . )</li>
<li>   APM     (HDD)         7 .    APM      (-B 255).   -      .      ,   , ,  -.       .    -        .     , , - ¬´¬ª,    -,    RAID-   mini-MAID-.</li>
<li> readahead   ()  1  ‚Äî   /chunk RAID 6</li>
<li> readahead  SATA SSD</li>
<li> readahead  NVMe SSD</li>
<li> readahead   LVM    SSD.</li>
<li> readahead   RAID .</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bearbeiten Sie / etc / fstab:</font></font><br>
<br>
<code>#cat &gt;/etc/fstab &lt;&lt; EOF<br>
# /etc/fstab: static file system information.<br>
#<br>
# Use 'blkid' to print the universally unique identifier for a<br>
# device; this may be used with UUID= as a more robust way to name devices<br>
# that works even if disks are added and removed. See fstab(5).<br>
# file-system mount-point type options dump pass<br>
/dev/mapper/root-root / btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@ 0 1<br>
UUID=$(blkid -o value -s UUID /dev/md1) /boot btrfs defaults,space_cache,noatime,nodiratime,discard 0 2<br>
/dev/mapper/root-root /home btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@home 0 2<br>
/dev/mapper/root-swap none swap sw 0 0<br>
EOF</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum so..?</font></font></b><div class="spoiler_text"> /boot     UUID ..     .<br>
<br>
      LVM    /dev/mapper/vg-lv, ..     . <br>
<br>
  UUID  LVM .. UUID  LVM      .</div></div><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweimal mounten wir / dev / mapper / root-root ..?</font></font></b><div class="spoiler_text">.  .  BTRFS.         subvol.<br>
<br>
  -      LVM   BTRFS .     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir generieren die mdadm-Konfiguration neu: </font><font style="vertical-align: inherit;">
Korrigieren Sie die LVM-Einstellungen:</font></font><br>
<br>
<code>#/usr/share/mdadm/mkconf | sed 's/#DEVICE/DEVICE/g' &gt;/etc/mdadm/mdadm.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;&gt;/etc/lvm/lvmlocal.conf &lt;&lt; EOF<br>
<br>
activation {<br>
 thin_pool_autoextend_threshold=90<br>
 thin_pool_autoextend_percent=5<br>
}<br>
allocation {<br>
 cache_pool_max_chunks=2097152<br>
}<br>
devices {<br>
 global_filter=["r|^/dev/.*_corig$|","r|^/dev/.*_cdata$|","r|^/dev/.*_cmeta$|","r|^/dev/.*gpv$|","r|^/dev/images/.*$|","r|^/dev/mapper/images.*$|","r|^/dev/backup/.*$|","r|^/dev/mapper/backup.*$|"]<br>
 issue_discards=1<br>
}<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was war das..?</font></font></b><div class="spoiler_text">     LVM thin   90%    5%  .<br>
<br>
       LVM cache.<br>
<br>
  LVM  LVM  (PV) :<br>
<br>
<ul>
<li>   LVM cache (cdata)</li>
<li>     LVM cache    (&lt;lv_name&gt;_corig).            ( &lt;lv_name&gt;).</li>
<li>    LVM cache (cmeta)</li>
<li>    VG   images.        , ,     LVM       .</li>
<li>    VG   backup.         .</li>
<li>       ¬´gpv¬ª ( guest physical volume )</li>
</ul><br>
   DISCARD      LVM VG.  .    LV  SSD  .     SSD RAID 6. ,  ,    thin provisioning,  ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aktualisieren Sie das initramfs-Image: </font></font><br>
<br>
<code>#update-initramfs -u -k all</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installieren und konfigurieren Sie grub:</font></font><br>
<br>
<code>#apt-get install grub-pc<br>
#apt-get purge os-prober<br>
#dpkg-reconfigure grub-pc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Laufwerke zur Auswahl?</font></font></b><div class="spoiler_text">  sd*.         SATA   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum os-prober genagelt ..?</font></font></b><div class="spoiler_text">     . <br>
<br>
       RAID-    .      ,         .<br>
<br>
   ,   , ,    .         .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit haben wir die Erstinstallation abgeschlossen. </font><font style="vertical-align: inherit;">Es ist Zeit, das neu installierte Betriebssystem neu zu starten. </font><font style="vertical-align: inherit;">Denken Sie daran, die bootf√§hige Live-CD / USB zu entfernen. </font><font style="vertical-align: inherit;">
W√§hlen Sie als zu startendes Ger√§t eine der SATA-SSDs aus.</font></font><br>
<br>
<code>#exit<br>
#reboot</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM zu SATA SSD</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zeitpunkt haben wir bereits das neue Betriebssystem gestartet, das Netzwerk konfiguriert, apt, den Terminalemulator ge√∂ffnet und gestartet: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Initialisieren" eines Arrays von einer SATA-SSD: </font></font><br>
<br>
<code>#blkdiscard /dev/md2</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies nicht der Fall ist, versuchen Sie: </font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md2</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LVM-VG auf einer SATA-SSD erstellen:</font></font><br>
<br>
<code>#pvcreate /dev/md2<br>
#vgcreate data /dev/md2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum noch eine vg ..?</font></font></b><div class="spoiler_text">  ,     VG   root.        VG?<br>
<br>
  VG   PV,     VG  PV   (online).   LVM RAID,     .<br>
<br>
  ,    (  )    RAID 6           .<br>
<br>
 ,           ¬´¬ª   VG.<br>
<br>
 -,   RAID     ¬´ ¬ª.         ,    VG.<br>
<br>
 LVM  ¬´¬ª        RAID  -  . , ‚Äî  <b></b> bcache + LVM thin, bcache + BTRFS, LVM cache + LVM thin,   ZFS       ,      .<br>
<br>
 ¬´¬ª   ,  - ¬´¬ª LVM-,   .    , ,     .<br>
<br>
,   ,     -   .<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM zu SATA HDD</font></font></h3><br>
<code>#pvcreate /dev/md3<br>
#vgcreate backup /dev/md3</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wieder die neue VG ..?</font></font></b><div class="spoiler_text">  ,     ,        ,      , -     . , -   VG, ‚Äî    VG.<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurieren Sie den LVM-Cache</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie LV auf NVMe RAID 1, um es als Caching-Ger√§t zu verwenden.</font></font><br>
<br>
<code>#lvcreate -L 70871154688B --name cache root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum so wenig ...?</font></font></b><div class="spoiler_text">  ,    NVMe SSD   SLC . 4  ¬´¬ª  18         3-bit MLC. -   NVMe SSD       SATA SSD  . ,        LVM cache      SLC  NVMe .   NVMe      32-64  . <br>
<br>
      64  ,       .<br>
<br>
 ,      LVM         .  ,       lvchange       . ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen wir LV auf SATA RAID 6, um es als zwischengespeichertes Ger√§t zu verwenden.</font></font><br>
<br>
<code>#lvcreate -L 3298543271936B --name cache data</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nur drei Terabyte ..?</font></font></b><div class="spoiler_text">,  ,    SATA SSD RAID 6  -  .      ,  ,    .         , ,   LVM-cache , , bcache,  ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie eine neue VG f√ºr das Caching. </font><font style="vertical-align: inherit;">
Erstellen Sie LV auf dem zwischengespeicherten Ger√§t. </font><font style="vertical-align: inherit;">
Hier haben wir sofort den gesamten freien Speicherplatz in / dev / data / cache belegt, sodass alle anderen erforderlichen Partitionen sofort in / dev / root / cache erstellt wurden. </font><font style="vertical-align: inherit;">Wenn Sie dort etwas nicht erstellt haben, k√∂nnen Sie es mit pvmove verschieben. </font><font style="vertical-align: inherit;">
Erstellen und aktivieren Sie den Cache:</font></font><br>
<br>
<code>#pvcreate /dev/root/cache<br>
#pvcreate /dev/data/cache<br>
#vgcreate cache /dev/root/cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 3298539077632B --name cachedata cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -y -L 64G -n cache cache /dev/root/cache<br>
#lvcreate -y -L 1G -n cachemeta cache /dev/root/cache<br>
#lvconvert -y --type cache-pool --cachemode writeback --chunksize 64k --poolmetadata cache/cachemeta cache/cache<br>
#lvconvert -y --type cache --cachepool cache/cache cache/cachedata<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum so Chunksize ..?</font></font></b><div class="spoiler_text">     ,        LVM cache     LVM thin.  ,   ,        . <br>
<br>
64 ‚Äî       LVM thin.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achtung R√ºckschreiben ..!</font></font></b><div class="spoiler_text">.         .    , ,    ,      .   ,  ,  NVMe RAID 1  ,    . <br>
<br>
    ,     RAID 6   .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen wir, ob dies erfolgreich war: </font><font style="vertical-align: inherit;">
Nur [cachedata_corig] sollte sich in / dev / data / cache befinden. </font><font style="vertical-align: inherit;">Wenn etwas nicht stimmt, verwenden Sie pvmove. </font><font style="vertical-align: inherit;">
Bei Bedarf k√∂nnen Sie den Cache mit einem Befehl deaktivieren: </font><font style="vertical-align: inherit;">
Dies erfolgt online. </font><font style="vertical-align: inherit;">LVM synchronisiert einfach den Cache mit der Festplatte, l√∂scht ihn und benennt cachedata_corig wieder in cachedata um.</font></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B cache<br>
 LV LSize Devices <br>
 [cache] 68719476736B cache_cdata(0) <br>
 [cache_cdata] 68719476736B /dev/root/cache(0) <br>
 [cache_cmeta] 1073741824B /dev/root/cache(16384)<br>
 cachedata 3298539077632B cachedata_corig(0) <br>
 [cachedata_corig] 3298539077632B /dev/data/cache(0) <br>
 [lvol0_pmspare] 1073741824B /dev/root/cache(16640)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvconvert -y --uncache cache/cachedata</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM Thin Setup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden </font><font style="vertical-align: inherit;">
ungef√§hr </font><font style="vertical-align: inherit;">sch√§tzen, wie viel Speicherplatz wir f√ºr LVM-Thin-Metadaten ben√∂tigen: </font><font style="vertical-align: inherit;">Auf 4 Gigabyte aufrunden: 4294967296B Mit </font><font style="vertical-align: inherit;">
zwei multiplizieren und 4194304B f√ºr LVM-Metadaten hinzuf√ºgen PV: 8594128896B </font><font style="vertical-align: inherit;">
Erstellen Sie eine separate Partition auf NVMe RAID 1, um LVM-Thin-Metadaten darauf zu markieren und zu sichern:</font></font><br>
<br>
<code>#thin_metadata_size --block-size=64k --pool-size=6terabytes --max-thins=100000 -u bytes<br>
thin_metadata_size - 3385794560 bytes estimated metadata area size for "--block-size=64kibibytes --pool-size=6terabytes --max-thins=100000"</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 8594128896B --name images root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wozu..?</font></font></b><div class="spoiler_text">   ,    LVM thin ,        NVMe    .<br>
<br>
     ,     .    ,  ,   .    - , ,   LVM thin  ,      .         .<br>
<br>
-    -,  , ,          .             ,      .           .<br>
<br>
 ,        , ,  ,       , ,      LVM thin,        . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie eine neue VG, die f√ºr die Thin-Bereitstellung verantwortlich ist: </font><font style="vertical-align: inherit;">
Erstellen Sie einen Pool:</font></font><br>
<br>
<code>#pvcreate /dev/root/images<br>
#pvcreate /dev/cache/cachedata<br>
#vgcreate images /dev/root/images /dev/cache/cachedata</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T images/thin-pool</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum -Z y</font></font></b><div class="spoiler_text"> ,       , ‚Äî               , ‚Äî zeroing          64k.    64k           64K    .          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verschieben </font><font style="vertical-align: inherit;">
wir </font><font style="vertical-align: inherit;">LV zu den entsprechenden PVs: </font><font style="vertical-align: inherit;">√úberpr√ºfen: </font><font style="vertical-align: inherit;">
Erstellen Sie ein Thin Volume f√ºr Tests: </font><font style="vertical-align: inherit;">
Legen Sie Pakete f√ºr Tests und Beobachtungen ab: </font><font style="vertical-align: inherit;">
So k√∂nnen Sie das Verhalten unserer Speicherkonfiguration in Echtzeit beobachten: </font><font style="vertical-align: inherit;">
So k√∂nnen Sie unsere Konfiguration testen:</font></font><br>
<br>
<code>#pvmove -n images/thin-pool_tdata /dev/root/images /dev/cache/cachedata<br>
#pvmove -n images/lvol0_pmspare /dev/cache/cachedata /dev/root/images<br>
#pvmove -n images/thin-pool_tmeta /dev/cache/cachedata /dev/root/images <br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B images<br>
 LV LSize Devices <br>
 [lvol0_pmspare] 4294967296B /dev/root/images(0) <br>
 thin-pool 274877906944B thin-pool_tdata(0) <br>
 [thin-pool_tdata] 274877906944B /dev/cache/cachedata(0) <br>
 [thin-pool_tmeta] 4294967296B /dev/root/images(1024)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -V 64G --thin-pool thin-pool --name test images</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#apt-get install sysstat fio</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#watch 'lvs --rows --reportformat basic --quiet -ocache_dirty_blocks,cache_settings cache/cachedata &amp;&amp; (lvdisplay cache/cachedata | grep Cache) &amp;&amp; (sar -p -d 2 1 | grep -E "sd|nvme|DEV|md1|md2|md3|md0" | grep -v Average | sort)'</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#fio --loops=1 --size=64G --runtime=4 --filename=/dev/images/test --stonewall --ioengine=libaio --direct=1 \<br>
--name=4kQD32read --bs=4k --iodepth=32 --rw=randread \<br>
--name=8kQD32read --bs=8k --iodepth=32 --rw=randread \<br>
--name=16kQD32read --bs=16k --iodepth=32 --rw=randread \<br>
--name=32KQD32read --bs=32k --iodepth=32 --rw=randread \<br>
--name=64KQD32read --bs=64k --iodepth=32 --rw=randread \<br>
--name=128KQD32read --bs=128k --iodepth=32 --rw=randread \<br>
--name=256KQD32read --bs=256k --iodepth=32 --rw=randread \<br>
--name=512KQD32read --bs=512k --iodepth=32 --rw=randread \<br>
--name=4Kread --bs=4k --rw=read \<br>
--name=8Kread --bs=8k --rw=read \<br>
--name=16Kread --bs=16k --rw=read \<br>
--name=32Kread --bs=32k --rw=read \<br>
--name=64Kread --bs=64k --rw=read \<br>
--name=128Kread --bs=128k --rw=read \<br>
--name=256Kread --bs=256k --rw=read \<br>
--name=512Kread --bs=512k --rw=read \<br>
--name=Seqread --bs=1m --rw=read \<br>
--name=Longread --bs=8m --rw=read \<br>
--name=Longwrite --bs=8m --rw=write \<br>
--name=Seqwrite --bs=1m --rw=write \<br>
--name=512Kwrite --bs=512k --rw=write \<br>
--name=256Kwrite --bs=256k --rw=write \<br>
--name=128Kwrite --bs=128k --rw=write \<br>
--name=64Kwrite --bs=64k --rw=write \<br>
--name=32Kwrite --bs=32k --rw=write \<br>
--name=16Kwrite --bs=16k --rw=write \<br>
--name=8Kwrite --bs=8k --rw=write \<br>
--name=4Kwrite --bs=4k --rw=write \<br>
--name=512KQD32write --bs=512k --iodepth=32 --rw=randwrite \<br>
--name=256KQD32write --bs=256k --iodepth=32 --rw=randwrite \<br>
--name=128KQD32write --bs=128k --iodepth=32 --rw=randwrite \<br>
--name=64KQD32write --bs=64k --iodepth=32 --rw=randwrite \<br>
--name=32KQD32write --bs=32k --iodepth=32 --rw=randwrite \<br>
--name=16KQD32write --bs=16k --iodepth=32 --rw=randwrite \<br>
--name=8KQD32write --bs=8k --iodepth=32 --rw=randwrite \<br>
--name=4kQD32write --bs=4k --iodepth=32 --rw=randwrite \<br>
 | grep -E 'read|write|test' | grep -v ioengine<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorsicht! </font><font style="vertical-align: inherit;">Ressource!</font></font></b><div class="spoiler_text">   36  ,       4 .     .  4   NVMe     .  3   .  ,           216   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shuffle lesen und schreiben?</font></font></b><div class="spoiler_text">.          .  ,   ,    ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse variieren stark beim ersten Start und bei den nachfolgenden, wenn sich der Cache und das Thin Volume f√ºllen. Dies h√§ngt auch davon ab, ob das System die beim letzten Start gef√ºllten Caches synchronisieren konnte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich empfehle unter anderem, die Geschwindigkeit an dem bereits gef√ºllten d√ºnnen Volumen zu messen, aus dem der Schnappschuss gerade erstellt wurde. </font><font style="vertical-align: inherit;">Der Autor hatte die M√∂glichkeit zu beobachten, wie sich die zuf√§llige Aufzeichnung unmittelbar nach der Erstellung des ersten Schnappschusses stark beschleunigt, insbesondere wenn der Cache noch nicht voll ist. </font><font style="vertical-align: inherit;">Dies liegt an der Schreibsemantik beim Schreiben, der Ausrichtung von Cache-Bl√∂cken und Thin-Volumes sowie an der Tatsache, dass zuf√§lliges Schreiben in RAID 6 zu zuf√§lligem Lesen von RAID 6 und anschlie√üendem Schreiben in den Cache wird. </font><font style="vertical-align: inherit;">In unserer Konfiguration ist das zuf√§llige Lesen von RAID 6 bis zu 6 Mal (die Anzahl der SATA-SSDs im Array) schneller als das Schreiben. </font><font style="vertical-align: inherit;">weil </font><font style="vertical-align: inherit;">Da CoW-Bl√∂cke nacheinander aus einem Thin Pool zugewiesen werden, wird der Datensatz gr√∂√ütenteils auch zu einem sequentiellen Datensatz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Merkmale k√∂nnen vorteilhaft genutzt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache "koh√§rente" Schnappsch√ºsse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Risiko eines Datenverlusts bei Cache-Sch√§den / -Verlusten zu verringern, empfiehlt der Autor, die Praxis des Rotierens von Snapshots einzuf√ºhren, um deren Integrit√§t in diesem Fall zu gew√§hrleisten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens sind die Metadaten aufgrund der Tatsache, dass sich die Metadaten d√ºnner Volumes auf einem nicht zwischengespeicherten Ger√§t befinden, konsistent und m√∂gliche Verluste werden innerhalb der Datenbl√∂cke isoliert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der folgende Snapshot-Rotationszyklus garantiert die Datenintegrit√§t in Snapshots bei Cache-Verlust:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie f√ºr jedes Thin-Volume mit dem Namen &lt;Name&gt; einen Snapshot mit dem Namen &lt;Name&gt; .cached</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie den Migrationsschwellenwert auf einen angemessen hohen Wert ein: </font></font><code>#lvchange --quiet --cachesettings "migration_threshold=16384" cache/cachedata</code> </li>
<li>       : <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>    .     ,        writethrough . ,      SATA  NVMe SSD,  ,   TBW,            ,           . -          100%    .  NVMe SSD  100%        <b>3-4 </b>. SATA SSD  -    . ,   ,       ,     , ‚Äî             .</li>
<li>   ( )  ‚Äî  &lt;&gt;.cached  &lt;&gt;.committed.  &lt;&gt;.committed   .</li>
<li>,     100%,    ,   .         .</li>
<li> migration threshold  : <code>#lvchange --quiet --cachesettings "migration_threshold=0" cache/cachedata</code>        . </li>
<li>,        <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>   .</li>
<li> . </li>
</ol><br>
<div class="spoiler"><b class="spoiler_title">   migration threshold...?</b><div class="spoiler_text">   ,     ¬´¬ª       .    -    4 ,   ,         -     (+- 32K) .<br>
<br>
 migration threshold        SATA SSD       64K  .      SATA SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title">  ..?</b><div class="spoiler_text"> ,         bash     100%    ¬´google¬ª-driven development,  ,    ,      ,     .<br>
<br>
,               , ,  ,      systemd ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem solchen einfachen Rotationsschema f√ºr Snapshots k√∂nnen wir nicht nur st√§ndig einen Snapshot vollst√§ndig auf der SATA-SSD synchronisieren, sondern auch mithilfe des Dienstprogramms thin_delta herausfinden, welche Bl√∂cke nach ihrer Erstellung ge√§ndert wurden, und so den Schaden auf den Hauptvolumes lokalisieren, wodurch die Wiederherstellung erheblich vereinfacht wird .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TRIM / DISCARD in libvirt / KVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
weil </font><font style="vertical-align: inherit;">Da der Datenspeicher f√ºr KVM verwendet wird, auf dem libvirt ausgef√ºhrt wird, w√§re es hilfreich, unseren VMs beizubringen, nicht nur freien Speicherplatz zu belegen, sondern auch das freizugeben, was nicht mehr ben√∂tigt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies erfolgt durch Emulieren der TRIM / DISCARD-Unterst√ºtzung auf virtuellen Festplatten. </font><font style="vertical-align: inherit;">√Ñndern Sie dazu den Controller-Typ in virtio-scsi und bearbeiten Sie die XML. </font><font style="vertical-align: inherit;">
√Ñhnliche DISCARDs von Gastbetriebssystemen werden von LVM korrekt verarbeitet, und Bl√∂cke werden sowohl im Cache als auch im Thin Pool korrekt freigegeben. </font><font style="vertical-align: inherit;">In unserem Fall geschieht dies haupts√§chlich verschoben, wenn Sie den n√§chsten Schnappschuss l√∂schen.</font></font><br>
<br>
<code>#virsh edit vmname<br>
&lt;disk type='block' device='disk'&gt;<br>
 &lt;driver name='qemu' type='raw' cache='writethrough' io='threads' <b>discard='unmap'</b>/&gt;<br>
 &lt;source dev='/dev/images/vmname'/&gt;<br>
 &lt;backingStore/&gt;<br>
 &lt;target dev='sda' bus='scsi'/&gt;<br>
 &lt;alias name='scsi0-0-0-0'/&gt;<br>
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;<br>
&lt;/disk&gt;<br>
<br>
&lt;controller type='scsi' index='0' <b>model='virtio-scsi'</b>&gt;<br>
 &lt;alias name='scsi0'/&gt;<br>
 &lt;address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;<br>
&lt;/controller&gt;<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BTRFS-Sicherung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie vorgefertigte Skripte mit </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§u√üerster</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorsicht und </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf eigene Gefahr und Gefahr</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Autor hat diesen Code selbst und exklusiv f√ºr sich selbst geschrieben. </font><font style="vertical-align: inherit;">Ich bin sicher , </font><font style="vertical-align: inherit;">dass viele erfahrene Linux - </font><font style="vertical-align: inherit;">Anwender so haben </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kr√ºcken von</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erfahrung, und kopieren Sie </font><font style="vertical-align: inherit;">andere nicht brauchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein Volume auf dem Sicherungsger√§t: </font></font><br>
<br>
<code>#lvcreate -L 256G --name backup backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formatieren Sie es in BTRFS: </font></font><br>
<br>
<code>#mkfs.btrfs /dev/backup/backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie Mount-Punkte und Mount-Root-Unterschl√ºssel des FS: </font><font style="vertical-align: inherit;">
Erstellen Sie Verzeichnisse f√ºr Backups: </font><font style="vertical-align: inherit;">
Erstellen Sie ein Verzeichnis f√ºr Backup-Skripte: Kopieren Sie das </font><font style="vertical-align: inherit;">
Skript:</font></font><br>
<br>
<code>#mkdir /backup<br>
#mkdir /backup/btrfs<br>
#mkdir /backup/btrfs/root<br>
#mkdir /backup/btrfs/back<br>
#ln -s /boot /backup/btrfs<br>
# cat &gt;&gt;/etc/fstab &lt;&lt; EOF<br>
<br>
/dev/mapper/root-root /backup/btrfs/root btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
/dev/mapper/backup-backup /backup/btrfs/back btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
EOF<br>
#mount -a<br>
#update-initramfs -u<br>
#update-grub<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /backup/btrfs/back/remote<br>
#mkdir /backup/btrfs/back/remote/root<br>
#mkdir /backup/btrfs/back/remote/boot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /root/btrfs-backup</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel gruseliger Bash-Code. </font><font style="vertical-align: inherit;">Benutzung auf eigene Gefahr. </font><font style="vertical-align: inherit;">Der Autor schreibt keine w√ºtenden Briefe ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/btrfs-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".@base"<br>
PEND_SUFFIX=".@pend"<br>
SNAP_SUFFIX=".@snap"<br>
MOUNTS="/backup/btrfs/"<br>
BACKUPS="/backup/btrfs/back/remote/"<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_PATH="$MOUNTS$1"<br>
TARGET_PATH="$BACKUPS$1"<br>
SOURCE_BASE_PATH="$MOUNTS$1$BASE_SUFFIX"<br>
TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
TARGET_BASE_DIR="$(dirname $TARGET_BASE_PATH)"<br>
SOURCE_PEND_PATH="$MOUNTS$1$PEND_SUFFIX"<br>
TARGET_PEND_PATH="$BACKUPS$1$PEND_SUFFIX"<br>
 if [ -d "$SOURCE_BASE_PATH" ]<br>
 then<br>
 echo "$SOURCE_BASE_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_PATH File not found creating snapshot of $SOURCE_PATH to $SOURCE_BASE_PATH"<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_BASE_PATH<br>
 sync<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found out of sync with source... removing..."<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 fi<br>
 fi<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_PATH not found. Synching to $TARGET_BASE_DIR"<br>
 btrfs send $SOURCE_BASE_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 fi<br>
 if [ -d "$SOURCE_PEND_PATH" ]<br>
 then<br>
 echo "$SOURCE_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $SOURCE_PEND_PATH<br>
 sync<br>
 fi<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_PEND_PATH<br>
 sync<br>
 if [ -d "$TARGET_PEND_PATH" ]<br>
 then<br>
 echo "$TARGET_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $TARGET_PEND_PATH<br>
 sync<br>
 fi<br>
 echo "Sending $SOURCE_PEND_PATH to $TARGET_PEND_PATH"<br>
 btrfs send -p $SOURCE_BASE_PATH $SOURCE_PEND_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 TARGET_DATE_SUFFIX=$(suffix)<br>
 btrfs subvolume snapshot -r $TARGET_PEND_PATH "$TARGET_PATH$TARGET_DATE_SUFFIX"<br>
 sync<br>
 btrfs subvolume delete -c $SOURCE_BASE_PATH<br>
 sync<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 mv $SOURCE_PEND_PATH $SOURCE_BASE_PATH<br>
 mv $TARGET_PEND_PATH $TARGET_BASE_PATH<br>
 sync<br>
}<br>
<br>
function list()<br>
{<br>
LIST_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
LIST_TARGET_BASE_DIR="$(dirname $LIST_TARGET_BASE_PATH)"<br>
LIST_TARGET_BASE_NAME="$(basename -s .$BASE_SUFFIX $LIST_TARGET_BASE_PATH)"<br>
find "$LIST_TARGET_BASE_DIR" -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | grep "${LIST_TARGET_BASE_NAME/$BASE_SUFFIX/$SNAP_SUFFIX}.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
REMOVE_TARGET_BASE_DIR="$(dirname $REMOVE_TARGET_BASE_PATH)"<br>
btrfs subvolume delete -c $REMOVE_TARGET_BASE_DIR/$2<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$2"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$1" "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1"<br>
 ;;<br>
 "list") <br>
 list "$1"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1" "$2"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht es √ºberhaupt ..?</font></font></b><div class="spoiler_text">       BTRFS        BTRFS send/recieve.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Start kann relativ lang sein, weil </font><font style="vertical-align: inherit;">Zu Beginn werden alle Daten kopiert. </font><font style="vertical-align: inherit;">Weitere Starts werden sehr schnell sein, weil </font><font style="vertical-align: inherit;">Es werden nur √Ñnderungen kopiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Skript, um Cron zu stopfen:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noch etwas Bash-Code</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/btrfs-backup.sh"<br>
RETENTION="-60 day"<br>
$BACKUP_SCRIPT backup root/@<br>
$BACKUP_SCRIPT removeall root/@ "$RETENTION"<br>
$BACKUP_SCRIPT backup root/@home<br>
$BACKUP_SCRIPT removeall root/@home "$RETENTION"<br>
$BACKUP_SCRIPT backup boot/<br>
$BACKUP_SCRIPT removeall boot/ "$RETENTION"<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht es ..?</font></font></b><div class="spoiler_text">     backup     BTRFS-.       60  .     /backup/btrfs/back/remote/     . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geben wir dem Code das Recht zur Ausf√ºhrung: </font><font style="vertical-align: inherit;">
√úberpr√ºfen und stopfen Sie die Kronen ein:</font></font><br>
<br>
<code>#chmod +x /root/btrfs-backup/cron-daily.sh<br>
#chmod +x /root/btrfs-backup/btrfs-backup.sh<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
#cat /var/log/syslog | grep btrfs-backup<br>
#crontab -e<br>
0 2 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM Thin Backup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie einen Thin Pool auf dem Sicherungsger√§t: </font></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T backup/thin-pool</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installieren Sie ddrescue, weil </font><font style="vertical-align: inherit;">Skripte verwenden dieses Tool: </font></font><br>
<br>
<code>#apt-get install gddrescue</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein Verzeichnis f√ºr Skripte: </font></font><br>
<br>
<code>#mkdir /root/lvm-thin-backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie die Skripte:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Bash drinnen ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/lvm-thin-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".base"<br>
PEND_SUFFIX=".pend"<br>
SNAP_SUFFIX=".snap"<br>
BACKUPS="backup"<br>
BACKUPS_POOL="thin-pool"<br>
<br>
export LVM_SUPPRESS_FD_WARNINGS=1<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function read_thin_id {<br>
lvs --rows --reportformat basic --quiet -othin_id "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_pool_lv {<br>
lvs --rows --reportformat basic --quiet -opool_lv "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_dm_path {<br>
lvs --rows --reportformat basic --quiet -olv_dm_path "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_active {<br>
lvs --rows --reportformat basic --quiet -olv_active "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_chunk_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -ochunk_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -olv_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function activate_volume {<br>
lvchange -ay -Ky "$1/$2"<br>
}<br>
<br>
function deactivate_volume {<br>
lvchange -an "$1/$2"<br>
}<br>
<br>
function read_thin_metadata_snap {<br>
dmsetup status "$1" | awk '{print $7}'<br>
}<br>
<br>
function thindiff()<br>
{<br>
DIFF_VG="$1"<br>
DIFF_SOURCE="$2"<br>
DIFF_TARGET="$3"<br>
DIFF_SOURCE_POOL=$(read_pool_lv $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_POOL=$(read_pool_lv $DIFF_VG $DIFF_TARGET)<br>
<br>
if [ "$DIFF_SOURCE_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Source LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_TARGET_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Target LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_SOURCE_POOL" != "$DIFF_TARGET_POOL" ]<br>
then<br>
 (&gt;&amp;2 echo "Source and target LVs belong to different thin pools.")<br>
 exit 1<br>
fi<br>
<br>
DIFF_POOL_PATH=$(read_lv_dm_path $DIFF_VG $DIFF_SOURCE_POOL)<br>
DIFF_SOURCE_ID=$(read_thin_id $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_ID=$(read_thin_id $DIFF_VG $DIFF_TARGET)<br>
DIFF_POOL_PATH_TPOOL="$DIFF_POOL_PATH-tpool"<br>
DIFF_POOL_PATH_TMETA="$DIFF_POOL_PATH"_tmeta<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" != "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Thin pool metadata snapshot already exist. Assuming stale one. Will release metadata snapshot in 5 seconds.")<br>
 sleep 5<br>
 dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
fi<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 reserve_metadata_snap<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" == "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Failed to create thin pool metadata snapshot.")<br>
 exit 1<br>
fi<br>
<br>
#We keep output in variable because metadata snapshot need to be released early.<br>
DIFF_DATA=$(thin_delta -m$DIFF_POOL_METADATA_SNAP --snap1 $DIFF_SOURCE_ID --snap2 $DIFF_TARGET_ID $DIFF_POOL_PATH_TMETA)<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
<br>
echo $"$DIFF_DATA" | grep -E 'different|left_only|right_only' | sed 's/&lt;/"/g' | sed 's/ /"/g' | awk -F'\"' '{print $6 "\t" $8 "\t" $11}' | sed 's/different/copy/g' | sed 's/left_only/copy/g' | sed 's/right_only/discard/g'<br>
<br>
}<br>
<br>
function thinsync()<br>
{<br>
SYNC_VG="$1"<br>
SYNC_PEND="$2"<br>
SYNC_BASE="$3"<br>
SYNC_TARGET="$4"<br>
SYNC_PEND_POOL=$(read_pool_lv $SYNC_VG $SYNC_PEND)<br>
SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SYNC_VG $SYNC_PEND_POOL)<br>
SYNC_PEND_PATH=$(read_lv_dm_path $SYNC_VG $SYNC_PEND)<br>
<br>
activate_volume $SYNC_VG $SYNC_PEND<br>
<br>
while read -r SYNC_ACTION SYNC_OFFSET SYNC_LENGTH ; do<br>
 SYNC_OFFSET_BYTES=$((SYNC_OFFSET * SYNC_BLOCK_SIZE))<br>
 SYNC_LENGTH_BYTES=$((SYNC_LENGTH * SYNC_BLOCK_SIZE))<br>
 if [ "$SYNC_ACTION" == "copy" ]<br>
 then<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SYNC_PEND_PATH" "$SYNC_TARGET"<br>
 fi<br>
<br>
if [ "$SYNC_ACTION" == "discard" ]<br>
 then<br>
 blkdiscard -o $SYNC_OFFSET_BYTES -l $SYNC_LENGTH_BYTES "$SYNC_TARGET"<br>
 fi<br>
done &lt; &lt;(thindiff "$SYNC_VG" "$SYNC_PEND" "$SYNC_BASE")<br>
}<br>
<br>
function discard_volume()<br>
{<br>
DISCARD_VG="$1"<br>
DISCARD_LV="$2"<br>
DISCARD_LV_PATH=$(read_lv_dm_path "$DISCARD_VG" "$DISCARD_LV")<br>
if [ "$DISCARD_LV_PATH" != "" ]<br>
then<br>
 echo "$DISCARD_LV_PATH found"<br>
else<br>
 echo "$DISCARD_LV not found in $DISCARD_VG"<br>
 exit 1<br>
fi<br>
DISCARD_LV_POOL=$(read_pool_lv $DISCARD_VG $DISCARD_LV)<br>
DISCARD_LV_SIZE=$(read_lv_size "$DISCARD_VG" "$DISCARD_LV")<br>
lvremove -y --quiet "$DISCARD_LV_PATH" || exit 1<br>
lvcreate --thin-pool "$DISCARD_LV_POOL" -V "$DISCARD_LV_SIZE"B --name "$DISCARD_LV" "$DISCARD_VG" || exit 1<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
SOURCE_PEND_LV="$SOURCE_LV$PEND_SUFFIX"<br>
TARGET_PEND_LV="$TARGET_LV$PEND_SUFFIX"<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "Source base not found creating snapshot of $SOURCE_VG/$SOURCE_LV to $SOURCE_VG/$SOURCE_BASE_LV"<br>
 lvcreate --quiet --snapshot --name "$SOURCE_BASE_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
 SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo "Discarding $SOURCE_BASE_LV_PATH as we need to bootstrap."<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 sync<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found out of sync with source... removing..."<br>
 lvremove -y --quiet $TARGET_BASE_LV_PATH || exit 1<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 sync<br>
 fi<br>
 fi<br>
SOURCE_BASE_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_VG/$TARGET_LV not found. Creating empty volume."<br>
 lvcreate --thin-pool "$BACKUPS_POOL" -V "$SOURCE_BASE_SIZE"B --name "$TARGET_BASE_LV" "$TARGET_VG" || exit 1<br>
 echo "Have to rebootstrap. Discarding source at $SOURCE_BASE_LV_PATH"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 TARGET_BASE_POOL=$(read_pool_lv $TARGET_VG $TARGET_BASE_LV)<br>
 TARGET_BASE_CHUNK_SIZE=$(read_lv_chunk_size $TARGET_VG $TARGET_BASE_POOL)<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 echo "Discarding target at $TARGET_BASE_LV_PATH"<br>
 discard_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 sync<br>
 fi<br>
 if [ "$SOURCE_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet "$SOURCE_PEND_LV_PATH" || exit 1<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$SOURCE_PEND_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 sync<br>
 if [ "$TARGET_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet $TARGET_PEND_LV_PATH<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$TARGET_PEND_LV" "$TARGET_VG/$TARGET_BASE_LV" || exit 1<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
SOURCE_PEND_LV_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 lvresize -L "$SOURCE_PEND_LV_SIZE"B "$TARGET_PEND_LV_PATH"<br>
 activate_volume "$TARGET_VG" "$TARGET_PEND_LV"<br>
 echo "Synching $SOURCE_PEND_LV_PATH to $TARGET_PEND_LV_PATH"<br>
 thinsync "$SOURCE_VG" "$SOURCE_PEND_LV" "$SOURCE_BASE_LV" "$TARGET_PEND_LV_PATH" || exit 1<br>
 sync<br>
<br>
TARGET_DATE_SUFFIX=$(suffix)<br>
 lvcreate --quiet --snapshot --name "$TARGET_LV$TARGET_DATE_SUFFIX" "$TARGET_VG/$TARGET_PEND_LV" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$SOURCE_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$TARGET_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvrename -y "$SOURCE_VG/$SOURCE_PEND_LV" "$SOURCE_BASE_LV" || exit 1<br>
 lvrename -y "$TARGET_VG/$TARGET_PEND_LV" "$TARGET_BASE_LV" || exit 1<br>
 sync<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function verify()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo Comparing "$SOURCE_BASE_LV_PATH" with "$TARGET_BASE_LV_PATH"<br>
 cmp "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function resync()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
<br>
echo Syncronizing "$SOURCE_BASE_LV_PATH" to "$TARGET_BASE_LV_PATH"<br>
<br>
CMP_OFFSET=0<br>
 while [[ "$CMP_OFFSET" != "" ]] ; do<br>
 CMP_MISMATCH=$(cmp -i "$CMP_OFFSET" "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH" | grep differ | awk '{print $5}' | sed 's/,//g' )<br>
 if [[ "$CMP_MISMATCH" != "" ]] ; then<br>
 CMP_OFFSET=$(( CMP_MISMATCH + CMP_OFFSET ))<br>
 SYNC_OFFSET_BYTES=$(( ( CMP_OFFSET / SYNC_BLOCK_SIZE ) * SYNC_BLOCK_SIZE ))<br>
 SYNC_LENGTH_BYTES=$(( SYNC_BLOCK_SIZE ))<br>
 echo "Synching $SYNC_LENGTH_BYTES bytes at $SYNC_OFFSET_BYTES from $SOURCE_BASE_LV_PATH to $TARGET_BASE_LV_PATH"<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 else<br>
 CMP_OFFSET=""<br>
 fi<br>
 done<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function list()<br>
{<br>
LIST_SOURCE_VG="$1"<br>
LIST_SOURCE_LV="$2"<br>
LIST_TARGET_VG="$BACKUPS"<br>
LIST_TARGET_LV="$LIST_SOURCE_VG-$LIST_SOURCE_LV"<br>
LIST_TARGET_BASE_LV="$LIST_TARGET_LV$SNAP_SUFFIX"<br>
lvs -olv_name | grep "$LIST_TARGET_BASE_LV.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_VG="$BACKUPS"<br>
REMOVE_TARGET_LV="$1"<br>
lvremove -y "$REMOVE_TARGET_VG/$REMOVE_TARGET_LV"<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$3"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" "$2" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1" "$2"<br>
 ;;<br>
 "list") <br>
 list "$1" "$2"<br>
 ;;<br>
 "thindiff") <br>
 thindiff "$1" "$2" "$3"<br>
 ;;<br>
 "thinsync") <br>
 thinsync "$1" "$2" "$3" "$4"<br>
 ;;<br>
 "verify") <br>
 wait_lock_or_terminate<br>
 verify "$1" "$2"<br>
 ;;<br>
 "resync") <br>
 wait_lock_or_terminate<br>
 resync "$1" "$2"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2" "$3"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht es ...?</font></font></b><div class="spoiler_text">             ,   thin_delta,       ddrescue  blkdiscard.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Skript, das wir in Kronen packen werden:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noch etwas Bash</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/lvm-thin-backup.sh"<br>
RETENTION="-60 days"<br>
<br>
$BACKUP_SCRIPT backup images linux-dev<br>
$BACKUP_SCRIPT backup images win8<br>
$BACKUP_SCRIPT backup images win8-data<br>
#etc<br>
<br>
$BACKUP_SCRIPT removeall images linux-dev "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8 "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8-data "$RETENTION"<br>
#etc<br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht es ...?</font></font></b><div class="spoiler_text">  ,         .      ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Skript muss bearbeitet werden und enth√§lt eine Liste der Thin-Volumes, f√ºr die Sicherungen erforderlich sind. </font><font style="vertical-align: inherit;">Die angegebenen Namen dienen nur zur Veranschaulichung. </font><font style="vertical-align: inherit;">Wenn Sie m√∂chten, k√∂nnen Sie ein Skript schreiben, das alle Volumes synchronisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns Rechte geben: </font><font style="vertical-align: inherit;">
√úberpr√ºfen und in die Kronen stopfen: </font><font style="vertical-align: inherit;">
Der erste Start wird lang sein, weil </font><font style="vertical-align: inherit;">Thin Volumes werden vollst√§ndig synchronisiert, indem der gesamte verwendete Speicherplatz kopiert wird. </font><font style="vertical-align: inherit;">Dank der LVM-Thin-Metadaten wissen wir, welche Bl√∂cke tats√§chlich verwendet werden, sodass nur die tats√§chlich verwendeten Bl√∂cke mit Thin-Volumes kopiert werden. </font><font style="vertical-align: inherit;">
Bei nachfolgenden Starts werden die Daten schrittweise kopiert, indem √Ñnderungen √ºber LVM-Thin-Metadaten verfolgt werden.</font></font><br>
<br>
<code>#chmod +x /root/lvm-thin-backup/cron-daily.sh<br>
#chmod +x /root/lvm-thin-backup/lvm-thin-backup.sh</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
#cat /var/log/syslog | grep lvm-thin-backup<br>
#crontab -e<br>
0 3 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lass uns nachsehen, was passiert ist:</font></font></h3><br>
<code>#time /root/btrfs-backup/cron-daily.sh<br>
real 0m2,967s<br>
user 0m0,225s<br>
sys 0m0,353s<br>
<br>
#time /root/lvm-thin-backup/cron-daily.sh<br>
real 1m2,710s<br>
user 0m12,721s<br>
sys 0m6,671s<br>
<br>
#ls -al /backup/btrfs/back/remote/*<br>
/backup/btrfs/back/remote/boot:<br>
total 0<br>
drwxr-xr-x 1 root root 1260  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 322  26 02:00 .@base<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-37<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-57<br>
...<br>
/backup/btrfs/back/remote/root:<br>
total 0<br>
drwxr-xr-x 1 root root 2820  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 240  26 09:11 @.@base<br>
drwxr-xr-x 1 root root 22  26 09:11 @home.@base<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-35<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-57<br>
...<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-26<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-56<br>
...<br>
<br>
#lvs -olv_name,lv_size images &amp;&amp; lvs -olv_name,lv_size backup<br>
 LV LSize <br>
 linux-dev 128,00g<br>
 linux-dev.base 128,00g<br>
 thin-pool 1,38t<br>
 win8 128,00g<br>
 win8-data 2,00t<br>
 win8-data.base 2,00t<br>
 win8.base 128,00g<br>
 LV LSize <br>
 backup 256,00g<br>
 images-linux-dev.base 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-11 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-25 128,00g<br>
...<br>
 images-win8-data.base 2,00t<br>
 images-win8-data.snap.2020-03-16-14-11-55 2,00t<br>
 images-win8-data.snap.2020-03-16-14-19-50 2,00t<br>
...<br>
 images-win8.base 128,00g<br>
 images-win8.snap.2020-03-17-04-51-46 128,00g<br>
 images-win8.snap.2020-03-18-03-02-49 128,00g<br>
...<br>
 thin-pool &lt;2,09t<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und was ist mit Nistpuppen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√∂chstwahrscheinlich k√∂nnen logische LVM-LV-Volumes physische LVM-PV-Volumes f√ºr andere VGs sein. </font><font style="vertical-align: inherit;">LVM kann rekursiv sein, wie Nestpuppen. </font><font style="vertical-align: inherit;">Dies gibt LVM extreme Flexibilit√§t.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im n√§chsten Artikel werden wir versuchen, mehrere √§hnliche mobile Speichersysteme / KVMs als Grundlage f√ºr die Erstellung eines geoverteilten Speicher- / VM-Clusters mit Redundanz auf mehreren Kontinenten √ºber Heimdesktops, Heiminternet und P2P-Netzwerke zu verwenden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492820/index.html">.Net Core Api: Abrufen von Daten in einer Anfrage aus verschiedenen Quellen</a></li>
<li><a href="../de492822/index.html">CSS-Entwickler - warum braucht die Welt sie?</a></li>
<li><a href="../de492828/index.html">Wie man in einer verschlossenen Welt √ºberlebt</a></li>
<li><a href="../de492830/index.html">SameSite = Lax standardm√§√üig - bereits in Chrome 80 stabil (allerdings noch nicht f√ºr alle)</a></li>
<li><a href="../de492832/index.html">IoT-Gateway f√ºr Industrieprotokolle basierend auf i.MX6 und Linux</a></li>
<li><a href="../de492838/index.html">Schlie√üen Sie den M5Stack an das Fernsehger√§t an</a></li>
<li><a href="../de492844/index.html">Visualisieren und Animieren von (geophysikalischen) Modellen. 3D-Animation und Visualisierung von 4D-Daten</a></li>
<li><a href="../de492850/index.html">Nicht jeder m√∂chte zur Fernarbeit wechseln</a></li>
<li><a href="../de492856/index.html">Covid19, Ihre Gesellschaft und Sie sind aus Sicht von Data Science. √úbersetzter Artikel von Jeremy Howard und Rachel Thomas (fast.ai)</a></li>
<li><a href="../de492862/index.html">Die 15 besten Tipps zur Optimierung der Oracle APEX-Leistung f√ºr Entwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>