<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏡 🤳🏾 👨🏻‍⚕️ Schneller und einfacher Algorithmus zum Rendern von Volumes 🦇 🗽 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe kürzlich einen kleinen ShaderToy geschrieben, der einfaches volumetrisches Rendern ausführt, und dann beschlossen, einen Beitrag zu veröffent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Schneller und einfacher Algorithmus zum Rendern von Volumes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe kürzlich einen kleinen ShaderToy geschrieben, der einfaches volumetrisches Rendern ausführt, und dann beschlossen, einen Beitrag zu veröffentlichen, in dem seine Arbeit erklärt wird. </font><font style="vertical-align: inherit;">Das interaktive ShaderToy selbst kann hier angesehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie von einem Telefon oder Laptop lesen, empfehle ich, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnellversion anzusehen. </font><font style="vertical-align: inherit;">Ich habe Codefragmente in den Beitrag aufgenommen, die Ihnen helfen, die Leistung von ShaderToy auf hohem Niveau zu verstehen, aber sie enthalten nicht alle Details. </font><font style="vertical-align: inherit;">Wenn Sie tiefer graben möchten, empfehle ich, den ShaderToy-Code zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein ShaderToy hatte drei Hauptaufgaben:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echtzeitausführung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfachheit</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Körperliche Korrektheit (... oder so ähnlich)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde mit dieser leeren Codeszene beginnen. </font><font style="vertical-align: inherit;">Ich werde nicht auf Details der Implementierung eingehen, da diese nicht sehr interessant ist, aber ich werde Ihnen kurz sagen, wo wir anfangen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raytracing von undurchsichtigen Objekten. </font><font style="vertical-align: inherit;">Alle Objekte sind Grundelemente mit einfachen Schnittpunkten mit Strahlen (1 Ebene und 3 Kugeln)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur Berechnung der Beleuchtung wird die Phong-Schattierung verwendet, und bei drei sphärischen Lichtquellen wird ein benutzerdefinierter Lichtschwächungskoeffizient verwendet. </font><font style="vertical-align: inherit;">Schattenstrahlen sind nicht erforderlich, da wir nur die Ebene beleuchten.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="ShaderToy-Screenshot"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden den Band als separate Passage rendern, die sich mit einer undurchsichtigen Szene mischt. </font><font style="vertical-align: inherit;">Dies ähnelt der Art und Weise, wie alle Echtzeit-Rendering-Engines undurchsichtige und durchscheinende Oberflächen einzeln verarbeiten.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1: Volumen simulieren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber bevor wir mit dem volumetrischen Rendern beginnen können, benötigen wir dasselbe Volume! Um die Lautstärke zu simulieren, habe ich mich für die Verwendung von SDF (Signed Distance Functions) entschieden. Warum genau die Funktionen von Distanzfeldern? Weil ich kein Künstler bin, aber sie ermöglichen es Ihnen, sehr organische Formen in nur wenigen Codezeilen zu erstellen. Ich werde nicht im Detail über die Funktionen von Entfernungen mit einem Zeichen sprechen, da Inigo Kiles sie bereits wunderbar erklärt hat. Wenn Sie neugierig sind, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es eine große Liste verschiedener Funktionen von Vorzeichenabständen und Modifikatoren. Und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein weiterer Artikel über diese Raymarching SDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit einer einfachen und fügen hier eine Kugel hinzu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt fügen wir eine weitere Kugel hinzu und verwenden eine glatte Konjugation, um die Abstandsfunktionen der Kugeln zusammenzuführen. </font><font style="vertical-align: inherit;">Diesen Code habe ich direkt von der Inigo-Seite übernommen, aber aus Gründen der Übersichtlichkeit werde ich ihn hier einfügen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Smooth Pairing ist ein äußerst leistungsfähiges Werkzeug, da Sie etwas ganz Interessantes erhalten können, indem Sie es einfach mit ein paar einfachen Formen kombinieren. </font><font style="vertical-align: inherit;">So sehen meine vielen glatt konjugierten Kugeln aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also etwas Tropfenförmiges, aber wir brauchen eher eine Wolke als einen Tropfen. Ein großartiges Merkmal von SDF ist, wie einfach es ist, die Oberfläche durch einfaches Hinzufügen von etwas Rauschen zum SDF zu verzerren. Fügen wir also eine fraktale Brownsche Bewegung (fBM) über das Rauschen hinzu und verwenden Sie die Position, um die Rauschfunktion zu indizieren. Inigo Kiles behandelte dieses Thema auch in einem großartigen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über fBM-Rauschen. So sieht das Bild mit überlagertem fBM-Rauschen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein! </font><font style="vertical-align: inherit;">Dank fBM-Rauschen sah das Objekt plötzlich viel interessanter aus! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir die Illusion erzeugen, dass das Volumen mit der Ebene der Erde interagiert. </font><font style="vertical-align: inherit;">Dazu habe ich einen Abstand der vorzeichenbehafteten Ebene etwas unterhalb der Grundebene hinzugefügt und die Kombination aus glatter Paarung mit einem sehr aggressiven Paarungswert (Parameter k) wiederverwendet. </font><font style="vertical-align: inherit;">Danach haben wir dieses Bild bekommen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schliff wird die Änderung des xz-Index des fBM-Rauschens im Laufe der Zeit sein, so dass die Lautstärke wie wirbelnder Nebel aussieht. </font><font style="vertical-align: inherit;">Unterwegs sieht es sehr gut aus!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großartig, wir haben so etwas wie eine Wolke! </font><font style="vertical-align: inherit;">Der SDF-Berechnungscode ist auch recht kompakt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies rendert nur ein undurchsichtiges Objekt. Wir brauchen einen schönen herrlichen Nebel! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie rendern wir es in Form eines Volumens und nicht als undurchsichtiges Objekt? Lassen Sie uns zuerst über die Physik sprechen, die wir simulieren. Das Volumen ist eine große Anzahl von Partikeln in einem bestimmten Raumbereich. Und wenn ich "riesig" sage, meine ich "RIESIG". So sehr, dass die Modellierung jedes dieser Partikel heute selbst für das Offline-Rendering eine unmögliche Aufgabe ist. Gute Beispiele dafür sind Feuer, Nebel und Wolken. Genau genommen ist alles Volumen, aber aus Gründen der Geschwindigkeit der Berechnungen ist es einfacher, die Augen davor zu schließen und so zu tun, als ob dies nicht der Fall wäre. Wir stellen die Akkumulation dieser Partikel als Dichtewerte dar, die normalerweise in einer Art 3D-Gitter (oder etwas Komplexerem, beispielsweise in OpenVDB) gespeichert sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Licht durch ein Volumen tritt, können zwei Phänomene auftreten, wenn Licht mit einem Partikel kollidiert. </font><font style="vertical-align: inherit;">Es kann entweder streuen und in die andere Richtung gehen, oder ein Teil des Lichts kann vom Partikel absorbiert werden und sich auflösen. </font><font style="vertical-align: inherit;">Um die Anforderungen an die Echtzeitausführung zu erfüllen, führen wir eine sogenannte Einzelstreuung durch. </font><font style="vertical-align: inherit;">Dies bedeutet Folgendes: Wir gehen davon aus, dass Licht nur einmal gestreut wird, wenn das Licht mit einem Partikel kollidiert und in Richtung Kamera fliegt. </font><font style="vertical-align: inherit;">Das heißt, wir werden nicht in der Lage sein, die Auswirkungen der Mehrfachstreuung zu simulieren, z. B. Nebel, bei dem Objekte in einiger Entfernung normalerweise vager aussehen. </font><font style="vertical-align: inherit;">Für unser System ist dies jedoch völlig ausreichend. </font><font style="vertical-align: inherit;">So sieht Einzelstreuung beim Raymarchen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Pseudocode dafür sieht ungefähr so ​​aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wir haben es mit Berechnungen mit der Komplexität O (n * m * k) zu tun. </font><font style="vertical-align: inherit;">Die GPU muss also hart arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen die Absorption</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir zunächst die Absorption von Licht im Volumen entlang des Strahls der Kamera (d. H. Lassen Sie uns noch kein Raymarchen in Richtung der Lichtquellen durchführen). </font><font style="vertical-align: inherit;">Dazu benötigen wir zwei Aktionen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie ein Raymarchen innerhalb des Volumens durch</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie die Absorption / Beleuchtung bei jedem Schritt</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu berechnen, wie viel Licht an jedem Punkt absorbiert wird, verwenden wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Bouguer-Lambert-Beer-Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das die Lichtschwächung beim Durchgang durch ein Material beschreibt. </font><font style="vertical-align: inherit;">Die Berechnungen sind überraschend einfach:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Absorptionskoeffizient ist ein Materialparameter. </font><font style="vertical-align: inherit;">Beispielsweise ist in einem transparenten Volumen, beispielsweise in Wasser, dieser Wert niedrig, und für etwas Dickeres, beispielsweise Milch, ist der Koeffizient höher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Volumen-Raymarchen durchzuführen, machen wir einfach Schritte fester Größe entlang des Strahls und erhalten bei jedem Schritt Absorption. </font><font style="vertical-align: inherit;">Sie verstehen vielleicht nicht, warum Sie feste Schritte anstelle von etwas Schnellerem ausführen sollen, z. B. das Verfolgen einer Kugel. Wenn Sie sich jedoch daran erinnern, dass die Dichte innerhalb des Volumens heterogen ist, wird alles klar. </font><font style="vertical-align: inherit;">Unten finden Sie den Raymarch- und Akkumulationsabsorptionscode. </font><font style="vertical-align: inherit;">Einige Variablen liegen außerhalb des Bereichs dieses Code-Snippets. Überprüfen Sie daher die vollständige Implementierung in ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist, was wir damit bekommen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sieht aus wie Zuckerwatte! </font><font style="vertical-align: inherit;">Vielleicht reicht dies für einige Effekte! </font><font style="vertical-align: inherit;">Aber es fehlt uns an Selbstbeschattung. </font><font style="vertical-align: inherit;">Licht erreicht alle Teile des Volumens gleichermaßen. </font><font style="vertical-align: inherit;">Dies ist jedoch physikalisch nicht korrekt. Abhängig von der Größe des Volumens zwischen dem gerenderten Punkt und der Lichtquelle erhalten wir eine unterschiedliche Menge an einfallendem Licht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbstbeschattung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schwierigste haben wir schon gemacht. </font><font style="vertical-align: inherit;">Wir müssen das Gleiche tun wie bei der Berechnung der Absorption entlang des Kamerastrahls, jedoch nur entlang des Lichtstrahls. </font><font style="vertical-align: inherit;">Der Code zum Berechnen der Lichtmenge, die jeden Punkt erreicht, ist im Wesentlichen eine Wiederholung des Codes, aber das Duplizieren ist einfacher als das Hacken von HLSL, um die benötigte Rekursion zu erhalten. </font><font style="vertical-align: inherit;">So wird es also aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Hinzufügen von Selbstbeschattung erhalten wir Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="ShaderToy-Screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweichen Sie die Kanten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment gefällt mir unser Volumen schon ganz gut. </font><font style="vertical-align: inherit;">Ich zeigte ihn dem talentierten Leiter der VFX-Abteilung der Koalition, James Sharp. </font><font style="vertical-align: inherit;">Er bemerkte sofort, dass die Ränder des Volumens zu scharf aussahen. </font><font style="vertical-align: inherit;">Und das ist absolut richtig - Objekte wie Wolken sind ständig im Raum um sie herum verstreut, sodass sich ihre Kanten mit dem leeren Raum um das Volumen vermischen, was zur Bildung sehr glatter Kanten führen sollte. </font><font style="vertical-align: inherit;">James bot mir eine großartige Idee an - die Dichte zu reduzieren, je nachdem, wie nah wir am Rand sind. </font><font style="vertical-align: inherit;">Und da wir mit Distanzfunktionen mit Vorzeichen arbeiten, ist die Implementierung sehr einfach! </font><font style="vertical-align: inherit;">Fügen wir also eine Funktion hinzu, mit der die Dichte an jedem Punkt des Volumes angefordert werden kann:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann kollabieren wir es einfach in den Absorptionswert:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so sieht es aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="ShaderToy-Screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dichtefunktion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da wir die Dichtefunktion haben, können Sie der Lautstärke leicht ein wenig Rauschen hinzufügen, um ihr zusätzliche Details und Pracht zu verleihen. </font><font style="vertical-align: inherit;">In diesem Fall verwende ich nur die fBM-Funktion, mit der wir die Volumenform angepasst haben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so haben wir folgendes bekommen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="ShaderToy-Screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Undurchsichtige Selbstbeschattung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lautstärke sieht schon ziemlich hübsch aus! </font><font style="vertical-align: inherit;">Aber ein wenig Licht tritt immer noch durch. </font><font style="vertical-align: inherit;">Hier sehen wir, wie die grüne Farbe dort versickert, wo das Volumen sie definitiv absorbieren sollte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt daran, dass undurchsichtige Objekte gerendert werden, bevor das Volume gerendert wird, sodass sie die durch das Volume verursachte Schattierung nicht berücksichtigen. </font><font style="vertical-align: inherit;">Dies ist recht einfach zu beheben. Wir haben eine GetLightVisiblity-Funktion, mit der die Schattierung berechnet werden kann. Sie müssen sie also nur aufrufen, um ein undurchsichtiges Objekt zu beleuchten. </font><font style="vertical-align: inherit;">Wir bekommen folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies erzeugt nicht nur schöne mehrfarbige Schatten, sondern verbessert auch die Schatten und sorgt für mehr Volumen in der Szene. </font><font style="vertical-align: inherit;">Darüber hinaus erhalten wir dank der glatten Kanten des Volumens weiche Schatten, obwohl wir streng genommen mit punktuellen Beleuchtungsquellen arbeiten. </font><font style="vertical-align: inherit;">Das ist alles! </font><font style="vertical-align: inherit;">Hier kann noch viel mehr getan werden, aber es scheint mir, dass ich die visuelle Qualität erreicht habe, die ich brauche, während die relative Einfachheit des Beispiels erhalten bleibt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierungen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende werde ich einige mögliche Optimierungen kurz auflisten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem Raymarchen in Richtung der Lichtquelle muss anhand des Wertes der Lichtauslöschung überprüft werden, ob eine signifikante Menge dieses Lichts tatsächlich den fraglichen Punkt erreicht. </font><font style="vertical-align: inherit;">In meiner Implementierung betrachte ich die Helligkeit des Lichts multipliziert mit der Albedo des Materials und stelle sicher, dass der Wert groß genug ist, damit Raymarching durchgeführt werden kann.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles! </font><font style="vertical-align: inherit;">Persönlich war ich überrascht, dass Sie mit so wenig Code (ca. 500 Zeilen) etwas ganz physikalisch Korrektes erstellen können. </font><font style="vertical-align: inherit;">Danke fürs Lesen, ich hoffe es war interessant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und noch eine Anmerkung: Hier ist eine lustige Änderung: Ich habe die Lichtemission basierend auf der SDF-Entfernung hinzugefügt, um einen Explosionseffekt zu erzielen. </font><font style="vertical-align: inherit;">Explosionen gibt es schließlich nie.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="ShaderToy-Screenshot"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500896/index.html">Was gibt es in Quarantäne zu sehen? Eine Auswahl von Materialien aus Technostream (Teil 3)</a></li>
<li><a href="../de500898/index.html">Verrückter SpaceX-Mondplan? Programmevaluierung durch U / S_Hirangy (reddit)</a></li>
<li><a href="../de500902/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 343 (27. April - 3. Mai)</a></li>
<li><a href="../de500904/index.html">Wer ist wer im Zahlungsverkehr 2020. Teil 1</a></li>
<li><a href="../de500910/index.html">China Langstrecken-Weltraumkommunikationssystem</a></li>
<li><a href="../de500918/index.html">Worauf wir bei der Berechnung der statistischen Signifikanz des A / B-Tests achten</a></li>
<li><a href="../de500920/index.html">Antiquitäten: ZX Spectrum und der alte Iglowur</a></li>
<li><a href="../de500922/index.html">Ein Wolf im Schafspelz: Wie man einen Hacker fängt, der sich sorgfältig als gewöhnlicher Benutzer verkleidet</a></li>
<li><a href="../de500924/index.html">Online-Treffen JUG.ru "Spring-Builder" mit Evgeny Borisov</a></li>
<li><a href="../de500926/index.html">Dynamisches Tippen ist kein Entwicklungswerkzeug. Das ist Unsinn (mies)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>