<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè° ü§≥üèæ üë®üèª‚Äç‚öïÔ∏è Schneller und einfacher Algorithmus zum Rendern von Volumes ü¶á üóΩ ‚ûø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe k√ºrzlich einen kleinen ShaderToy geschrieben, der einfaches volumetrisches Rendern ausf√ºhrt, und dann beschlossen, einen Beitrag zu ver√∂ffent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Schneller und einfacher Algorithmus zum Rendern von Volumes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe k√ºrzlich einen kleinen ShaderToy geschrieben, der einfaches volumetrisches Rendern ausf√ºhrt, und dann beschlossen, einen Beitrag zu ver√∂ffentlichen, in dem seine Arbeit erkl√§rt wird. </font><font style="vertical-align: inherit;">Das interaktive ShaderToy selbst kann hier angesehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie von einem Telefon oder Laptop lesen, empfehle ich, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnellversion anzusehen. </font><font style="vertical-align: inherit;">Ich habe Codefragmente in den Beitrag aufgenommen, die Ihnen helfen, die Leistung von ShaderToy auf hohem Niveau zu verstehen, aber sie enthalten nicht alle Details. </font><font style="vertical-align: inherit;">Wenn Sie tiefer graben m√∂chten, empfehle ich, den ShaderToy-Code zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein ShaderToy hatte drei Hauptaufgaben:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echtzeitausf√ºhrung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfachheit</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂rperliche Korrektheit (... oder so √§hnlich)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde mit dieser leeren Codeszene beginnen. </font><font style="vertical-align: inherit;">Ich werde nicht auf Details der Implementierung eingehen, da diese nicht sehr interessant ist, aber ich werde Ihnen kurz sagen, wo wir anfangen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raytracing von undurchsichtigen Objekten. </font><font style="vertical-align: inherit;">Alle Objekte sind Grundelemente mit einfachen Schnittpunkten mit Strahlen (1 Ebene und 3 Kugeln)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur Berechnung der Beleuchtung wird die Phong-Schattierung verwendet, und bei drei sph√§rischen Lichtquellen wird ein benutzerdefinierter Lichtschw√§chungskoeffizient verwendet. </font><font style="vertical-align: inherit;">Schattenstrahlen sind nicht erforderlich, da wir nur die Ebene beleuchten.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="ShaderToy-Screenshot"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden den Band als separate Passage rendern, die sich mit einer undurchsichtigen Szene mischt. </font><font style="vertical-align: inherit;">Dies √§hnelt der Art und Weise, wie alle Echtzeit-Rendering-Engines undurchsichtige und durchscheinende Oberfl√§chen einzeln verarbeiten.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1: Volumen simulieren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber bevor wir mit dem volumetrischen Rendern beginnen k√∂nnen, ben√∂tigen wir dasselbe Volume! Um die Lautst√§rke zu simulieren, habe ich mich f√ºr die Verwendung von SDF (Signed Distance Functions) entschieden. Warum genau die Funktionen von Distanzfeldern? Weil ich kein K√ºnstler bin, aber sie erm√∂glichen es Ihnen, sehr organische Formen in nur wenigen Codezeilen zu erstellen. Ich werde nicht im Detail √ºber die Funktionen von Entfernungen mit einem Zeichen sprechen, da Inigo Kiles sie bereits wunderbar erkl√§rt hat. Wenn Sie neugierig sind, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es eine gro√üe Liste verschiedener Funktionen von Vorzeichenabst√§nden und Modifikatoren. Und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein weiterer Artikel √ºber diese Raymarching SDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit einer einfachen und f√ºgen hier eine Kugel hinzu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt f√ºgen wir eine weitere Kugel hinzu und verwenden eine glatte Konjugation, um die Abstandsfunktionen der Kugeln zusammenzuf√ºhren. </font><font style="vertical-align: inherit;">Diesen Code habe ich direkt von der Inigo-Seite √ºbernommen, aber aus Gr√ºnden der √úbersichtlichkeit werde ich ihn hier einf√ºgen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Smooth Pairing ist ein √§u√üerst leistungsf√§higes Werkzeug, da Sie etwas ganz Interessantes erhalten k√∂nnen, indem Sie es einfach mit ein paar einfachen Formen kombinieren. </font><font style="vertical-align: inherit;">So sehen meine vielen glatt konjugierten Kugeln aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also etwas Tropfenf√∂rmiges, aber wir brauchen eher eine Wolke als einen Tropfen. Ein gro√üartiges Merkmal von SDF ist, wie einfach es ist, die Oberfl√§che durch einfaches Hinzuf√ºgen von etwas Rauschen zum SDF zu verzerren. F√ºgen wir also eine fraktale Brownsche Bewegung (fBM) √ºber das Rauschen hinzu und verwenden Sie die Position, um die Rauschfunktion zu indizieren. Inigo Kiles behandelte dieses Thema auch in einem gro√üartigen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber fBM-Rauschen. So sieht das Bild mit √ºberlagertem fBM-Rauschen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein! </font><font style="vertical-align: inherit;">Dank fBM-Rauschen sah das Objekt pl√∂tzlich viel interessanter aus! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen wir die Illusion erzeugen, dass das Volumen mit der Ebene der Erde interagiert. </font><font style="vertical-align: inherit;">Dazu habe ich einen Abstand der vorzeichenbehafteten Ebene etwas unterhalb der Grundebene hinzugef√ºgt und die Kombination aus glatter Paarung mit einem sehr aggressiven Paarungswert (Parameter k) wiederverwendet. </font><font style="vertical-align: inherit;">Danach haben wir dieses Bild bekommen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schliff wird die √Ñnderung des xz-Index des fBM-Rauschens im Laufe der Zeit sein, so dass die Lautst√§rke wie wirbelnder Nebel aussieht. </font><font style="vertical-align: inherit;">Unterwegs sieht es sehr gut aus!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üartig, wir haben so etwas wie eine Wolke! </font><font style="vertical-align: inherit;">Der SDF-Berechnungscode ist auch recht kompakt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies rendert nur ein undurchsichtiges Objekt. Wir brauchen einen sch√∂nen herrlichen Nebel! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie rendern wir es in Form eines Volumens und nicht als undurchsichtiges Objekt? Lassen Sie uns zuerst √ºber die Physik sprechen, die wir simulieren. Das Volumen ist eine gro√üe Anzahl von Partikeln in einem bestimmten Raumbereich. Und wenn ich "riesig" sage, meine ich "RIESIG". So sehr, dass die Modellierung jedes dieser Partikel heute selbst f√ºr das Offline-Rendering eine unm√∂gliche Aufgabe ist. Gute Beispiele daf√ºr sind Feuer, Nebel und Wolken. Genau genommen ist alles Volumen, aber aus Gr√ºnden der Geschwindigkeit der Berechnungen ist es einfacher, die Augen davor zu schlie√üen und so zu tun, als ob dies nicht der Fall w√§re. Wir stellen die Akkumulation dieser Partikel als Dichtewerte dar, die normalerweise in einer Art 3D-Gitter (oder etwas Komplexerem, beispielsweise in OpenVDB) gespeichert sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Licht durch ein Volumen tritt, k√∂nnen zwei Ph√§nomene auftreten, wenn Licht mit einem Partikel kollidiert. </font><font style="vertical-align: inherit;">Es kann entweder streuen und in die andere Richtung gehen, oder ein Teil des Lichts kann vom Partikel absorbiert werden und sich aufl√∂sen. </font><font style="vertical-align: inherit;">Um die Anforderungen an die Echtzeitausf√ºhrung zu erf√ºllen, f√ºhren wir eine sogenannte Einzelstreuung durch. </font><font style="vertical-align: inherit;">Dies bedeutet Folgendes: Wir gehen davon aus, dass Licht nur einmal gestreut wird, wenn das Licht mit einem Partikel kollidiert und in Richtung Kamera fliegt. </font><font style="vertical-align: inherit;">Das hei√üt, wir werden nicht in der Lage sein, die Auswirkungen der Mehrfachstreuung zu simulieren, z. B. Nebel, bei dem Objekte in einiger Entfernung normalerweise vager aussehen. </font><font style="vertical-align: inherit;">F√ºr unser System ist dies jedoch v√∂llig ausreichend. </font><font style="vertical-align: inherit;">So sieht Einzelstreuung beim Raymarchen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Pseudocode daf√ºr sieht ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, wir haben es mit Berechnungen mit der Komplexit√§t O (n * m * k) zu tun. </font><font style="vertical-align: inherit;">Die GPU muss also hart arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen die Absorption</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir zun√§chst die Absorption von Licht im Volumen entlang des Strahls der Kamera (d. H. Lassen Sie uns noch kein Raymarchen in Richtung der Lichtquellen durchf√ºhren). </font><font style="vertical-align: inherit;">Dazu ben√∂tigen wir zwei Aktionen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhren Sie ein Raymarchen innerhalb des Volumens durch</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie die Absorption / Beleuchtung bei jedem Schritt</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu berechnen, wie viel Licht an jedem Punkt absorbiert wird, verwenden wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Bouguer-Lambert-Beer-Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das die Lichtschw√§chung beim Durchgang durch ein Material beschreibt. </font><font style="vertical-align: inherit;">Die Berechnungen sind √ºberraschend einfach:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Absorptionskoeffizient ist ein Materialparameter. </font><font style="vertical-align: inherit;">Beispielsweise ist in einem transparenten Volumen, beispielsweise in Wasser, dieser Wert niedrig, und f√ºr etwas Dickeres, beispielsweise Milch, ist der Koeffizient h√∂her. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Volumen-Raymarchen durchzuf√ºhren, machen wir einfach Schritte fester Gr√∂√üe entlang des Strahls und erhalten bei jedem Schritt Absorption. </font><font style="vertical-align: inherit;">Sie verstehen vielleicht nicht, warum Sie feste Schritte anstelle von etwas Schnellerem ausf√ºhren sollen, z. B. das Verfolgen einer Kugel. Wenn Sie sich jedoch daran erinnern, dass die Dichte innerhalb des Volumens heterogen ist, wird alles klar. </font><font style="vertical-align: inherit;">Unten finden Sie den Raymarch- und Akkumulationsabsorptionscode. </font><font style="vertical-align: inherit;">Einige Variablen liegen au√üerhalb des Bereichs dieses Code-Snippets. √úberpr√ºfen Sie daher die vollst√§ndige Implementierung in ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist, was wir damit bekommen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sieht aus wie Zuckerwatte! </font><font style="vertical-align: inherit;">Vielleicht reicht dies f√ºr einige Effekte! </font><font style="vertical-align: inherit;">Aber es fehlt uns an Selbstbeschattung. </font><font style="vertical-align: inherit;">Licht erreicht alle Teile des Volumens gleicherma√üen. </font><font style="vertical-align: inherit;">Dies ist jedoch physikalisch nicht korrekt. Abh√§ngig von der Gr√∂√üe des Volumens zwischen dem gerenderten Punkt und der Lichtquelle erhalten wir eine unterschiedliche Menge an einfallendem Licht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbstbeschattung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schwierigste haben wir schon gemacht. </font><font style="vertical-align: inherit;">Wir m√ºssen das Gleiche tun wie bei der Berechnung der Absorption entlang des Kamerastrahls, jedoch nur entlang des Lichtstrahls. </font><font style="vertical-align: inherit;">Der Code zum Berechnen der Lichtmenge, die jeden Punkt erreicht, ist im Wesentlichen eine Wiederholung des Codes, aber das Duplizieren ist einfacher als das Hacken von HLSL, um die ben√∂tigte Rekursion zu erhalten. </font><font style="vertical-align: inherit;">So wird es also aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Hinzuf√ºgen von Selbstbeschattung erhalten wir Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="ShaderToy-Screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweichen Sie die Kanten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment gef√§llt mir unser Volumen schon ganz gut. </font><font style="vertical-align: inherit;">Ich zeigte ihn dem talentierten Leiter der VFX-Abteilung der Koalition, James Sharp. </font><font style="vertical-align: inherit;">Er bemerkte sofort, dass die R√§nder des Volumens zu scharf aussahen. </font><font style="vertical-align: inherit;">Und das ist absolut richtig - Objekte wie Wolken sind st√§ndig im Raum um sie herum verstreut, sodass sich ihre Kanten mit dem leeren Raum um das Volumen vermischen, was zur Bildung sehr glatter Kanten f√ºhren sollte. </font><font style="vertical-align: inherit;">James bot mir eine gro√üartige Idee an - die Dichte zu reduzieren, je nachdem, wie nah wir am Rand sind. </font><font style="vertical-align: inherit;">Und da wir mit Distanzfunktionen mit Vorzeichen arbeiten, ist die Implementierung sehr einfach! </font><font style="vertical-align: inherit;">F√ºgen wir also eine Funktion hinzu, mit der die Dichte an jedem Punkt des Volumes angefordert werden kann:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann kollabieren wir es einfach in den Absorptionswert:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so sieht es aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="ShaderToy-Screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dichtefunktion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da wir die Dichtefunktion haben, k√∂nnen Sie der Lautst√§rke leicht ein wenig Rauschen hinzuf√ºgen, um ihr zus√§tzliche Details und Pracht zu verleihen. </font><font style="vertical-align: inherit;">In diesem Fall verwende ich nur die fBM-Funktion, mit der wir die Volumenform angepasst haben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so haben wir folgendes bekommen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="ShaderToy-Screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Undurchsichtige Selbstbeschattung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lautst√§rke sieht schon ziemlich h√ºbsch aus! </font><font style="vertical-align: inherit;">Aber ein wenig Licht tritt immer noch durch. </font><font style="vertical-align: inherit;">Hier sehen wir, wie die gr√ºne Farbe dort versickert, wo das Volumen sie definitiv absorbieren sollte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt daran, dass undurchsichtige Objekte gerendert werden, bevor das Volume gerendert wird, sodass sie die durch das Volume verursachte Schattierung nicht ber√ºcksichtigen. </font><font style="vertical-align: inherit;">Dies ist recht einfach zu beheben. Wir haben eine GetLightVisiblity-Funktion, mit der die Schattierung berechnet werden kann. Sie m√ºssen sie also nur aufrufen, um ein undurchsichtiges Objekt zu beleuchten. </font><font style="vertical-align: inherit;">Wir bekommen folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="ShaderToy-Screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies erzeugt nicht nur sch√∂ne mehrfarbige Schatten, sondern verbessert auch die Schatten und sorgt f√ºr mehr Volumen in der Szene. </font><font style="vertical-align: inherit;">Dar√ºber hinaus erhalten wir dank der glatten Kanten des Volumens weiche Schatten, obwohl wir streng genommen mit punktuellen Beleuchtungsquellen arbeiten. </font><font style="vertical-align: inherit;">Das ist alles! </font><font style="vertical-align: inherit;">Hier kann noch viel mehr getan werden, aber es scheint mir, dass ich die visuelle Qualit√§t erreicht habe, die ich brauche, w√§hrend die relative Einfachheit des Beispiels erhalten bleibt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierungen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende werde ich einige m√∂gliche Optimierungen kurz auflisten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem Raymarchen in Richtung der Lichtquelle muss anhand des Wertes der Lichtausl√∂schung √ºberpr√ºft werden, ob eine signifikante Menge dieses Lichts tats√§chlich den fraglichen Punkt erreicht. </font><font style="vertical-align: inherit;">In meiner Implementierung betrachte ich die Helligkeit des Lichts multipliziert mit der Albedo des Materials und stelle sicher, dass der Wert gro√ü genug ist, damit Raymarching durchgef√ºhrt werden kann.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles! </font><font style="vertical-align: inherit;">Pers√∂nlich war ich √ºberrascht, dass Sie mit so wenig Code (ca. 500 Zeilen) etwas ganz physikalisch Korrektes erstellen k√∂nnen. </font><font style="vertical-align: inherit;">Danke f√ºrs Lesen, ich hoffe es war interessant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und noch eine Anmerkung: Hier ist eine lustige √Ñnderung: Ich habe die Lichtemission basierend auf der SDF-Entfernung hinzugef√ºgt, um einen Explosionseffekt zu erzielen. </font><font style="vertical-align: inherit;">Explosionen gibt es schlie√ülich nie.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="ShaderToy-Screenshot"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500896/index.html">Was gibt es in Quarant√§ne zu sehen? Eine Auswahl von Materialien aus Technostream (Teil 3)</a></li>
<li><a href="../de500898/index.html">Verr√ºckter SpaceX-Mondplan? Programmevaluierung durch U / S_Hirangy (reddit)</a></li>
<li><a href="../de500902/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 343 (27. April - 3. Mai)</a></li>
<li><a href="../de500904/index.html">Wer ist wer im Zahlungsverkehr 2020. Teil 1</a></li>
<li><a href="../de500910/index.html">China Langstrecken-Weltraumkommunikationssystem</a></li>
<li><a href="../de500918/index.html">Worauf wir bei der Berechnung der statistischen Signifikanz des A / B-Tests achten</a></li>
<li><a href="../de500920/index.html">Antiquit√§ten: ZX Spectrum und der alte Iglowur</a></li>
<li><a href="../de500922/index.html">Ein Wolf im Schafspelz: Wie man einen Hacker f√§ngt, der sich sorgf√§ltig als gew√∂hnlicher Benutzer verkleidet</a></li>
<li><a href="../de500924/index.html">Online-Treffen JUG.ru "Spring-Builder" mit Evgeny Borisov</a></li>
<li><a href="../de500926/index.html">Dynamisches Tippen ist kein Entwicklungswerkzeug. Das ist Unsinn (mies)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>