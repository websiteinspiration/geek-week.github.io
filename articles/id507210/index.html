<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷 🎈 ❕ Kinerja Java modern saat bekerja dengan sejumlah besar data, bagian 2 🤑 👨🏽‍⚕️ #⃣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FYI: Bagian pertama .
 
 Konveyor Batch Benchmark
 Pipa batch memproses jumlah akhir dari data yang disimpan. Tidak ada aliran hasil pemrosesan, outpu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kinerja Java modern saat bekerja dengan sejumlah besar data, bagian 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/507210/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d1/gm/bn/d1gmbnhwk4pkhy1bck7ykdmu-uq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FYI: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian pertama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konveyor Batch Benchmark</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pipa batch memproses jumlah akhir dari data yang disimpan. Tidak ada aliran hasil pemrosesan, output dari fungsi agregasi perlu diterapkan ke seluruh kumpulan data. Ini mengubah persyaratan kinerja: latensi - faktor kunci dalam pemrosesan streaming - tidak ada di sini karena kami memproses data secara real time. Satu-satunya metrik penting adalah waktu total berjalannya konveyor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, kami memilih Paralel. </font><font style="vertical-align: inherit;">Pada tahap pertama pengujian, ketika bekerja pada satu node, kolektor ini benar-benar menunjukkan throughput terbaik (tetapi hanya setelah penyetelan). </font><font style="vertical-align: inherit;">Namun, ini diperoleh dengan biaya jeda panjang. </font><font style="vertical-align: inherit;">Jika salah satu node cluster berhenti di pengumpulan sampah, ini akan menghentikan seluruh pipa. </font><font style="vertical-align: inherit;">Dan karena node mengumpulkan sampah pada waktu yang berbeda, total waktu build meningkat dengan penambahan setiap node ke cluster. </font><font style="vertical-align: inherit;">Kami menganalisis efek ini dengan membandingkan hasil tes pada satu node dan pada cluster tiga node. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, pada tahap ini, kami tidak mempertimbangkan kolektor latensi rendah eksperimental. </font><font style="vertical-align: inherit;">Jeda yang sangat singkat tidak mempengaruhi hasil tes, apalagi, ini dicapai karena bandwidth.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian pada satu node: conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk benchmark kumpulan pada satu node, kami menggunakan pipa sederhana. Kode lengkap di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource)<font></font>
 .rebalance() <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; (e.getKey() &amp; <span class="hljs-number">0xFF_FFFFL</span>) == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sumber adalah sebuah rintisan yang menghasilkan urutan nomor tipe </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fungsi kunci didefinisikan sehingga </font></font><code>groupingKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siklus melalui ruang kunci: 0, 1, 2, ... </font></font><code>NUM_KEYS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, 0, 1, 2, ... Ini berarti bahwa selama siklus pertama pipa melihat semua kunci dan membuat struktur data tetap untuk menyimpan hasil. pengumpulan. Dan selama siklus berikutnya, sistem hanya memperbarui data yang tersedia. Ini sepenuhnya konsisten dengan hipotesis pengumpulan sampah dengan memperhitungkan generasi yang berbeda: benda bisa melalui semua perhitungan, atau tidak ada lama dan menjadi sampah tak lama setelah pembuatannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sumber kami menghasilkan 400 juta elemen, dan kami menciptakan 100 juta kunci individual, yaitu empat kali melewati semua kunci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator</font></font><code>.rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggantikan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregasi dua tahap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> default Jet </font><font style="vertical-align: inherit;">dengan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">agregasi</font></a><font style="vertical-align: inherit;"> satu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">tahap</font></a><font style="vertical-align: inherit;"> . Ini membuat perilaku mesin di tolok ukur kami lebih mudah diprediksi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga menguji opsi di mana operasi agregasi menggunakan instance dari tipe objek sebagai status </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menghasilkan sampah setiap kali akun berjalan diperbarui. Dalam hal ini, banyak objek mati setelah waktu yang layak di generasi lama. Dalam situasi ini, kami harus mengurangi jumlah kunci menjadi 70 juta, karena pada 100 juta beban pada pengumpul terlalu tinggi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami tidak fokus pada pengumpul latensi rendah karena mereka tidak memiliki apa pun untuk ditawarkan dalam kasus pemipaan batch. </font><font style="vertical-align: inherit;">Karena kita telah melihat bahwa JDK 14 bekerja hampir seperti JDK 11, kami menjalankan satu tes untuk mengonfirmasi ini. </font><font style="vertical-align: inherit;">Dan kemudian kami fokus pada JDK 8 dan JDK 11. Dan kami juga membandingkan kolektor Paralel default yang digunakan dalam JDK 8 dengan G1.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian pada satu simpul: hasil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menjalankan benchmark pada laptop dengan RAM 16 GB dan Intel Core i7 6-core. Ukuran heap adalah 10 GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya, karena Parallel, kinerjanya sangat buruk, dan kami harus menyetel pengumpulan sampah. Oleh karena itu, kami sangat merekomendasikan menggunakan VisualVM dan plugin Visual GC. Jika Anda menetapkan frame rate maksimum (10 fps), Anda dapat menikmati visualisasi yang sangat rinci tentang hubungan antara alokasi memori aplikasi Anda dan pekerjaan pengumpul sampah. Setelah menonton animasi, kami menyadari bahwa masalah utama adalah potongan memori terlalu besar yang dialokasikan untuk generasi baru. Secara default, rasio generasi lama dengan yang baru hanya 2: 1, dan selama eksekusi tidak berubah secara dinamis. Karena itu, kami memutuskan untuk menerapkan pengaturan</font></font><code>-XX:NewRatio=8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan itu mengubah keseluruhan gambar. Sekarang Paralel bekerja paling baik. Kami juga menerapkan </font></font><code>-XX:MaxTenuringThreshold=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang selamat untuk mengurangi penyalinan data antar ruang karena benda sementara cepat mati dalam pipa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tentang hasilnya. Satu-satunya metrik yang cocok untuk pipa batch adalah durasi tugas. Untuk memvisualisasikan hasil, kami mengambil nilai timbal baliknya, oleh karena itu, grafik menunjukkan throughput dalam elemen per detik. Untuk satu simpul:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/87a/5c6/a4f87a5c66be2c77e0337151adb9d2ca.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/377/c40/5ab/377c405ab09606862cb1464b07624d56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregasi tanpa pengumpulan sampah bekerja sekitar 30-35% lebih cepat, meskipun set kunci lebih besar. Bundel G1 dan JDK 8 bekerja paling buruk, dan Paralel dan JDK 11. mencari yang terbaik. Bundel G1 dan JDK 11 tidak kalah banyak. Harap dicatat bahwa kami tidak menyentuh konfigurasi G1, ini adalah poin penting. Konfigurasi pengumpulan sampah sangat tergantung pada situasi. Hasilnya dapat berubah secara dramatis, misalnya, dengan peningkatan jumlah data. Dan Anda perlu mengkonfigurasi untuk seluruh cluster, untuk jenis beban tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini kinerja kolektor Paralel default dibandingkan dengan versi khusus yang kami gunakan saat menguji:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/797/c4a/81b797c4acae8f632c51147b699c3cad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan tumpukan 10 GB, hasilnya sangat buruk. </font><font style="vertical-align: inherit;">Sistem macet dalam jeda penuh untuk perakitan, yang masing-masing membutuhkan waktu sekitar 7 detik. </font><font style="vertical-align: inherit;">Ketika tumpukan meningkat, situasinya membaik, tetapi siklus perakitan lengkap terjadi sangat sering. </font><font style="vertical-align: inherit;">Harap dicatat bahwa hasil ini diperoleh untuk kasus yang paling umum - agregasi tanpa perakitan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian pada tiga node: conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menguji cluster dengan benar, kami harus menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang lebih kompleks </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource())<font></font>
 .rebalance()<font></font>
 .flatMap(n -&gt; {<font></font>
     Long[] items = <span class="hljs-keyword">new</span> Long[SOURCE_STEP];<font></font>
     Arrays.setAll(items, i -&gt; n + i);<font></font>
     <span class="hljs-keyword">return</span> traverseArray(items);<font></font>
 })<font></font>
 .rebalance()<font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(AggregateOperations.summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; e.getKey() % <span class="hljs-number">1_000_000</span> == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena sumbernya tidak bekerja secara paralel, kami membuat beberapa optimasi sehingga tidak menjadi hambatan dalam sistem. </font><font style="vertical-align: inherit;">Sumber menghasilkan angka 0, 10, 20, ..., dan kami memparalelkan tahap </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana angka-angka yang hilang diinterpolasi. </font><font style="vertical-align: inherit;">Juga antara sumber dan </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami menggunakan </font></font><code>rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mendistribusikan data di seluruh cluster. </font><font style="vertical-align: inherit;">Dan sebelum dimulainya tahap utama (agregasi kunci), kami kembali menyeimbangkan kembali. </font><font style="vertical-align: inherit;">Setelah agregasi, pertama-tama kita hanya menyisakan setiap pasangan nilai kunci sepersejuta, dan kemudian meneruskannya ke logger. </font><font style="vertical-align: inherit;">Satu miliar elemen data dan satu set 500 juta kunci digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti dalam kasus dengan satu simpul, kami menguji konveyor dengan agregasi tanpa sampah dan dengannya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian pada tiga node: hasil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menjalankan tolok ukur ini pada kluster AWS dari tiga instance c5d.4xlarge. Mereka memiliki 16 inti prosesor tervirtualisasi dan 32 GB memori. Bandwidth saluran 10 Gb / s. Hasil:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/cc6/a6d/579cc6a6d172a6098f96b3c2b9cfbda8.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/32f/ca6/b2832fca67b0123a6ca976e518ecd87c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara sepintas, kami mencatat peningkatan keseluruhan sekitar tiga kali lipat dalam throughput dibandingkan dengan satu node. Ini adalah konsekuensi dari pemrosesan yang didistribusikan. Sedangkan untuk assembler, kombinasi G1 dan JDK 11 menjadi pemenang dari kedua tes tersebut.Hasil mencolok lainnya adalah kombinasi yang hampir tidak dapat dioperasi dari G1 dan JDK 8. Namun, ini memiliki alasan yang lebih dalam yang mempengaruhi dimensi lain. Sebagai contoh, keuntungan yang jelas dari Paralel pada JDK 8 dan JDK 11. Ini disebabkan oleh efek yang kami catat di awal: segera setelah node berhenti untuk pengumpulan sampah, pemrosesan pada seluruh cluster berhenti. Dan G1 pada JDK 8 naik untuk jeda yang sangat lama, lebih dari satu menit. Ini cukup untuk detektor kegagalan dalam gugus untuk bekerja dan memutuskan bahwa simpul telah mati. Tugas gagal, gugus mereorganisasi sendiri, dan tugas dimulai lagi pada dua node.Ini mengarah pada kegagalan baru lebih cepat, karena setiap node sekarang memproses lebih banyak data. Pada saat yang sama, node yang dikeluarkan bergabung lagi, dan tugas dimulai lagi pada dua node, tetapi yang lain. Ada loop tanpa akhir untuk memulai kembali tugas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeda paralel tidak terlalu lama untuk memecah cluster, tetapi itu bekerja jauh lebih buruk pada tes pada node yang sama. Pada tiga node, ia kehilangan 30% dari G1 dan JDK 11. Dan pada kelompok yang lebih besar situasinya akan menjadi lebih buruk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda melihat semua tes, itu mengejutkan bahwa Paralel berjalan lebih cepat pada JDK 8 daripada pada JDK 11. Namun, ini karena kebetulan yang sangat baik: dalam uji ini, jeda penuh dimulai secara sinkron pada semua node, yang memaralelkan pekerjaan kolektor. Jelas, efek ini tidak dapat diandalkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun fakta bahwa dalam konfigurasi pengujian kami menggunakan Paralel, kami tidak mengamati efek bencana dari jeda lama pada stabilitas cluster, ini adalah skenario yang sangat mungkin. </font><font style="vertical-align: inherit;">Dalam pengujian lain, ketika kami meningkatkan tumpukan dan jumlah data, atau meninggalkan tumpukan yang sama, tetapi mengurangi margin operasi, Paralel bertindak sama destruktifnya. </font><font style="vertical-align: inherit;">Tetapi bahkan ketika itu tidak menyebabkan kegagalan, pada grafik keuntungannya menghilang ketika bekerja pada simpul yang sama. </font><font style="vertical-align: inherit;">Dapat diharapkan bahwa situasi akan memburuk dengan penambahan node baru ke cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sisi lain, sekelompok G1 dan JDK 11 bekerja dengan jeda yang agak pendek, sehingga conveyor tidak berhenti. </font><font style="vertical-align: inherit;">Ini memiliki mekanisme yang mengurangi waktu henti singkat, dan sementara jeda tidak melebihi 150 ms, pengumpulan sampah hanya berdampak lokal.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id507198/index.html">Podcast sebagai media korporat: cara menghasilkan uang darinya dan metrik apa yang digunakan</a></li>
<li><a href="../id507200/index.html">7 Cara Data Ilmuwan Membodohi Anda</a></li>
<li><a href="../id507202/index.html">Pertemuan Avito Analytics</a></li>
<li><a href="../id507204/index.html">Desain interior dapur: mulai dari sketsa hingga produk dalam kotak</a></li>
<li><a href="../id507206/index.html">Arsitektur Y messenger</a></li>
<li><a href="../id507212/index.html">Melatih saingan gim pintar di Unity menggunakan metode "mainkan sendiri" menggunakan ML-Agents</a></li>
<li><a href="../id507214/index.html">Cara membuat dan memodifikasi formulir PDF interaktif, atau skill baru ABBYY FineReader PDF</a></li>
<li><a href="../id507218/index.html">Baca saya, atau mengapa teks tidak dibaca sampai akhir</a></li>
<li><a href="../id507222/index.html">Kenapa semua orang harus memakai topeng</a></li>
<li><a href="../id507224/index.html">Cara menghilangkan bintik-bintik buta dengan pengujian visual</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>