<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌥️ 🕤 😲 時計の管理方法は？第2回プログラミングチャンピオンシップのフロントエンドトラックの分析 ☯️ ⛷️ 🙍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近のチャンピオンシップの一連の分析における新しいhabrapost。フロントエンドセクションを選択した資格認定の参加者は、非常に異なる複雑さのいくつかの問題を解決する必要がありました。通常とは異なる主題領域を理解する能力を含む、インターフェース開発者の幅広いスキルをテストしました。
 
 A.全滅...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>時計の管理方法は？第2回プログラミングチャンピオンシップのフロントエンドトラックの分析</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478550/"><img src="https://habrastorage.org/webt/4e/n2/ks/4en2ksorc6zfdwcwfcvsceozmxg.jpeg" width="300" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近のチャンピオンシップの一連の分析における新しいhabrapost。</font><font style="vertical-align: inherit;">フロントエンドセクションを選択した資格認定の参加者は、非常に異なる複雑さのいくつかの問題を解決する必要がありました。</font><font style="vertical-align: inherit;">通常とは異なる主題領域を理解する能力を含む、インターフェース開発者の幅広いスキルをテストしました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.全滅させる</font></font></h2><sup><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者：Maxim Sysoev、Konstantin Petryaev</font></font></i></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初のタスクはウォームアップです。</font><font style="vertical-align: inherit;">各参加者は、互いに同様に、タスクの4つのオプションのいずれかを取得しました。</font><font style="vertical-align: inherit;">テキスト条件だけでなく、「悪い」再帰的解決策も提案しました。</font><font style="vertical-align: inherit;">コードをやり直し（最速のソリューションを生成する貪欲なアルゴリズムを作成）、再帰や不要な操作や計算な​​どのさまざまなナンセンスを削除する必要がありました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは反物質の研究のために実験室で仕事を得ました、そこで彼らは様々な実験を行います。あなたの部門は、物質と反物質を組み合わせるときに発生するプロセスを研究しています。特定の数の分子に対して一連の実験を行う必要があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接する部門は、物質を短期間で反物質に変える装置を開発しました。次のアルゴリズムを使用して実験を行う場合に役立ちます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。-最も重い分子が2つ見つかりました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-私たちはそれらの1つを反物質に変えます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-それらを組み合わせます。また、重さが同じであれば全滅します。重みが異なる場合は、新しい分子を取得します。その分子の重みは、前の2つの分子の重みの差に等しくなります。結果として生じる分子自体が問題です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-分子が1つ残っている場合は、その重量を調べる必要があります。分子が多い場合は、ステップ1に戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験の最後に残る分子を見つける必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この知識は、別の部門の科学者が必要としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の開発者はこれらの計算に関連するコードをスケッチしましたが、実験が多数の分子で実行された場合、コードは計算を完了できません。</font><font style="vertical-align: inherit;">適切な時間内で機能するようにコードを調整する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたから継承したコード</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
入力として、分子量の配列ができます。</font><font style="vertical-align: inherit;">出力として、最後の分子の重量を示す数値を返す必要があります。</font><font style="vertical-align: inherit;">分子が残っていない場合は、0を返す必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">weights, i = weights.length - <span class="hljs-number">1</span></span>) </span>{  
  <span class="hljs-keyword">const</span> cur = weights.length - <span class="hljs-number">1</span> === i;  <font></font>
 <font></font>
  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> weights[<span class="hljs-number">0</span>];  <font></font>
 <font></font>
  weights.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);  <font></font>
  weights[i - <span class="hljs-number">1</span>] = (weights[i] === weights[i<span class="hljs-number">-1</span>]) ? <span class="hljs-number">0</span> : weights[i] - weights[i<span class="hljs-number">-1</span>];  <font></font>
 <font></font>
  <span class="hljs-keyword">return</span> findLatestWeight(weights, i - <span class="hljs-number">1</span>);  <font></font>
}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例とメモ</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></h4><br>
: [2,7,4,1,8,1]<br>
: 1<br>
<br>
    7  8,  7         8.    1.     [2,4,1,1,1].     2  4,  2         4.    2.     [2,1,1,1].     2  1,  1         2.    1.     [1,1,1].     1  1,           .  .    [1].   .  — 1.<br>
<br>
<h4></h4><br>
    ,      findLatestWeight:<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLatestWeight</span>(<span class="hljs-params">weights</span>) </span>{  
  <span class="hljs-comment">// ...  </span><font></font>
}  <font></font>
 <font></font>
<span class="hljs-built_in">module</span>.exports = findLatestWeight;</code></pre><br>
    Node.js 12.<br>
</div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提供された「悪い」ソリューションには、一度にいくつかの問題があります。</font><font style="vertical-align: inherit;">最初は再帰です。</font><font style="vertical-align: inherit;">条件で述べたように、数値の大きな配列を処理します。これにより、再帰的なソリューションが即座に排除されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">weights</span>) </span>{
    <span class="hljs-keyword">let</span> i = weights.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> weights[<span class="hljs-number">0</span>] || <span class="hljs-number">0</span>;<font></font>
<font></font>
        weights.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<font></font>
        weights[i<span class="hljs-number">-1</span>] = (weights[i]=== weights[i<span class="hljs-number">-1</span>]) ? <span class="hljs-number">0</span> : weights[i]-weights[i<span class="hljs-number">-1</span>];<font></font>
<font></font>
        i--;<font></font>
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで再帰を拡張することは非常に簡単ですが、別の問題が発生します-一定の再ソート（小さいものから大きいものへ）があり、配列の最後を処理します。</font><font style="vertical-align: inherit;">その結果、配列の最後から2番目の要素が減少します。</font><font style="vertical-align: inherit;">しかし、その後は配列をトリムせず、100万要素の配列が関数に渡された場合は、最後まで再ソートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するオプションは、常にアレイをトリミングすることです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">weights</span>) </span>{
    <span class="hljs-keyword">let</span> i = weights.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> weights[<span class="hljs-number">0</span>] || <span class="hljs-number">0</span>;<font></font>
<font></font>
        weights.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<font></font>
        weights[i<span class="hljs-number">-1</span>] = (weights[i]=== weights[i<span class="hljs-number">-1</span>]) ? <span class="hljs-number">0</span> : weights[i]-weights[i<span class="hljs-number">-1</span>];<font></font>
	weights.length = i; <span class="hljs-comment">// &lt;---  </span><font></font>
        i--;<font></font>
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪くはありませんが、並べ替えを取り除く必要もあります。これは、それ自体が高価な操作です。</font><font style="vertical-align: inherit;">概して、いつでも、配列の最大の2つのメンバーに関心があります。</font><font style="vertical-align: inherit;">つまり、1つのパスで非常に簡単に実行される2つの高値の検索です。</font><font style="vertical-align: inherit;">便宜上、このような検索は別の関数で実行します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> maximumTwo = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> max1 = arr[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> max2 = arr[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">let</span> max1I = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> max2I = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">if</span> (arr[i] &gt; max1) {
            <span class="hljs-keyword">if</span> (max1 &gt; max2) {<font></font>
                max2 = arr[i];<font></font>
                max2I = i;<font></font>
            } <span class="hljs-keyword">else</span> {<font></font>
                max1 = arr[i];<font></font>
                max1I = i;<font></font>
            }<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; max2) {<font></font>
            max2 = arr[i];<font></font>
            max2I = i;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (max1 &gt; max2) <span class="hljs-keyword">return</span> [max2, max1, max2I, max1I];
    <span class="hljs-keyword">return</span> [max1, max2, max1I, max2I];<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、検索機能を次のように変更します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">weights</span>) </span>{
    <span class="hljs-keyword">if</span> (weights.length &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> weights[<span class="hljs-number">0</span>];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">const</span> [x, y, xI, yI] =  maximumTwo(weights);
        <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> y;<font></font>
        }<font></font>
<font></font>
        weights[xI] = <span class="hljs-number">0</span>;<font></font>
        weights[yI] = y - x;<font></font>
<font></font>
    } <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、2つの要素のうち小さい方を常にゼロにし、大きい方をそれらの差に変換します。</font><font style="vertical-align: inherit;">ソートを取り除き、代わりに1つの線形パスを取得しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが気付いた一般的な間違いのうち、参加者は最大の要素を取り、それに–1を掛けて2番目に大きい石に追加しました。</font><font style="vertical-align: inherit;">結果は負の数になり、「そのまま」の計算に使用されました。</font><font style="vertical-align: inherit;">さらに、このタスクには、独自の重量の石を残して、それらとの差を計算できるという事実に関連した精神的な罠があります。</font><font style="vertical-align: inherit;">ただし、この方法では正しい結果が得られません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B. BEM</font></font></h2><sup><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成者：Eugene Mishchenko、Vladimir Grinenko </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タダトゥタ</font></font></a></i></sup><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイアウトAlexanderは、BEM方法論を使用する多くのプロジェクトに関与しています。彼は愛するIDE用の便利なプラグインを作成しました。これにより、短縮表記でクラス名を記述し、それらを完全に展開することができます。しかし、問題は、プロジェクトごとに、人々がブロック、要素、修飾子（block__mod__val-elem、block-mod-val ___ elem）の間に異なる区切り文字を設定し、毎回プラグインで手動で編集する必要があることです。 Alexanderがクラスに基づいてエンティティーのセパレーターを決定するモジュールを書くのを手伝ってください。区切り文字の規則は、文字ではなく任意の数の文字です。可能な表記法の例（入力データ内のブロックの修飾子には値がない場合があります）：</font></font><br>
<br>
<pre><code class="javascript hljs">block_mod__elem <span class="hljs-comment">// ,      </span><font></font>
block_mod_mod__elem  <font></font>
block__elem_mod_mod<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確化：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-プロジェクトのクラスは小文字でのみ書かれています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-有効なCSSクラスの文字列がモジュールの入力に供給されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールは次の形式の応答を返す必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs">{  
  <span class="hljs-attr">mod</span>: <span class="hljs-string">"_"</span>, <span class="hljs-comment">//     </span>
  <span class="hljs-attr">elem</span>: <span class="hljs-string">"__"</span>, <span class="hljs-comment">//     </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールはcommonJSモジュールとして発行する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{  <font></font>
 <font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のタスクには約20分かかりました。その助けを借りて、参加者の間で正規表現の知識をテストしたかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この条件から、関数への入力は、追加の制限付きの有効なCSSクラスを含む文字列であり、文字シーケンスが非文字文字の任意のシーケンスで区切られていることがわかります。私たちの仕事は、セパレータを見つけてそのセマンティクスを理解することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス名の最初の部分は常にブロックの名前になります。これは、1つ以上の文字のシーケンスです。対応する正規表現[az] +を記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの部分を検索するには、同様の式が必要です。修飾子の名前とその値、または対応する修飾子と値を持つ要素の名前。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区切り文字を検索するには、文字以外のシーケンスが必要です。式：[^ az] +が適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それをまとめて、使用する値を持つグループを定義します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> [, mod, elem ] = str.match(<span class="hljs-regexp">/[a-z]+(?:([^a-z]+)[a-z]+(?:\1)?[a-z]+)([^a-z]+)[a-z]+(?:\2)?[a-z]+/</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、見つかったグループのセマンティクスを正しく定義したことを確認する必要があります。</font><font style="vertical-align: inherit;">モディファイアだけが2回会うことができるという事実を利用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出現数を計算するために見つかった元の文字列とセパレータを取得する関数を記述します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> substringCount = <span class="hljs-function">(<span class="hljs-params">source, substr</span>) =&gt;</span> (source.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'[a-z]'</span> + substr + <span class="hljs-string">'[a-z]'</span>, <span class="hljs-string">'g'</span>)) || []).length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区切り文字elemが2回発生し、mod-1回発生することが判明した場合、実際にはその逆です。</font><font style="vertical-align: inherit;">最終決定：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> [, mod, elem ] = str.match(<span class="hljs-regexp">/[a-z]+(?:([^a-z]+)[a-z]+(?:\1)?[a-z]+)([^a-z]+)[a-z]+(?:\2)?[a-z]+/</span>);
    <span class="hljs-keyword">const</span> substringCount = <span class="hljs-function">(<span class="hljs-params">source, substr</span>) =&gt;</span> (source.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'[a-z]'</span> + substr + <span class="hljs-string">'[a-z]'</span>, <span class="hljs-string">'g'</span>)) || []).length;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (substringCount(str, elem) === <span class="hljs-number">2</span> &amp;&amp; substringCount(str, mod) === <span class="hljs-number">1</span>) {<font></font>
        [mod, elem] = [elem, mod];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> { mod, elem };<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.クローンファクトリー</font></font></h2><sup><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成者：Dmitry Andriyanov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dima117</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アレクセイ・グセフ</font></font></i></sup><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
窓の外は2319です。企業は、成功した従業員を複製して複雑なタスクを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クローンの生産では、彼らは、クローンを区別するために、肩にバーコードが付いた入れ墨の助けを借りて、新しい「製品」にラベルを付けることにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工場のスタッフが、クローンに関する情報を含むバーコードを描画する関数を作成できるようにします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クローン情報のフォーマットクローン</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
情報は次のように保存されます。</font></font><br>
<br>
<pre><code class="javascript hljs">type CloneInfo = {  
    <span class="hljs-comment">/**  
     *   —  ’male’  ’female’  
     */</span>  
    <span class="hljs-attr">sex</span>: string;  
    <span class="hljs-comment">/**  
     *   —       
     *    ,  10   
     */</span>  <font></font>
    id: string;  <font></font>
    <span class="hljs-comment">/**  
     *   —       
     *     ( 0  26 )  
     */</span>  <font></font>
    name: string;  <font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バーコードレンダリングアルゴリズム</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クローンファクトリで使用される</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/jj/dc/jljjdcawcmcsrmsgyyi9bk19oii.png" width="400"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バーコードは</font><font style="vertical-align: inherit;">次のようになります。</font><font style="vertical-align: inherit;">バーコードのサイズは148 x 156ピクセルに固定されています。バーコードの周囲には、それぞれ3ピクセルの黒と白のフレームがあります。フレーム内には、1行あたり17個の黒または白の正方形の18行で構成されるバーコードコンテンツがあります。各正方形のサイズは8 x 8ピクセルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテンツの白い四角は0、黒いものは1をエンコードします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バーコードコンテンツを生成するアルゴリズムコンテンツ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の最初の行と最初の列の交点に、クローンの性別をエンコードする四角が描かれます。女性の値はゼロ（白）、男性の値（黒）でエンコードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、&lt;id&gt; &lt;name&gt;という形式の行がフィールドidとnameから形成されます。名前フィールドには、最大26文字の末尾にスペースが埋め込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の文字列はバイト配列に変換されます-文字列の各文字には、対応するASCIIコード（0〜255の数値）が割り当てられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、結果の配列の各要素はバイナリ表記（8文字の0または1）に変換され、8つの正方形のシーケンス（0-白い四角形、1-黒の正方形）でエンコードされます。</font><font style="vertical-align: inherit;">正方形は、バーコードコンテンツに順次、1行ずつ描画されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテンツの最後の行には、制御情報が含まれています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御情報計算アルゴリズム</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
制御情報行の各正方形は、対応する列のコンテンツ値の合計のパリティを決定します。</font><font style="vertical-align: inherit;">列のゼロと1の合計が偶数の場合は、白い正方形が制御情報に描画され、それ以外の場合は黒い正方形が描画されます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの形式と例</font></font></b><div class="spoiler_text"><b> </b><br>
<br>
      renderBarcode:<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">/**  
 *       element  
 * <span class="hljs-doctag">@param </span>cloneInfo {CloneInfo} —     
 * <span class="hljs-doctag">@param </span>element {HTMLDivElement} — div     
 *     148x156 ,       
 */</span>  
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderBarcode</span>(<span class="hljs-params">cloneInfo, element</span>) </span>{  
    <span class="hljs-comment">//    </span>
}&lt;/source lang=<span class="hljs-string">"javascript"</span>&gt;<font></font>
     Google Chrome <span class="hljs-number">77.</span><font></font>
<font></font>
&lt;h4&gt; <span class="hljs-number">1</span>&lt;/h4&gt;<font></font>
  :<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"javascript"</span>&gt;</span>{  
    "sex": "male",  
    "id": "c5j818dyo5",  
    "name": "Oleg Vladimirovich"  
}</span></code></pre><br>
:<br>
<br>
<img src="https://habrastorage.org/webt/zm/pi/iz/zmpiiztvwzeo77-xswxzdrfhshs.png"><br>
<br>
<h4> 2</h4><br>
  :<br>
<br>
<pre><code class="javascript hljs">{  
    <span class="hljs-string">"sex"</span>: <span class="hljs-string">"female"</span>,  
    <span class="hljs-string">"id"</span>: <span class="hljs-string">"0owrgqqwfw"</span>,  
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"Dazdraperma Petrovna"</span>  
}</code></pre><br>
:<br>
<br>
<img src="https://habrastorage.org/webt/9e/yk/vo/9eykvoqjupololm76rjmle7030k.png"></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データのバイナリ表現を正しく形成し、そのチェックサムを計算して、このデータをレイアウトに描画する必要がありました。</font><font style="vertical-align: inherit;">コードの最適化を行わずに、これをできるだけ簡単で額にしてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリ表現から始めましょう。</font><font style="vertical-align: inherit;">まず、ヘルパー関数を宣言します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    ASCII-</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charToByte</span>(<span class="hljs-params">char</span>) </span>{
  <span class="hljs-keyword">return</span> char.charCodeAt(<span class="hljs-number">0</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//      0  1 (      )</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">byteToString</span>(<span class="hljs-params">byte</span>) </span>{
  <span class="hljs-keyword">return</span> byte.toString(<span class="hljs-number">2</span>).padStart(<span class="hljs-number">8</span>, <span class="hljs-string">'0'</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースデータから、ゼロと1で構成される文字列を形成します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> dataString =<font></font>
  (cloneInfo.sex === <span class="hljs-string">'female'</span> ? <span class="hljs-string">'0'</span> : <span class="hljs-string">'1'</span>) +<font></font>
  cloneInfo.id.split(<span class="hljs-string">''</span>).map(charToByte).map(byteToString).join(<span class="hljs-string">''</span>) +<font></font>
  cloneInfo.name.padEnd(<span class="hljs-number">26</span>, <span class="hljs-string">' '</span>).split(<span class="hljs-string">''</span>).map(charToByte).map(byteToString).join(<span class="hljs-string">''</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、バーコードのレイアウトとスタイルを記述します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    «» .</span>
<span class="hljs-comment">//  ,      DOM API   innerHTML,     . </span>
<span class="hljs-comment">//     ,      ,      «».</span>
<span class="hljs-comment">//         —   ,        .</span>
<span class="hljs-keyword">const</span> contentElId = <span class="hljs-string">'content-'</span> + <span class="hljs-built_in">Math</span>.random();<font></font>
element.style.display = <span class="hljs-string">'flex'</span>;<font></font>
element.innerHTML = <span class="hljs-string">`
  &lt;style&gt;
    .barcode {
      border: 3px solid black;
      box-sizing: border-box;
    }

    .content {
      margin-top: 3px;
      margin-left: 3px;
      width: 136px;
      height: 144px;
      display: flex;
      flex-wrap: wrap;
    }

    .content__bit {
      width: 8px;
      height: 8px;
    }
        
    .content__bit_one {
      background: black;
    }
  &lt;/style&gt;

  &lt;div class="content" id="<span class="hljs-subst">${contentElId}</span>"&gt;&lt;/div&gt;
`</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> contentDiv = <span class="hljs-built_in">document</span>.getElementById(contentElId);<font></font>
element.className += <span class="hljs-string">' barcode'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリデータをレイアウトにレンダリングします。</font></font><br>
<br>
<pre><code class="javascript hljs">dataString<font></font>
  .split(<span class="hljs-string">''</span>)<font></font>
  .forEach(<span class="hljs-function">(<span class="hljs-params">bit</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> bitDiv = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);<font></font>
    bitDiv.className = <span class="hljs-string">'content__bit content__bit_'</span> + (bit === <span class="hljs-string">'0'</span> ? <span class="hljs-string">'zero'</span> : <span class="hljs-string">'one'</span>);<font></font>
    contentDiv.appendChild(bitDiv);<font></font>
  });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チェックサムの計算と表示は残ります。</font><font style="vertical-align: inherit;">これは次のように行うことができます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">17</span>; i++) {
  <span class="hljs-comment">//  </span>
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; <span class="hljs-number">17</span> ** <span class="hljs-number">2</span>; j += <span class="hljs-number">17</span>) {<font></font>
    sum += <span class="hljs-built_in">parseInt</span>(dataString[j], <span class="hljs-number">2</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">const</span> check = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> bitDiv = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
  <span class="hljs-comment">//      </span>
  bitDiv.className = <span class="hljs-string">'content__bit content__bit_'</span> + (sum % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">'zero'</span> : <span class="hljs-string">'one'</span>);<font></font>
  contentDiv.appendChild(bitDiv);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.自動化する</font></font></h2><sup><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者：Vladimir Rusov、Dmitry Kanatnikov</font></font></i></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
各資格オプションには、表またはリストを含むHTMLページが入力として提供されるタスクがありました。</font><font style="vertical-align: inherit;">このシリーズのタスクには別の凡例がありましたが、それらはすべて、ページをMarkdownと同様の形式にする必要があるという事実にまで煮詰められました。</font><font style="vertical-align: inherit;">問題の1つに対する解決策を分析します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスの提供のための州のポータルで、彼らは完全に自動的にドキュメントを申請することを可能にしました、これのためにあなたは個人データでテーブルに記入するだけで済みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、このデータは検証のために総務省を含むいくつかの当局に送信されます。</font><font style="vertical-align: inherit;">テストの開始後、総務省はMarkdown形式のデータを受け入れ、州政府サービスはHTML形式を使用することが判明しました。</font><font style="vertical-align: inherit;">あるフォーマットを別のフォーマットに移行するスクリプトを書いて、みんなができるだけ早く起動できるようにしてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTMLテーブルを入力として受け取り、それをMarkdownのようなマークアップに変換する関数を作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタスクのソリューションとして、ソリューション関数が宣言されている.jsファイルを送信します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solution</span>(<span class="hljs-params">input</span>) </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入出力形式と注意事項</font></font></b><div class="spoiler_text"><h4>  </h4><br>
HTML-    :<br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"right"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">col</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Command         <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Description     <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Is implemented  <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>git status<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>List all new or modified    files<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>git diff<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Show file differences that haven't been<font></font>
 staged<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre><br>
     colgroup, thead  tbody   .    ,       thead  tbody.<br>
<br>
— colgroup   col,       align      (left|center|right)<br>
— thead  tbody  1   tr<br>
— tr,   ,   td,   th<br>
—        .&nbsp; —        .&nbsp; —        -whitespace .<br>
—   th/td            col  colgroup,   colgroup.<br>
—       HTML     ,    HTML.<br>
<br>
<h4>  </h4><br>
      Markdown-:<br>
<br>
<code>| Command | Description | **Is implemented** |<br>
| ---: | :--- | :---: |<br>
| **git status** | List all new or modified files | **Yes** |<br>
| **git diff** | Show file differences that haven't been staged | No |</code><br>
<br>
—          -  Markdown-. <br>
—       . <br>
—    .<br>
—  td   ,  th  **bold**. <br>
—     markdown-    (|)   .<br>
—      td  th   . <br>
—        . <br>
—            .<br>
—      Markdown-    :<br>
<br>
　| :--- |&nbsp;    &nbsp;<br>
　| :---: |&nbsp;   &nbsp;<br>
　| ---: |&nbsp;    <br>
<br>
     col  align     .<br>
<br>
<h4></h4><br>
—       \n.<br>
—       <b>(Chrome 78)</b>     document  window.<br>
—     <b>es2018</b> .</div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、テーブルのDOMツリーをトラバースするだけで解決されます。</font><font style="vertical-align: inherit;">DOMツリーのサポートはブラウザレベルで実装されており、その不可欠な部分であるため、問題はありません。</font><font style="vertical-align: inherit;">この問題を解決するには、DOMツリーをHTMLからMarkdownマークアップに変換するだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を調べると、変換が非常に簡単であることがわかります。</font><font style="vertical-align: inherit;">以下は、ソリューション（入力）関数の本体であるコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、文字列をHTMLからDOMツリーに変換する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);<font></font>
div.innerHTML = input;<font></font>
<span class="hljs-keyword">const</span> table = div.firstChild;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOMツリーを受け取ったら、それをたどって、さまざまなDOMノードからのデータを処理できます。</font><font style="vertical-align: inherit;">これを行うには、さまざまなDOM要素の子のシーケンスを再帰的にバイパスするだけで十分です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> processors = {
    <span class="hljs-string">'colgroup'</span>: processColgroup,
    <span class="hljs-string">'thead'</span>: processThead,
    <span class="hljs-string">'tbody'</span>: processTbody,<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> child <span class="hljs-keyword">of</span> table.children) {<font></font>
    processors[child.tagName.toLowerCase()](child);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
colgroupおよびcolタグから、テーブルの列の配置を知ることに関心があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> alignments = [];
<span class="hljs-keyword">const</span> defaultAlign = <span class="hljs-string">'left'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> processColgroup = <span class="hljs-function">(<span class="hljs-params">colgroup</span>) =&gt;</span> {<font></font>
    alignments.push(...Array(...colgroup.children).map(<span class="hljs-function"><span class="hljs-params">col</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> col.align || defaultAlign;<font></font>
    }));<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
thead、tbody、およびtrタグでは、子供のみに関心があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> rows = [];<font></font>
<font></font>
<span class="hljs-keyword">const</span> processThead = <span class="hljs-function">(<span class="hljs-params">thead</span>) =&gt;</span> {<font></font>
    rows.push(...Array(...thead.children).map(processTr));<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> processTbody = <span class="hljs-function">(<span class="hljs-params">tbody</span>) =&gt;</span> {<font></font>
    rows.push(...Array(...tbody.children).map(processTr));<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> processTr = <span class="hljs-function">(<span class="hljs-params">tr</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(...tr.children).map(processCell);<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
慣例により、tdとthのフォーマットは異なることを忘れないでください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> processCell = <span class="hljs-function">(<span class="hljs-params">cell</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> tag = cell.tagName.toLowerCase();
    <span class="hljs-keyword">const</span> content = clearString(cell.innerHTML);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'td'</span>: content,
        <span class="hljs-string">'th'</span>: <span class="hljs-string">`**<span class="hljs-subst">${content}</span>**`</span>,<font></font>
    }[tag];<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOMのテストコンテンツを使用するには、条件に記載されている要件を満たす必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> clearLineBreaks = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.replace(<span class="hljs-regexp">/\r?\n|\r/g</span>, <span class="hljs-string">''</span>);
<span class="hljs-keyword">const</span> clearSpaces = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">' '</span>);
<span class="hljs-keyword">const</span> clearString = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> clearSpaces(clearLineBreaks(str)).trim();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOMツリーをウォークスルーした後、テーブルの主要部分が行配列に書き込まれました。列の配置</font><font style="vertical-align: inherit;">
に関する情報は、alignments配列にありました。</font><font style="vertical-align: inherit;">
列の配置に関する情報は、入力データに含まれていない可能性があることに注意してください。</font></font><br>
<br>
<code>[<br>
 ["Command","Description","**Is implemented**"],<br>
 ["**git status**","List all new or modified files","**Yes**"],<br>
 ["**git diff**","Show file differences that haven't been staged","No"]<br>
]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>["right","left","center"]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> updateAlignments = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (alignments.length &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
    alignments.push(...rows[<span class="hljs-number">0</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> defaultAlign));<font></font>
};<font></font>
<font></font>
updateAlignments();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形を最終形式に変換します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> alignmentsContents = alignments.map(<span class="hljs-function"><span class="hljs-params">align</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'left'</span>: <span class="hljs-string">' :--- '</span>,
        <span class="hljs-string">'center'</span>: <span class="hljs-string">' :---: '</span>,
        <span class="hljs-string">'right'</span>: <span class="hljs-string">' ---: '</span><font></font>
    }[align];<font></font>
});<font></font>
<span class="hljs-keyword">const</span> delimiter = <span class="hljs-string">`|<span class="hljs-subst">${alignmentsContents.join(<span class="hljs-string">'|'</span>)}</span>|`</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区切り値の例：</font></font><br>
<br>
<code>"| ---: | :--- | :---: |"</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、HTMLから読み取られたすべてのデータを含むMarkdown行の形成です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> lineEnd = <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
rows.forEach(<span class="hljs-function">(<span class="hljs-params">row, i</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) markdown += lineEnd;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> mdRow = <span class="hljs-string">`| <span class="hljs-subst">${row.join(<span class="hljs-string">' | '</span>)}</span> |`</span>;<font></font>
    markdown += mdRow;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {<font></font>
        markdown += lineEnd;<font></font>
        markdown += delimiter;<font></font>
    }<font></font>
});<font></font>
<font></font>
<span class="hljs-keyword">return</span> markdown;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
return構文は、上記のすべてのコードがソリューション（入力）関数の本体であることを意味します。</font><font style="vertical-align: inherit;">この関数の結果として、タスク条件からの出力例に示されている必要なMarkdownテーブルコードを取得します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E.パンデミックウイルス</font></font></h2><sup><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者：Andrei Mokrousov、Ivan Petukhov</font></font></i></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
世界保健機関は、フロントエンドの開発者を脅かす新しいウイルスの差し迫った流行の兆候に関するレポートを公開しました。ホストが何らかの式を含むJSコードを見るまで、ウイルスは現れないことが知られています。感染者はこの表現を見るとすぐに、JSでコードを書く能力を失い、Fortranで自発的にコードを書き始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートは、Zyn関数呼び出しへの引数によって渡された関数の最初の引数の使用を見ることによってウイルスが活性化されることを述べています。つまり、感染者はZyn（function（a、b、c）{console.log（a）}）のような式を表示できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誤ってすべてのフロントエンドを失うことがないように、AST＆Coは、コードに上記の式が含まれているかどうかを確認することにしました。会社のエンジニアがそのようなチェックを書くのを助けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AST＆Coのコードについては、次のこと</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
が</font><font style="vertical-align: inherit;">わかっています。</font><font style="vertical-align: inherit;">-ES3で記述されている</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-ドットと角かっこ（abと['b']）の両方を介してオブジェクトのプロパティにアクセスできる</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-式の一部を変数に格納できる、ただしパラメータ（a（x）-forbidden）によって関数に渡されることはありません</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。-検索された式の一部を返す関数はありません。-式の</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部を含むオブジェクトまたは配列要素のプロパティはありません。-オブジェクト</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のプロパティにアクセスする場合、プロパティ名は変数から取得（a [x]、xは変数）、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-変数は宣言中に値を取得し、上書きされません。つまり、コードにはそのようなvar a = xはありません。</font><font style="vertical-align: inherit;">a = y; </font><font style="vertical-align: inherit;">および変数a = b = 1。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの形式とメモ</font></font></b><div class="spoiler_text"><h4> </h4><br>
      CommonJS-,   ,       (ast)  .<br>
<br>
     ast-,       callback-,    Z.y.n.      ,   .<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{<font></font>
  ...<font></font>
  return [...];<font></font>
}</code></pre><br>
<h4></h4><br>
        .<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">/**
 *   .     ,
 *   callback- onNodeEnter (  )
 *  onNodeLeave (  )   
 *     (  Scope ).
 *
 * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>    </span>ast                               ast.
 * <span class="hljs-doctag">@param      <span class="hljs-type">{Function}</span>  </span>[onNodeEnter=(node, scope)=&gt;{}]        .
 * <span class="hljs-doctag">@param      <span class="hljs-type">{Function}</span>  </span>[onNodeLeave=(node, scope)=&gt;{}]        .
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">
    ast,
    onNodeEnter = (node, scope</span>) =&gt; </span>{},<font></font>
    onNodeLeave = <span class="hljs-function">(<span class="hljs-params">node, scope</span>) =&gt;</span> {}<font></font>
) {<font></font>
    <span class="hljs-keyword">const</span> rootScope = <span class="hljs-keyword">new</span> Scope(ast);<font></font>
<font></font>
    _inner(ast, rootScope);<font></font>
<font></font>
    <span class="hljs-comment">/**
     *    .
     *     scope,   .
     *
     * @param      {object}  astNode       ast-.
     * @param      {Scope}   currentScope    .
     * @return     {Scope}        astNode.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveScope</span>(<span class="hljs-params">astNode, currentScope</span>) </span>{
        <span class="hljs-keyword">let</span> isFunctionExpression = ast.type === <span class="hljs-string">'FunctionExpression'</span>,<font></font>
            isFunctionDeclaration = ast.type === <span class="hljs-string">'FunctionDeclaration'</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFunctionExpression &amp;&amp;<font></font>
            !isFunctionDeclaration) {<font></font>
            <span class="hljs-comment">//      .</span>
            <span class="hljs-keyword">return</span> currentScope;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">//      .</span>
        <span class="hljs-keyword">const</span> newScope = <span class="hljs-keyword">new</span> Scope(ast, currentScope);<font></font>
<font></font>
        ast.params.forEach(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> {
            <span class="hljs-comment">//     .</span><font></font>
            newScope.add(param.name);<font></font>
        });<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFunctionDeclaration) {
            <span class="hljs-comment">//       .</span><font></font>
            currentScope.add(ast.id.name);<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//  -    .</span><font></font>
            newScope.add(ast.id.name);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> newScope;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">/**
     *    ast.
     *
     * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>  </span>astNode   ast-.
     * <span class="hljs-doctag">@param      <span class="hljs-type">{Scope}</span>  </span>scope         ast-.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inner</span>(<span class="hljs-params">astNode, scope</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(astNode)) {<font></font>
            astNode.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
                <span class="hljs-comment">/*    .
                 *  , ,  .
                 */</span><font></font>
                _inner(node, scope);<font></font>
            });<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (astNode &amp;&amp; <span class="hljs-keyword">typeof</span> astNode === <span class="hljs-string">'object'</span>) {<font></font>
            onNodeEnter(astNode, scope);<font></font>
<font></font>
            <span class="hljs-keyword">const</span> innerScope = resolveScope(astNode, scope),<font></font>
                keys = <span class="hljs-built_in">Object</span>.keys(astNode).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                    <span class="hljs-comment">// loc -  ,   ast-.</span>
                    <span class="hljs-keyword">return</span> key !== <span class="hljs-string">'loc'</span> &amp;&amp;<font></font>
                        astNode[key] &amp;&amp; <span class="hljs-keyword">typeof</span> astNode[key] === <span class="hljs-string">'object'</span>;<font></font>
                });<font></font>
<font></font>
            keys.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                <span class="hljs-comment">//   .</span><font></font>
                _inner(astNode[key], innerScope);<font></font>
            });<font></font>
<font></font>
            onNodeLeave(astNode, scope);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/**
 *   .
 *
 * <span class="hljs-doctag">@class      </span>Scope (name)
 * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>  </span>astNode      ast-,    .
 * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>  </span>parentScope    .
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scope</span>(<span class="hljs-params">astNode, parentScope</span>) </span>{
    <span class="hljs-keyword">this</span>._node = astNode;
    <span class="hljs-keyword">this</span>._parent = parentScope;
    <span class="hljs-keyword">this</span>._vars = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<font></font>
}<font></font>
<font></font>
Scope.prototype = {<font></font>
    <span class="hljs-comment">/**
     *      .
     *
     * <span class="hljs-doctag">@param      <span class="hljs-type">{string}</span>  </span>name     .
     */</span><font></font>
    add(name) {<font></font>
        <span class="hljs-keyword">this</span>._vars.add(name);<font></font>
    },<font></font>
    <span class="hljs-comment">/**
     *       .
     *
     * <span class="hljs-doctag">@param      <span class="hljs-type">{string}</span>   </span>name     .
     * <span class="hljs-doctag">@return     <span class="hljs-type">{boolean}</span>  </span>         .
     */</span><font></font>
    isDefined(name) {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._vars.has(name) || (<span class="hljs-keyword">this</span>._parent &amp;&amp; <span class="hljs-keyword">this</span>._parent.isDefined(name));<font></font>
    }<font></font>
};</code></pre></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、制限に対処しましょう。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-それはES3で書かれています</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、ツリーをトラバースする場合、最も基本的な言語構成要素のみが見つかります。</font><font style="vertical-align: inherit;">たとえば、配列の操作に使用できるのはループだけです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-オブジェクトのプロパティへのアクセスは、ポイントとブラケットの両方を介して可能です（abおよび['b']）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、ZynだけでなくZ ['y']、N、Zy ['n']、Z ['y'] ['n']も検索する必要があります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式の一部を変数に格納できますが、パラメーターによって関数に渡されることはありません（a（x）-forbidden）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数の値とスコープを追跡する必要があるため、このアイテムはすぐにタスクを数倍難しくします。</font><font style="vertical-align: inherit;">たとえば、次のコードを設定する必要があります。var x = Zy; </font><font style="vertical-align: inherit;">xn（...）</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-目的の式の一部を返す関数はありません</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-オブジェクトのプロパティまたは式の一部を含む配列の要素はありません</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-変数は宣言時に値を取得し、上書きされません。つまり、</font><font style="vertical-align: inherit;">コードはvar a = xのようにはなりません。</font><font style="vertical-align: inherit;">a = y; </font><font style="vertical-align: inherit;">および変数a = b = 1。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの点（および式を関数に渡すことの禁止）はタスクを簡略化しますが、変数とスコープの値を考慮する必要があります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-オブジェクトのプロパティを参照する場合、プロパティの名前は変数から取得できます（[x]、xは変数）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この項目では、監視する必要のあるオブジェクトのプロパティにアクセスする別の方法について説明します。var x = 'y'; Z [x] .n（...）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おおよそのソリューションプランが明らかになり</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。1.宣言時に受け取る変数の値に関する情報を収集して、ツリー全体を</font><font style="vertical-align: inherit;">移動</font><font style="vertical-align: inherit;">します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.前の段落の情報を考慮して、目的のデザインを見つけます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクノートに記載されたコードは、最も退屈な場所で少し時間を節約できます-ツリーをたどり、関数の名前とパラメーターに関する情報を収集します。したがって、ポイント2から始めます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の検索検索を2つの部分に分割します。最初にZyn（関数（a、b、c）{...}）を見つけ、次に関数内の最初の引数を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分はFunctionExpressionに対応します。これはCallExpressionの最初で唯一のパラメーターであり、その呼び出し先はMemberExpressionです。</font><font style="vertical-align: inherit;">さらに、名前のプロパティはnであり、オブジェクト（名前がyのオブジェクトとプロパティを持つ別のMemberExpression）はZです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。2番目の部分は、最初の引数の呼び出しに対応します。これは、有効なアクション（書き換え）のみが条件によって禁止されているためです。</font><font style="vertical-align: inherit;">最初の引数の呼び出しは、MemberExpressionとObjectLiteral以外のプロパティとして検出された同じ名前の識別子です（それぞれxaとvar x = {a：...}）。</font></font><br>
<br>
<pre><code class="javascript hljs">+++ b/traverse.js<font></font>
@@ <span class="hljs-number">-120</span>,<span class="hljs-number">3</span> +<span class="hljs-number">120</span>,<span class="hljs-number">59</span> @@ Scope.prototype = {
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._vars.has(name) || (<span class="hljs-keyword">this</span>._parent &amp;&amp; <span class="hljs-keyword">this</span>._parent.isDefined(name));<font></font>
     }<font></font>
 };<font></font>
+<font></font>
+<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{<font></font>
+    <span class="hljs-keyword">var</span> result = [];<font></font>
+<font></font>
+    traverse(ast, (node, scope) =&gt; {<font></font>
+        <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'CallExpression'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+        <span class="hljs-keyword">let</span> args = node.arguments;<font></font>
+        <span class="hljs-keyword">if</span> (args.length !== <span class="hljs-number">1</span> ||<font></font>
+            args[<span class="hljs-number">0</span>].type !== <span class="hljs-string">'FunctionExpression'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+        <span class="hljs-keyword">let</span> callee = node.callee;<font></font>
+        <span class="hljs-keyword">if</span> (callee.type !== <span class="hljs-string">'MemberExpression'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+        <span class="hljs-keyword">let</span> property = callee.property,<font></font>
+            object = callee.object;<font></font>
+        <span class="hljs-keyword">if</span> (property.name !== <span class="hljs-string">'n'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+        <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'MemberExpression'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+        property = object.property;<font></font>
+        object = object.object;<font></font>
+        <span class="hljs-keyword">if</span> (property.name !== <span class="hljs-string">'y'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+        <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'Identifier'</span> ||<font></font>
+            object.name !== <span class="hljs-string">'Z'</span>) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+<font></font>
+        checkFunction(args[<span class="hljs-number">0</span>]);<font></font>
+    });<font></font>
+<font></font>
+    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFunction</span>(<span class="hljs-params">ast</span>) </span>{<font></font>
+        <span class="hljs-keyword">let</span> firstArg = ast.params[<span class="hljs-number">0</span>];<font></font>
+        <span class="hljs-keyword">if</span> (!firstArg) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+<font></font>
+        traverse(ast.body, (node, scope) =&gt; {<font></font>
+            <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'Identifier'</span>) {<font></font>
+                <span class="hljs-keyword">return</span>;<font></font>
+            }<font></font>
+            <span class="hljs-keyword">if</span> (node.name === firstArg.name) {<font></font>
+                result.push(node);<font></font>
+            }<font></font>
+        });<font></font>
+    }<font></font>
+<font></font>
+    <span class="hljs-keyword">return</span> result;<font></font>
+};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トラバースへの最後の呼び出しは、トラバースするときに、MemberExpressionおよびObjectPropertyの識別子を正しくフィルター処理するために親情報が必要であることを示しています。</font><font style="vertical-align: inherit;">追加：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs">--- a/traverse.js<font></font>
+++ b/traverse.js<font></font>
@@ <span class="hljs-number">-60</span>,<span class="hljs-number">16</span> +<span class="hljs-number">60</span>,<span class="hljs-number">16</span> @@ <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">
      * @param      {object}  astNode   ast-
      * @param      {Scope}  scope         ast-
      */
-    function _inner(astNode, scope</span>) </span>{<font></font>
+    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inner</span>(<span class="hljs-params">astNode, scope, parent</span>) </span>{
         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(astNode)) {<font></font>
             astNode.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
                 <span class="hljs-comment">/*    .
                  *  , ,  
                  */</span><font></font>
-                _inner(node, scope);<font></font>
+                _inner(node, scope, parent);<font></font>
             });<font></font>
         } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (astNode &amp;&amp; <span class="hljs-keyword">typeof</span> astNode === <span class="hljs-string">'object'</span>) {<font></font>
-            onNodeEnter(astNode, scope);<font></font>
+            onNodeEnter(astNode, scope, parent);<font></font>
<font></font>
             <span class="hljs-keyword">const</span> innerScope = resolveScope(astNode, scope),<font></font>
                 keys = <span class="hljs-built_in">Object</span>.keys(astNode).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {<font></font>
@@ <span class="hljs-number">-80</span>,<span class="hljs-number">10</span> +<span class="hljs-number">80</span>,<span class="hljs-number">10</span> @@ <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">

             keys.forEach(key =&gt; {
                 <span class="hljs-regexp">//</span>   
-                _inner(astNode[key], innerScope</span>);
+                <span class="hljs-title">_inner</span>(<span class="hljs-params">astNode[key], innerScope, astNode</span>);
             });

-            <span class="hljs-title">onNodeLeave</span>(<span class="hljs-params">astNode, scope</span>);
+            <span class="hljs-title">onNodeLeave</span>(<span class="hljs-params">astNode, scope, parent</span>);
         }
     }
 }
@@ -164,10 +164,22 @@ <span class="hljs-title">module</span>.<span class="hljs-title">exports</span> = <span class="hljs-title">function</span> (<span class="hljs-params">ast</span>) </span>{
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
<font></font>
-        traverse(ast.body, (node, scope) =&gt; {<font></font>
+        traverse(ast.body, (node, scope, parent) =&gt; {<font></font>
             <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'Identifier'</span>) {
                 <span class="hljs-keyword">return</span>;<font></font>
             }<font></font>
+            <span class="hljs-keyword">if</span> (!parent) {<font></font>
+                <span class="hljs-keyword">return</span>;<font></font>
+            }<font></font>
+            <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">'MemberExpression'</span> &amp;&amp;<font></font>
+                parent.computed === <span class="hljs-literal">false</span> &amp;&amp;<font></font>
+                parent.property === node) {<font></font>
+                <span class="hljs-keyword">return</span>;<font></font>
+            }<font></font>
+            <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">'ObjectProperty'</span> &amp;&amp;<font></font>
+                parent.key === node) {<font></font>
+                <span class="hljs-keyword">return</span>;<font></font>
+            }<font></font>
             <span class="hljs-keyword">if</span> (node.name === firstArg.name) {<font></font>
                 result.push(node);<font></font>
             }</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
括弧を通してオブジェクトのプロパティへの魅力を考慮する必要があります。</font><font style="vertical-align: inherit;">getPropName関数を作成します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs">--- a/traverse.js<font></font>
+++ b/traverse.js<font></font>
@@ <span class="hljs-number">-121</span>,<span class="hljs-number">6</span> +<span class="hljs-number">121</span>,<span class="hljs-number">18</span> @@ Scope.prototype = {<font></font>
     }<font></font>
 };<font></font>
<font></font>
+<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropName</span>(<span class="hljs-params">node</span>) </span>{<font></font>
+    <span class="hljs-keyword">let</span> prop = node.property;<font></font>
+<font></font>
+    <span class="hljs-keyword">if</span> (!node.computed) {<font></font>
+        <span class="hljs-keyword">return</span> prop.name;<font></font>
+    }<font></font>
+<font></font>
+    <span class="hljs-keyword">if</span> (prop.type === <span class="hljs-string">'StringLiteral'</span>) {<font></font>
+        <span class="hljs-keyword">return</span> prop.value;<font></font>
+    }<font></font>
+}<font></font>
+<font></font>
 <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
     <span class="hljs-keyword">var</span> result = [];<font></font>
<font></font>
@@ <span class="hljs-number">-137</span>,<span class="hljs-number">17</span> +<span class="hljs-number">149</span>,<span class="hljs-number">17</span> @@ <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
         <span class="hljs-keyword">if</span> (callee.type !== <span class="hljs-string">'MemberExpression'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
-        <span class="hljs-keyword">let</span> property = callee.property,<font></font>
+        <span class="hljs-keyword">let</span> property = getPropName(callee),<font></font>
             object = callee.object;<font></font>
-        <span class="hljs-keyword">if</span> (property.name !== <span class="hljs-string">'n'</span>) {<font></font>
+        <span class="hljs-keyword">if</span> (property !== <span class="hljs-string">'n'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
         <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'MemberExpression'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
-        property = object.property;<font></font>
+        property = getPropName(object);<font></font>
         object = object.object;<font></font>
-        <span class="hljs-keyword">if</span> (property.name !== <span class="hljs-string">'y'</span>) {<font></font>
+        <span class="hljs-keyword">if</span> (property !== <span class="hljs-string">'y'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
         <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'Identifier'</span> ||</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードにはまだ欠陥があり、スコープと変数を使用していません。</font><font style="vertical-align: inherit;">しかし、彼は少なくとも最初の3つのテストに合格しています。</font><font style="vertical-align: inherit;">次にステップ1に進みます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スコープの改善</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
変数とその値に関する情報のコレクションをスコープに追加する必要があります。</font><font style="vertical-align: inherit;">さらに、トラバースする呼び出し間で収集した情報が失われないようにする必要があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs">--- a/traverse.js<font></font>
+++ b/traverse.js<font></font>
@@ <span class="hljs-number">-1</span>,<span class="hljs-number">3</span> +<span class="hljs-number">1</span>,<span class="hljs-number">12</span> @@<font></font>
+<span class="hljs-keyword">const</span> scopeStorage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<font></font>
+<font></font>
+<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeFor</span>(<span class="hljs-params">ast, outerScope</span>) </span>{<font></font>
+    <span class="hljs-keyword">if</span> (!scopeStorage.has(ast)) {<font></font>
+        scopeStorage.set(ast, <span class="hljs-keyword">new</span> Scope(ast, outerScope));<font></font>
+    }<font></font>
+<font></font>
+    <span class="hljs-keyword">return</span> scopeStorage.get(ast);<font></font>
+}<font></font>
 <span class="hljs-comment">/**
  *   .     ,
  *   callback- onNodeEnter (  ).
@@ -13,7 +22,7 @@ function traverse(
     onNodeEnter = (node, scope) =&gt; {},
     onNodeLeave = (node, scope) =&gt; {}
 ) {
-    const rootScope = new Scope(ast);
+    const rootScope = getScopeFor(ast);

     _inner(ast, rootScope);

@@ -36,19 +45,19 @@ function traverse(
         }

         //      .
-        const newScope = new Scope(ast, currentScope);
+        const newScope = getScopeFor(ast, currentScope);

         ast.params.forEach(param =&gt; {
             //     .
-            newScope.add(param.name);
+            newScope.add(param.name, param);
         });

         if (isFunctionDeclaration) {
             //       .
-            currentScope.add(ast.id.name);
+            currentScope.add(ast.id.name, ast);
         } else if (ast.id) {
             //  -    .
-            newScope.add(ast.id.name);
+            newScope.add(ast.id.name, ast);
         }

         return newScope;
@@ -98,7 +107,7 @@ function traverse(
 function Scope(astNode, parentScope) {
     this._node = astNode;
     this._parent = parentScope;
-    this._vars = new Set();
+    this._vars = new Map();
 }

 Scope.prototype = {
@@ -107,8 +116,24 @@ Scope.prototype = {
      *
      * <span class="hljs-doctag">@param      <span class="hljs-type">{string}</span>  </span>name     
      */</span><font></font>
-    add(name) {<font></font>
-        <span class="hljs-keyword">this</span>._vars.add(name);<font></font>
+    add(name, value) {<font></font>
+        <span class="hljs-keyword">this</span>._vars.set(name, {<font></font>
+            value: value,<font></font>
+            scope: <span class="hljs-keyword">this</span><font></font>
+        });<font></font>
+    },<font></font>
+    resolve(node) {<font></font>
+        <span class="hljs-keyword">if</span> (!node) {<font></font>
+            <span class="hljs-keyword">return</span> node;<font></font>
+        }<font></font>
+        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'Identifier'</span>) {<font></font>
+            <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>._vars.get(node.name);<font></font>
+            <span class="hljs-keyword">if</span> (value) {<font></font>
+                <span class="hljs-keyword">return</span> value;<font></font>
+            }<font></font>
+            value = (<span class="hljs-keyword">this</span>._parent &amp;&amp; <span class="hljs-keyword">this</span>._parent.resolve(node));<font></font>
+            <span class="hljs-keyword">return</span> value;<font></font>
+        }<font></font>
     },<font></font>
     <span class="hljs-comment">/**
      *       .
@@ -136,6 +161,12 @@ function getPropName(node) {
 module.exports = function (ast) {
     var result = [];

+    traverse(ast, (node, scope) =&gt; {
+        if (node.type === 'VariableDeclarator') {
+            scope.add(node.id.name, node.init);
+        }
+    });
+
     traverse(ast, (node, scope) =&gt; {
         if (node.type !== 'CallExpression') {
             return;</span></code></pre></div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スコープの使用</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、変数に関する知識の使用を追加します。</font><font style="vertical-align: inherit;">式の各部分は変数に配置できるため、各部分の後の後でスコープを参照します。</font><font style="vertical-align: inherit;">変数の値はスコープに関連付けられているため、スコープ自体も変更される可能性があることに注意してください。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs">--- a/traverse.js<font></font>
+++ b/traverse.js<font></font>
@@ <span class="hljs-number">-146</span>,<span class="hljs-number">13</span> +<span class="hljs-number">146</span>,<span class="hljs-number">17</span> @@ Scope.prototype = {<font></font>
     }<font></font>
 };<font></font>
<font></font>
-<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropName</span>(<span class="hljs-params">node</span>) </span>{<font></font>
+<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropName</span>(<span class="hljs-params">node, scope</span>) </span>{
     <span class="hljs-keyword">let</span> prop = node.property;<font></font>
<font></font>
     <span class="hljs-keyword">if</span> (!node.computed) {
         <span class="hljs-keyword">return</span> prop.name;<font></font>
     }<font></font>
<font></font>
+    <span class="hljs-keyword">let</span> resolved = scope.resolve(prop);<font></font>
+    <span class="hljs-keyword">if</span> (resolved) {<font></font>
+        prop = resolved.value;<font></font>
+    }<font></font>
     <span class="hljs-keyword">if</span> (prop.type === <span class="hljs-string">'StringLiteral'</span>) {
         <span class="hljs-keyword">return</span> prop.value;<font></font>
     }<font></font>
@@ <span class="hljs-number">-177</span>,<span class="hljs-number">22</span> +<span class="hljs-number">181</span>,<span class="hljs-number">43</span> @@ <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
         <span class="hljs-keyword">let</span> callee = node.callee;<font></font>
+<font></font>
+        <span class="hljs-keyword">let</span> resolved = scope.resolve(callee);<font></font>
+        <span class="hljs-keyword">if</span> (resolved) {<font></font>
+            callee = resolved.value;<font></font>
+            scope = resolved.scope;<font></font>
+        }<font></font>
+<font></font>
         <span class="hljs-keyword">if</span> (callee.type !== <span class="hljs-string">'MemberExpression'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
-        <span class="hljs-keyword">let</span> property = getPropName(callee),<font></font>
+        <span class="hljs-keyword">let</span> property = getPropName(callee, scope),<font></font>
             object = callee.object;<font></font>
         <span class="hljs-keyword">if</span> (property !== <span class="hljs-string">'n'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
+<font></font>
+        resolved = scope.resolve(object);<font></font>
+        <span class="hljs-keyword">if</span> (resolved) {<font></font>
+            object = resolved.value;<font></font>
+            scope = resolved.scope;<font></font>
+        }<font></font>
+<font></font>
         <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'MemberExpression'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
-        property = getPropName(object);<font></font>
+        property = getPropName(object, scope);<font></font>
         object = object.object;<font></font>
         <span class="hljs-keyword">if</span> (property !== <span class="hljs-string">'y'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
+<font></font>
+        resolved = scope.resolve(object);<font></font>
+        <span class="hljs-keyword">if</span> (resolved) {<font></font>
+            object = resolved.value;<font></font>
+            scope = resolved.scope;<font></font>
+        }<font></font>
+<font></font>
         <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'Identifier'</span> ||<font></font>
             object.name !== <span class="hljs-string">'Z'</span>) {
             <span class="hljs-keyword">return</span>;</code></pre></div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近の改善</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コード全体をもう一度見てみましょう。ソリューションは9つのテストのうち5つだけに合格します。</font><font style="vertical-align: inherit;">3つの問題を区別できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-Zが必要なグローバルオブジェクトであり、なんらかの変数ではないことの検証はありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-関数が目的の関数の引数の使用を検出し、同じ名前のネストされた変数を検出していないことの検証はありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-変数の値の取得は1回だけ行われますが、var a = 'x'、b = aの形式のチェーンは条件によって禁止されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの3つのポイントを修正すると、ソリューションの準備が整います。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs">--- a/traverse.js<font></font>
+++ b/traverse.js<font></font>
@@ <span class="hljs-number">-128</span>,<span class="hljs-number">10</span> +<span class="hljs-number">128</span>,<span class="hljs-number">23</span> @@ Scope.prototype = {<font></font>
         }<font></font>
         <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'Identifier'</span>) {
             <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>._vars.get(node.name);<font></font>
-            <span class="hljs-keyword">if</span> (value) {<font></font>
-                <span class="hljs-keyword">return</span> value;<font></font>
+            <span class="hljs-keyword">if</span> (!value) {<font></font>
+                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._parent) {<font></font>
+                    value = <span class="hljs-keyword">this</span>._parent.resolve(node);<font></font>
+                } <span class="hljs-keyword">else</span> {<font></font>
+                    <span class="hljs-comment">//   scope,  node —</span>
+                    <span class="hljs-comment">//   .</span>
+                    <span class="hljs-keyword">this</span>.add(node.name, node);<font></font>
+                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resolve(node);<font></font>
+                }<font></font>
+            }<font></font>
+            <span class="hljs-keyword">if</span> (!value) {<font></font>
+                <span class="hljs-keyword">return</span>;<font></font>
+            }<font></font>
+            <span class="hljs-keyword">if</span> (value.value.type === <span class="hljs-string">'Identifier'</span> &amp;&amp;<font></font>
+                value.value !== node) {<font></font>
+                <span class="hljs-keyword">return</span> value.scope.resolve(value.value) || value;<font></font>
             }<font></font>
-            value = (<span class="hljs-keyword">this</span>._parent &amp;&amp; <span class="hljs-keyword">this</span>._parent.resolve(node));
             <span class="hljs-keyword">return</span> value;<font></font>
         }<font></font>
     },<font></font>
@@ <span class="hljs-number">-165</span>,<span class="hljs-number">12</span> +<span class="hljs-number">178</span>,<span class="hljs-number">15</span> @@ <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropName</span>(<span class="hljs-params">node, scope</span>) </span>{
 <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
     <span class="hljs-keyword">var</span> result = [];<font></font>
<font></font>
+<font></font>
     traverse(ast, (node, scope) =&gt; {<font></font>
         <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'VariableDeclarator'</span>) {<font></font>
             scope.add(node.id.name, node.init);<font></font>
         }<font></font>
     });<font></font>
<font></font>
+    <span class="hljs-keyword">let</span> rootScope = getScopeFor(ast);<font></font>
+<font></font>
     traverse(ast, (node, scope) =&gt; {<font></font>
         <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'CallExpression'</span>) {
             <span class="hljs-keyword">return</span>;<font></font>
@@ <span class="hljs-number">-213</span>,<span class="hljs-number">9</span> +<span class="hljs-number">229</span>,<span class="hljs-number">10</span> @@ <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{<font></font>
         }<font></font>
<font></font>
         resolved = scope.resolve(object);<font></font>
+        <span class="hljs-keyword">let</span> zScope;
         <span class="hljs-keyword">if</span> (resolved) {<font></font>
             object = resolved.value;<font></font>
-            scope = resolved.scope;<font></font>
+            zScope = resolved.scope;<font></font>
         }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'Identifier'</span> ||<font></font>
@@ <span class="hljs-number">-223</span>,<span class="hljs-number">6</span> +<span class="hljs-number">240</span>,<span class="hljs-number">10</span> @@ <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
<font></font>
+        <span class="hljs-keyword">if</span> (zScope &amp;&amp; zScope !== rootScope) {<font></font>
+            <span class="hljs-keyword">return</span>;<font></font>
+        }<font></font>
+<font></font>
         checkFunction(args[<span class="hljs-number">0</span>]);<font></font>
     });<font></font>
<font></font>
@@ <span class="hljs-number">-232</span>,<span class="hljs-number">7</span> +<span class="hljs-number">253</span>,<span class="hljs-number">10</span> @@ <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
             <span class="hljs-keyword">return</span>;<font></font>
         }<font></font>
<font></font>
-        traverse(ast.body, (node, scope, parent) =&gt; {<font></font>
+        traverse(ast, (node, scope, parent) =&gt; {<font></font>
+            <span class="hljs-keyword">if</span> (parent === ast) {<font></font>
+                <span class="hljs-keyword">return</span>;<font></font>
+            }<font></font>
             <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'Identifier'</span>) {
                 <span class="hljs-keyword">return</span>;<font></font>
             }<font></font>
@@ <span class="hljs-number">-248</span>,<span class="hljs-number">7</span> +<span class="hljs-number">272</span>,<span class="hljs-number">9</span> @@ <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{<font></font>
                 parent.key === node) {<font></font>
                 <span class="hljs-keyword">return</span>;<font></font>
             }<font></font>
-            <span class="hljs-keyword">if</span> (node.name === firstArg.name) {<font></font>
+<font></font>
+            <span class="hljs-keyword">let</span> resolved = scope.resolve(node);<font></font>
+            <span class="hljs-keyword">if</span> (resolved &amp;&amp; resolved.value === firstArg) {<font></font>
                 result.push(node);<font></font>
             }<font></font>
         });</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なソリューションコード：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> scopeStorage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeFor</span>(<span class="hljs-params">ast, outerScope</span>) </span>{
    <span class="hljs-keyword">if</span> (!scopeStorage.has(ast)) {<font></font>
        scopeStorage.set(ast, <span class="hljs-keyword">new</span> Scope(ast, outerScope));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> scopeStorage.get(ast);<font></font>
}<font></font>
<span class="hljs-comment">/**
 *   .     ,
 *  callback- onNodeEnter (  )
 *  onNodeLeave (  )    
 *     (  Scope )
 *
 * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>    </span>ast                               ast
 * <span class="hljs-doctag">@param      <span class="hljs-type">{Function}</span>  </span>[onNodeEnter=(node, scope)=&gt;{}]        
 * <span class="hljs-doctag">@param      <span class="hljs-type">{Function}</span>  </span>[onNodeLeave=(node, scope)=&gt;{}]        
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">
    ast, 
    onNodeEnter = (node, scope</span>) =&gt; </span>{}, <font></font>
    onNodeLeave = <span class="hljs-function">(<span class="hljs-params">node, scope</span>) =&gt;</span> {}<font></font>
) {<font></font>
    <span class="hljs-keyword">const</span> rootScope = getScopeFor(ast);<font></font>
<font></font>
    _inner(ast, rootScope);<font></font>
<font></font>
    <span class="hljs-comment">/**
     *    .
     *     scope,   
     *
     * @param      {object}  ast       ast-
     * @param      {Scope}   currentScope    
     * @return     {Scope}        astNode
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveScope</span>(<span class="hljs-params">ast, currentScope</span>) </span>{
        <span class="hljs-keyword">let</span> isFunctionExpression = ast.type === <span class="hljs-string">'FunctionExpression'</span>,<font></font>
            isFunctionDeclaration = ast.type === <span class="hljs-string">'FunctionDeclaration'</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFunctionExpression &amp;&amp;<font></font>
            !isFunctionDeclaration) {<font></font>
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">return</span> currentScope;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">//      </span>
        <span class="hljs-keyword">const</span> newScope = getScopeFor(ast, currentScope);<font></font>
<font></font>
        ast.params.forEach(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> {
            <span class="hljs-comment">//     </span><font></font>
            newScope.add(param.name, param);<font></font>
        });<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFunctionDeclaration) {
            <span class="hljs-comment">//       </span><font></font>
            currentScope.add(ast.id.name, ast);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ast.id) {
            <span class="hljs-comment">//  -    </span><font></font>
            newScope.add(ast.id.name, ast);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> newScope;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">/**
     *    ast
     *
     * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>  </span>astNode   ast-
     * <span class="hljs-doctag">@param      <span class="hljs-type">{Scope}</span>  </span>scope         ast-
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inner</span>(<span class="hljs-params">astNode, scope, parent</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(astNode)) {<font></font>
            astNode.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
                <span class="hljs-comment">/*    .
                 *  , ,  
                 */</span><font></font>
                _inner(node, scope, parent);<font></font>
            });<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (astNode &amp;&amp; <span class="hljs-keyword">typeof</span> astNode === <span class="hljs-string">'object'</span>) {<font></font>
            onNodeEnter(astNode, scope, parent);<font></font>
<font></font>
            <span class="hljs-keyword">const</span> innerScope = resolveScope(astNode, scope),<font></font>
                keys = <span class="hljs-built_in">Object</span>.keys(astNode).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                    <span class="hljs-comment">// loc -  ,   ast-</span>
                    <span class="hljs-keyword">return</span> key !== <span class="hljs-string">'loc'</span> &amp;&amp;<font></font>
                        astNode[key] &amp;&amp; <span class="hljs-keyword">typeof</span> astNode[key] === <span class="hljs-string">'object'</span>;<font></font>
                });<font></font>
<font></font>
            keys.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                <span class="hljs-comment">//   </span><font></font>
                _inner(astNode[key], innerScope, astNode);<font></font>
            });<font></font>
<font></font>
            onNodeLeave(astNode, scope, parent);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/**
 *   
 *
 * <span class="hljs-doctag">@class      </span>Scope (name)
 * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>  </span>astNode      ast-,    
 * <span class="hljs-doctag">@param      <span class="hljs-type">{object}</span>  </span>parentScope    
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scope</span>(<span class="hljs-params">astNode, parentScope</span>) </span>{
    <span class="hljs-keyword">this</span>._node = astNode;
    <span class="hljs-keyword">this</span>._parent = parentScope;
    <span class="hljs-keyword">this</span>._vars = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<font></font>
}<font></font>
<font></font>
Scope.prototype = {<font></font>
    <span class="hljs-comment">/**
     *      
     *
     * <span class="hljs-doctag">@param      <span class="hljs-type">{string}</span>  </span>name     
     */</span><font></font>
    add(name, value) {<font></font>
        <span class="hljs-keyword">this</span>._vars.set(name, {
            <span class="hljs-attr">value</span>: value,
            <span class="hljs-attr">scope</span>: <span class="hljs-keyword">this</span><font></font>
        });<font></font>
    },<font></font>
    resolve(node) {<font></font>
        <span class="hljs-keyword">if</span> (!node) {
            <span class="hljs-keyword">return</span> node;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'Identifier'</span>) {
            <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>._vars.get(node.name);
            <span class="hljs-keyword">if</span> (!value) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._parent) {<font></font>
                    value = <span class="hljs-keyword">this</span>._parent.resolve(node);<font></font>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">//   scope,  node -</span>
                    <span class="hljs-comment">//   </span>
                    <span class="hljs-keyword">this</span>.add(node.name, node);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resolve(node);<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (!value) {
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (value.value.type === <span class="hljs-string">'Identifier'</span> &amp;&amp;<font></font>
                value.value !== node) {<font></font>
                <span class="hljs-keyword">return</span> value.scope.resolve(value.value) || value;<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> value;<font></font>
        }<font></font>
    },<font></font>
    <span class="hljs-comment">/**
     *       .
     *
     * <span class="hljs-doctag">@param      <span class="hljs-type">{string}</span>   </span>name     
     * <span class="hljs-doctag">@return     <span class="hljs-type">{boolean}</span>  </span>         
     */</span><font></font>
    isDefined(name) {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._vars.has(name) || (<span class="hljs-keyword">this</span>._parent &amp;&amp; <span class="hljs-keyword">this</span>._parent.isDefined(name));<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropName</span>(<span class="hljs-params">node, scope</span>) </span>{
    <span class="hljs-keyword">let</span> prop = node.property;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (!node.computed) {
        <span class="hljs-keyword">return</span> prop.name;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">let</span> resolved = scope.resolve(prop);
    <span class="hljs-keyword">if</span> (resolved) {<font></font>
        prop = resolved.value;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (prop.type === <span class="hljs-string">'StringLiteral'</span>) {
        <span class="hljs-keyword">return</span> prop.value;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast</span>) </span>{
    <span class="hljs-keyword">var</span> result = [];<font></font>
<font></font>
<font></font>
    traverse(ast, (node, scope) =&gt; {<font></font>
        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'VariableDeclarator'</span>) {<font></font>
            scope.add(node.id.name, node.init);<font></font>
        }<font></font>
    });<font></font>
<font></font>
    <span class="hljs-keyword">let</span> rootScope = getScopeFor(ast);<font></font>
<font></font>
    traverse(ast, (node, scope) =&gt; {<font></font>
        <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'CallExpression'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">let</span> args = node.arguments;
        <span class="hljs-keyword">if</span> (args.length !== <span class="hljs-number">1</span> ||<font></font>
            args[<span class="hljs-number">0</span>].type !== <span class="hljs-string">'FunctionExpression'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">let</span> callee = node.callee;<font></font>
<font></font>
        <span class="hljs-keyword">let</span> resolved = scope.resolve(callee);
        <span class="hljs-keyword">if</span> (resolved) {<font></font>
            callee = resolved.value;<font></font>
            scope = resolved.scope;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (callee.type !== <span class="hljs-string">'MemberExpression'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">let</span> property = getPropName(callee, scope),<font></font>
            object = callee.object;<font></font>
        <span class="hljs-keyword">if</span> (property !== <span class="hljs-string">'n'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        resolved = scope.resolve(object);<font></font>
        <span class="hljs-keyword">if</span> (resolved) {<font></font>
            object = resolved.value;<font></font>
            scope = resolved.scope;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'MemberExpression'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        property = getPropName(object, scope);<font></font>
        object = object.object;<font></font>
        <span class="hljs-keyword">if</span> (property !== <span class="hljs-string">'y'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        resolved = scope.resolve(object);<font></font>
        <span class="hljs-keyword">let</span> zScope;
        <span class="hljs-keyword">if</span> (resolved) {<font></font>
            object = resolved.value;<font></font>
            zScope = resolved.scope;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (object.type !== <span class="hljs-string">'Identifier'</span> ||<font></font>
            object.name !== <span class="hljs-string">'Z'</span>) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (zScope &amp;&amp; zScope !== rootScope) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        checkFunction(args[<span class="hljs-number">0</span>]);<font></font>
    });<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFunction</span>(<span class="hljs-params">ast</span>) </span>{
        <span class="hljs-keyword">let</span> firstArg = ast.params[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (!firstArg) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        traverse(ast, (node, scope, parent) =&gt; {<font></font>
            <span class="hljs-keyword">if</span> (parent === ast) {
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'Identifier'</span>) {
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (!parent) {
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">'MemberExpression'</span> &amp;&amp;<font></font>
                parent.computed === <span class="hljs-literal">false</span> &amp;&amp;<font></font>
                parent.property === node) {<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">'ObjectProperty'</span> &amp;&amp;<font></font>
                parent.key === node) {<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">let</span> resolved = scope.resolve(node);
            <span class="hljs-keyword">if</span> (resolved &amp;&amp; resolved.value === firstArg) {<font></font>
                result.push(node);<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
};</code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F.クロックフレームワークのタスク</font></font></h2><sup><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成者：Dmitry Andriyanov、Alexey Berezhnoy </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">崩壊</font></font></a></i></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参加者は、あまり便利ではないAPIを備えた既製のフレームワークを使用して、通常とは異なる分野のアプリケーションを作成する必要がありました。</font><font style="vertical-align: inherit;">参加者にはフレームワークのドキュメントの基本的な部分のみを提供したかったのです。詳細を確認するには、そのコードを読む必要がありました。</font><font style="vertical-align: inherit;">サブジェクトエリアとして、ダイヤルクロックの管理を選択しました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステパンは銀河の収集家として働いています-銀河帝国全体の住宅と共同サービスのための借金を集めます。ステパンは彼の作品が好きです。それは彼が別の状況にあったことがなかったであろう場所を訪問することを可能にします。たくさんの感動と新しい知り合い！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステパンはしばしばある惑星から別の惑星へ飛ぶ必要があります。惑星は異なる軌道で回転するため、各惑星には独自のタイミングがあります。秒はどこでも同じように流れますが、惑星によって、1秒あたりの秒数、1時間あたりの分数、1日あたりの時間数は異なります（ただし、1日は常に時計回りの2回転に等しい）。また、過去には、すべての惑星の時間が0（0時間、0分、0秒）である基準点があったと考えられています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
惑星の時刻を切り替えられるステパン用の時計を作ってください。これには、JavaScriptとFrameworkと呼ばれるJSフレームワークを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時計の針は、時、分、秒の3つです。コンストラクターの引数には、惑星の時間パラメーターと現在の時刻（基準点からの経過秒数）が入ります。時計には、惑星の時間を切り替える（周期的な）ボタンが必要です。矢印を平行移動するときは、矢印を時計回りまたは反対方向に移動できます（最短経路上）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時計がオンになると、すべての針が値0を示します。リストから、最初の惑星の指定された時間（時間パラメーター）に対応する位置に針を最短で転送する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時計ファームウェアのコード例</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> ONE_SECOND_DEGREES = <span class="hljs-number">6</span>;  
<span class="hljs-keyword">const</span> ONE_SECOND_FACTOR = <span class="hljs-number">1</span> / Framework.SPEED * ONE_SECOND_DEGREES;  <font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Framework</span>.<span class="hljs-title">Clock</span> </span>{  
    <span class="hljs-keyword">constructor</span>() {  
        <span class="hljs-keyword">super</span>();  <font></font>
 <font></font>
        <span class="hljs-keyword">this</span>.arrows.push(<span class="hljs-keyword">new</span> Framework.Arrow(<span class="hljs-string">"seconds"</span>, {  
            <span class="hljs-attr">color</span>: <span class="hljs-string">"red"</span>  <font></font>
        }));  <font></font>
 <font></font>
        <span class="hljs-keyword">this</span>.arrows.push(<span class="hljs-keyword">new</span> Framework.Arrow(<span class="hljs-string">"minutes"</span>, {  
            <span class="hljs-attr">weight</span>: <span class="hljs-number">3</span>,  
            <span class="hljs-attr">length</span>: <span class="hljs-number">80</span>  <font></font>
        }));  <font></font>
 <font></font>
        <span class="hljs-keyword">this</span>.arrows.push(<span class="hljs-keyword">new</span> Framework.Arrow(<span class="hljs-string">"hours"</span>, {  
            <span class="hljs-attr">weight</span>: <span class="hljs-number">3</span>,  
            <span class="hljs-attr">length</span>: <span class="hljs-number">60</span>  <font></font>
        }));  <font></font>
 <font></font>
        <span class="hljs-keyword">this</span>.buttons.push(<span class="hljs-keyword">new</span> Framework.Button(<span class="hljs-string">"A"</span>, () =&gt; {  <font></font>
            alert(<span class="hljs-string">"A"</span>);  <font></font>
        }));  <font></font>
 <font></font>
        <span class="hljs-keyword">this</span>.tick = <span class="hljs-number">0</span>;  <font></font>
    }  <font></font>
 <font></font>
    onBeforeTick() {  <font></font>
        <span class="hljs-keyword">const</span> [arrow] = <span class="hljs-keyword">this</span>.arrows;  <font></font>
 <font></font>
        <span class="hljs-keyword">this</span>.tick++;  <font></font>
 <font></font>
        arrow.rotateFactor = <span class="hljs-keyword">this</span>.tick % <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : ONE_SECOND_FACTOR;  <font></font>
 <font></font>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"before: "</span> + arrow.pos);  <font></font>
    }  <font></font>
 <font></font>
    onAfterTick() {  <font></font>
        <span class="hljs-keyword">const</span> [arrow] = <span class="hljs-keyword">this</span>.arrows;  <font></font>
 <font></font>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"after: "</span> + arrow.pos);  <font></font>
    }  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームワークについて学んだこと：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-時計はベースから継承されたクラスです</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-時計には矢印とボタンがあります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-矢印が付いているローラーがあります。</font><font style="vertical-align: inherit;">短い間隔（100 ms）では、ローラーは時計回りに特定の角度で回転します。</font><font style="vertical-align: inherit;">ローラーに対する矢印の回転係数を変更することにより、矢印を制御できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、惑星によって時間の扱い方は異なりますが、「時間の基準点」があり、その結果、秒数は同じになります。</font><font style="vertical-align: inherit;">この値を使用して操作し、ティックごとに更新してから、特定の惑星の時間を再カウントし、矢印の位置を計算して、現在の状態からターゲットに移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のファームウェアバージョンには、秒、分、時の3つの針があります。</font><font style="vertical-align: inherit;">2番目は、タスクの条件に従って移動します。</font><font style="vertical-align: inherit;">分針と時針も移動する必要があり、対応する動作を持つ惑星の時間を切り替えるボタンを追加する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームワークのソースコードを見てみましょう。便宜上、定数を定義します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> TPS = <span class="hljs-number">1000</span> / Framework.INTERVAL; <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の惑星のティックを秒/分/時針に変換する機能を実装しています。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTarget</span>(<span class="hljs-params">ticks, planet</span>) </span>{
    <span class="hljs-keyword">const</span> { h, m, s } = planet; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">const</span> ts = <span class="hljs-built_in">Math</span>.floor(ticks / TPS); <span class="hljs-comment">//      </span><font></font>
<font></font>
    <span class="hljs-keyword">const</span> ss = ts % s * <span class="hljs-number">360</span> / s;
    <span class="hljs-keyword">const</span> mm = <span class="hljs-built_in">Math</span>.floor(ts / s) % m * <span class="hljs-number">360</span> / m;
    <span class="hljs-keyword">const</span> hh = <span class="hljs-built_in">Math</span>.floor(ts / (s * m)) % h * <span class="hljs-number">360</span> / h;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> { hh, mm, ss };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームワークは、矢印の動きを制御する唯一の方法があるように実装されています。これは、回転係数rotateFactorを設定することです。</font><font style="vertical-align: inherit;">これを行うには、回転係数を計算して矢印の現在の位置と到達する必要がある位置を取得する補助関数getRotateFactorを記述します。</font><font style="vertical-align: inherit;">この関数には2つのモードがあります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1。通常の時間の経過、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2。手の並進。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のモードでは、矢印は反対方向に移動できます。</font><font style="vertical-align: inherit;">モードは追加のパラメーターによって渡されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRotateFactor</span>(<span class="hljs-params">pos, target, forward = true</span>) </span>{
    <span class="hljs-keyword">let</span> angle = target - pos; <span class="hljs-comment">//       </span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (forward) {
        <span class="hljs-comment">//     </span>
        angle &lt; <span class="hljs-number">0</span> &amp;&amp; (angle += <span class="hljs-number">360</span>); <span class="hljs-comment">//        0  360 ( 360   0),   </span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//        </span>
        <span class="hljs-built_in">Math</span>.abs(angle) &gt; <span class="hljs-number">180</span> &amp;&amp; (angle -= <span class="hljs-built_in">Math</span>.sign(angle) * <span class="hljs-number">360</span>)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> angle / Framework.SPEED;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームワークのコードから、矢印の速度にMAX_SPEED制限があることがわかります。</font><font style="vertical-align: inherit;">これは、getRotateFactor関数で考慮する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRotateFactor</span>(<span class="hljs-params">pos, target, forward = true</span>) </span>{
    <span class="hljs-keyword">let</span> angle = target - pos;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (forward) {<font></font>
        angle &lt; <span class="hljs-number">0</span> &amp;&amp; (angle += <span class="hljs-number">360</span>);<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">Math</span>.abs(angle) &gt; <span class="hljs-number">180</span> &amp;&amp; (angle -= <span class="hljs-built_in">Math</span>.sign(angle) * <span class="hljs-number">360</span>)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> factor = angle / Framework.SPEED;
    <span class="hljs-comment">//      ,   </span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(factor) &gt; MAX_FACTOR ? <span class="hljs-built_in">Math</span>.sign(factor) * MAX_FACTOR : factor; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
惑星を切り替えるボタンのハンドラーを設定します。</font></font><br>
<br>
<pre><code class="javascript hljs">buttonAHandler() {
        <span class="hljs-comment">//    </span>
        <span class="hljs-keyword">this</span>.pos = (<span class="hljs-keyword">this</span>.pos + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.planets.length;
        <span class="hljs-comment">//     </span>
        <span class="hljs-keyword">this</span>.forward = <span class="hljs-literal">false</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ティックごとに次のことが発生します。</font></font><br>
<br>
<pre><code class="javascript hljs">onBeforeTick() {
        <span class="hljs-keyword">const</span> [sec, min, hour] = <span class="hljs-keyword">this</span>.arrows;
        <span class="hljs-keyword">const</span> time = ++<span class="hljs-keyword">this</span>.ticks;
        <span class="hljs-keyword">const</span> planet = <span class="hljs-keyword">this</span>.planets[<span class="hljs-keyword">this</span>.pos];<font></font>
<font></font>
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">const</span> target = getTarget(time, planet); 
        <span class="hljs-comment">//     </span>
        sec.rotateFactor = getRotateFactor(sec.pos, target.ss, <span class="hljs-keyword">this</span>.forward);<font></font>
        min.rotateFactor = getRotateFactor(min.pos, target.mm, <span class="hljs-keyword">this</span>.forward);<font></font>
        hour.rotateFactor = getRotateFactor(hour.pos, target.hh, <span class="hljs-keyword">this</span>.forward);<font></font>
 <font></font>
        <span class="hljs-comment">//       ,      </span>
        !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (<span class="hljs-keyword">this</span>.forward = <span class="hljs-literal">true</span>);<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なソリューションコード：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開いた</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> TPS = <span class="hljs-number">1000</span> / Framework.INTERVAL;
<span class="hljs-keyword">const</span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTarget</span>(<span class="hljs-params">ticks, planet</span>) </span>{
    <span class="hljs-keyword">const</span> { h, m, s } = planet;
    <span class="hljs-keyword">const</span> ts = <span class="hljs-built_in">Math</span>.floor(ticks / TPS); <span class="hljs-comment">// total seconds    </span><font></font>
<font></font>
    <span class="hljs-keyword">const</span> ss = ts % s * <span class="hljs-number">360</span> / s;
    <span class="hljs-keyword">const</span> mm = <span class="hljs-built_in">Math</span>.floor(ts / s) % m * <span class="hljs-number">360</span> / m;
    <span class="hljs-keyword">const</span> hh = <span class="hljs-built_in">Math</span>.floor(ts / (s * m)) % h * <span class="hljs-number">360</span> / h;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> { hh, mm, ss };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRotateFactor</span>(<span class="hljs-params">pos, target, forward = true</span>) </span>{
    <span class="hljs-keyword">let</span> angle = target - pos;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (forward) {<font></font>
        angle &lt; <span class="hljs-number">0</span> &amp;&amp; (angle += <span class="hljs-number">360</span>);<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">Math</span>.abs(angle) &gt; <span class="hljs-number">180</span> &amp;&amp; (angle -= <span class="hljs-built_in">Math</span>.sign(angle) * <span class="hljs-number">360</span>)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> factor = angle / Framework.SPEED;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(factor) &gt; MAX_FACTOR ? <span class="hljs-built_in">Math</span>.sign(factor) * MAX_FACTOR : factor; <font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Clock</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">// planets -  </span>
    <span class="hljs-comment">// [ { h: 4, m: 20, s: 10 }, ... ]</span>
    <span class="hljs-keyword">constructor</span>({ planets, time }) {
        <span class="hljs-keyword">super</span>();<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.arrows.push(<span class="hljs-keyword">new</span> Arrow(<span class="hljs-string">'seconds'</span>, {
            <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span><font></font>
        }));<font></font>
        <span class="hljs-keyword">this</span>.arrows.push(<span class="hljs-keyword">new</span> Arrow(<span class="hljs-string">'minutes'</span>, {
            <span class="hljs-attr">weight</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">length</span>: <span class="hljs-number">80</span><font></font>
        }));<font></font>
        <span class="hljs-keyword">this</span>.arrows.push(<span class="hljs-keyword">new</span> Arrow(<span class="hljs-string">'hours'</span>, {
            <span class="hljs-attr">weight</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">length</span>: <span class="hljs-number">60</span><font></font>
        }));<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.buttons.push(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">'Switch'</span>, <span class="hljs-keyword">this</span>.buttonAHandler.bind(<span class="hljs-keyword">this</span>)));<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.planets = planets;
        <span class="hljs-keyword">this</span>.ticks = time * TPS;
        <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.forward = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    onBeforeTick() {<font></font>
        <span class="hljs-keyword">const</span> [sec, min, hour] = <span class="hljs-keyword">this</span>.arrows;
        <span class="hljs-keyword">const</span> time = ++<span class="hljs-keyword">this</span>.ticks;
        <span class="hljs-keyword">const</span> planet = <span class="hljs-keyword">this</span>.planets[<span class="hljs-keyword">this</span>.pos];<font></font>
<font></font>
        <span class="hljs-keyword">const</span> target = getTarget(time, planet);<font></font>
        sec.rotateFactor = getRotateFactor(sec.pos, target.ss, <span class="hljs-keyword">this</span>.forward);<font></font>
        min.rotateFactor = getRotateFactor(min.pos, target.mm, <span class="hljs-keyword">this</span>.forward);<font></font>
        hour.rotateFactor = getRotateFactor(hour.pos, target.hh, <span class="hljs-keyword">this</span>.forward);<font></font>
<font></font>
        !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (<span class="hljs-keyword">this</span>.forward = <span class="hljs-literal">true</span>);<font></font>
    }<font></font>
<font></font>
    buttonAHandler() {<font></font>
        <span class="hljs-keyword">this</span>.pos = (<span class="hljs-keyword">this</span>.pos + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.planets.length;
        <span class="hljs-keyword">this</span>.forward = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
}</code></pre></div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
タスクは自動</font><b><font style="vertical-align: inherit;">テスト</font></b><font style="vertical-align: inherit;">によってチェックされました。その中で、ティックジェネレーターのスタブを作成し、コンストラクターのパラメーターに渡しました。したがって、タイマーでティックを生成する代わりに、テストコードで必要なティック数を生成し、矢印のステータスを確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの状況を確認しました：標準の矢印の動き、動きの不連続性、最大速度を超える矢印の平行移動、平行移動中の矢印の移動方向（方向に関連する条件は、問題のバージョンによって異なりました）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕事はかなり難しいことがわかりました。</font><font style="vertical-align: inherit;">参加者は、異常な主題領域となじみのないフレームワークを理解する必要がありました。</font><font style="vertical-align: inherit;">最高速度や逆ストロークの可能性など、いくつかの条件は隠されていました。</font><font style="vertical-align: inherit;">フレームワークのコードからのみそれらについて学ぶことができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの見積もりでは、タスクは約1時間かかっているはずです。</font><font style="vertical-align: inherit;">4人だけが完全にそれを決定し、ゼロ点以上（すべてのテストに合格したわけではない）は18人の参加者を獲得しました。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンク：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二選手権のML-トラックの分析</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初優勝のフロントエンドトラックの分析</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昨年の大会では、フロントエンドのトラックの分析</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja478538/index.html">パスポートの有効性を確認する方法</a></li>
<li><a href="../ja478540/index.html">第10回フォーラム「Positive Hack Days 10：Getting Started」が始まります</a></li>
<li><a href="../ja478542/index.html">figmaGen：iOSアプリのスタイルオートメーション</a></li>
<li><a href="../ja478544/index.html">Vue Storefront：Magento 2からディレクトリをインポート</a></li>
<li><a href="../ja478546/index.html">WebSocket 開発と運用の経験。クライアントを変更します</a></li>
<li><a href="../ja478552/index.html">2番目のアプレット、Processing 3で閉じ、透明なボタン</a></li>
<li><a href="../ja478554/index.html">ウェビナー「SRE-誇大宣伝か未来か？」12月12日11:00</a></li>
<li><a href="../ja478560/index.html">無料のインスタントメッセンジャーは匿名ですか？</a></li>
<li><a href="../ja478564/index.html">TsIANがテラバイトのログをどのように手入れしたか</a></li>
<li><a href="../ja478566/index.html">iOS アプリケーションが実行されていないときのネットワーク</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>