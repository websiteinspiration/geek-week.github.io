<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõí üìü üë©üèæ‚ÄçüöÄ Cuando el filtro de floraci√≥n no encaja üê≤ ‚òîÔ∏è ü§≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sab√≠a por la universidad sobre el filtro Bloom , una estructura de datos probabil√≠stica que lleva el nombre de Burton Bloom. Pero no tuve la oportunid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cuando el filtro de floraci√≥n no encaja</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sab√≠a por la universidad sobre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el filtro Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , una estructura de datos probabil√≠stica que lleva el nombre de Burton Bloom. Pero no tuve la oportunidad de usarlo. El mes pasado, apareci√≥ tal oportunidad, y esta estructura literalmente me fascin√≥. Sin embargo, pronto encontr√© algunos defectos en ella. Este art√≠culo es una historia sobre mi breve historia de amor con el filtro Bloom.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el proceso de investigaci√≥n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsificaci√≥n de IP,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fue necesario verificar las direcciones IP en los paquetes entrantes, compar√°ndolas con la ubicaci√≥n geogr√°fica de nuestros centros de datos. Por ejemplo, los paquetes de Italia no deben ir al centro de datos brasile√±o. Este problema puede parecer simple, pero en el panorama cambiante de Internet est√° lejos de ser simple. Baste decir que al final acumul√© muchos archivos de texto grandes con aproximadamente el siguiente contenido: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que una solicitud de la direcci√≥n IP resuelta 192.0.2.1 se registr√≥ en el centro de datos de Cloudflare n√∫mero 107. Estos datos provienen de muchas fuentes, incluidas nuestras muestras activas y pasivas, los registros de algunos dominios que poseemos (por ejemplo,</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), fuentes abiertas (por ejemplo, tablas BGP), etc. La misma l√≠nea generalmente se repite en varios archivos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Termin√© con un gigantesco conjunto de datos de este tipo. </font><font style="vertical-align: inherit;">En alg√∫n momento, en todas las fuentes recopiladas, cont√© mil millones de l√≠neas. </font><font style="vertical-align: inherit;">Por lo general, escribo scripts de bash para preprocesar los datos de entrada, pero en esta escala este enfoque no funcion√≥. </font><font style="vertical-align: inherit;">Por ejemplo, la eliminaci√≥n de duplicados de este peque√±o archivo de 600 MiB y 40 millones de l√≠neas de toma ... la eternidad: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baste decir que las l√≠neas de deduplicaci√≥n con comandos comunes del tipo </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en varias configuraciones (v√©ase </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) no era el mejor para un gran conjunto de tales datos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtros Bloom</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustraci√≥n de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el dominio p√∫blico</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Entonces me di cuenta: ¬°no ordene las l√≠neas! Debe eliminar duplicados, por lo que alg√∫n tipo de estructura de datos 'establecida' funcionar√° mucho m√°s r√°pido. Adem√°s, conozco aproximadamente el tama√±o del archivo de entrada (el n√∫mero de l√≠neas √∫nicas), y la p√©rdida de algunos datos no es cr√≠tica, es decir, la estructura de datos probabil√≠stica es bastante adecuada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Esto es perfecto para los filtros Bloom!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras lee</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia en los filtros Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ es como veo esta estructura de datos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo implementar√≠a</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la pluralidad</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Dada una funci√≥n hash ideal y una memoria infinita, simplemente podemos crear un mapa de bits infinito y establecer un n√∫mero de bit para cada elemento</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto proporciona la estructura de datos ideal para la "multitud". </font><font style="vertical-align: inherit;">¬øDerecha? </font><font style="vertical-align: inherit;">Trivialmente </font><font style="vertical-align: inherit;">Desafortunadamente, las funciones hash chocan y la memoria infinita no existe, por lo que en nuestra realidad tenemos que comprometernos. </font><font style="vertical-align: inherit;">Pero podemos calcular la probabilidad de colisiones y administrar este valor. </font><font style="vertical-align: inherit;">Por ejemplo, tenemos una buena funci√≥n hash y 128 GB de memoria. </font><font style="vertical-align: inherit;">Podemos calcular que la probabilidad de colisi√≥n para cada elemento nuevo es de 1 a 1099511627776. Cuando agrega m√°s elementos, la probabilidad aumenta a medida que se llena el mapa de bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, podemos aplicar m√°s de una funci√≥n hash y obtener un mapa de bits m√°s denso. </font><font style="vertical-align: inherit;">Aqu√≠ es donde el filtro Bloom funciona bien, que es un conjunto de datos matem√°ticos con cuatro variables:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - n√∫mero de elementos insertados (n√∫mero cardinal)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - memoria utilizada por el mapa de bits</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - el n√∫mero de funciones hash calculadas para cada entrada</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - probabilidad de coincidencia falsa positiva</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado el n√∫mero cardinal </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la probabilidad deseada de falsos positivos </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el filtro Bloom devuelve la memoria requerida </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el n√∫mero requerido de funciones hash </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Echa un vistazo a esta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente visualizaci√≥n de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">de</font></a><font style="vertical-align: inherit;"> c√≥mo los par√°metros se afectan entre s√≠.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guiado por la intuici√≥n, agregu√© la herramienta probabil√≠stica mmuniq-bloom a mi arsenal, que toma la entrada STDIN y devuelve solo l√≠neas √∫nicas en STDOUT. </font><font style="vertical-align: inherit;">¬°Deber√≠a ser mucho m√°s r√°pido que una combinaci√≥n de </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahi esta:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por simplicidad y velocidad, inicialmente establec√≠ algunos par√°metros. Primero, a menos que se indique lo contrario, mmuniq-bloom usa ocho funciones hash k = 8. Esto parece estar cerca del n√∫mero √≥ptimo para nuestro tama√±o de datos, y la funci√≥n hash puede producir r√°pidamente ocho hashes decentes. Luego alineamos la memoria </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el mapa de bits a la potencia de dos para evitar una operaci√≥n costosa </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que en ensamblador se reduce a lenta </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la matriz es igual a la potencia de dos, simplemente podemos usar AND bit a bit (por diversi√≥n, lea </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥mo los compiladores optimizan algunas operaciones de divisi√≥n al multiplicar por una constante m√°gica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora podemos ejecutarlo en el mismo archivo de datos que usamos antes:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Oh, eso es mucho mejor! 12 segundos en lugar de dos minutos. El programa utiliza una estructura de datos optimizada, una cantidad relativamente limitada de memoria, un an√°lisis de l√≠nea optimizado y un buen almacenamiento en b√∫fer de salida ... y con todo esto, 12 segundos parecen una eternidad en comparaci√≥n con la herramienta </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© est√° pasando? Entiendo que contar cadenas es </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s f√°cil que calcular cadenas √∫nicas, pero ¬øest√° realmente justificada la diferencia de 26 veces? ¬øQu√© toma la CPU </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe ser para calcular hashes. La utilidad </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no gasta el procesador, haciendo todos estos c√°lculos matem√°ticos extra√±os para cada una de las 40 millones de l√≠neas. Utilizo una funci√≥n hash bastante trivial </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seguro que quema el procesador, ¬øverdad? Verifiquemos ejecutando solo la funci√≥n hash, pero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no realizar operaciones con el filtro Bloom: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
esto es extra√±o. </font><font style="vertical-align: inherit;">El c√°lculo de la funci√≥n hash solo lleva unos dos segundos, aunque todo el programa en la ejecuci√≥n anterior se ejecut√≥ durante 12 segundos. </font><font style="vertical-align: inherit;">¬øUn filtro Bloom funciona durante 10 segundos? </font><font style="vertical-align: inherit;">¬øC√≥mo es esto posible? </font><font style="vertical-align: inherit;">Esta es una estructura de datos tan simple ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arma secreta - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es hora de aplicar la herramienta adecuada para esta tarea: ejecutemos el generador de perfiles y veamos en qu√© est√° trabajando el procesador. Primero, corramos </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para verificar que no haya llamadas inesperadas del sistema: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
todo se ve bien. Diez llamadas a </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms cada una (3971 Œºs) son interesantes, pero est√° bien. Precargamos la memoria con </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para luego evitar errores debido a la falta de una p√°gina. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øCu√°l es el pr√≥ximo paso? Por supuesto que lo es </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces veamos el resultado: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, realmente quemamos el 87.2% de los ciclos en el c√≥digo principal. Veamos d√≥nde exactamente. El equipo </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra inmediatamente algo inesperado. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que el 26.90% del procesador se quem√≥ en</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ¬°Pero eso no es todo! El compilador inserta correctamente la funci√≥n y expande el bucle. ¬°Resulta que la mayor√≠a de los ciclos van a esto </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o a la l√≠nea </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, el rendimiento es incorrecto, ¬øc√≥mo puede una cadena tan simple tomar tantos recursos? Pero repetir la prueba con cualquier otro perfilador muestra el mismo problema. Por ejemplo, me gusta usar google-perftools con kcachegrind debido a los coloridos diagramas: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado de la visualizaci√≥n es el siguiente: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perm√≠tanme resumir lo que hemos descubierto hasta ahora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La utilidad est√°ndar </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">procesa un archivo de 600 MiB durante 0,45 s de tiempo de procesador. Nuestra herramienta optimizada </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona 12 segundos. El procesador se graba en una instrucci√≥n </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, desreferenciando la memoria ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagen de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬°Oh! Como podr√≠a olvidarlo. ¬°El acceso aleatorio a la memoria es</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lento! ¬°Muy, muy, muy lento!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acuerdo con los</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√∫meros que todo programador debe saber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un solo acceso a la RAM toma alrededor de 100 ns. Vamos a contar: 40 millones de l√≠neas, 8 hashes cada una. Dado que nuestro filtro Bloom tiene un tama√±o de 128 MiB, en</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuestro hardware antiguo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no cabe en el cach√© L3. Los hashes se distribuyen uniformemente en una amplia gama de memoria: cada uno de ellos genera una p√©rdida de cach√©. Ponlo todo junto, y resulta ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que 32 segundos se queman solo en accesos de memoria. El programa real se ajusta en solo 12 segundos, porque el filtro Bloom todav√≠a se beneficia del almacenamiento en cach√©. Esto es f√°cil de ver con </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√≠, deber√≠amos haber tenido un m√≠nimo de 320 millones de errores de cach√© (LLC-load-miss), pero solo sucedieron 280 millones: esto todav√≠a no explica por qu√© el programa funcion√≥ en solo 12 segundos. Pero no importa. Es importante que el n√∫mero de errores de cach√© sea un problema real, y solo podemos resolverlo reduciendo el n√∫mero de accesos a la memoria. Intentemos configurar el filtro Bloom para usar solo una funci√≥n hash: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Ay! ¬°En verdad duele! Para obtener una probabilidad de colisi√≥n de 1 por 10,000 l√≠neas, el filtro Bloom requer√≠a 64 gigabytes de memoria. ¬°Es horrible!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, no parece que la velocidad haya aumentado significativamente. </font><font style="vertical-align: inherit;">Le tom√≥ 22 segundos al sistema operativo preparar la memoria para nosotros, pero a√∫n pasamos 11 segundos en el espacio del usuario. </font><font style="vertical-align: inherit;">Creo que ahora todas las ventajas de un acceso m√°s raro a la memoria se compensan con una menor probabilidad de ingresar a la memoria cach√© debido al gran aumento del tama√±o de la memoria. </font><font style="vertical-align: inherit;">Anteriormente, ¬°128 MiB eran suficientes para el filtro Bloom!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechazar los filtros de floraci√≥n</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se est√° volviendo rid√≠culo. </font><font style="vertical-align: inherit;">Para reducir la probabilidad de falsos positivos, debe usar muchos hash en el filtro Bloom (por ejemplo, ocho) con muchos accesos a la memoria, o dejar una funci√≥n hash, pero use grandes cantidades de memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad no tenemos un l√≠mite de memoria, queremos minimizar el n√∫mero de llamadas a √©l. </font><font style="vertical-align: inherit;">Necesitamos una estructura de datos que cueste un m√°ximo de una p√©rdida de cach√© por elemento y use menos de 64 gigabytes de RAM ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, puede implementar estructuras de datos complejas, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un filtro de cuco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero ciertamente hay una opci√≥n m√°s f√°cil. </font><font style="vertical-align: inherit;">¬øQu√© pasa con la buena y antigua tabla hash de sondeo lineal? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustraci√≥n de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conoce a mmuniq-hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° la nueva versi√≥n de mmuniq-bloom usando una tabla hash:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar de los bits para el filtro Bloom, ahora almacenamos hashes de 64 bits de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la funci√≥n 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto proporciona una protecci√≥n mucho mejor contra colisiones de hash: mucho mejor que una por cada 10.000 l√≠neas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contemos. </font><font style="vertical-align: inherit;">Agregar un nuevo elemento a una tabla hash, digamos con 40 millones de entradas, da la posibilidad de colisiones hash </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto es aproximadamente 1 en 461 mil millones, una probabilidad bastante baja. </font><font style="vertical-align: inherit;">¬°Pero no agregamos un elemento al conjunto precargado! </font><font style="vertical-align: inherit;">En cambio, agregamos 40 millones de filas al conjunto inicialmente vac√≠o. </font><font style="vertical-align: inherit;">Seg√∫n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la paradoja del cumplea√±os</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , esto aumenta enormemente la probabilidad de colisiones. </font><font style="vertical-align: inherit;">Una aproximaci√≥n razonable ser√≠a una estimaci√≥n </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en nuestro caso es</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Resulta una posibilidad de 23,000. En otras palabras, con una buena funci√≥n hash, esperamos una colisi√≥n en uno de los 23,000 conjuntos aleatorios de 40 millones de elementos. Esta es una probabilidad distinta de cero, pero a√∫n mejor que en el filtro Bloom, y es completamente tolerable para nuestro caso de uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo con una tabla hash funciona m√°s r√°pido, tiene mejores patrones de acceso a la memoria y menor probabilidad de falsos positivos que en el filtro Bloom.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No se alarme por la l√≠nea de "conflictos hash", solo muestra cu√°n llena est√° la tabla hash. </font><font style="vertical-align: inherit;">Usamos la detecci√≥n lineal, as√≠ que cuando entramos en el conjunto completo, simplemente tomamos el siguiente vac√≠o. </font><font style="vertical-align: inherit;">En nuestro caso, tenemos que omitir un promedio de 0.7 conjuntos para encontrar un lugar vac√≠o en la tabla. </font><font style="vertical-align: inherit;">Esto es normal. </font><font style="vertical-align: inherit;">Como iteramos sobre los conjuntos en un orden lineal, la memoria debe estar cualitativamente llena. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Del ejemplo anterior, sabemos que nuestra funci√≥n hash tarda unos dos segundos. </font><font style="vertical-align: inherit;">Llegamos a la conclusi√≥n de que 40 millones de accesos a la memoria tardan unos cuatro segundos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecciones aprendidas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los procesadores modernos son realmente buenos en el acceso secuencial a la memoria cuando es posible predecir patrones de muestreo (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">captaci√≥n previa de cach√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). El acceso aleatorio a la memoria, por otro lado, es muy costoso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las estructuras de datos avanzadas son muy interesantes, pero tenga cuidado. Las computadoras modernas requieren el uso de algoritmos optimizados para cach√©. Cuando se trabaja con grandes conjuntos de datos que no caben en L3, se prefiere la optimizaci√≥n sobre el n√∫mero de visitas, en lugar de la optimizaci√≥n sobre la cantidad de memoria utilizada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es justo decir que los filtros Bloom funcionan muy bien cuando se colocan en el cach√© L3. Pero si no, entonces son terribles. Esto no es noticia: los filtros Bloom est√°n optimizados para la cantidad de memoria, no para la cantidad de llamadas. Por ejemplo, ver</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art√≠culo cient√≠fico sobre filtros de cuco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra cosa son las discusiones interminables sobre las funciones hash. Honestamente, en la mayor√≠a de los casos esto no importa. El costo de contar incluso las funciones hash complejas parece ser </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peque√±o en comparaci√≥n con el costo del acceso aleatorio a la memoria. En nuestro caso, simplificar la funci√≥n hash traer√° solo un peque√±o beneficio. El tiempo de CPU se pierde en otro lugar, ¬°esperando memoria! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un colega a menudo dice: ‚ÄúSe puede suponer que los procesadores modernos son infinitamente r√°pidos. Trabajan a una velocidad infinita, hasta que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descansan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contra la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">pared de la memoria</font></a><font style="vertical-align: inherit;"> ". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, no repitas mi error. Siempre debe realizar primero la creaci√≥n de perfiles con</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y mire el contador de IPC (instrucciones por ciclo). </font><font style="vertical-align: inherit;">Si es menos de uno, esto generalmente significa que el programa est√° atascado esperando memoria. </font><font style="vertical-align: inherit;">Los valores √≥ptimos son superiores a dos. </font><font style="vertical-align: inherit;">Esto significa que la carga de trabajo est√° principalmente en la CPU. </font><font style="vertical-align: inherit;">Desafortunadamente, en mis tareas, el IPC sigue siendo bajo ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superior mmuniq</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la ayuda de colegas, escrib√≠ una versi√≥n mejorada de la herramienta mmuniq basada en una tabla hash. </font><font style="vertical-align: inherit;">Aqu√≠ est√° el c√≥digo:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede cambiar din√°micamente el tama√±o de la tabla hash, admite entradas con un n√∫mero cardinal arbitrario. </font><font style="vertical-align: inherit;">Luego procesa los datos en paquetes, utilizando efectivamente la sugerencia </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la CPU, que acelera el programa en un 35-40%. </font><font style="vertical-align: inherit;">Tenga cuidado, el uso abundante </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el c√≥digo rara vez da efecto. </font><font style="vertical-align: inherit;">Para usar esta funci√≥n, reorden√© especialmente los algoritmos. </font><font style="vertical-align: inherit;">Con todas las mejoras, el tiempo de ejecuci√≥n se redujo a 2.1 segundos:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el fin</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La creaci√≥n de una herramienta b√°sica que intenta superar a la combinaci√≥n 'sort / uniq' ha revelado algunas caracter√≠sticas ocultas de la inform√°tica moderna. </font><font style="vertical-align: inherit;">Despu√©s de sudar un poco, aceleramos el programa de m√°s de dos minutos a dos segundos. </font><font style="vertical-align: inherit;">Durante el desarrollo, aprendimos sobre el retraso en el acceso aleatorio a la memoria, as√≠ como el poder de las estructuras de datos compatibles con la cach√©. </font><font style="vertical-align: inherit;">Las estructuras de datos extra√±as llaman la atenci√≥n, pero en la pr√°ctica a menudo es m√°s eficiente reducir el n√∫mero de accesos aleatorios a la memoria.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491116/index.html">Est√°ndares de identificaci√≥n modernos: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../es491118/index.html">Developer Heart: Devkits de la 5ta generaci√≥n de consolas (Parte 1)</a></li>
<li><a href="../es491120/index.html">$ mol: 4 a√±os despu√©s</a></li>
<li><a href="../es491122/index.html">An√°lisis forense de copias de seguridad HiSuite</a></li>
<li><a href="../es491130/index.html">Caracter√≠sticas de Vue para recordar</a></li>
<li><a href="../es491134/index.html">5 etapas de inevitabilidad de la adopci√≥n de la certificaci√≥n ISO / IEC 27001. Negaci√≥n</a></li>
<li><a href="../es491136/index.html">Proyectar contenido en documentaci√≥n angular o perdida de contenido ng</a></li>
<li><a href="../es491138/index.html">Sat√©lite y torre de integraci√≥n Ansible</a></li>
<li><a href="../es491146/index.html">UML para desarrolladores</a></li>
<li><a href="../es491150/index.html">C√≥mo pirate√© a los estafadores, o solo el interior de los paneles de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>