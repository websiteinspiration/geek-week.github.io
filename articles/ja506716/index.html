<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩 ⏏️ 😚 マルチスレッド線形リスト：要素の存在問題、生産性の向上、およびSTL関係 🎸 🦆 🚞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、Habrの親愛なる訪問者！
 
 この記事では、リンクされたリスト、マルチスレッド、およびC ++に焦点を当てます。私はすぐに、この作品を棚に置いて、少数の個人的なプロジェクトで使用する機会があったことに注意します。代わりに、私はまだそれを公衆の法廷に置くことにしました-突然、それは誰か...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>マルチスレッド線形リスト：要素の存在問題、生産性の向上、およびSTL関係</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、Habrの親愛なる訪問者！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、リンクされたリスト、マルチスレッド、およびC ++に焦点を当てます。私はすぐに、この作品を棚に置いて、少数の個人的なプロジェクトで使用する機会があったことに注意します。代わりに、私はまだそれを公衆の法廷に置くことにしました-突然、それは誰かにとって本当に本当に便利または興味深いようです。また、誰かがすでにこのようなことを成し遂げていることが判明した場合は、これらの資料を私に教えてください。しかし、このトピックでどのようにグーグルしようとしても、すべての試みは失敗しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、これはクラシックリンクリストではなく、マルチスレッド環境でのこのデータ構造の使用についての私の創造的な再考についてであることにも注意します。無秩序で集中的なマルチスレッドリストアクセスのシナリオを検討していました。つまり、他のスレッドに関係なく、どのスレッドでもいつでもリストにアクセスして必要な操作を実行できます。要素を追加または変更するだけの場合、これはそれほど悪くはありません。要素も削除すると、さまざまな興味深い機能が発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が趣味と自己啓発として携わったこのプロジェクトは、さまざまな理由で非常に長続きしました。</font><font style="vertical-align: inherit;">さらに、私がそれに取り組んでいる間、私は集中的に研究しました。プロジェクトはSTLの知識と理解なしで始まり、C ++言語自体の内部手段のみを使用して、それに応じて設計されました。</font><font style="vertical-align: inherit;">しかし、それから私はSTLを考慮して、さらにはSTLの下でさえ、それを非常に真剣に変更しました。</font><font style="vertical-align: inherit;">読者の皆さん、私がこれから得たもの、あなたを判断してください。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで説明されている内容を最も完全に理解するには、次の本を読む必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A.-「C ++のモダンデザイン」。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リヒターD.、ナザールK.-「C / C ++を介したWindows、Visual C ++プログラミング」。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N.-「C ++標準ライブラリ。</font><font style="vertical-align: inherit;">リファレンスガイド。</font><font style="vertical-align: inherit;">第2版​​」またはSTLに関する同様の本。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラインリスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形リストは、C言語の時代以前から使用されてきたよく知られたデータ構造です。その要素は、1つまたは2つの隣接する同様の要素との接続を持つメモリ内の特定のオブジェクトです-以下は、二重リンクリストの例です。</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;…   …&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、リスト自体は、これらの要素を操作する特定の（サブ）プログラムです。</font><font style="vertical-align: inherit;">原則として、リストの最初と、必要に応じて最後へのポインタがわかっています。これは、最初の要素から始めて、そのすべての要素を最後まで通過するのに十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私はすでによく研究され、よく知られている情報について説明しています。それは完全に気づいていない人々のための教育プログラムでした。</font><font style="vertical-align: inherit;">詳細については、たとえば、こちらに連絡できます。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形リスト（Wikipedia）</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
STLライブラリには、すばらしいコンテナーstd ::リスト（二重リンクリスト）とそのツイン-std :: forward_list（単一リンクリスト）があります。</font><font style="vertical-align: inherit;">つまり、リストがどのように編成され、内部で機能するかに興味がなく、タスクにそれを使用したい場合は、提案されたコンテナーがオプションです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、一つだけあります...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッドの問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックを分析し始めたとき、私は繰り返します。STLサポートなしでC ++内部ツールのみに依存して、私はすべてを行うつもりでした。</font><font style="vertical-align: inherit;">ここでそれについて話すことに決めた場合、何が起こるかという価値は低くなります。</font><font style="vertical-align: inherit;">しかしその一方で、私はライブラリの概念や制限から完全に解放されていたので、何にも縛られず、心を開いて独立したアプローチを探しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、遠い昔に、コンピュータの大部分はシングルコアでシングルプロセッサでした。線形リストは比較的単純で透過的なデータ構造であり、それを操作しても特に問題は発生しませんでした。今ではスマートフォンでもマルチコアになっています。マルチスレッドの条件下では、リンクリストのような単純な構造でさえ、非常に複雑になります。マルチスレッドモードでの正しい操作を保証すると、一般にプログラムが非常に複雑になりますが、これは既知の事実です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなスレッドのリストを使用して、集中的な作業の抽象的なシナリオを考えてみましょう。各スレッドは、完全に任意の時点で要素などを追加、削除、変更することができます。一方で、この場合のリストでの作業は主に安全である必要があります。データ違反やプログラムの未定義の動作がある場合、これは完全に不適切なソリューションになります。一方で、できるだけ早く彼と一緒に仕事をしたいと思っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の問題を解決するには、リストを何らかの方法でブロックし、アクセスを同期する必要があります。 2番目の問題-パフォーマンス-は今のところ延期されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、ストリームへの排他的アクセスのために、ストリームによってリスト全体をブロックすることのみを考慮しています。他のオプションは、たとえば以下の理由により、疑わしいように思われました。二重にリンクされたリストがあり、そのリストからアイテムを削除することにしたとします。これを行うには、ノード自体だけでなく、前後のノードもブロックする必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、操作の開始前に、別のスレッドが前のノードなどを削除します。削除されたものをブロックし、別のスレッドによってブロックされた前のノードの解放を待つのをやめます。そして彼は彼のために次を待つためにブロックされています。削除されたノード。それだけです、それはデッドロックです。したがって、この方法は信頼できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドが特定のノードへのポインター（またはイテレーター）を格納しない場合、タスクは非常に単純化されます。実際、STLツールでしか実行できません。ストリームはリストをブロックし、その中の任意の要素を参照します（たとえば、最初から、最後から、またはいくつかの基準に従って検索することによって）、この要素を処理または削除し、それらへのリンクを保存せずに新しい要素を追加します、次にリストを完成させます。このすべて-1つのスレッド内のリストへのアクセスを排他的にブロックし、必要な操作の間リストを所有します。この場合、std ::リストとライブラリのロック機能を使用することは完全に論理的です。このすべてについて、スレッドが必要なすべての作業を実行している間、他のスレッドは待機を停止することに注意してください。リストの操作はシングルスレッドモードで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドが必要な要素へのポインターまたはイテレーターを格納するとき、私は別のより複雑なシナリオを検討しました。</font><font style="vertical-align: inherit;">たとえば、プログラムはいくつかの複雑な計算を処理し、リストアイテムから初期データを取得して、処理後にその値を更新し、そこに計算結果を追加します。</font><font style="vertical-align: inherit;">ただし、他のスレッドも同じリストにアクセスできます。</font><font style="vertical-align: inherit;">アプリケーションの性質については何も想定していません。別のスレッドが何らかの理由でこの要素を簡単に削除する可能性があります。</font><font style="vertical-align: inherit;">または、別の場所に移動します。</font><font style="vertical-align: inherit;">したがって、リストの操作は、マルチスレッド化と同期の通常の理由だけでなく問題になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素の存在の問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストと、たとえば配列の根本的な違いは何ですか？では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、分散</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト項目の配置。配列のすべての要素は、単一のメモリ領域に配置されます。一部の要素へのポインタを格納した場合でも、そのアドレスへのアクセスが正しいことは確かです（もちろん、配列がメモリ内で、そのサイズの拡張で別の場所に移動されなかった場合など）。必要な要素が削除されたか、別のスレッドに移動された場合は、前のアドレスに移動するだけで、必要な要素がここにないことをいくつかの兆候で理解できます。次に、それを検索してみます。もちろん、プログラムはそのような機会を事前にサポートする必要があります。ただし、いずれの場合も、適切なメモリ制限内にいる限り、その動作は正しいままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全に異なる状況は、リストの場合（およびツリー、グラフの場合-分散要素を持つ任意のデータ構造）です。ポインタに応じた要素が別のスレッドで削除された場合、そのことを知ることすらできず、そのアドレスにアクセスしようとすると、アクセス違反が発生します（せいぜい）。実際にメモリから削除されていなくても（たとえば、スマートポインタが使用されている場合）、リストから削除されます。それの一部ではありません。これについても知らないでしょう。リストでの正しい作業は壊れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、リストを使用した集中的なマルチスレッド処理により、素晴らしいシナリオが作成されます。要素とその要素へのポインタですべてが正常であることを確認することさえできます-それを扱うためにいくつかのリスト関数にアクセスするまで。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例。リストの一部があり、ノードへのポインター（ここでは（＃）と表記）がいくつかの関数リストメソッドに転送されますが、それに関連付けられたノードはそれに対する相対番号で示されます。関数が呼び出された時点で、この要素が存在し、その要素へのポインターが正しいことがわかります。つまり、この領域のリストの状態は次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノード（＃）をパラメーターとしていくつかのリスト関数に渡します。この機能は、通常どおり、アクセスを待機している間ブロックされます。彼女が待つ間、3つのスレッドが彼女の前に働き、ノード（＃）を隣接するスレッドと一緒に削除して、それが起こるようにしました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、別の5つのスレッドが（-2）で始まる5つの要素をリストに挿入しました。新しい要素を（nN）として表します。ここで、Nはゼロから始まる5つの要素間の相対数です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最後に（＃）で呼び出されたストリームが呼び出されます。問題は、結局（＃）がなくなってしまったので、この場合彼は何をすべきかということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回答：すべては、操作と、リストを使用するシナリオに依存します。ただし、制限のない最も一般的なケースを検討しているため、いくつかの一般的な仮定を行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが削除操作の場合は、指定されたアイテムがリストに存在するかどうかを確認するだけで十分です。そうでない場合は、すでに削除されているため、他に何もする必要はありません。はいの場合は、削除します。同様に、ノードのコンテンツの読み取り/変更操作の場合：ノードが削除された場合、すでに読み取り/変更するものはありません。ただし、最大の問題は、新しいノードを挿入する操作と、次のノードまたは前のノードに移動するときに発生します。一方で、指定されたノードはもう存在せず、障害が返される可能性があります。一方、ノードは挿入する必要があり、そのような状況はいつでも発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優先度（一般的な場合）は依然として安全性と信頼性であり、それからスピードだけなので、スレッドが最終的に関数内の動作時間を取得したときに、リストに要素が存在するという事実を確立する必要があることは明らかです。これにより、1つの問題が解決します。少なくとも、要求されたノードがそこにない場合にリスト全体を混乱させることはなく、メモリアクセスエラーを回避できます。しかし、それは挿入と遷移の問題を解決しません。新しいノードをどこに挿入し、すでに削除されたノードから移動するかは明確ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素の存在の問題の解決策については、以下で詳細に説明します。</font><font style="vertical-align: inherit;">要素がもう存在しないとわかったときにどうするかという問題は、本当に必要ですが、リストプログラムを使用する作業のアルゴリズムに完全に依存しているため、この記事の範囲を超えています。</font><font style="vertical-align: inherit;">もちろん、そのようなシナリオとそれに対応する対応を含める必要があります。たとえば、要素がない場合は、リストの先頭に移動するか、他の操作を実行します。</font><font style="vertical-align: inherit;">この状況で確認する必要がある主なことは、リストの正しい安全な操作と、そのような状況の通知です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接商品検索</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純で最も簡単な方法は、特定の要素を検索するために要素を順次通過させることにより、リスト内の要素の存在を確認することです。それら。与えられた要素を探すだけです。彼がリストにあれば、私たちは彼と協力します。そうでない場合は、関数に応じて、成功または失敗で終了し、この状況で何をするかを呼び出し側プログラムに決定させます。主なことは、どのような場合でもリストを使用した作業が正しいことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法は安全で完全に機能しますが、特に大きなリストの場合、パフォーマンスが壊滅的に低下します。実際、リストの操作はシングルスレッドであることがわかります。リスト内の特定の要素を検索している間、リストはブロックされ、他のスレッドはリストにアクセスできません。第二に、オーバーヘッドは急激に増加します- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストを使用した操作では、操作時に必要な要素があるかどうかを確認する必要があり、時間の大部分は、有用な作業ではなく、要素の存在の確認に費やされます。</font><font style="vertical-align: inherit;">それにもかかわらず、この単純で単純なアプローチは、要素の存在の問題を解決するための最初の近似と同様に、小容量のリストとそれによる過度の操作ではないリストに非常に適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、要素の数が多いリストがあり、それを扱う作業が非常に集中している場合はどうでしょう。多くのスレッドが常に要素を追加、変更、削除しているのでしょうか。</font><font style="vertical-align: inherit;">どういうわけかそれをスピードアップする方法はありますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリまたはパフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムが使用するメモリを増やすと、プログラムの速度が上がることはよく知られています。たとえば、プログラムは一部の計算結果を頻繁に使用します。それらをすべて最初から実行する代わりに、すべてを事前に計算し、その結果をテーブルまたは配列に保存できます。次に、プログラムはテーブル内の目的のセルにアクセスするだけで、目的の値をすぐに受け取り、作業を大幅に高速化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストの場合に使用したのはこのアプローチです。ビットマップを作成します。各要素のサービス情報に、次の要素への必要なポインターに加えて、オプションで前の要素、さらに2つの新しいフィールドを追加します。最初のフィールドはこのリスト内の一意の番号で、2番目はリスト自体へのポインターです。要素が作成されると、一意の番号が割り当てられ、ビットマップの対応するインデックスに単位が設定されます。要素が削除されると、このビットはリセットされます。作成された要素の数は、新しい要素が作成されるたびに絶えず増加しています-すでに使用されているゼロ化ビットは再利用されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、特定の要素の存在を確認する必要がある場合、リスト全体で線形に検索するのではなく、ビットマップは要素内のこの要素のインデックスによって単純にアクセスされ、その存在の事実は、リストのサイズに関係なく、一定の時間、即座に確立されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法では、最大のパフォーマンスを達成できますが、重大な欠点があります。まず、アレイ全体にメモリを一度に割り当てる必要があります。そのビットの一部はプログラム中にまったく必要ない場合がありますが、このメモリは他のニーズに使用できます。この問題とメモリオーバーランを解消する方法については、以下で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の欠点は、より深刻で興味深いものです。新しいリストアイテムは、単調に増加する数によって作成されます。つまり、遅かれ早かれ、配列の空きビットが使い果たされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、残念ながら、リストを停止してブロックし、サービスの提供を開始する必要があります。それら。この配列のビットを圧縮し、以前に削除された中間のリスト要素からすべてのゼロビットを削除し、現時点で実際に存在する要素のビットのみを残して、これらのすべてのビットを配列の先頭にシフトします。リスト全体をもう一度調べる必要があります。シングルスレッドモードでは、各要素のすべてのインデックスを書き換えます。前のアプローチと比較した場合の明らかな利点は、この場合は</font><b><font style="vertical-align: inherit;">1つ</font></b><font style="vertical-align: inherit;">しか実行されないことです。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期間にわたって。</font><font style="vertical-align: inherit;">さらに、このリストは非常に高速なモードでも以前と同様に機能し続けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ノードがリストに追加されただけではありません。</font><font style="vertical-align: inherit;">この場合、配列のすべてのビットはシングルになります。</font><font style="vertical-align: inherit;">アイテムが集中的かつ任意に削除および追加されるシナリオを検討しています。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">作業開始時からのリストアイテムの総数は、若干異なる場合があります。</font><font style="vertical-align: inherit;">当然、配列のサイズを選択する問題は、プログラムの性質によって異なります。</font><font style="vertical-align: inherit;">現在のボリュームのサイズが十分でない場合は、いつでもより大きなボリュームの新しいアレイを作成することもできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前に削除された要素からのゼロビットの使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは何か他のことができます：要素を作成するとき、ビットマップの最初から最初のゼロビットを探します。これによりメモリ消費が最適化されますが、パフォーマンスが低下します。新しい要素を作成するたびに、追加の作業を行う必要があります。空きビットを探して配列を調べます。しかし、リストを直接表示して要素の存在を確認する場合と比較すると、明らかな利点があります。</font><b><font style="vertical-align: inherit;">配列</font></b><font style="vertical-align: inherit;">を見てみましょう。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接する要素、およびそのような配列の各要素には多くのビットが含まれます。</font><font style="vertical-align: inherit;">一度に多くのリストノードを処理します（最新のシステムでは64ビット、SSE / AVXを使用している場合は128/256/512）。</font><font style="vertical-align: inherit;">すべての単位ビットを持つ単語と等しくない最初の単語を探し、次にこの単語の最初のゼロビットを探します。</font><font style="vertical-align: inherit;">実際、この方法は、前の方法と直視方法の中間の速度です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">占有されていない配列ビットのメモリ消費の最適化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストに大量のビット配列を割り当てて、リストを長時間集中的に処理するとします。しかし、そのため、実際にはプログラムの動作が異なりました。リストにアクセスすることはほとんどなく、メモリを必要とする他の操作を実行することはほとんどありませんでした。その結果、プログラムのその他の部分で、ボリュームとメモリの問題のほとんど使用されていないビットの配列が発生します。全く不便！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxは、私の知る限り、この問題を自動的に解決します（ただし、経験豊富なLinux開発者が修正できるようにしています）。アレイにメモリを割り当てますが、実際には、システム</font><font style="vertical-align: inherit;">は実際に必要になるまで</font><font style="vertical-align: inherit;">このメモリをアレイに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送しません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。メモリ使用量の最適化があります。 Windowsではこれを許可していません。むしろ、それは可能ですが、あなた自身でそれをしなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まったく最新でない人のために、私は説明します：アプリケーション（より正確には、それに対応するプロセス）は、システムが</font><font style="vertical-align: inherit;">大きな</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想アドレス空間を</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当て</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;"> -64ビットWindowsの場合、最大8 TB。システムの物理メモリははるかに少なくなる可能性があります-現時点では、大容量コンピュータの場合は8 GBまたは16 GBです。オペレーティングシステムの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスプレイ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想プロセス空間のアドレスを物理メモリアドレスに変換します。これは、直接関与せずに透過的な方法で行います。当然、プロセスの空き仮想メモリのほとんどは通常、占有されていません。したがって、従来の方法でメモリを割り当てるようにWindowsに要求すると、仮想スペースと物理メモリの両方に同時にこのメモリが割り当てられます。大きなボリュームのビットマップを割り当てると、このメモリがまったく必要になることを保証せずに、マシンで利用可能なすべてのメモリをすぐに占有するリスクがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、別の方法で動作することもできます。プロセスの仮想空間でメモリの大部分をマークアップしますが、実際に必要な場合にのみ、物理的に転送します。</font><font style="vertical-align: inherit;">これは、Windowsでの構造例外処理を通じて実行できます。詳細については、Richter D.、Nazar K.著の本を参照してください-「C / C ++を介したWindows、Visual C ++プログラミング」。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてのアイデアを実践せず、単純な実験プログラムの形式ではなかった場合、これはアイデアと理論にすぎません：私は実際のプロジェクトで使用するつもりで、制作のためにできる限り慎重にそれを実行しました。したがって、この形式で必要になります想像してみてください。</font><font style="vertical-align: inherit;">私の限られた数のプロジェクトで行われたことを、それが有用であるか、少なくとも開発者の幅広いサークルにとって興味深いものであるとしたら、それは不当で利己的すぎると思いました。</font><font style="vertical-align: inherit;">一方、Boostライブラリやその他のより専門的なライブラリの作成者は、誰にでも彼らの仕事を完全に無料で提供します。</font><font style="vertical-align: inherit;">同じことができないのはなぜですか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化-データのないリスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストを2つの論理レベルに分割しました。最初のレベルはリストであり、各要素には有用なデータは含まれていませんが、補助情報のみが含まれています。隣接する要素へのポインターと、オプションで、リスト内の要素の存在を迅速にチェックするための2つの追加フィールドがあります。ただし、すでにこのレベルでは、要素の追加と削除、リストの分割とマージなど、リストに対してすべての基本的な操作を実行できます。実際、私は主にこのレベルに焦点を合わせました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のレベルは、リストアイテムに実際のデータを追加することと、このデータを操作するためにリストに新しい操作を追加することです。これはすべて継承によってC ++で提供されます。ただし、詳細は以下で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装をこのように2つのレベルに分類することは理にかなっています。一連の操作全体がこれらのデータにまったく依存しない場合に、特定のデータの可用性を考慮する必要があるのはなぜですか。特定のリストアイテムについては、他の一般的な操作を実行するだけでなく、リストアイテムを削除してリストに追加する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の冒頭のC言語の構成から取った非常にシンプルで複雑でない概念から始め、CとC ++の両方の内部ポインターがリストの内部と外部の両方で使用されています。唯一の違いは、上記のようにデータの追加が後日延期されたことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接する要素へのポインタのみを含む、データのないリストの要素があるとします。次に、それに対応するコードは、次のように概略的に表すことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;…m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一リンクリストの要素には、次の要素へのポインタが含まれています。リストクラスは、この要素のタイプによってパラメーター化されます。つまり、このタイプは、データを追加する段階で変更されます。内部の最初と最後の要素へのポインタが含まれています。私はもともとこのプロジェクトをWindowsのみを対象としていたため、SRWLockなどの重要なセクションも含まれ、リストをブロックしています。次に、コンストラクタ、デストラクタ、およびリストを操作するために必要なすべての関数が定義されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装には、2つの問題が同時に含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つは、要素のサービス情報のコンテンツへのオープンアクセスです。これは、あるノードへのアクセスを得たこと、つまりこのノードへのポインタがあれば、次または前の要素を直接参照できます。</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、主にこの遷移がロックをバイパスしてリストを保護しているため、受け入れられません。実際に、いくつかのpCurr要素へのポインタがある場合、次のように、pNextポインタ内のそれに関連する次の要素に値を保存したとします。pNext= pCurr-&gt; pNext。その後、このpCurrノードで時間のかかる操作を実行します。同時に、他のスレッドはpCurrに関する次のリスト項目を削除しました。 pCurrの操作が完了すると、ローカルpNextアドレスにある要素が存在しなくなり、更新された値pCurr-&gt; pNextにアクセスする必要があるため、現在のスレッドはローカルpNextに保存されている古い値を使用して次の要素に移動し、アクセスエラーまたは未定義の動作を受け取ります。次に、現在のアイテムがpCurrにある場合、また存在します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を防ぐために、この例から2つの結論を導き出すことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストの外側から次/前のノードに移動し、通常、リストをロックしてリストへのアクセスを安全にするリストクラスの関数（メソッド）を通じてのみ、リスト要素を使用して作業を行います。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素にアクセスする直前にできるだけ早く要素にアクセスするには（たとえば、次の要素へのポインタを取得するにはpNext = list.GetNext（pCurr）を事前ではなく、次のノードに移動する必要がある直前に表示されます）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、最初の段落からの結論を実装するには、外部から隣接する要素へのポインターへのアクセスを禁止する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題はもう少しデリケートです。それを理解するには、クラスの構造をより詳細に説明する必要があります。リストクラスはテンプレートとして定義され、ListElement_OneLinkedタイプの要素では機能しませんが、テンプレートパラメーターとして渡されるListElementタイプでは機能します。これは、クラス内にデータを持つ新しいノードを作成できるようにするために行われます。これを行うには、作成されるノードの正確なタイプを知る必要があります。リストノードの正確なタイプはまだ不明です。後でデータとともに決定されます。要素作成関数はメモリを割り当て、ポインタを初期化してから、作成した要素へのポインタを呼び出し側の関数で返します。したがって、派生クラスの呼び出し関数では、このクラスに固有で後で定義される要素の他のプロパティを初期化することができます。言い換えると、リストノードのタイプの正確な定義は将来のために残されており、リストが正しく機能するためには、その要素にpNextポインタが含まれていることが重要であり、残りは今のところ問題ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ListElement_OneLinkedに基づいて、継承によって、特定のデータを持つ要素に対して新しいクラスが作成され、テンプレートパラメータを通じてList_OneLinkedクラスに渡されます。同時に、この新しいデータでの操作をさらに定義するList_OneLinkedに基づいて、新しい派生クラスが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このオプションでさえ完全に正しいわけではありません。以前のバージョンのリストクラスでは、reinterpret_cast &lt;ListElement *&gt;（...）型の明示的な変換操作が複数回使用されていました。テンプレートクラスは、ListElement_OneLinked / ListElement_TwoLinkedから派生したListElementテンプレートパラメータタイプで動作するというのが事実です。クラス関数では、変数は次のタイプの式で作成されます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、pCurr-&gt; pNextは、基本クラスのメンバーとしてのListElement_OneLinked / ListElement_TwoLinkedへのポインターです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力：明示的な基本型ListElement_OneLinked / ListElement_TwoLinkedを示す変数を宣言するか、それを派生型に明示的にキャストします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、たとえば、リストの削除（クリーニング）関数では、基本タイプの明示的な定義でさえ正しくありません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインターのタイプを変更する場合：</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、それらが操作によって削除されることを意味します</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト内の各ノードの基本部分のみですが、これは誤りです。</font><font style="vertical-align: inherit;">または、オプションとして、pCurrポインターをその派生型に変換する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、どのような場合でも、そのようなクラス構造を使用した明示的なreinterpret_cast変換を取り除くことはできません。これは、最善の解決策ではありません（正確には、これは本当に悪いことです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、このような明示的な変換を取り除くために、要素の基本クラスを変更することが決定されました（二重にリンクされたリストの場合も同様）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言えば、これは次のように説明できます。リストの基本要素には別の要素へのポインタが含まれていますが、このポインタの型はテンプレートパラメータによって渡されるため、まだ不明です（この型の正確な定義は将来のために残されます）。言い換えると、この段階では、リストノードのタイプ（つまり、最終的にどのようなものになるか）はまだ決定されておらず、後で決定されます。しかし今は、まだ知られていないタイプの未来の要素へのポインタを保持しています。リストノードの結果の型は、テンプレートパラメーターとしてここに渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストクラスとノードのクラスの両方で、同じListElementタイプのポインターがどこでも使用されるため、変換は必要ありません。こことリストクラスのListElementは、特定のデータを持つアイテムの最終クラスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、リストクラスはその特定の内容から可能な限り抽象化されています。そのノードに他のそのようなノードへのポインターが含まれていることがわかっているだけであり、この情報を使用して、対応するマルチスレッドロックを持つノードに対するすべての基本操作がリストクラスで実行されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素の存在の問題を解決する-単純な検索（バージョン01.03.2018）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のバージョンは非常にシンプルでわかりやすく、上記のフレームワークを超えていませんでした。</font><font style="vertical-align: inherit;">C ++内部ポインタが使用され、要素のメモリは新しい操作を使用して割り当てられ、削除を使用して削除されました。リストはそれに含まれるクリティカルセクションでブロックされました </font><font style="vertical-align: inherit;">私はSTLライブラリの手段について、またそれらがC ++でプログラミングをもたらすレベルについても知りませんでしたし、疑っていませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにこの段階で、実際には、前に説明した要素の存在の問題に遭遇し、リストをロックするだけでは十分ではないことに気付きました。</font><font style="vertical-align: inherit;">すべての予防措置を講じて、適切な機能を使用してリストをナビゲートしました。リストは正しくブロックされましたが、プログラムはさまざまな間隔で正常にクラッシュしました。</font><font style="vertical-align: inherit;">そのとき、要素の存在を確認する必要があり、主要な機能のロジックが変化することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の要素の後に要素を追加する機能の例を挙げましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい要素を作成する前に、FindElement（...）関数を呼び出して、指定された要素がリストに存在するかどうかを確認します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッドリストクラスのさらなる複雑化-戦略クラス（バージョン18.02.2019、11.27.2019）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、このプロジェクトは厳密にWindowsを対象としていました。しかし、ある時点で、柔軟性を追加してみませんか？なぜ窓だけなのか？結局のところ、このリストは基本的に純粋なC ++で実装されたものであり、WindowsにはSRWLockの重要なセクションという1つしかありませんでした。その時までに、私はすでに戦略クラスの概念に精通していました。これについて詳しくは、本のAlexandrescu A.-"C ++のモダンデザイン"を参照してください。本はすでに12年前であるという事実にもかかわらず、それは今でも役立つことができる多くの異常で驚くべきことを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの1つは戦略のクラスです。 B. Straustrupが著書で述べたように、実際、戦略のクラスはテンプレートによるクラスの動作の変化です。 Alexandrescuの本でのみ、このトピックは広く開示されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスが1つの特定のアクションを実行するとします。</font><font style="vertical-align: inherit;">このアクションの定義をクラスの外で取り、このアクションに基づいて別のクラスを作成し、それをテンプレートパラメーターとしてソースクラスに渡すことができます。</font><font style="vertical-align: inherit;">これにより、コードとその読み取りと理解が複雑になりますが、クラスに柔軟性が大幅に追加されます。この特定のアクションを他の類似のアクションで置き換えるには、別の類似の戦略を記述して、それをテンプレートパラメーターとしてクラスに渡すだけです。</font><font style="vertical-align: inherit;">残りの作業はコンパイラーが行います。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロック戦略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを説明されたリストに適用して、SRWLockを介してロックを別の戦略に取り入れ、他のいくつかの戦略を書きました：Windowsの通常の重要なセクションを介して、C ++ STLミューテックスを介してなど。</font><font style="vertical-align: inherit;">次に、純粋にLinux固有のメソッドを追加することができます。</font><font style="vertical-align: inherit;">したがって、このクラスはWindowsだけでなく、必要な戦略を指定するだけで、最適な方法でいつでもWindows用に再構成できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ戦略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この頃、私は真剣にSTLを研究し始め、このライブラリーの最初のツールの中で、私はスマートポインターについて知りました。</font><font style="vertical-align: inherit;">そして、私は考えました：なぜリストにスマートポインターサポートを追加できないのですか？</font><font style="vertical-align: inherit;">次に、ポインターのタイプを取り出し、別の戦略でリストアイテムのデータを作成および削除しました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートポインターの同様の戦略：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ戦略は3つのパラメータを取ります。Typeオブジェクトのタイプ、メモリアロケータおよびリムーバです。オブジェクトのタイプに基づいて、戦略はこのタイプへのポインタのタイプを作成します-戦略に応じてType *またはstd :: shared_ptrのいずれかであり、オブジェクトを作成および削除するための対応する関数も提供します。これらの関数は、デフォルトでディストリビューターと削除者について話す場合、新しいType操作またはstd :: make_shared（...）関数のいずれかを介してオブジェクトを作成します。これはすべて、C ++組み込みポインターとスマートstd :: shared_ptrの両方でポインター逆参照が同じであるためです。もちろん、二重リンクリストとスマートポインターの場合、ループポインターの不快な機能を回避するために、std :: weak_ptrが前の要素へのポインターに使用されます。二重にリンクされたリストのコンパイル時に、選択したメモリ戦略に応じて、それを逆参照する方法を選択します（これはC ++ 17の新機能です）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、リストは独自の要素を作成しません。対応する戦略に呼び出しをリダイレクトします。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテムの在庫戦略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、別の戦略で要素が存在するという問題を解決しました。リストが要素の存在を確認する必要がある場合は、対応する戦略に呼び出しをリダイレクトするだけです。最初の、単純で不器用なアプローチは、DirectSearchダイレクトサーチ戦略になりました。次に、前に説明した2つのアプローチに基づいて、ビットマップを説明順に並べた2つの戦略、SearchByIndex_BitArrayとSearchByIndex_BitArray2を開発しました。 Windowsの場合、ビットマップがいっぱいになるとメモリを徐々に占有する可能性があるため、さらに2つの戦略を追加しました：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocalとSearchByIndex_BitArray2_MemoryOnRequestLocalです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、これらの高度な戦略を機能させるには、リストアイテムにビットマップ内のインデックスとリストの基本クラスへのポインター（以下を参照）が含まれている必要があります。</font><font style="vertical-align: inherit;">次のように定義されました：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリー戦略と要素チェック戦略の間の相関</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細な調査の結果、記憶戦略と要素の存在を確認する戦略との関係に落とし穴があることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートポインターをメモリ戦略として使用し、ビットマップを使用してリスト内のアイテムをすばやく確認する戦略を想定します。アイテムを削除すると、メモリ戦略によってそのポインタがリセットされます。ただし、呼び出し元のプログラムでこの要素への別のスマートポインターを使用しているため、この要素は実際にはメモリから削除されません。将来的には、この要素を含むリストを参照すると、そのデータ（ビットマップ内のインデックスとリストへのポインター）を参照して、チェックが正しく行われます。要素が実際にメモリから削除されるのは、要素へのリンクがなくなった場合のみです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、C ++組み込みポインターを使用する場合には当てはまりません。この場合、メモリ戦略</font><font style="vertical-align: inherit;">は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除操作を使用してこのアイテムをメモリから削除します。将来、前の場合と同様に、この要素を含むリストを参照する</font><font style="vertical-align: inherit;">と、ビットマップのインデックスとリストへのポインターを読み取るために、このアドレスの要素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にアクセス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しようと</font><b><font style="vertical-align: inherit;">します</font></b><font style="vertical-align: inherit;">。ただし、これはできません。要素はすでにメモリから削除されています！最良のケースでは、C ++ライブラリ、ランタイムライブラリ、またはオペレーティングシステムだけがそこに考慮した完全に任意の値を書き込み、リストから要素が存在するという事実を確立しようとすると、最悪の未定義の動作でアクセス違反が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、内部ポインターはDirectSearchダイレクトチェック戦略とのみ互換性があることがわかり、この場合のスマートポインターは、固有のセキュリティだけでなくパフォーマンスも向上させます。ビット配列を使用することでのみ、リストの作業を大幅に増やすことができます。マルチスレッドモード！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性を確保し、互換性のない戦略構成を排除するために、各リストクラスに次のチェックを含めました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストに渡された戦略クラスを比較し、それらに互換性がない場合は、対応するエラーメッセージ出力でコンパイルを停止します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外またはエラーの戻り</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、リストのエラー処理は例外を介してのみ実行されていました。</font><font style="vertical-align: inherit;">しかし、どういうわけか、覚えていないフォーラムで、例外によってプログラムの速度が低下することを読みました。最大のパフォーマンスを得るには、従来のエラーリターンを使用する必要があります。</font><font style="vertical-align: inherit;">彼は、元のクラスに基づいて2つの新しいクラスを作成し、エラーを返すようにそれらを書き換えるだけでそうしました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本クラスのリスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素の存在をチェックするための上記の戦略の実装は、1つの重要な問題を明らかにしました。覚えているように、リスト要素には、このリストで一意の番号に加えて、このリストへのポインターも含まれています。結局のところ、プログラムには2つ以上のリストを含めることができ、各リストには、要素の存在を示すフラグの独自のビット配列が含まれています。この要素がこの特定のリストに属していて、別のリストに属していないことを確認するにはどうすればよいですか？各要素内のリスト全体へのポインタを格納することによってのみ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、リストクラスにさまざまな戦略を追加することで、その</font><b><font style="vertical-align: inherit;">タイプ</font></b><font style="vertical-align: inherit;">を大幅に複雑にしたこと</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同じタイプの要素と同じメモリ戦略を持つ2つの異なるリストがあり、それらの要素の存在をロックおよびチェックするための異なる戦略があるとします。コンパイラーの場合、これらは2つの異なる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストになります。要素に格納するタイプへのポインター？さらに、要素のクラスは、どの戦略が適用されるかを事前に認識していないため、それら</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考慮する必要が</font><b><font style="vertical-align: inherit;">あり</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロッキング戦略、要素の存在を確認するための戦略、およびリストの接続性（単純に接続されているか、または二重に接続されている）も、リスト自体の動作のみを参照しますが、</font><b><font style="vertical-align: inherit;">格納</font></b><font style="vertical-align: inherit;">する</font><b><font style="vertical-align: inherit;">データ</font></b><font style="vertical-align: inherit;">とは関係がないことも思い出してください</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、このクラスのエンドユーザーである私たちはデータに興味を持っています！</font><font style="vertical-align: inherit;">したがって、一方では戦略のクラスを使用して、柔軟性を追加し、他方では、私たちの生活を複雑にし、問題を追加しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どういうわけかオオカミをいっぱいにして羊を安全にすることは可能ですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
できる。</font><font style="vertical-align: inherit;">リストのクラスから（つまり、型から）データへのポインタを推測できます。</font><font style="vertical-align: inherit;">上記のリストの2つのレベルの編成に加えて、もう1つ-ゼロが表示されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、</font><font style="vertical-align: inherit;">リストの実際のクラスはそこから継承されます。実際のタイプに関係なくリストデータにアクセスする場合は、その基本クラスListBaseを参照する必要があります。</font><font style="vertical-align: inherit;">リストの最初と最後にアクセスし、必要に応じてそのデータを操作します。</font><font style="vertical-align: inherit;">リストの特定のタイプ、およびリストで使用される戦略の組み合わせは重要ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イテレータ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に実際のプロジェクト（私のものではありません）でSTLと緊密に連携しており、本でも研究を続けているため、コレクションのforループに注目しました。</font><font style="vertical-align: inherit;">結局のところ、このサイクルはSTLの一部ではなく、すでに言語の内部になっています。</font><font style="vertical-align: inherit;">私のプロジェクトにもサポートを追加できると思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、イテレータのサポートを追加し、ポインタを操作する特定の方法から抽象化し、リストをナビゲートする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イテレータの例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今では次のように書くことが可能になりました：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(…)<font></font>
{<font></font>
      …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValueには、リスト項目へのポインター型があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、例外がサポートされているリストにのみイテレーターのサポートを含めました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その理由は単純でした。ループ内のコードが利用できないため、エラーを正しく処理することができません。</font><font style="vertical-align: inherit;">あとは、ループをtryブロックでラップして例外を処理するだけです。</font><font style="vertical-align: inherit;">一般に、他のスレッドがリストを集中的に処理しているときにリストをこのように歩くのは良い考えではありません。リストを自分でブロックし、シングルスレッドモードで落ち着いて通過することをお勧めします。</font><font style="vertical-align: inherit;">しかし、それでも、何らかの理由で上記の例とまったく同じようにしたい場合は、この機会があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のコンテナに要素が存在するかどうかをチェックする戦略の一般化。</font><font style="vertical-align: inherit;">例外のないリストのイテレータ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私は当初、マルチスレッドリストだけでなくツリーも作成することを計画していました（今でも計画しています）。彼らのニーズのいくつかのために。グラフも可能ですが、第1に、グラフは必要ありませんでした。第2に、グラフは非常に重要なアルゴリズムを使用する複雑なものであり、特別な必要なしにグラフに飛び込みたくありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期バージョンでは、要素の存在を確認する方法はリストのみを対象としており、その関数は要素へのポインターとリストの基本クラスへのポインター（ListBase *）を受け入れていました。その後、私は考えました：しかし、木の場合、あなたはまったく同じことをしなければなりません！別の、しかし本質的にはまったく同じ戦略を実行しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は簡単でした。リストを無視してください。</font><font style="vertical-align: inherit;">つまり、要素へのポインタではなく、イテレータによって入力が受信されるようになりました。</font><font style="vertical-align: inherit;">そして、関数は、任意の適切なタイプのコンテナーへのポインターを受け入れるためのボイラープレートになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、元の関数、たとえばビットマップにリストを登録する</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナ登録機能に変わりました：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインタによるリストを介した遷移は、イテレータを使用して抽象コンテナを介した遷移に変換されました。</font><font style="vertical-align: inherit;">これで、ツリーでイテレータを実装するだけで十分になり、これらの戦略によるツリーのサポートはすでに提供されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには、イテレータを例外なくリストに戻す必要がありましたが、外部からアクセスできず、内部での使用のみを目的としていました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データアダプター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STLをかなり集中的に使用し、本からトレーニングプログラムを入力、起動、および学習してきたので、STLコンテナの操作の単純さに注目しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のコードに注意してください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なタイプのintを渡してベクターを作成しました。これで完了です。デフォルトで設定されているいくつかの追加パラメーターを変更する必要がない場合、コンテナーはすぐに動作する準備ができていますが、これはほとんどの場合起こりません！私にとっては、リストの3レベルの構成から始めて、いずれの場合も、最初に要素の新しいクラスを作成し、次にデータを含むリストのクラスを記述して、最終的なリストに固有の操作を実装する必要があります。どれだけの作業を想像してみてください！また、他のデータ用に別のリストを作成する必要がある場合は、最初からやり直すか、極端な場合は前のコードをコピーして、少し変更する必要があります。これは、C言語とWindows APIの同じ大騒ぎにすでに似ています。基本的なアクションごとに、構造に必要なすべてのデータを入力してから、目的の関数を呼び出す必要があります。そして、それをすべて心に留めておいてくださいまたは、MSDNを常に読んで、各新しい関数の引数を調べてください！日常的でひどく不快！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は、毎回同じ面倒を行う必要がないように、STLコンテナーとの類推によってリストを作成する機会を得る方法を探し始めました：新しい項目に対して個別のクラスを作成し、次にこの要素を操作するための個別のリストクラスを作成しますタイプ。</font><font style="vertical-align: inherit;">したがって、データデータを含むリスト用のアダプターがありました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを含むリストのアダプタはクラスであり、テンプレートパラメータで</font><font style="vertical-align: inherit;">は、要素ではなく</font><font style="vertical-align: inherit;">必要な</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型をすぐに渡します</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に作成したこのデータに基づいて、要素の複合型と呼んだ要素の型</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言及する価値のある別のポイントは、アイテムのデータへのアクセスです。</font><font style="vertical-align: inherit;">要素タイプには操作「*」が含まれています。</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、pElement要素へのポインターがある場合、そこに格納されているデータにアクセスするには、2回逆参照する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1回-ポインターによってListElementCompound_OneLinkedタイプのオブジェクトにアクセスするには：ListElementCompound_OneLinked＆le = * pCurrElement、2回目-操作 '*'を介してデータにアクセスするには：ElementData＆li = * le。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
見た目は非常に奇妙で異例ですが、ポインタ（これはすでに既製の初期バージョンが用意されている）ではなく、イテレータを使用することを前提としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アダプターに基づいてリストを作成するときに、以前と同様に、必要な戦略を指定します。</font><font style="vertical-align: inherit;">すべてのパラメーターに基づいて、アダプターは自動的に必要なタイプを作成し、それらを継承する基本内部リストに渡します。</font><font style="vertical-align: inherit;">一般的なクラス定義：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外を含むリストの特殊化：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは非常にかさばって、多階建てで醜いです。知っている。しかし、この定義は、それを使用することを計画しているプログラマーの直接参加なしに、必要なすべてを自動的に行います。 std :: conditional_tおよびstd :: is_same_vの助けを借りて、送信した要素の存在を確認する戦略が直接検索戦略と比較され、結果に応じて、リスト要素の対応するタイプが選択されます：ビットマップ内のインデックスとリストへのポインターまたはなし。これにより、直接検索戦略を使用する場合、各ノード内の不要な追加データによりメモリが節約されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス内では、固有のイテレーターだけが実装されているほか、STLとの類推で必要なpush_back（）/ push_front（）関数も実装されています。この関数は、呼び出しをベースのマルチスレッドリストにリダイレクトします。</font><font style="vertical-align: inherit;">後で他の関数を追加できるため、リストはSTLと非常によく似たものになります。</font><font style="vertical-align: inherit;">しかし、同時に、マルチスレッド環境で生産性を向上させるために必要なすべての保護とオプションが提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データアダプターの操作は次のようになりました。</font><font style="vertical-align: inherit;">リストオブジェクトの作成：</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのデフォルトの戦略とパラメーターに満足している場合、リストの作成は非常に簡単になります。</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、外見上は、リストクラスの名前が異なることを除いて、STLと比較してまったく違いはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、基本クラスの関数を使用して、これまでと同じように操作できます。</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、0から3までの数字がリストの最後に順番に追加されます。作成された型のコンストラクターに渡された引数を、それが作成されたときに取得するには、最初の3つの引数の値を明示的に下に置く必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、型を明示的に示すことには特定の不便がありますが、これは、ポインタを操作するための以前の関数を介してリストに再度アクセスしようとした結果です。</font><font style="vertical-align: inherit;">イテレータを返すアダプタにback（）関数を追加した場合、それを介して作業してもそのような問題は発生しません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イテレーターをSTLの要件に調整した後：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリアルゴリズムでリストを使用することが可能になります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
…<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、例外のインターセプトと処理を整理する必要があります。上記の例はすべて、STLとの互換性をテストするために1つのスレッドで作業するためのものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STLアルゴリズムを使用すると、興味深い点が可能になります。一度に複数のアルゴリズムを使用して、複数のスレッドで並列に実行できます。これは、リストクラスの内部コンテンツにアクセスすることなく、従来の方法（たとえば、std ::リストとブロッキング手段を使用）で行うことはできません。アルゴリズム全体の間、リスト全体をブロックすることのみが可能でした。もちろん、これにより、アルゴリズムを実行するスレッドの処理が高速化されますが、他のスレッドからリストにアクセスできなくなります。ただし、同じ「シン」SRWLockロックを適用すると、このリストを変更しない限り、リストで複数のアルゴリズムを同時に実行できます。しかし、最初に書き込むスレッドは、他のすべてのスレッドによるリストの読み取り操作が完了するのを待って立ち上がります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案されたリストオプションを使用すると、作業をより柔軟に整理できます。</font><font style="vertical-align: inherit;">たとえば、リストを使用して作業を整理すると、リストの前半の非変更アルゴリズムが複数のスレッドによって同時に実行され、他の多くのスレッドがリストの後半で何かを追加または変更できます。</font><font style="vertical-align: inherit;">アルゴリズム全体ではなく、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">中にリストがブロックされるという事実により、リスト</font><font style="vertical-align: inherit;">の読み取り操作のシーケンスを通じて書き込み操作の「書き込み」が可能になり、リストの操作がより柔軟で生産的かつ効率的になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外サポートがある場合とない場合のリストクラスの2つのバリアントをブールパラメータを持つ1つに組み合わせる</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、リストは例外を除いてありませんでした。</font><font style="vertical-align: inherit;">次に、新しいものを追加しました-エラーが返されても例外はありませんでした。また、クラス名に文字「E」を追加して古いものの名前を変更しました：List_OneLinked_EおよびList_TwoLinked_E。</font><font style="vertical-align: inherit;">これは、どこでもリストクラスの4つの宣言を示す必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから私はそれが多くの理由で不便であると決めました。</font><font style="vertical-align: inherit;">例外サポートの有無にかかわらず、これが同じリストである場合、なぜ2つの完全に異なるクラスが必要なのですか？</font><font style="vertical-align: inherit;">各タイプの両方のリストを追加のブールパラメータを持つ単一のクラスに結合しました。例外のある場合とない場合の特定の実装は、指定されたブールパラメータの単一クラスの2つの特殊化です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートリストのマージ操作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストを組み合わせるテンプレート操作は、以前は同じタイプのリストでのみ機能していました。単一接続リストのみ、または二重接続リストのみを組み合わせたものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、考えれば、操作に関係するリストの種類は関係ありません。単に接続されているか、二重接続されているかです。それらのブロック戦略も重要ではありません。要素の存在をチェックするための戦略は何であり、例外処理をサポートしているかどうかです。これはすべて、リストの編成にのみ適用され、リストに含まれるデータには適用されません。要素のデータ型とメモリ戦略のみが一致することが重要です。したがって、現在、例外に関するブールパラメーターとリストを組み合わせた後、入力操作は、パラメーターのすべてのバリアントを含む任意のタイプのリストを受け入れます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、リストタイプの結果として、コンパイラーは、外部パラメーターce_bGetMinLinksListの設定に応じて、最小または最大の接続性を持つリストを選択し、このソリューションに応じて、対応するパラメーターが使用されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択したパラメーターに基づいて、結果リストが作成されます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このリストで、ポインタは最初のリストの最初と2番目のリストの最後に設定されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、前のリストがクリアされ、関数が終了します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数の弱点は、潜在的なデッドロックを伴うリストの二重ロックです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: lock（mutex1、mutex2）のような単一のアトミック操作で2つのリストを同時にロックする関数を導入できますが、すべてのロック戦略がstd :: lock（...）のような2つの同期オブジェクトの同時ロックをサポートしているわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、2つのリストには異なるロック戦略がある場合があります。</font><font style="vertical-align: inherit;">この問題の解決策（存在する場合）は、将来に渡ります。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linuxコンパイル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux Ubuntu 16.04 LTS、g ++ 8.2.0コンパイラで、元々Windows固有の機能を持たない純粋なC ++で記述されたListDataAdapterTestプロジェクトを通じてコン​​パイルがチェックされました。マイナーなニュアンスのほとんどは修正が簡単で、プロジェクトは正常にコンパイルされ、プログラムの出力はWindowsでの同じ出力と一致しました。ただし、これは、「+」という操作でリストを結合する行をコメント化する場合です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのままにしておくと、リストの複合要素のクラスで特権が宣言されていないかのように、上記の「+」演算でコンパイルエラーが発生します。同様のエラーは、DirectSearch要素の存在を直接チェックする方法でも発生します。 Visual C ++ではすべてがここで問題ありませんが、複合要素クラスとリストクラスで、特権とリストとDirectSearchを組み合わせる操作を宣言するコメントがコメント化されている場合、これらの同じエラーが表示されます。 g ++はこれらの宣言を単にスキップし、対応するクラスのプライベート/保護されたメンバーについて文句を言うようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（g ++バージョン9（Ubuntu 20.04）では、同じエラーが発生します。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特権のアナウンスがスキップされる理由と修正方法については、理解できませんでした。</font><font style="vertical-align: inherit;">私はGCCコンパイラーの機能が苦手です。</font><font style="vertical-align: inherit;">この瞬間も未来に残しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このニュアンスを除いて、他に重大なコンパイルエラーはありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダーファイル構造の説明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者の皆様、私はGitHubのLGPL 3.0ライセンスに基づく本格的なプロジェクトを</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に公開しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、いくつかのテストプロジェクトで構成される1つのソリューションです。</font><font style="vertical-align: inherit;">マルチスレッドリストのメインコードは、テンプレートを介して実装されているため、いくつかのヘッダーファイルにあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.hは、データなしのリストの基本クラスであり、特定のデータや同様のデータ用のSTLアダプターを定義せずに可能な、リストを使用したすべての基本操作を実装します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h-例外サポート付きのリストのバージョン。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h-リスト項目の基本クラスの定義。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h-例外のコードとエラークラスの定義。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストされているメインファイルに加えて、以下も実装されています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h-メモリを操作するための戦略。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h-ブロック戦略。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h-リスト内の要素の存在を確認するための戦略。イテレータを備えたコンテナについて抽象的に説明されています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的なプロジェクトに加えて、「Old versions」フォルダに3つの古いバージョンを追加しました。これにより、プロジェクトの開発に伴う変化を簡単に評価できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト中</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストと呼ばれるメインプロジェクトは、Windows用のインターフェイスを備えたプログラムであり、Windows APIを介してハードコア実装されています（他に方法はわかりません）。このプログラムでは、リストのタイプ（単純接続または二重接続）を選択し、要素の初期数と必要なスレッド数も指定します。リスト項目には、単一の64ビット値が含まれています。リストを作成した後、ループ内の各スレッドのプログラムは、リストを順方向または逆方向にランダムな数の要素にジャンプし、要素を追加または削除します。このリストでは実際に役立つ作業は行われず、すべてのエネルギーが大気の加熱に費やされますが、これは必須ではありません。集中的なマルチスレッド環境でリストの操作性とパフォーマンスを評価するだけで済みます。パフォーマンスの測定は、すべてのスレッドによって実行された上記のサイクルの1秒あたりの反復回数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストは、プログラムコードで適切な戦略を示し、再コンパイルすることによって設定されます。メインプログラムのすべての戦略はメインモジュールListMain.cppで指定され、メモリ戦略はListDataExample.hで選択されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に言って、私は少し実験を行いました。私は正直に認めます。主な理由は、いくつかのケースでアイテムのリストが大幅に変更されるためです。実験の純度がパフォーマンスを測定するためには、平均して要素の数が研究期間にわたって変化しないか、または非常にわずかに変化しないような方法でテストを行う必要があります。そのような条件下でのみ、平均値に基づいて生産性の価値を評価することは公正でしょう。もし誰かが興味を持っているなら、私はそのような実験を自分で組織することを提案します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の理由により、テストの初期構成を修正しませんでした。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず第一に、私はただ怠惰でした。</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、私の意見では、パフォーマンスの正確な定量値に誰も興味がありません</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算されたエラーがある場合</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：リストのパフォーマンスとパフォーマンスを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質の高い方法</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で評価することが重要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">次に、これにより、ボリュームの増加に伴うリストのパフォーマンスの変化を評価できます。これも非常に重要で興味深い情報です。</font><font style="vertical-align: inherit;">これらの理由から、元の実験は変更しませんでした。</font><font style="vertical-align: inherit;">3番目に、リストのすべてのバリアントに対して同じテストコードが実行されます。つまり、この意味でそれらは同じ条件に置かれます。この場合、動作が異なるという事実により、変更の品質を判断できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスメータリングを有効にするには、ListMain.cppモジュールのce_bPerformanceMeasureフラグをtrueに設定します。</font><font style="vertical-align: inherit;">プログラムは、「要素数-サイクル数/秒」のペアを「：」記号で区切ったファイル「PerformanceMeasure.txt」を作成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス測定結果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、リストのすべての可能な構成についてテストを実施したわけではありません。それらの構成がたくさんあるからです。</font><font style="vertical-align: inherit;">私は重要なものだけに焦点を当てました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストは、すでに古くなっているがまだ非常に元気のない構成のIntel Core i7-3930K、DDR3-1333、4チャネルメモリコントローラーの注文で実行されました。</font><font style="vertical-align: inherit;">コンパイルは、Visual Studio 2019 for Release x64モード、つまりオペレーティングシステムWindows 7 x64を介して行われました。</font><font style="vertical-align: inherit;">私はスレッドの数で遊んでいなかったので、すべてのテストで、このシステムで使用可能な最大12スレッドが常に使用されました。</font><font style="vertical-align: inherit;">リストは、最後のテストを除いて、ランダムに選択された10,000アイテムで常に作成されています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ戦略テスト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に述べたように、組み込みポインターを使用すると、リスト内の項目を確認するために直接検索戦略しか使用できません。したがって、比較が正しくなるように、そしてスマートポインターの場合、このテストではこの戦略のみが適用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロッキング戦略として、シンロックのクリティカルセクションがWindowsで最も生産性の高いものとして選択されました（以下を参照）：ThreadLockingWin_SRWLock。エラー処理は、エラーコードを返すことで実行されます。例外なくオプション。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このグラフは、テストの期間（秒単位）に応じて、すべてのスレッドによって実行された1秒あたりの合計サイクル数を示しています。リストにアクセスするスレッドのランダムな性質により、明らかにパフォーマンスに一貫性がありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のグラフは、テスト中にリストアイテムの数がどのように変化するかを示しています。明らかな場合を除いて、このスケジュールについては慎重な発言はしません。これらが少し異なる方法で機能することは明らかであり、メモリ戦略とリストの接続性が影響します。内部ポインタを持つ二重にリンクされたリストは、テスト期間全体で平均サイズが予期せず変化しない唯一のリストです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
測定期間の平均生産性（サイクル/秒）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少なくとも、スマートポインターを使用したリストオプションは、組み込みポインターを使用したバージョンよりも遅いことが予想されます。</font><font style="vertical-align: inherit;">どちらの場合も、どういうわけか、単一接続の方が二重接続のものよりも高速であることがわかります。これは、マルチスレッドモードでは、多くの使い慣れたものが変更できることを再度示しています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテムの在庫戦略のテスト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も興味深いのは、要素の存在を確認するための戦略をテストすることです。メモリ戦略として、前述の理由により、スマートポインタは当然示されます。残りは同じです。ThreadLockingWin_SRWLockでロックし、エラーコードを返すことでエラーを処理します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての戦略がほぼ同じように機能することは確かです。これは理解できます。単一リンクリストでは、そのアイテムを削除するときに、削除するアイテムを示すアイテムを毎回参照する必要があります。これにより、リストへのアクセスを最適化し、リスト内の要素の存在のチェックを高速化するすべての取り組みが無効になります。したがって、単一リンクリストは、それを使用した集中的な無秩序なマルチスレッド処理には最適な選択ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素の数のグラフは示しません。そこには興味深いものは何もありません。すべてのリストの要素の数が増加していることに注意します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二重にリンクされたリストでは、まったく異なる状況が発生します。グラフを美しく見せるために、DirectSearchリストを直接表示する戦略も除外しました。結果によって、他のリストから明らかに「抜け落ちる」ためです。また、要素数の上限を4倍に増やしたため、テストが停止しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、リストへのアクセスのパフォーマンス（およびプロセッサの負荷、99〜100％になる）が劇的に大幅に向上しました。第2に、配列ビットを順次埋める1組の戦略は、テスト中に変更されないほぼ同じパフォーマンスを持っています。戦略の2番目のペアの速度は非線形に減少します。なぜそうなのかは、リストのノード数のグラフから明らかになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
戦略の最初のペアを持つリストは、要素の数が増加し、直線的に増加します。 2番目のペアは大幅に非線形の成長を示し、要素の数が多いほどリストの成長が遅くなります。これは理解できるので新しい要素を作成するときに要素の数が増えると、平均して、配列のより多くのビットを調べて空きを探す必要があります。戦略の最初のペアはこれを扱いません、それは新しい要素ごとに新しいビットを使用します。したがって、このような戦略を持つリストは、最大のアクセスパフォーマンスを持ち、従来のリストに最も近いものです。要素の作成と削除は、要素の数に関係なく、一定の時間で実行されます。ただし、一定量のメモリを消費しますが、マルチスレッド環境での整合性とセキュリティは保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、2番目のストラテジーのリストは著しく遅くなります。ただし、直接チェックオプションよりもはるかに高速です。そのため、パフォーマンスは中程度であるが、メモリ消費の点ではより最適なものとして、実際に推奨できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、直接検索方式のリストは、要素の数が増えると動作が遅くなります。毎回、より多くの要素を表示する必要があります。テスト中にリストが大きく成長せず、混沌としたパフォーマンスの変動にもかかわらず目立つようになるだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平均化されたパフォーマンス値は、シーケンシャルフィル中にビットマップを使用する戦略により、リストへのアクセスの生産性が約200倍に向上したことを示しています。</font><font style="vertical-align: inherit;">直接検索戦略と比較して2桁。</font><font style="vertical-align: inherit;">これは非常に根本的な変化です。</font><font style="vertical-align: inherit;">上記のように、メモリ最適ビットフィルを使用したオプションのパフォーマンスは、当然ながら著しく低速ですが、直接検証を使用するオプションよりもはるかに高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、要求に応じてメモリ転送メカニズムを使用すると、リストへのアクセスが多少遅くなることにも注意してください。</font><font style="vertical-align: inherit;">それほど重要ではないが、効果が存在し、特にメモリの経済的な使用を伴うバリアント（グラフの黄色の線）で顕著です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロッキング戦略のテスト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、さまざまなロック戦略を選択したときに、リストのパフォーマンスがどのように変化するかを見てみましょう。</font><font style="vertical-align: inherit;">私は3種類のロックを使用しました。SRWLock「シン」ロック、通常のWindowsクリティカルセクション、およびSTLミューテックスです。</font><font style="vertical-align: inherit;">残りの設定では、リストの最高速バージョンが使用されました：双方向接続されたスマートポインター、要素の存在を確認するための戦略-SearchByIndex_BitArray、例外のないバリアント。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご想像のとおり、「シン」ロックはパフォーマンスをほぼ25％向上させます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowsのクリティカルセクションとSTLミューテックスの処理速度はほぼ同じです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外がパフォーマンスに与える影響を評価するために、3つのテストを実施しました。</font><font style="vertical-align: inherit;">最初の2つは、二重リンクリスト、スマートポインター、要素の存在チェック戦略-SearchByIndex_BitArray、およびSRWLockのクリティカルセクションを使用しました。</font><font style="vertical-align: inherit;">最後のテストでも同じテストが使用され、比較のためにロックのみが通常のクリティカルセクションに置き換えられました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外のサポートにより、特に「より粗い」ブロッキングオプションを使用する場合は、作業速度が実際に低下する可能性があることがわかります。</font><font style="vertical-align: inherit;">ただし、この場合、コレクション内のSTLおよびforループのサポートは利用できなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とても大規模な実験でした。上記のテストではなく、プロジェクト全体を意味します。彼は自分がそんなに引きずられるとは思っていなかった。それにもかかわらず、私はそれを完全に、私が計画した範囲で実行しました。もちろん、これは最終的にはまだ最終版ではなく、実際のプロトタイプであり、記事の冒頭で説明したアイデアの実装にすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト結果によると、Windowsでは、スマートポインターを備えた最高速の二重リンクリストであることがわかりました。これは、SearchByIndex_BitArray要素の存在を確認するための戦略であり、SRWLockのクリティカルセクションであり、例外はありません。この構成では、リストはさまざまなスレッドからの集中的なカオスアクセスで最大のパフォーマンスを提供し、動作はクラシックリストに最も近く、マルチスレッドモードでのセキュリティが保証されます。 （DirectSearch直接検証と比較して）メモリ消費がより経済的なオプションも非常に生産的ですが、それでも以前のオプションよりも著しく遅く、要素の数が増えるとパフォーマンスが低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がここでキャンペーンを行って、すごいことをして、それを使うのがどれほど素晴らしいかを考えているとしたら、いいえ。実際、私はあなたを落胆させることから始めます。</font><font style="vertical-align: inherit;">確かに：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列など、要素の配置が異なるコンテナを使用できるかどうかを検討します。</font><font style="vertical-align: inherit;">リストのような問題はありません。</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    –       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   –     .    . ,   –          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オンデマンドでビット配列にメモリを転送する戦略では、少なくとも部分的にマルチスレッドリストをクラシックリストに近づけます。少なくともメモリ配列が完全にいっぱいになるまで、実際に必要な量だけかかります。</font><font style="vertical-align: inherit;">ただし、これによりパフォーマンスが低下します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 プロジェクトの欠点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前述のリストの結合操作での相互ブロッキングの可能性。</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが面白かったと思います。初心者は役に立つかもしれません、なぜならすべてが単純なものから複雑なものまで考慮されます。私は専門家に、あなたの意見では、ここで説明されているアイデアが実際のプロジェクトの実際にどれだけ適用できるかを尋ねますか？アクティビティによっては、別のコンテナではなく、リストまたはツリーが必要な場合がありますが、ここで説明する問題のためにプログラムのボトルネックになりましたか？または、プログラムを大幅に変更または複雑にする必要がありました。以前にこれに会ったことがあるなら、どうやってこれを解決しましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、本質的に、このプロジェクトは、この問題の解決策についての私自身の見解の実現にすぎません。</font><font style="vertical-align: inherit;">いくつかのより良いオプションがある可能性があります。</font><font style="vertical-align: inherit;">最初は自分でやったので、公の場に出すつもりはなかったのではないかという考えを最初から繰り返します。</font><font style="vertical-align: inherit;">しかし、それでも、そこで説明されている理由でそれをしたので、建設的な批評を喜んで受けます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを注意深くレビューすると、そのようなデザインに出くわすかもしれません：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この黒魔術は別の記事に値する。</font><font style="vertical-align: inherit;">確かに、これはここで説明するマルチスレッドリストよりも実用的ではありませんが、独自の興味深い機能があります。</font><font style="vertical-align: inherit;">それがどこから来たのか、なぜそれが現れたのかに興味があり、後で詳しく説明したい場合は、コメントに書き込んでください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja506702/index.html">Backblaze Q1 2020による最も信頼性の高いHDD</a></li>
<li><a href="../ja506704/index.html">2020年にPHPで記述する理由 Holivarimは今週木曜日にYouTubeでインタラクティブなポッドキャストです</a></li>
<li><a href="../ja506706/index.html">大量のデータを処理するときの最新のJavaのパフォーマンス、パート1</a></li>
<li><a href="../ja506708/index.html">VPN / Mikrotik 2要素認証-シンプルでスケーラブル</a></li>
<li><a href="../ja506710/index.html">Zimbra Collaboration Suite Open-Source Editionで複数のアドレス帳を管理する</a></li>
<li><a href="../ja506726/index.html">システムでのユーザーの登録と承認にRutokenテクノロジーを使用した経験（パート2）</a></li>
<li><a href="../ja506730/index.html">SnortまたはSuricata。パート1：企業ネットワークを保護するための無料のIDS / IPSを選択する</a></li>
<li><a href="../ja506732/index.html">UIコンポーネントの組織全体での再利用</a></li>
<li><a href="../ja506734/index.html">電気ネットワークの過渡計算</a></li>
<li><a href="../ja506736/index.html">クラスにはいくつのメソッドが必要ですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>