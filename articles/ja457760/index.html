<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤥 😭 🤦🏻 コンテナーをさらに分離する方法：コンテナーサンドボックステクノロジーのレビュー 🤘🏿 💪 👿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ほとんどのIT業界がコンテナーとクラウドソリューションに基づくインフラストラクチャソリューションを実装しているという事実にもかかわらず、これらのテクノロジーの制限を理解する必要があります。伝統的に、Docker、Linux Containers（LXC）、およびRocket（rkt）は、作業において...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コンテナーをさらに分離する方法：コンテナーサンドボックステクノロジーのレビュー</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/457760/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどのIT業界がコンテナーとクラウドソリューションに基づくインフラストラクチャソリューションを実装しているという事実にもかかわらず、これらのテクノロジーの制限を理解する必要があります。伝統的に、Docker、Linux Containers（LXC）、およびRocket（rkt）は、作業において親オペレーティングシステムのコアを共有するため、完全に分離されていません。はい、リソースの点では効率的ですが、特にコンテナが配置されているマルチテナントクラウド環境の場合は、推定攻撃ベクトルの合計数とハッキングによる潜在的な損失が依然として大きいです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/er/x_/lserx_gyy2iflakk5liv6en4yty.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの問題の根本は、ホストオペレーティングシステムがコンテナごとに仮想ユーザー領域を作成するときに、コンテナの区切りが弱いことにあります。はい、研究開発は、完全な「サンドボックス」を備えた実際の「コンテナ」を作成することを目的として行われました。そして、結果として生じるソリューションのほとんどは、コンテナ間の分離を強化するためにコンテナ間の境界の再構築につながります。この記事では、IBM、Google、Amazon、OpenStackの4つのユニークなプロジェクトを見ていきます。これらのプロジェクトは、同じ目標を達成するために異なる方法を使用しています。それは、信頼できる分離を作成することです。そのため、IBM Nablaはコンテナーをユニカーネルの上にデプロイし、Google gVisorは専用のゲストカーネルを作成し、Amazon Firecrackerはサンドボックスアプリケーションに非常に軽量なハイパーバイザーを使用します。OpenStackは、オーケストレーション機器用に最適化された専用の仮想マシンにコンテナーを配置します。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のコンテナ技術の概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーは、アプリケーションをパッケージ化、共有、およびデプロイする最新の方法です。</font><font style="vertical-align: inherit;">すべての機能が1つのプログラムにパッケージ化されているモノリシックアプリケーションとは異なり、コンテナーアプリケーションまたはマイクロサービスは対象を絞った用途向けに設計されており、1つのタスクのみに特化しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーには、アプリケーションが特定のタスクを完了するために必要なすべての依存関係（パッケージ、ライブラリ、バイナリなど）が含まれます。その結果、コンテナ化されたアプリケーションはプラットフォームに依存せず、バージョンやインストールされているパッケージに関係なく、どのオペレーティングシステムでも実行できます。この便利さにより、開発者は、さまざまなバージョンのソフトウェアをさまざまなプラットフォームまたはクライアントに適応させるための膨大な作業から解放されます。概念的には完全に正確ではありませんが、多くの人々はコンテナを「軽量の仮想マシン」と考えるのが好きです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーがホストにデプロイされると、ファイルシステム、プロセス、ネットワークスタックなどの各コンテナーのリソースは、他のコンテナーがアクセスできない仮想的に分離された環境に配置されます。このアーキテクチャでは、1つのクラスターで数百および数千のコンテナーを同時に実行でき、多数のインスタンスを複製することで、各アプリケーション（またはマイクロサービス）を簡単にスケーリングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーのレイアウトは、Linux名前空間とLinuxコントロールグループ（cgroup）の2つの主要な「ビルディングブロック」に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前空間は、実質的に隔離されたユーザースペースを作成し、ファイルシステム、ネットワークスタック、プロセスID、ユーザーIDなどの専用システムリソースをアプリケーションに提供します。この分離されたユーザー空間では、アプリケーションはファイルシステムのルートディレクトリを制御し、ルートとして実行できます。この抽象的なスペースにより、同じホスト上にある他のアプリケーションに干渉することなく、各アプリケーションが独立して動作することができます。現在、6つの名前空間が使用可能です：マウント、プロセス間通信（ipc）、UNIXタイムシェアリングシステム（uts）、プロセスID（pid）、ネットワーク、ユーザー。このリストは、timeとsyslogの2つの追加の名前空間で補足することを提案していますが、Linuxコミュニティは最終的な仕様をまだ決定していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cgroupsは、ハードウェアリソースの制限、優先順位付け、アプリケーションの監視と制御を提供します。ユーザーが制御できるハードウェアリソースの例には、プロセッサ、メモリ、デバイス、ネットワークなどがあります。名前空間とcgroupを組み合わせると、同じホスト上で複数のアプリケーションを安全に実行できます。各アプリケーションは、コンテナーの基本的なプロパティである独自の分離された環境で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシン（VM）とコンテナーの主な違いは、仮想マシンがハードウェアレベルの仮想化であり、コンテナーがオペレーティングシステムレベルの仮想化であることです。 VMハイパーバイザーは、各マシンのハードウェア環境をエミュレートします。コンテナーランタイムは、すでに各オブジェクトのオペレーティングシステムをエミュレートしています。仮想マシンはホストの物理ハードウェアを共有し、コンテナーはハードウェアとOSコアの両方を共有します。コンテナは通常、ホストとより多くのリソースを共有するため、ストレージ、メモリ、およびCPUサイクルでの作業は、仮想マシンよりもはるかに効率的です。ただし、この共有アクセスの欠点は、コンテナとホストの間で確立されている信頼が高すぎるため、情報セキュリティの面での問題です。図1は、コンテナーと仮想マシンのアーキテクチャの違いを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_7/qr/bk/_7qrbkpwq4ee_ep709hxsqzyl8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、仮想化された機器の分離は、名前空間の分離よりもはるかに強力なセキュリティ境界を作成します。攻撃者が分離されたプロセスを正常に離れるリスクは、仮想マシンを離れる確率よりもはるかに高くなります。制限されたコンテナー環境を超えるリスクが高いのは、名前空間とcgroupによって作成された分離が不十分なためです。 Linuxは、新しいプロパティフィールドを各プロセスに関連付けることによってそれらを実装します。ファイルシステムのこれらのフィールド</font></font><code>/proc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるプロセスが別のプロセスを認識できるかどうか、または特定のプロセスが使用できるプロセッサ/メモリリソースの量をホストオペレーティングシステムに示します。実行中のプロセスとスレッドを親OS（たとえば、topまたはpsコマンド）から表示すると、コンテナープロセスは他のプロセスと同じように見えます。通常、LXCやDockerなどの従来のソリューションは、同じホスト内で同じコアを使用するため、完全に分離されているとは見なされません。したがって、コンテナに十分な数の脆弱性があることは当然のことです。たとえば、CVE-2014-3519、CVE-2016-5195、CVE-2016-9962、CVE-2017-5123、およびCVE-2019-5736は、攻撃者がコンテナーの外部のデータにアクセスする可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのカーネルエクスプロイトは、通常、特権の昇格を引き起こし、侵害されたプロセスが目的の名前空間の外で制御を取得できるため、攻撃を成功させるためのベクトルを作成します。ソフトウェアの脆弱性のコンテキストでの攻撃ベクトルに加えて、不適切な構成も役割を果たす可能性があります。たとえば、過度の権限（CAP_SYS_ADMIN、特権アクセス）または重要なマウントポイント（</font></font><code>/var/run/docker.sock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">イメージを展開すると</font><font style="vertical-align: inherit;">、リークが発生する可能性があります。これらの壊滅的な結果をもたらす可能性があるため、システムをマルチテナントスペースに展開する場合、またはコンテナーを使用して機密データを格納する場合のリスクを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題は、研究者がより強力なセキュリティ境界を作成する動機となります。アイデアは、メインOSから可能な限り分離された実際のサンドボックスコンテナーを作成することです。これらのソリューションのほとんどには、アプリケーションと仮想マシンの厳密な区別を使用し、コンテナソリューションの効率の向上に焦点を当てたハイブリッドアーキテクチャの開発が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の執筆時点では、標準として受け入れられるほど成熟しているとは言えない単一のプロジェクトはありませんでしたが、将来的には、開発者がこれらの概念のいくつかを主要な概念として受け入れることは間違いありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レビューは、最小限のOSライブラリのセットを使用してアプリケーションを1つのイメージにパックする最も古く専門化されたシステムであるUnikernelから始めます。</font><font style="vertical-align: inherit;">Unikernelのコンセプト自体は、安全でコンパクトな最適化されたイメージを作成することを目的とした多くのプロジェクトの基礎となりました。</font><font style="vertical-align: inherit;">その後、コンテナーを含むUnikernelアプリケーションを起動するプロジェクトであるIBM Nablaについて検討します。</font><font style="vertical-align: inherit;">さらに、ユーザーカーネルスペースでコンテナーを起動するためのプロジェクトであるGoogle gVisorがあります。</font><font style="vertical-align: inherit;">次に、仮想マシン（Amazon FirecrackerとOpenStack Kata）に基づくコンテナーソリューションに切り替えます。</font><font style="vertical-align: inherit;">上記のソリューションをすべて比較して、この投稿を要約します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニカーネル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想化テクノロジーの開発により、クラウドコンピューティングへの移行が可能になりました。 XenやKVMなどのハイパーバイザーは、Amazon Webサービス（AWS）およびGoogle Cloud Platform（GCP）として現在知られているものの基礎を築きました。また、最新のハイパーバイザーは数百の仮想マシンを単一のクラスターに組み合わせて動作することができますが、従来の汎用オペレーティングシステムは、そのような環境で動作するように適応および最適化されていません。汎用OSは、まず、できるだけ多くのさまざまなアプリケーションをサポートして動作することを目的としています。そのため、それらのカーネルには、あらゆる種類のドライバー、ライブラリ、プロトコル、スケジューラーなどが含まれています。ただし、現在クラウドのどこかに展開されているほとんどの仮想マシンは、たとえばDNSを提供するために、単一のアプリケーションを実行するために使用されます。プロキシまたは何らかのデータベース。このような単一のアプリケーションは、OSカーネルの特定の小さな部分にのみ依存しているため、他のすべての「スカート」はシステムリソースを浪費するだけであり、アプリケーションが存在するという事実により、潜在的な攻撃のベクトル数が増加します。実際、コードベースが大きくなるほど、すべての欠点を排除することが難しくなり、潜在的な脆弱性、エラー、その他の弱点が増えます。この問題により、スペシャリストは、最小限のカーネル機能を備えた高度に専門化されたオペレーティングシステムを開発すること、つまり、特定の1つのアプリケーションをサポートするツールを作成することが奨励されます。彼の残りの「ボディキット」はすべてシステムリソースを浪費しているだけであり、それらが存在するという事実により、攻撃の可能性のあるベクターの数が増えます。実際、コードベースが大きくなるほど、すべての欠点を排除することが難しくなり、潜在的な脆弱性、エラー、その他の弱点が増えます。この問題により、スペシャリストは、最小限のカーネル機能を備えた高度に専門化されたオペレーティングシステムを開発すること、つまり、特定の1つのアプリケーションをサポートするツールを作成することが奨励されます。彼の残りの「ボディキット」はすべてシステムリソースを浪費しているだけであり、それらが存在するという事実により、攻撃の可能性のあるベクターの数が増えます。実際、コードベースが大きくなるほど、すべての欠点を排除することが難しくなり、潜在的な脆弱性、エラー、その他の弱点が増えます。この問題により、スペシャリストは、最小限のカーネル機能を備えた高度に専門化されたオペレーティングシステムを開発すること、つまり、特定の1つのアプリケーションをサポートするツールを作成することが奨励されます。この問題により、スペシャリストは、最小限のカーネル機能セットで高度に専門化されたオペレーティングシステムを開発すること、つまり、特定の1つのアプリケーションをサポートするツールを作成することが奨励されます。この問題により、スペシャリストは、最小限のカーネル機能を備えた高度に専門化されたオペレーティングシステムを開発すること、つまり、特定の1つのアプリケーションをサポートするツールを作成することが奨励されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初めて、Unikernelのアイデアは90年代に生まれました。それから彼は、ハイパーバイザーで直接動作できる単一のアドレス空間を持つマシンの特殊なイメージとして形を作りました。コアとカーネルに依存するアプリケーションと機能を単一のイメージにパックします。 NemesisとExokernelは、Unikernelプロジェクトの最初の2つの研究バージョンです。パッケージ化と展開のプロセスを図2に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/pl/2q/lvpl2q9eel5loxodhibvhzjc93m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2.多目的オペレーティングシステムは、すべてのタイプのアプリケーションをサポートするように設計されているため、多くのライブラリとドライバーが事前にロードされています。ユニカーネルは、1つの特定のアプリケーションをサポートするように設計された、高度に専門化されたオペレーティングシステムです。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unikernelはカーネルをいくつかのライブラリに分割し、必要なコンポーネントのみをイメージに入れます。通常の仮想マシンと同様に、ユニカーネルはVMハイパーバイザー上にデプロイされ、実行されます。サイズが小さいため、読み込みが速く、スケーリングも高速です。 Unikernelの最も重要な機能は、セキュリティの向上、フットプリントの小ささ、高度な最適化、高速読み込みです。これらのイメージにはアプリケーション依存のライブラリのみが含まれており、意図的に接続されていないとOSシェルを利用できないため、攻撃者がそれらに使用できる攻撃ベクトルの数は最小限です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、攻撃者がこれらの固有のコアに足場を置くことは難しいだけでなく、その影響も1つのコアインスタンスに限定されます。 Unikernelイメージのサイズは数メガバイトしかないため、数十ミリ秒でダウンロードされ、文字通り数百のインスタンスを単一のホストで起動できます。マルチレベルページテーブルの代わりに同じアドレス空間でメモリ割り当てを使用すると、ほとんどの最新のオペレーティングシステムの場合のように、ユニカーネルアプリケーションは、通常の仮想マシンで実行されている同じアプリケーションと比較して、メモリアクセスの遅延が少なくなります。アプリケーションはイメージを構築するときにカーネルと一緒に来るので、コンパイラーは静的型検査を実行してバイナリー・ファイルを最適化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unikernel.orgは、unikernelプロジェクトのリストを管理しています。しかし、すべての特徴的な機能と特性により、ユニカーネルは広く使用されていません。 Dockerが2016年にUnikernel Systemsを買収したとき、コミュニティは会社がコンテナを梱包することを決定しました。しかし、3年が経過し、統合の兆候はまだありません。この遅い実装の主な理由の1つは、Unikernelアプリケーションを作成するための成熟したツールがまだなく、これらのアプリケーションのほとんどが特定のハイパーバイザーでしか機能しないことです。さらに、アプリケーションをユニカーネルに移植するには、依存するカーネルライブラリの書き換えなど、他の言語でコードを手動で書き換える必要がある場合があります。ユニカーネルでの監視またはデバッグが不可能であることも重要です。またはパフォーマンスに大きな影響を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての制限により、開発者はこのテクノロジーに切り替えることができません。</font><font style="vertical-align: inherit;">ユニカーネルとコンテナには多くの類似したプロパティがあることに注意してください。</font><font style="vertical-align: inherit;">1つ目と2つ目は非常に焦点を合わせた不変のイメージです。つまり、イメージ内のコンポーネントは更新または修正できません。つまり、常にアプリケーションパッチ用の新しいイメージを作成する必要があります。</font><font style="vertical-align: inherit;">今日、UnikernelはDockerの祖先に似ています。コンテナランタイムは利用できず、開発者は分離されたアプリケーション環境（chroot、unshare、cgroups）を構築するために基本的なツールを使用する必要がありました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イブムナブラ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、IBMの研究者が「プロセスとしてのユニカーネル」の概念を提案しました。つまり、専用のハイパーバイザーでプロセスとして実行されるユニカーネルアプリケーションです。 IBMプロジェクトの「Nablaコンテナー」は、ユニバーサルハイパーバイザー（QEMUなど）をNabla Tenderと呼ばれる独自の開発に置き換えて、ユニカーネルのセキュリティ境界を強化しました。このアプローチの背後にある理論的根拠は、ユニカーネルとハイパーバイザー間の呼び出しが依然として最も多くの攻撃ベクトルを提供するということです。そのため、許可されるシステムコールが少ないユニカーネル専用のハイパーバイザーを使用すると、セキュリティ境界を大幅に強化できます。 Nabla Tenderは、ユニカーネルがハイパーバイザーにルーティングする呼び出しを傍受し、すでに独立してそれらをシステム要求に変換します。同時に、seccomp Linuxポリシーは、Tenderの動作に不要な他のすべてのシステムコールをブロックします。したがって、Nabla Tenderと組み合わせたUnikernelは、ホストのユーザー空間でプロセスとして実行されます。下の図3は、Nablaがユニカーネルとホストの間にシンインターフェイスを作成する方法を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wy/je/p6/wyjep6mcxwfd8n-ogesrx1rnjyi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3. Nablaを既存のコンテナーランタイムプラットフォームとリンクするために、NablaはOCI互換の環境を使用します。この環境は、DockerまたはKubernetesに接続できます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
開発者は、Nabla Tenderがホストとのやり取りに7つ未満のシステムコールを使用していると主張しています。システムコールは、ユーザー空間のプロセスとオペレーティングシステムのカーネル間の一種のブリッジとして機能するため、使用できるシステムコールが少ないほど、カーネルを攻撃するために利用できるベクターの数は少なくなります。 unikernelをプロセスとして実行するもう1つの利点は、gdbなどの多数のツールを使用して、そのようなアプリケーションをデバッグできることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーオーケストレーションプラットフォームを操作するために、Nablaは</font></font><code>runnc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Container Initiative（OCI）標準を実装</font><font style="vertical-align: inherit;">する専用ランタイム環境</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供しています</font><font style="vertical-align: inherit;">。後者は、クライアント（Docker、Kubectlなど）とランタイム環境（runcなど）の間のAPIを定義します。 Nablaには、後で起動できるイメージデザイナーも付属しています</font></font><code>runnc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、ユニカーネルと従来のコンテナーのファイルシステムの違いにより、NablaイメージはOCIイメージ仕様に準拠していないため、Dockerイメージは</font></font><code>runnc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">執筆時点では、プロジェクトはまだ開発の初期段階にあります。</font><font style="vertical-align: inherit;">他の制限があります。たとえば、ホストファイルシステムのマウント/アクセス、いくつかのネットワークインターフェースの追加（Kubernetesに必要）、または他のユニカーネルイメージのイメージ（MirageOSなど）の使用のサポートの欠如です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google gVisor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google gVisorは、Google Cloud Platform Application Engine（GCP）、クラウド機能、CloudMLを使用したサンドボックステクノロジーです。ある時点で、Googleは信頼できないアプリケーションをパブリッククラウドインフラストラクチャで実行するリスクと、仮想マシンを使用したサンドボックスアプリケーションの非効率性を認識しました。その結果、このような信頼性の低いアプリケーションの隔離された環境用にユーザー空間カーネルが開発されました。 gVisorはこれらのアプリケーションをサンドボックスに配置し、アプリケーションからホストカーネルへのすべてのシステムコールをインターセプトし、gVisor Sentryカーネルを使用してユーザー環境でそれらを処理します。本質的には、ゲストコアとハイパーバイザーの組み合わせとして機能します。図4は、gVisorアーキテクチャーを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rk/xe/eq/rkxeeqqm9qs73q5enqp6zy99rfk.png"><br>
<i> 4.   gVisor //   Sentry  gVisor Gofer         </i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gVisorは、アプリケーションとそのホストの間に強力なセキュリティ境界を作成します。アプリケーションがユーザー空間で使用できるシステムコールを制限します。仮想化に依存することなく、gVisorはスタンドアロンアプリケーションとホストの間で相互作用するホストプロセスとして機能します。 Sentryは、ほとんどのLinuxシステムコールと、信号配信、メモリ管理、ネットワークスタック、ストリームモデルなどのコアカーネル機能をサポートしています。 Sentryは、サンドボックスアプリケーションをサポートする319 Linuxシステムコールの70％以上を実装しています。ただし、Sentryはホストカーネルとのやり取りに20未満のLinuxシステムコールを使用します。 gVisorとNablaは非常によく似た戦略を持っていることは注目に値します。ホストOSを保護し、これらのソリューションはどちらもカーネルと対話するためにLinuxシステムコールの10％未満しか使用しません。ただし、gVisorは多目的カーネルを作成することを理解する必要があります。たとえば、Nablaは独自のカーネルに依存しています。同時に、どちらのソリューションも、ユーザー空間で専用のゲストカーネルを起動して、信頼できる分離されたアプリケーションをサポートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxカーネルがすでにオープンソースであり、簡単にアクセスできるのに、なぜgVisorが独自のカーネルを必要とするのか疑問に思われるかもしれません。したがって、Golangで記述されたgVisorカーネルは、Cで記述されたLinuxカーネルよりも安全です。すべて、Golangの強力なタイプセーフティおよびメモリ管理機能のおかげです。 gVisorに関するもう1つの重要な点は、Docker、Kubernetes、およびOCI標準との緊密な統合です。ほとんどのDockerイメージは、ランタイムをgVisor runcに変更することで、gVisorを使用して簡単に取得および実行できます。サンドボックスの代わりにKubernetesの場合、gVisorの個々のコンテナーごとに、サンドボックスモジュール全体を実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gVisorはまだ初期段階なので、いくつかの制限があります。</font><font style="vertical-align: inherit;">gVisorがアプリケーションによってサンドボックスから作成されたシステムコールをインターセプトして処理すると、常にコストが発生するため、重いアプリケーションには適していません。</font><font style="vertical-align: inherit;">（ユニカーネルアプリケーションはシステムコールを行わないため、Nablaにはそのような問題はありません。Nablaはハイパーコールの処理にのみ7つのシステムコールを使用します）。</font><font style="vertical-align: inherit;">GVisorにはハードウェアへの直接アクセス（パススルー）がないため、たとえばGPUへのアクセスを必要とするアプリケーションは、GVisorで動作できません。</font><font style="vertical-align: inherit;">最後に、gVisorはLinuxシステムコールの70％しかサポートしていないため、サポートリストにない呼び出しを使用するアプリケーションはgVisorで実行できません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アマゾン爆竹</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amazon Firecrackerは、AWS LambdaとAWS Fargateで現在使用されているテクノロジーです。これは、特にマルチテナントコンテナーおよびサーバーレスオペレーティングモデル用の「軽量仮想マシン」（MicroVM）を作成するハイパーバイザーです。 Firecrackerの前は、各クライアントのLambda関数とFargate関数が専用のEC2仮想マシン内で動作して、信頼性の高い分離を実現していました。仮想マシンはパブリッククラウド内のコンテナーに対して十分な分離を提供しますが、分離された環境でアプリケーションに汎用仮想マシンと仮想マシンの両方を使用することは、リソース消費の点で非常に効率的ではありません。 Firecrackerは、クラウドアプリケーション用に特別に設計されており、セキュリティとパフォーマンスの両方の問題を解決します。Firecracker Hypervisorは、各ゲスト仮想マシンに最小限のOS機能とエミュレートされたデバイスを提供し、セキュリティとパフォーマンスの両方を強化します。ユーザーは、Linuxカーネルバイナリとext4ファイルシステムイメージを使用して、仮想マシンイメージを簡単に作成できます。 Amazonは2017年にFirecrackerの開発を開始し、2018年にはプロジェクトのソースコードをコミュニティに公開しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニカーネルの概念と同様に、Firecrackerは、コンテナー操作が確実に機能するようにするための機能のごく一部を提供します。従来の仮想マシンと比較して、マイクロVMには潜在的な脆弱性がはるかに少ないだけでなく、メモリの消費と起動時間もありません。実際には、2 CPU + 256 GB RAMの構成のホストで作業する場合、FirecrackerのマイクロVMが約5 MBのメモリを消費し、約125 msでロードすることが示されています。図5は、Firecrackerアーキテクチャとそのセキュリティ境界を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/rd/qu/_irdqutnwf2v659vbsxz47igzo0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5. Firecrackerハイパーバイザーは、セキュリティレベルを使用して、個々のユーザーのアプリケーションを分離します</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
爆竹はKVMに基づいており、各インスタンスはユーザー空間でプロセスとして実行されます。各ファイアクラッカープロセスは、seccomp、cgroups、および名前空間のポリシーによってブロックされるため、システムコール、ハードウェアリソース、ファイルシステム、およびネットワークアクションは厳密に制限されます。各Firecrackerプロセス内には、いくつかのスレッドがあります。したがって、APIストリームにより、ホスト上のクライアントとmicroVM間の管理が可能になります。ハイパーバイザースレッドは、virtIOデバイスの最小セット（ネットワークおよびブロック）を提供します。 Firecrackerは、microVMごとに4つのエミュレートされたデバイス（virtio-block、virtio-net、シリアルコンソール、およびmicroVMを停止するためだけに設計された1ボタンキーボードコントローラー）のみを提供します。同じセキュリティの目的で、仮想マシンにはホストとファイルを交換するメカニズムがありません。コンテナイメージなどのホストデータファイルブロックデバイスを介してmicroVMと対話し、ネットワークインターフェースはネットワークブリッジを介してサポートされます。すべての発信パケットは専用デバイスにコピーされ、その速度はcgroupsポリシーによって制限されます。これらすべての予防策と情報セキュリティにより、1つのアプリケーションが他のアプリケーションに影響を与える可能性が最小限に抑えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の執筆時点では、FirecrackerはまだDockerおよびKubernetesとの統合プロセスを完全には完了していません。</font><font style="vertical-align: inherit;">爆竹はエンドツーエンドのハードウェア接続をサポートしていないため、デバイスにアクセスするためにグラフィックスプロセッサまたはアクセラレータを必要とするアプリケーションは、互換性がありません。</font><font style="vertical-align: inherit;">また、仮想マシンとプリミティブネットワークモデル間のファイル共有機能も制限されています。</font><font style="vertical-align: inherit;">ただし、プロジェクトは大規模なコミュニティによって開発されているため、すぐにOCI標準に移行し、より多くのアプリケーションのサポートを開始する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンスタック型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来のコンテナーのセキュリティ問題を見て、2015年にIntelはClear Containers仮想マシンに基づく独自のテクノロジーを導入しました。 Clear Containersは、Intel VT仮想化ハードウェアテクノロジーと高度に変更されたQEMU-KVMハイパーバイザーに基づいてい</font></font><code>qemu-lite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 2017年の終わりに、Clear ContainersプロジェクトはハイパーバイザーベースのOCIであるHyper RunVに加わり、Kataプロジェクトの開発を開始しました。クリアコンテナーのすべてのプロパティを継承するカタは、幅広いインフラストラクチャと仕様をサポートするようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kataは、OCI、コンテナーランタイムインターフェイス（CRI）、およびネットワークインターフェイス（CNI）と完全に統合されています。さまざまな種類のネットワークモデル（パススルー、MacVTap、ブリッジ、tcミラーリングなど）とカスタムゲストカーネルをサポートしているため、特別なネットワークモデルまたはカーネルバージョンを必要とするすべてのアプリケーションで動作できます。図6は、Kata仮想マシン内のコンテナーが既存のオーケストレーションプラットフォームとどのように相互作用するかを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/7k/yy/f07kyyzusufaygo32ysb8hjjb-i.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図6. KataコンテナーとDockerおよびKubernetesの完全統合</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kataホストには、起動および構成環境があります。 Kata仮想マシンの各コンテナーについて、ホストには対応するKata Shimがあり、クライアント（dockerやkubectlなど）からAPIリクエストを受信し、VSockを介して仮想マシン内のエージェントにリクエストをルーティングします。さらに、カタはダウンロード時間を最適化します。 NEMUはQEMUの軽量バージョンで、デバイスとパッケージの約80％が削除されています。 VM-Templatingは、実行中のKata VMインスタンスのクローンを作成し、作成したばかりの他のVMと共有します。これにより、ゲストマシンの読み込み時間とメモリ消費が大幅に削減されますが、たとえばCVE-2015-2877によると、サイドチャネル攻撃の脆弱性につながる可能性があります。 「ホット」に接続する機能により、VMは最小限のリソース（CPU、メモリ、virtioブロックなど）で起動し、後で必要に応じて不足しているリソースを追加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KataおよびFirecrackerコンテナーは、クラウドアプリケーション用に設計された仮想マシンサンドボックステクノロジーです。</font><font style="vertical-align: inherit;">目標は1つですが、アプローチは異なります。</font><font style="vertical-align: inherit;">Firecrackerは、ゲストOSの安全な仮想化環境を作成する特殊なハイパーバイザーですが、Kataコンテナーは、タスクに最適化された軽量の仮想マシンです。</font><font style="vertical-align: inherit;">FirecrackerでKataコンテナを起動する試みがありました。</font><font style="vertical-align: inherit;">このアイデアはまだ実験段階ですが、2つのプロジェクトの最高の機能を組み合わせることができる可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、現代のコンテナ技術の分離が不十分であるという問題を解決することを目的とするいくつかのソリューションを検討しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IBM Nablaは、アプリケーションを専用の仮想マシンにパックするユニカーネルベースのソリューションです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google gVisorは、ハイパーバイザーの専用コアとゲストOSを組み合わせたもので、アプリケーションとそのホスト間に安全なインターフェイスを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amazon Firecrackerは、各ゲストOSに最小限のハードウェアと核リソースのセットを提供する特殊なハイパーバイザーです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStack Kataは、さまざまなハイパーバイザーで実行できるコンテナーエンジンを組み込んだ高度に最適化された仮想マシンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのソリューションには長所と短所があるため、どのソリューションが最適であるかを判断するのは困難です。記事の最後にある表は、4つのプロジェクトすべてのいくつかの重要な機能を比較したものです。 Nablaは、MirageOSやIncludeOSなどのユニカーネルシステムでアプリケーションを実行している場合に最適です。 gVisorはDockerおよびKubernetesと最適に統合されるようになりましたが、システムコールのカバレッジが不完全なため、一部のアプリケーションはそれと互換性がありません。 FirecrackerはカスタムゲストOSイメージをサポートしており、アプリケーションを構成済みの仮想マシンで実行する場合に適しています。 KataコンテナーはOCI標準に完全に準拠しており、KVMまたはXenハイパーバイザーのいずれかで実行できます。これにより、ハイブリッドプラットフォームでのマイクロサービスの展開を簡略化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/50/d1/gr/50d1grnpu0ushkd6pkjl74vbeju.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションの1つが標準になるまでしばらく時間がかかる場合がありますが、大規模なクラウドプロバイダーのほとんどが既存の問題に対するソリューションを探し始めているので、今は良いことです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457750/index.html">Symfony 4でJSON RPCを操作する</a></li>
<li><a href="../ja457752/index.html">月面探査機やジョーカーではありません。福島のロボットについて知っていること</a></li>
<li><a href="../ja457754/index.html">Государство и Т-киллеры</a></li>
<li><a href="../ja457756/index.html">アクションの本カフカストリーム。リアルタイムアプリケーションとマイクロサービス»</a></li>
<li><a href="../ja457758/index.html">エンジニアは森で失われた人々を救うが、森はまだ降伏していない</a></li>
<li><a href="../ja457762/index.html">CCDルーラー：一緒に食べるもの</a></li>
<li><a href="../ja457764/index.html">若いPOの10の間違い（パートII）</a></li>
<li><a href="../ja457766/index.html">タイルレベルを生成し、プレーヤーから正方形を非表示にします</a></li>
<li><a href="../ja457768/index.html">脆弱になった経緯：QualysでITインフラストラクチャをスキャンする</a></li>
<li><a href="../ja457770/index.html">TypeScriptにカスタムトランスフォーマASTを記述します</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>