<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎤 🔖 🤶🏽 .NET：依存関係の扱い 👩‍👦‍👦 🐪 🤡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="アセンブリリダイレクトが原因で問題が発生したのは誰ですか？おそらく、比較的大きなアプリケーションを開発したすべての人が遅かれ早かれこの問題に直面するでしょう。
 
 現在、私はJetBrains RiderプロジェクトのJetBrainsで働いており、Riderを.NET Coreに移行するタスクに...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET：依存関係の扱い</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリリダイレクトが原因で問題が発生したのは誰ですか？</font><font style="vertical-align: inherit;">おそらく、比較的大きなアプリケーションを開発したすべての人が遅かれ早かれこの問題に直面するでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、私はJetBrains RiderプロジェクトのJetBrainsで働いており、Riderを.NET Coreに移行するタスクに携わっています。</font><font style="vertical-align: inherit;">以前は、クラウドベースのアプリケーションホスティングプラットフォームであるCircuitの共有インフラストラクチャに従事していました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットシーンの下には、DotNext 2019モスクワ会議からの私のレポートの筆記録があります。そこでは、.NETでアセンブリを操作するときの困難について話し、何が起こり、それに対処する方法を実際的な例で示しました。</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET開発者として働いていたすべてのプロジェクトで、依存関係の接続とアセンブリの読み込みに関するさまざまな問題に対処する必要がありました。</font><font style="vertical-align: inherit;">これについて話します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポストの構造：</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係の問題</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密なリグ装填</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リダイレクトのバインド</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強い命名</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有フレームワーク、.runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係マニフェスト（.deps.json）</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrainsライダーをコアで実行するためのハック</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリダウンロードのデバッグ</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">融合ログ</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムイベント</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係の問題とは何ですか？</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2000年代初頭に.NET Frameworkの開発を開始したとき、依存関係の地獄の問題はすでに知られており、すべてのライブラリで開発者は重大な変更を許可し、これらのライブラリは既にコンパイルされたコードでの使用に互換性がなくなります。</font><font style="vertical-align: inherit;">このような問題を解決するにはどうすればよいですか？</font><font style="vertical-align: inherit;">最初の解決策は明白です。</font><font style="vertical-align: inherit;">常に下位互換性を維持します。</font><font style="vertical-align: inherit;">もちろん、これはあまり現実的ではありません。破壊的な変更はコードに入れるのが非常に簡単だからです。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重大な変更と.NETライブラリ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは.NETに固有の例です。メソッドがあり、デフォルト値のパラメーターを追加することにしました。コードを再アセンブルしてもコードはコンパイルされ続けますが、バイナリは2つの完全に異なるメソッドになります。1つのメソッドには引数がなく、2番目のメソッドには引数が1つあります。依存関係の内部の開発者がこのように下位互換性を壊した場合、この依存関係でコンパイルされたコードを以前のバージョンで使用できなくなります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係の問題に対する2番目の解決策は、ライブラリ、アセンブリのバージョン管理を追加することです-何でも。バージョン管理のルールが異なる可能性があります。ポイントは、同じライブラリの異なるバージョンを何らかの方法で互いに区別できることであり、更新が壊れるかどうかを理解できます。残念ながら、バージョンを導入するとすぐに、別の種類の問題が発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バージョン地獄とは、バイナリ互換の依存関係を使用できないことですが、同時に、ランタイムに適合しないバージョンや、これらのバージョンをチェックする別のコンポーネントがあります。 .NETでは、バージョンhellの典型的な症状はFileLoadExceptionですが、ファイルはディスク上にありますが、なんらかの理由で実行時にロードされません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETでは、アセンブリには多くの異なるバージョンがあります。それらはさまざまな方法でバージョンの地獄を修正し、何が起こったかを確認しようとしました。パッケージがあります</font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。多くの人が彼を知っています。彼はNuGetパッケージ1.6.0の最新バージョンを持っています。ライブラリ、バージョン1.2.4.0のアセンブリが含まれています。ビルドライブラリバージョン1.2.4.0がないことがわかりました。それが1.6.0 NuGetパッケージにあることをどのように理解しますか？それは簡単ではありません。アセンブリバージョンに加えて、このライブラリにはさらにいくつかのバージョンがあります。たとえば、アセンブリファイルバージョン、アセンブリ情報バージョン。このNuGetパッケージには、同じバージョンの（.NET Standardの異なるバージョンの）3つの異なるアセンブリが実際に含まれています。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETドキュメンテーション</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild標準</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETでアセンブリを操作する方法については、多くのドキュメントが作成されています。</font><font style="vertical-align: inherit;">.NET Framework、.NET Standard、.NET Core、オープンソースなど、あらゆることを考慮した.NET用の最新のアプリケーションを開発するための.NETガイドがあります。</font><font style="vertical-align: inherit;">ドキュメント全体の約30％がアセンブリの読み込みに費やされています。</font><font style="vertical-align: inherit;">特定の問題と発生する可能性のある例を分析します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれがすべて必要なのですか？</font><font style="vertical-align: inherit;">まず、熊手を踏まないようにするためです。</font><font style="vertical-align: inherit;">第2に、ライブラリを使用すると、これまで使用していた依存関係の問題が発生しないため、ライブラリのユーザーの生活が楽になります。</font><font style="vertical-align: inherit;">また、複雑なアプリケーションの.NET Coreへの移行にも対応できます。</font><font style="vertical-align: inherit;">さらに、SREになることもできます。これは、シニア（バインディング）リダイレクトエンジニアで、チームの全員が来て、別のリダイレクトを作成する方法を尋ねます。</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳格なアセンブリ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密なアセンブリの読み込みは、.NET Frameworkの開発者が直面している主な問題です。</font><font style="vertical-align: inherit;">で表現され</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Strictアセンブリの読み込みに進む前に、いくつかの基本的なことを思い出させてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETアプリケーションをビルドすると、アーティファクトが発生します。アーティファクトは通常Bin / DebugまたはBin / Releaseにあり、アセンブリアセンブリと構成ファイルの特定のセットが含まれています。</font><font style="vertical-align: inherit;">アセンブリは、アセンブリ名という名前で相互に参照します。</font><font style="vertical-align: inherit;">アセンブリへのリンクは、このアセンブリを参照するアセンブリに直接配置されていることを理解することが重要です。アセンブリ参照が書き込まれる魔法の構成ファイルはありません。</font><font style="vertical-align: inherit;">そのようなファイルが存在するように見えるかもしれませんが。</font><font style="vertical-align: inherit;">参照は、バイナリ形式でアセンブリ自体にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETには、アセンブリ解決プロセスがあります。これは、アセンブリ定義がディスク上またはメモリのどこかにロードされている実際のアセンブリに既に変換されている場合です。アセンブリの解決は2回実行されます。ビルド段階で* .csprojに参照がある場合と、ランタイム段階でアセンブリ内に参照がある場合で、いくつかのルールにより、それらはダウンロード可能なアセンブリになります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//単純な名前</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly、バージョン= 6.0.0.0、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カルチャー=ニュートラル、PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密</font><font style="vertical-align: inherit;">な名前</font><font style="vertical-align: inherit;">Newtonsoft.Json、バージョン= 6.0.0.0、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カルチャー=ニュートラル、PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題に移りましょう。アセンブリ名には、主に2つのタイプがあります。最初の種類のアセンブリ名は単純名です。それらはPublicKeyToken = nullを持っているという事実によって簡単に識別できます。厳密な名前があり、PublicKeyTokenがnullではなく、いくつかの値であるという事実によって簡単に識別できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を見てみましょう。 MyUtilsユーティリティを備えたライブラリに依存するプログラムがあり、MyUtilsのバージョンは9.0.0.0です。同じプログラムに別のライブラリへのリンクがあります。このライブラリもMyUtilsを使用する必要がありますが、バージョン6.0.0.0です。 MyUtilsバージョン9.0.0.0、およびバージョン6.0.0.0には、PublicKeyToken = nullがあります。つまり、これらの名前はシンプルです。どのバージョンが6.0.0.0または9.0.0.0のバイナリアーティファクトに分類されますか？ 9番目のバージョン。 MyLibraryは、バイナリアーティファクトに入ったMyUtilsバージョン9.0.0.0を使用できますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyUtilsの名前がSimpleであるため、Strictアセンブリのロードが存在しないため、実際にはそれが可能です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一つの例。</font><font style="vertical-align: inherit;">MyUtilsの代わりに、厳密な名前を持つNuGetの完全なライブラリがあります。</font><font style="vertical-align: inherit;">NuGetのほとんどのライブラリには厳密な名前が付いています。</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビルド段階で、バージョン9.0.0.0がBINにコピーされますが、実行時に有名なバージョンが取得されます</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バージョン6.0.0.0を必要</font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とする</font><font style="vertical-align: inherit;">MyLibraryがバージョン9.0.0.0 </font><font style="vertical-align: inherit;">を使用できるようにするには、Binding redirectをに書き込む必要があります</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リダイレクトのバインド</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリバージョンのリダイレクト</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、そのような名前とそのようなpublicKeyTokenを持つアセンブリを、そのような範囲のバージョンからそのような範囲のバージョンにリダイレクトする必要があることを示しています。</font><font style="vertical-align: inherit;">非常に単純なレコードのようですが、それでもここ</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">あります</font><font style="vertical-align: inherit;">が、他のファイルに含まれている可能性があります。</font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Framework内、ランタイム内に</font><font style="vertical-align: inherit;">ファイルがあり</font><font style="vertical-align: inherit;">、リダイレクトの標準セットが定義されています。これは、.NET Frameworkのバージョンごとに異なる場合があります。</font><font style="vertical-align: inherit;">4.7.1では何も機能しないことがありますが、4.7.2ではすでに機能しているか、その逆です。</font><font style="vertical-align: inherit;">リダイレクトはyoursからだけでなく</font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デバッグ時に考慮する</font><font style="vertical-align: inherit;">必要があることを覚えておく必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リダイレクトの記述を簡素化します</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バインディングリダイレクトを自分の手で書きたいと思う人はいません。このタスクをMSBuildに割り当てましょう！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動バインディングリダイレクトを有効または無効にする方法バインディングリダイレクト</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の操作を簡略化する方法に関するいくつかのヒント。ヒント1：MSBuildでバインドリダイレクトの自動生成を有効にします。のプロパティによってオンになりました</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。プロジェクトをビルドすると、バイナリアーティファクトに分類されます</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、同じアーティファクトにあるライブラリのバージョンへのリダイレクトを示します。これは、実行中のアプリケーション、コンソールアプリケーション、WinExeでのみ機能します。ライブラリの場合、これは機能しません。ライブラリの場合</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、アセンブリ自体を起動およびロードするアプリケーションに関連しているため、単に関連性がありません。ライブラリの構成を作成した場合、アプリケーションの一部の依存関係は、ライブラリのビルド時のものとは異なる場合があり、ライブラリの構成はあまり意味がないことがわかります。それにもかかわらず、時にはライブラリの設定はまだ意味があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストを書くときの状況。テストは通常​​ClassLibraryにあり、リダイレクトも必要です。テストフレームワークは、テストを含むライブラリにdll-configがあることを認識し、そこにあるリダイレクトをテストからのコードと交換します。これらのリダイレクトは自動的に生成できます。古いフォーマットがある場合</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDKスタイルではなく、簡単な方法で、OutputTypeをExeに変更し、空のエントリポイントを追加できます。これにより、MSBuildでリダイレクトが生成されます。別の方法でハックを使用できます。別のプロパティを</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">追加することができます</font><font style="vertical-align: inherit;">。これにより、MSBuildは、このOutputTypeについてもバインドリダイレクトを生成する必要があると見なします。この方法はハックのように見えますが、Exeでやり直すことができないライブラリや他のタイプのプロジェクト（テストを除く）のリダイレクトを生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい形式の場合、</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のMicrosoft.NET.Test.Sdkを使用すると</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">リダイレクト自体が生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のヒント：NuGetではバインディングリダイレクト生成を使用しないでください。 NuGetには、パッケージから最新バージョンに渡すライブラリのバインディングリダイレクトを生成する機能がありますが、これは最良のオプションではありません。これらのリダイレクトはすべて追加し</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てコミットする必要があります。MSBuildを使用してリダイレクトを生成すると、ビルド中にリダイレクトが生成されます。それらをコミットすると、マージの競合が発生する可能性があります。自分でファイル内のBindingリダイレクトを更新するのを忘れることができます。ビルド中に生成された場合でも、忘れることはありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリ参照の解決</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バインディングリダイレクトの生成</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バインディングリダイレクトの生成がどのように機能するかをより深く理解したい人のための宿題：コードがどのように機能するかを確認し、これをコードで確認してください。 .NETディレクトリに移動し、生成を有効にするために使用されるnameプロパティを使用して、どこにでも移動します。これは一般的にこのような一般的なアプローチです。MSBuildに奇妙なプロパティがある場合は、その使用を利用できます。幸い、プロパティは通常XML構成で使用され、その使用法を簡単に見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのXMLターゲットの内容を調べると、このプロパティが2つのMSBuildタスクをトリガーすることがわかります。最初のタスクはと呼ば</font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ、ファイルに書き込まれる一連のリダイレクトを生成します。 2番目のタスク</font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、最初のタスクの結果を</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最初のタスクの操作をわずかに修正し、不要なリダイレクトを削除したり、新しいリダイレクトを追加したりするXMLロジックがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XML構成の代替</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XML構成でリダイレクトを保持することが常に便利であるとは限りません。</font><font style="vertical-align: inherit;">アプリケーションがプラグインをダウンロードする状況があり、このプラグインはリダイレクトを必要とする他のライブラリを使用しています。</font><font style="vertical-align: inherit;">この場合、必要なリダイレクトのセットを認識していないか、XMLを生成したくない場合があります。</font><font style="vertical-align: inherit;">このような状況では、AppDomainを作成し、作成時に、必要なリダイレクトを含むXMLが配置されているAppDomainに転送することができます。</font><font style="vertical-align: inherit;">実行時にアセンブリの読み込みエラーを直接処理することもできます。</font><font style="vertical-align: inherit;">Rantime .NETはそのような機会を提供します。</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントがあり、と呼ばれてい</font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。このイベントをサブスクライブすると、失敗したすべてのアセンブリダウンロードに関するエラーが表示されます。読み込まれなかったアセンブリの名前を取得し、最初のアセンブリの読み込みを要求したアセンブリアセンブリを取得します。ここでは、適切な場所から手動でアセンブリを読み込むことができます。たとえば、バージョンをドロップし、ファイルから取得し、ハンドラーからこのイベントを返します。または、アセンブリをロードできない場合、何も返さない場合はnullを返します。 PublicKeyTokenは同じである必要があります。PublicKeyTokenが異なるアセンブリは互いに友好的ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このイベントは、1つのアプリケーションドメインにのみ適用されます。</font><font style="vertical-align: inherit;">プラグインが内部にAppDomainを作成する場合、ランタイムでのこのリダイレクトはそれらで機能しません。</font><font style="vertical-align: inherit;">プラグインが作成したすべてのAppDomainでこのイベントをサブスクライブする必要があります。</font><font style="vertical-align: inherit;">AppDomainManagerを使用してこれを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManagerは、特定のインターフェイスを実装するクラスを含む独立したアセンブリです。このインターフェイスのメソッドの1つを使用すると、アプリケーションで作成された新しいAppDomainを初期化できます。</font><font style="vertical-align: inherit;">AppDomainが作成されると、このメソッドが呼び出されます。</font><font style="vertical-align: inherit;">その中で、あなたはこのイベントを購読することができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密なアセンブリ読み込みと.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Coreでは、「厳密なアセンブリの読み込み」と呼ばれる問題はありません。これは、署名されたアセンブリが要求されたバージョンを正確に必要とするためです。別の要件があります。すべてのアセンブリについて、厳密な名前で署名されているかどうかに関係なく、ランタイムで読み込まれたバージョンが以前のバージョン以上であることが確認されます。プラグインを使用するアプリケーションの状況にある場合、たとえば、新しいバージョンのSDKからプラグインが収集され、それがダウンロードされたアプリケーションがこれまでのバージョンのSDKを使用していて、ばらばらになるのではなく、このイベントをサブスクライブすることもできますが、すでに.NET Coreにあり、所有しているアセンブリをロードすることもできます。このコードを書くことができます：</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起動しなかったアセンブリの名前を取得し、バージョンを無効に</font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、同じバージョンから</font><font style="vertical-align: inherit;">呼び出します</font><font style="vertical-align: inherit;">。ここでは再帰を確認したので、再帰はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyUtilsバージョン0.0.2.0をダウンロードする必要がありました。 BINには、MyUtilsバージョン0.0.1.0があります。バージョン0.0.2.0からバージョン0.0にリダイレクトしました。バージョン0.0.1.0はロードされません。出口は、バージョン0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリをロードすることができなかったことを示します</font><font style="vertical-align: inherit;">。 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versionクラスでは、すべてのコンポーネントが必須ではなく、オプションのコンポーネント–1の代わりに格納されますが、内部のどこかでオーバーフローが発生し、2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が取得され</font><font style="vertical-align: inherit;">ます。興味があれば、オーバーフローが発生した場所を正確に見つけることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リフレクションアセンブリを使用していて、すべてのタイプを取得したい場合、すべてのタイプがGetTypesメソッドを取得できるわけではない場合があります。アセンブリには、読み込まれていないアセンブリ内にある別のクラスを継承するクラスがあります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、問題はReflectionTypeLoadExceptionがスローされることです。</font><font style="vertical-align: inherit;">内部</font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、まだロードできたタイプが存在するプロパティがあります。</font><font style="vertical-align: inherit;">すべての一般的なライブラリがこのことを考慮しているわけではありません。</font><font style="vertical-align: inherit;">AutoMapper、そのバージョンの少なくとも1つがReflectionTypeLoadExceptionに直面した場合、例外の内部からタイプを選択するのではなく、ただ落ちました。</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強い命名</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密な</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">名前のアセンブリ</font></a><font style="vertical-align: inherit;">厳密なアセンブリの読み込みの原因について説明しましょう。これは厳密な名前です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密な名前は、非対称暗号化を使用する秘密キーによるアセンブリの署名です。 PublicKeyTokenは、このアセンブリの公開キーハッシュです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密な名前を付けると、同じ名前の異なるアセンブリを区別できます。たとえば、MyUtilsは一意の名前ではありません。その名前のアセンブリが複数存在する可能性がありますが、厳密な名前に署名すると、それらのパブリックキートークンが異なり、このように区別できます。一部のアセンブリ読み込みシナリオでは厳密な名前が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、アセンブリをグローバルアセンブリキャッシュにインストールするため、または同時に複数のバージョンを並べてダウンロードするためなどです。</font><font style="vertical-align: inherit;">最も重要なのは、厳密な名前付きアセンブリが他の厳密な名前付きアセンブリのみを参照できることです。</font><font style="vertical-align: inherit;">一部のユーザーは厳密な名前でビルドに署名することを望んでいるため、ライブラリ開発者もライブラリに署名します。これにより、ユーザーがそれらをインストールしやすくなり、ユーザーがこれらのライブラリに再署名する必要がなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密な名前：レガシー？</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密な名前付けと.NETライブラリ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoftは、セキュリティの目的で厳密な名前を使用しないで、同じ名前の異なるアセンブリを区別するためだけに提供することをMSDNで明示的に言っています。アセンブリキーはどのような方法でも変更できません。変更すると、すべてのユーザーへのリダイレクトが中断されます。厳密な名前のキーの秘密部分がパブリックアクセスに漏洩した場合、この署名を撤回することはできません。厳密な名前が配置されているSNKファイル形式はそのような機会を提供しません。また、キーを保存するための他の形式には、少なくともCRL証明書失効リストへのリンクが含まれます。これにより、この証明書は有効ではなくなったことがわかります。 SNKにはそのようなものはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オープンソースガイドには、次の推奨事項があります。まず、セキュリティの目的で他のテクノロジーを使用します。次に、オープンソースライブラリがある場合は、一般に、キーのプライベート部分をリポジトリにコミットすることをお勧めします。これにより、ライブラリをフォークして再構築し、既製のアプリケーションに配置するのが簡単になります。 3番目に、厳密な名前を変更しないでください。破壊的すぎる。破壊的すぎてオープンソースガイドに記載されているにもかかわらず、Microsoftは独自のライブラリに問題がある場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
System.Reactiveというライブラリがあります。</font><font style="vertical-align: inherit;">以前は、これらはいくつかのNuGetパッケージでしたが、そのうちの1つはRx-Linqです。</font><font style="vertical-align: inherit;">これは単なる例であり、他のパッケージでも同じです。</font><font style="vertical-align: inherit;">2番目のバージョンでは、Microsoftキーで署名されていました。</font><font style="vertical-align: inherit;">3番目のバージョンでは、彼は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトのリポジトリに移動し、</font><font style="vertical-align: inherit;">.NET Foundationの署名を付け始めました。</font><font style="vertical-align: inherit;">ライブラリは、実際には、厳密な名前を変更しました。</font><font style="vertical-align: inherit;">NuGetパッケージの名前が変更されましたが、アセンブリは以前とまったく同じように内部で呼び出されます。</font><font style="vertical-align: inherit;">2番目のバージョンから3番目のバージョンにリダイレクトする方法は？</font><font style="vertical-align: inherit;">このリダイレクトは実行できません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密な名前の検証</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法：厳密な名前のバイパス機能を無効にする</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密な名前は過去のものであり、純粋に正式なままであるというもう1つの主張は、検証されていないということです。署名されたアセンブリがあり、それにある種のバグを修正したいのですが、ソースにアクセスできません。 dnSpyを使用できます。これは、既にコンパイルされたアセンブリを逆コンパイルして修正できるユーティリティです。すべてがうまくいきます。デフォルトでは、厳密な名前の検証バイパスが有効になっているため、PublicKeyTokenが等しいかどうかのみがチェックされ、署名自体の整合性はチェックされません。署名がまだ検証されている環境調査があるかもしれません、そしてここで鮮やかな例はIISです。署名の整合性はIISでチェックされ（強力な名前検証バイパスはデフォルトで無効になっています）、署名されたアセンブリを編集するとすべてが壊れます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加：</font></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリックサイン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、アセンブリの署名検証を無効にすることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます。</font></a><font style="vertical-align: inherit;">これにより、署名には公開鍵のみが使用され、アセンブリ名の安全性が確保されます。 Microsoftが使用する公開鍵は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掲載されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Riderでは、プロジェクトのプロパティでパブリックサインを有効にできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルアセンブリのバージョンを変更するタイミング</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オープンソースガイドは、いくつかのバージョン管理ポリシーも提供します。その目的は、NET Framework上のユーザーが必要とするバインドリダイレクトとそれらへの変更の数を減らすことです。このバージョン管理ポリシーでは、アセンブリバージョンを常に変更しないでください。もちろん、これはGACでのインストールに問題を引き起こす可能性があるため、インストールされたネイティブイメージがアセンブリに対応していない可能性があり、JITコンパイルを再度実行する必要がありますが、私の意見では、これはバージョン管理の問題ほど危険ではありません。 CrossGenの場合、ネイティブアセンブリはグローバルにインストールされません-問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、NuGetパッケージNewtonsoft.Jsonには、12.0.1、12.0.2などのいくつかのバージョンがあります。これらのすべてのパッケージには、バージョン12.0.0.0のアセンブリがあります。</font><font style="vertical-align: inherit;">NuGetパッケージのメジャーバージョンが変更された場合は、アセンブリバージョンを更新することをお勧めします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Frameworkのヒントに従ってください。リダイレクトを手動で生成し、ソリューション内のすべてのプロジェクトで同じバージョンの依存関係を使用してみてください。</font><font style="vertical-align: inherit;">これにより、リダイレクトの数が大幅に最小限になります。</font><font style="vertical-align: inherit;">厳密な名前付けが必要なのは、必要な特定のビルド読み込みシナリオがある場合、またはライブラリを開発していて、厳密な名前付けが本当に必要なユーザーの生活を簡素化したい場合のみです。</font><font style="vertical-align: inherit;">厳密な名前は変更しないでください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET標準</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Standardに合格します。 .NET FrameworkのVersion hellとかなり密接に関連しています。 .NET Standardは、.NETプラットフォームのさまざまな実装と互換性のあるライブラリを作成するためのツールです。実装とは、.NET Framework、.NET Core、Mono、Unity、およびXamarinを指します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*ドキュメントへのリンク</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、さまざまなバージョンのランタイムのさまざまなバージョンの.NET標準サポートテーブルです。ここで、.NET Frameworkが.NET Standardバージョン2.1をサポートしていないことがわかります。 .NET Standard 2.1以降をサポートする.NET Frameworkのリリースはまだ計画されていません。ライブラリを開発していて、それを.NET Frameworkのユーザーが機能できるようにするには、.NET Standard 2.0のターゲットが必要です。 .NET Frameworkが最新バージョンの.NET Standardをサポートしていないという事実に加えて、アスタリスクに注目しましょう。 .NET Framework 4.6.1は.NET Standard 2.0をサポートしていますが、アスタリスクが付いています。ドキュメントに直接このような脚注があり、どこでこの表を入手しましたか。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルプロジェクトを考えてみましょう。 .NET標準を対象とする1つの依存関係を持つ.NET Framework上のアプリケーション。このようなもの：ConsoleAppとClassLibrary。ターゲットライブラリ.NET標準。このプロジェクトをまとめると、BINでは次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこには100のDLLがあり、そのうち1つだけがアプリケーションに関連し、他のすべては.NET標準をサポートするために来ました。事実、.NET Standard 2.0は.NET Framework 4.6.1よりも後に登場しましたが、同時にAPI互換であることが判明し、開発者は.NET 4.6.1にStandard 2.0サポートを追加することを決定しました。 （</font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイム自体に</font><font style="vertical-align: inherit;">含めることにより）ネイティブではありません</font><font style="vertical-align: inherit;">が、.NET Standard * .dllおよびその他のすべてのアセンブリファサードが直接BINに配置されるようにしています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対象とする.NET Frameworkのバージョンの依存関係と、BINに分類されるライブラリの数を見ると、4.7.1ではそれほど多くなく、4.7.2以降、追加のライブラリはありません。標準はそこでネイティブにサポートされています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは.NET開発者の1人からのツイートです。この問題について説明し、.NET標準ライブラリがある場合は.NET Frameworkバージョン4.7.2の使用を推奨しています。</font><font style="vertical-align: inherit;">ここでもバージョン2.0ではなく、バージョン1.5です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能であれば、プロジェクトのターゲットフレームワークを少なくとも4.7.1、できれば4.7.2に上げます。</font><font style="vertical-align: inherit;">ライブラリユーザーの生活を楽にするためにライブラリを開発している場合は、.NET Frameworkの個別のターゲットを作成すると、何かと競合する可能性がある多数のdllが回避されます。</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な理論から始めましょう。</font><font style="vertical-align: inherit;">JetBrains Riderを.NET Coreでどのように起動したか、そしてなぜそれについて話す必要があるのか​​について説明します。</font><font style="vertical-align: inherit;">Riderは非常に大規模なプロジェクトであり、多数の異なるプロジェクト、依存関係の複雑なシステムを備えた巨大なエンタープライズソリューションを備えており、一度に別のランタイムに移行することはできません。</font><font style="vertical-align: inherit;">これを行うには、いくつかのハックを使用する必要があります。これも分析します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Coreアプリケーション</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的な.NET Coreアプリケーションはどのように見えますか？それがどのように正確に展開されるか、最終的には何になるかによって異なります。いくつかのシナリオが考えられます。 1つ目は、フレームワークに依存した展開です。これは、アプリケーションがコンピューターにプリインストールされているランタイムを使用する場合の.NET Frameworkと同じです。これは自己完結型のデプロイメントにすることができます。これは、アプリケーションがランタイムを実行するときです。そして、単一ファイルの展開がある場合があります。これは、1つのexeファイルを取得したときですが、このexeファイル内の.NET Coreの場合、自己完結型アプリケーションのアーティファクトがあり、これは自己解凍アーカイブです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームワークに依存した展開のみを検討します。アプリケーションにdllがあり、2つの構成ファイルがあります。最初のファイルは必須で、これ</font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">.NET Core 3.0以降では、アプリケーションの実行をより便利にするために必要なexeファイルが生成されるため、Windowsの場合は.NETコマンドを入力する必要はありません。</font><font style="vertical-align: inherit;">依存関係はこのアーティファクトに分類されます。.NETCore 3.0以降、.NET Core 2.1では、で別のプロパティを発行または使用する必要があります</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有フレームワーク、 </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行に必要なランタイム設定が含まれています。これは、アプリケーションがどの共有フレームワークで起動されるかを示し、次のようになります。アプリケーションは「Microsoft.NETCore.App」バージョン3.0.0で実行されることを示していますが、他の共有フレームワークが存在する可能性があります。他の設定もここにあります。たとえば、サーバーのガベージコレクターを有効にすることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトのアセンブリ中に生成されます。サーバーGCを有効にする場合は、プロジェクトをアセンブルする前、または手動で追加する前であっても、このファイルを何らかの方法で事前に変更する必要があります。このようにここに設定を追加できます。プロパティをに含めることができます</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そのようなプロパティが.NET開発者によって提供されている場合、またはプロパティが提供されていない場合は、というファイルを作成できます。</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに必要な設定を書き込みます。アセンブリ中に、他の必要な設定、たとえば同じ共有フレームワークがこのテンプレートに追加されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有フレームワークは、ランタイムとライブラリのセットです。実際、.NET Frameworkランタイムと同じものは、マシンに一度インストールするだけで、すべてのバージョンで1つのバージョンでした。共有フレームワーク、および単一の.NET Frameworkランタイムとは異なり、バージョンを付けることができます。アプリケーションごとに、インストールされているランタイムのバージョンを変えることができます。また、共有フレームワークを継承できます。共有フレームワーク自体は、通常システムにインストールされているディスク上の場所に表示できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のコンソールアプリケーションを実行するMicrosoft.NETCore.App、Webアプリケーション用のAspNetCore.App、デスクトップアプリケーションを実行する.NET Core 3の新しい共有フレームワークであるWindowsDesktop.Appなど、いくつかの標準的な共有フレームワークがあります。 WindowsフォームとWPF。最後の2つの共有フレームワークは、基本的にコンソールアプリケーションに必要な最初のフレームワークを補完します。つまり、まったく新しいランタイムを実行するのではなく、既存のフレームワークに必要なライブラリを追加するだけです。この継承は</font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、基本の共有フレームワークが指定さ</font><font style="vertical-align: inherit;">れている共有フレームワークディレクトリ</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">もあるよう</font><font style="vertical-align: inherit;">です。</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係マニフェスト（</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのプローブ-.NET Core</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2番目の構成ファイルはこれ</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このファイルには、アプリケーションまたは共有フレームワーク、またはライブラリのすべての依存関係の説明が含まれており、ライブラリに</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も含まれています。推移的なものを含むすべての依存関係が含まれています。また、.NET Coreランタイムの動作は、</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション</font><font style="vertical-align: inherit;">にあるかどうかによって異なります</font><font style="vertical-align: inherit;">。そうで</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない場合、アプリケーションは共有フレームワークまたはBINディレクトリにあるすべてのアセンブリをロードできます。存在する場合</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、検証が有効になります。にリストされているアセンブリの1つがそうで</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない場合、アプリケーションは単純に起動しません。上記のエラーが表示されます。アプリケーションが実行時にアセンブリをロードしようとした場合、</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> たとえば、アセンブリの読み込み方法を使用する場合、またはアセンブリの解決プロセス中に、厳密なアセンブリの読み込みと非常によく似たエラーが表示されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetbrainsライダー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライダーは.NET IDEです。 RiderがIntelliJ IDEAに基づくJavaとKotlinで記述されたフロントエンドとバックエンドで構成されるIDEであることを誰もが知っているわけではありません。バックエンドは基本的にR＃であり、IntelliJ IDEAと通信できます。このバックエンドは現在、クロスプラットフォームの.NETアプリケーションです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どこで実行されますか？ Windowsは、ユーザーのコンピューターにインストールされている.NET Frameworkを使用します。他の情報システム、LinuxおよびMacでは、Monoが使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どこにでも異なるランタイムがある場合、これは理想的なソリューションではありません。Riderが.NET Coreで実行できるように、次の状態に移行したいと考えています。 .NET Coreではすべての最新機能がこれに関連付けられているため、パフォーマンスを向上させるために。メモリ消費を削減する。今、Monoがメモリでどのように機能するかに関する問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Coreに切り替えると、レガシーでサポートされていないテクノロジーを放棄し、ランタイムで見つかった問題のいくつかの修正を修正できます。</font><font style="vertical-align: inherit;">.NET Coreに切り替えると、ランタイムのバージョンを制御できるようになります。つまり、Riderは、ユーザーのコンピューターにインストールされている.NET Frameworkではなく、自己完結型の展開として禁止できる.NET Coreの特定のバージョンで実行されます。</font><font style="vertical-align: inherit;">.NET Coreへの移行により、最終的にはCoreに特別にインポートされた新しいAPIを使用できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの目標は、プロトタイプを起動してそれを起動し、それがどのように機能するか、潜在的な障害点は何か、どのコンポーネントを再度書き換える必要があるか、グローバルな処理が必要になるかを確認することです。</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riderを.NET Coreに変換することを困難にする機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studioは、R＃がインストールされていなくても、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDKスタイル* .csprojのプロジェクトが存在する大規模なソリューションでメモリ不足からクラッシュします</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">SDKスタイル* .csprojは、完全な.NET Core再配置の主な条件の1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RiderはR＃に基づいているため、これは問題です。R＃は同じリポジトリに存在し、R＃開発者はVisual Studioを使用して自社製品を開発し、それを食品にしたいと考えています。</font><font style="vertical-align: inherit;">R＃には、何かを行う必要があるフレームワーク用のリンク固有のライブラリがあります。</font><font style="vertical-align: inherit;">Windowsでは、デスクトップアプリケーションのフレームワークを使用できます。LinuxおよびMacでは、最小限の機能を備えたWindowsライブラリでMockがすでに使用されています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは今のところ古いものを使い続け</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、完全なフレームワークの下でアセンブル</font><font style="vertical-align: inherit;">することにしました</font><font style="vertical-align: inherit;">が、フレームワークとコアのアセンブリはバイナリ互換であるため、コア上で実行します。</font><font style="vertical-align: inherit;">互換性のない機能は使用せず、必要なすべての構成ファイルを手動で追加し、.NET Coreの依存関係の特別なバージョンがあればダウンロードします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのハックに行かなければなりませんでしたか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのハック：フレームワークでのみ使用可能なメソッドを呼び出します。たとえば、このメソッドはR＃では必要ですが、コアでは必要ありません。</font><font style="vertical-align: inherit;">問題は、メソッドがない場合、JITコンパイル中にそれを呼び出すメソッドが早く落ちること</font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">つまり、存在しないメソッドは、それを呼び出すメソッドを台無しにしました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は次のとおりです。互換性のないメソッドを個別のメソッドに呼び出します。もう1つの問題があります。そのようなメソッドはインラインになる可能性があるため、属性でマークします</font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のハック：相対パスでアセンブリをロードできる必要があります。フレームワーク用に1つのアセンブリがあり、.NET Core用の特別なバージョンがあります。 .NET Coreの.NET Coreバージョンをダウンロードするにはどうすればよいですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは私たちを助けます</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Diagnostics.PerformanceCounterライブラリを</font><font style="vertical-align: inherit;">見てみましょう</font><font style="vertical-align: inherit;">。このようなライブラリは、その点で注目に値します</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ランタイムセクションがあり、相対パスを持つライブラリの1つのバージョンが示されています。このライブラリは、アセンブリがすべてのランタイムに読み込まれ、実行をスローするだけです。たとえば、Linuxでロードした場合、PerformanceCounterはLinuxでの設計では機能せず、そこからPlatformNotSupportedExceptionが発生します。これには</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runtimeTargetsセクション</font><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">あります。ここには、PerformanceCounterが機能するWindows専用のこのアセンブリのバージョンが既に示されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランタイムセクションを取得して、ロードするライブラリへの相対パスを書き込む場合、これは役に立ちません。ランタイムセクションは、実際にはBINからの相対パスではなく、NuGetパッケージ内の相対パスを設定します。このアセンブリをBINで検索すると、そこからファイル名のみが使用されます。 runtimeTargetsセクションには、正直な相対パス、BINに対する相対パスがすでに含まれています。 runtimeTargetsセクションでアセンブリの相対パスを規定します。ここでは「勝つ」ランタイム識別子の代わりに、好きな別のものを使用できます。たとえば、ランタイム識別子は「any」と記述し、このアセンブリは通常すべてのプラットフォームにロードされます。または、「unix」と書いて、LinuxやMacなどで起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のハック：WindowsBaseを構築するために、LinuxとMac Mockにダウンロードしたいと思います。問題は、</font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windowsを使用していない場合でも</font><font style="vertical-align: inherit;">、WindowsBaseという名前のアセンブリが共有フレームワークに既に存在し</font><font style="vertical-align: inherit;">ていることです。 Windows共有フレームワークでは、</font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBaseはにあるバージョンを再定義し</font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのフレームワーク、より正確にはWindowsBaseを説明するセクションを</font><font style="vertical-align: inherit;">見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの違いは次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのライブラリ競合とは、いくつかの中に存在している場合は</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、それらの最大のペアのために選択されている</font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 .NETガイドでは</font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Windowsエクスプローラーで表示するだけでよいと記載されていますが、必要ではありません。</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">規定されているバージョン</font><font style="vertical-align: inherit;">が実際に使用</font><font style="vertical-align: inherit;">されたときに知っている唯一のケースです</font><font style="vertical-align: inherit;">。他のすべての場合では、どのバージョン</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で書き込まれたとしても、アセンブリは引き続きロードされ続ける</font><font style="vertical-align: inherit;">という動作がありまし</font><font style="vertical-align: inherit;">た。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4番目のハック。タスク：前の2つのハッキング用の.deps.jsonファイルがあり、特定の依存関係に対してのみ必要です。それらは</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半手動モードで生成されるので、そこに到達する必要があるもののいくつかの説明に従って、ビルド中にそれを生成するスクリプトがあります。これを</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小限にして、その中の内容を理解できるようにします。検証を無効にして、BINにあるがで説明されていないアセンブリのダウンロードを許可します</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策：runtimeconfigでカスタム構成を有効にします。</font><font style="vertical-align: inherit;">この設定は、.NET Core 1.0との下位互換性のために実際に必要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、</font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETのコアに-これらは、類似体の一種です</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じことをしてみましょう。たとえば、相対的な方法でアセンブリをロードします。</font><font style="vertical-align: inherit;">を使用し</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て手動で書き換え、非常に複雑なシナリオがある場合は、.NET Coreでのアセンブリのロードをカスタマイズできます。</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリダウンロードのデバッグ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの種類の問題について説明したので、アセンブリの読み込みに関する問題をデバッグできる必要があります。</font><font style="vertical-align: inherit;">これで何ができますか？</font><font style="vertical-align: inherit;">まず、ランタイムは、アセンブリの読み込み方法に関するログを書き込みます。</font><font style="vertical-align: inherit;">第二に、あなたはあなたに飛ぶ処刑をより詳しく見ることができます。</font><font style="vertical-align: inherit;">ランタイムイベントに集中することもできます。</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">融合ログ</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本に戻る：Fusionログビューアを使用して不明瞭なエラーをデバッグする</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
.NET FrameworkでアセンブリをロードするメカニズムはFusionと呼ばれ、ディスクに何をしたかを記録する方法を知っています。ログを有効にするには、レジストリに特別な設定を追加する必要があります。これはあまり便利ではないため、Fusion Log ViewerやFusion ++などのユーティリティを使用することは理にかなっています。 Fusion Log Viewerは、Visual Studioに付属する標準ユーティリティであり、Visual StudioコマンドラインであるVisual Studio Developer Command Promptから起動できます。 Fusion ++は、このツールのオープンソースアナログで、インターフェイスが優れています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion Log Viewerは次のようになります。このウィンドウは拡大さえしないので、WinDbgよりも悪いです。それでも、どのチェックマークのセットが正しいかが常に明確であるとは限りませんが、ここでチェックマークに穴を開けることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++には「ログの開始」ボタンが1つあり、「ログの停止」ボタンが表示されます。その中で、アセンブリの読み込みに関するすべてのレコードを確認し、正確に何が起こっていたかに関するログを読み取ることができます。これらのログは、このように簡潔に表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Strictアセンブリのロードからの免除です。</font><font style="vertical-align: inherit;">Fusionのログを見ると、すべての構成を処理した後でバージョン9.0.0.0をダウンロードする必要があることがわかります。</font><font style="vertical-align: inherit;">必要なアセンブリがあることが疑われるファイルが見つかりました。</font><font style="vertical-align: inherit;">このファイルにはバージョン6.0.0.0が含まれていることがわかりました。</font><font style="vertical-align: inherit;">アセンブリの完全な名前を比較したという警告があり、メジャーバージョンでは異なります。</font><font style="vertical-align: inherit;">そして、エラーが発生しました-バージョンの不一致。</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムイベント</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムイベントのロギング</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Monoでは、環境変数を使用してロギングを有効にできます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ログは最終的に</font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">に書き込まれ</font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。それほど便利ではありませんが、ソリューションは機能しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのプローブ-.NET Core </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント/設計ドキュメント/ホストトレース</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
.NET Coreには、</font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログインを含む</font><font style="vertical-align: inherit;">特別な環境変数</font><font style="vertical-align: inherit;">もあります</font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 .NET Core 3.0では、変数へのパスを指定することで、ログをファイルに書き込むことができます</font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブリの読み込みに失敗したときに発生するイベントがあります。これはイベント</font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。 2番目の便利なイベントであるthisがあり</font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。誰かがtry..catchを書いて、場所ですべての実行を逃した場合でも、それをサブスクライブしてアセンブリのロードに関するエラーを取得できます。</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生した。</font><font style="vertical-align: inherit;">アプリケーションがすでにコンパイルされている場合は、アプリケーションを起動して</font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、.NETの実行を監視し、ダウンロードファイルに関連するものをそこで見つけることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業をツール、開発ツール、IDE、MSBuildに転送します。これにより、リダイレクトを生成できます。</font><font style="vertical-align: inherit;">.NET Coreに切り替えると、Strict Assembly Loadingが何であるかを忘れて、Riderで実現したいのと同じように新しいAPIを使用できるようになります。</font><font style="vertical-align: inherit;">.NET標準ライブラリを接続する場合は、.NET Frameworkのターゲットバージョンを少なくとも4.7.1に上げます。</font><font style="vertical-align: inherit;">絶望的な状況にあると思われる場合は、ハックを探すか、ハックを使用するか、または絶望的な状況のために独自のハックを考えてください。</font><font style="vertical-align: inherit;">そしてデバッグツールで武装してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のリンクをお読みになることを強くお勧めします。</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499824/index.html">2020年5月の人事およびIT採用担当者向けのイベントのダイジェスト</a></li>
<li><a href="../ja499826/index.html">分布した血圧</a></li>
<li><a href="../ja499832/index.html">従業員のリモート作業を迅速かつ安全に整理する方法は？さまざまなアプローチについて話します。VDIを使用するだけでなく、</a></li>
<li><a href="../ja499834/index.html">Felix Arithmometerの紹介</a></li>
<li><a href="../ja499836/index.html">ウダレンカ対 開発チームのためのオフィス</a></li>
<li><a href="../ja499842/index.html">なぜ人々は再学習するのですか</a></li>
<li><a href="../ja499846/index.html">個別のガベージコレクションが機能し始める時期と、ガベージコンテナのサイトのビデオ監視が必要な理由</a></li>
<li><a href="../ja499850/index.html">競合他社を分析し、40分でデジタル戦略を設定する方法</a></li>
<li><a href="../ja499852/index.html">Angularの英語ドキュメント</a></li>
<li><a href="../ja499854/index.html">Apache Bigtopと今日のHadoopディストリビューションの選択</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>