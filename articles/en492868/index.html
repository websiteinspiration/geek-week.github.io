<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüíª üöº üêì String optimization in ClickHouse. Yandex Report ü§∂üèø ü§ûüèª üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The ClickHouse analytic database engine processes many different lines, consuming resources. To speed up the system, new optimizations are constantly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>String optimization in ClickHouse. Yandex Report</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/492868/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ClickHouse analytic database engine processes many different lines, consuming resources. </font><font style="vertical-align: inherit;">To speed up the system, new optimizations are constantly being added. </font><font style="vertical-align: inherit;">ClickHouse developer Nikolay Kochetov talks about the string data type, including the new type, LowCardinality, and explains how to speed up work with strings.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/rqf-ILRgBdY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- First, let's see how you can store strings. </font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/ch/9s/zs/ch9szsqfnkkvpmjjxoo0lmpacno.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have string data types. </font><font style="vertical-align: inherit;">String works well by default, it should be used almost always. </font><font style="vertical-align: inherit;">It has a small Overhead - 9 bytes per line. </font><font style="vertical-align: inherit;">If we want the row size to be fixed and known in advance, it is better to use FixedString. </font><font style="vertical-align: inherit;">In it you can set the number of bytes we need, it is convenient for data such as IP addresses or hash functions. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/lx/mo/rdlxmobm0ch5l88ab74sszn_fps.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, sometimes something slows down. </font><font style="vertical-align: inherit;">Suppose you are making a query on a table. </font><font style="vertical-align: inherit;">ClickHouse reads a fairly large amount of data, say, at a speed of 100 GB / s, with few lines being processed. </font><font style="vertical-align: inherit;">We have two tables that store almost the same data. </font><font style="vertical-align: inherit;">ClickHouse reads data from the second table at a higher speed, but it reads three times less rows per second.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nd/tz/6l/ndtz6l6-1pwaycgcoxhslfj2hcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we look at the size of the compressed data, it will be almost equal. In fact, the same data is written in the tables - the first billion numbers - only in the first column are they written in the form of UInt64, and in the second column in String. Because of this, the second query reads data from the disk longer and decompresses it. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i8/a2/vf/i8a2vfterxcfto5foypz6tig3zy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is another example. Suppose that there is a predetermined set of lines, it is limited to a constant of 1000 or 10,000 and almost never changes. For this case, the Enum data type is suitable for us, in ClickHouse there are two of them - Enum8 and Enum16. Due to storage in Enum, we quickly process requests.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ClickHouse has accelerations for GROUP BY, IN, DISTINCT and optimizations for some functions, for example, for comparison with a constant string. Of course, the numbers in the string are not converted, but, on the contrary, the constant string is converted to the value Enum. After that, everything is quickly compared. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there are also disadvantages. Even if we know the exact set of lines, sometimes it needs to be replenished. A new line has arrived - we have to do ALTER. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b0/ay/sz/b0ayszedkf252ktki2xizo2fxfm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ALTER for Enum in ClickHouse is optimally implemented. We do not overwrite the data on the disk, but ALTER can slow down due to the fact that Enum structures are stored in the schema of the table itself. Therefore, we must wait for read requests from the table, for example.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The question is, can one do better? Maybe yes. You can save the Enum structure not in the table schema, but in ZooKeeper. However, synchronization problems may occur. For example, one replica received data, the other did not, and if it has an old Enum, then something will break. (In ClickHouse, we almost completed the non-blocking ALTER requests. When we finish them completely, we won‚Äôt have to wait for read requests.) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yf/rc/vj/yfrcvjamitxxi5taditsaouvrl4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order not to mess with ALTER Enum, you can use external ClickHouse dictionaries. Let me remind you that this is a key-value data structure inside ClickHouse, with which you can get data from external sources, for example, from MySQL tables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the ClickHouse dictionary, we store many different lines, and in the table their identifiers in the form of numbers. If we need to get a string, we call the dictGet function and work with it. After that we should not do ALTER. To add something to Enum, we insert this into the same MySQL table. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there are other problems. Firstly, the awkward syntax. If we want to get a string, we must call dictGet. Secondly, the lack of some optimizations. Comparison with the constant string for dictionaries is also not quick to do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There may still be problems with the update. Suppose we requested a line in the cache dictionary, but it did not get into the cache. Then we have to wait until the data is loaded from an external source.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/em/4z/ii/em4ziibqzsukh-mvfu2o8dpncv0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A common drawback of both methods is that we store all the keys in one place and synchronize them. </font><font style="vertical-align: inherit;">So why not store dictionaries locally? </font><font style="vertical-align: inherit;">No synchronization - no problem. </font><font style="vertical-align: inherit;">You can store the dictionary locally in a piece on disk. </font><font style="vertical-align: inherit;">That is, we did Insert, recorded a dictionary. </font><font style="vertical-align: inherit;">If we work with data in memory, we can write a dictionary either to a data block, or to a piece of a column, or to some cache to speed up the calculations.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vocabulary String Encoding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So we came to the creation of a new data type in ClickHouse - LowCardinality. This is a format for storing data: how they are written to disk and how they are read, how they are presented in memory and the scheme of their processing. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5h/5e/se5h5er0yccult4fjfamsksw4rk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are two columns on the slide. On the right, strings are stored standardly in the String type. It can be seen that these are some kind of mobile phone models. On the left there is exactly the same column, only in the LowCardinality type. It consists of a dictionary with many different lines (lines from the column on the right) and a list of positions (line numbers). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using these two structures, you can restore the original column. There is also a reverse inverse index - a hash table that helps you find the position in the dictionary by line. It is needed to speed up some queries. For example, if we want to compare, look for a line in our column or merge them together.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LowCardinality is a parametric data type. It can be either a number, or something that is stored as a number, or a string, or Nullable from them. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/et/r4/h9/etr4h9fjutj5sf6ffxqjmf04xpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The peculiarity of LowCardinality is that it can be saved for some functions. An example request is shown on the slide. In the first line, I created a column of type LowCardinality from String, named it S. Then I asked her name - ClickHouse said that it was LowCardinality from String. All right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third line is almost the same, only we called the length function. In ClickHouse, the length function returns the UInt64 data type. But we got LowCardinality from UInt64. What's the point?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6h/hs/0x/6hhs0xgy2-hnsc8tputwp8ukqqu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The names of mobile phones were stored in the dictionary, we applied the length function. Now we have a similar dictionary, consisting only of numbers, these are the lengths of strings. The column with the positions has not changed. As a result, we processed less data, saved on request time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There may be other optimizations, such as adding a simple cache. When calculating the value of a function, you can remember it and make it the same, do not re-calculate.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimization can also be done GROUP BY, because our column with the dictionary is already partially aggregated - you can quickly calculate the value of the hash functions and approximately find the bucket where to put the next line. You can also specialize some aggregate functions, for example uniq, because you can send only a dictionary to it, and leave the positions untouched - this will work faster. The first two optimizations we have already added to ClickHouse.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kc/6u/v4/kc6uv48b2vbsmki20ckwvvbc990.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what if we create a column with our data type and insert many bad different rows into it? Is our memory full? No, there are two special settings for this in ClickHouse. The first is low_cardinality_max_dictionary_size. This is the maximum size of a dictionary that can be written to disk. The insertion occurs as follows: when we insert the data, a stream of lines comes to us, from them we form a large general dictionary. If the dictionary becomes larger than the setting value, we write the current dictionary to disk, and the rest of the lines somewhere somewhere on the side, next to the indexes. As a result, we will never recount a large dictionary and get no memory problems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second setting is called low_cardinality_use_single_dictionary_for_part. Imagine that in the previous scheme, when we inserted the data, our dictionary was full, and we wrote it to disk. The question arises, why not now form another exactly the same dictionary? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When it overflows, we will again write it to disk and begin to form a third one. This setting just disables this feature by default.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, many dictionaries can be useful if we want to insert some set of lines, but accidentally inserted ‚Äúgarbage‚Äù. Say we first inserted the bad lines, and then we inserted the good ones. Then the dictionary will be divided into many small dictionaries. Some of them will be with garbage, but the latter will be with good lines. And if we read, say, only the last pellet, then everything will also work quickly. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/jx/jb/jcjxjbo7vmgmexmzxryscvj0lhu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before speaking about the advantages of LowCardinality, I‚Äôll say right away that we are unlikely to achieve reduced data on the disk (although this can happen), because ClickHouse compresses the data. There is a default option - LZ4. You can also do compression using ZSTD. But both algorithms already implement dictionary compression, so our external ClickHouse dictionary will not help much.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order not to be unfounded, I took some data from the metric - String, LowCardinality (String) and Enum - and saved them in different data types. </font><font style="vertical-align: inherit;">It turned out three columns, where one billion rows are written. </font><font style="vertical-align: inherit;">The first column, CodePage, has a total of 62 values. </font><font style="vertical-align: inherit;">And you can see that in LowCardinality (String), they squeezed them better. </font><font style="vertical-align: inherit;">String is a little worse, but this is most likely due to the fact that the strings are short, we store their lengths, and they take up a lot of space and do not compress well. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you take PhoneModel, there are more than 48 thousand of them, and there are almost no differences between String and LowCardinality (String). </font><font style="vertical-align: inherit;">For the URL, we also saved only 2 GB - I think you should not rely on this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimation of the speed of work</font></font></h3> <br>
<img src="https://habrastorage.org/webt/3q/v7/ar/3qv7aronmenayqfhdjait6xo3tw.jpeg"><br>
<b><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link from the slide</font></font></a></sub></sup></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Now let's evaluate the speed of work. To evaluate it, I used a dataset describing taxi rides in New York. It</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is available</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on GitHub. It has a little over a billion trips. It shows the location, the start and end times of the trip, the payment method, the number of passengers and even the type of taxi - green, yellow and Uber.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2o/9n/qb/2o9nqbsb7dodtnoimgnnl66lhlg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I made the first request quite simple - I asked where taxis are most often ordered. To do this, you need to take the location from where you ordered, make GROUP BY on it and calculate the count function. Here ClickHouse gives out something.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/uy/kz/teuykz6_ucr7tuklbfsnobntncc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To measure the speed of query processing, I created three tables with the same data, but used three different data types for our start location - String, LowCardinality and Enum. LowCardinality and Enum are five times faster than String. Enum is faster because it works with numbers. LowCardinality - because GROUP BY optimization is implemented. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pl/mx/qr/plmxqrgggpwl4xp2quqggej847k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's complicate the request - ask where the most popular park in New York is located. Again, we will measure this by where taxi is most often ordered, but at the same time we will filter out only those locations where the word ‚Äúpark‚Äù is available. Also add a like function.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0u/iq/bz/0uiqbzwkh280_wuzn8bccqg2lhi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We look at the time - we see that Enum suddenly began to slow down. And it works even slower than the standard String data type. This is because the like function is not at all optimized for Enum. We have to convert our lines from Enum to regular lines - we do more work. LowCardinality (String) is also not optimized by default, but like works there on the dictionary, so the query is faster compared to String. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a more global problem with Enum. If we want to optimize it, we must do it in every place of the code. Suppose we wrote a new function - you must definitely come up with optimizations for Enum. And in LowCardinality, everything is optimized by default.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_j/oc/eq/_joceq5ioy66p6gjatm1l5f2rqy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the last request, more artificial. </font><font style="vertical-align: inherit;">We will simply calculate the hash function from our location. </font><font style="vertical-align: inherit;">The hash function is a rather slow request, it takes a long time, so everything will slow down three times. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dn/06/x9/dn06x9ujvdxgdpmjcus8qzlccbg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LowCardinality is still faster, although there is no filtering. </font><font style="vertical-align: inherit;">This is due to the fact that our functions work only on the dictionary. </font><font style="vertical-align: inherit;">The hash calculation function has one argument - it can process less data and can also return LowCardinality. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/63/yt/qz/63ytqzwuufiatce0y8wdy4whn5s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our global plan is to achieve a speed not lower than that of String in any cases, and save acceleration. </font><font style="vertical-align: inherit;">And maybe we'll someday replace String with LowCardinality, you will update ClickHouse, and everything will work for you a little faster.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492850/index.html">Not everyone wants to switch to remote work</a></li>
<li><a href="../en492856/index.html">Covid19, Your society and you are from the point of view of Data Science. Translated article by Jeremy Howard and Rachel Thomas (fast.ai)</a></li>
<li><a href="../en492862/index.html">15 best Oracle APEX performance tuning tips for developers</a></li>
<li><a href="../en492864/index.html">Can I hack a ship?</a></li>
<li><a href="../en492866/index.html">The book "Machine Learning without words"</a></li>
<li><a href="../en492872/index.html">How to organize remote access and not suffer from hackers</a></li>
<li><a href="../en492874/index.html">Rendering optimization for Mobile</a></li>
<li><a href="../en492878/index.html">Geek slippers: looking for positive in temporary office closures</a></li>
<li><a href="../en492880/index.html">What should we build a smart home?</a></li>
<li><a href="../en492884/index.html">Receiving messages from youtube broadcasts + google authorization in PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>