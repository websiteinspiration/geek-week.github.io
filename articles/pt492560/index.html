<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé® üîπ üòù Tabela de hash simples para GPU ‚ò†Ô∏è ‚ôéÔ∏è üë®üèæ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postei no Github um novo projeto chamado A Simple GPU Hash Table . 
 
 Esta √© uma tabela de hash simples para a GPU, capaz de processar centenas de mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tabela de hash simples para GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postei no Github um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novo projeto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chamado </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© uma tabela de hash simples para a GPU, capaz de processar centenas de milh√µes de inser√ß√µes por segundo. </font><font style="vertical-align: inherit;">No meu laptop com um NVIDIA GTX 1060, o c√≥digo insere 64 milh√µes de pares de valores-chave gerados aleatoriamente em cerca de 210 ms e remove 32 milh√µes de pares em cerca de 64 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, a velocidade do laptop √© de aproximadamente 300 milh√µes de inser√ß√µes / s e 500 milh√µes de remo√ß√µes / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela est√° escrita em CUDA, embora a mesma t√©cnica possa ser aplicada ao HLSL ou GLSL. </font><font style="vertical-align: inherit;">A implementa√ß√£o possui v√°rias limita√ß√µes que garantem alto desempenho na placa de v√≠deo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somente chaves de 32 bits e os mesmos valores s√£o processados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tabela de hash tem um tamanho fixo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E esse tamanho deve ser igual a dois em grau.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para chaves e valores, voc√™ precisa reservar um marcador de delimita√ß√£o simples (no c√≥digo acima, √© 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesa de hash sem fechaduras</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela de hash usa endere√ßamento aberto com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detec√ß√£o linear</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja, √© apenas uma matriz de pares de valores-chave armazenados na mem√≥ria e com excelente desempenho de cache. </font><font style="vertical-align: inherit;">Esse n√£o √© o caso do encadeamento, o que significa procurar um ponteiro em uma lista vinculada. </font><font style="vertical-align: inherit;">Uma tabela de hash √© uma matriz simples que armazena elementos </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tamanho da tabela √© igual a dois em pot√™ncia, e n√£o um n√∫mero primo, porque para usar pow2 / AND-mask, basta uma instru√ß√£o r√°pida e o operador do m√≥dulo √© muito mais lento. Isso √© importante no caso da detec√ß√£o linear, pois em uma pesquisa linear na tabela, o √≠ndice do slot deve ser empacotado em cada slot. E, como resultado, o custo da opera√ß√£o √© adicionado ao m√≥dulo em cada slot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela armazena apenas a chave e o valor de cada item, n√£o o hash da chave. Como a tabela armazena apenas chaves de 32 bits, o hash √© calculado muito rapidamente. O c√≥digo acima usa o hash Murmur3, que executa apenas alguns turnos, XORs e multiplica√ß√µes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela de hash usa uma t√©cnica de prote√ß√£o de bloqueio que n√£o depende da ordem de coloca√ß√£o da mem√≥ria. Mesmo que algumas opera√ß√µes de grava√ß√£o violem a ordem de outras opera√ß√µes, a tabela de hash ainda manter√° o estado correto. Falaremos sobre isso abaixo. A t√©cnica funciona muito bem com placas de v√≠deo nas quais milhares de threads competem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaves e valores na tabela de hash s√£o inicializados para esvaziar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo pode ser modificado para poder processar chaves e valores de 64 bits. As chaves requerem opera√ß√µes at√¥micas de leitura, grava√ß√£o e troca (comparar e trocar). E os valores requerem opera√ß√µes at√¥micas de leitura e grava√ß√£o. Felizmente, no CUDA, as opera√ß√µes de leitura e grava√ß√£o para valores de 32 e 64 bits s√£o at√¥micas, desde que estejam naturalmente alinhadas (veja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e as placas de v√≠deo modernas oferecem suporte a opera√ß√µes at√¥micas de 64 bits comparadas √† troca. </font><font style="vertical-align: inherit;">Obviamente, ao mudar para 64 bits, o desempenho diminuir√° um pouco.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status da tabela de hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada par de valores-chave em uma tabela de hash pode ter um dos quatro estados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A chave e o significado est√£o vazios. </font><font style="vertical-align: inherit;">Nesse estado, a tabela de hash √© inicializada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A chave foi gravada, mas o valor ainda n√£o √©. </font><font style="vertical-align: inherit;">Se outro encadeamento de execu√ß√£o estiver lendo dados nesse momento, ele retornar√° um valor vazio. </font><font style="vertical-align: inherit;">Isso √© normal, o mesmo aconteceria se outro segmento de execu√ß√£o funcionasse um pouco mais cedo, e estamos falando de uma estrutura de dados competitiva.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A chave e o valor s√£o registrados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O valor est√° dispon√≠vel para outros encadeamentos de execu√ß√£o, mas a chave ainda n√£o est√°. </font><font style="vertical-align: inherit;">Isso pode acontecer porque o modelo de programa√ß√£o CUDA implica um modelo de mem√≥ria mal ordenado. </font><font style="vertical-align: inherit;">Isso √© normal; de qualquer forma, a chave ainda est√° vazia, mesmo que o valor n√£o seja mais esse.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma nuance importante √© que, assim que a chave √© gravada no slot, ela n√£o se move mais - mesmo que a chave seja exclu√≠da, falaremos sobre isso abaixo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo da tabela de hash funciona mesmo com modelos de mem√≥ria mal ordenados que n√£o sabem a ordem de leitura e grava√ß√£o na mem√≥ria. </font><font style="vertical-align: inherit;">Ao analisar a inser√ß√£o, pesquisar e excluir na tabela de hash, lembre-se de que cada par de valor-chave est√° em um dos quatro estados descritos acima.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserir em uma tabela de hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma fun√ß√£o CUDA que insere pares de valores-chave em uma tabela de hash √© assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para inserir uma chave, o c√≥digo itera sobre a matriz da tabela de hash, come√ßando com o hash da chave inserida. Em cada slot da matriz, uma opera√ß√£o de compara√ß√£o at√¥mica √© realizada com a central, na qual a chave nesse slot √© comparada com uma vazia. Se uma incompatibilidade for detectada, a chave no slot √© atualizada para a chave inserida e a chave original do slot √© retornada. Se essa chave original estava vazia ou correspondeu √† chave inserida, o c√≥digo encontrou um slot adequado para inser√ß√£o e traz o valor inserido para o slot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se em uma chamada do kernel</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem v√°rios elementos com a mesma chave, ent√£o qualquer um dos seus valores pode ser gravado no slot de chave. </font><font style="vertical-align: inherit;">Isso √© considerado normal: uma das opera√ß√µes de grava√ß√£o de valor-chave durante a chamada ser√° bem-sucedida, mas como tudo isso acontece em paralelo em v√°rios encadeamentos de execu√ß√£o, n√£o podemos prever qual opera√ß√£o de grava√ß√£o na mem√≥ria ser√° a √∫ltima.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa de tabela de hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥digo do localizador de chaves:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para encontrar o valor da chave armazenada na tabela, iteramos sobre a matriz come√ßando com o hash da chave desejada. </font><font style="vertical-align: inherit;">Em cada slot, verificamos se a chave √© a que estamos procurando e, se for o caso, retornamos seu valor. </font><font style="vertical-align: inherit;">Tamb√©m verificamos se a chave est√° vazia e, se estiver, interrompemos a pesquisa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se n√£o conseguirmos encontrar a chave, o c√≥digo retornar√° um valor vazio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas essas opera√ß√µes de pesquisa podem ser executadas competitivamente durante inser√ß√µes e exclus√µes. </font><font style="vertical-align: inherit;">Cada par na tabela ter√° um dos quatro estados descritos acima para o fluxo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exclus√£o de tabela de hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥digo de remo√ß√£o de chave:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A remo√ß√£o de uma chave √© incomum: deixamos a chave na tabela e marcamos seu valor (n√£o a pr√≥pria chave) em branco. </font><font style="vertical-align: inherit;">Esse c√≥digo √© muito semelhante a </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, exceto que, quando uma correspond√™ncia √© encontrada para a chave, ele torna seu valor vazio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencionado acima, uma vez que a chave √© gravada no slot, ela n√£o se move mais. </font><font style="vertical-align: inherit;">Mesmo quando voc√™ exclui um item da tabela, a chave permanece no lugar, apenas seu valor fica vazio. </font><font style="vertical-align: inherit;">Isso significa que n√£o precisamos usar a opera√ß√£o at√¥mica para escrever o valor do slot, porque n√£o importa se o valor atual est√° vazio ou n√£o - ele ainda ficar√° vazio.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redimensionar uma tabela de hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode redimensionar a tabela de hash criando uma tabela maior e inserindo elementos n√£o vazios da tabela antiga nela. </font><font style="vertical-align: inherit;">Eu n√£o implementei essa funcionalidade porque queria manter o c√≥digo de exemplo simples. </font><font style="vertical-align: inherit;">Al√©m disso, nos programas CUDA, a aloca√ß√£o de mem√≥ria geralmente √© feita no c√≥digo do host e n√£o no n√∫cleo do CUDA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabela de hash sem bloqueio e sem espera</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descreve como alterar uma estrutura de dados protegida por bloqueio.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Competitividade</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos fragmentos acima de c√≥digo, as fun√ß√µes </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processo de um par de chaves de valor de cada vez. </font><font style="vertical-align: inherit;">E abaixo </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eles </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processam uma matriz de pares em paralelo, cada par em um thread de execu√ß√£o da GPU separado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma tabela de hash bloque√°vel suporta inser√ß√µes, pesquisas e exclus√µes simult√¢neas. Como os pares de valores-chave est√£o sempre em um dos quatro estados e as chaves n√£o se movem, a tabela garante a corre√ß√£o, mesmo ao usar diferentes tipos de opera√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, se processarmos um pacote de inser√ß√µes e exclus√µes em paralelo, e se chaves duplicadas estiverem contidas na matriz de entrada de pares, n√£o conseguiremos prever quais pares ser√£o "vencidos" - eles ser√£o gravados na tabela de hash por √∫ltimo. Suponha que tenhamos chamado um c√≥digo de inser√ß√£o com uma matriz de entrada de pares </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Quando o c√≥digo √© conclu√≠do, os pares </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√™m a </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garantia de estar presentes na tabela, mas ao mesmo tempo qualquer um dos pares aparecer√° nele </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso pode ou n√£o ser um problema - tudo depende do aplicativo. Voc√™ deve saber antecipadamente que n√£o h√° chaves duplicadas na matriz de entrada ou talvez n√£o seja importante para voc√™ qual valor foi gravado pela √∫ltima vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se isso for um problema para voc√™, ser√° necess√°rio dividir os pares duplicados em diferentes chamadas CUDA do sistema. No CUDA, qualquer opera√ß√£o de chamada do kernel sempre termina antes da pr√≥xima chamada do kernel (pelo menos dentro do mesmo thread. Em threads diferentes, o kernel √© executado em paralelo). Se no exemplo acima, chame um n√∫cleo com </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o outro com </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a chave </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obter√° um valor </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos falar se a fun√ß√£o </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar um ponteiro simples (simples) ou vari√°vel (vol√°til) para uma matriz de pares em uma tabela de hash.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A documenta√ß√£o da CUDA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afirma que:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O compilador pode, a seu crit√©rio, otimizar as opera√ß√µes de leitura e grava√ß√£o na mem√≥ria global ou compartilhada ... Essas otimiza√ß√µes podem ser desativadas usando a palavra </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">chave </font><font style="vertical-align: inherit;">: ... qualquer link para essa vari√°vel √© compilado em uma instru√ß√£o real de leitura ou grava√ß√£o na mem√≥ria.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As considera√ß√µes de corre√ß√£o n√£o requerem aplica√ß√£o </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se o encadeamento de execu√ß√£o usar o valor em cache de uma opera√ß√£o de leitura anterior, isso significa que ele usar√° informa√ß√µes um pouco desatualizadas. </font><font style="vertical-align: inherit;">Mas ainda assim, essas s√£o informa√ß√µes do estado correto da tabela de hash em um determinado ponto da chamada do kernel. </font><font style="vertical-align: inherit;">Se voc√™ precisar usar as informa√ß√µes mais recentes, poder√° usar o ponteiro </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas o desempenho diminuir√° um pouco: de acordo com meus testes, quando voc√™ exclui 32 milh√µes de itens, a velocidade diminui de 500 milh√µes de exclus√µes para 450 milh√µes de exclus√µes.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atua√ß√£o</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No teste para inserir 64 milh√µes de elementos e excluir 32 milh√µes deles, </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">praticamente n√£o h√° </font><font style="vertical-align: inherit;">concorr√™ncia entre </font><font style="vertical-align: inherit;">e a tabela de hash para a GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gastou 70 691 ms na inser√ß√£o e exclus√£o de elementos com libera√ß√£o subsequente </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(a libera√ß√£o de milh√µes de elementos leva muito tempo, porque </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muitas aloca√ß√µes de mem√≥ria s√£o executadas </font><font style="vertical-align: inherit;">no interior </font><font style="vertical-align: inherit;">). Honestamente, existem </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limita√ß√µes completamente diferentes. Este √© um √∫nico thread de execu√ß√£o da CPU, suporta valores-chave de qualquer tamanho, funciona bem em altas taxas de utiliza√ß√£o e mostra desempenho est√°vel ap√≥s in√∫meras exclus√µes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A dura√ß√£o da tabela de hash para a comunica√ß√£o GPU e entre programas foi de 984 ms. Isso inclui o tempo gasto para colocar a tabela na mem√≥ria e exclu√≠-la (aloca√ß√£o √∫nica de 1 GB de mem√≥ria, que no CUDA leva algum tempo), inser√ß√£o e exclus√£o de elementos e tamb√©m itera√ß√£o sobre eles. Tamb√©m foram levadas em considera√ß√£o todas as c√≥pias de e para a mem√≥ria da placa de v√≠deo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pr√≥pria tabela de hash levou 271 ms. Isso inclui o tempo gasto pela placa de v√≠deo para inserir e remover itens e n√£o leva em considera√ß√£o o tempo necess√°rio para copiar para a mem√≥ria e iterar sobre a tabela resultante. Se a tabela da GPU permanecer por muito tempo ou se a tabela de hash estiver totalmente contida na mem√≥ria da placa de v√≠deo (por exemplo, para criar uma tabela de hash que ser√° usada por outro c√≥digo da GPU e n√£o pelo processador central), o resultado do teste √© relevante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela de hash da placa de v√≠deo demonstra alto desempenho devido √† sua alta largura de banda e paraleliza√ß√£o ativa.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desvantagens</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A arquitetura da tabela de hash tem v√°rios problemas a serem lembrados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O agrupamento interfere na an√°lise linear, pelo que as chaves da tabela est√£o longe do ideal.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As teclas n√£o s√£o exclu√≠das usando a fun√ß√£o </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, com o tempo, desorganizam a mesa.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, o desempenho da tabela de hash pode diminuir gradualmente, especialmente se ele existir por um longo tempo e v√°rias inser√ß√µes e exclus√µes forem realizadas nela. </font><font style="vertical-align: inherit;">Uma maneira de mitigar essas defici√™ncias √© refazer uma nova tabela com uma taxa de utiliza√ß√£o razoavelmente baixa e filtrar as chaves remotas ao refazer a tarefa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ilustrar os problemas descritos, eu uso o c√≥digo acima para criar uma tabela para 128 milh√µes de elementos, inserirei ciclicamente 4 milh√µes de elementos at√© preencher 124 milh√µes de slots (a utiliza√ß√£o √© de cerca de 0,96). </font><font style="vertical-align: inherit;">Aqui est√° a tabela de resultados, cada linha √© uma chamada para o n√∫cleo CUDA com a inser√ß√£o de 4 milh√µes de novos elementos em uma tabela de hash:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taxa de utiliza√ß√£o </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dura√ß√£o da inser√ß√£o 4 194 304 elementos</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11,608448 ms (361,314798 milh√µes de chaves / s)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä medida que a utiliza√ß√£o aumenta, a produtividade diminui. Isso √© indesej√°vel na maioria dos casos. Se um aplicativo inserir elementos em uma tabela e depois descart√°-los (por exemplo, ao contar palavras em um livro), isso n√£o ser√° um problema. Mas se o aplicativo usar uma tabela de hash de longa dura√ß√£o (por exemplo, em um editor de gr√°ficos para armazenar partes n√£o vazias de imagens quando o usu√°rio geralmente inserir e excluir informa√ß√µes), esse comportamento poder√° ser problem√°tico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E ele mediu a profundidade da an√°lise da tabela de hash ap√≥s 64 milh√µes de inser√ß√µes (fator de utiliza√ß√£o 0,5). A profundidade m√©dia foi de 0,4774; portanto, a maioria das teclas estava localizada no melhor slot poss√≠vel ou em um slot da melhor posi√ß√£o. A profundidade m√°xima do som foi 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois, medi a profundidade do som na tabela com 124 milh√µes de inser√ß√µes (taxa de utiliza√ß√£o 0,97). A profundidade m√©dia j√° era 10.1757, e a m√°xima - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). O desempenho do som linear diminui drasticamente a altas taxas de utiliza√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â melhor manter essa tabela de hash baixa. Mas aumentamos a produtividade consumindo mem√≥ria. Felizmente, no caso de chaves e valores de 32 bits, isso pode ser justificado. Se no exemplo acima na tabela para 128 milh√µes de elementos o coeficiente de utiliza√ß√£o de 0,25 estiver armazenado, n√£o podemos colocar mais de 32 milh√µes de elementos nele e os 96 milh√µes de slots restantes ser√£o perdidos - 8 bytes para cada par, 768 MB de mem√≥ria perdida.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que estamos falando sobre a perda de mem√≥ria da placa de v√≠deo, que √© um recurso mais valioso que a mem√≥ria do sistema. </font><font style="vertical-align: inherit;">Embora a maioria das placas gr√°ficas de desktop modernas que suportam CUDA possuam pelo menos 4 GB de mem√≥ria (no momento da escrita, o NVIDIA 2080 Ti possui 11 GB), a perda desses volumes n√£o ser√° a decis√£o mais sensata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posteriormente, escreverei mais sobre a cria√ß√£o de tabelas de hash para placas de v√≠deo que n√£o apresentam problemas com a profundidade da sonoridade, bem como maneiras de reutilizar slots remotos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medi√ß√£o da profundidade da detec√ß√£o</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para determinar a profundidade do som da chave, podemos extrair o hash da chave (seu √≠ndice ideal na tabela) do seu √≠ndice real da tabela:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido √† magia de dois n√∫meros bin√°rios no c√≥digo adicional e ao fato de a capacidade da tabela de hash ser igual a dois no poder, essa abordagem funcionar√° mesmo quando o √≠ndice de chave for movido para o in√≠cio da tabela. </font><font style="vertical-align: inherit;">Pegue uma chave com hash em 1, mas inserida no slot 3. Em uma tabela com capacidade 4, obtemos </font></font><code>(3 ‚Äî 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o equivalente a 2.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ tiver perguntas ou coment√°rios, escreva-me no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou abra um novo t√≥pico no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposit√≥rio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c√≥digo √© inspirado em alguns √≥timos artigos:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tabela de hash sem bloqueio mais simples do mundo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma tabela de hash sem bloqueio e sem espera</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No futuro, continuarei escrevendo sobre implementa√ß√µes de tabelas de hash para placas de v√≠deo e analisarei seu desempenho. </font><font style="vertical-align: inherit;">Tenho planos de encadear, hash Robin Hood e cuco usando opera√ß√µes at√¥micas em estruturas de dados que s√£o convenientes para placas de v√≠deo.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt492540/index.html">O jogo "Espere um momento!" no arduino</a></li>
<li><a href="../pt492546/index.html">Verificando a vulnerabilidade de qualquer site usando o Nikto</a></li>
<li><a href="../pt492548/index.html">Unity Machine Learning: ensinando agentes do MO a pular muros</a></li>
<li><a href="../pt492552/index.html">Como viver e trabalhar em quarentena em Barcelona</a></li>
<li><a href="../pt492558/index.html">Ol√°, aqui √© COVID19: O coronav√≠rus vive na superf√≠cie de um smartphone?</a></li>
<li><a href="../pt492562/index.html">Tr√™s webinars √∫teis do Apache Ignite em seu programa de quarentena</a></li>
<li><a href="../pt492566/index.html">An√°lise da combina√ß√£o de um algoritmo de busca por clique ganancioso com enumera√ß√£o parcial de v√©rtices de gr√°fico</a></li>
<li><a href="../pt492568/index.html">Obtenha uma extra√ß√£o do Rosreestr atrav√©s do FSIS USRN e python. Parte 2</a></li>
<li><a href="../pt492572/index.html">O estado atual do mundo Java: tend√™ncias e fatos para uma das linguagens de programa√ß√£o mais populares</a></li>
<li><a href="../pt492574/index.html">Reflex√µes sobre a probabilidade de decolagem: Apple AirPods com Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>