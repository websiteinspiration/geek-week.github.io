<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â¡ï¸ ğŸ˜¾ ğŸ§•ğŸ¿ Tabel hash sederhana untuk GPU ğŸ‘• â­ï¸ ğŸ¤µğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya memposting di Github sebuah proyek baru bernama A Simple GPU Hash Table . 
 
 Ini adalah tabel hash sederhana untuk GPU, yang mampu memproses rat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tabel hash sederhana untuk GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memposting di Github sebuah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyek baru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bernama </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah tabel hash sederhana untuk GPU, yang mampu memproses ratusan juta insert per detik. </font><font style="vertical-align: inherit;">Pada laptop saya dengan NVIDIA GTX 1060, kode tersebut menyisipkan 64 juta pasangan nilai kunci yang dihasilkan secara acak dalam sekitar 210 ms dan menghilangkan 32 juta pasangan dalam sekitar 64 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, kecepatan pada laptop adalah sekitar 300 juta sisipan / detik dan 500 juta kepindahan / detik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel ini ditulis dalam CUDA, meskipun teknik yang sama dapat diterapkan ke HLSL atau GLSL. </font><font style="vertical-align: inherit;">Implementasinya memiliki beberapa batasan yang memastikan kinerja tinggi pada kartu video:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya kunci 32-bit dan nilai yang sama diproses.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel hash memiliki ukuran tetap.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ukuran ini harus sama dengan dua derajat.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kunci dan nilai, Anda perlu memesan penanda pembatas sederhana (dalam kode di atasnya 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meja hash tanpa kunci</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel hash menggunakan pengalamatan terbuka dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penginderaan linier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yaitu, hanya array pasangan nilai kunci yang disimpan dalam memori dan memiliki kinerja cache yang sangat baik. </font><font style="vertical-align: inherit;">Ini tidak terjadi dengan chaining, yang berarti mencari pointer di daftar tertaut. </font><font style="vertical-align: inherit;">Tabel hash adalah elemen penyimpanan array sederhana </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ukuran tabel sama dengan dua daya, dan bukan bilangan prima, karena untuk menggunakan pow2 / AND-mask, satu instruksi cepat sudah cukup, dan operator modul jauh lebih lambat. Ini penting dalam kasus penginderaan linier, karena dalam pencarian linear dalam tabel, indeks slot harus dibungkus di setiap slot. Dan sebagai hasilnya, biaya operasi ditambahkan modulo di setiap slot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel hanya menyimpan kunci dan nilai untuk setiap item, bukan hash kunci. Karena tabel hanya menyimpan kunci 32-bit, hash dihitung dengan sangat cepat. Kode di atas menggunakan hash Murmur3, yang hanya melakukan beberapa shift, XOR, dan multiplikasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel hash menggunakan teknik perlindungan kunci yang tidak tergantung pada urutan penempatan memori. Bahkan jika beberapa operasi penulisan melanggar urutan operasi lainnya, tabel hash akan tetap mempertahankan status yang benar. Kami akan membicarakan ini di bawah ini. Teknik ini bekerja sangat baik dengan kartu video di mana ribuan utas bersaing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kunci dan nilai dalam tabel hash diinisialisasi ke kosong. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode dapat dimodifikasi sehingga dapat memproses kunci dan nilai 64-bit. Kunci memerlukan operasi membaca, menulis, dan bertukar atom (bandingkan-dan-tukar). Dan nilai membutuhkan operasi baca dan tulis atom. Untungnya, dalam CUDA, operasi baca-tulis untuk nilai 32-bit dan 64-bit adalah atom selama mereka secara alami selaras (lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dan kartu video modern mendukung operasi atom 64-bit perbandingan dengan pertukaran. </font><font style="vertical-align: inherit;">Tentu saja, ketika beralih ke 64 bit, kinerja akan sedikit menurun.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status Tabel Hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap pasangan kunci-nilai dalam tabel hash dapat memiliki satu dari empat status:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuncinya dan artinya kosong. </font><font style="vertical-align: inherit;">Dalam keadaan ini, tabel hash diinisialisasi.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunci telah direkam, tetapi nilainya belum. </font><font style="vertical-align: inherit;">Jika utas eksekusi lainnya sedang membaca data pada saat itu, maka itu mengembalikan nilai kosong. </font><font style="vertical-align: inherit;">Ini normal, hal yang sama akan terjadi jika utas eksekusi lainnya bekerja sedikit lebih awal, dan kita berbicara tentang struktur data kompetitif.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baik kunci maupun nilainya dicatat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai tersedia untuk utas eksekusi lainnya, tetapi kuncinya belum. </font><font style="vertical-align: inherit;">Ini bisa terjadi karena model pemrograman CUDA menyiratkan model memori yang tidak tertata dengan baik. </font><font style="vertical-align: inherit;">Ini normal, dalam hal apapun, kuncinya masih kosong, bahkan jika nilainya tidak lagi seperti itu.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuansa yang penting adalah bahwa begitu kunci telah ditulis ke slot, itu tidak lagi bergerak - bahkan jika kunci dihapus, kita akan membicarakan hal ini di bawah ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode tabel hash bahkan bekerja dengan model memori yang dipesan dengan buruk yang tidak tahu urutan membaca dan menulis ke memori. </font><font style="vertical-align: inherit;">Saat kami menganalisis sisipan, mencari dan menghapus dalam tabel hash, ingatlah bahwa setiap pasangan nilai kunci ada di salah satu dari empat negara yang dijelaskan di atas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masukkan ke dalam tabel hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi CUDA yang memasukkan pasangan nilai kunci ke dalam tabel hash terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menyisipkan kunci, kode iterates di atas array tabel hash dimulai dengan hash dari kunci yang dimasukkan. Di setiap slot array, operasi perbandingan atom dilakukan dengan pertukaran, di mana kunci dalam slot ini dibandingkan dengan yang kosong. Jika ketidakcocokan terdeteksi, kunci dalam slot diperbarui ke kunci yang dimasukkan, dan kemudian kunci asli dari slot dikembalikan. Jika kunci asli ini kosong atau terkait dengan kunci yang dimasukkan, maka kode menemukan slot yang cocok untuk dimasukkan dan membawa nilai yang dimasukkan ke dalam slot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika dalam satu panggilan kernel</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada beberapa elemen dengan kunci yang sama, maka salah satu nilainya dapat ditulis ke slot kunci. </font><font style="vertical-align: inherit;">Ini dianggap normal: salah satu operasi penulisan nilai kunci selama panggilan akan berhasil, tetapi karena semua ini terjadi secara paralel dalam beberapa utas eksekusi, kami tidak dapat memperkirakan operasi penulisan ke memori mana yang akan menjadi yang terakhir.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian Tabel Hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode Pencari Kunci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menemukan nilai kunci yang disimpan dalam tabel, kita beralih pada array yang dimulai dengan hash kunci yang diinginkan. </font><font style="vertical-align: inherit;">Di setiap slot, kami memeriksa apakah kuncinya adalah yang kami cari, dan jika demikian, kembalikan nilainya. </font><font style="vertical-align: inherit;">Kami juga memeriksa apakah kunci kosong, dan jika demikian, kami menghentikan pencarian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kami tidak dapat menemukan kunci, maka kode mengembalikan nilai kosong. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua operasi pencarian ini dapat dilakukan secara kompetitif selama penyisipan dan penghapusan. </font><font style="vertical-align: inherit;">Setiap pasangan dalam tabel akan memiliki satu dari empat negara yang dijelaskan di atas untuk streaming.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penghapusan tabel hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode Penghapusan Kunci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menghapus kunci adalah tidak biasa: kita membiarkan kunci di dalam tabel dan menandai nilainya (bukan kunci itu sendiri) kosong. </font><font style="vertical-align: inherit;">Kode ini sangat mirip dengan </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kecuali bahwa ketika kecocokan ditemukan untuk kunci, itu membuat nilainya kosong. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti disebutkan di atas, begitu kunci ditulis ke slot, itu tidak lagi bergerak. </font><font style="vertical-align: inherit;">Bahkan ketika Anda menghapus item dari tabel, kuncinya tetap di tempatnya, hanya nilainya menjadi kosong. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita tidak perlu menggunakan operasi atom untuk menulis nilai slot, karena tidak masalah apakah nilai saat ini kosong atau tidak - masih akan menjadi kosong.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah ukuran tabel hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda bisa mengubah ukuran tabel hash dengan membuat tabel yang lebih besar dan memasukkan elemen yang tidak kosong dari tabel lama ke dalamnya. </font><font style="vertical-align: inherit;">Saya tidak menerapkan fungsi ini karena saya ingin menjaga kode sampel tetap sederhana. </font><font style="vertical-align: inherit;">Selain itu, dalam program CUDA, alokasi memori sering dilakukan dalam kode host, dan bukan pada inti CUDA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Hash-Free Tunggu-Gratis Tabel Hash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggambarkan bagaimana mengubah struktur data yang dilindungi kunci.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daya saing</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam cuplikan kode di atas, fungsi </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proses satu pasangan nilai kunci sekaligus. </font><font style="vertical-align: inherit;">Dan di bawah ini </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memproses berbagai pasangan secara paralel, masing-masing pasangan dalam alur eksekusi GPU terpisah:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel hash yang dapat dikunci mendukung sisipan, pencarian, dan penghapusan secara bersamaan. Karena pasangan nilai kunci selalu di salah satu dari empat negara, dan kunci tidak bergerak, tabel menjamin kebenaran bahkan ketika menggunakan berbagai jenis operasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, jika kita memproses paket penyisipan dan penghapusan secara paralel, dan jika kunci duplikat terkandung dalam array input berpasangan, maka kita tidak akan dapat memprediksi pasangan mana yang akan "menang" - mereka akan ditulis ke tabel hash terakhir. Misalkan kita memanggil kode insert dengan array input berpasangan </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ketika kode selesai, pasangan </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijamin akan hadir dalam tabel, tetapi pada saat yang sama salah satu pasangan akan muncul di dalamnya </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini mungkin atau mungkin tidak menjadi masalah - itu semua tergantung pada aplikasi. Anda mungkin tahu sebelumnya bahwa tidak ada kunci duplikat di larik input, atau mungkin tidak masalah bagi Anda nilai apa yang terakhir ditulis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika ini masalah bagi Anda, maka Anda perlu membagi pasangan duplikat menjadi panggilan sistem CUDA yang berbeda. Dalam CUDA, setiap operasi panggilan kernel selalu berakhir sebelum panggilan kernel berikutnya (setidaknya dalam utas yang sama. Dalam utas yang berbeda, kernel mengeksekusi secara paralel). Jika dalam contoh di atas, panggil satu inti dengan </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan yang lainnya dengan </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka kunci </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan mendapatkan nilai </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita bicara tentang apakah fungsi </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan sederhana (polos) atau variabel (mudah menguap) pointer ke array pasangan dalam tabel hash.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi CUDA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyatakan bahwa:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompiler dapat, atas kebijakannya sendiri, mengoptimalkan operasi baca dan tulis ke memori global atau bersama ... Optimalisasi ini dapat dinonaktifkan menggunakan kata kunci </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... tautan apa pun ke variabel ini dikompilasi menjadi instruksi baca atau tulis nyata dalam memori.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangan kebenaran tidak membutuhkan aplikasi </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika utas eksekusi menggunakan nilai cache dari operasi baca sebelumnya, maka ini berarti akan menggunakan informasi yang sedikit ketinggalan zaman. </font><font style="vertical-align: inherit;">Tapi tetap saja, ini adalah informasi dari status tabel hash yang benar pada titik tertentu dalam panggilan kernel. </font><font style="vertical-align: inherit;">Jika Anda perlu menggunakan informasi terbaru, Anda dapat menggunakan pointer </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi kemudian kinerja akan sedikit menurun: menurut pengujian saya, ketika Anda menghapus 32 juta item, kecepatan berkurang dari 500 juta delete / s menjadi 450 juta delete / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam tes untuk memasukkan 64 juta elemen dan menghapus 32 juta elemen, </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">praktis tidak ada </font><font style="vertical-align: inherit;">persaingan antara </font><font style="vertical-align: inherit;">dan tabel hash untuk GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghabiskan 70.691 ms pada penyisipan dan penghapusan elemen dengan rilis berikutnya </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(rilis dari jutaan elemen membutuhkan banyak waktu, karena </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak alokasi memori dilakukan </font><font style="vertical-align: inherit;">di dalam </font><font style="vertical-align: inherit;">). Jujur saja, ada </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">batasan </font><font style="vertical-align: inherit;">yang </font><font style="vertical-align: inherit;">sangat berbeda. Ini adalah eksekusi CPU-thread tunggal, mendukung nilai-nilai kunci dari berbagai ukuran, bekerja dengan baik pada tingkat pemanfaatan yang tinggi dan menunjukkan kinerja yang stabil setelah banyak penghapusan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durasi tabel hash untuk GPU dan komunikasi antar-program adalah 984 ms. Ini termasuk waktu yang diperlukan untuk menempatkan tabel dalam memori dan menghapusnya (alokasi satu kali memori 1 GB, yang dalam CUDA membutuhkan waktu), penyisipan dan penghapusan elemen, dan juga iterasi di atasnya. Juga memperhitungkan semua salinan ke dan dari memori kartu video. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel hash itu sendiri mengambil 271 ms. Ini termasuk waktu yang dihabiskan oleh kartu video untuk memasukkan dan menghapus item, dan tidak memperhitungkan waktu yang diperlukan untuk menyalin ke memori dan beralih ke tabel yang dihasilkan. Jika tabel GPU hidup untuk waktu yang lama, atau jika tabel hash seluruhnya terdapat dalam memori kartu video (misalnya, untuk membuat tabel hash yang akan digunakan oleh kode GPU lain dan bukan prosesor pusat), maka hasil pengujian tersebut relevan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tabel hash untuk kartu video menunjukkan kinerja tinggi karena bandwidth tinggi dan paralelisasi aktif.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kerugian</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitektur tabel hash memiliki beberapa masalah yang perlu diingat:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clustering mengganggu linear probing, karena itu kunci dalam tabel jauh dari ideal.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tombol tidak dihapus menggunakan fungsi </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan seiring waktu mengacaukan tabel.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, kinerja tabel hash dapat secara bertahap menurun, terutama jika ada untuk waktu yang lama dan banyak penyisipan dan penghapusan dilakukan di dalamnya. </font><font style="vertical-align: inherit;">Salah satu cara untuk mengurangi kekurangan ini adalah dengan mengulangi tabel baru dengan tingkat pemanfaatan yang cukup rendah dan memfilter kunci jarak jauh saat pengulangan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggambarkan masalah yang dijelaskan, saya menggunakan kode di atas untuk membuat tabel untuk 128 juta elemen, saya akan secara siklik memasukkan 4 juta elemen hingga saya mengisi 124 juta slot (utilisasi sekitar 0,96). </font><font style="vertical-align: inherit;">Berikut adalah tabel hasil, setiap baris adalah panggilan ke inti CUDA dengan penyisipan 4 juta elemen baru ke dalam satu tabel hash:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat penggunaan </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durasi penyisipan 4 194 304 elemen</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.608448 ms (361.314798 juta kunci / detik)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika pemanfaatan meningkat, produktivitas menurun. Ini tidak diinginkan dalam banyak kasus. Jika aplikasi memasukkan elemen ke dalam tabel dan kemudian membuangnya (misalnya, saat menghitung kata dalam buku), maka ini bukan masalah. Tetapi jika aplikasi menggunakan tabel hash yang berumur panjang (misalnya, dalam editor grafis untuk menyimpan bagian gambar yang tidak kosong ketika pengguna sering memasukkan dan menghapus informasi), maka perilaku ini dapat menyusahkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan dia mengukur kedalaman menggali tabel hash setelah 64 juta sisipan (faktor pemanfaatan 0,5). Kedalaman rata-rata adalah 0,4774, sehingga sebagian besar tombol berada di slot terbaik atau dalam satu slot dari posisi terbaik. Kedalaman suara maksimal adalah 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian saya mengukur kedalaman bunyi dalam tabel dengan 124 juta sisipan (tingkat pemanfaatan 0,97). Kedalaman rata-rata sudah 10,1757, dan maksimum - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). Kinerja suara linier turun drastis pada tingkat pemanfaatan yang tinggi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang terbaik adalah menjaga tabel hash ini tetap rendah. Tetapi kemudian kami meningkatkan produktivitas dengan mengonsumsi memori. Untungnya, dalam kasus kunci dan nilai 32-bit, ini dapat dibenarkan. Jika dalam contoh di atas dalam tabel untuk 128 juta elemen, koefisien pemanfaatan 0,25 disimpan, maka kita dapat menempatkan tidak lebih dari 32 juta elemen di dalamnya, dan sisa 96 juta slot akan hilang - 8 byte untuk setiap pasangan, 768 MB memori yang hilang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa kita berbicara tentang hilangnya memori kartu video, yang merupakan sumber daya yang lebih berharga daripada memori sistem. </font><font style="vertical-align: inherit;">Meskipun sebagian besar kartu grafis desktop modern yang mendukung CUDA memiliki setidaknya 4 GB memori (pada saat penulisan, NVIDIA 2080 Ti memiliki 11 GB), kehilangan volume seperti itu tidak akan menjadi keputusan paling bijaksana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nantinya, saya akan menulis lebih banyak tentang membuat tabel hash untuk kartu video yang tidak memiliki masalah dengan kedalaman bunyi, serta cara untuk menggunakan kembali slot jarak jauh.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengukuran Kedalaman Sensing</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menentukan kedalaman bunyi kunci, kita dapat mengekstrak hash kunci (indeks ideal dalam tabel) dari indeks tabel aktualnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena keajaiban dua angka biner dalam kode tambahan dan fakta bahwa kapasitas tabel hash sama dengan dua dalam kekuasaan, pendekatan ini akan bekerja bahkan ketika indeks kunci dipindahkan ke awal tabel. </font><font style="vertical-align: inherit;">Ambil kunci yang hash pada 1 tetapi dimasukkan dalam slot 3. Kemudian untuk tabel dengan kapasitas 4 kita mendapatkan </font></font><code>(3 â€” 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa yang setara dengan 2.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memiliki pertanyaan atau komentar, tulis saya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau buka topik baru di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini terinspirasi oleh beberapa artikel hebat:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel Hash Bebas-Kunci Paling Sederhana di Dunia</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meja Hash Bebas-Tunggu-Bebas-Kunci</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di masa depan, saya akan terus menulis tentang implementasi tabel hash untuk kartu video dan akan menganalisis kinerjanya. </font><font style="vertical-align: inherit;">Saya punya rencana untuk rantai, hash Robin Hood, dan hash cuckoo menggunakan operasi atom dalam struktur data yang sesuai untuk kartu video.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492540/index.html">Permainan "Tunggu sebentar!" pada Arduino</a></li>
<li><a href="../id492546/index.html">Memeriksa kerentanan situs apa pun yang menggunakan Nikto</a></li>
<li><a href="../id492548/index.html">Unity Machine Learning: Mengajar Agen MO untuk Melompati Dinding</a></li>
<li><a href="../id492552/index.html">Cara hidup dan bekerja di karantina di Barcelona</a></li>
<li><a href="../id492558/index.html">Halo, ini COVID19: Apakah coronavirus hidup di permukaan smartphone?</a></li>
<li><a href="../id492562/index.html">Tiga webinar Apache Ignite yang berguna dalam program karantina Anda</a></li>
<li><a href="../id492566/index.html">Analisis kombinasi algoritma pencarian klik rakus dengan enumerasi sebagian dari simpul grafik</a></li>
<li><a href="../id492568/index.html">Dapatkan ekstrak dari Rosreestr melalui FSIS USRN dan python. Bagian 2</a></li>
<li><a href="../id492572/index.html">Keadaan dunia Jawa saat ini: tren dan fakta untuk salah satu bahasa pemrograman paling populer</a></li>
<li><a href="../id492574/index.html">Refleksi Kemungkinan Pelepasan: Apple AirPods dengan Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>