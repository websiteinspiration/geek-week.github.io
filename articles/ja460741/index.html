<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📌 🔐 🏇🏾 ECMAScript 6の概要（ES-2015） 🚧 🐘 🧔🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ES6の概要
 
 目次
 1.テンプレートリテラル
 2. letおよびconst 
 3.矢印関数式
 4. For ... of 
 5.計算されたプロパティ名
 6. Object.assign（）
 7.残りのパラメーター
 8.デフォルトのパラメーター
 9.割り当ての破壊
 10.マッ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ECMAScript 6の概要（ES-2015）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6の概要</font></font></h2><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></b><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.テンプレートリテラル</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. letおよびconst </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.矢印関数式</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. For ... of </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.計算されたプロパティ名</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Object.assign（）</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.残りのパラメーター</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.デフォルトのパラメーター</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.割り当ての破壊</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.マップ</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11セット</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.クラス</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.プロミス</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14.イテレーター</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.ジェネレーター</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.サムボル</font></font></a><br>
<br>
<a name="section001"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートリテラル（テンプレート文字列）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートリテラルは、内部で式を使用できる文字列リテラルです。それらを使用すると、複数行リテラルと文字列補間を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートリテラルは、ダブルまたはシングルではなくバッククォート（ ``）で囲まれています。ドル記号と中括弧（$ {式}）で表されるワイルドカードを含めることができます。置換式とそれらの間のテキストが関数に渡されます。デフォルトでは、関数は単にすべての部分を連結して文字列にします。行の前に式がある場合（ここではタグ）、テンプレート行は「タグテンプレート」と呼ばれます。この場合、タグ式（通常は関数）が処理されたテンプレートリテラルで呼び出され、出力前に変更できます。テンプレートリテラルの逆引用符をエスケープするには、円記号\を指定します。</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数行リテラル改行</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
文字はパターンリテラルの一部です。</font><font style="vertical-align: inherit;">通常の文字列を使用して、挿入をラップするには、次の構文が必要です。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'string text line 1\n'</span> +
<span class="hljs-string">'string text line 2'</span>);
<span class="hljs-comment">// "string text line 1</span>
<span class="hljs-comment">//  string text line 2"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートリテラルを使用して同じこと：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`string text line 1
string text line 2`</span>);
<span class="hljs-comment">// "string text line 1</span>
<span class="hljs-comment">//  string text line 2"</span></code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式の補間</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
式を通常の文字列に挿入するには、次の構文を使用する必要があります。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Fifteen is '</span> + (a + b) + <span class="hljs-string">' and not '</span> + (<span class="hljs-number">2</span> * a + b) + <span class="hljs-string">'.'</span>);
<span class="hljs-comment">// "Fifteen is 15 and not 20."</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、テンプレートリテラルの助けを借りて、「構文糖」を使用できます。これにより、このような置換が読みやすくなります。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Fifteen is <span class="hljs-subst">${a + b}</span> and not <span class="hljs-subst">${<span class="hljs-number">2</span> * a + b}</span>.`</span>);
<span class="hljs-comment">// "Fifteen is 15 and not 20."</span></code></pre><cut></cut><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたテンプレート</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
時々、</font><b><font style="vertical-align: inherit;">テンプレートをネスト</font></b><font style="vertical-align: inherit;">することは、行を作成するための最も短く、おそらくより読みやすい方法です。</font><font style="vertical-align: inherit;">もう1つをバッククォートされたテンプレート内に置き、それらを$ {}置換でラップします。</font><font style="vertical-align: inherit;">たとえば、式がtrueの場合、テンプレートリテラルを返すことができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES5の場合：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> classes = <span class="hljs-string">'header'</span><font></font>
classes += (isLargeScreen() ?<font></font>
   <span class="hljs-string">''</span> : item.isCollapsed ?
     <span class="hljs-string">' icon-expander'</span> : <span class="hljs-string">' icon-collapser'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストのないテンプレートリテラルを使用するES2015では：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> classes = <span class="hljs-string">`header <span class="hljs-subst">${ isLargeScreen() ? <span class="hljs-string">''</span> :
    (item.isCollapsed ? <span class="hljs-string">'icon-expander'</span> : <span class="hljs-string">'icon-collapser'</span>) }</span>`</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたテンプレートリテラルを含むES2015では：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> classes = <span class="hljs-string">`header <span class="hljs-subst">${ isLargeScreen() ? <span class="hljs-string">''</span> :
<span class="hljs-string">`icon-<span class="hljs-subst">${item.isCollapsed ? <span class="hljs-string">'expander'</span> : <span class="hljs-string">'collapser'</span>}</span>`</span> }</span>`</span>;</code></pre><br>
<cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タグテンプレート</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
テンプレートリテラルの拡張形式はタグテンプレートです。</font><font style="vertical-align: inherit;">これらを使用すると、関数を使用してテンプレートリテラルを解析できます。</font><font style="vertical-align: inherit;">このような関数の最初の引数には文字列値の配列が含まれ、残りには置換の式が含まれます。</font><font style="vertical-align: inherit;">その結果、関数はアセンブルされた文字列（または、後で示すように、まったく異なるもの）を返す必要があります。</font><font style="vertical-align: inherit;">関数の名前は何でもかまいません。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-string">'Mike'</span>;
<span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTag</span>(<span class="hljs-params">strings, personExp, ageExp</span>) </span>{
  <span class="hljs-keyword">var</span> str0 = strings[<span class="hljs-number">0</span>]; <span class="hljs-comment">// "That "</span>
  <span class="hljs-keyword">var</span> str1 = strings[<span class="hljs-number">1</span>]; <span class="hljs-comment">// " is a "</span><font></font>
<font></font>
  <span class="hljs-comment">// ,    </span>
  <span class="hljs-comment">// (  )    ,</span>
  <span class="hljs-comment">//    (""),    .</span>
  <span class="hljs-comment">// var str2 = strings[2];</span><font></font>
<font></font>
  <span class="hljs-keyword">var</span> ageStr;
  <span class="hljs-keyword">if</span> (ageExp &gt; <span class="hljs-number">99</span>){<font></font>
    ageStr = <span class="hljs-string">'centenarian'</span>;<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    ageStr = <span class="hljs-string">'youngster'</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//     ,    </span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${str0}</span><span class="hljs-subst">${personExp}</span><span class="hljs-subst">${str1}</span><span class="hljs-subst">${ageStr}</span>`</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> output = myTag<span class="hljs-string">`That <span class="hljs-subst">${ person }</span> is a <span class="hljs-subst">${ age }</span>`</span>;<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(output);<span class="hljs-comment">// That Mike is a youngster</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タグ関数は文字列を返す必要はありません。</font></font><br>
<cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未加工</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
文字列タグテンプレートの最初の引数で使用できる特別な未加工プロパティを使用すると、解釈せずに、入力された形式の文字列を取得できます。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tag</span>(<span class="hljs-params">strings</span>) </span>{
  <span class="hljs-keyword">return</span> strings.raw[<span class="hljs-number">0</span>];<font></font>
}<font></font>
<font></font>
tag<span class="hljs-string">`string text line 1 \\n string text line 2`</span>;
<span class="hljs-comment">//  "string text line 1 \\n string text line 2",</span>
<span class="hljs-comment">//  'n'    '\'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、デフォルトのテンプレート関数とまったく同じソース文字列を返すString.raw（）メソッドがあり、文字列連結は一緒に返されます。</font></font><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMAScript 2016では、タグ付きテンプレートは、次の文字をエスケープするためのルールに従います。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 「\ u」で始まるUnicode文字、たとえば、\ u00A9</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 「\ u {}」で始まるUnicodeコードポイント、たとえば、\ u {2F804}</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 「\ x」で始まる16進文字表現、たとえば、\ xA9</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 「\」で始まる文字の8進表現。たとえば、\ 251</font></font></li>
</ul><br>
<cut></cut><br>
<a name="section002"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レットアンドコンスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
letおよびconstキーワードによって宣言された変数のスコープは、それらが宣言されているブロックと、ブロックの下のすべてのブロックです。この点で、letディレクティブの操作はvarディレクティブの操作と似ています。主な違いは、varディレクティブによって宣言された変数のスコープが、それが宣言されている関数全体であることです。変数に加えて、定数の値は、新しい割り当てによって変更することも、再定義することもできません。 constキーワードで変数を宣言するときは、代入演算子を使用して定数の値を設定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var変数とは異なり、グローバル定数はウィンドウオブジェクトのプロパティにはなりません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数の初期化が必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言と同時に値を指定する必要があります（つまり、この値は変更できなくなります）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
constキーワードを使用して変数を宣言すると、読み取り専用の定数（メモリ領域への新しい名前付き参照）が作成されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、示された値が変更されていないことを意味するのではなく、識別子を再割り当てできないことを意味します。</font><font style="vertical-align: inherit;">たとえば、定数がオブジェクトを指している場合、オブジェクト自体を変更できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数の名前は、同じスコープの関数または変数の名前と一致させることはできません。</font></font><cut></cut><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルスコープとブロックスコープの違いの例：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)
        <span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//SyntaxError   a     if</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)
        <span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//5   b    </span>
}</code></pre><br>
<br>
<a name="section003"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アロー関数式</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロー関数式の構文は関数式よりも短く、字句的にthisの値に関連付けられています（ただし、独自のthis、arguments、super、またはnew.targetには関連付けられていません）。</font><font style="vertical-align: inherit;">矢印関数の式では名前を指定できません。そのため、矢印関数は、何も割り当てられていない限り匿名です。</font></font><br>
<cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な構文</font></font></b><br>
<pre><code class="javascript hljs">(param1, param2, …, paramN) =&gt; { statements }<font></font>
(param1, param2, …, paramN) =&gt; expression<font></font>
<span class="hljs-comment">// : (param1, param2, …, paramN) =&gt; { return expression; }</span><font></font>
<font></font>
<span class="hljs-comment">//       :</span><font></font>
(singleParam) =&gt; { statements }<font></font>
singleParam =&gt; { statements }<font></font>
<font></font>
<span class="hljs-comment">//       :</span><font></font>
() =&gt; { statements }<font></font>
() =&gt; expression <font></font>
<span class="hljs-comment">// : () =&gt; { return expression; }</span></code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張構文</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     ,    </span>
params =&gt; ({<span class="hljs-attr">foo</span>: bar})<font></font>
<font></font>
<span class="hljs-comment">// Rest      </span><font></font>
(param1, param2, ...rest) =&gt; { statements }<font></font>
(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; { statements }<font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> f = <span class="hljs-function">(<span class="hljs-params">[a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], {x: c} = {x: a + b}</span>) =&gt;</span> a + b + c;<font></font>
f();  <span class="hljs-comment">// 6</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矢印関数の詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section004"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for ... ofステートメントは、反復可能なオブジェクト（配列、マップ、セット、引数のオブジェクトなどを含む）を介してループを実行し、オブジェクトのさまざまなプロパティから各値の各反復ステップで演算子を呼び出します。</font></font><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しにfor ... inループを使用すべきではないのはなぜですか？エンジンによっては、JavaScriptがランダムな順序で反復できるため、予期しない結果が生じる可能性があります。プロパティが1回の反復で変更され、その後再び変更される場合、ループ内のその値は最後の値です。サイクルに達する前に削除されたプロパティは、それに参加しません。ループ内のオブジェクトに追加されたプロパティはスキップされる場合があります。一般に、まだ渡していない場合は、反復中にオブジェクトのプロパティを追加、変更、または削除しないことをお勧めします。追加されたプロパティがサイクルによってアクセスされ、変更後に変更され、削除後に削除される保証はありません。さらに、反復変数は数値ではなく文字列です。つまり、変数を使用して計算を行う場合は、文字列を追加するのではなく、連結する必要があります。したがって、論理エラーを回避するために、使用しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for ... ofループとは異なり、for ... inループは、整数以外の名前や継承されたプロパティを含む、列挙されたすべてのプロパティを返します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for ... ofループ構文</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">of</span> arr) <span class="hljs-comment">//for ( of )</span>
    arr[i] = <span class="hljs-string">"something value"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Object</span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; 
<span class="hljs-built_in">Array</span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};<font></font>
<font></font>
<span class="hljs-keyword">let</span> iterable = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<font></font>
iterable.foo = <span class="hljs-string">'hello'</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> iterable)
    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom"</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> iterable) {
    <span class="hljs-keyword">if</span> (iterable.hasOwnProperty(i))
        <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">//  0, 1, 2, "foo"</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> iterable)
    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 3, 5, 7</span>
</code></pre><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各オブジェクトはobjCustomメソッドを継承し、各配列はObject.prototypeおよびArray.prototypeで作成することによりarrCustomメソッドを継承します。反復可能オブジェクトは、プロトタイプの継承により、objCustomおよびarrCustomメソッドを継承します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループは、反復可能オブジェクトの列挙されたプロパティのみを、作成された順序で表示します。列挙できないため、値3、5、7、およびhelloは出力されません。プロパティとメソッドの名前が表示されます（arrCustom、objCustomなど）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループは前のループと似ていますが、hasOwnProperty（）を使用して、オブジェクトのこのプロパティが独自のものか継承されているかを確認します。自分のプロパティのみが表示されます。名前0、1、2、およびfooは、オブジェクトのインスタンスにのみ属します（継承されません）。 arrCustomおよびobjCustomメソッドは継承されているため、出力されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このループは、反復可能オブジェクトをバイパスし、反復処理のメソッドで定義された反復可能オブジェクトのこれらの値を表示します。</font><font style="vertical-align: inherit;">オブジェクトのプロパティではなく、配列3、5、7の値</font></font><br>
<br>
<a name="section005"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算されたプロパティ名</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトとその要素を宣言する構文は、計算されたプロパティ名をサポートします。</font><font style="vertical-align: inherit;">これにより、プロパティの名前として評価される式を角かっこ[]に追加できます。</font><font style="vertical-align: inherit;">これはテンプレートリテラルに似ています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算された名前の例：</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">"world"</span>;<font></font>
<font></font>
<span class="hljs-keyword">var</span> a = {<font></font>
	[<span class="hljs-string">"a"</span> + (<span class="hljs-number">10</span> - <span class="hljs-number">6</span>)]: {<font></font>
		[<span class="hljs-string">"some"</span> + <span class="hljs-string">"string"</span>]: <span class="hljs-literal">true</span>,<font></font>
		[<span class="hljs-number">10</span> + <span class="hljs-number">20</span>]: <span class="hljs-number">10</span>,<font></font>
		[<span class="hljs-string">`hello <span class="hljs-subst">${a()}</span>`</span>]: a()<font></font>
	}<font></font>
}</code></pre><br>
<cut></cut><br>
<br>
<a name="section006"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Object.assign（）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.assign（）メソッドは、1つ以上のソースオブジェクトからターゲットオブジェクトに、それ自体の列挙されたすべてのプロパティの値をコピーするために使用されます。</font><font style="vertical-align: inherit;">コピー後、ターゲットオブジェクトを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.assign（）メソッドは、列挙されたネイティブプロパティのみをソースオブジェクトからターゲットオブジェクトにコピーします。ソースオブジェクトの内部[[Get]]メソッドとターゲットオブジェクトの内部[[Set]]メソッドを使用するため、ゲッターとセッターも呼び出します。これが、新しいプロパティを単にコピーまたは定義するのではなく、プロパティを割り当てる理由です。この動作により、注入されたソースオブジェクトにゲッターが含まれている場合、プロトタイプに新しいプロパティを注入するにはメソッドが不適切になる可能性があります。代わりに、列挙の記号を含むプロパティ定義のプロトタイプをプロトタイプにコピーするには、Object.getOwnPropertyDescriptor（）およびObject.defineProperty（）メソッドを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字列とシンボルの両方のタイプのプロパティがコピーされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーが発生した場合、たとえば、プロパティが書き込み可能でない場合、TypeError例外がスローされ、ターゲットオブジェクトは変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期値がnullまたは未定義の場合、Object.assign（）メソッドは例外をスローしないことに注意してください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例：オブジェクトの複製</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">Object</span>.assign({}, obj);
<span class="hljs-built_in">console</span>.log(copy); <span class="hljs-comment">// { a: 1 }</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例：オブジェクトのマージ</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> o1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">var</span> o2 = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> o3 = { <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };<font></font>
<font></font>
<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.assign(o1, o2, o3);
<span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// { a: 1, b: 2, c: 3 }</span>
<span class="hljs-built_in">console</span>.log(o1);  <span class="hljs-comment">// { a: 1, b: 2, c: 3 },     .</span></code></pre><br>
<br>
<a name="section007"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りのパラメータ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の残りのパラメーターの構文により、無制限の引数のセットを配列の形式で表すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に指定された関数の引数にプレフィックス...が付いている場合、関数に渡される実際の引数の数に従って、0からtheArgs.lengthまでの要素を持つ配列が自動的に作成されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, ...theArgs</span>) </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りのパラメーターの構文の使用例：</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span> (<span class="hljs-params">a, b, ...c</span>) </span>{}<font></font>
name (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、a = 0 b = 1 c [0] = 2 c [1] = 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りのパラメーターが渡されない場合、空の配列になります（通常のパラメーターとは異なり、未定義になることはありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構文は、関数の引数だけでなく、配列のコピーや結合など、他の場所でも使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> b = [ <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ];<font></font>
<font></font>
<span class="hljs-keyword">var</span> c = [ ...a, ...b ]; <span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></code></pre><br>
<br>
<a name="section008"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのパラメーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトのパラメーターを使用すると、関数が引数なしで呼び出された場合、またはパラメーターが明示的に未定義で渡された場合に、正式な関数パラメーターをデフォルト値に設定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptでは、呼び出されたときに値が渡されない関数のパラメーターは、デフォルト値が未定義になります。</font><font style="vertical-align: inherit;">ただし、別のデフォルト値を設定すると便利な場合があります。</font><font style="vertical-align: inherit;">デフォルト設定が意図されているのは、そのような場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数呼び出し中にこのパラメーターの値が渡されなかった場合、またはundefinedが明示的に渡された場合にのみ、デフォルト値が仮パラメーターに割り当てられます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトパラメータの使用例：</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span>(<span class="hljs-params">a=<span class="hljs-number">5</span></span>) </span>{
	<span class="hljs-keyword">return</span> a*a;<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(myFun()); <span class="hljs-comment">// 25</span></code></pre><cut></cut><br>
<br>
<a name="section009"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解体任務</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript式の構造化代入構文を使用すると、オブジェクトで配列またはリテラルを宣言するのと同様の構文を使用して、配列またはオブジェクトからデータを取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトまたは配列の宣言式は、同種のデータのパッケージを作成する簡単な方法を提供します。</font><font style="vertical-align: inherit;">そのようなパッケージを作成するとき、あなたは可能な限りあらゆる方法でそれを使用する機会を得ます。</font><font style="vertical-align: inherit;">関数で返すこともできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
破壊的代入を使用する重要な方法の1つは、1つの演算子でデータ構造を読み取ることですが、これ以外にも多くの用途があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破壊的な割り当ての例：</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> a, b, rest;<font></font>
[a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 2</span><font></font>
<font></font>
[a, b, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.log(rest); <span class="hljs-comment">// [3, 4, 5]</span><font></font>
<font></font>
({a, b} = {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>});
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 2</span></code></pre><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
より多くの例を見ることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section010"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地図</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マップ-キーと値のペアを含み、挿入順序を保持するオブジェクト。</font><font style="vertical-align: inherit;">任意の値（オブジェクトとプリミティブの両方）をキーとして使用できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例：</font></font></b><cut></cut><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<font></font>
<font></font>
<span class="hljs-keyword">var</span> keyObj = {},<font></font>
    keyFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},<font></font>
    keyString = <span class="hljs-string">"a string"</span>;<font></font>
<font></font>
<span class="hljs-comment">//  </span>
myMap.set(keyString, <span class="hljs-string">"value associated with 'a string'"</span>);<font></font>
myMap.set(keyObj, <span class="hljs-string">"value associated with keyObj"</span>);<font></font>
myMap.set(keyFunc, <span class="hljs-string">"value associated with keyFunc"</span>);<font></font>
<font></font>
myMap.size; <span class="hljs-comment">// 3</span><font></font>
<font></font>
<span class="hljs-comment">//  </span>
myMap.get(keyString);    <span class="hljs-comment">// "value associated with 'a string'"</span>
myMap.get(keyObj);       <span class="hljs-comment">// "value associated with keyObj"</span>
myMap.get(keyFunc);      <span class="hljs-comment">// "value associated with keyFunc"</span><font></font>
<font></font>
myMap.get(<span class="hljs-string">"a string"</span>);   <span class="hljs-comment">// "value associated with 'a string'"</span>
                         <span class="hljs-comment">//   keyString === 'a string'</span>
myMap.get({});           <span class="hljs-comment">// undefined,   keyObj !== {}</span>
myMap.get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}) <span class="hljs-comment">// undefined,   keyFunc !== function () {}</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトとマップの違い：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトキーは線と記号ですが、関数、オブジェクト、プリミティブを含む任意の値をマップキーにすることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトとは異なり、マップのキーは順序付けられています。</font><font style="vertical-align: inherit;">したがって、マップの反復中に、キーは挿入順に返されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの要素数は手動でしか決定できないのに対して、sizeプロパティを使用してマップの要素数を簡単に取得できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マップは反復可能なオブジェクトであり、直接反復できますが、オブジェクトはキーのリストとその反復を手動で受信する必要があります。</font></font></li>
<li>        , ,  ,     .    ES5       map = Object.create(null).</li>
<li>Map            .</li>
</ul><cut></cut><br>
<b>  :</b><br>
<br>
<ul>
<li>Map.prototype.size —    \  Map </li>
<li>Map.prototype.set(key, value) —    \  Map.          .</li>
<li>Map.prototype.get(key) —    .   ,   undefined</li>
<li>Map.prototype.has(key) —  true      false   </li>
<li>Map.prototype.delete(key) —    \   true.  false    </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map.prototype.clear（）-すべてのキーと値のペアをマップから削除します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map.prototype.keys（）-各要素のマップ上のキーのイテレータを返します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map.prototype.values（）-各要素のマップ上の値のイテレータを返します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map.prototype.entries（）-各要素のMapの配列[キー、値]のイテレータを返します</font></font></li>
</ul><cut></cut><br>
<br>
<a name="section011"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットする</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブと他のタイプのオブジェクトの両方の任意のタイプの一意の値を保存できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セットオブジェクトは、要素の挿入順にトラバースできる値のコレクションを表します。</font><font style="vertical-align: inherit;">Set内の要素の値は1つのインスタンスにのみ存在でき、これにより、Setコレクション内での一意性が保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティとインスタンスメソッドセット</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size-Setオブジェクトの要素数を返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add（値）-指定された値を持つ新しい要素をSetオブジェクトに追加します。</font><font style="vertical-align: inherit;">Setオブジェクトを返します。</font></font></li>
<li>clear() —      Set.</li>
<li>delete(value) —  ,   ,   ,  has (value)   . has (value)  false .</li>
<li>entries() —    Iterator,    [value, value]      Set   .     Map,             .</li>
<li>forEach(callbackFn[, thisArg]) —  callbackFn     ,    Set,   .   thisEach   thisArg,       this    .</li>
<li>has(value) —   , ,         Set  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">values（）-Setオブジェクトの各要素の値を挿入順に含む新しいIteratorオブジェクトを返します。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setオブジェクトの使用</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<font></font>
<font></font>
mySet.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// Set { 1 }</span>
mySet.add(<span class="hljs-number">5</span>); <span class="hljs-comment">// Set { 1, 5 }</span>
mySet.add(<span class="hljs-number">5</span>); <span class="hljs-comment">// Set { 1, 5 }</span>
mySet.add(<span class="hljs-string">"some text"</span>); <span class="hljs-comment">// Set { 1, 5, 'some text' }</span>
<span class="hljs-keyword">var</span> o = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>};<font></font>
mySet.add(o);<font></font>
<font></font>
mySet.add({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}); <span class="hljs-comment">//  o    ,     </span><font></font>
<font></font>
mySet.has(<span class="hljs-number">1</span>); <span class="hljs-comment">// true</span>
mySet.has(<span class="hljs-number">3</span>); <span class="hljs-comment">// false, 3     set</span>
mySet.has(<span class="hljs-number">5</span>);              <span class="hljs-comment">// true</span>
mySet.has(<span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">25</span>));  <span class="hljs-comment">// true</span>
mySet.has(<span class="hljs-string">"Some Text"</span>.toLowerCase()); <span class="hljs-comment">// true</span>
mySet.has(o); <span class="hljs-comment">// true</span><font></font>
<font></font>
mySet.size; <span class="hljs-comment">// 5</span><font></font>
<font></font>
mySet.delete(<span class="hljs-number">5</span>); <span class="hljs-comment">//  5  set</span>
mySet.has(<span class="hljs-number">5</span>);    <span class="hljs-comment">// false, 5  </span><font></font>
<font></font>
mySet.size; <span class="hljs-comment">// 4,    </span>
<span class="hljs-built_in">console</span>.log(mySet); <span class="hljs-comment">// Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイパスセット</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2}</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet) <span class="hljs-built_in">console</span>.log(item);<font></font>
<font></font>
<span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2}</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet.keys()) <span class="hljs-built_in">console</span>.log(item);<font></font>
 <font></font>
<span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2}</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet.values()) <span class="hljs-built_in">console</span>.log(item);<font></font>
<font></font>
<span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} </span>
<span class="hljs-comment">//(key  value    )</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> mySet.entries()) <span class="hljs-built_in">console</span>.log(key);<font></font>
<font></font>
<span class="hljs-comment">//  Set  Array</span>
<span class="hljs-keyword">var</span> myArr = <span class="hljs-built_in">Array</span>.from(mySet); <span class="hljs-comment">// [1, "some text", {"a": 1, "b": 2}]</span><font></font>
<font></font>
<span class="hljs-comment">//       HTML </span>
mySet.add(<span class="hljs-built_in">document</span>.body);<font></font>
mySet.has(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"body"</span>)); <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-comment">//   Array  Set  </span>
mySet2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<font></font>
mySet2.size; <span class="hljs-comment">// 4</span>
[...mySet2]; <span class="hljs-comment">// [1,2,3,4]</span><font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-keyword">var</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set1].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> set2.has(x)));<font></font>
<font></font>
<span class="hljs-comment">//     </span>
<span class="hljs-keyword">var</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set1].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !set2.has(x))); <font></font>
<font></font>
<span class="hljs-comment">//   set   forEach</span>
mySet.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-built_in">console</span>.log(value);<font></font>
});<font></font>
<font></font>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 4</span></code></pre><br>
<cut></cut><br>
<br>
<a name="section012"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptのクラスはECMAScript 2015で導入され、JavaScriptのプロトタイプ継承に対する構文糖衣です。</font><font style="vertical-align: inherit;">クラス構文は新しいオブジェクト指向モデルを導入しませんが、オブジェクトを作成して継承を編成するためのよりシンプルで直感的な方法を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスは実際には「特別な関数」であるため、関数（関数式と関数宣言）を定義するのと同じように、クラスをクラス宣言とクラス式で定義できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数宣言とクラス宣言の違いは、関数宣言はホイストされるのに対し、クラス宣言はホイストしないことです。</font><font style="vertical-align: inherit;">したがって、最初にクラスを宣言してから作業する必要があります。そうしないと、ReferenceError型の例外がスローされます。</font></font><br>
<cut></cut><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス宣言</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを定義する最初の方法は、クラス宣言を使用することです。</font><font style="vertical-align: inherit;">これを行うには、classキーワードを使用してクラス名を指定します（この例では「myClass」）。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span></span>{
    <span class="hljs-keyword">constructor</span>(height, width) {
        <span class="hljs-keyword">this</span>.height = height;
        <span class="hljs-keyword">this</span>.width = width;<font></font>
    }<font></font>
}</code></pre><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを定義する2番目の方法は、クラス式です。</font><font style="vertical-align: inherit;">名前付き式と名前なし式を作成できます。</font><font style="vertical-align: inherit;">最初のケースでは、クラス式の名前はクラスのローカルスコープ内にあり、インスタンスではなくクラス自体のプロパティを介して取得できます。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-keyword">var</span> myClass = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-keyword">constructor</span>(height, width) {
        <span class="hljs-keyword">this</span>.height = height;
        <span class="hljs-keyword">this</span>.width = width;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">var</span> myClass = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>{
    <span class="hljs-keyword">constructor</span>(height, width) {
        <span class="hljs-keyword">this</span>.height = height;
        <span class="hljs-keyword">this</span>.width = width;<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス式は、クラス宣言と同じ巻き上げ問題の影響を受けます！</font></font><cut></cut><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス宣言本体とクラス式は、厳密モードで実行されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密モードは、ランタイムの構文と動作を変更します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より正確に言うと、strictモードは次の特徴があります。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーを例外に変換する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前を使用する特定のケースで変数の計算を簡略化する変更。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evalと引数を簡略化する変更。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「安全な」JavaScriptの記述を簡素化する変更。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーを例外に変換する</font></font></b><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行時エラーは、未処理の例外に変換されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誤ってグローバル変数を作成することはできません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それでも失敗する割り当ては例外をスローします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除できないプロパティを削除しようとすると、例外がスローされます（そのような試みが行われる前は、単に効果がありませんでした）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化されたオブジェクトにリストされているすべてのプロパティは、1回だけ出現する必要があります。</font><font style="vertical-align: inherit;">通常のコードでは、プロパティ名を重複させることができ、プロパティの値は最後の宣言によって決定されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数宣言の引数名が1回だけ検出されました。</font><font style="vertical-align: inherit;">通常のコードでは、最後に繰り返された引数により、同じ名前の以前の引数が非表示になります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8進数システムの構文は禁止されています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ値でプロパティを設定することは禁止されています。</font></font></li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数を使用した作業の</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
簡略化厳密モードでは、変数名とコード内の定義の場所との比較が簡略化されます。</font></font><br>
<ol>
<li>  with.   with  ,               ,       (   )  —     .   with   —                .</li>
<li>eval()          .</li>
<li>   .</li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evalと引数の簡素化</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Strictモードは、引数とevalの動作の奇数の数を減らします。どちらも、通常のコードに一定量の魔法を混ぜます。</font><font style="vertical-align: inherit;">したがって、evalは変数を追加または削除し、それらの値を変更します。arguments変数は、名前付き関数の引数の参照（同義語）であるそのインデックス付きプロパティで驚くかもしれません。</font></font><cut></cut><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワードevalおよびargumentsは、オーバーライドまたは変更できません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数オブジェクトのフィールドは、名前付き関数の引数に関連付けられていませんが、値の複製されたコピーです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arguments.calleeプロパティはサポートされていません。</font><font style="vertical-align: inherit;">通常のコードでは、arguments.calleeプロパティは、argumentsオブジェクトが作成された呼び出しの関数自体を参照します。</font></font></li>
</ol><cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「安全な」JavaScript</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一部のWebサイトは、他のユーザーに代わってサイトで実行されるJavaScriptを作成する機能をユーザーに提供します。</font><font style="vertical-align: inherit;">ブラウザでは、JavaScriptが個人情報にアクセスする可能性があります。これはJavaScriptのセキュリティホールです。</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密モードではオブジェクトにキャストされないため、関数に渡される値。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なECMAScript拡張を介してJavaScriptスタックを「実行」することはできません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数では、argumentsプロパティは関数内で作成された変数へのアクセスを提供しなくなりました。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strictモードの詳細について</font><font style="vertical-align: inherit;">
は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">仕様</font></a><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">参照し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">て</font></a><font style="vertical-align: inherit;">ください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また</font><font style="vertical-align: inherit;">、Mozillaからの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<cut></cut><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンストラクタ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクタは、クラスを使用して作成されたオブジェクトを作成および初期化するために使用される特別なメソッドです。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{
	<span class="hljs-keyword">constructor</span>(name) {
    	    <span class="hljs-keyword">this</span>.name = name;<font></font>
  	}<font></font>
}<font></font>
<span class="hljs-keyword">var</span> robert = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Robert'</span>);
<span class="hljs-built_in">console</span>.log(robert.name);  <span class="hljs-comment">// Outputs 'Robert'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスから新しいオブジェクトを作成するとき、オブジェクトの初期化に必要なコンストラクター（）が起動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクターと呼ばれるクラス内に存在できるメソッドは1つだけです。</font><font style="vertical-align: inherit;">クラスに複数のコンストラクターが含まれている場合、SyntaxError例外がスローされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
superキーワードをコンストラクターで使用して、親クラスのコンストラクターを呼び出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクターメソッドを定義しなかった場合は、デフォルトのコンストラクターが使用されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本クラスの場合、デフォルトのコンストラクタは次のとおりです。</font></font><pre><code class="javascript hljs"><span class="hljs-keyword">constructor</span>() {}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生クラスの場合、デフォルトのコンストラクタは次のとおりです。</font></font><pre><code class="javascript hljs"><span class="hljs-keyword">constructor</span>(...args) {
  <span class="hljs-keyword">super</span>(...args);<font></font>
}</code></pre><br>
<cut></cut><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド宣言構文：</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = {<font></font>
    property([parameters]) {},<font></font>
    <span class="hljs-keyword">get</span> <span class="hljs-title">property</span>() {},
    <span class="hljs-keyword">set</span> <span class="hljs-title">property</span>(<span class="hljs-params">value</span>) {},<font></font>
    * generator() {}<font></font>
};</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速記ジェネレーターメソッド</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = { <font></font>
    * g() {<font></font>
        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
            <span class="hljs-keyword">yield</span> index++;<font></font>
    }<font></font>
};<font></font>
<span class="hljs-keyword">var</span> it = obj.g();
<span class="hljs-built_in">console</span>.log(it.next().value); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.log(it.next().value); <span class="hljs-comment">// 1</span></code></pre><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターメソッドを除くすべてのメソッド定義はコンストラクターにすることはできず、インスタンス化しようとするとTypeErrorがスローされます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算されたプロパティ名</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = {<font></font>
    [<span class="hljs-string">"foo"</span> + <span class="hljs-number">2</span>](){ <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; }<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(obj.foo2()); <span class="hljs-comment">// 2</span>
};</code></pre><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
staticキーワードは、クラスの静的メソッドを定義します。</font><font style="vertical-align: inherit;">静的メソッドは、クラスをインスタンス化せずに呼び出され、クラスのインスタンスで呼び出すことはできません。</font></font><br>
<cut></cut><cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲッターとセッターの構文</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{
	<span class="hljs-keyword">constructor</span>(name) {
    	        <span class="hljs-keyword">this</span>.name = name;<font></font>
  	}<font></font>
  	<span class="hljs-keyword">get</span> <span class="hljs-title">Name</span>() {
  		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<font></font>
  	}<font></font>
  	<span class="hljs-keyword">set</span> <span class="hljs-title">Name</span>(<span class="hljs-params">newName</span>) {
  		<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(newName) != <span class="hljs-string">"string"</span>)
  			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Name is not a string!"</span>);
  		<span class="hljs-keyword">else</span>
  			<span class="hljs-keyword">this</span>.name = newName; <span class="hljs-comment">// Robert</span><font></font>
  	}<font></font>
}<font></font>
<span class="hljs-keyword">var</span> robert = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'robert'</span>);<font></font>
robert.Name = <span class="hljs-string">"Robert"</span>;
<span class="hljs-built_in">console</span>.log(robert.Name);</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッター-書き込まれたパラメーターの検証に必要（上記の例のように）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter-プロパティを取得するために必要です（ただし、直接取得できます）。</font><font style="vertical-align: inherit;">引数を持つことはできません</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6には組み込みのカプセル化はありませんが、自分で構成することができます。</font><font style="vertical-align: inherit;">たとえば、次のようになります。</font></font><br>
<cut></cut><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> Student = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">let</span> privateProps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    	        <span class="hljs-keyword">constructor</span>(name, Age) {
      		        <span class="hljs-keyword">this</span>.name = name; <span class="hljs-comment">// public</span>
      		        privateProps.set(<span class="hljs-keyword">this</span>, {<span class="hljs-attr">age</span>: Age}); <span class="hljs-comment">// private</span><font></font>
    	        }<font></font>
    	        <span class="hljs-keyword">get</span> <span class="hljs-title">Age</span>() {
      		        <span class="hljs-keyword">return</span> privateProps.get(<span class="hljs-keyword">this</span>).age;<font></font>
    	        }<font></font>
    	        set Age (newAge) {<font></font>
    		        privateProps.set(<span class="hljs-keyword">this</span>, {<span class="hljs-attr">age</span>: newAge});<font></font>
    	        }<font></font>
  	}<font></font>
  	<span class="hljs-keyword">return</span> Person;<font></font>
})();<font></font>
<span class="hljs-keyword">var</span> robert = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Robert'</span>, <span class="hljs-number">19</span>);<font></font>
robert.Age = <span class="hljs-number">20</span>;
<span class="hljs-built_in">console</span>.log(robert.Age); <span class="hljs-comment">// 20</span></code></pre><br>
<cut></cut><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
extendsキーワードは、クラス宣言およびクラス式で使用され、別のクラスの子であるクラスを作成します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
	<span class="hljs-keyword">constructor</span> (age) {
		<span class="hljs-keyword">this</span>.age = age;<font></font>
	}<font></font>
	sayAge () {<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<font></font>
	}<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{
	<span class="hljs-keyword">constructor</span> (name, age) {
		<span class="hljs-keyword">super</span>(age);
		<span class="hljs-keyword">this</span>.name = name;<font></font>
	}<font></font>
	sayFull () {<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-string">`Hello my name is <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span> and I'm <span class="hljs-subst">${<span class="hljs-keyword">super</span>.sayAge()}</span> years old`</span>;<font></font>
	}<font></font>
}<font></font>
<span class="hljs-keyword">var</span> robert = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Robert"</span>, <span class="hljs-number">19</span>);
<span class="hljs-built_in">console</span>.log(robert.sayFull()); <span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></code></pre><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクターでは、親コンストラクターを呼び出す関数としてsuper（）キーワードが使用されます。</font><font style="vertical-align: inherit;">コンストラクターの本体でthisキーワードを最初に呼び出す前に呼び出す必要があります。</font><font style="vertical-align: inherit;">superキーワードは、親オブジェクトの関数を呼び出すためにも使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子クラスの親クラスのメソッドをオーバーライドすると、デフォルトで子クラスのメソッドが呼び出されますが、super（）関数を使用して親クラスのメソッドを明示的に呼び出すことができます。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">obj</span> </span>{
  <span class="hljs-keyword">constructor</span>(name){
    <span class="hljs-keyword">this</span>.name = name;<font></font>
  }<font></font>
  <font></font>
  displayName(){<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.length;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-literal">undefined</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">obj_2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">obj</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">super</span>(name);<font></font>
  }<font></font>
  <font></font>
  displayName() { <span class="hljs-comment">//    </span>
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">super</span>.displayName()];<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> Obj = <span class="hljs-keyword">new</span> obj_2(<span class="hljs-string">"obj_2"</span>);
<span class="hljs-built_in">console</span>.log(Obj.displayName()); <span class="hljs-comment">// Array [ "obj_2", 5 ]</span>
</code></pre><cut></cut><br>
<cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extendsを使用したインラインオブジェクトの拡張</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この例では、インラインDateオブジェクトを拡張しています。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myDate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Date</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();<font></font>
  }<font></font>
<font></font>
  getFormattedDate() {<font></font>
    <span class="hljs-keyword">var</span> months = [
      <span class="hljs-string">'Jan'</span>, <span class="hljs-string">'Feb'</span>, <span class="hljs-string">'Mar'</span>, <span class="hljs-string">'Apr'</span>, <span class="hljs-string">'May'</span>, <span class="hljs-string">'Jun'</span>,
      <span class="hljs-string">'Jul'</span>, <span class="hljs-string">'Aug'</span>, <span class="hljs-string">'Sep'</span>, <span class="hljs-string">'Oct'</span>, <span class="hljs-string">'Nov'</span>, <span class="hljs-string">'Dec'</span><font></font>
    ];<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getDate() + <span class="hljs-string">'-'</span> +<font></font>
      months[<span class="hljs-keyword">this</span>.getMonth()] + <span class="hljs-string">'-'</span> +
      <span class="hljs-keyword">this</span>.getFullYear();<font></font>
  }<font></font>
}</code></pre><br>
<br>
<a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseオブジェクトは、遅延計算と非同期計算に使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseには次の3つの状態があります。</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留中：初期状態。完了しておらず、拒否もされていません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了：操作は正常に完了しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rejected：操作はエラーで完了しました。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロミスを作成するとき、それは保留されており、結果（値）を返すことで実現されるか、拒否の理由を返すことで拒否されます。</font><font style="vertical-align: inherit;">これらのいずれの場合でも、thenメソッドを使用してpromiseにアタッチされているハンドラーが呼び出されます。</font><font style="vertical-align: inherit;">（アポイントメントPROMISハンドラーの時刻がすでに許可または拒否されている場合でも、ハンドラーは呼び出されます。つまり、PROMISの非同期実行とハンドラーのアポイントメントは、たとえばDOMのイベントの場合のように、「競合状態」では発生しません。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、 Promise.prototype.then（）メソッドとPromise.prototype.catch（）メソッド自体がどのようにPromiseを返すか、それらをチェーンで呼び出して接続を作成できます。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="画像"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束をする（約束）</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseオブジェクトは、newキーワードとそのコンストラクターを使用して作成されます。</font><font style="vertical-align: inherit;">Promiseコンストラクタは、「エグゼキュータ関数」と呼ばれる関数を引数として取ります。</font><font style="vertical-align: inherit;">この関数は、パラメーターとして2つのコールバック関数を受け入れる必要があります。</font><font style="vertical-align: inherit;">最初の1つ（解決）は、非同期操作が正常に完了し、その実行結果を値として返したときに呼び出されます。</font><font style="vertical-align: inherit;">2番目のコールバック（拒否）は、操作が失敗したときに呼び出され、失敗の理由を示す値（ほとんどの場合はエラーオブジェクト）を返します。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">//   ,    :</span>
   resolve(someValue); <span class="hljs-comment">//  </span>
  <span class="hljs-comment">// </span>
  reject(<span class="hljs-string">"failure reason"</span>); <span class="hljs-comment">// </span>
});</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resolve</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rejectの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2つの引数を持つ関数オブジェクト</font><font style="vertical-align: inherit;">は、promiseを成功させ、2番目はそれを拒否します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数にpromise機能を提供するには、Promiseオブジェクトを返すだけです。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAsyncFunction</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<font></font>
    xhr.open(<span class="hljs-string">"GET"</span>, url);<font></font>
    xhr.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(xhr.responseText);<font></font>
    xhr.onerror = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(xhr.statusText);<font></font>
    xhr.send();<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経由。</font><font style="vertical-align: inherit;">次に、実行ハンドラと拒否ハンドラがアタッチされます。</font></font><br>
<cut></cut><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all（反復可能）-すべてのプロミスが実行または拒否されるのを待ちます。</font><font style="vertical-align: inherit;">すべてのpromiseがiterableで実行された後に実行されるpromiseを返します。</font><font style="vertical-align: inherit;">いずれかの約束が拒否された場合、Promise.allも拒否されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled（反復可能）-受信したすべてのプロミス（実行と拒否の両方）の完了を待ちます。</font><font style="vertical-align: inherit;">受信したすべてのプロミスが完了（実行または拒否）されたときに実行されるプロミスを返します。これには、受信したプロミスの実行結果の配列が含まれます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race（iterable）-受け取ったpromiseの実行または拒否を待ちます。</font><font style="vertical-align: inherit;">.iterableからの最初の実行または拒否されたプロミスの実行結果とともに実行または拒否されるプロミスを返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.reject（reason）-理由により拒否されたpromiseを返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.resolve（値）-結果の値で実行されたpromiseを返します。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロミスプロトタイプ</font></font></b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch（onRejected）-コールバック関数を追加して、呼び出された場合は渡された値で作成された新しいプロミスを返し、プロミスが行われた場合は元の解決値を返すプロミスの拒否を処理します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then（onFulfilled、onRejected）-promiseのフルフィルメントと拒否のハンドラーを追加し、呼び出されたハンドラーの値で実行された新しいpromiseを返します。promiseが処理されなかった場合（つまり、対応するonFulfilledまたはonRejectedハンドラーが関数でない場合）は元の値を返します。 </font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期httpリクエストを作成する：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> URL = <span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span>; <span class="hljs-comment">//  API     </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncHttpRequest</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> { <span class="hljs-comment">//  promise</span>
  <span class="hljs-keyword">if</span> (url == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">//     url</span>
    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected url and received nothing"</span>));
  <span class="hljs-keyword">else</span> {<font></font>
    resolve(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      fetch(url).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> { <span class="hljs-comment">//  </span>
        <span class="hljs-keyword">return</span> response.json(); <span class="hljs-comment">//    JSON  </span>
  	  }).then(<span class="hljs-function">(<span class="hljs-params">myJson</span>) =&gt;</span> {
    	    <span class="hljs-keyword">return</span>(<span class="hljs-built_in">console</span>.log(myJson)); <span class="hljs-comment">//     </span><font></font>
  	  });<font></font>
	});<font></font>
      }<font></font>
    }<font></font>
);}<font></font>
<font></font>
asyncHttpRequest(URL).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> result(), (error) =&gt; <span class="hljs-built_in">console</span>.log(error));</code></pre><br>
<cut></cut><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font><font style="vertical-align: inherit;">Mozillaの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、約束に関するその他の例や情報を入手でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イテレータ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクション内の各アイテムの処理は非常に一般的な操作です。 JavaScriptは、単純なforループからマップ（）、フィルター（）、配列内包まで、コレクションを反復処理するいくつかの方法を提供します。イテレータとジェネレータは、列挙型の概念を言語のコアに直接実装し、ループの動作を設定するためのメカニズムを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシーケンス内の現在の位置を追跡しながら、コレクションの要素に一度に1つずつアクセスできる場合、オブジェクトはイテレータです。 JavaScriptでは、イテレータは、シーケンスの次の要素を返すnext（）メソッドを提供するオブジェクトです。このメソッドは、doneとvalueの2つのプロパティを持つオブジェクトを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成された反復子オブジェクトは、next（）メソッドを呼び出すことで明示的に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Iterable-これは、内容を反復できるオブジェクトです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反復可能オブジェクトは、特別なシンボルが使用されるアクセス用のオブジェクトを返す特別なメソッドを持っているという点で、反復不可能オブジェクトとは異なります。Symbol.iterator</font></font><br>
<pre><code class="javascript hljs">Iterable {<font></font>
    [<span class="hljs-built_in">Symbol</span>.iterator]()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドを返すオブジェクトは、正式にはイテレータと呼ばれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イテレータにはnext（）メソッドが1つだけあります</font></font><br>
<pre><code class="javascript hljs">Iterator {<font></font>
    next();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、2つのプロパティdoneと値を持つオブジェクト（itreratorResultと呼ぶことにします）を返します</font></font><br>
<pre><code class="javascript hljs">IteratorResult {<font></font>
    done,<font></font>
    value<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
doneは、検索されるシーケンスにまだ値があるかどうかを示します。値には、シーケンスの次の要素が含まれます。</font></font><br>
<cut></cut><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化後、next（）メソッドを呼び出して、オブジェクト内のキーと値のペアに1つずつアクセスできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトが値を列挙するためのメソッドを定義している場合、つまり、たとえば、値がfor..ofコンストラクトでどのように列挙されているかによって、オブジェクトは反復可能です。</font><font style="vertical-align: inherit;">ArrayやMapなどの一部の組み込み型はデフォルトで反復可能ですが、Objectなどの他の型はデフォルトで反復可能ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反復可能にするには、オブジェクトに反復子メソッドを実装する必要があります。つまり、オブジェクト（またはプロトタイプチェーンの上のオブジェクトの1つ）にSymbol.iteratorという名前のプロパティが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のイテレータは次のようになります。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeIterator</span>(<span class="hljs-params">array</span>)</span>{
    <span class="hljs-keyword">var</span> nextIndex = <span class="hljs-number">0</span>;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> {
       <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
           <span class="hljs-keyword">return</span> nextIndex &lt; array.length ? { <span class="hljs-attr">value</span>: array[nextIndex++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> } : { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };<font></font>
       }<font></font>
    }<font></font>
}</code></pre><br>
<br>
<a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発電機</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターは、イテレーターファクトリーのように機能する特別なタイプの関数です。</font><font style="vertical-align: inherit;">関数は、1つ以上のyieldステートメントを含み、function *構文を使用する場合、ジェネレーターになります。</font></font><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレータは、実行を一時停止して中間結果を返し、後で実行を再開できる新しい種類の関数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの計算をして結果を返す通常の関数を見てみましょう：</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params">a</span>) </span>{<font></font>
	a = a*<span class="hljs-number">2</span>;<font></font>
	a = a - <span class="hljs-number">1</span>;<font></font>
<font></font>
	<span class="hljs-keyword">return</span> a;<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(myFunction(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 9</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、同様のジェネレーター関数を見てみましょう。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params">a</span>) </span>{<font></font>
	a = a*<span class="hljs-number">2</span>;
	<span class="hljs-keyword">yield</span> a;<font></font>
	a = a - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">yield</span> a;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> it = generator(<span class="hljs-number">5</span>);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(it.next().value); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(it.next().value); <span class="hljs-comment">// 9&lt;/i&gt;</span></code></pre><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、ジェネレーターは実行を一時停止し、中間結果を返すことができます。この例は、最初の呼び出し時に、関数が最初のブレークポイントで実行を一時停止したかのように機能し、最初の式の結果を返すことを示しています。 2番目の呼び出しでは、関数は前のブレークポイントから継続して次のブレークポイントに移動し、次の式の結果を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数発生器は、複雑な順次関数を作成するための強力なツールを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターは、必要に応じて収量式の結果を計算します。これにより、計算が非常に複雑なシーケンス、または無限シーケンスを効率的に処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
next（）メソッドも、ジェネレーターの内部状態を変更するために使用できる値を取ります。 next（）に渡される値は、ジェネレーターを一時停止した最後のyield式の結果と見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
throw（）メソッドを呼び出して、スローする例外の値をパラメーターとして渡すことにより、ジェネレーターに例外をスローさせることができます。この例外は、現在の一時停止されたyieldステートメントがthrowステートメントであるかのように、ジェネレーターの現在の一時停止されたコンテキストからスローされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スローされた例外の処理中にyieldステートメントが発生しない場合、例外は上記のthrow（）呼び出しを介して渡され、next（）への後続の呼び出しの結果は、trueに等しいdoneプロパティになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターには、指定された値を返し、ジェネレーターを停止するreturn（value）メソッドがあります。</font></font><br>
<br>
<a name="section016"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンボル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンボルは、インスタンスが一意で不変のプリミティブデータ型です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptランタイムでは、「シンボル」値はSymbol（）関数を呼び出すことによって作成され、匿名で一意の値を動的に作成します。</font><font style="vertical-align: inherit;">唯一の妥当な使用法は、キャラクターを保存し、格納された値を使用してオブジェクトのプロパティを作成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティ割り当てで文字が識別子として使用されている場合、プロパティ（文字など）は匿名です。</font><font style="vertical-align: inherit;">また、カウントできません。</font><font style="vertical-align: inherit;">プロパティは計算できないため、「for（... in ...）」ループには表示されません。また、プロパティは匿名であるため、「Object.getOwnPropertyNames（）」結果配列には表示されません。</font><font style="vertical-align: inherit;">このプロパティへのアクセスは、それを作成したシンボルの初期値を使用するか、結果配列「Object.getOwnPropertySymbols（）」を反復することによって取得できます。</font></font><br>
<br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、文字プロパティを作成できます。</font></font><br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">var</span> user = {
	<span class="hljs-attr">name</span>: <span class="hljs-string">"Alex"</span>,<font></font>
	[<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"password"</span>)]: <span class="hljs-string">"12hsK3I"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字オブジェクトの配列を取得するには、Object.getOwnPropertySymbols（obj）プロパティを使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの任意の場所にアクセスするには、Symbol.for（）メソッドとSymbol.keyFor（）メソッドを使用します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Sumbolデータ型の詳細については、公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">Mozilla </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460729/index.html">楽しくて教育に役立つ</a></li>
<li><a href="../ja460731/index.html">アメリカ当局は2017年にロボットバス事故の調査を完了</a></li>
<li><a href="../ja460735/index.html">スタートアップのCI \ CD：どのようなツールがあり、大規模で有名な企業だけがそれらを使用しないのか</a></li>
<li><a href="../ja460737/index.html">背景を聞く：プロジェクト管理ポッドキャスト</a></li>
<li><a href="../ja460739/index.html">私たちはすべての人類から平和に来ました</a></li>
<li><a href="../ja460743/index.html">Flutter初心者向けガイド</a></li>
<li><a href="../ja460745/index.html">ホームオートメーションでGSMモジュールを使用した経験</a></li>
<li><a href="../ja460747/index.html">利益追求または引き締め：Spotifyは著者との直接の協力を停止しました-それはどういう意味ですか</a></li>
<li><a href="../ja460751/index.html">小さなチェルノブイリでロボットを打ち上げた方法。パート1</a></li>
<li><a href="../ja460755/index.html">ROSトロリーロボット-パート1：鉄</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>