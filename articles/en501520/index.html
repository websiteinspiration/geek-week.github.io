<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèø üíΩ ü•Å C # 8 and null validity. How do we live with this üè¥‚Äç‚ò†Ô∏è üöÉ üëºüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues! It's time to mention that we have plans to release Ian Griffiths' fundamental book on C # 8:
 
 
 In the meantime, on his blog, the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # 8 and null validity. How do we live with this</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello colleagues! </font><font style="vertical-align: inherit;">It's time to mention that we have plans to release </font><font style="vertical-align: inherit;">Ian Griffiths' </font><font style="vertical-align: inherit;">fundamental </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on C # 8:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/to/l-/iwtol-20o3gyqy1ppgnewp68giw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the meantime, on his </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog, the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> author has published </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> related </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which he considers the intricacies of new phenomena such as nullability, null-obliviousness, and null-awareness. </font><font style="vertical-align: inherit;">We have translated both articles under one heading and suggest discussing them.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most ambitious new feature in C # 8.0 is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullable references</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The purpose of this new feature is to smooth out the damage from a dangerous thing, which the computer scientist Tony Hoar once called his " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">billion dollar mistake</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font><font style="vertical-align: inherit;">C # has a keyword</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(the equivalent of which is found in many other languages), and the roots of this keyword can be traced back to the language Algol W, in the development of which Hoar participated. In this ancient language (it appeared in 1966), variables referring to instances of a certain type could receive a special meaning indicating that right now this variable is not referenced anywhere. This opportunity was very widely borrowed, and today many experts (including Hoar himself) believe that it has become the biggest source of costly software errors of all time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is wrong with assuming zero? In a world where any link may point to zero, you have to consider this wherever any links are used in your code, otherwise you run the risk of being refused at runtime. Sometimes it‚Äôs not too burdensome; if you initialize a variable with an expression </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the same place where you declare it, then you know that this variable is not equal to zero. But even such a simple example is fraught with some cognitive load: before the release of C # 8, the compiler could not tell you if you are doing anything that can convert this value to </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But, as soon as you start stitching different fragments of code, it becomes much more difficult to judge with certainty about such things: how likely is it that this property that I am reading now can return </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Is it allowed to transmit</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into that method? In what situations can I be sure that the method I'm calling will set this argument </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not to </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but to a different value? Moreover, the matter is not even limited to remembering to check such things; it‚Äôs not entirely clear what you should do if you run into zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With numerical types in C #, there is no such problem: if you write a function that takes some numbers as an input and returns a number as a result, then you don‚Äôt have to wonder if the transmitted values ‚Äã‚Äãare really numbers, and if anything among them can be mixed up. When calling such a function, it is not necessary to think about whether it can return anything instead of a number. Unless such a development of events interests you as an option: in this case, you can declare parameters or results of the type</font></font><code>int?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, indicating that in this particular case you really want to allow the transmission or return of a null value. So, for numerical types and, in a more general sense, significant types, zero tolerance has always been one of those things that are done voluntarily, as an option. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As for the reference types, prior to C # 8.0, the permissibility of zero was not only set by default, but it could not be disabled either. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, for reasons of backward compatibility, zero-validity continues to operate by default even in C # 8.0, since new language functions in this area remain disabled until you explicitly request them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, as soon as you enable this new feature - everything changes. The easiest way to activate it is to add it </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside the element.</font></font><code>&lt;PropertyGroup&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in your file </font></font><code>.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. (I note that more filigree control is also available. If you really really need it, you can configure the behavior to be allowed </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separately on each line. But, when we recently decided to include this feature in all our projects, it turned out that it would be activated on a scale one project at a time is a doable task.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the permissible links in C # 8.0 are </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fully activated, the situation changes: now, by default, it is assumed that the links do not allow null only if you yourself do not specify the opposite, exactly as with significant types ( even the syntax is the same: you could write int ?, if you really wanted the integer value to be optional. Now you write string?, if you mean that you want either a string reference or</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a very significant change, and, first of all, due to its significance, this new feature is disabled by default. Microsoft could have designed this language feature differently: you could leave the default links nullable and introduce new syntax that would allow you to specify that you want to ensure that it is not allowed </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Perhaps this would lower the bar when exploring this possibility, but in the long run such a solution would be incorrect, since in practice most of the links in the huge mass of C # code are not designed to point to </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assuming zero is an exception, not a rule, and that is why, when this new language feature is enabled, preventing null becomes a new default. This is reflected even in the original feature name: ‚Äúnullable references.‚Äù The name is curious, given that links could point </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">back to C # 1.0. But the developers chose to emphasize that now the null assumption goes into the category of things that need to be explicitly requested. </font></font><br>
‚ÄÉ<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C # 8.0 smoothes out the process of introducing permissive links </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since it allows you to introduce this feature gradually. One does not have to make a yes or no choice. This is quite different from the feature </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">added in C # 5.0, which tended to spread: in fact, asynchronous operations oblige the caller to be</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and therefore, the code that calls this caller must be </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and so on, to the very top of the stack. Fortunately, types that allow </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are constructed differently: they can be implemented selectively and gradually. You can work through the files one by one, or even line by line, if necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most important aspect of types allowing</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(thanks to which the transition to them is simplified), is that by default they are disabled. Otherwise, most developers would refuse to use C # 8.0, since such a transition would cause warnings in almost any code base. However, for the same reasons, the entry threshold for using this new feature feels rather high: if a new feature makes such dramatic changes that it is disabled by default, then you probably won‚Äôt want to mess with it, but there are problems associated with switching to it will always seem unnecessary hassle. But this would be a shame, because the feature is very valuable. It helps to find bugs in the code before users do it for you. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, if you are considering introducing types that allow</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, be sure to note that you can introduce this feature step by step. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnings only</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The roughest level of control over the entire project after a simple on / off is the ability to activate warnings regardless of annotations. For example, if I fully enable the zero assumption for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling.Json</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in our </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repository </font><font style="vertical-align: inherit;">, adding </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the group of properties in the project file, then in its current state 20 warnings from the compiler will immediately appear. However, if I use it instead, I </font></font><code>&lt;Nullablegt;warnings&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äôll get just one warning.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But wait! Why will less warnings be shown to me? In the end, here I just asked for warnings. The answer to this question is not entirely obvious: the fact is that some variables and expressions can be </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null-oblivious. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null Neutrality</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C # supports two interpretations of null validity. Firstly, any variable of a reference type can be declared as admitting or not admitting </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and secondly, the compiler will </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whenever </font><font style="vertical-align: inherit;">possible logically conclude whether or not this variable can be </font><font style="vertical-align: inherit;">at any particular point in the code. This article deals only with the first variety of admissibility</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, about the static type of a variable (in fact, this applies not only to variables and parameters and fields close to them in spirit; both static and logically deducible admissibility are </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determined for each expression in C #.) In fact, admissibility </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in its first sense , the one we are considering is an extension of the type system. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, it turns out that if we focus only on null admissibility for a type, the situation will not be as coherent as one might assume. This is not just a contrast between "null validity" and "invalid</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". In fact, there are two more possibilities. There is a category of ‚Äúunknown‚Äù, which is mandatory due to the availability of generics; if you have an unlimited type parameter, then it will not be possible to find out anything about the validity </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for it: code using the appropriate generalized method or type can substitute an argument in them, either allowing or not allowing </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can add restrictions, but often such restrictions are undesirable, since they narrow the scope of the generalized type or method. So, for variables or expressions of some unlimited type parameter, the </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(non) validity of zero must be unknown; perhaps, in each case, the question of admissibility</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will be decided separately for them, but we don‚Äôt know which option will appear in the generic code, since it will depend on the type argument. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The latter category is called ‚Äúneutral‚Äù. By the principle of "neutrality" everything worked before the advent of C # 8.0, and this will work if you do not activate the ability to work with nullable links. (Basically, this is an example of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retroactivity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Even though the idea of ‚Äã‚Äãnull neutrality was first introduced in C # 8.0 as a natural state of code before activating null validity for references, C # designers insisted that this property was never really alien to C #.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps you don‚Äôt have to explain what ‚Äúneutrality‚Äù means in this case, since it is in this vein that C # always worked, so you yourself understand everything ... although, perhaps, this is a little dishonest. So listen: in a world where admissibility is known </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the most important characteristic of </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral expressions is that they do not cause warnings about null acceptability. You can assign a null-neutral expression as an allowable </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable, but not allowable. </font></font><code>Null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral variables (as well as properties, fields, etc.), you can assign expressions that the compiler considered ‚Äúpossible </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù or ‚Äúnot </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That‚Äôs why, if you just turn on warnings, then there will not be many new alerts. All code remains in the context of disabled validity annotations </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so all variables, parameters, fields and properties will be </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral, which means that you will not receive any warnings if you try to use them in conjunction with any entities that take into account </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why, then, do I get warnings at all? A common reason is because of an attempt to make friends in an unacceptable way two pieces of code that take into account </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For example, suppose I have a library where permissive links are fully included </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and this library has the following deeply contrived class:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NullableAwareClass</span><font></font>
	{<font></font>
	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span>? GetNullable() =&gt; DateTime.Now.Hour &gt; <span class="hljs-number">12</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">"morning"</span>;<font></font>
	<font></font>
<font></font>
	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">RequireNonNull</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> s</span>)</span> =&gt; s.Length;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, in another project, I can write this code in the context where null validity warnings are activated, but the corresponding annotations are disabled: </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">UseString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> x</span>)</span> =&gt; NullableAwareClass.RequireNonNull(x);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since annotations about null validity are disabled, the parameter </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here is </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral. </font><font style="vertical-align: inherit;">This means that the compiler cannot determine if this code is true or not. </font><font style="vertical-align: inherit;">If the compiler issued warnings in cases where </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral expressions are mixed with those that take into account </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a significant proportion of these warnings could be considered doubtful - therefore, warnings are not issued. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this wrapper, I actually hid the fact that the code takes into account validity </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This means that now I can write like this:</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">int</span> x = UseString(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The compiler knows what it </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can return </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but since I called the method with a null-neutral parameter, the program does not know if this is right or wrong. Using the </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral wrapper, I disarmed the compiler, which now does not see a problem here. However, if I combined these two methods directly, everything would be different:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> y = NullableAwareClass.RequireNonNull(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here I pass the result </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">right to </font></font><code>RequireNonNull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If I tried to do this in a context where null assumptions are enabled, the compiler would generate a warning, regardless of whether I turned on or off the context of the corresponding annotations. In this particular case, the context of annotations does not matter, since there are no declarations with a reference type. If you enable warnings about the assumption of null, but disable the corresponding annotations, then all declarations will become- </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral, which, however, does not mean that all expressions become such. So, we know that the result </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is null. Therefore, we get a warning. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Summarizing: since all declarations in the context of disabled annotations that allow </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral, we won‚Äôt get many warnings, since most expressions will be </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral. But the compiler will still be able to catch errors related to the assumption </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in those cases when the expressions do not pass through some null-neutral intermediary. Moreover, the greatest benefit in this case will be from detecting errors associated with attempts to dereference potential null values ‚Äã‚Äãusing </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for example:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> z = NullableAwareClass.GetNullable().Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If your code is well-designed, then there should not be a large number of errors of this kind. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradual annotation of the entire project</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
After you take the first step - just activate the warnings, then you can proceed to the gradual activation of annotations, file by file. It is convenient to include them immediately in the entire project, see in which files warnings appear - and then select a file in which there are relatively few warnings. Again, turn them off at the level of the entire project, and write at the top of the file you selected </font></font><code>#nullable enable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This will fully enable the assumption </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(both for warnings and for annotations) in the entire file (unless you turn them off again using another directive</font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Then you can go through the entire file and make sure that all entities that are likely to be null are annotated as allowing </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i.e., add </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and then deal with warnings in this file, if any remain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It may turn out that adding all the necessary annotations is all that is required to eliminate all warnings. The reverse is also possible: you may notice that when you neatly annotate one file about validity</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, other warnings have surfaced in other files using it. As a rule, there are not many such warnings, and you have time to quickly fix them. But, if for some reason after this step you just drown in warnings, then you still have a couple of solutions. Firstly, you can simply cancel the selection, leave this file and take on another one. Secondly, you can selectively turn off annotations for those members that you think are causing the most problems. ( </font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use the </font><font style="vertical-align: inherit;">directive </font><font style="vertical-align: inherit;">as many times as you want, so you can control the null validity settings even line by line, if you want to.) Perhaps if you return to this file later when you already activate null validity in most of the project, you will see less warnings than the first time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are times when problems cannot be solved in such a straightforward way. </font><font style="vertical-align: inherit;">So, in certain scenarios related to serialization (for example, when using Json.NET or Entity Framework), the work may be more difficult. </font><font style="vertical-align: inherit;">I think this problem deserves a separate article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links with the assumption </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">improve the expressiveness of your code and increase the chances that the compiler will catch your errors before users bump into them. </font><font style="vertical-align: inherit;">Therefore, it is better to include this feature if possible. </font><font style="vertical-align: inherit;">And, if you include it selectively, then the benefits of it will begin to feel faster.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501502/index.html">New Lab Digital Synthesis Continues Harris Book and Helps Make FPGA Video Game</a></li>
<li><a href="../en501506/index.html">About GDI leaks and the importance of luck</a></li>
<li><a href="../en501508/index.html">Damn old CRM</a></li>
<li><a href="../en501510/index.html">A new look at Fullstack development with the Ruby on Rails framework</a></li>
<li><a href="../en501516/index.html">Let's turn off the vacuum ?! Alexey Lesovsky</a></li>
<li><a href="../en501522/index.html">Free Skillbox Webinars: Writing Games in PHP, Unity and Unreal Engine</a></li>
<li><a href="../en501524/index.html">Secrets of synchronizing the electromagnetic fields of the Earth and a living organism</a></li>
<li><a href="../en501526/index.html">Why Canadian English is considered "dirty" and what does Keanu Reeves have to do with it?</a></li>
<li><a href="../en501528/index.html">The book "Bash and cybersecurity: attack, defense and analysis from the Linux command line"</a></li>
<li><a href="../en501534/index.html">Now with COVID-19 there is also a rash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>