<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🍳 👶🏼 👨🏼‍🤝‍👨🏻 準ニュートン法、またはAthosの二次導関数が多すぎる場合 🤦 🔲 🔱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="初めて準ニュートン法に慣れると、2度驚くかもしれません。まず、数式を一目見ただけで、これがまったく機能するかどうか疑問が生じます。ただし、機能します。さらに、それらがうまく機能するかどうかは疑わしいようです。また、特別に構成されたタスクではなく、実際に実行された実際のタスクでは、勾配降下のさまざまな...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>準ニュートン法、またはAthosの二次導関数が多すぎる場合</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初めて準ニュートン法に慣れると、2度驚くかもしれません。まず、数式を一目見ただけで、これがまったく機能するかどうか疑問が生じます。ただし、機能します。さらに、それらがうまく機能するかどうかは疑わしいようです。また、特別に構成されたタスクではなく、実際に実行された実際のタスクでは、勾配降下のさまざまなバリエーションよりもはるかに高速であることに驚かされます。この後も関心が混ざった疑問が残っている場合は、なぜこれがなぜ機能するのかを理解する必要があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起源とニュートン法などの勾配法を、ドライブの基本的な考え方は、している</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、既に検討されて</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、現在の位置の近くでの関数の動作に関する情報に依存していたため、簡単な数学的分析ができました。少なくとも、一次導関数に関する情報が入手可能であると想定されていました。これが私たちが利用できるすべての場合はどうなりますか？勾配降下法は私たちの文ですか？もちろん、そうです。私たちが</font><font style="vertical-align: inherit;">目的関数が適切に処理される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を扱っていることを突然覚えていない限り</font><font style="vertical-align: inherit;">は。もしそうなら、関数の動作に関する蓄積された情報を使用して、関数の表面を少し盲目にしないようにしてみませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対象の経路に関する情報を使用するという考えは、降下方法を高速化するほとんどの方法の中心にあります。この記事では、この種類の情報を説明する最も安価な方法ではありませんが、最も効果的な方法の1つについて説明し、準ニュートン法のアイデアを導きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準ニュートン法の脚がどこで成長し、名前がどこから来たかを理解するために、定常点方程式の直接解に基づく最小化法に戻る必要があります</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c43/946/5f9/c439465f905d9f366a2f4b3296306290.gif" title="「\ bigtriangledown f = 0 &quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この方程式の解に適用されたニュートン法の考察が同じ名前の最適化法に導いたのと同じように（その祖先とは異なり、収束のグローバル領域を持っています）、非線形方程式のシステムを解く他の方法の考察が実を結ぶと期待できます。他の最適化方法を構築するためのアイデアを計画します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セカント法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は連立方程式を解くためのニュートン法のことを思い出してみよう</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="&quot;F（x）= 0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近傍に置き換えに基づいている</font></font><img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="バツ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">近傍の点の解決に</font></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="「F」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その線形近似</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d15/479/f23/d15479f235f0d60ce8837c9043a0d2cc.gif" title="「L（p）= F（x）+ J（x）p」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/206/f34/999/206f349991c0724c2fdce788124abe1c.gif" title="「J」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合に、それは、線形演算子であり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="バツ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトルであり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="「F」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各変数に関して偏導関数、ヤコビ行列との一致を有しているが</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4d2/826/ff6/4d2826ff6ba22f9f67cab70bfbe17a16.gif" title="「J_ {ij} = \ dfrac {\ partial F_ {i}} {\ partial x_ {j}}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、方程式が解かれ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c9d/8be/3f2/c9d8be3f2d70054db890ea34e3409544.gif" title="&quot;L（p）= 0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その点が</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2c4/a7b/e55/2c4a7be5582848bfbcdd9ee141e7d764.gif" title="＆quot; x '= x + p＆quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的の解の新しい近似として使用されます。シンプルで機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、何らかの理由でヤコビ行列を計算できない場合はどうでしょうか。この場合、最初に頭に浮かぶのは、偏導関数を分析的に計算できない場合は、それらの数値近似を適切に取得できることです。そのような近似の最も単純な（決して唯一ではない）バリアントは、正しい有限差分の公式にすることができます</font><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/149/708/f5b/149708f5b8bab4374023295557622e82.gif" title="&quot;\ dfrac {\パーシャルF_ {i}} {\パーシャルx_ {j}} \約\ dfrac {F_ {i}（x + h_ {j} e_ {j}）-F_ {i}（x）} { h_ {j}}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/459/e61/aa0/459e61aa08f7fe807167a596e7ebd8a9.gif" title="「e_ {j}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、はj番目の基底ベクトルです。このような近似からなる行列を表す</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a51/533/990/a5153399048e881eb8661304792b8c81.gif" title="「\バー{J}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">作品のかなり多数に専念してきた</font><font style="vertical-align: inherit;">どのくらい置換の分析</font></font><img src="https://habrastorage.org/getpro/habr/post_images/206/f34/999/206f349991c0724c2fdce788124abe1c.gif" title="「J」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のための</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a51/533/990/a5153399048e881eb8661304792b8c81.gif" title="「\バー{J}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュートン法での収束に影響しますが、この場合には、我々は別の側面に興味を持っています。つまり、そのような近似には、N個の追加ポイントでの関数の計算が必要であり、さらに</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6c4/afd/100/6c4afd1002ddcfa43d07afbc9f103a9d.gif" title="「\ bar {L}（p）= F（x）+ \ bar {J} p」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのポイント</font><font style="vertical-align: inherit;">での関数の計算が必要です。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を</font><i><font style="vertical-align: inherit;">補間し</font></i><font style="vertical-align: inherit;">ます</font></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="「F」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c56/5c9/4b4/c565c94b4a37b9cd5f42fc1be92b2e15.gif" title="&quot;\ bar {L（} h_ {j} e_ {j}）= F（x）+ h_ {j} \ dfrac {F（x + h_ {j} e_ {j}）-F（x）} {h_ {j}} = F（x）+ F（x + h_ {j} e_ {j}）-F（x）= F（x + h_ {j} e_ {j}） &quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヤコビ行列のすべての近似にこのプロパティがあるわけではありませんが、このプロパティを持つアフィン関数のすべての行列はヤコビ行列の近似です。確かに、もし</font></font><img src="https://habrastorage.org/getpro/habr/post_images/88f/5c8/dd7/88f5c8dd7e9876a2d0e0980882f261da.gif" title="&quot;F（x + p_ {j}）= F（x）+ J（x）p_ {j} + o \ left（\ left \ Vert p_ {j} \ right \ Vert ^ {2} \ right）&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5ad/e1e/ad2/5ade1ead2804a3bfaa8ffdf9122a179a.gif" title="&quot;\bar{J}p_{j}=F(x+p_{j})-F(x)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それから</font></font><img src="https://habrastorage.org/getpro/habr/post_images/803/ca4/351/803ca4351b87edf1a13a2a2947772fa7.gif" title="&quot;\left\Vert p_{j}\right\Vert \rightarrow0\quad\bar{J}(x)p_{j}\rightarrow J(x)p_{j}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このプロパティ、つまり内挿プロパティは、ニュートン法を一般化するための建設的な方法を提供します。</font><font style="vertical-align: inherit;">を線形独立ベクトルのいくつかのシステムの</font><font style="vertical-align: inherit;">要件</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">満たす関数</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と</font></font><img src="https://habrastorage.org/getpro/habr/post_images/194/ad1/d42/194ad1d42aa4320679b9498748ceb78d.gif" title="&quot;\bar{L}(p)=a+Ap&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">。このような関数は</font><i><font style="vertical-align: inherit;">割線</font></i><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">と呼ばれ、</font><font style="vertical-align: inherit;">それを定義する</font><i><font style="vertical-align: inherit;">方程式</font></i><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">割線</font></i><i><font style="vertical-align: inherit;">方程式</font></i><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。ベクトルのシステム</font></font><img src="https://habrastorage.org/getpro/habr/post_images/06e/34e/3a7/06e34e3a7a0d0058ef351da74258a637.gif" title="&quot;\bar{L}(p_{i})=F(x+p_{i})&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="&quot;p_{i}&quot;"><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;"><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="&quot;p_{i}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は完全であり（つまり、それらは正確にN個あり、それらは依然として線形独立です）、さらに、ベクトルのシステムは</font></font><img src="https://habrastorage.org/getpro/habr/post_images/94f/cf5/579/94fcf55798902795ffb670e35359d2af.gif" title="&quot;\left\{ F(x+p_{i}),i=1\dots N\right\}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形独立であり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/77f/eec/dd2/77feecdd2ae9a4795d2f81f3eec18b1b.gif" title="&quot;\bar{L}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一意に決定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式のローカル交換に基づく任意の方法</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="&quot;F(x)=0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォームの方程式</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ccb/557/80f/ccb55780f0c8e65187b0f4c9126be81c.gif" title="&quot;\bar{L}(p)=0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/77f/eec/dd2/77feecdd2ae9a4795d2f81f3eec18b1b.gif" title="&quot;\bar{L}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">満たす</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割線式が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割線方法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の割線を最も合理的な方法で構築する方法について、公正な質問が生じ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。次の推論の行は明白に思われます。点xでアフィンモデルを構築し、点で所与の関数を補間し</font></font><img src="https://habrastorage.org/getpro/habr/post_images/462/bcf/f32/462bcff32469c0ec5f8ccfc80534c05c.gif" title="&quot;x-x_{1},x-x_{2},\dots,x-x_{N}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。方程式</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ccb/557/80f/ccb55780f0c8e65187b0f4c9126be81c.gif" title="&quot;\bar{L}(p)=0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">解くこと</font><font style="vertical-align: inherit;">は私たちに新しいポイントを与え</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2c4/a7b/e55/2c4a7be5582848bfbcdd9ee141e7d764.gif" title="&amp;quot;x'=x+p&amp;quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。次に、ある時点でアフィンモデルを構築するには</font></font><img src="https://habrastorage.org/getpro/habr/post_images/787/cf7/c3a/787cf7c3a3d374114b3a07305b7fa446.gif" title="&amp;quot;x'&amp;quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が</font></font><img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="&quot;F&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既にわかっ</font><font style="vertical-align: inherit;">ているように補間ポイントを選択</font><font style="vertical-align: inherit;">すること、つまりセットからそれらを取得する</font><font style="vertical-align: inherit;">ことが最も妥当</font></font><img src="https://habrastorage.org/getpro/habr/post_images/333/297/225/33329722533f0b608b0994d2a5ba83fa.gif" title="&amp;quot;\left\{ x'-x,x'-x_{1},x'-x_{2},\dots,x'-x_{N}\right\}&amp;quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。以前に使用された多くのポイントから選択するポイントには、さまざまなオプションがあります。たとえば、補間点として</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bb3/e3a/cd5/bb3e3acd5043b859fe89006d4cabe5a0.gif" title="&quot;\left\Vert F\right\Vert&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、値が最も小さい</font></font><img src="https://habrastorage.org/getpro/habr/post_images/055/8e9/3d9/0558e93d918ff32e873b6a71703e9969.gif" title="&quot;N&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点</font><font style="vertical-align: inherit;">、または最初の</font><font style="vertical-align: inherit;">点のみを使用できます。いずれの場合も</font></font><img src="https://habrastorage.org/getpro/habr/post_images/95f/756/92b/95f75692ba0aeefcef24ae42714dbc1b.gif" title="&amp;quot;p=x'-x&amp;quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、新しいアフィンモデルの補間ポイントのセットに</font><font style="vertical-align: inherit;">何</font><font style="vertical-align: inherit;">を含める必要がある</font><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">明らか</font><font style="vertical-align: inherit;">です。したがって、この</font></font><img src="https://habrastorage.org/getpro/habr/post_images/f24/8e8/91e/f248e891effc6650d9d31fbefc54cbe4.gif" title="&quot;n&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットの反復プロセスのステップは、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/f24/8e8/91e/f248e891effc6650d9d31fbefc54cbe4.gif" title="&quot;n&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前に渡されたポイントから構成</font><font style="vertical-align: inherit;">された</font><font style="vertical-align: inherit;">変位</font><font style="vertical-align: inherit;">まで可能</font><font style="vertical-align: inherit;">です。新しいアフィンモデルが</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前の値を</font><font style="vertical-align: inherit;">使用しないようにプロセスが構築されている</font><font style="vertical-align: inherit;">場合、そのようなプロセスはp点割線法と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、N点割線法は、ニュートン法を置き換える役割の最良の候補であると思われるかもしれません。なぜなら、解法の過程で得られる情報を最大限に利用し、同時に追加の計算の数を最小限に抑えるためです。後者の関数の値を使用します。 Nポイントを通過しました。残念ながら、そうではありません。問題なのは、ベクトルのシステムが</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ed0/117/8ca/ed01178ca46506fa4588780d16d705a1.gif" title="&quot;F(x_{0}),F(x_{1}),\dots F(x_{N})&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十分に大きなNに対して線形に独立することを頑固に拒否することです。さらに、この条件が満たされ、対応するアフィンモデルがまだ存在する場合でも、方向</font></font><img src="https://habrastorage.org/getpro/habr/post_images/602/ff2/50c/602ff250c473d5b28e08a1453d4175b3.gif" title="&quot;p_{j}=x_{j}-x_{0}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も線形に独立する可能性はさらに低くなります。 。これには、アフィンモデルは存在しますが、縮退しており、実際には不適切であるという事実が伴います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、最も安定しているのは2点割線法です。</font><font style="vertical-align: inherit;">つまり、各反復で関数の追加のN-1値を計算する必要がある方法です。</font><font style="vertical-align: inherit;">これは明らかに私たちの実際の目的には適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから問題は-これは何でしたか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方程式を解くための準ニュートン法</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確ではありませんが、方法は簡単です。すでに計算された値に基づいて、割線方程式を満たすアフィンモデルを一意に決定する技術的な能力がない場合は、必要ありません。割線の方程式を基礎として使用しますが、一部の不完全なベクトルシステムに対してのみ満たされることを要求し</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e5e/f2b/432/e5ef2b43292735aa2a68afffb80bf520.gif" title="&quot;\left\{ p_{1},p_{2},\dots,p_{m}\right\} , m &amp;lt; N&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。言い換えれば、十分に少数の既知の値についてのみ、補間条件が満たされる必要があります。もちろん、この場合、そのようなモデルで使用される行列がヤコビ行列になる傾向があることはもはや保証できませんが、これは必要ありません。これに加えて、アフィンモデルが現在のポイントで関数を補間する必要があることを追加します。つまり</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3b9/9d1/7fa/3b99d17fa378aeaf36097faef3830bd5.gif" title="&quot;\bar{L}(0)=F(x)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、割線法の次の公式を取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/78c/f30/421/78cf304219a4bc90d4f900062bf2d027.gif" title="&quot;\\
\bar{L}(p_{i})=F(x)+Ap_{i}=F(x+p_{i}),\quad i=1\dots m \\
\bar{L}(p)=0\quad\Rightarrow p=A^{-1}F(x)
&quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bruidenは、m = 1に対してこの種のメソッドを最初に検討したので、それらは準ニュートン行列と呼ばれました。この場合の割線条件で</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c9d/999/d9a/c9d999d9a4e8bd3d6f8e50519d1dfaa8.gif" title="&quot;A&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、追加の条件が課された場合にのみ</font><font style="vertical-align: inherit;">マトリックスを一意に識別でき、</font><font style="vertical-align: inherit;">そのような追加条件ごとに個別のメソッドが生成される</font><font style="vertical-align: inherit;">ことは明らかです</font><font style="vertical-align: inherit;">。ブライデン自身は次のように推論します：</font><i><font style="vertical-align: inherit;">ポイントからポイント</font></i><i><font style="vertical-align: inherit;">へ</font></i></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の移動</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、関数がそれ以外の</font><font style="vertical-align: inherit;">方向に</font><font style="vertical-align: inherit;">どのように変化するかについての追加情報を提供しないため</font><font style="vertical-align: inherit;">、ベクトルに対する新しいアフィン関数</font><font style="vertical-align: inherit;">の効果は、同じベクトルに対する古い関数の効果とは異なる必要があります。複数の異なる</font><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">。最後の手段として、</font><font style="vertical-align: inherit;">直交する</font><font style="vertical-align: inherit;">とき</font></font><img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="&quot;x_{0}&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/1d0/56f/301/1d056f3016bc715aacc23418d8629173.gif" title="&quot;x_{1}&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="&quot;q&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="&quot;q&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="&quot;q&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、新しい関数の動作は古い関数の動作と異なるべきではありません。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ブライデンのアイデアは、そのシンプルさで素晴らしいです。実際、関数の動作に関する新しい情報がない場合は、古いものを汚さないようにすることが最善の方法です。次に、</font><font style="vertical-align: inherit;">
古い変換にランク1の修正を追加することで、新しい変換の行列を一意に決定できる</font><font style="vertical-align: inherit;">ようにする</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0b3/d43/d20/0b3d43d207b144b926274d0c81abccbf.gif" title="&quot;\bar{L}_{1}q=\bar{L}_{0}q&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべての人の</font><font style="vertical-align: inherit;">追加条件</font><font style="vertical-align: inherit;">が得られます。</font><font style="vertical-align: inherit;">
ただし、Bruidenの結論は単純で一貫しているにもかかわらず、基礎となる支点は提供されません。他の同様のメソッドを構築します。幸いなことに、彼のアイデアはより正式に表現されています。つまり、この方法で作成された行列</font><font style="vertical-align: inherit;">は、次の問題の解決策です。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="&quot;q&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/c16/9f6/315/c169f6315171249a34b50b26a2975c6e.gif" title="&quot;q^{T}p=0&quot;"> <br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/522/f36/1f9/522f361f94a7b5a2e9da68094983b21d.gif" title="&quot; \\
A_{1}=A_{0}+\dfrac{(y-A_{0}p)p^{T}}{p^{T}p} \\
y=F(x_{0})-F(x_{1})
&quot;"><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="&quot;A_{1}&quot;"><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/028/96f/3fa/02896f3facb898d70f26abad02fe90a9.gif" title="&quot;\\
\left\Vert A_{1}-A_{0}\right\Vert _{F}\rightarrow\min \\
F(x_{1})-Ap=F(x_{0})
&quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の制限は正割方程式に他なりません。最小化条件は、行列にできるだけ多くの情報を保存したいという私たちの願望を反映しています</font></font><img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="&quot;A_{0}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合の行列間の不一致の尺度は、フロベニウスノルムです。この場合、提起された問題には一意の解決策があります。</font><font style="vertical-align: inherit;">この定式化は、他の方法を構築するための開始点として役立つ可能性があります。</font><font style="vertical-align: inherit;">つまり、我々は両方変更することができます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対策</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々が導入された変更を評価し、締めれる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行列に課せられています。</font><font style="vertical-align: inherit;">一般に、このような方法の定式化ですでに作業することができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準ニュートン最適化手法</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な考え方を理解したので、ようやく最適化の問題に戻り、アフィンモデルの再計算にブライデンの公式を適用しても、タスクがうまくいかないことに気付くことができます。実際、勾配関数の1次導関数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6b8/82e/be7/6b882ebe727121dcb5fc21b091044b5a.gif" title="&quot;\bigtriangledown f&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、構造上対称であるヘッセ行列にほかなりません。同時に、ブライデン規則に従って更新すると、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="&quot;A_{1}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="&quot;A_{0}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対称</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">あった</font><font style="vertical-align: inherit;">としても</font><font style="vertical-align: inherit;">、非対称行列に</font><font style="vertical-align: inherit;">なり</font><font style="vertical-align: inherit;">ます。これは、ブロイデン法を定常点方程式を解くために適用できないことを意味しませんが、そのような更新規則に基づいて、適切な最適化法を構築することはできません。一般に、準ニュートン法がうまく機能すればするほど、問題の状態システムが特定のヤコビ行列の詳細をより正確に説明できることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この欠点を修正するために、ブロイデン最小化問題に追加の制限を追加し、新しい行列が古い行列と対称であることを明示的に要求します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/03e/167/aa2/03e167aa25e0f4aa6b8df8546552e79a.gif" title="&quot;\\
\left\Vert A_{1}-A_{0}\right\Vert _{F}\rightarrow\min \\
\bigtriangledown f(x_{1})-Ap=\bigtriangledown f(x_{0}) \\
A_{1}^{T}=A_{1}
&quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">解決策は</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/df8/356/74b/df835674b94bab190bca3c18efed98ce.gif" title="&quot;A_{1}=A_{0}+\dfrac{(y-A_{0}p)p^{T}+p(y-A_{0}p)^{T}}{p^{T}p}-\dfrac{(y-A_{0}p)^{T}p}{\left(p^{T}p\right)^{2}}pp^{T}&quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/89c/f84/f29/89cf84f292ed72d1b20755677688a054.gif" title="y=\bigtriangledown f(x_{1})-\bigtriangledown f(x_{0})"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、行列変換式はその作成者-Powell、Shanno、およびBruyden（PSB）にちなんで名付けられました。結果の行列は対称ですが、突然</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6c7/040/47d/6c704047d3148fd7a8b563aaf79dd7f4.gif" title="&quot;y&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共線性に</font><font style="vertical-align: inherit;">ならない限り、明らかに正定ではありません</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。また</font><font style="vertical-align: inherit;">、最適化手法では確実な確実性が非常に望ましいことが</font><font style="vertical-align: inherit;">わかり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合も、今回はスケーリングされたフロベニウスノルムを行列発散の尺度として使用して、問題の状態を修正します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f37/eb1/0f4/f37eb10f4eb10d0c54acc9adab962f10.gif" title="&quot;\\ \ left \ Vert T ^ {-T} \ left（A_ {1} -A_ {0} \ right）T ^ {-1} \ right \ Vert _ {F} \ rightarrow \ min \\ \ bigtriangledown f（x_ {1}）-Ap = \ bigtriangledown f（x_ {0}）\\ A_ {1} ^ {T} = A_ {1} &quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の定式化の起源は別の大きなトピックですが、興味深いのは、行列Tが次のようなものである場合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/673/872/131/673872131fa6cb0f44e6839be0e448e7.gif" title="T ^ {T} T = G、Gp = y"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、Gも方向pの割線方程式を満たすアフィン変換行列である場合）、この問題の解決策はTの選択に依存せず、式</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/135/ea6/c14/135ea6c14ea8f63f961e83576f1be5d5.gif" title="「A_ {1} = A_ {0} + \ dfrac {（y-A_ {0} p）y ^ {T} + y（y-A_ {0} p）^ {T}} {y ^ {T} p}-\ dfrac {\ left（y-A_ {0} p \ right）^ {T} p} {\ left（y ^ {T} p \ right）^ {2}} yy ^ {T} &quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Davidon-Fletcher-Powell式として知られる</font><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">。この更新方法は、それは次のプロパティを持っているので、実際にはかなり良いことが証明された：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e3e/c44/1c1/e3ec441c17e1b43df108a7d8e15d3dd6.gif" title="「y ^ {T} p＆gt; 0 &quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは</font></font><img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="「A_ {0}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正定、それはある</font></font><img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="「A_ {1}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も正定値。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
その後、最初の条件が満たされない場合、割線の方程式を満たす正定行列を持つアフィン関数は存在しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFP法につながる問題で、行列自体の間ではなく、それらの逆数の間の距離をアフィンモデル間の差の尺度として取る場合、次の形式の問題が得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/337/0b0/af2/3370b0af216ab9695789eeb586cf3604.gif" title="&quot;\\ \ left \ Vert T ^ {-T} \ left（A_ {1} ^ {-1} -A_ {0} ^ {-1} \ right）T ^ {-1} \ right \ Vert _ { F} \ rightarrow \ min \\ \ bigtriangledown f（x_ {1}）-Ap = \ bigtriangledown f（x_ {0}）\\ A_ {1} ^ {T} = A_ {1} &quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その解は、ブライデン、フレッチャー、ゴールドファーブ、シャノによってほぼ同時に発見された既知の公式です。 （BFGS）。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/840/c7b/3fa840c7b6ec3de81eb02bb0e9240722.gif" title="「A_ {1} = A_ {0} + \ dfrac {yy ^ {T}} {y ^ {T} p}-\ dfrac {A_ {0} pp ^ {T} A_ {0}} {p ^ { T} A_ {0} p}「"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、この式による再計算は、計算の観点から最も効率的であると同時に、多数の反復によるマトリックスの退化が起こりにくいと考えられています。 DFPと同じ条件下で、この式は正定性の特性を維持します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックスを更新するために説明されているすべての方法では、ランク2の補正を導入する必要があります。これにより</font></font><img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="「A_ {1}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、シャーマンモリソンの式と値を使用し</font><font style="vertical-align: inherit;">てマトリックス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">簡単かつ自然に反転させることができ</font><font style="vertical-align: inherit;">ます</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5f6/3ac/2d9/5f63ac2d91f47a730fee01b5db38f3bd.gif" title="「A_ {0} ^ {-1}」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ed0/9f8/002/ed09f80027e56f58a3502cc943758509.gif" title="&quot;B_ {1} = B_ {0} + uv ^ {T} \ Rightarrow B_ {1} ^ {-1} = B_ {0} ^ {-1} + \ dfrac {B_ {0} ^ {-1} uv ^ {T} B_ {0} ^ {-1}} {1 + v ^ {T} B_ {0} ^ {-1} u} &quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式の分母がゼロでない場合。リストされたメソッドの逆行列を更新するための具体的な公式は示しません。それらは簡単に見つけたり、個別に導出したりできるためです。この場合に注意すべき唯一のことは、逆行列の更新を伴うメソッドのバリアントは通常、元の行列の更新を提案するものよりもはるかに安定性が低い（つまり、丸め誤差の影響を受ける）ことです。行列自体ではなく、コレスキー分解を更新することが最も効果的です（もちろん、そのような分解が行われない限り）。そのような実装オプションは数値的に安定しており、さらに、動きの方向を決定する方程式を解くコストを最小限に抑えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準ニュートン過程で最初の行列がどのように見えるかという問題を検討する必要があります。ここではすべてが明白です。ヘッセ行列またはその修正バージョンに近いほど、ヘッセ行列が突然正定にならない場合は、収束の点で優れています。ただし、原則として、任意の正定行列が適しています。そのような行列の最も単純なバージョンは単一のものであり、最初の反復は勾配降下の反復と一致します。フレッチャーとパウエルは、（当然、DFPメソッドの場合）2次関数が最小化されている場合、最初のDFP反復としてどの（正定）行列が使用されているかに関係なく、Nが正確にN回の反復で解を導くことを示しましたタスクの次元さらに、準ニュートン行列は最小点でヘッセ行列と一致します。そのような幸福の一般的な非線形の場合、もちろん、私たちは待つことはありませんが、これは少なくとも、初期行列の不適切な選択についてあまり心配しない理由を与えます。</font></font><br>
<br>
<h2></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準ニュートン法の構築への記述されたアプローチは唯一の可能なものではありません。少なくとも、説明されている準ニュートン法の発見者とその後の多くの研究者は、まったく異なる考察に基づいて同じ式にたどり着きました。ただし、興味深いことに、ある種の準ニュートン法が出現するとすぐに、それを取得する方法に関係なく、かなり短時間で、非常に簡単に解釈できる最適化問題の解決策であることが明らかになりました。私の意見では、特定のタスクの詳細をより適切に考慮した他のメソッドを構築するための基礎を提供するため、このような多様なメソッドに共通の特徴をもたらすことが可能であることに注目すべきです。特に、スパース行列、メソッドを更新するために設計された準ニュートン法があります。可能な限り少ない数の要素が変更される可能性があり、他の多くは空想的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、変数メトリックのメソッドは、その名前にもかかわらず、必ずしも可能であるたびに実行されますが、必ずしも実際のメトリックであるマトリックスの構築につながるとは限らないことにも注意してください。これは通常大きな問題ではありませんが、起こりうる困惑から身を守りたい人は、ニュートン法で同様の問題を克服するために作成されたのと同じトリックに頼る可能性があります。たとえば、方向を変更したり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、Levenberg-Marquardtスキームを</font></a><font style="vertical-align: inherit;">適用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">たりします。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。確かに、この場合、信頼する領域の形式を選択するという疑問が再び関連性を持つようになりますが、ここでは、より小さな悪を選択する必要があります。この問題の別の解決策は、線形探索法を使用して、確実性を維持するために必要な条件が満たされていることを確認することです。ウルフのルールはこの条件が満たされることを保証しますが、アルミホとゴールドスタインのルールは保証しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には、特定の種類の問題に関して、膨大な数の可能な準ニュートン法のうちどれが最も効果的であるかを決定することはほとんど不可能です。通常、メソッドを公式化する場合、それらは二次関数を最小化する有効性を示すことに限定されます（ちなみに、メソッドがN反復で正確な解につながる場合、つまり、SLAEを解決する直接的な方法よりも遅くない場合、メソッドは有効であると見なされます）。よりまれなケースでは、メソッドの収束次数（通常、超線形、つまり勾配降下法で得られるものよりも大幅に優れている）、安定性、およびその他の関心のある特性の研究を見つけることができます。しかし、一般的には、特定のクラスのタスクに対する特定のメソッドの有効性を判断できる唯一の妥当な基準は実践です。だから、シャベルを手に-アプリケーションの成功。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470620/index.html">コードとしてのインフラストラクチャ：XPの問題を克服する方法</a></li>
<li><a href="../ja470622/index.html">特徴選択手法の概要</a></li>
<li><a href="../ja470628/index.html">宇宙船シミュレータ造船</a></li>
<li><a href="../ja470632/index.html">Arend-HoTTベースの依存型言語（パート2）</a></li>
<li><a href="../ja470634/index.html">Instagramでコミュニティを特定してユーザーの興味を特定する</a></li>
<li><a href="../ja470640/index.html">Elasticsearchのサイジング</a></li>
<li><a href="../ja470642/index.html">Yandex.Station Miniをご覧ください。小さなデバイスの大きな物語</a></li>
<li><a href="../ja470644/index.html">corblogが時々酸味を帯びる理由：いくつかの観察とヒント</a></li>
<li><a href="../ja470646/index.html">データサイエンスのための数学。OTUSからの新しいコース</a></li>
<li><a href="../ja470648/index.html">IBM LTO-8-コールドデータを保存する簡単な方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>