<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💩 👶🏾 👏🏼 Meningkatkan kinerja menggunakan cache uop di Sandy Bridge + 💽 🧙🏼 🕚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam prosesor Intel x86 modern, pipa dapat dibagi menjadi 2 bagian: Front End dan Back End. 
 
 Front End bertanggung jawab untuk memuat kode dari me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Meningkatkan kinerja menggunakan cache uop di Sandy Bridge +</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497290/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam prosesor Intel x86 modern, pipa dapat dibagi menjadi 2 bagian: Front End dan Back End. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Front End bertanggung jawab untuk memuat kode dari memori dan mendekodekannya dalam operasi mikro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back End bertanggung jawab untuk melakukan operasi mikro dari Front End. </font><font style="vertical-align: inherit;">Karena operasi mikro ini dapat dilakukan oleh kernel yang rusak, Back End juga memastikan bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari operasi mikro ini benar-benar sesuai dengan urutan kode tersebut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kebanyakan kasus, penggunaan Front End'a yang tidak efisien tidak memiliki efek nyata pada kinerja. </font><font style="vertical-align: inherit;">Bandwidth puncak pada sebagian besar prosesor Intel adalah 4 operasi mikro per siklus, oleh karena itu, misalnya, untuk kode yang terikat Memori / L3, CPU tidak akan dapat sepenuhnya menggunakannya.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danau Es Pro relatif baru</font></font></b><div class="spoiler_text">   ,      Ice Lake    4  5   .  ,        ,         . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, dalam beberapa kasus, perbedaan kinerja bisa sangat signifikan. </font><font style="vertical-align: inherit;">Di bawah potongan adalah analisis dampak dari cache operasi mikro pada kinerja.</font></font><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isi artikel</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkungan Hidup</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinjauan Umum tentang prosesor Front End'a Intel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis Bandwidth Puncak µop cache -&gt; IDQ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkungan Hidup</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk semua pengukuran dalam artikel ini akan digunakan </font></font><code>i7-8550U Kaby Lake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, HT diaktifkan / </font></font><code>Ubuntu 18.04/Linux Kernel 5.3.0-45-generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam hal ini, lingkungan seperti itu dapat menjadi signifikan, karena </font><font style="vertical-align: inherit;">setiap model CPU memiliki acara kinerjanya sendiri. </font><font style="vertical-align: inherit;">Khususnya, untuk arsitektur mikro yang lebih tua dari Sandy Bridge, beberapa peristiwa yang digunakan di masa depan sama sekali tidak masuk akal.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinjauan Umum tentang prosesor Front End'a Intel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Organisasi jalur perakitan tingkat tinggi adalah informasi yang tersedia untuk umum dan diterbitkan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi resmi Intel tentang pengoptimalan perangkat lunak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Penjelasan lebih rinci tentang beberapa fitur yang dihilangkan dari dokumentasi resmi dapat ditemukan di sumber-sumber terkemuka lainnya, seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agner Fog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travis Downs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jadi, misalnya, skema jalur pipa perakitan untuk Skylake dalam dokumentasi Intel terlihat seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qe/jr/xa/qejrxaieyvky3yjl5yps8toljme.png" alt="Pipa skylake"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita </font><font style="vertical-align: inherit;">lihat </font><font style="vertical-align: inherit;">lebih dekat </font><font style="vertical-align: inherit;">di bagian </font><font style="vertical-align: inherit;">atas skema ini - Front End. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/ya/yw/dpyaywk2lq0qub5zh4dvjlqwjn4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pipeline Decode Pipeline bertanggung jawab untuk mendekode kode dalam operasi mikro. </font><font style="vertical-align: inherit;">Ini terdiri dari komponen-komponen berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit Ambil Instruksi - IFU</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache Petunjuk Level Pertama - L1i</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instruksi Log Terjemahan Alamat Cache - ITLB</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengajar Instruktur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Petunjuk pra-dekoder</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antrian instruksi yang telah diterjemahkan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengurai instruksi pra-dekode operasi mikro</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan masing-masing bagian dari Legacy Decode Pipeline secara individual. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit Ambil Instruksi. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia bertanggung jawab untuk memuat kode, pra-pengkodean (menentukan panjang instruksi dan properti seperti "apakah instruksi adalah cabang") dan mengirimkan instruksi yang telah didekodekan ke antrian. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache Petunjuk Level Pertama - L1i</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengunduh kode, IFU menggunakan L1i, cache instruksi tingkat pertama, dan L2 / LLC, cache level kedua dan cache offcore tingkat atas, yang umum digunakan untuk kode dan data. Pengunduhan dilakukan dalam ukuran 16 byte, juga disesuaikan dengan 16 byte. Ketika potongan kode 16 byte berikutnya dimuat secara berurutan, panggilan dilakukan ke L1i dan, jika baris yang sesuai tidak ditemukan, maka pencarian dilakukan di L2 dan, jika terjadi kegagalan, pada LLC dan memori. Sebelum Skylake LLC, cache bersifat inklusif - setiap baris di L1 (i / d) dan L2 harus dimuat dalam LLC. Dengan demikian, LLC “tahu” tentang semua garis di semua inti dan, dalam kasus LLC meleset, diketahui apakah cache di inti lainnya berisi garis yang diperlukan dalam keadaan Dimodifikasi, yang berarti bahwa garis ini dapat dimuat dari inti lain. Skylake LLC menjadi cache korban-L2 yang non-inklusif, tetapi ukuran L2 meningkat 4 kali lipat. Saya tidak tahuapakah L2 inklusif sehubungan dengan L1i. L2</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inklusif sehubungan dengan L1d. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerjemahan alamat logis dari instruksi - ITLB</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sebelum mengunduh data dari cache, Anda harus mencari baris yang sesuai. Untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache asosiatif-jalan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , setiap baris dapat berada di </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempat yang berbeda dalam cache itu sendiri. Untuk menentukan posisi yang mungkin dalam cache, indeks digunakan (biasanya beberapa bit lebih rendah dari alamat). Untuk menentukan apakah baris cocok dengan alamat yang kami butuhkan, tag digunakan (sisa alamat). Alamat mana yang akan digunakan: fisik atau logis - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tergantung pada implementasi cache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Menggunakan alamat fisik membutuhkan terjemahan alamat. Untuk terjemahan alamat, buffer TLB digunakan, yang menyimpan hasil penelusuran halaman, dengan demikian mengurangi penundaan dalam menerima alamat fisik dari alamat logis pada panggilan berikutnya. Untuk instruksi, ada buffer TLB Instruksi sendiri, yang terletak secara terpisah dari TLB Data. Inti CPU juga memiliki TLB tingkat kedua yang umum digunakan untuk kode dan data - STLB. Apakah STLB inklusif tidak saya ketahui (dikabarkan bukan cache korban inklusif relatif terhadap D / I TLB). Menggunakan Petunjuk Prefetch Perangkat Lunak</font></font><code>prefetcht1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menarik baris dengan kode di L2, namun, catatan TLB yang sesuai akan ditarik hanya di DTLB. </font><font style="vertical-align: inherit;">Jika STLB tidak inklusif, maka ketika Anda mencari baris ini dengan kode di dalam cache, Anda akan mendapatkan ITLB miss -&gt; STLB miss -&gt; page walk (sebenarnya, itu tidak begitu sederhana, karena kernel dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memulai berjalan halaman spekulatif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebelum itu terjadi Miss TLB). </font><font style="vertical-align: inherit;">Dokumentasi Intel juga mencegah penggunaan prefetch SW untuk kode, Intel Software Optimization Manual / 2.5.5.4:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefetch yang dikendalikan perangkat lunak dimaksudkan untuk mengambil data awal, tetapi tidak untuk kode prefetching.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, Travis D. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyebutkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahwa prefetch semacam itu bisa sangat efektif (dan kemungkinan besar memang demikian), tetapi sejauh ini tidak jelas bagi saya dan untuk diyakinkan tentang hal ini saya perlu memeriksa masalah ini secara terpisah. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengajar Instruktur</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemuatan data ke dalam cache (L1d / i, L2, dll) terjadi ketika mengakses lokasi memori yang tidak di-cache. </font><font style="vertical-align: inherit;">Namun, jika ini terjadi hanya dalam kondisi seperti itu, maka sebagai hasilnya kita akan mendapatkan penggunaan bandwidth cache yang tidak efisien. </font><font style="vertical-align: inherit;">Misalnya, pada operasi Sandy Bridge untuk L1d - 2 baca, 1 tulis 16 byte per siklus; </font><font style="vertical-align: inherit;">untuk L1i - 1 operasi baca 16 byte, tulis throughput tidak ditentukan dalam dokumentasi, Agner Fog juga tidak ditemukan. </font><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, ada prefetcher Perangkat Keras yang dapat menentukan pola akses ke memori dan menarik garis yang diperlukan ke dalam cache sebelum kode benar-benar mengatasinya. </font><font style="vertical-align: inherit;">Dokumentasi Intel menetapkan 4 prefetcher: 2 untuk L1d, 2 untuk L2:</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 DCU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Awalan garis cache serial. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya Baca Maju</font></font></b></li>
<li><b>L1 IP</b> —              (. 0x5555555545a0, 0x5555555545b0, 0x5555555545c0, ...),    ,   ,  </li>
<li><b>L2 Spatial</b> —       L2    -,        128-.       LLC</li>
<li><b>L2 Streamer</b> —    .    L1 DCU      «».       LLC</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dokumentasi Intel tidak menjelaskan prinsip prefektor L1i. </font><font style="vertical-align: inherit;">Yang diketahui hanyalah bahwa Unit Prediksi Cabang (BPU) terlibat dalam proses ini, Manual Pengoptimalan Perangkat Lunak Intel / 2.6.2: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/js/y3/sdjsy3jrgseyeuukletr84i2gyu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog juga tidak melihat detail apa pun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengambilan kode sebelumnya dalam L2 / LLC secara eksplisit ditentukan hanya untuk Streamer. </font><font style="vertical-align: inherit;">Manual Pengoptimalan / 2.5.5.4 Pembuatan Data:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streamer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Prefetcher ini memonitor permintaan membaca dari cache L1 untuk urutan naik dan turunnya alamat. </font><font style="vertical-align: inherit;">Permintaan baca yang dimonitor termasuk permintaan L1 DCache yang dimulai oleh operasi memuat dan menyimpan dan oleh prefetcher perangkat keras, dan permintaan L1 ICache untuk pengambilan kode.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk prefetcher Spasial, ini jelas tidak dijabarkan:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefetcher Spasial: Prefetcher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini berusaha untuk menyelesaikan setiap baris cache yang diambil ke cache L2 dengan garis pasangan yang melengkapinya ke potongan sejajar 128-byte.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ini bisa diverifikasi. </font><font style="vertical-align: inherit;">Masing-masing prefetcher ini dapat dimatikan menggunakan </font></font><code>MSR 0x1A4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti yang dijelaskan dalam manual </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register Spesifik Model.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang MSR 0x1A4</font></font></b><div class="spoiler_text">  MSR     L2 Spatial    L1i.     .              ,    LLC.     L2 Streamer       2.5 . <br>
<br>
 Linux  msr ,   msr     .  <code>$ sudo wrmsr -p 1 0x1a4 1</code>  L2 Streamer   1.<br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instruksi pra-dekoder</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah kode 16-byte berikutnya dimuat, mereka masuk ke dalam instruksi pra-dekoder. </font><font style="vertical-align: inherit;">Tugasnya adalah untuk menentukan panjang instruksi, memecahkan kode awalan dan menandai apakah instruksi yang sesuai adalah cabang (kemungkinan besar masih ada banyak properti yang berbeda, tetapi dokumentasi tentang mereka adalah diam). </font><font style="vertical-align: inherit;">Manual Pengoptimalan Perangkat Lunak Intel / 2.6.2.2:</font></font><br>
<blockquote>The predecode unit accepts the sixteen bytes from the instruction cache or prefetch buffers and carries out the following tasks:<br>
<br>
<ul>
<li>Determine the length of the instructions</li>
<li>Decode all prefixes associated with instructions</li>
<li>Mark various properties of instructions for the decoders (for example, “is branch.”)</li>
</ul></blockquote><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baris instruksi yang sudah diterjemahkan. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari IFU, instruksi ditambahkan ke antrian instruksi yang sudah dikodekan. </font><font style="vertical-align: inherit;">Antrian ini telah muncul sejak Nehalem, sesuai dengan dokumentasi Intel, ukurannya adalah 18 instruksi. </font><font style="vertical-align: inherit;">Agner Fog juga menyebutkan bahwa antrian ini menampung tidak lebih dari 64 byte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga di Core2, antrian ini digunakan sebagai cache loop. </font><font style="vertical-align: inherit;">Jika semua operasi mikro dari siklus berada dalam antrian, maka dalam beberapa kasus biaya pemuatan dan pra-pengkodean dapat dihindari. </font><font style="vertical-align: inherit;">Loop Stream Detector (LSD) dapat memberikan instruksi yang sudah ada dalam antrian sampai BPU memberi sinyal bahwa siklus telah berakhir. </font><font style="vertical-align: inherit;">Agner Fog memiliki sejumlah catatan menarik tentang LSD di Core2:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terdiri dari 4 baris 16 byte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puncak throughput hingga 32 byte kode per siklus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dimulai dengan Sandy Bridge, cache loop ini telah pindah dari antrian instruksi yang sudah didekodekan kembali ke IDQ. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoder instruksi pra-dekode dalam operasi mikro</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dari antrian instruksi pra-dekode, kode dikirim ke decoding dalam operasi mikro. Decoder bertanggung jawab untuk decoding - ada total 4. Sesuai dengan dokumentasi Intel, salah satu decoder dapat mendekode instruksi yang terdiri dari 4 operasi mikro atau kurang. Sisanya menerjemahkan instruksi yang terdiri dari satu operasi mikro (menyatu mikro / makro), Intel Software Optimization Manual / 2.5.2.1:</font></font><br>
<blockquote>There are four decoding units that decode instruction into micro-ops. The first can decode all IA-32 and Intel 64 instructions up to four micro-ops in size. The remaining three decoding units handle single-micro-op instructions. All four decoding units support the common cases of single micro-op flows including micro-fusion and macro-fusion.</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instruksi diterjemahkan dalam sejumlah besar operasi mikro (mis. Rep movsb yang digunakan dalam implementasi memcpy dalam libc pada ukuran tertentu dari memori yang disalin) berasal dari Microcode Sequencer (MS ROM). Bandwidth puncak sequencer adalah 4 operasi mikro per siklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang dapat Anda lihat dalam diagram jalur perakitan, Legacy Decode Pipeline dapat mendekodekan hingga 5 operasi mikro per siklus di Skylake. Pada Broadwell dan yang lebih tua, throughput puncak Pipeline Decode Pipeline adalah 4 operasi mikro per siklus. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache operasi mikro</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah instruksi diterjemahkan dalam operasi mikro, dari Legacy Decode Pipeline mereka jatuh ke dalam antrian operasi mikro khusus - Antrian Dekode Instruksi (IDQ), serta apa yang disebut cache operasi mikro (Decoded ICache, cache µop). Cache operasi mikro awalnya diperkenalkan di Sandy Bridge dan digunakan untuk menghindari mengambil dan mendekode instruksi dalam operasi mikro, sehingga meningkatkan throughput untuk mengirimkan operasi mikro di IDQ - hingga 6 per siklus. Setelah masuk ke IDQ, operasi mikro pergi ke Back End untuk eksekusi dengan throughput puncak 4 operasi mikro per siklus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut dokumentasi Intel, cache operasi mikro terdiri dari 32 set, setiap set berisi 8 baris, setiap baris dapat menyimpan cache hingga 6 operasi mikro (penyatuan mikro / makro), memungkinkan total cache hingga 32 * 8 * 6 = 1536 operasi mikro . </font><font style="vertical-align: inherit;">Caching operasi mikro terjadi dengan granularitas 32 byte, mis. </font><font style="vertical-align: inherit;">operasi mikro yang mengikuti instruksi dari berbagai wilayah 32-byte tidak dapat dikelompokkan menjadi satu baris. </font><font style="vertical-align: inherit;">Namun, hingga 3 baris cache yang berbeda dapat sesuai dengan satu wilayah 32-byte. </font><font style="vertical-align: inherit;">Dengan demikian, hingga 18 operasi mikro dalam cache µop dapat sesuai dengan masing-masing wilayah 32-byte.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manual Pengoptimalan Perangkat Lunak Intel / 2.5.5.2</font></font></b><div class="spoiler_text"><blockquote>The Decoded ICache consists of 32 sets. Each set contains eight Ways. Each Way can hold up to six micro-ops. The Decoded ICache can ideally hold up to 1536 micro-ops. The following are some of the rules how the Decoded ICache is filled with micro-ops:<br>
<br>
<ul>
<li>ll micro-ops in a Way represent instructions which are statically contiguous in the code and have their EIPs within the same aligned 32-byte region.</li>
<li>Up to three Ways may be dedicated to the same 32-byte aligned chunk, allowing a total of 18 micro-ops to be cached per 32-byte region of the original IA program.</li>
<li>A multi micro-op instruction cannot be split across Ways.</li>
<li>Up to two branches are allowed per Way. </li>
<li>An instruction which turns on the MSROM consumes an entire Way.</li>
<li>A non-conditional branch is the last micro-op in a Way. </li>
<li>Micro-fused micro-ops (load+op and stores) are kept as one micro-op.</li>
<li>A pair of macro-fused instructions is kept as one micro-op.</li>
<li>Instructions with 64-bit immediate require two slots to hold the immediate.</li>
</ul></blockquote><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog juga menyebutkan bahwa hanya operasi mikro jalur tunggal yang dapat diunduh per siklus (tidak secara eksplisit dinyatakan dalam dokumentasi Intel, meskipun dapat dengan mudah diperiksa secara manual).</font></font><br>
<br>
<h4>    µop cache --&gt; IDQ</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam beberapa kasus, sangat nyaman menggunakan </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panjang 1 byte </font><font style="vertical-align: inherit;">untuk mempelajari perilaku Front End </font><font style="vertical-align: inherit;">. Pada saat yang sama, kita dapat yakin bahwa kita sedang menyelidiki Front End, dan bukan Resource Stall di Back End, dengan alasan apa pun. Faktanya adalah bahwa </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, serta instruksi lainnya, mereka diterjemahkan dalam Legacy Decode Pipeline, dicampur dalam µop cache dan dikirim ke IDQ. Selanjutnya </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, serta instruksi lainnya, membutuhkan back end. Perbedaan yang signifikan adalah bahwa dari sumber daya di Back End </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyusun Ulang Pesanan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan tidak memerlukan slot di Stasiun Pemesanan (alias Penjadwal). Dengan demikian, segera setelah memasuki Reorder Buffer, ia </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siap untuk pensiun, yang akan dilakukan sesuai dengan urutan dalam kode program.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menguji throughput, deklarasikan suatu fungsi </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_decoded_icache</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> iteration_count)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dengan implementasi pada </font></font><code>nasm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">align 32<font></font>
test_decoded_icache:<font></font>
    ;nop',  0  23 <font></font>
    dec rdi<font></font>
    ja test_decoded_icache<font></font>
    ret</code></pre><br>
<code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu tidak dipilih secara kebetulan. </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan flag yang berbeda - </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibaca dari </font></font><code>CF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>ZF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak direkam dalam CF, sehingga Macro Fusion tidak berlaku. </font><font style="vertical-align: inherit;">Ini dilakukan murni untuk kenyamanan penghitungan operasi mikro dalam satu siklus - setiap instruksi berhubungan dengan satu operasi mikro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pengukuran, kita membutuhkan acara perf berikut: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font></font><code>uops_issued.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Digunakan untuk menghitung operasi mikro yang diambil Renamer dari IDQ. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panduan Pemrograman Sistem Intel mendokumentasikan acara ini sebagai jumlah operasi mikro yang dilakukan Renamer ke dalam Reservation Station:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghitung jumlah uops yang dikeluarkan Tabel Alokasi Sumber Daya (RAT) ke Stasiun Reservasi (RS).</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deskripsi ini tidak sepenuhnya berkorelasi dengan nilai-nilai yang dapat diperoleh dari percobaan. Secara khusus, mereka </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jatuh ke konter ini, meskipun itu hanya fakta bahwa mereka tidak diperlukan sama sekali di Stasiun Reservasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><code>uops_retired.retire_slots</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- jumlah total pensiunan mikro dengan memperhitungkan mikro / makro-fusi </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- jumlah kutu yang tidak ada satu mikro pensiunan </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- jumlah kutu dari konveyor menganggur karena tidak dapat diaksesnya sumber daya apa pun Back End </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Intel Software Optimization Manual / B .4.1 ada diagram konten yang mencirikan peristiwa yang dijelaskan di atas: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/j9/y3/wqj9y3jj7aeisnmdjxxxjwsl_jk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font></font><code>idq.all_dsb_cycles_4_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- jumlah siklus jam untuk 4 (atau lebih) instruksi yang dikirim dari cache µop.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fakta bahwa metrik ini memperhitungkan pengiriman lebih dari 4 operasi mikro per siklus tidak dijelaskan dalam dokumentasi Intel, tetapi metrik ini sangat setuju dengan eksperimen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. </font></font><code>idq.all_dsb_cycles_any_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- jumlah tindakan yang sedikitnya satu operasi mikro disampaikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><code>idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Jumlah total langkah-langkah di mana pengiriman berasal dari µop cache </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8. </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Jumlah langkah-langkah dimana Renamer mengambil satu </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau kurang operasi mikro dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada downtime di sisi Back End</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 1, 2, 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melakukan penelitian </font></font><code>iteration_count = 1 &lt;&lt; 31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami memulai analisis tentang apa yang terjadi di CPU dengan memeriksa jumlah operasi mikro dan, pertama, dengan mengukur bandwidth rata-rata pensiun, yaitu </font></font><code>uops_retired.retire_slots/uops_retired.total_cycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xi/b2/0s/xib20shepbr334i1xmhka10rjeg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang segera menarik perhatian Anda adalah surutnya arus pensiun pada ukuran siklus 7 operasi mikro. Untuk memahami apa itu, mari kita perhatikan bagaimana tingkat pengiriman rata-rata cache μop - </font></font><code>idq.all_dsb_cycles_any_uops / idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xm/5s/su/xm5ssuzamxr4th-xs7e0ixrisfm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan bagaimana menghubungkan jumlah total siklus jam dan siklus di mana cache μop dikirimkan dalam IDQ: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/w5/va/itw5vasl9ogpslneyoclxzasu4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian dapat dilihat bahwa siklus 6 operasi mikro yang kita miliki efektif Pemanfaatan bandwidth cache µop - 6 operasi mikro per siklus. Karena kenyataan bahwa Renamer tidak dapat menerima sebanyak µop cache yang dikirimkan, bagian dari siklus cache µop tidak mengirimkan apa pun, yang terlihat jelas dalam grafik sebelumnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan siklus 7 operasi mikro, kami mendapatkan penurunan tajam dalam throughput cache µop - 3,5 operasi mikro per siklus. Pada saat yang sama, seperti dapat dilihat dari grafik sebelumnya, cache µop terus beroperasi. Dengan demikian, dengan siklus 7 operasi mikro, kami mendapatkan pemanfaatan bandwidth µop cache yang tidak efisien. Faktanya adalah bahwa, seperti disebutkan sebelumnya, cache µop per siklus dapat mengirimkan operasi mikro hanya dari satu baris. Dalam kasus operasi mikro 7 - 6 pertama jatuh dalam satu baris, dan 7 sisanya - di yang lain. Dengan cara ini, kita mendapatkan 7 operasi mikro per 2 siklus, atau 3,5 operasi mikro per siklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita lihat bagaimana Renamer mengambil operasi mikro dari IDQ. Untuk ini kita perlu </font></font><code>idq_uops_not_delivered.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/mg/qv/kvmgqvwgra-j4qgpxia46mwlsh4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin memperhatikan bahwa dengan 7 operasi mikro, hanya 3 operasi mikro pada saat yang sama mengambil setengah siklus Renamer. Dari sini kita mendapatkan hasil pensiun rata-rata 3,5 operasi mikro per siklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal menarik lainnya yang terkait dengan contoh ini dapat dilihat jika kita mempertimbangkan </font><font style="vertical-align: inherit;">throughput pensiun yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efektif</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Itu tidak mempertimbangkan </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/hy/gt/uohygtod0xknhsvolqjnig7tfos.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dapat dicatat bahwa dengan 7 operasi mikro, setiap 7 langkah pensiun dari 4 operasi mikro dilakukan, dan setiap langkah ke 8 menganggur tanpa operasi mikro yang pensiun (kandang pensiun). </font><font style="vertical-align: inherit;">Setelah melakukan serangkaian percobaan, adalah mungkin untuk menemukan bahwa perilaku seperti itu selalu diamati selama 7 operasi mikro, terlepas dari tata letak mereka 1-6, 6-1, 2-5, 5-2, 3-4, 4-3. </font><font style="vertical-align: inherit;">Saya tidak tahu mengapa ini persis seperti itu, dan tidak, misalnya, pensiun dari 3 operasi mikro dilakukan dalam satu siklus clock, dan 4 di berikutnya. </font><font style="vertical-align: inherit;">Agner Fog menyebutkan bahwa transisi cabang hanya dapat menggunakan bagian dari slot stasiun pensiun. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pembatasan ini adalah alasan perilaku pensiun ini.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami apakah ini semua memiliki efek dalam praktik, pertimbangkan contoh berikut yang sedikit lebih praktis daripada dengan </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua array diberikan </font></font><code>unsigned</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adalah perlu untuk mengakumulasikan jumlah alat aritmatika untuk setiap indeks dan menulisnya ke array ketiga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh implementasi mungkin terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr1[] = { ... };<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr2[] = { ... };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-keyword">unsigned</span> out[<span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>)];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4096</span> * <span class="hljs-number">4096</span>; i++){<font></font>
        arithmetic_mean(arr1, arr2, out, <span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>));<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilasi dengan flag gcc </font></font><br>
<br>
<pre><code class="plaintext hljs">-Werror<font></font>
-Wextra<font></font>
-Wall<font></font>
-pedantic<font></font>
-Wno-stack-protector<font></font>
-g3<font></font>
-O3<font></font>
-Wno-unused-result<font></font>
-Wno-unused-parameter</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cukup jelas bahwa fungsi </font></font><code>arithmetic_mean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan ada dalam kode dan akan dimasukkan langsung ke </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">(gdb) disas main<font></font>
Dump of assembler code for function main:<font></font>
   #...<font></font>
   0x00000000000005dc &lt;+60&gt;:    nop    DWORD PTR [rax+0x0]<font></font>
   0x00000000000005e0 &lt;+64&gt;:    mov    edx,DWORD PTR [rdi+rax*4]<font></font>
   0x00000000000005e3 &lt;+67&gt;:    add    edx,DWORD PTR [r8+rax*4]<font></font>
   0x00000000000005e7 &lt;+71&gt;:    shr    edx,1<font></font>
   0x00000000000005e9 &lt;+73&gt;:    add    ecx,edx<font></font>
   0x00000000000005eb &lt;+75&gt;:    mov    DWORD PTR [rsi+rax*4],ecx<font></font>
   0x00000000000005ee &lt;+78&gt;:    add    rax,0x1<font></font>
   0x00000000000005f2 &lt;+82&gt;:    cmp    rax,0x80<font></font>
   0x00000000000005f8 &lt;+88&gt;:    jne    0x5e0 &lt;main+64&gt;<font></font>
   0x00000000000005fa &lt;+90&gt;:    sub    r9,0x1<font></font>
   0x00000000000005fe &lt;+94&gt;:    jne    0x5d8 &lt;main+56&gt;<font></font>
   #...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa kompiler menyelaraskan kode loop ke 32 byte ( </font></font><code>nop DWORD PTR [rax+0x0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), yang persis apa yang kita butuhkan. </font><font style="vertical-align: inherit;">Setelah memastikan bahwa tidak ada </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back End (semua pengukuran dilakukan dengan mempertimbangkan cache L1d yang dipanaskan), kita dapat mulai mempertimbangkan penghitung yang terkait dengan pengiriman ke IDQ:</font></font><br>
<br>
<pre><code class="plaintext hljs"> Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2 273 343 251      idq.all_dsb_cycles_4_uops                                     (15,94%)<font></font>
     4 458 322 025      idq.all_dsb_cycles_any_uops                                     (16,26%)<font></font>
    15 473 065 238      idq.dsb_uops                                                  (16,59%)<font></font>
     4 358 690 532      idq.dsb_cycles                                                (16,91%)<font></font>
     2 528 373 243      idq_uops_not_delivered.core                                     (16,93%)<font></font>
        73 728 040      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,93%)<font></font>
       107 262 304      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,93%)<font></font>
       108 454 043      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,65%)<font></font>
     2 248 557 762      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,32%)<font></font>
     2 385 493 805      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,00%)<font></font>
    15 147 004 678     uops_retired.retire_slots<font></font>
    4 724 790 623      uops_retired.total_cycles<font></font>
       <font></font>
     1,228684264 seconds time elapsed<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa badwidth pensiun dalam kasus ini = 15147004678/4724790623 = 3.20585733562, dan juga hanya 3 operasi mikro yang mengambil setengah jam dari Renamer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tambahkan promosi loop manual ke implementasi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(sz &amp; <span class="hljs-number">2</span>){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;  <span class="hljs-comment">//   idx++     idx+=2</span><font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penghitung perf yang dihasilkan terlihat seperti:</font></font><br>
<br>
<pre><code class="plaintext hljs">Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2 152 818 549      idq.all_dsb_cycles_4_uops                                     (14,79%)<font></font>
     3 207 203 856      idq.all_dsb_cycles_any_uops                                     (15,25%)<font></font>
    12 855 932 240      idq.dsb_uops                                                  (15,70%)<font></font>
     3 184 814 613      idq.dsb_cycles                                                (16,15%)<font></font>
        24 946 367      idq_uops_not_delivered.core                                     (16,24%)<font></font>
         3 011 119      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,24%)<font></font>
         5 239 222      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,24%)<font></font>
         7 373 563      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,24%)<font></font>
         7 837 764      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,24%)<font></font>
     3 418 529 799      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,24%)<font></font>
     3 444 833 440      uops_retired.total_cycles                                     (18,18%)<font></font>
    13 037 919 196      uops_retired.retire_slots                                     (18,17%)<font></font>
<font></font>
    0,871040207 seconds time elapsed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, kami memiliki bandwidth pensiunan = 13037919196/3444833440 = 3.78477491672, serta pemanfaatan bandwidth Renamer yang efisien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kami tidak hanya menghilangkan satu operasi percabangan dan satu peningkatan dalam satu lingkaran, tetapi juga meningkatkan bandwidth pensiun menggunakan pemanfaatan yang efisien dari throughput cache operasi mikro, yang memberikan peningkatan total kinerja 28%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa hanya pengurangan dalam satu cabang dan operasi penambahan yang memberikan peningkatan kinerja rata-rata 9%.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komentar kecil</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada CPU yang digunakan untuk melakukan eksperimen ini, LSD dimatikan. </font><font style="vertical-align: inherit;">Tampaknya LSD dapat menangani situasi seperti itu. </font><font style="vertical-align: inherit;">Untuk CPU dengan LSD diaktifkan, kasus-kasus seperti itu perlu diselidiki secara terpisah.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497278/index.html">Berdebar. Sinkronisasi dan paralelisme</a></li>
<li><a href="../id497280/index.html">Bagaimana saya berhenti menjadi takut dan jatuh cinta pada kolesterol</a></li>
<li><a href="../id497282/index.html">Bersihkan kode dalam Angular. Memasak ESLint, codelyzer, stylelint, husky, lint-staged dan Prettier</a></li>
<li><a href="../id497286/index.html">Ludum Dare: daftar periksa seminggu sebelum memulai</a></li>
<li><a href="../id497288/index.html">Lampu langit-langit dekoratif Feron AL5000</a></li>
<li><a href="../id497292/index.html">Game Stack Shiro Teknologi</a></li>
<li><a href="../id497296/index.html">Kesalahan populer dalam bahasa Inggris di kalangan profesional TI. Bagian 2: Pengucapan</a></li>
<li><a href="../id497302/index.html">Navigasi otonom dari robot seluler</a></li>
<li><a href="../id497304/index.html">Intercepter-NG 2.5 dirilis untuk Android</a></li>
<li><a href="../id497306/index.html">DLL spoofing (pembajakan DLL)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>