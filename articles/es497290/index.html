<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 👩🏿‍🤝‍👩🏽 👨🏿‍🔧 Mejora del rendimiento con el caché uop en Sandy Bridge + 🍑 👶 👨🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los procesadores Intel x86 modernos, la tubería se puede dividir en 2 partes: Front End y Back End. 
 
 Front End es responsable de cargar el códig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mejora del rendimiento con el caché uop en Sandy Bridge +</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497290/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los procesadores Intel x86 modernos, la tubería se puede dividir en 2 partes: Front End y Back End. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Front End es responsable de cargar el código de la memoria y decodificarlo en microoperaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back End es responsable de realizar microoperaciones desde Front End. </font><font style="vertical-align: inherit;">Dado que estas microoperaciones pueden ser realizadas por el núcleo fuera de servicio, el Back End también asegura que el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de estas microoperaciones corresponda estrictamente al orden en que van en el código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la mayoría de los casos, el uso ineficiente de Front End'a no tiene un efecto notable en el rendimiento. </font><font style="vertical-align: inherit;">El ancho de banda máximo en la mayoría de los procesadores Intel es de 4 micro operaciones por ciclo, por lo tanto, por ejemplo, para un código enlazado con Memoria / L3, la CPU no podrá utilizarlo por completo.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pro relativamente nuevo Ice Lake</font></font></b><div class="spoiler_text">   ,      Ice Lake    4  5   .  ,        ,         . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, en algunos casos, la diferencia en el rendimiento puede ser bastante significativa. </font><font style="vertical-align: inherit;">Debajo del corte hay un análisis del impacto del caché de microoperación en el rendimiento.</font></font><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El contenido del articulo</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medio ambiente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripción general de los procesadores Front End'a Intel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análisis de ancho de banda máximo µop cache -&gt; IDQ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medio ambiente</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todas las mediciones en este artículo se utilizará </font></font><code>i7-8550U Kaby Lake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, HT habilitado / </font></font><code>Ubuntu 18.04/Linux Kernel 5.3.0-45-generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En este caso, dicho entorno puede ser significativo, porque </font><font style="vertical-align: inherit;">Cada modelo de CPU tiene su propio evento de rendimiento. </font><font style="vertical-align: inherit;">En particular, para las microarquitecturas más antiguas que Sandy Bridge, algunos de los eventos utilizados en el futuro simplemente no tienen sentido.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripción general de los procesadores Front End'a Intel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La organización de la línea de ensamblaje de alto nivel es información disponible públicamente y se publica en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentación oficial de Intel sobre optimización de software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Puede encontrar una descripción más detallada de algunas de las funciones que se omiten de la documentación oficial en otras fuentes acreditadas, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agner Fog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travis Downs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entonces, por ejemplo, el esquema de la tubería de ensamblaje para Skylake en la documentación de Intel se ve así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qe/jr/xa/qejrxaieyvky3yjl5yps8toljme.png" alt="Oleoducto Skylake"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Echemos un </font><font style="vertical-align: inherit;">vistazo </font><font style="vertical-align: inherit;">más de cerca </font><font style="vertical-align: inherit;">a la </font><font style="vertical-align: inherit;">parte superior de este esquema: Front End. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/ya/yw/dpyaywk2lq0qub5zh4dvjlqwjn4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Legacy Decode Pipeline es responsable de decodificar el código en microoperaciones. </font><font style="vertical-align: inherit;">Se compone de los siguientes componentes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unidad de búsqueda de instrucciones - IFU</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caché de instrucciones de primer nivel - L1i</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caché de direcciones de traducción del registro de instrucciones - ITLB</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instructor Prefector</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instrucciones de predescodificador</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cola de instrucciones pre-decodificadas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decodificadores de instrucciones precodificados por microoperación</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere cada una de las partes del Legacy Decode Pipeline individualmente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unidad de búsqueda de instrucciones. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es responsable de cargar el código, precodificar (determinar la longitud de la instrucción y propiedades tales como "si la instrucción es una rama") y entregar instrucciones precodificadas a la cola. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caché de instrucciones de primer nivel - L1i</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para descargar el código, la IFU usa L1i, el caché de instrucciones de primer nivel, y L2 / LLC, el caché de segundo nivel y el caché offcore de nivel superior, comunes al código y los datos. La descarga se realiza en piezas de 16 bytes, también alineados a 16 bytes. Cuando se carga el siguiente fragmento de código de 16 bytes en orden, se realiza una llamada a L1i y, si no se encuentra la línea correspondiente, se realiza una búsqueda en L2 y, en caso de falla, en LLC y memoria. Antes de Skylake LLC, el caché era inclusivo: cada línea en L1 (i / d) y L2 debería estar contenida en la LLC. Por lo tanto, LLC "sabía" acerca de todas las líneas en todos los núcleos y, en el caso de un deslizamiento de LLC, se sabía si los cachés en otros núcleos contenían la línea requerida en el estado Modificado, lo que significa que esta línea podría cargarse desde otro núcleo. Skylake LLC se convirtió en un caché de víctimas L2 no inclusivo, pero el tamaño de L2 aumentó 4 veces. No lo sési L2 es inclusivo con respecto a L1i. L2</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inclusivo con respecto a L1d. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traducción de direcciones lógicas de instrucciones - ITLB</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Antes de descargar datos del caché, debe buscar la línea correspondiente. Para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cachés asociativos de ida</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cada línea puede estar en </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferentes lugares en el propio caché. Para determinar las posibles posiciones en el caché, se usa un índice (generalmente unos pocos bits más bajos de la dirección). Para determinar si la línea coincide con la dirección que necesitamos, se utiliza una etiqueta (el resto de la dirección). Qué direcciones usar: físicas o lógicas, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depende de la implementación de la memoria caché</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El uso de direcciones físicas requiere traducción de direcciones. Para la traducción de direcciones, se utiliza un búfer TLB, que almacena en caché los resultados de las visitas a la página, lo que reduce el retraso en la recepción de una dirección física de una dirección lógica en las llamadas posteriores. Para obtener instrucciones, hay su propio búfer TLB de instrucciones, ubicado por separado del TLB de datos. El núcleo de la CPU también tiene un TLB de segundo nivel común al código y los datos: STLB. No sé si STLB es inclusivo (se rumorea que no es un caché de víctimas inclusivo en relación con D / I TLB). Uso de instrucciones de captación previa de software</font></font><code>prefetcht1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede abrir la línea con el código en L2, sin embargo, el registro TLB correspondiente solo se levantará en DTLB. </font><font style="vertical-align: inherit;">Si STLB no es inclusivo, cuando busque esta línea con el código en los cachés, obtendrá la falta de ITLB -&gt; Falta de STLB -&gt; recorrido de página (de hecho, no es tan simple, porque el núcleo puede </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iniciar un recorrido de página especulativo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> antes de que ocurra Señorita TLB). </font><font style="vertical-align: inherit;">La documentación de Intel también desalienta el uso de captaciones previas de SW para el código, Intel Software Optimization Manual / 2.5.5.4:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La captación previa controlada por software está destinada a la captación previa de datos, pero no a la captación previa de código.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, Travis D. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencionó</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que tal captación previa puede ser muy efectiva (y muy probablemente lo sea), pero hasta ahora esto no es obvio para mí y para estar convencido de esto, tendré que examinar este tema por separado. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instructor Prefector</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La descarga de datos a la caché (L1d / i, L2, etc.) ocurre cuando se accede a una sección de memoria no almacenada en caché. </font><font style="vertical-align: inherit;">Sin embargo, si esto sucediera solo bajo tales condiciones, entonces como resultado obtendríamos un uso ineficiente del ancho de banda de caché. </font><font style="vertical-align: inherit;">Por ejemplo, en Sandy Bridge para L1d: 2 operaciones de lectura, 1 escritura de 16 bytes por ciclo; </font><font style="vertical-align: inherit;">para la operación de lectura L1i - 1 de 16 bytes, el rendimiento de escritura no se especifica en la documentación, tampoco se encontró Agner Fog. </font><font style="vertical-align: inherit;">Para resolver este problema, hay buscadores de hardware que pueden determinar el patrón de acceso a la memoria y extraer las líneas necesarias en la memoria caché antes de que el código las aborde realmente. </font><font style="vertical-align: inherit;">La documentación de Intel define 4 captadores previos: 2 para L1d, 2 para L2:</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 DCU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : prefijo de líneas de caché serie. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo lectura hacia adelante</font></font></b></li>
<li><b>L1 IP</b> —              (. 0x5555555545a0, 0x5555555545b0, 0x5555555545c0, ...),    ,   ,  </li>
<li><b>L2 Spatial</b> —       L2    -,        128-.       LLC</li>
<li><b>L2 Streamer</b> —    .    L1 DCU      «».       LLC</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentación de Intel no describe el principio del prefector L1i. </font><font style="vertical-align: inherit;">Todo lo que se sabe es que la Unidad de predicción de sucursal (BPU) está involucrada en este proceso, Intel Software Optimization Manual / 2.6.2: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/js/y3/sdjsy3jrgseyeuukletr84i2gyu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog tampoco ve ningún detalle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La captación previa de código en L2 / LLC se define explícitamente solo para Streamer. </font><font style="vertical-align: inherit;">Manual de optimización / 2.5.5.4 Preprogramación de datos:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streamer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este prefetcher monitorea las solicitudes de lectura del caché L1 para secuencias de direcciones ascendentes y descendentes. </font><font style="vertical-align: inherit;">Las solicitudes de lectura monitoreadas incluyen las solicitudes L1 DCache iniciadas por las operaciones de carga y almacenamiento y por los captadores de hardware, y las solicitudes L1 ICache para la búsqueda de código.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el prefetcher espacial, esto claramente no se explica:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefetcher espacial:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este prefetcher se esfuerza por completar cada línea de caché obtenida en el caché L2 con la línea de pares que la completa en un fragmento alineado de 128 bytes.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero esto puede ser verificado. </font><font style="vertical-align: inherit;">Cada uno de estos captadores previos se puede desactivar utilizando </font></font><code>MSR 0x1A4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como se describe en el manual de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Registros específicos</font></a><font style="vertical-align: inherit;"> del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acerca de MSR 0x1A4</font></font></b><div class="spoiler_text">  MSR     L2 Spatial    L1i.     .              ,    LLC.     L2 Streamer       2.5 . <br>
<br>
 Linux  msr ,   msr     .  <code>$ sudo wrmsr -p 1 0x1a4 1</code>  L2 Streamer   1.<br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instrucciones de predescodificador</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Después de cargar el siguiente código de 16 bytes, se incluyen en las instrucciones de predescodificador. </font><font style="vertical-align: inherit;">Su tarea es determinar la longitud de la instrucción, decodificar los prefijos y marcar si la instrucción correspondiente es una rama (lo más probable es que todavía haya muchas propiedades diferentes, pero la documentación sobre ellas es silenciosa). </font><font style="vertical-align: inherit;">Manual de optimización de software Intel / 2.6.2.2:</font></font><br>
<blockquote>The predecode unit accepts the sixteen bytes from the instruction cache or prefetch buffers and carries out the following tasks:<br>
<br>
<ul>
<li>Determine the length of the instructions</li>
<li>Decode all prefixes associated with instructions</li>
<li>Mark various properties of instructions for the decoders (for example, “is branch.”)</li>
</ul></blockquote><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una línea de instrucciones predescodificadas. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde la IFU, las instrucciones se agregan a la cola de instrucciones precodificadas. </font><font style="vertical-align: inherit;">Esta cola ha aparecido desde Nehalem, de acuerdo con la documentación de Intel, su tamaño es de 18 instrucciones. </font><font style="vertical-align: inherit;">Agner Fog también menciona que esta cola no contiene más de 64 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También en Core2, esta cola se usó como caché de bucle. </font><font style="vertical-align: inherit;">Si todas las microoperaciones del ciclo están en la cola, entonces en algunos casos se podría evitar el costo de carga y codificación previa. </font><font style="vertical-align: inherit;">El Loop Stream Detector (LSD) puede entregar instrucciones que ya están en la cola hasta que la BPU indique que el ciclo ha finalizado. </font><font style="vertical-align: inherit;">Agner Fog tiene una serie de notas interesantes sobre LSD en Core2:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consta de 4 líneas de 16 bytes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Máximo rendimiento de hasta 32 bytes de código por ciclo</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzando con Sandy Bridge, este caché de bucle se ha movido de la cola de instrucciones predescodificadas de nuevo a IDQ. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decodificadores de instrucciones predescodificadas en microoperación</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Desde la cola de </font><b><font style="vertical-align: inherit;">instrucciones predescodificadas</font></b><font style="vertical-align: inherit;"> , el código se envía a la decodificación en microoperación. Los decodificadores son responsables de la decodificación: hay 4 en total. Según la documentación de Intel, uno de los decodificadores puede decodificar instrucciones que consisten en 4 microoperaciones o menos. El resto decodifica las instrucciones que consisten en una microoperación (micro / macro fusionada), Manual de optimización de software Intel / 2.5.2.1:</font></font><br>
<blockquote>There are four decoding units that decode instruction into micro-ops. The first can decode all IA-32 and Intel 64 instructions up to four micro-ops in size. The remaining three decoding units handle single-micro-op instructions. All four decoding units support the common cases of single micro-op flows including micro-fusion and macro-fusion.</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las instrucciones decodificadas en una gran cantidad de microoperaciones (por ejemplo, rep movsb utilizado en la implementación de memcpy en libc en ciertos tamaños de memoria copiada) provienen de Microcode Sequencer (MS ROM). El ancho de banda máximo del secuenciador es de 4 microoperaciones por ciclo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver en el diagrama de la línea de ensamblaje, el Legacy Decode Pipeline puede decodificar hasta 5 micro operaciones por ciclo en Skylake. En Broadwell y versiones anteriores, el rendimiento máximo de Legacy Decode Pipeline fue de 4 microoperaciones por ciclo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caché de microoperación</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de que las instrucciones se descodifiquen en microoperaciones, desde el Legacy Decode Pipeline caen en la cola de microoperación especial: Cola de decodificación de instrucciones (IDQ), así como el llamado caché de microoperación (Decoded ICache, µop cache). El caché de microoperaciones se introdujo originalmente en Sandy Bridge y se usa para evitar buscar y decodificar instrucciones en microoperaciones, lo que aumenta el rendimiento para entregar microoperaciones en IDQ, hasta 6 por ciclo. Después de ingresar a IDQ, las microoperaciones van al Back End para su ejecución con un rendimiento máximo de 4 microoperaciones por ciclo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acuerdo con la documentación de Intel, el caché de microoperación consta de 32 conjuntos, cada conjunto contiene 8 líneas, cada línea puede almacenar en caché hasta 6 micro operaciones (micro / macro fusionadas), lo que permite un caché total de hasta 32 * 8 * 6 = 1536 micro operaciones . </font><font style="vertical-align: inherit;">El almacenamiento en caché de microoperación se produce con una granularidad de 32 bytes, es decir </font><font style="vertical-align: inherit;">Las microoperaciones que siguen instrucciones de diferentes regiones de 32 bytes no pueden caer en una sola línea. </font><font style="vertical-align: inherit;">Sin embargo, hasta 3 líneas de caché diferentes pueden corresponder a una región de 32 bytes. </font><font style="vertical-align: inherit;">Por lo tanto, hasta 18 microoperaciones en caché µop pueden corresponder a cada región de 32 bytes.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manual de optimización de software Intel / 2.5.5.2</font></font></b><div class="spoiler_text"><blockquote>The Decoded ICache consists of 32 sets. Each set contains eight Ways. Each Way can hold up to six micro-ops. The Decoded ICache can ideally hold up to 1536 micro-ops. The following are some of the rules how the Decoded ICache is filled with micro-ops:<br>
<br>
<ul>
<li>ll micro-ops in a Way represent instructions which are statically contiguous in the code and have their EIPs within the same aligned 32-byte region.</li>
<li>Up to three Ways may be dedicated to the same 32-byte aligned chunk, allowing a total of 18 micro-ops to be cached per 32-byte region of the original IA program.</li>
<li>A multi micro-op instruction cannot be split across Ways.</li>
<li>Up to two branches are allowed per Way. </li>
<li>An instruction which turns on the MSROM consumes an entire Way.</li>
<li>A non-conditional branch is the last micro-op in a Way. </li>
<li>Micro-fused micro-ops (load+op and stores) are kept as one micro-op.</li>
<li>A pair of macro-fused instructions is kept as one micro-op.</li>
<li>Instructions with 64-bit immediate require two slots to hold the immediate.</li>
</ul></blockquote><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog también menciona que solo se pueden descargar micro operaciones de una sola línea por ciclo (no se indica explícitamente en la documentación de Intel, aunque se puede verificar fácilmente de forma manual).</font></font><br>
<br>
<h4>    µop cache --&gt; IDQ</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En algunos casos, es muy conveniente usar </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">longitudes de 1 byte </font><font style="vertical-align: inherit;">para estudiar el comportamiento de Front End </font><font style="vertical-align: inherit;">. Al mismo tiempo, podemos estar seguros de que estamos investigando el Front End, y no el Puesto de recursos en el Back End, por cualquier motivo. El hecho es que </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, además de otras instrucciones, se decodifican en la tubería de decodificación heredada, se mezclan en caché µop y se envían a IDQ. Además </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, al igual que otras instrucciones, se remonta. La diferencia significativa es que de los recursos en el Back End </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza solo el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reorden Buffer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y no requiere un espacio en la Estación de Reserva (también conocido como Programador). Por lo tanto, inmediatamente después de ingresar Reorder Buffer, está </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listo para la jubilación, que se realizará de acuerdo con el orden en el código del programa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para probar el rendimiento, declare una función </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_decoded_icache</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> iteration_count)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
con implementación en </font></font><code>nasm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">align 32<font></font>
test_decoded_icache:<font></font>
    ;nop',  0  23 <font></font>
    dec rdi<font></font>
    ja test_decoded_icache<font></font>
    ret</code></pre><br>
<code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No fue elegido por casualidad. </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizar diferentes banderas - </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lee de </font></font><code>CF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>ZF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se está grabando en el CF, por lo macro fusión no se aplica. </font><font style="vertical-align: inherit;">Esto se hace únicamente por la conveniencia de contar microoperaciones en un ciclo; cada instrucción corresponde a una microoperación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para las mediciones, necesitamos los siguientes eventos de rendimiento: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font></font><code>uops_issued.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Se utiliza para contar las microoperaciones que Renamer toma de IDQ. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La Guía de programación del sistema Intel documenta este evento como el número de microoperaciones que Renamer pone en la Estación de reserva:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuenta el número de uops que la tabla de asignación de recursos (RAT) emite a la estación de reserva (RS).</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta descripción no se correlaciona completamente con los valores que se pueden obtener de los experimentos. En particular, </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caen en este mostrador, aunque es solo un hecho que no son necesarios en absoluto en la Estación de Reservaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><code>uops_retired.retire_slots</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el número total de microoperaciones retiradas teniendo en cuenta la micro / macro fusión </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el número de ticks para los cuales no hubo una sola microoperación retirada </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el número de ticks del transportador inactivo debido a la inaccesibilidad de cualquiera de los recursos Back End </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en el Intel Software Optimization Manual / B .4.1 hay un diagrama de contenido que caracteriza los eventos descritos anteriormente: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/j9/y3/wqj9y3jj7aeisnmdjxxxjwsl_jk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font></font><code>idq.all_dsb_cycles_4_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el número de ciclos de reloj para los cuales se entregaron 4 (o más) instrucciones desde el caché µop.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El hecho de que esta métrica tenga en cuenta la entrega de más de 4 microoperaciones por ciclo no se describe en la documentación de Intel, pero está muy de acuerdo con los experimentos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. </font></font><code>idq.all_dsb_cycles_any_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el número de medidas para las cuales se entregó al menos una microoperación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><code>idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- El número total de medidas en las que la entrega se realizó desde el caché µop </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8. </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- El número de medidas para las cuales Renamer tomó una </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o menos microoperaciones y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hubo tiempo de inactividad en el lado de Back End</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 1, 2, 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos para la investigación </font></font><code>iteration_count = 1 &lt;&lt; 31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comenzamos el análisis de lo que está sucediendo en la CPU examinando el número de microoperaciones y, primero, midiendo el ancho de banda promedio de retiro, es decir </font></font><code>uops_retired.retire_slots/uops_retired.total_cycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xi/b2/0s/xib20shepbr334i1xmhka10rjeg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que llama la atención de inmediato es la subsidencia del rendimiento de la jubilación en un ciclo de 7 microoperaciones. Para entender qué es, consideremos cómo la tasa de entrega promedio de caché μop - </font></font><code>idq.all_dsb_cycles_any_uops / idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xm/5s/su/xm5ssuzamxr4th-xs7e0ixrisfm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y cómo relacionar el número total de ciclos de reloj y ciclos para los cuales se entregó caché μop en IDQ: por lo </font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/w5/va/itw5vasl9ogpslneyoclxzasu4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tanto, se puede ver que el ciclo de 6 microoperaciones tenemos efectivo Utilización de ancho de banda de caché µop: 6 micro operaciones por ciclo. Debido al hecho de que Renamer no puede recoger tanto como el caché µop entrega, algunos de los ciclos de caché µop no entregan nada, lo cual es claramente visible en el gráfico anterior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con un ciclo de 7 microoperaciones, obtenemos una fuerte caída en el rendimiento del caché µop: 3.5 microoperaciones por ciclo. Al mismo tiempo, como se puede ver en el gráfico anterior, el caché µop está constantemente en funcionamiento. Por lo tanto, con un ciclo de 7 microoperaciones, obtenemos una utilización ineficiente de la caché µop de ancho de banda. El hecho es que, como se señaló anteriormente, la caché µop por ciclo puede entregar microoperaciones desde una sola línea. En caso de microoperaciones 7, los primeros 6 caen en una línea y los 7 restantes, en otra. De esta manera, obtenemos 7 microoperaciones por 2 ciclos, o 3,5 microoperaciones por ciclo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos cómo Renamer toma microoperaciones de IDQ. Para esto necesitamos </font></font><code>idq_uops_not_delivered.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/mg/qv/kvmgqvwgra-j4qgpxia46mwlsh4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede notar que con 7 microoperaciones, solo 3 microoperaciones a la vez toman la mitad de los ciclos de Renamer. A partir de aquí, obtenemos un rendimiento de jubilación de un promedio de 3.5 microoperaciones por ciclo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro punto interesante relacionado con este ejemplo se puede ver si consideramos el </font><font style="vertical-align: inherit;">rendimiento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efectivo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la jubilación. Aquellos. sin considerar </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/hy/gt/uohygtod0xknhsvolqjnig7tfos.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se puede observar que con 7 microoperaciones, cada 7 medidas se realiza el retiro de 4 microoperaciones, y cada octava medida está inactiva sin microoperaciones retiradas (parada de retiro). </font><font style="vertical-align: inherit;">Después de realizar una serie de experimentos, fue posible encontrar que tal comportamiento siempre se observó durante 7 microoperaciones, independientemente de su diseño 1-6, 6-1, 2-5, 5-2, 3-4, 4-3. </font><font style="vertical-align: inherit;">No sé por qué este es exactamente el caso, y no, por ejemplo, el retiro de 3 microoperaciones se realiza en un ciclo de reloj y 4 en el siguiente. </font><font style="vertical-align: inherit;">Agner Fog mencionó que las transiciones de rama solo pueden usar parte de las ranuras de la estación de retiro. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quizás</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esta restricción sea la razón de este comportamiento de jubilación.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender si todo esto tiene un efecto en la práctica, considere el siguiente ejemplo un poco más práctico que con </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
se dan dos matrices </font></font><code>unsigned</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es necesario acumular la suma de los medios aritméticos para cada índice y escribirlo en la tercera matriz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo de implementación podría verse así:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr1[] = { ... };<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr2[] = { ... };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-keyword">unsigned</span> out[<span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>)];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4096</span> * <span class="hljs-number">4096</span>; i++){<font></font>
        arithmetic_mean(arr1, arr2, out, <span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>));<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compilar con banderas gcc </font></font><br>
<br>
<pre><code class="plaintext hljs">-Werror<font></font>
-Wextra<font></font>
-Wall<font></font>
-pedantic<font></font>
-Wno-stack-protector<font></font>
-g3<font></font>
-O3<font></font>
-Wno-unused-result<font></font>
-Wno-unused-parameter</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bastante obvio que la función </font></font><code>arithmetic_mean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no estará presente en el código y se insertará directamente en </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">(gdb) disas main<font></font>
Dump of assembler code for function main:<font></font>
   #...<font></font>
   0x00000000000005dc &lt;+60&gt;:    nop    DWORD PTR [rax+0x0]<font></font>
   0x00000000000005e0 &lt;+64&gt;:    mov    edx,DWORD PTR [rdi+rax*4]<font></font>
   0x00000000000005e3 &lt;+67&gt;:    add    edx,DWORD PTR [r8+rax*4]<font></font>
   0x00000000000005e7 &lt;+71&gt;:    shr    edx,1<font></font>
   0x00000000000005e9 &lt;+73&gt;:    add    ecx,edx<font></font>
   0x00000000000005eb &lt;+75&gt;:    mov    DWORD PTR [rsi+rax*4],ecx<font></font>
   0x00000000000005ee &lt;+78&gt;:    add    rax,0x1<font></font>
   0x00000000000005f2 &lt;+82&gt;:    cmp    rax,0x80<font></font>
   0x00000000000005f8 &lt;+88&gt;:    jne    0x5e0 &lt;main+64&gt;<font></font>
   0x00000000000005fa &lt;+90&gt;:    sub    r9,0x1<font></font>
   0x00000000000005fe &lt;+94&gt;:    jne    0x5d8 &lt;main+56&gt;<font></font>
   #...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que el compilador alineó el código de bucle a 32 bytes ( </font></font><code>nop DWORD PTR [rax+0x0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), que es exactamente lo que necesitamos. </font><font style="vertical-align: inherit;">Después de asegurarnos de que no haya </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back End (todas las mediciones se realizan teniendo en cuenta el caché L1d calentado), podemos comenzar a considerar los contadores asociados con la entrega a IDQ:</font></font><br>
<br>
<pre><code class="plaintext hljs"> Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2 273 343 251      idq.all_dsb_cycles_4_uops                                     (15,94%)<font></font>
     4 458 322 025      idq.all_dsb_cycles_any_uops                                     (16,26%)<font></font>
    15 473 065 238      idq.dsb_uops                                                  (16,59%)<font></font>
     4 358 690 532      idq.dsb_cycles                                                (16,91%)<font></font>
     2 528 373 243      idq_uops_not_delivered.core                                     (16,93%)<font></font>
        73 728 040      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,93%)<font></font>
       107 262 304      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,93%)<font></font>
       108 454 043      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,65%)<font></font>
     2 248 557 762      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,32%)<font></font>
     2 385 493 805      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,00%)<font></font>
    15 147 004 678     uops_retired.retire_slots<font></font>
    4 724 790 623      uops_retired.total_cycles<font></font>
       <font></font>
     1,228684264 seconds time elapsed<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que el ancho de retiro incorrecto en este caso = 15147004678/4724790623 = 3.20585733562, y también que solo 3 microoperaciones toman la mitad de los relojes de Renamer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora agregue la promoción de bucle manual a la implementación:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(sz &amp; <span class="hljs-number">2</span>){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;  <span class="hljs-comment">//   idx++     idx+=2</span><font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los contadores de rendimiento resultantes se ven así:</font></font><br>
<br>
<pre><code class="plaintext hljs">Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2 152 818 549      idq.all_dsb_cycles_4_uops                                     (14,79%)<font></font>
     3 207 203 856      idq.all_dsb_cycles_any_uops                                     (15,25%)<font></font>
    12 855 932 240      idq.dsb_uops                                                  (15,70%)<font></font>
     3 184 814 613      idq.dsb_cycles                                                (16,15%)<font></font>
        24 946 367      idq_uops_not_delivered.core                                     (16,24%)<font></font>
         3 011 119      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,24%)<font></font>
         5 239 222      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,24%)<font></font>
         7 373 563      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,24%)<font></font>
         7 837 764      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,24%)<font></font>
     3 418 529 799      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,24%)<font></font>
     3 444 833 440      uops_retired.total_cycles                                     (18,18%)<font></font>
    13 037 919 196      uops_retired.retire_slots                                     (18,17%)<font></font>
<font></font>
    0,871040207 seconds time elapsed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, tenemos un ancho de banda de retiro = 13037919196/3444833440 = 3.78477491672, así como una utilización eficiente del ancho de banda de Renamer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, no solo nos deshicimos de una ramificación y una operación de incremento en un bucle, sino que también aumentamos el ancho de banda de retiro mediante la utilización eficiente del rendimiento del caché de microoperación, lo que dio un aumento total del 28% en el rendimiento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que solo una reducción en una operación de rama e incremento proporciona un aumento de rendimiento promedio del 9%.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pequeño comentario</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la CPU que se utilizó para realizar estos experimentos, LSD está desactivado. </font><font style="vertical-align: inherit;">Parece que el LSD podría manejar tal situación. </font><font style="vertical-align: inherit;">Para las CPU con LSD habilitado, estos casos deberán investigarse por separado.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es497278/index.html">Aleteo. Asincronía y paralelismo</a></li>
<li><a href="../es497280/index.html">Cómo dejé de tener miedo y me enamoré del colesterol</a></li>
<li><a href="../es497282/index.html">Limpia el código en Angular. Cocinar ESLint, codelyzer, stylelint, husky, pelusa y más bonita</a></li>
<li><a href="../es497286/index.html">Ludum Dare: lista de verificación una semana antes del comienzo</a></li>
<li><a href="../es497288/index.html">Plafón decorativo Feron AL5000</a></li>
<li><a href="../es497292/index.html">Technology Stack Shiro Games</a></li>
<li><a href="../es497296/index.html">Errores populares en inglés entre los profesionales de TI. Parte 2: Pronunciación</a></li>
<li><a href="../es497302/index.html">Navegación autónoma de un robot móvil.</a></li>
<li><a href="../es497304/index.html">Intercepter-NG 2.5 lanzado para Android</a></li>
<li><a href="../es497306/index.html">Suplantación de DLL (secuestro de DLL)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>