<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÜ üíà üå≤ Kubernetes best practices. Setting Queries and Resource Limits ü§±üèΩ üë©üèø‚Äçüç≥ ü§õüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetes best practices. Creating Small Containers 
 Kubernetes Best Practices. Kubernetes Organization with the Kubernetes 
 Best Practices Namespa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes best practices. Setting Queries and Resource Limits</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/502614/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes best practices. Creating Small Containers </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes Best Practices. Kubernetes Organization with the Kubernetes </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Practices Namespace. Checking the viability of Kubernetes using the Readiness and Liveness tests</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
For each Kubernetes resource, you can configure two types of requirements - Requests and Limits. The first describes the minimum requirements for the availability of free node resources necessary to run a container or hearth, the second strictly limits the resources available to the container.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When Kubernetes plans a pod, it is very important that the containers have enough resources for normal operation. If you plan to deploy a large application on a node with limited resources, it is quite possible that it will not work because the node runs out of memory or lacks processor power. In this article, we will look at how you can solve the problems of lack of computer capacity using resource requests and restrictions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Requests and Limits are mechanisms that Kubernetes uses to manage resources such as the processor and memory. </font><font style="vertical-align: inherit;">Requests is the result of which the container is guaranteed to receive the requested resource. </font><font style="vertical-align: inherit;">If a container requests a resource, Kubernetes will only schedule it on the host that can provide it. </font><font style="vertical-align: inherit;">Limits limits control that the resources requested by the container will never exceed a certain value.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cm/qe/ea/cmqeea8rq8jd0tuwefj5zyx0enw.jpeg"><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A container can only increase computing power to a certain limit, after which it will be limited. </font><font style="vertical-align: inherit;">Let's see how it works. </font><font style="vertical-align: inherit;">So, there are two types of resources - processor and memory. </font><font style="vertical-align: inherit;">The Kubernetes Scheduler uses data from these resources to figure out where to run your pods. </font><font style="vertical-align: inherit;">A typical hearth resource specification looks like this.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/mk/5i/itmk5ipiyoeirubucdzbg8rs0-e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each container in pod can set its own queries and restrictions, all of which are additive. Processor resources are defined in millimeters. If your launch container needs two full cores, you set the value to 2000m. If the container needs power only 1/4 of the core, the value is 250m. Keep in mind that if you assign a processor resource value greater than the number of cores of the largest node, then the launch of your hearth will not be planned at all. A similar situation will happen if you have a sub that needs four cores, and the Kubernetes cluster consists of only two main virtual machines.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unless your application is specifically designed to take advantage of multiple cores (with programs such as complex scientific computing and database operations coming to mind), it‚Äôs best practice to set CPU Requests to 1 or lower and then run more replicas for scalability. Such a solution will give the system greater flexibility and reliability.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When it comes to processor limitations, things get more interesting as it is considered a compressible resource. If your application starts to approach the processor capacity limit, Kubernetes will begin to slow down your container using CPU Throttling - lowering the processor frequency. This means that the processor will be artificially limited, providing the application with potentially worse performance, but the process will not be terminated or handed down.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memory resources are defined in bytes. Usually, the value in the settings is measured in Mib mebytes, but you can specify any value, from bytes to petabytes. Here the situation is the same as with the CPU - if you place a request for an amount of memory exceeding the amount of memory on your nodes, the execution of this pod will not be scheduled. But unlike processor resources, memory is not compressed, because there is no way to limit its use. Therefore, the execution of the container will be stopped as soon as it leaves the limits of the memory allocated to it. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/ot/wx/v0otwxhbugxkjf_wgoxzicvfwoq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to remember that you cannot configure requests that exceed the size of resources that your sites can provide. The characteristics of the shared resources for GKE virtual machines can be found on the links located under this video.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In an ideal world, the default container settings will be enough for workflows to go smoothly. But the real world is not like that, people can easily forget to configure the use of resources or hackers will set requests and restrictions that exceed the real capabilities of the infrastructure. To prevent these scenarios from developing, you can configure ResourceQuota resource quotas and LimitRange restriction ranges. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After you create a namespace, you can block them with quotas. For example, if you have prod and dev namespaces, a template is used in which there are no production quotas at all, and development quotas are very strict. This allows prod in the event of a sharp jump in traffic to take all the available resource for itself, completely blocking dev.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A resource quota may look like this. In this example, there are 4 sections ‚Äî these are the 4 bottom lines of code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h_/op/qe/h_opqel58whmaoilppxkrg3xama.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at each of them. Requests.cpu is the maximum number of combined processor power requests that can come from all namespace containers. In this example, you can have 50 containers with requests of 10m each, five containers with requests of 100m or just one container with a request of 500m. As long as the total number of requests.cpu of this namespace is less than 500m, everything will be fine.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Requested memory requests.memory is the maximum amount of combined memory requests that all containers in the namespace can have. As in the previous case, you can have 50 containers of 2 mib each, five containers of 20 Mib each or a single container with 100 Mib until the total amount of requested memory in the namespace is less than 100 mebibytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Limits.cpu is the maximum combined processor power value that all namespace containers can use. We can assume that this is the limit of processor power requests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, limits.memory is the maximum amount of shared memory that all containers in the namespace can use. This is a limitation of total memory requests.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, by default, containers in a Kubernetes cluster work with unlimited computing resources. Using resource quotas, cluster administrators can limit the consumption of resources and their creation based on the namespace. In the namespace, the pod module or container can consume as much CPU and memory power as the quota of namespace resources determines. However, there is concern that one under or a container may monopolize all available resources. To prevent this situation, the limit range Range Range is used - the policy of restricting the distribution of resources (for pods or containers) in the namespace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The limit range provides limitations that may:</font></font><br>
<br>
<ul>
<li>              ;</li>
<li>       Starage Request   PersistentVolumeClaim   ;</li>
<li>     Request   Limit     ;</li>
<li> Requests/Limits                 .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This way you can create a limit range in your namespace. Unlike the quota that applies to the entire namespace, the Limit Range is used for individual containers. This can prevent users from creating very tiny, or vice versa, giant containers inside the namespace. The Limit Range may look like this. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_9/uy/rn/_9uyrn1sexjxtag8c6mik-ge2ak.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As in the previous case, 4 sections can be distinguished here. Let's take a look at each. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the default section, the default restrictions are set for the container in the hearth. If you specify these values ‚Äã‚Äãin the limit range, then any containers for which these values ‚Äã‚Äãhave not been explicitly set will be guided by the default values.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the default query section, defaultRequest, the default queries for the container in the hearth are configured. Again, if you set these values ‚Äã‚Äãin the limit range, then any containers for which these parameters are not explicitly set will use these values ‚Äã‚Äãby default. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The max section indicates the maximum restrictions that can be set for the container in the hearth. The values ‚Äã‚Äãin the default section and the restrictions for the container cannot be set above this limit. It is important to note that if max is set and the default section is absent, then the maximum value becomes the default value.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The min section indicates the minimum queries that can be set for the container in the hearth. At the same time, the values ‚Äã‚Äãin the default section and requests for the container cannot be set below this limit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again, it is important to note that if this value is set, the default value is not, then the minimum value becomes the default query. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, these resource requests are used by the Kubernetes scheduler to execute your workloads. In order for you to properly configure your containers, it is very important to understand how this works. Suppose you want to run several modules in your cluster. Assuming that the hearth specifications are valid, the Kubernetes schedule will use cyclic balancing to select the node for the workload.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fs/fe/mq/fsfemqkaemlldldxw2avrexegzc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes will check to see if the Node 1 node has enough resources to fulfill pod container requests, and if it does not, it will move on to the next node. If none of the nodes in the system is able to satisfy requests, the pods will go to the Pending state. With Google Kubernetes engine features such as auto-scaling of nodes, GKE can automatically determine the wait state and create some more additional nodes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If subsequently there is an excess capacity of nodes, the auto-scaling function will reduce their number in order to save you money. That's why Kubernetes plans query-based pods. However, the limit may be higher than requests, and in some cases the node may actually run out of resources. We call this state overcommitment state.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/dm/5u/gwdm5u5ol_p3br-onpxzzlq81ou.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I said, if we are talking about a processor, Kubernetes will begin to limit pods. Each pod will receive as much as he requested, but if at the same time he does not reach the limit, then throttling will begin to apply. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As for memory resources, here Kubernetes is forced to make decisions about which pods to delete and which to keep until you free up system resources, otherwise the whole system will crash. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's imagine a scenario in which you have a machine that has run out of memory - how will Kubernetes do this?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes will look for pods that use more resources than requested. So if your containers do not have Requests at all, it means that by default they use more than they requested, simply because they did not ask for anything at all! Such containers become the main candidates for shutdown. The next candidates are containers that have satisfied all their requests, but are still below the maximum limit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So if Kubernetes finds several pods that have exceeded the parameters of their queries, it will sort them by priority, and then delete the lowest priority modules. If all modules have the same priority, Kubernetes will stop those pods that exceed their requests more than the rest of the pods.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In very rare cases, Kubernetes can interrupt the hearths that are still within its scope. </font><font style="vertical-align: inherit;">This can happen when critical system components such as the Kubelet agent or Docker start consuming more resources than was reserved for them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, at the initial stages of small companies, the Kubernetes cluster can work fine without setting resource requests and restrictions, but as your teams and projects begin to grow in size, you run the risk of encountering problems in this area. </font><font style="vertical-align: inherit;">Adding queries and restrictions to your modules and namespaces requires very little extra effort and can save you a lot of hassle. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes best practices. </font><font style="vertical-align: inherit;">Correct Terminate Disable</font></font></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mxEvAPQRwhw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of advertising :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for staying with us. Do you like our articles? Want to see more interesting materials? Support us by placing an order or recommending to your friends </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud-based VPS for developers from $ 4.99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique analog of entry-level servers that was invented by us for you: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The whole truth about VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps from $ 19 or how to divide the server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 times cheaper at the Equinix Tier IV data center in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only we have </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV from $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the Netherlands!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - from $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read about</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to Build Infrastructure Bldg. </font><font style="vertical-align: inherit;">class c using Dell R730xd E5-2650 v4 servers costing 9,000 euros for a penny?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502594/index.html">7 reasons why web projects are not brought to an end, and how to deal with it</a></li>
<li><a href="../en502596/index.html">Free quarantine educational courses: design</a></li>
<li><a href="../en502598/index.html">Security Week 21: Windows Print Service Vulnerability</a></li>
<li><a href="../en502604/index.html">An Introduction to TLS for Patrik Patrick (Part 1)</a></li>
<li><a href="../en502608/index.html">How we started the marketplace of applications in the SaaS service</a></li>
<li><a href="../en502620/index.html">Money accounting</a></li>
<li><a href="../en502624/index.html">How do they work on Facebook? Values ‚Äã‚Äãand hiring in a company</a></li>
<li><a href="../en502626/index.html">Automatic iOS screenshots using XCTestplan and Xcode 11</a></li>
<li><a href="../en502628/index.html">The semantic web myth</a></li>
<li><a href="../en502630/index.html">Mail that you deleted a couple of years ago can still be stored on your smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>