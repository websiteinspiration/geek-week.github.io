<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☮️ 🏇 🀄️ CIを介してSymfony + ReactアプリケーションをAWSにデプロイする ♎️ 👩🏿 💲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは。この記事では、AWSにSymfony 4アプリケーションをデプロイする方法を示します。公式ドキュメントにはそのようなプロセスの例がありますが、私のバージョンはアプリケーションでzipアーカイブをダウンロードするほど簡単ではありません。2019年の庭で、docker modで、マイクロサー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>CIを介してSymfony + ReactアプリケーションをAWSにデプロイする</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462415/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは。この記事では、AWSにSymfony 4アプリケーションをデプロイする方法を示します。</font><font style="vertical-align: inherit;">公式ドキュメントにはそのようなプロセスの例がありますが、私のバージョンはアプリケーションでzipアーカイブをダウンロードするほど簡単ではありません。</font><font style="vertical-align: inherit;">2019年の庭で、docker modで、マイクロサービスアーキテクチャとCI / CDプラクティスがついにDevOpsエンジニアだけでなく、一般の</font><s><font style="vertical-align: inherit;">人間の</font></s><font style="vertical-align: inherit;">ツールにも含まれるようになりました</font></font><s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者。記事をより面白くするために、React.JSにフロントを追加して、より多くの人々のニーズをカバーしました。アプリケーションがEncoreを使用していない場合-それは問題ではありません。Dockerファイルを変更する方法を示します。React.JSのサポートはそれにのみ影響します。誰がこのチュートリアルに興味がありますか？まず第一に、それは彼らの配備慣行を変えたい-通常のカノンから離れてそして彼らのアプリケーションをパックしてイメージをレイアウトするためにDockerを使うことを望んでいるPHP開発者を対象としています。ただし、もう少し詳しく説明すると、CI / CDプラットフォームを介してGitからアプリケーションを自動的にデプロイすることを目的としています（CircleCIが使用されますが、Gitlab構成に興味がある場合は、コメントに書き込んで、添付します）。実際、React / PHPアプリケーションを使用しているか、.NET Coreを使用しているかは、ここでは絶対に重要ではありません。この部分は、開発者がデプロイメント自動化のスキル全般を習得するのに役立ちます。ソースコードは、記事の最後にあるリンクであるgithubリポジトリで入手できます。じゃあ行こう！</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はあなたがあなた自身のsymfonyアプリケーションを持っていることを前提としていますが、デモの目的のために、私はスケッチ以下のパッケージを含む「こんにちは、世界を！」：</font></font><br>
<br>
<code>`symfony/webpack-encore-bundle symfony/form symfony/orm-pack symfony/profiler-pack symfony/security-bundle symfony/twig-bundle symfony/validator symfony/phpunit-bridge`</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-最小限の紳士のセット。現時点では、フォルダー構造は次のようになります。</font></font><br>
<br>
<img width="350" src="https://habrastorage.org/webt/6m/ck/xi/6mckxiczmqlde3nsjhdpzcbforq.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、クラウドインフラストラクチャを構成する必要があります。 AWSの試用期間の登録とアクティブ化には重点を置きません。この段階では、2つのデータベースインスタンスを作成する必要があります。STG（ステージング）の2種類の環境を使用して、新しい「機能」とPROD（本番）の実装を直接「戦闘」としてテストしますサーバ。マネージドサービスデータベースの利点については多くの記事が記述されています。さらに、このガイドでは主に開発者の利便性を追求しているため、RDSを使用し、独自のデータベースサーバーを発生させません。この例のDBMSとして、私はPostgreSQLを使用しました。自分に合ったものを自由に選択し、RDSサービスにアクセスして、必要な容量とボリュームの2つのインスタンスを作成します。 Symfonyの箱から出してすぐにファイルが利用可能です</font></font><code>.env</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、我々はそれのコピーを作成します。例えば、PRODのために、とSTGのために、それを使用します</font></font><code>.env.stg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、それを変更</font></font><code>APP_ENV=dev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>APP_ENV=stg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> </font></font><code>.env.stg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>APP_ENV=dev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>APP_ENV=prod </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> </font></font><code>.env</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、また、作成した各インスタンスのデータベース接続パラメータを入力します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すばらしい、スタートができました！</font><font style="vertical-align: inherit;">ご存知のように、symfonyの依存関係はcomposerを介してインストールされます。それをインストールするには、プロジェクトのルートに配置したcomposer.shファイルを使用します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composer.sh</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">#!/bin/sh<font></font>
<font></font>
EXPECTED_SIGNATURE="$(wget -q -O - https://composer.github.io/installer.sig)"<font></font>
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"<font></font>
ACTUAL_SIGNATURE="$(php -r "echo hash_file('sha384', 'composer-setup.php');")"<font></font>
<font></font>
if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ]<font></font>
then<font></font>
    &gt;&amp;2 echo 'ERROR: Invalid installer signature'<font></font>
    rm composer-setup.php<font></font>
    exit 1<font></font>
fi<font></font>
<font></font>
php composer-setup.php --quiet<font></font>
RESULT=$?<font></font>
rm composer-setup.php<font></font>
exit $RESULT</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はcomposerのソフトウェアインストール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガイド</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、環境ごとに、プロジェクトのルートに独自のDockerfileを作成します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerfile.stg（ステージング）</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">FROM php:7.2.19-apache<font></font>
<font></font>
EXPOSE 80<font></font>
<font></font>
RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite<font></font>
RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini"<font></font>
<font></font>
RUN apt-get update &amp;&amp; apt-get install -y \<font></font>
    wget \<font></font>
    curl \<font></font>
    libfreetype6-dev \<font></font>
    libjpeg62-turbo-dev \<font></font>
    libpng-dev \<font></font>
    libzip-dev \<font></font>
    zip \<font></font>
    libpq-dev \<font></font>
    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \<font></font>
    &amp;&amp; docker-php-ext-configure zip --with-libzip \<font></font>
    &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \<font></font>
    &amp;&amp; docker-php-ext-install -j$(nproc) gd \<font></font>
    &amp;&amp; docker-php-ext-install zip \<font></font>
    &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql<font></font>
<font></font>
WORKDIR /var/www<font></font>
<font></font>
ENV APACHE_DOCUMENT_ROOT /var/www/public<font></font>
RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf<font></font>
RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf<font></font>
RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf<font></font>
<font></font>
COPY ./composer.sh ./<font></font>
RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer<font></font>
<font></font>
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \<font></font>
    &amp;&amp; apt-get install -y nodejs<font></font>
<font></font>
RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \<font></font>
    &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \<font></font>
    &amp;&amp; apt-get update -qq \<font></font>
    &amp;&amp; apt-get install -y yarn<font></font>
<font></font>
COPY ./ ./<font></font>
COPY ./.env.stg ./.env<font></font>
<font></font>
RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerfile（本番）</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">FROM php:7.2.19-apache<font></font>
<font></font>
EXPOSE 80<font></font>
<font></font>
RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite<font></font>
RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini"<font></font>
<font></font>
RUN apt-get update &amp;&amp; apt-get install -y \<font></font>
    wget \<font></font>
    curl \<font></font>
    libfreetype6-dev \<font></font>
    libjpeg62-turbo-dev \<font></font>
    libpng-dev \<font></font>
    libzip-dev \<font></font>
    zip \<font></font>
    libpq-dev \<font></font>
    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \<font></font>
    &amp;&amp; docker-php-ext-configure zip --with-libzip \<font></font>
    &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \<font></font>
    &amp;&amp; docker-php-ext-install -j$(nproc) gd \<font></font>
    &amp;&amp; docker-php-ext-install zip \<font></font>
    &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql<font></font>
<font></font>
WORKDIR /var/www<font></font>
<font></font>
ENV APACHE_DOCUMENT_ROOT /var/www/public<font></font>
RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf<font></font>
RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf<font></font>
RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf<font></font>
<font></font>
COPY ./composer.sh ./<font></font>
RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer<font></font>
<font></font>
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \<font></font>
    &amp;&amp; apt-get install -y nodejs<font></font>
<font></font>
RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \<font></font>
    &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \<font></font>
    &amp;&amp; apt-get update -qq \<font></font>
    &amp;&amp; apt-get install -y yarn<font></font>
<font></font>
COPY ./ ./<font></font>
<font></font>
RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルは「そのまま」使用でき、変更にマクロは使用されません。 Dockerfileの内容を見て、ちょっとした魔法を解きましょう。 「基盤」として、Apache Webサーバーと統合された公式のPHP 7.2.19イメージを使用します（任意の選択肢を自由に使用したり、Nginxでバンドルを構成したりすることができます。この例では、上記の例を最も多く使用しています。便利）。エクスポーズラインは、現時点では重要ではありません。それ自体は何もしませんが、将来的には正しくデプロイする必要があるElasticBeanstalkによって使用されるようになります。次の構成では、メーカーが推奨するPHPに最適化されたプロダクション設定を使用し、Apacheのmod_rewriteをアクティブにして、PHPスクリプトの最大メモリを128から256 mbに増やします。composerが正しく機能するために必要なもの次に、必要なアプリケーション、PHP依存関係、拡張機能をインストールし、すぐに構成します。フォルダー/ var / wwwをアプリケーションの作業ディレクトリに割り当てます-アプリケーションのソースコードがそこにコピーされます。 apacheはデフォルトで/ var / wwwをそのホストのエントリポイントとして使用し、symfonyインデックスファイルは/ var / www / publicにあるので、次の構成としてapacheドキュメントルートを変更します。次に、composer、nodejs、yarnを順次インストールします（アプリケーションでencore / react.jsを使用しない場合、最後の2つのポイントは必要ありません）。最後に、ソースコードをコピーし、symfonyのcomposerとreact.jsのyarnを介して依存関係のインストールを開始します。 STG用の別のDockerfileの意味は、dockerの最後から2番目の命令-.envのコピーにあります。.env内のstg、つまりSTGのイメージ内.env-fileには、この環境に関連するパラメーターが含まれます。ローカルで（もちろん、Dockerがインストールされている状態で）イメージを収集して実行し、アプリケーションが機能しており、この作業に他のものが必要ないことを確認できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">docker build -t tmp:stg -f Dockerfile.stg .<font></font>
docker run -p 80:80 tmp:stg</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STGおよび </font></font><br>
<br>
<pre><code class="plaintext hljs">docker build -t tmp:prod .<font></font>
docker run -p 80:80 tmp:prod</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PROD用。 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EC2を使用したり、ELB / ASGなどを構成したり、ElasticBeanstalkを使用したりできます。ElasticBeanstalkは、利便性の点で私たちへの贈り物にすぎません。 ElasticBeanstalkセクションに移動し、名前と説明を使用して新しいアプリケーションを作成します。次に、前述の2つの環境を作成します。STGとPROD、両方の環境をWebサーバー環境として作成し、プラットフォームとして「Docker」を指定して、サンプルアプリケーションをアプリケーションコードのままにします。 ElasticBeanstalkへのデプロイは、通常はzipアーカイブでプロジェクトファイルまたは手順をアップロードすることによって行われます。私たちの場合、フローは次のようになります。アプリケーションのdockerイメージを収集してリポジトリにアップロードし、ソースアーカイブまたはdockerイメージの代わりに命令をロードします。これにより、ElasticBeanstalkにリモートサーバーからイメージを取得してデプロイするように指示します。そして、これはすべて自動です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dockerイメージを格納するためのリポジトリを作成することから始めましょう。 2つのオプションがあります。1- </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プライベートプロジェクトがあり、そのコードが閉じており、リポジトリもそれぞれ閉じている必要があります。この場合、画像の独自の登録をどこかに保持するか、プライベートクラウドを使用します。 AWSにはこれらの目的のためのECRがあり、そこでリポジトリを作成できますが、これを強制する人は誰もいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-オープンソースプロジェクトがあり、dockerhubを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例ではコードは開いていますが、閉じたリポジトリの使用方法を示します。このプロセスを理解した後、dockerhubからのイメージの接続は難しくありません。最初に必要なのは、リポジトリ自体を作成することです。その後、その一意のURIを取得します。 （ナレーションはAWS ECRリポジトリとその統合ではなく）サードパーティ向けです。その後、ECRについて書きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリを作成したら、このサービスにログインする必要があります。ちょっとしたトリックがあります...ローカルにインストールされたDockerの設定に移動し、外部ストレージにパスワードを保存するオプションがあることを確認します（macOSユーザーの場合：Dockerログインを安全に保存しますmacOSキーチェーン”）で、それ以外の場合、必要な構成ファイルは空になります。</font><font style="vertical-align: inherit;">そして、私たちはあなたの画像のレジスタを保存するために選択されたサービスを承認します：</font></font><br>
<br>
<pre><code class="plaintext hljs">docker login -u LOGIN -p PASSWORD REGISTRY</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
認証が成功すると、次の構成が〜/ .docker / config.json構成ファイルに表示されます。</font></font><br>
<br>
<pre><code class="json hljs"><span class="hljs-string">"REGISTRY"</span> : {
      <span class="hljs-attr">"auth"</span> : <span class="hljs-string">"BASE64_ENCODED_TOKEN"</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示されない場合は、上記のdocker設定を再確認してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ElasticBeanstalkのインストラクションファイルを準備する準備がすべて整いました-Dockerrun.aws.jsonのコードは次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerrun.aws.json</font></font></b><div class="spoiler_text"><pre><code class="json hljs">{
  <span class="hljs-attr">"AWSEBDockerrunVersion"</span>: <span class="hljs-string">"1"</span>,
  <span class="hljs-attr">"Authentication"</span>: {
    <span class="hljs-attr">"Bucket"</span>: <span class="hljs-string">"BUCKET_ID"</span>,
    <span class="hljs-attr">"Key"</span>: <span class="hljs-string">"KEY_PATH"</span><font></font>
  },<font></font>
  <span class="hljs-attr">"Image"</span>: {
    <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"IMAGE_URL"</span>,
    <span class="hljs-attr">"Update"</span>: <span class="hljs-string">"true"</span><font></font>
  },<font></font>
  <span class="hljs-attr">"Ports"</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">"ContainerPort"</span>: <span class="hljs-string">"80"</span><font></font>
    }<font></font>
  ]<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、手順は次のようになります。S3ストレージのBUCKET_IDのKEY_PATHにあるキーを使用してログインし、IMAGE_URLでイメージをロードして保存したイメージを上書きし、ポート80をコンテナの同じポートに転送することで開始します。</font><font style="vertical-align: inherit;">次に、使用される定数について説明します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。BUCKET_IDは、S3サービスで自動的に作成される「バックパック」であり、elasticbeanstalk-REGION-HASHの形式を持っています。これは、システムがElasticBeanstalkのサービスファイルを見つける場所です。アップロードしてデプロイします。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KEY_PATH-イメージリポジトリへの認証ファイルへのパス。APP_NAME/ cr.json形式を使用します。つまり、アプリケーション名の下のBUCKET_ID内のフォルダーにあります（まだ作成していない場合は作成します）認証後に受け取ったコードを含むcr.jsonファイルをレジスターに入れます。ローカルの画像：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUCKET_ID / APP_NAME / cr.json</font></font></b><div class="spoiler_text"><pre><code class="json hljs">{
    <span class="hljs-attr">"REGISTRY"</span> : {
        <span class="hljs-attr">"auth"</span> : <span class="hljs-string">"BASE64_ENCODED_TOKEN"</span><font></font>
    }<font></font>
}</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IMAGE_URLは、イメージレジスタの一意のURI +イメージ自体のタグです。すべてがここで明確になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以上で、ElasticBeanstalkでアプリケーションのバージョンとしてこのファイルをダウンロードできるようになりました。彼は指定されたイメージをプルアップしてデプロイします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスを自動化する必要があります。</font><font style="vertical-align: inherit;">そして、興味深いことに、次のフローの一連のステップを実装します。マスターブランチではないすべてのコミットについて、イメージが収集され、STG環境にデプロイされます。マスターにプッシュするか、それ以上の場合は、マスターを閉じて、マージリクエストで埋めます。の場合、コードはPRODにデプロイされます。</font><font style="vertical-align: inherit;">したがって、PRODにはすべてが正常に動作する最新のウィザードと、STGで新しいコードを開発およびテストするための分岐が含まれています。</font><font style="vertical-align: inherit;">この実装では、最新のイメージではなくアップロードの手順、Dockerrun.aws.jsonをDockerrun.aws.stg.jsonにコピー、Dockerrun.aws.jsonの名前をDockerrun.aws.prod.jsonに（便宜上）変更する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dockerrun.aws.prod.jsonとは別にDockerrun.aws.stg.jsonを設定する唯一のものはIMAGE_URLです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerrun.aws.stg.json</font></font></b><div class="spoiler_text"><pre><code class="json hljs">{
  <span class="hljs-attr">"AWSEBDockerrunVersion"</span>: <span class="hljs-string">"1"</span>,
  <span class="hljs-attr">"Authentication"</span>: {
    <span class="hljs-attr">"Bucket"</span>: <span class="hljs-string">"BUCKET_ID"</span>,
    <span class="hljs-attr">"Key"</span>: <span class="hljs-string">"KEY_PATH"</span><font></font>
  },<font></font>
  <span class="hljs-attr">"Image"</span>: {
    <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"IMAGE_URL:dev"</span>,
    <span class="hljs-attr">"Update"</span>: <span class="hljs-string">"true"</span><font></font>
  },<font></font>
  <span class="hljs-attr">"Ports"</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">"ContainerPort"</span>: <span class="hljs-string">"80"</span><font></font>
    }<font></font>
  ]<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の冒頭で述べたように、私はCI / CDとしてCircleCIを使用します。これは、私の個人的な感情によると、無料のSaaSバージョンを使用する場合、GitlabCIよりも高速です。</font><font style="vertical-align: inherit;">Free Travisは機能しますが、プライベートgitリポジトリでは機能しないため、そのような機会が必要になったときに失望しないように、具体的にデモを実行しませんでした。</font><font style="vertical-align: inherit;">読者が自分で学習できるように、プロジェクトの設定をCircleCIに残します。展開に必要な指示を自分で行います。プロジェクトのルートで、.circleciフォルダーを作成し、それにconfig.ymlと次の内容を含めます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.circleci / config.yml</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">version: 2<font></font>
jobs:<font></font>
  build:<font></font>
    machine: true<font></font>
    steps:<font></font>
      - checkout<font></font>
      - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY<font></font>
      - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg .<font></font>
      - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev<font></font>
<font></font>
  build-master:<font></font>
    machine: true<font></font>
    steps:<font></font>
      - checkout<font></font>
      - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY<font></font>
      - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest .<font></font>
      - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest<font></font>
<font></font>
  deploy-stg:<font></font>
    docker:<font></font>
      - image: circleci/python:latest<font></font>
    steps:<font></font>
      - checkout<font></font>
      - run: sudo pip install awsebcli --upgrade<font></font>
      - run: |<font></font>
          mkdir ~/.aws<font></font>
          touch ~/.aws/config<font></font>
          chmod 600 ~/.aws/config<font></font>
          echo "[profile eb-cli]" &gt; ~/.aws/config<font></font>
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config<font></font>
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config<font></font>
      - run: eb init --region EB_REGION --platform Docker EB_APP<font></font>
      - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json<font></font>
      - run: eb use EB_ENV_STG --region EB_REGION<font></font>
      - run: eb deploy -v --staged --profile eb-cli<font></font>
<font></font>
  deploy-prod:<font></font>
    docker:<font></font>
      - image: circleci/python:latest<font></font>
    steps:<font></font>
      - checkout<font></font>
      - run: sudo pip install awsebcli --upgrade<font></font>
      - run: |<font></font>
          mkdir ~/.aws<font></font>
          touch ~/.aws/config<font></font>
          chmod 600 ~/.aws/config<font></font>
          echo "[profile eb-cli]" &gt; ~/.aws/config<font></font>
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config<font></font>
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config<font></font>
      - run: eb init --region EB_REGION --platform Docker EB_APP<font></font>
      - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json<font></font>
      - run: eb use EB_ENV_STG --region EB_REGION<font></font>
      - run: eb deploy -v --staged --profile eb-cli<font></font>
<font></font>
workflows:<font></font>
  version: 2<font></font>
  build:<font></font>
    jobs:<font></font>
      - build:<font></font>
          filters:<font></font>
            branches:<font></font>
              ignore:<font></font>
                - master<font></font>
      - deploy-stg:<font></font>
          requires:<font></font>
            - build<font></font>
          filters:<font></font>
            branches:<font></font>
              ignore:<font></font>
                - master<font></font>
<font></font>
  build-deploy:<font></font>
    jobs:<font></font>
      - build-master:<font></font>
          filters:<font></font>
            branches:<font></font>
              only:<font></font>
                - master<font></font>
      - deploy-prod:<font></font>
          requires:<font></font>
            - build-master<font></font>
          filters:<font></font>
            branches:<font></font>
              only:<font></font>
                - master<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロー自体を少し前に描きました。ここでは、CircleCIのyaml命令に翻訳されています。具体的な手順の実装を見てみましょう。彼らは自分の仕事中に使用することCIのための環境固有の変数の存在を注意することが重要、それを次のとおりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CI_REGISTRY、CI_REGISTRY_USER、CI_REGISTRY_PASSWORDは、ドッキングウィンドウの画像記憶のアクセスに必要とされている-私たちはcr.jsonに入れていることと同じこと、base64でのみなし</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CI_REGISTRY / CI_REGISTRY_IDを作りますタグなしの画像URL</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AWS_ACCESS_KEY_IDおよびAWS_SECRET_ACCESS_KEY-名前はそれ自体が意味します。これらは、CircleCIがデプロイするユーザーに代わってユーザーのAWSクレジットです。</font><font style="vertical-align: inherit;">AWS IAMに移動してユーザーを作成し、管理者グループに追加して、プログラムによるアクセスのみを提供します。</font><font style="vertical-align: inherit;">AWS_SECRET_ACCESS_KEYは1回だけ表示/コピーに使用できることに注意してください。[表示]リンクをクリックすると、再び表示されることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CircleCIの構成手順に戻ります。</font><font style="vertical-align: inherit;">魔法とは何ですか？</font><font style="vertical-align: inherit;">チェックアウトはgitブランチから現在の作業ディレクトリにソースコードをロードします。このプロセスはすべてのジョブで繰り返されます。</font><font style="vertical-align: inherit;">ビルドプロセスでは、リポジトリに順次ログインし、Dockerfile.stgに基づいてXXX：devタグの下でコードを収集し、リポジトリに送信します。</font><font style="vertical-align: inherit;">build-masterも同じことを行います。ビルドの場合のみ、タグXXX：latestの下で「通常の」Dockerfileを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
deploy-stgはAWS EB CLIをインストールし、CLIが正しく機能するために必要な〜/ .aws / configファイルに承認プロファイルを作成してから、CLIの変数を初期化します。選択するリージョン、プラットフォーム、常にDockerとアプリケーションの名前を指定する必要があります。次に、Dockerrun.aws.stg.jsonの内容を新しいDockerrun.aws.jsonファイルにコピーし、特定の環境とリージョンを使用して、作成した承認プロファイルを使用してアプリケーションをデプロイするコマンドを提供します。デフォルトでは、このコマンドの結果として、監視対象ブランチのすべてのコードは最終的にzipアーカイブになり、ElasticBeanstalkにダウンロードされてそこに解凍されますが、この操作は比較的コストがかかるため、新しいDockerrun.aws.jsonファイルを作成しました。リモート画像、そして実際にそれをアップロードする必要があるだけです。これを行うには、プロジェクトルートに.ebignoreファイルを作成します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.ebignore</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">*<font></font>
!Dockerrun.aws.json<font></font>
 </code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このファイルは構文.gitignoreを使用します。これは.gitignoreですが、Git CLIではなくAWS EB CLIです。</font><font style="vertical-align: inherit;">このファイルでは、Dockerrun.aws.json以外のすべてのファイルをスキップするようにCLIに指示しています。</font><font style="vertical-align: inherit;">以上で、ElasticBeanstalkでdeploy-stgジョブを実行すると、作成したファイルのみが送信されます。</font><font style="vertical-align: inherit;">deploy-prodは同じことを行い、Dockerrun.aws.prod.jsonファイルの内容をDockerrun.aws.jsonにコピーするだけです。最後の1つは、CircleCI形式での作業のシーケンスを示します（ビルド後のdeploy-stgおよびビルド後のdeploy-prod -master）、およびデータが探しているブランチ（無視：-マスターおよび唯一：-マスター）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AWS ECRではケースが少し異なります。私が約束したとおり、話を戻しましょう。</font><font style="vertical-align: inherit;">ElasticBeanstalkは「兄弟を直接知っている」ため、リモートでECRにログインしてcr.jsonファイルを作成する必要はありません。</font><font style="vertical-align: inherit;">したがって、Dockerrun.aws.jsonは異なって見えます-単に認証ブロックはありません：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerrun.aws.json（AWS ECR）</font></font></b><div class="spoiler_text"><pre><code class="json hljs">{
  <span class="hljs-attr">"AWSEBDockerrunVersion"</span>: <span class="hljs-string">"1"</span>,
  <span class="hljs-attr">"Image"</span>: {
    <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"IMAGE_URL"</span>,
    <span class="hljs-attr">"Update"</span>: <span class="hljs-string">"true"</span><font></font>
  },<font></font>
  <span class="hljs-attr">"Ports"</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">"ContainerPort"</span>: <span class="hljs-string">"80"</span><font></font>
    }<font></font>
  ]<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、どのようにして認証が行われるのでしょうか？実際には、ECRにアクセスするサービスには、特定のセキュリティポリシーに基づく特定の権限セットがあります。私たちのケースでは、デプロイがAWS CLI経由で（CIから）サードパーティのサーバーから起動されると、「aws-elasticbeanstalk-ec2-role」ロールが使用され、AWS IAMのロールセクションで見つけて、追加のポリシー「AmazonEC2ContainerRegistryReadOnly」をそれにアタッチします。これで、プライベートリポジトリから「ネイバー」へのダウンロードがエラーなしで成功します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは同じVPCから正確にロードされ、CLIを介してdocker loginコマンドも「トリックなし」ではありません。AWSCLIを介して（確かに）dockersログインを受信する必要があります。これにはコマンドがあります</font></font><br>
<br>
<code>aws ecr get-login --region REGION --no-include-email</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコマンドは、docker login ...という形式の行を返します。つまり、</font></font><br>
<br>
<code>eval $(aws ecr get-login --region EB_REGION --no-include-email) </code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンド</font><font style="vertical-align: inherit;">を実行する必要があるコンソールで、</font><font style="vertical-align: inherit;">最初に認証用の文字列を受け取り、対応するプロセスを開始します。</font><font style="vertical-align: inherit;">AWS ECRのこれらのルールを考慮すると、CircleCIの指示ファイルは次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.circleci / config.yml（AWS ECRの場合）</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">version: 2<font></font>
jobs:<font></font>
  build:<font></font>
    docker:<font></font>
      - image: circleci/python:latest<font></font>
    steps: <font></font>
      - checkout<font></font>
      - run: sudo pip install awscli --upgrade<font></font>
      - run: |<font></font>
          mkdir ~/.aws<font></font>
          touch ~/.aws/config<font></font>
          chmod 600 ~/.aws/config<font></font>
          echo "[profile eb-cli]" &gt; ~/.aws/config<font></font>
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config<font></font>
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config<font></font>
      - setup_remote_docker<font></font>
      - run: eval $(aws ecr get-login --region EB_REGION --no-include-email)      <font></font>
      - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg .<font></font>
      - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev<font></font>
<font></font>
  build-master:<font></font>
    docker:<font></font>
      - image: circleci/python:latest<font></font>
    steps: <font></font>
      - checkout<font></font>
      - run: sudo pip install awscli --upgrade<font></font>
      - run: |<font></font>
          mkdir ~/.aws<font></font>
          touch ~/.aws/config<font></font>
          chmod 600 ~/.aws/config<font></font>
          echo "[profile eb-cli]" &gt; ~/.aws/config<font></font>
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config<font></font>
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config<font></font>
      - setup_remote_docker<font></font>
      - run: eval $(aws ecr get-login --region EB_REGION --no-include-email)      <font></font>
      - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest .<font></font>
      - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest<font></font>
<font></font>
  deploy-stg:<font></font>
    docker:<font></font>
      - image: circleci/python:latest<font></font>
    steps:<font></font>
      - checkout<font></font>
      - run: sudo pip install awsebcli --upgrade<font></font>
      - run: |<font></font>
          mkdir ~/.aws<font></font>
          touch ~/.aws/config<font></font>
          chmod 600 ~/.aws/config<font></font>
          echo "[profile eb-cli]" &gt; ~/.aws/config<font></font>
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config<font></font>
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config<font></font>
      - run: eb init --region EB_REGION --platform Docker EB_APP<font></font>
      - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json<font></font>
      - run: eb use EB_ENV_STG --region EB_REGION<font></font>
      - run: eb deploy -v --staged --profile eb-cli<font></font>
<font></font>
  deploy-prod:<font></font>
    docker:<font></font>
      - image: circleci/python:latest<font></font>
    steps:<font></font>
      - checkout<font></font>
      - run: sudo pip install awsebcli --upgrade<font></font>
      - run: |<font></font>
          mkdir ~/.aws<font></font>
          touch ~/.aws/config<font></font>
          chmod 600 ~/.aws/config<font></font>
          echo "[profile eb-cli]" &gt; ~/.aws/config<font></font>
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config<font></font>
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config<font></font>
      - run: eb init --region EB_REGION --platform Docker EB_APP<font></font>
      - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json<font></font>
      - run: eb use EB_ENV_STG --region EB_REGION<font></font>
      - run: eb deploy -v --staged --profile eb-cli<font></font>
<font></font>
workflows:<font></font>
  version: 2<font></font>
  build:<font></font>
    jobs:<font></font>
      - build:<font></font>
          filters:<font></font>
            branches:<font></font>
              ignore:<font></font>
                - master<font></font>
      - deploy-stg:<font></font>
          requires:<font></font>
            - build<font></font>
          filters:<font></font>
            branches:<font></font>
              ignore:<font></font>
                - master<font></font>
<font></font>
  build-deploy:<font></font>
    jobs:<font></font>
      - build-master:<font></font>
          filters:<font></font>
            branches:<font></font>
              only:<font></font>
                - master<font></font>
      - deploy-prod:<font></font>
          requires:<font></font>
            - build-master<font></font>
          filters:<font></font>
            branches:<font></font>
              only:<font></font>
                - master<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker-in-dockerをサポートするために、アセンブリー段階でsetup_remote_dockerを追加しました。この記事の内容から、残りの部分をすでに理解しているはずです。</font><font style="vertical-align: inherit;">以上で、プロジェクトの構造は次のようになります。</font></font><br>
<br>
<img width="350" src="https://habrastorage.org/webt/7e/cw/sj/7ecwsjkjjmr8myxiuutwkujwnkg.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを変更してタスクブランチにプッシュし、マスターにマージ（プル）リクエストを送信して受け入れます。</font><font style="vertical-align: inherit;">更新を投稿する「移動」はもうありません。</font><font style="vertical-align: inherit;">さらに進んで、ローリングマイグレーション用の独自のジョブデスクを作成し、自動テストに合格するための中間必須手順を実行するなどが可能です。この記事が、このような実験と、その後の高品質で適切なコンテンツ配信の実装の基礎となることを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHubソースコード：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial-aws-symfony-ci</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462401/index.html">開発者の大罪</a></li>
<li><a href="../ja462403/index.html">Выбор размера монитора: теория угловых размеров, обоснование и сравнение</a></li>
<li><a href="../ja462407/index.html">フードデザインダイジェスト2019年7月</a></li>
<li><a href="../ja462409/index.html">AVRマイクロコントローラー用のアセンブラーコードジェネレーターライブラリ。パート1</a></li>
<li><a href="../ja462411/index.html">アルゴリズムXで数独を解く</a></li>
<li><a href="../ja462417/index.html">アップルの請願</a></li>
<li><a href="../ja462421/index.html">アポロガイダンスコンピューター-アーキテクチャおよびシステムソフトウェア。パート2</a></li>
<li><a href="../ja462423/index.html">プロジェクト管理</a></li>
<li><a href="../ja462429/index.html">VueJs + VueRouter +モーダル。別の自転車</a></li>
<li><a href="../ja462431/index.html">モバイル開発者向けの興味深い資料の要約＃309（7月29日-8月4日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>