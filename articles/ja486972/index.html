<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💹 👨‍👩‍👦 🚉 導関数を見つける例を使用したC＃の式ツリー（式ツリービジターvsパターンマッチング） 💆🏼 ☄️ 🤜🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="良い一日。式ツリーは、特にVisitorパターンと組み合わせると、常にややこしいトピックでした。したがって、このトピックに関する情報が多様であるほど、例が多いほど、興味のある人にとって、明確で有用な何かを見つけやすくなります。
 
 
 
 記事は通常どおりに作成されています-概念的なフレームワーク...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>導関数を見つける例を使用したC＃の式ツリー（式ツリービジターvsパターンマッチング）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486972/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良い一日。</font><font style="vertical-align: inherit;">式ツリーは、特にVisitorパターンと組み合わせると、常にややこしいトピックでした。</font><font style="vertical-align: inherit;">したがって、このトピックに関する情報が多様であるほど、例が多いほど、興味のある人にとって、明確で有用な何かを見つけやすくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/6c/bf/xt6cbf1-gfkv4-64zs250n_-7pa.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事は通常どおりに作成されています-概念的なフレームワークと定義から始まり、例と使用方法で終わります。</font><font style="vertical-align: inherit;">以下の目次。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式ツリーの基本式ツリーの</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文式</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンマッチング</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なビジター</font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラシックビジター</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さて、目標は特定のソリューションを課したり、一方が他方よりも優れていると言ったりすることではありません。</font><font style="vertical-align: inherit;">私はあなたのケースのすべてのニュアンスを考慮して、自分で結論を出すことを提案します。</font><font style="vertical-align: inherit;">私の例について私の意見を述べます。</font></font><br>
<br>
<a name="basic"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式ツリー</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基礎</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、式ツリーを処理する必要があります。これらは、式のタイプまたはその相続人のいずれかを意味します（これらについては後で説明します）。通常のシナリオでは、式/アルゴリズムは、ユーザーが実行（主に実行）する必要のない実行可能コード/命令の形式で提示されます。式タイプを使用すると、式/アルゴリズム（通常はラムダですが、必須ではありません）を、ユーザーがアクセスできるツリー構造に編成されたデータとして表すことができます。アルゴリズムに関する情報を整理するツリーのような方法とクラスの名前は、「式ツリー」を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、簡単な例を分析します。ラムダ</font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x）=&gt; Console.WriteLine（x + 5）</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
があるとします。これは次のツリーとして表すことができます</font></font><br>
<br>
<div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/yv/wy/sq/yvwysqugbtttw-gvz07tipuq-oy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーのルートは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodCall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の最上位で</font><font style="vertical-align: inherit;">あり、メソッドのパラメーターも式であるため、子をいくつでも持つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、子孫は1つだけです-「</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArithmeticOperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の</font><font style="vertical-align: inherit;">ピークです</font><font style="vertical-align: inherit;">。これには、演算の種類に関する情報が含まれており、左と右のオペランドも式です。このような頂点には常に2つの子孫があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペランドは、定数（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）およびパラメーター（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">表され</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。そのような表現には子孫がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは非常に単純化された例ですが、本質を完全に反映しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式ツリーの主な特徴は、それらを解析して、アルゴリズムの実行内容について必要なすべての情報を読み取ることができることです。ある観点から見ると、これは属性の反対です。属性は、動作を宣言的に説明する手段です（非常に条件付きですが、最終的な目標はほぼ同じです）。式ツリーは関数/アルゴリズムを使用してデータを記述しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、</font><font style="vertical-align: inherit;">エンティティフレームワーク</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロバイダー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で使用され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。アプリケーションは明らかです。式のツリーを解析し、そこで実行する必要があるものを理解し、この記述から</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。あまり知られていない例は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mokingのmoq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリーです</font><font style="vertical-align: inherit;">。式ツリーは</font><i><font style="vertical-align: inherit;">DLR</font></i><font style="vertical-align: inherit;">でも使用され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（動的言語ランタイム）。</font><font style="vertical-align: inherit;">コンパイラ開発者は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSIL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を生成する代わりに、これらを使用して動的な性質とドットネット間の互換性を保証し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、式ツリーは不変であることにも言及する価値があります。</font></font><br>
<a name="syn"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に説明する価値があるのは構文です。</font><font style="vertical-align: inherit;">主な方法は2つあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressionクラスの静的メソッドによる式ツリーの作成</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressionでコンパイルされたラムダ式の使用</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式クラスの静的メソッド</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expressionクラスの静的メソッドを使用して式ツリーを作成することはあまり一般的ではありません（特にユーザーの観点から）。これは厄介ですが、非常に単純</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。基本的なレンガがたくさんあり、そこから非常に複雑な</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ものを</font><font style="vertical-align: inherit;">構築できます</font><font style="vertical-align: inherit;">。作成は静的メソッドを介して行われます式コンストラクタには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修飾子があり</font><font style="vertical-align: inherit;">ます。そして、これは反射を明らかにする必要があるという意味ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、上の例から式を作成します：</font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x）=&gt; Console.WriteLine（x + 5）</font></font></i></b><br>
<br>
<pre><code class="cs hljs">ParameterExpression parameter = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
ConstantExpression constant = Expression.Constant(<span class="hljs-number">5</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
BinaryExpression <span class="hljs-keyword">add</span> = Expression.Add(parameter, constant);<font></font>
MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });<font></font>
MethodCallExpression methodCall = Expression.Call(<span class="hljs-literal">null</span>, writeLine, <span class="hljs-keyword">add</span>);<font></font>
Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; expressionlambda = Expression.Lambda&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt;(methodCall, parameter);<font></font>
Action&lt;<span class="hljs-keyword">double</span>&gt; delegateLambda = expressionlambda.Compile();<font></font>
delegateLambda(<span class="hljs-number">123321</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはあまり便利な方法ではないかもしれませんが、式ツリーの内部構造を完全に反映しています。</font><font style="vertical-align: inherit;">さらに、このメソッドは、ループ、条件、try-catch、goto、代入、フォールトブロックでの終了、ブレークポイントのデバッグ情報、動的など、式ツリーで使用できるより多くの機能を提供します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラムダ式</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式としてラムダを使用する方が頻繁な方法です。</font><font style="vertical-align: inherit;">これは非常に簡単に機能します。コンパイル段階のスマートコンパイラは、ラムダが何に使用されているかを調べます。</font><font style="vertical-align: inherit;">そして、それをデリゲートまたは式にコンパイルします。</font><font style="vertical-align: inherit;">すでに習得した例では、次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs">Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; write =  =&gt; Console.WriteLine( + <span class="hljs-number">5</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなことを明確にすることは価値があります-式は徹底的な説明です。</font><font style="vertical-align: inherit;">そして</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、結果</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">得る</font><font style="vertical-align: inherit;">にはそれで十分</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">LambdaExpressionまたはその子孫などの式ツリーは</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、実行可能なILに変換</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">残りの型を実行可能コードに直接変換することはできません（ただし、これはあまり意味がありません）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、誰かが式の高速コンパイルを批判している場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サードパーティプロジェクトをご覧ください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースでは、その逆は当てはまりません。</font><font style="vertical-align: inherit;">デリゲートは、それを拾い上げて表現として自己紹介することはできません（ただし、これはまだ可能です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのラムダを式ツリーに変換できるわけではありません。</font><font style="vertical-align: inherit;">これらには以下が含まれます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代入演算子を含む</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダイナミックな貢献</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボディ付き（ブレース）</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">double</span> variable;
<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">dynamic</span>;<font></font>
Expression&lt;Action&gt; assignment = () =&gt; variable = <span class="hljs-number">5</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain an assignment operator</span>
Expression&lt;Func&lt;<span class="hljs-keyword">double</span>&gt;&gt; dynamically = () =&gt; <span class="hljs-keyword">dynamic</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain a dynamic operation</span>
Expression&lt;Func&lt;Task&gt;&gt; asynchon = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> Task.CompletedTask; <span class="hljs-comment">//Compiler error: Async lambda cannot be converted to expresiion trees</span>
Expression&lt;Action&gt; body = () =&gt; { }; <span class="hljs-comment">//Compiler error: A lambda expression with a statement body cannot be converted to an expression tree</span>
</code></pre> <br>
<a name="types"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式のタイプ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちがどんな機会を持っているかを表すために利用可能なタイプを簡単に見てみることを提案します。</font><font style="vertical-align: inherit;">これらはすべて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Linq.Expressions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前空間にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、いくつかの本当に興味深い、珍しい機能について</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">理解する</font></a><font style="vertical-align: inherit;">ことをお勧めします。</font><font style="vertical-align: inherit;">簡単な説明付きでタブレットにまとめた、より単純なタイプの表現。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DynamicExpressionを使用すると、式ツリーで動的およびそのすべての機能を使用できます。</font><font style="vertical-align: inherit;">ややこしいAPIがあり、他のすべての組み合わせよりもこの例に長く座っていました。</font><font style="vertical-align: inherit;">すべての混乱は、さまざまなフラグの束によって提供されます。</font><font style="vertical-align: inherit;">そしてそれらのいくつかはあなたが探しているものと似ていますが、必ずしもそうではありません。</font><font style="vertical-align: inherit;">また、式ツリーで動的を使用すると、会話エラーが発生しにくくなります。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> parameter1 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name1"</span>);
<span class="hljs-keyword">var</span> parameter2 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name2"</span>); 
<span class="hljs-keyword">var</span> dynamicParam1 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);
<span class="hljs-keyword">var</span> dynamicParam2 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);<font></font>
CallSiteBinder csb = Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Add, <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-keyword">new</span>[] { dynamicParam1, dynamicParam2 });
<span class="hljs-keyword">var</span> dyno = Expression.Dynamic(csb, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), parameter1, parameter2);<font></font>
Expression&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt;(dyno, <span class="hljs-keyword">new</span>[] { parameter1, parameter2 });<font></font>
Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt; action = expr.Compile();
<span class="hljs-keyword">var</span> res = action(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//12</span>
res = action(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//3</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
System.Reflectionからのバインダーとの混乱を避けるために、バインダーがどこから来たのかを明示しました。</font><font style="vertical-align: inherit;">興味深いことに、refおよびoutパラメータ、名前付きパラメータ、単項演算、そして原則として、ダイナミックを通じて実行できるすべてのことを実行できますが、これにはある程度のスキルが必要です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外キャッチブロック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に注意するのは、try / catch / finally / fault機能、つまり</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、faultブロックにアクセスできる</font><font style="vertical-align: inherit;">という事実</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">C＃では使用できませんが、MSILで使用できます。これは、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外が発生した場合に実行される、最終的に</font><font style="vertical-align: inherit;">は一種の</font><font style="vertical-align: inherit;">アナログです。</font><font style="vertical-align: inherit;">以下の例では、例外がスローされ、その後「Hi」が表示され、プログラムは入力を待機します。</font><font style="vertical-align: inherit;">その後、それは完全に落ちます。</font><font style="vertical-align: inherit;">この方法を使用することはお勧めしません。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> throwSmth = Expression.Throw(Expression.Constant(<span class="hljs-keyword">new</span> Exception(), <span class="hljs-keyword">typeof</span>(Exception)));
<span class="hljs-keyword">var</span> log = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>) }), Expression.Constant(<span class="hljs-string">"Hi"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>)));
<span class="hljs-keyword">var</span> read = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.ReadLine)));
<span class="hljs-keyword">var</span> fault = Expression.TryFault(throwSmth, Expression.Block(<span class="hljs-keyword">new</span>[] { log, read }));<font></font>
Expression&lt;Action&gt; expr = Expression.Lambda&lt;Action&gt;(fault);<font></font>
Action compiledExpression = expr.Compile();<font></font>
compiledExpression();<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用可能な式ツリータイプの簡単な説明</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な説明</font></font></th>
</tr>
<tr>
<td colspan="2" align="center"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メイン</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表情</font></font></td>
<td> ,      .     ,      </td>
</tr>
<tr>
<td>Expression&lt;TDelegate&gt;</td>
<td>    </td>
</tr>
<tr>
<td colspan="2" align="center"><b> </b></td>
</tr>
<tr>
<td>BinaryExpression</td>
<td>     (+, —  )</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td> (+, -),    throw</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td> —   </td>
</tr>
<tr>
<td>ParameterExpression</td>
<td> </td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>  ,  MethodInfo</td>
</tr>
<tr>
<td>IndexExpression</td>
<td></td>
</tr>
<tr>
<td>BlockExpression</td>
<td>,   .      </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  </b></td>
</tr>
<tr>
<td>ConditionalExpression </td>
<td>   — if-else</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>   goto</td>
</tr>
<tr>
<td>LabelExpression</td>
<td> ,            .    LabelTarget.    ,    GotoExpression,    —   .    void,    .</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>  .    . ( .. «break»)</td>
</tr>
<tr>
<td>LoopExpression</td>
<td> ,    «break»</td>
</tr>
<tr>
<td>SwitchCase</td>
<td>    SwitchExpression</td>
</tr>
<tr>
<td>SwitchExpression</td>
<td>  switch/case</td>
</tr>
<tr>
<td>TryExpression</td>
<td>    try/catch/finally/fault </td>
</tr>
<tr>
<td>CatchBlock</td>
<td>,   ,    </td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>ElementInit</td>
<td>    IEnumerable.   ListInitExpression</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>  +   </td>
</tr>
<tr>
<td>DefaultExpression</td>
<td>       </td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>   +  </td>
</tr>
<tr>
<td>NewExpression</td>
<td> </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  /</b></td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>    </td>
</tr>
<tr>
<td>MemberBinding</td>
<td>  ,    ,  ,        </td>
</tr>
<tr>
<td>MemberExpression</td>
<td>  /</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>      </td>
</tr>
<tr>
<td>MemberListBinding</td>
<td> /  </td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td> / ,    /</td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>LambdaExpression</td>
<td></td>
</tr>
<tr>
<td>InvocationExpression</td>
<td>   -    </td>
</tr>
<tr>
<td>DebugInfoExpression</td>
<td>       .         </td>
</tr>
<tr>
<td>SymbolDocumentInfo</td>
<td>       ,        .</td>
</tr>
<tr>
<td>DynamicExpression</td>
<td>   ( )</td>
</tr>
<tr>
<td>RuntimeVariablesExpression</td>
<td>   /    </td>
</tr>
<tr>
<td>TypeBinaryExpression</td>
<td>,      (is)</td>
</tr>
</tbody></table></div><br>
      <br>
<br>
<ul>
<li>ExpressionVisitor —     .  .</li>
<li>DynamicExpressionVisitor —      DynamicExpression ( VisitDynamic)</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報は、式ツリーの操作方法の比較を開始するのに十分です。</font><font style="vertical-align: inherit;">私は、導関数を見つける例を使用して、これらすべてを解析することにしました。</font><font style="vertical-align: inherit;">私はすべての可能なオプションを予測したのではなく、基本的なオプションのみを予測しました。</font><font style="vertical-align: inherit;">しかし、何らかの理由で誰かがそれを変更して使用することを決定した場合、私は私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へのリクエストを通じて改善を共有できてうれしい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">です</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="pm"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンマッチング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、タスクは導関数の微積分を作成することです。</font><font style="vertical-align: inherit;">以下を見積もることができます。さまざまなタイプの演算（乗算、除算など）の導関数を見つけるためのルールがいくつかあります。</font><font style="vertical-align: inherit;">操作に応じて、特定の式を選択する必要があります。</font><font style="vertical-align: inherit;">このような平凡な定式化では、タスクは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スイッチ/ケースに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置するのが理想的</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">そして、言語の最新バージョンでは、スイッチ/ケース2.0または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンマッチング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が提示されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何かを議論するのは難しいです。</font><font style="vertical-align: inherit;">ハブでは、そのような量のコードは扱いにくく、読みにくいので、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を確認することをお勧めし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">導関数の例としては、次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatterntMatchingDerivative</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
		<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; ParseDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(ParseDerivative(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Expression <span class="hljs-title">ParseDerivative</span>(<span class="hljs-params">Expression function</span>)</span> =&gt; function <span class="hljs-keyword">switch</span><font></font>
        {<font></font>
            BinaryExpression binaryExpr =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            },<font></font>
            MethodCallExpression methodCall <span class="hljs-keyword">when</span> methodCall.Method == _pow =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(ParseDerivative(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
             },<font></font>
             _ =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; _zero,<font></font>
                ExpressionType.Parameter =&gt; _one,<font></font>
                _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">"Bitmap best practice"</span>)<font></font>
             }<font></font>
        };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し変わって見えますが、面白いです。</font><font style="vertical-align: inherit;">これを書いて良かった-すべての条件が有機的に1行に収まる。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例はそれ自体が物語っています。言葉でそれをよりよく説明することはできません。</font></font><br>
<a name="nv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初心者</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなタスクでは、式ツリーの訪問者がすぐに頭に浮かび、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アマチュアの間でキッチンでアジャイルについて話し合う</font><font style="vertical-align: inherit;">ために多くの騒ぎ</font><font style="vertical-align: inherit;">と少しのパニックを引き起こします。</font><font style="vertical-align: inherit;">「無知ではなく、誤った知識を恐れてください。</font><font style="vertical-align: inherit;">真実ではないという真実を検討するよりも、何も知らない方がよいでしょう。」</font><font style="vertical-align: inherit;">トルストイのこのすばらしいフレーズを思い出し、無知を認め、Googleのサポートを求めて、次の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガイドを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見つけることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリンクは、「式ツリービジター」というクエリに対する最初の（1949年のシベリアの後の）リンクです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、これはまさに私たちが必要とするものです。</font><font style="vertical-align: inherit;">記事のタイトルは、私たちがやりたいことと一致しており、例のクラスには、接尾辞</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が付いています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事を確認し、派生物の例と同様に作成すると、次のようになります</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。githubへのリンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomDerivativeExpressionTreeVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; Visit(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visitor.CreateFromExpression(function.Body).Visit(), function.Parameters);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression Zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression One = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Visitor <span class="hljs-title">CreateFromExpression</span>(<span class="hljs-params">Expression node</span>)</span>
            =&gt; node <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                BinaryExpression be =&gt; <span class="hljs-keyword">new</span> BinaryVisitor(be),<font></font>
                MethodCallExpression mce <span class="hljs-keyword">when</span> mce.Method == Pow =&gt; <span class="hljs-keyword">new</span> PowMethodCallVisitor(mce),<font></font>
                _ =&gt; <span class="hljs-keyword">new</span> SimpleVisitor(node),<font></font>
            };<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BinaryExpression _node;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryVisitor</span>(<span class="hljs-params">BinaryExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowMethodCallVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodCallExpression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PowMethodCallVisitor</span>(<span class="hljs-params">MethodCallExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; (_node.Arguments[<span class="hljs-number">0</span>], _node.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(_node, Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, Pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(CreateFromExpression(expression).Visit(), _node), Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Expression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleVisitor</span>(<span class="hljs-params">Expression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; Zero,<font></font>
                ExpressionType.Parameter =&gt; One,<font></font>
            };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私たちはさまざまなクラスのスイッチケースを広げています。</font><font style="vertical-align: inherit;">それらは少なくなく、魔法は現れませんでした。</font><font style="vertical-align: inherit;">すべて同じ場合、はるかに多くの行。</font><font style="vertical-align: inherit;">そして、約束された二重派遣はどこにあるのですか？</font></font><br>
<a name="cv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラシックビジターとデュアルディスパッチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここについて伝えることの価値</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレート自体は</font><font style="vertical-align: inherit;">、それはまた、ある</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の基本である、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式ツリーの訪問者</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。式ツリーの例だけで分析してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少しの間、式ツリーを設計するとします。ユーザーに式ツリーを反復処理し、ノードのタイプ（式のタイプ）に応じて特定のアクションを実行する機会を提供したいと考えています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のオプション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は何もしないことです。つまり、ユーザーにスイッチ/ケースの使用を強制します。これはそれほど悪いオプションではありません。しかし、ここにはそのようなニュアンスがあります。特定のタイプに責任があるロジックを広げます。簡単に言えば、ポリモーフィズムと仮想の課題（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別名遅延バインディング）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）タイプ定義をランタイムにシフトし、これらのチェックをコードから削除できるようにします。目的のタイプのインスタンスを作成するロジックがあれば十分です。その後、ランタイムによってすべてが実行されます。</font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のオプション。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明白な解決策は、ロジックを仮想メソッドに取り込むことです。各サクセサの仮想メソッドをオーバーライドすることで、switch / caseを忘れることができます。ポリモーフィックコールのメカニズムによって決定されます。メソッドテーブルはここで機能し、メソッドはその中のオフセットによって呼び出されます。しかし、これは記事全体のトピックなので、夢中にならないようにしましょう。仮想メソッドは私たちの問題を解決するようです。しかし、残念ながら、彼らは別のものを作成します。このタスクでは、GetDeriviative（）メソッドを追加できます。しかし、今では式クラス自体が奇妙に見えます。そのようなメソッドをすべての場合に追加できますが、それらはクラスの一般的なロジックに適合しません。そして、私たちはまだユーザーに似た何かをする機会を提供しませんでした（もちろん、適切な方法で）。ユーザーが特定のタイプごとにロジックを定義できるようにする必要があります。しかし、ポリモーフィズムを維持します（これは利用可能です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うユーザーの努力だけが成功しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、実際の訪問者がいる場所です。</font><font style="vertical-align: inherit;">階層の基本タイプ（この場合は式）では、次の形式のメソッドを定義します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相続人では、このメソッドはオーバーライドされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExpressionVisitor自体は、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
階層のタイプごとに</font><font style="vertical-align: inherit;">同じシグネチャ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つ仮想メソッドを含む基本クラスです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ExpressionVisitorクラスを例として使用して、VisitBinary（...）、VisitMethodCall（...）、VisitConstant（...）、VisitParameter（...）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのメソッドは、階層の対応するクラスで呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">BinaryExpressionクラスのAcceptメソッドは次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span><font></font>
{<font></font>
        <span class="hljs-keyword">return</span> visitor.VisitBinary(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、新しい動作を定義するために、ユーザーはExpressionVisitorクラスへの継承を作成するだけで済みます。そこでは、1つの問題を解決するための対応するメソッドが再定義されます。この例では、DerivativeExpressionVisitorが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、Expressionの後継オブジェクトのオブジェクトがいくつかありますが、それらは不明ですが、必須ではありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想Acceptメソッドを必要なExpressionVisitor実装で呼び出します。 DerivativeExpressionVisitorで。動的ディスパッチのおかげで、ランタイムなど、Acceptのオーバーライドされた実装が呼び出されます（BinaryExpressionなど）。このメソッドの本文では、BinaryExpressionにいることを完全に理解していますが、ExpressionVisitorの後継者が来たのかわかりません。しかしそれ以来VisitBinaryも仮想であり、知る必要はありません。この場合も、基本クラスへの参照を呼び出すだけで、呼び出しは動的に（実行時に）ディスパッチされ、オーバーライドされたランタイム型のVisitBinary実装が呼び出されます。ダブルディスパッチについてはこれくらいです-「あなたがやる」-「いいえ、あなた」のスタイルのピンポン。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは私たちに何を与えますか。実際、これにより、外部からではなく外部から仮想メソッドを「追加」することが可能になります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを変更します。</font><font style="vertical-align: inherit;">素晴らしいように聞こえますが、欠点があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acceptメソッドの形式の一部の左翼。すべてに対して責任を負い、同時に何に対しても責任を負わない</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れたハッシュ関数の波及効果は、階層に相続人を1人だけ追加すると、最悪の場合、誰もが訪問者を終了する必要があることです。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、式ツリーの性質上、式を使用する場合の詳細のため、これらのコストは許容されます。これは、この種の回避策がその主な機能の1つであるためです。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オーバーロードに使用できるすべてのメソッドを確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、最後にそれがどのように見えるか見てみましょう。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githubにリンクします。</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildinExpressionTreeVisitor</span> : <span class="hljs-title">ExpressionVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; GetDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visit(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitBinary</span>(<span class="hljs-params">BinaryExpression binaryExpr</span>)</span>
            =&gt; binaryExpr.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; binaryExpr.Left,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; binaryExpr.Right,<font></font>
                ExpressionType.Multiply =&gt; Expression.Add(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))),<font></font>
<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; Expression.Divide(binaryExpr.Left, Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; Expression.Divide(_one, binaryExpr.Right),<font></font>
                ExpressionType.Divide =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitMethodCall</span>(<span class="hljs-params">MethodCallExpression methodCall</span>)</span>
            =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(Visit(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitConstant</span>(<span class="hljs-params">ConstantExpression _</span>)</span> =&gt; _zero;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitParameter</span>(<span class="hljs-params">ParameterExpression b</span>)</span> =&gt; _one;<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、ほとんどのプログラミングタスクと同様に、明確な答えを出すことはできません。</font><font style="vertical-align: inherit;">いつものように、すべては特定の状況に依存します。</font><font style="vertical-align: inherit;">私の例では、通常のパターンマッチングが好きです。</font><font style="vertical-align: inherit;">産業開発の規模までは開発していません。</font><font style="vertical-align: inherit;">この表現が制御不能に増加する場合は、訪問者について考える価値があります。</font><font style="vertical-align: inherit;">そして、世間知らずの訪問者にも生きる権利があります。結局のところ、階層がサポートを提供していない場合、これは大量のコードをクラスに分散させる良い方法です。</font><font style="vertical-align: inherit;">そしてここにも例外があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、階層からの訪問者のサポートは非​​常に物議を醸しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ここで提供される情報が正しい選択をするのに十分であることを願っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja486948/index.html">エディターを選択する方法、およびNeoVimを選択する理由</a></li>
<li><a href="../ja486950/index.html">骨董品：386番目のコンピューターの容赦ないアップグレード</a></li>
<li><a href="../ja486962/index.html">HSEゲーム開発レビュー</a></li>
<li><a href="../ja486964/index.html">マルチタスクと好奇心。JavaチャンピオンのMitya AlexandrovがITコミュニティ、「リモート」、そして人生の創造について語ります</a></li>
<li><a href="../ja486966/index.html">利便性とセキュリティがトレードオフにならない理由</a></li>
<li><a href="../ja486974/index.html">ロシアでの電子機器の大量生産。テスト自動化</a></li>
<li><a href="../ja486976/index.html">ロシアの情報教育の問題とその解決策</a></li>
<li><a href="../ja486978/index.html">フィールドノート：最大のオープンソースカンファレンスの1つFOSDEM 2020</a></li>
<li><a href="../ja486980/index.html">キム・ドットコム：キャッチ、オンラインで最も欲しい人。パート1</a></li>
<li><a href="../ja486982/index.html">フロントエンド開発を学び、最初の仕事を見つけ、バンプを取得しない方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>