<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⭐️ 🈹 👩🏾 Planificación en Go: Parte II - El programador de Go 🔣 👣 🎃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Esta es la segunda publicación de una serie de tres partes, que dará una idea de la mecánica y la semántica del trabajo del planificador en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planificación en Go: Parte II - El programador de Go</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr! </font><font style="vertical-align: inherit;">Esta es la segunda publicación de una serie de tres partes, que dará una idea de la mecánica y la semántica del trabajo del planificador en Go. </font><font style="vertical-align: inherit;">Esta publicación es sobre el planificador Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primera parte de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esta serie, expliqué aspectos del programador del sistema operativo que, en mi opinión, son importantes para comprender y evaluar la semántica del programador Go. </font><font style="vertical-align: inherit;">En esta publicación, explicaré a nivel semántico cómo funciona el planificador Go. </font><font style="vertical-align: inherit;">El Go Scheduler es un sistema complejo y los pequeños detalles mecánicos no son importantes. </font><font style="vertical-align: inherit;">Es importante tener un buen modelo de cómo funciona y se comporta todo. </font><font style="vertical-align: inherit;">Esto le permitirá tomar las mejores decisiones de ingeniería.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tu programa está comenzando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se inicia su programa Go, se le asigna un procesador lógico (P) para cada núcleo virtual definido en la máquina host. Si tiene un procesador con varios hilos de hardware por núcleo físico (Hyper-Threading), cada hilo de hardware se presentará a su programa como un núcleo virtual. Para comprender mejor esto, eche un vistazo al informe del sistema para mi MacBook Pro. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes ver que tengo un procesador con 4 núcleos físicos. Este informe no revela la cantidad de subprocesos de hardware por núcleo físico. El procesador Intel Core i7 tiene tecnología Hyper-Threading, lo que significa que el núcleo físico tiene 2 hilos de hardware. Esto le dice a Go que hay 8 núcleos virtuales disponibles para ejecutar subprocesos del sistema operativo en paralelo. Para verificar esto, considere el siguiente programa:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ejecuto este programa en mi computadora, el resultado de llamar a la función NumCPU () será 8. Cualquier programa Go que ejecute en mi computadora obtendrá 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A cada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se le asigna un flujo del sistema operativo ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). El sistema operativo todavía administra este subproceso y el sistema operativo sigue siendo responsable de colocar el subproceso en el núcleo para su ejecución. Esto significa que cuando ejecuto Go en mi computadora, tengo 8 hilos disponibles para hacer mi trabajo, cada uno vinculado individualmente a P. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada programa Go también recibe una Goroutine inicial ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine es esencialmente Coroutine, pero es Go, por lo que reemplazamos la letra C con G y obtenemos la palabra Goroutine. Puede pensar en Goroutines como subprocesos a nivel de aplicación, y se parecen mucho a los subprocesos del sistema operativo. Del mismo modo que el kernel activa y desactiva los hilos del sistema operativo, el contexto activa y desactiva los programas contextuales.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El último rompecabezas son las colas de ejecución. </font><font style="vertical-align: inherit;">Hay dos colas de ejecución diferentes en el planificador Go: la cola de ejecución global (GRQ) y la cola de ejecución local (LRQ). </font><font style="vertical-align: inherit;">A cada P se le asigna un LRQ que controla las goroutinas asignadas para ejecutarse en el contexto de P. Estas goroutinas se encienden y apagan desde el contexto M asignado a esta P. GRQ es para goroutinas que no se han asignado a P. Hay un proceso para mover las goroutinas de GRQ a LRQ, que discutiremos más adelante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La imagen muestra todos estos componentes juntos.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="imagen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planificador cooperativo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dijimos en la primera publicación, el planificador del sistema operativo es un planificador preventivo. Esencialmente, esto significa que no puede predecir lo que hará el planificador en un momento dado. El núcleo toma decisiones y todo no es determinista. Las aplicaciones que se ejecutan en la parte superior del sistema operativo no controlan lo que sucede dentro del núcleo con la programación a menos que usen primitivas de sincronización, como instrucciones atómicas y llamadas mutex.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler es parte de Go Runtime, y Go Runtime está integrado en su aplicación. Esto significa que el planificador Go funciona en el espacio del usuario en el núcleo. La implementación actual del planificador Go no es preventiva, sino un planificador interactivo. Ser un planificador cooperativo significa que el planificador necesita eventos claramente definidos en el espacio del usuario que ocurran en puntos seguros del código para tomar decisiones de planificación.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo bueno del planificador colaborativo de Go es que se ve y se siente proactivo. </font><font style="vertical-align: inherit;">No puede predecir qué va a hacer el planificador Go. </font><font style="vertical-align: inherit;">Esto se debe al hecho de que la toma de decisiones para este planificador no depende de los desarrolladores, sino del tiempo de ejecución de Go. </font><font style="vertical-align: inherit;">Es importante pensar en el planificador Go como un planificador proactivo, y dado que el planificador no es determinista, no es demasiado difícil.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estados Gorutin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que las corrientes, las goroutinas tienen los mismos tres estados de alto nivel. Determinan el papel que juega el planificador Go con cualquier rutina. Goroutin puede estar en uno de tres estados: en espera, listo o cumpliendo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperando</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Esto significa que la gorutina se detiene y espera que algo continúe. Esto puede suceder por razones como la espera del sistema operativo (llamadas del sistema) o la sincronización de llamadas (operaciones atómicas y mutex). Estos tipos de retrasos son la causa principal del bajo rendimiento. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparación</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: esto significa que goroutine quiere tiempo para seguir las instrucciones asignadas. </font><font style="vertical-align: inherit;">Si tienes muchas gorutinas que necesitan tiempo, las gorutinas tendrán que esperar más tiempo para tener tiempo. </font><font style="vertical-align: inherit;">Además, la cantidad de tiempo individual que recibe cualquier gorutina se reduce a medida que más gorutinas compiten por el tiempo. </font><font style="vertical-align: inherit;">Este tipo de retraso de programación también puede causar un bajo rendimiento. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cumplimiento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esto significa que se ha colocado gorutina en M y está siguiendo sus instrucciones. </font><font style="vertical-align: inherit;">El trabajo asociado con la aplicación se ha completado. </font><font style="vertical-align: inherit;">Esto es lo que todos quieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambio de contexto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler requiere eventos de espacio de usuario bien definidos que ocurran en puntos seguros del código para cambiar de contexto. </font><font style="vertical-align: inherit;">Estos eventos y puntos seguros aparecen en las llamadas a funciones. </font><font style="vertical-align: inherit;">Las llamadas a funciones son críticas para el rendimiento del Go Scheduler. </font><font style="vertical-align: inherit;">Si ejecuta bucles estrechos que no realizan llamadas a funciones, provocará demoras en el programador y la recolección de elementos no utilizados. </font><font style="vertical-align: inherit;">Es imperativo que las llamadas a funciones ocurran dentro de un período de tiempo razonable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay cuatro clases de eventos que ocurren en sus programas Go que le permiten al planificador tomar decisiones de planificación. </font><font style="vertical-align: inherit;">Esto no significa que esto siempre sucederá en uno de estos eventos. </font><font style="vertical-align: inherit;">Esto significa que el planificador tiene la oportunidad.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando la palabra clave go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recolector de basura</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de llamadas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincronización</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de la</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
palabra clave </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> La palabra clave </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> es cómo se crea goroutine. </font><font style="vertical-align: inherit;">Tan pronto como se crea una nueva gorutina, le da al planificador la oportunidad de tomar una decisión de planificación. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recolector de basura (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dado que el GC funciona con su propio conjunto de gorutinas, estas gorutinas necesitan tiempo en M para funcionar. </font><font style="vertical-align: inherit;">Esto obliga al GC a crear mucho caos en la planificación. </font><font style="vertical-align: inherit;">Sin embargo, el planificador es muy inteligente en lo que hace goroutine, y lo usará para tomar decisiones. </font><font style="vertical-align: inherit;">Una solución razonable es cambiar el contexto a goroutine, que quiere acceder al recurso del sistema, y ​​a nadie más que a él durante la recolección de basura. </font><font style="vertical-align: inherit;">Cuando el GC funciona, se toman muchas decisiones de planificación. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de llamadas</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si goroutine realiza una llamada al sistema que bloqueará M, el planificador puede cambiar el contexto a otra goroutine, a la misma M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincronización</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si una llamada a una operación atómica, un mutex o un canal hace que se bloquee la goroutine, el planificador puede cambiar el contexto para iniciar una nueva goroutine. </font><font style="vertical-align: inherit;">Una vez que la rutina puede funcionar nuevamente, se puede poner en cola y eventualmente volver a M.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamadas asincrónicas del sistema</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el sistema operativo en el que se está ejecutando tiene la capacidad de procesar una llamada del sistema de forma asincrónica, lo que se llama un sondeo de red se puede utilizar para procesar la llamada del sistema de manera más eficiente. </font><font style="vertical-align: inherit;">Esto se logra usando kqueue (MacOS), epoll (Linux) o iocp (Windows) en estos respectivos sistemas operativos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las llamadas al sistema de red pueden ser manejadas de forma asíncrona por muchos de los sistemas operativos que usamos hoy. Aquí es donde se muestra el sondeo de red, ya que su objetivo principal es procesar las operaciones de la red. Usando el sondeo de red para llamadas al sistema de red, el programador puede evitar que las rutinas bloqueen M durante estas llamadas al sistema. Esto ayuda a mantener M disponible para ejecutar otras rutinas en LRQ P sin la necesidad de crear una nueva M. Esto ayuda a reducir la carga de planificación en el sistema operativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mejor manera de ver cómo funciona esto es mirar un ejemplo. La figura muestra nuestro esquema de planificación básico. Gorutin-1 se ejecuta en M, y 3 Gorutins más están esperando en LRQ para obtener su tiempo en M. El encuestador de red está inactivo y no tiene nada que hacer.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente figura, Gorutin-1 (G1) desea realizar una llamada al sistema de red, por lo que G1 se mueve al sondeo de red y se trata como una llamada asincrónica del sistema de red. </font><font style="vertical-align: inherit;">Una vez que G1 se ha movido a Network poller, M ahora está disponible para ejecutar otra rutina desde LRQ. </font><font style="vertical-align: inherit;">En este caso, Gorutin-2 cambia a M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente figura, la llamada de red del sistema finaliza con una llamada de red asíncrona, y G1 vuelve a LRQ para P. Después de que G1 se puede volver a cambiar a M, el código asociado con Go, para el cual él responde puede ejecutar de nuevo. </font><font style="vertical-align: inherit;">La gran victoria es que no se necesita más Sra. Para hacer llamadas al sistema de red. </font><font style="vertical-align: inherit;">Network Poller tiene un subproceso de sistema operativo y procesa a través de un bucle de eventos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamadas al sistema sincrónico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué sucede cuando goroutine quiere hacer una llamada al sistema que no se puede ejecutar de forma asincrónica? </font><font style="vertical-align: inherit;">En este caso, el sondeo de red no se puede utilizar, y la rutina que realiza la llamada al sistema bloqueará M. Esto es malo, pero no hay forma de evitarlo. </font><font style="vertical-align: inherit;">Un ejemplo de una llamada al sistema que no se puede realizar de forma asíncrona son las llamadas al sistema basadas en archivos. </font><font style="vertical-align: inherit;">Si usa CGO, puede haber otras situaciones en las que llamar a las funciones de C también bloquea M.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema operativo Windows puede realizar llamadas de sistema asincrónicas basadas en archivos. </font><font style="vertical-align: inherit;">Técnicamente, cuando trabajas en Windows, puedes usar Network Poller.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos qué sucede con una llamada al sistema síncrono (por ejemplo, E / S de archivo) que bloqueará M. La figura muestra nuestro diagrama de planificación básico, pero esta vez G1 realizará una llamada al sistema síncrono que bloqueará M1. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente figura, el planificador puede determinar que G1 provocó un bloqueo M. En este punto, el planificador desconecta M1 de P con un bloqueo G1 aún conectado. Luego, el planificador introduce un nuevo M2 para servir a P. En este punto, G2 puede seleccionarse de LRQ e incluirse en el contexto M2. Si M ya existe debido a un intercambio previo, esta transición es más rápida que la necesidad de crear una nueva M.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente paso completa la llamada al sistema de bloqueo realizada por G1. </font><font style="vertical-align: inherit;">En este punto, G1 puede regresar a LRQ y ser atendido nuevamente por P. M1 luego se deja de lado para uso futuro si este escenario se repite.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="imagen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robar trabajo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro aspecto del planificador es que es un planificador de robos de rutina. Esto ayuda en varias áreas para apoyar una planificación efectiva. En primer lugar, lo último que necesita es que M pase al estado de espera, porque tan pronto como esto suceda, el sistema operativo cambiará M del núcleo usando el contexto. Esto significa que P no puede hacer ningún trabajo, incluso si hay una Goroutine en buen estado, hasta que M vuelva al kernel. Gorutin Theft también ayuda a equilibrar los intervalos de tiempo entre todos los Ps para que el trabajo se distribuya mejor y se realice de manera más eficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la figura, tenemos un programa Go multiproceso con dos Ps que sirven cuatro G cada una y una G en GRQ. ¿Qué sucede si uno de P sirve rápidamente a todo su G?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, P1 ya no tiene gorutinas para ejecutar. Pero hay gorutinas en condiciones de trabajo, tanto en LRQ para P2 como en GRQ. Este es el momento en que P1 necesita robar gorutina. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las reglas para robar goroutines son las siguientes. Todo el código se puede ver en las fuentes de tiempo de ejecución.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, con base en estas reglas, P1 debe verificar la presencia de gorutinas en su LRQ y tomar la mitad de lo que encuentra. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué sucede si P2 termina de servir todos sus programas y a P1 no le queda nada en LRQ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 ha completado todo su trabajo y ahora debe robar las gorutinas. </font><font style="vertical-align: inherit;">Primero, mirará el LRQ P1, pero no encontrará Goroutines. </font><font style="vertical-align: inherit;">A continuación, mirará a GRQ. </font><font style="vertical-align: inherit;">Allí encontrará el G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 roba G9 de GRQ y comienza a hacer el trabajo. </font><font style="vertical-align: inherit;">Lo bueno de todo este robo es que le permite a M mantenerse ocupado y no estar inactivo.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="imagen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo práctico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la mecánica y la semántica, quiero mostrarles cómo se combina todo esto para que el planificador Go pueda hacer más trabajo con el tiempo. Imagine una aplicación multiproceso escrita en C, en la que el programa administra dos subprocesos del sistema operativo que se envían mensajes entre sí. Hay 2 hilos en la imagen que envían el mensaje de un lado a otro. El hilo 1 recibe el núcleo 1 con cambio de contexto y ahora se está ejecutando, lo que permite que el hilo 1 envíe su mensaje al hilo 2.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, cuando el hilo 1 termina de enviar el mensaje, ahora debe esperar una respuesta. Esto hará que el hilo 1 se desconecte del contexto del núcleo 1 y se ponga en estado de espera. Tan pronto como el hilo 2 recibe una notificación de mensaje, pasa a un estado saludable. Ahora el sistema operativo puede realizar un cambio de contexto y ejecutar el hilo 2 en el núcleo, que resulta ser el núcleo 2. Luego, el hilo 2 procesa el mensaje y envía un nuevo mensaje al hilo 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, la secuencia vuelve al contexto cuando el mensaje 1 de la secuencia 2 es recibido por la secuencia 1. Ahora, la secuencia 2 cambia del estado de ejecución al estado de espera, y la secuencia 1 cambia del estado de espera al estado listo y finalmente regresa al estado de ejecución, lo que le permite procesar y enviar un nuevo mensaje de vuelta. Todos estos cambios de contexto y cambios de estado tardan en completarse, lo que limita la velocidad del trabajo. Dado que cada cambio de contexto implica un retraso de ~ 1000 nanosegundos, y esperamos que el hardware ejecute 12 instrucciones por nanosegundo, observará 12,000 instrucciones que no se ejecutan más o menos durante estos cambios de contexto. Dado que estos flujos también se cruzan entre diferentes núcleos,La probabilidad de un retraso adicional de pérdidas de línea de caché también es alta.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la figura hay dos gorutins que están en armonía unos con otros, pasando el mensaje de un lado a otro. G1 obtiene el cambio de contexto M1, que se ejecuta en Core 1, que le permite a G1 hacer su trabajo. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, cuando G1 termina de enviar el mensaje, ahora necesita esperar una respuesta. Esto hará que G1 se desconecte del contexto M1 y se ponga en estado inactivo. Tan pronto como G2 es notificado del mensaje, pasa a un estado saludable. Ahora el planificador Go puede realizar cambios de contexto y ejecutar G2 en M1, que aún se ejecuta en Core 1. Luego, G2 procesa el mensaje y envía un nuevo mensaje a G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el siguiente paso, todo cambia nuevamente cuando el mensaje enviado por G2 es recibido por G1. Ahora, el contexto G2 cambia del estado de ejecución al estado de espera, y el contexto G1 cambia del estado de espera al estado de ejecución y finalmente regresa al estado de ejecución, lo que le permite procesar y enviar un nuevo mensaje. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las cosas en la superficie no parecen ser diferentes. Todos los mismos cambios de contexto y cambios de estado ocurren independientemente de si usa Streams o Goroutines. Sin embargo, existe una gran diferencia entre el uso de Streams y Gorutin, que puede no ser obvio a primera vista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se usa goroutine, se utilizan los mismos hilos y kernel del sistema operativo para todo el procesamiento. Esto significa que desde el punto de vista del sistema operativo, OS Flow nunca pasa a un estado de espera; Nunca. Como resultado, todas esas instrucciones que perdimos al cambiar de contexto al usar flujos no se pierden al usar goroutin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esencialmente, Go convirtió el trabajo de IO / Bloqueo en un trabajo vinculado al procesador a nivel del sistema operativo. Dado que todo el cambio de contexto se produce a nivel de aplicación, no perdemos las mismas ~ 12 mil instrucciones (en promedio) sobre el cambio de contexto que perdimos al usar secuencias. En Go, los mismos cambios de contexto le cuestan ~ 200 nanosegundos o ~ 2.4 mil comandos. El planificador también ayuda a mejorar el rendimiento de las cadenas de almacenamiento en caché y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es por eso que no necesitamos más hilos de los que tenemos núcleos virtuales. </font><font style="vertical-align: inherit;">Go puede hacer más trabajo con el tiempo porque el programador Go intenta usar menos hilos y hacer más en cada hilo, lo que ayuda a reducir la carga en el sistema operativo y el hardware.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler es realmente sorprendente en cuanto a cómo tiene en cuenta las complejidades del sistema operativo y el hardware. La capacidad de convertir la operación de E / S / bloqueo en una operación vinculada al procesador a nivel del sistema operativo es donde obtenemos grandes ganancias al usar más potencia del procesador con el tiempo. Es por eso que no necesita más subprocesos del sistema operativo que los núcleos virtuales. Puede esperar razonablemente que todo su trabajo se realizará (con enlace de CPU y E / S / bloqueos) con un hilo del sistema operativo por núcleo virtual. Esto es posible para aplicaciones de red y otras aplicaciones que no necesitan llamadas al sistema que bloqueen los hilos del sistema operativo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como desarrollador, aún debe comprender lo que hace su aplicación en términos de tipo de trabajo. </font><font style="vertical-align: inherit;">No puede crear una cantidad ilimitada de goroutines y esperar un rendimiento increíble. </font><font style="vertical-align: inherit;">Menos es siempre más, pero con una comprensión de esta semántica del planificador Go, puede tomar mejores decisiones de ingeniería.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489852/index.html">Autenticación transparente en ASP.Net Core en Linux</a></li>
<li><a href="../es489854/index.html">Redux vs MobX sin confusión</a></li>
<li><a href="../es489856/index.html">La paradoja inversa de Banach-Tarski o cómo reducir el volumen de datos almacenados cinco veces</a></li>
<li><a href="../es489858/index.html">Internacionalización: hacer que la web sea accesible para todos</a></li>
<li><a href="../es489860/index.html">La historia de Telefunken: el fénix de la electrónica alemana desde Wilhelm II y Goebbels hasta los Beatles y hoy</a></li>
<li><a href="../es489868/index.html">Congelar cosas web de Mozilla</a></li>
<li><a href="../es489870/index.html">Intensivo sin conexión gratuito por Node.js en Nizhny Novgorod</a></li>
<li><a href="../es489872/index.html">Cómo el sistema DLP y el módulo OCR impidieron a los empleados falsificar los escaneos de pasaportes</a></li>
<li><a href="../es489874/index.html">Compilación cruzada Rust para ejecutables de Windows desde Linux</a></li>
<li><a href="../es489876/index.html">Cómo resolvimos el problema de tres monolitos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>