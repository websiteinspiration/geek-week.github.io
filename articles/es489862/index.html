<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚≠êÔ∏è üàπ üë©üèæ Planificaci√≥n en Go: Parte II - El programador de Go üî£ üë£ üéÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Esta es la segunda publicaci√≥n de una serie de tres partes, que dar√° una idea de la mec√°nica y la sem√°ntica del trabajo del planificador en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planificaci√≥n en Go: Parte II - El programador de Go</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr! </font><font style="vertical-align: inherit;">Esta es la segunda publicaci√≥n de una serie de tres partes, que dar√° una idea de la mec√°nica y la sem√°ntica del trabajo del planificador en Go. </font><font style="vertical-align: inherit;">Esta publicaci√≥n es sobre el planificador Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primera parte de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esta serie, expliqu√© aspectos del programador del sistema operativo que, en mi opini√≥n, son importantes para comprender y evaluar la sem√°ntica del programador Go. </font><font style="vertical-align: inherit;">En esta publicaci√≥n, explicar√© a nivel sem√°ntico c√≥mo funciona el planificador Go. </font><font style="vertical-align: inherit;">El Go Scheduler es un sistema complejo y los peque√±os detalles mec√°nicos no son importantes. </font><font style="vertical-align: inherit;">Es importante tener un buen modelo de c√≥mo funciona y se comporta todo. </font><font style="vertical-align: inherit;">Esto le permitir√° tomar las mejores decisiones de ingenier√≠a.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tu programa est√° comenzando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se inicia su programa Go, se le asigna un procesador l√≥gico (P) para cada n√∫cleo virtual definido en la m√°quina host. Si tiene un procesador con varios hilos de hardware por n√∫cleo f√≠sico (Hyper-Threading), cada hilo de hardware se presentar√° a su programa como un n√∫cleo virtual. Para comprender mejor esto, eche un vistazo al informe del sistema para mi MacBook Pro. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes ver que tengo un procesador con 4 n√∫cleos f√≠sicos. Este informe no revela la cantidad de subprocesos de hardware por n√∫cleo f√≠sico. El procesador Intel Core i7 tiene tecnolog√≠a Hyper-Threading, lo que significa que el n√∫cleo f√≠sico tiene 2 hilos de hardware. Esto le dice a Go que hay 8 n√∫cleos virtuales disponibles para ejecutar subprocesos del sistema operativo en paralelo. Para verificar esto, considere el siguiente programa:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ejecuto este programa en mi computadora, el resultado de llamar a la funci√≥n NumCPU () ser√° 8. Cualquier programa Go que ejecute en mi computadora obtendr√° 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A cada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se le asigna un flujo del sistema operativo ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). El sistema operativo todav√≠a administra este subproceso y el sistema operativo sigue siendo responsable de colocar el subproceso en el n√∫cleo para su ejecuci√≥n. Esto significa que cuando ejecuto Go en mi computadora, tengo 8 hilos disponibles para hacer mi trabajo, cada uno vinculado individualmente a P. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada programa Go tambi√©n recibe una Goroutine inicial ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine es esencialmente Coroutine, pero es Go, por lo que reemplazamos la letra C con G y obtenemos la palabra Goroutine. Puede pensar en Goroutines como subprocesos a nivel de aplicaci√≥n, y se parecen mucho a los subprocesos del sistema operativo. Del mismo modo que el kernel activa y desactiva los hilos del sistema operativo, el contexto activa y desactiva los programas contextuales.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El √∫ltimo rompecabezas son las colas de ejecuci√≥n. </font><font style="vertical-align: inherit;">Hay dos colas de ejecuci√≥n diferentes en el planificador Go: la cola de ejecuci√≥n global (GRQ) y la cola de ejecuci√≥n local (LRQ). </font><font style="vertical-align: inherit;">A cada P se le asigna un LRQ que controla las goroutinas asignadas para ejecutarse en el contexto de P. Estas goroutinas se encienden y apagan desde el contexto M asignado a esta P. GRQ es para goroutinas que no se han asignado a P. Hay un proceso para mover las goroutinas de GRQ a LRQ, que discutiremos m√°s adelante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La imagen muestra todos estos componentes juntos.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="imagen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planificador cooperativo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dijimos en la primera publicaci√≥n, el planificador del sistema operativo es un planificador preventivo. Esencialmente, esto significa que no puede predecir lo que har√° el planificador en un momento dado. El n√∫cleo toma decisiones y todo no es determinista. Las aplicaciones que se ejecutan en la parte superior del sistema operativo no controlan lo que sucede dentro del n√∫cleo con la programaci√≥n a menos que usen primitivas de sincronizaci√≥n, como instrucciones at√≥micas y llamadas mutex.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler es parte de Go Runtime, y Go Runtime est√° integrado en su aplicaci√≥n. Esto significa que el planificador Go funciona en el espacio del usuario en el n√∫cleo. La implementaci√≥n actual del planificador Go no es preventiva, sino un planificador interactivo. Ser un planificador cooperativo significa que el planificador necesita eventos claramente definidos en el espacio del usuario que ocurran en puntos seguros del c√≥digo para tomar decisiones de planificaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo bueno del planificador colaborativo de Go es que se ve y se siente proactivo. </font><font style="vertical-align: inherit;">No puede predecir qu√© va a hacer el planificador Go. </font><font style="vertical-align: inherit;">Esto se debe al hecho de que la toma de decisiones para este planificador no depende de los desarrolladores, sino del tiempo de ejecuci√≥n de Go. </font><font style="vertical-align: inherit;">Es importante pensar en el planificador Go como un planificador proactivo, y dado que el planificador no es determinista, no es demasiado dif√≠cil.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estados Gorutin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que las corrientes, las goroutinas tienen los mismos tres estados de alto nivel. Determinan el papel que juega el planificador Go con cualquier rutina. Goroutin puede estar en uno de tres estados: en espera, listo o cumpliendo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperando</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Esto significa que la gorutina se detiene y espera que algo contin√∫e. Esto puede suceder por razones como la espera del sistema operativo (llamadas del sistema) o la sincronizaci√≥n de llamadas (operaciones at√≥micas y mutex). Estos tipos de retrasos son la causa principal del bajo rendimiento. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparaci√≥n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: esto significa que goroutine quiere tiempo para seguir las instrucciones asignadas. </font><font style="vertical-align: inherit;">Si tienes muchas gorutinas que necesitan tiempo, las gorutinas tendr√°n que esperar m√°s tiempo para tener tiempo. </font><font style="vertical-align: inherit;">Adem√°s, la cantidad de tiempo individual que recibe cualquier gorutina se reduce a medida que m√°s gorutinas compiten por el tiempo. </font><font style="vertical-align: inherit;">Este tipo de retraso de programaci√≥n tambi√©n puede causar un bajo rendimiento. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cumplimiento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esto significa que se ha colocado gorutina en M y est√° siguiendo sus instrucciones. </font><font style="vertical-align: inherit;">El trabajo asociado con la aplicaci√≥n se ha completado. </font><font style="vertical-align: inherit;">Esto es lo que todos quieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambio de contexto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler requiere eventos de espacio de usuario bien definidos que ocurran en puntos seguros del c√≥digo para cambiar de contexto. </font><font style="vertical-align: inherit;">Estos eventos y puntos seguros aparecen en las llamadas a funciones. </font><font style="vertical-align: inherit;">Las llamadas a funciones son cr√≠ticas para el rendimiento del Go Scheduler. </font><font style="vertical-align: inherit;">Si ejecuta bucles estrechos que no realizan llamadas a funciones, provocar√° demoras en el programador y la recolecci√≥n de elementos no utilizados. </font><font style="vertical-align: inherit;">Es imperativo que las llamadas a funciones ocurran dentro de un per√≠odo de tiempo razonable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay cuatro clases de eventos que ocurren en sus programas Go que le permiten al planificador tomar decisiones de planificaci√≥n. </font><font style="vertical-align: inherit;">Esto no significa que esto siempre suceder√° en uno de estos eventos. </font><font style="vertical-align: inherit;">Esto significa que el planificador tiene la oportunidad.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando la palabra clave go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recolector de basura</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de llamadas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincronizaci√≥n</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de la</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
palabra clave </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> La palabra clave </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> es c√≥mo se crea goroutine. </font><font style="vertical-align: inherit;">Tan pronto como se crea una nueva gorutina, le da al planificador la oportunidad de tomar una decisi√≥n de planificaci√≥n. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recolector de basura (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dado que el GC funciona con su propio conjunto de gorutinas, estas gorutinas necesitan tiempo en M para funcionar. </font><font style="vertical-align: inherit;">Esto obliga al GC a crear mucho caos en la planificaci√≥n. </font><font style="vertical-align: inherit;">Sin embargo, el planificador es muy inteligente en lo que hace goroutine, y lo usar√° para tomar decisiones. </font><font style="vertical-align: inherit;">Una soluci√≥n razonable es cambiar el contexto a goroutine, que quiere acceder al recurso del sistema, y ‚Äã‚Äãa nadie m√°s que a √©l durante la recolecci√≥n de basura. </font><font style="vertical-align: inherit;">Cuando el GC funciona, se toman muchas decisiones de planificaci√≥n. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de llamadas</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si goroutine realiza una llamada al sistema que bloquear√° M, el planificador puede cambiar el contexto a otra goroutine, a la misma M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincronizaci√≥n</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si una llamada a una operaci√≥n at√≥mica, un mutex o un canal hace que se bloquee la goroutine, el planificador puede cambiar el contexto para iniciar una nueva goroutine. </font><font style="vertical-align: inherit;">Una vez que la rutina puede funcionar nuevamente, se puede poner en cola y eventualmente volver a M.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamadas asincr√≥nicas del sistema</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el sistema operativo en el que se est√° ejecutando tiene la capacidad de procesar una llamada del sistema de forma asincr√≥nica, lo que se llama un sondeo de red se puede utilizar para procesar la llamada del sistema de manera m√°s eficiente. </font><font style="vertical-align: inherit;">Esto se logra usando kqueue (MacOS), epoll (Linux) o iocp (Windows) en estos respectivos sistemas operativos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las llamadas al sistema de red pueden ser manejadas de forma as√≠ncrona por muchos de los sistemas operativos que usamos hoy. Aqu√≠ es donde se muestra el sondeo de red, ya que su objetivo principal es procesar las operaciones de la red. Usando el sondeo de red para llamadas al sistema de red, el programador puede evitar que las rutinas bloqueen M durante estas llamadas al sistema. Esto ayuda a mantener M disponible para ejecutar otras rutinas en LRQ P sin la necesidad de crear una nueva M. Esto ayuda a reducir la carga de planificaci√≥n en el sistema operativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mejor manera de ver c√≥mo funciona esto es mirar un ejemplo. La figura muestra nuestro esquema de planificaci√≥n b√°sico. Gorutin-1 se ejecuta en M, y 3 Gorutins m√°s est√°n esperando en LRQ para obtener su tiempo en M. El encuestador de red est√° inactivo y no tiene nada que hacer.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente figura, Gorutin-1 (G1) desea realizar una llamada al sistema de red, por lo que G1 se mueve al sondeo de red y se trata como una llamada asincr√≥nica del sistema de red. </font><font style="vertical-align: inherit;">Una vez que G1 se ha movido a Network poller, M ahora est√° disponible para ejecutar otra rutina desde LRQ. </font><font style="vertical-align: inherit;">En este caso, Gorutin-2 cambia a M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente figura, la llamada de red del sistema finaliza con una llamada de red as√≠ncrona, y G1 vuelve a LRQ para P. Despu√©s de que G1 se puede volver a cambiar a M, el c√≥digo asociado con Go, para el cual √©l responde puede ejecutar de nuevo. </font><font style="vertical-align: inherit;">La gran victoria es que no se necesita m√°s Sra. Para hacer llamadas al sistema de red. </font><font style="vertical-align: inherit;">Network Poller tiene un subproceso de sistema operativo y procesa a trav√©s de un bucle de eventos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamadas al sistema sincr√≥nico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© sucede cuando goroutine quiere hacer una llamada al sistema que no se puede ejecutar de forma asincr√≥nica? </font><font style="vertical-align: inherit;">En este caso, el sondeo de red no se puede utilizar, y la rutina que realiza la llamada al sistema bloquear√° M. Esto es malo, pero no hay forma de evitarlo. </font><font style="vertical-align: inherit;">Un ejemplo de una llamada al sistema que no se puede realizar de forma as√≠ncrona son las llamadas al sistema basadas en archivos. </font><font style="vertical-align: inherit;">Si usa CGO, puede haber otras situaciones en las que llamar a las funciones de C tambi√©n bloquea M.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema operativo Windows puede realizar llamadas de sistema asincr√≥nicas basadas en archivos. </font><font style="vertical-align: inherit;">T√©cnicamente, cuando trabajas en Windows, puedes usar Network Poller.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos qu√© sucede con una llamada al sistema s√≠ncrono (por ejemplo, E / S de archivo) que bloquear√° M. La figura muestra nuestro diagrama de planificaci√≥n b√°sico, pero esta vez G1 realizar√° una llamada al sistema s√≠ncrono que bloquear√° M1. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente figura, el planificador puede determinar que G1 provoc√≥ un bloqueo M. En este punto, el planificador desconecta M1 de P con un bloqueo G1 a√∫n conectado. Luego, el planificador introduce un nuevo M2 para servir a P. En este punto, G2 puede seleccionarse de LRQ e incluirse en el contexto M2. Si M ya existe debido a un intercambio previo, esta transici√≥n es m√°s r√°pida que la necesidad de crear una nueva M.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente paso completa la llamada al sistema de bloqueo realizada por G1. </font><font style="vertical-align: inherit;">En este punto, G1 puede regresar a LRQ y ser atendido nuevamente por P. M1 luego se deja de lado para uso futuro si este escenario se repite.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="imagen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robar trabajo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro aspecto del planificador es que es un planificador de robos de rutina. Esto ayuda en varias √°reas para apoyar una planificaci√≥n efectiva. En primer lugar, lo √∫ltimo que necesita es que M pase al estado de espera, porque tan pronto como esto suceda, el sistema operativo cambiar√° M del n√∫cleo usando el contexto. Esto significa que P no puede hacer ning√∫n trabajo, incluso si hay una Goroutine en buen estado, hasta que M vuelva al kernel. Gorutin Theft tambi√©n ayuda a equilibrar los intervalos de tiempo entre todos los Ps para que el trabajo se distribuya mejor y se realice de manera m√°s eficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la figura, tenemos un programa Go multiproceso con dos Ps que sirven cuatro G cada una y una G en GRQ. ¬øQu√© sucede si uno de P sirve r√°pidamente a todo su G?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, P1 ya no tiene gorutinas para ejecutar. Pero hay gorutinas en condiciones de trabajo, tanto en LRQ para P2 como en GRQ. Este es el momento en que P1 necesita robar gorutina. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las reglas para robar goroutines son las siguientes. Todo el c√≥digo se puede ver en las fuentes de tiempo de ejecuci√≥n.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, con base en estas reglas, P1 debe verificar la presencia de gorutinas en su LRQ y tomar la mitad de lo que encuentra. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© sucede si P2 termina de servir todos sus programas y a P1 no le queda nada en LRQ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 ha completado todo su trabajo y ahora debe robar las gorutinas. </font><font style="vertical-align: inherit;">Primero, mirar√° el LRQ P1, pero no encontrar√° Goroutines. </font><font style="vertical-align: inherit;">A continuaci√≥n, mirar√° a GRQ. </font><font style="vertical-align: inherit;">All√≠ encontrar√° el G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 roba G9 de GRQ y comienza a hacer el trabajo. </font><font style="vertical-align: inherit;">Lo bueno de todo este robo es que le permite a M mantenerse ocupado y no estar inactivo.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="imagen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo pr√°ctico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la mec√°nica y la sem√°ntica, quiero mostrarles c√≥mo se combina todo esto para que el planificador Go pueda hacer m√°s trabajo con el tiempo. Imagine una aplicaci√≥n multiproceso escrita en C, en la que el programa administra dos subprocesos del sistema operativo que se env√≠an mensajes entre s√≠. Hay 2 hilos en la imagen que env√≠an el mensaje de un lado a otro. El hilo 1 recibe el n√∫cleo 1 con cambio de contexto y ahora se est√° ejecutando, lo que permite que el hilo 1 env√≠e su mensaje al hilo 2.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, cuando el hilo 1 termina de enviar el mensaje, ahora debe esperar una respuesta. Esto har√° que el hilo 1 se desconecte del contexto del n√∫cleo 1 y se ponga en estado de espera. Tan pronto como el hilo 2 recibe una notificaci√≥n de mensaje, pasa a un estado saludable. Ahora el sistema operativo puede realizar un cambio de contexto y ejecutar el hilo 2 en el n√∫cleo, que resulta ser el n√∫cleo 2. Luego, el hilo 2 procesa el mensaje y env√≠a un nuevo mensaje al hilo 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, la secuencia vuelve al contexto cuando el mensaje 1 de la secuencia 2 es recibido por la secuencia 1. Ahora, la secuencia 2 cambia del estado de ejecuci√≥n al estado de espera, y la secuencia 1 cambia del estado de espera al estado listo y finalmente regresa al estado de ejecuci√≥n, lo que le permite procesar y enviar un nuevo mensaje de vuelta. Todos estos cambios de contexto y cambios de estado tardan en completarse, lo que limita la velocidad del trabajo. Dado que cada cambio de contexto implica un retraso de ~ 1000 nanosegundos, y esperamos que el hardware ejecute 12 instrucciones por nanosegundo, observar√° 12,000 instrucciones que no se ejecutan m√°s o menos durante estos cambios de contexto. Dado que estos flujos tambi√©n se cruzan entre diferentes n√∫cleos,La probabilidad de un retraso adicional de p√©rdidas de l√≠nea de cach√© tambi√©n es alta.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la figura hay dos gorutins que est√°n en armon√≠a unos con otros, pasando el mensaje de un lado a otro. G1 obtiene el cambio de contexto M1, que se ejecuta en Core 1, que le permite a G1 hacer su trabajo. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, cuando G1 termina de enviar el mensaje, ahora necesita esperar una respuesta. Esto har√° que G1 se desconecte del contexto M1 y se ponga en estado inactivo. Tan pronto como G2 es notificado del mensaje, pasa a un estado saludable. Ahora el planificador Go puede realizar cambios de contexto y ejecutar G2 en M1, que a√∫n se ejecuta en Core 1. Luego, G2 procesa el mensaje y env√≠a un nuevo mensaje a G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el siguiente paso, todo cambia nuevamente cuando el mensaje enviado por G2 es recibido por G1. Ahora, el contexto G2 cambia del estado de ejecuci√≥n al estado de espera, y el contexto G1 cambia del estado de espera al estado de ejecuci√≥n y finalmente regresa al estado de ejecuci√≥n, lo que le permite procesar y enviar un nuevo mensaje. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las cosas en la superficie no parecen ser diferentes. Todos los mismos cambios de contexto y cambios de estado ocurren independientemente de si usa Streams o Goroutines. Sin embargo, existe una gran diferencia entre el uso de Streams y Gorutin, que puede no ser obvio a primera vista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se usa goroutine, se utilizan los mismos hilos y kernel del sistema operativo para todo el procesamiento. Esto significa que desde el punto de vista del sistema operativo, OS Flow nunca pasa a un estado de espera; Nunca. Como resultado, todas esas instrucciones que perdimos al cambiar de contexto al usar flujos no se pierden al usar goroutin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esencialmente, Go convirti√≥ el trabajo de IO / Bloqueo en un trabajo vinculado al procesador a nivel del sistema operativo. Dado que todo el cambio de contexto se produce a nivel de aplicaci√≥n, no perdemos las mismas ~ 12 mil instrucciones (en promedio) sobre el cambio de contexto que perdimos al usar secuencias. En Go, los mismos cambios de contexto le cuestan ~ 200 nanosegundos o ~ 2.4 mil comandos. El planificador tambi√©n ayuda a mejorar el rendimiento de las cadenas de almacenamiento en cach√© y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es por eso que no necesitamos m√°s hilos de los que tenemos n√∫cleos virtuales. </font><font style="vertical-align: inherit;">Go puede hacer m√°s trabajo con el tiempo porque el programador Go intenta usar menos hilos y hacer m√°s en cada hilo, lo que ayuda a reducir la carga en el sistema operativo y el hardware.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler es realmente sorprendente en cuanto a c√≥mo tiene en cuenta las complejidades del sistema operativo y el hardware. La capacidad de convertir la operaci√≥n de E / S / bloqueo en una operaci√≥n vinculada al procesador a nivel del sistema operativo es donde obtenemos grandes ganancias al usar m√°s potencia del procesador con el tiempo. Es por eso que no necesita m√°s subprocesos del sistema operativo que los n√∫cleos virtuales. Puede esperar razonablemente que todo su trabajo se realizar√° (con enlace de CPU y E / S / bloqueos) con un hilo del sistema operativo por n√∫cleo virtual. Esto es posible para aplicaciones de red y otras aplicaciones que no necesitan llamadas al sistema que bloqueen los hilos del sistema operativo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como desarrollador, a√∫n debe comprender lo que hace su aplicaci√≥n en t√©rminos de tipo de trabajo. </font><font style="vertical-align: inherit;">No puede crear una cantidad ilimitada de goroutines y esperar un rendimiento incre√≠ble. </font><font style="vertical-align: inherit;">Menos es siempre m√°s, pero con una comprensi√≥n de esta sem√°ntica del planificador Go, puede tomar mejores decisiones de ingenier√≠a.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489852/index.html">Autenticaci√≥n transparente en ASP.Net Core en Linux</a></li>
<li><a href="../es489854/index.html">Redux vs MobX sin confusi√≥n</a></li>
<li><a href="../es489856/index.html">La paradoja inversa de Banach-Tarski o c√≥mo reducir el volumen de datos almacenados cinco veces</a></li>
<li><a href="../es489858/index.html">Internacionalizaci√≥n: hacer que la web sea accesible para todos</a></li>
<li><a href="../es489860/index.html">La historia de Telefunken: el f√©nix de la electr√≥nica alemana desde Wilhelm II y Goebbels hasta los Beatles y hoy</a></li>
<li><a href="../es489868/index.html">Congelar cosas web de Mozilla</a></li>
<li><a href="../es489870/index.html">Intensivo sin conexi√≥n gratuito por Node.js en Nizhny Novgorod</a></li>
<li><a href="../es489872/index.html">C√≥mo el sistema DLP y el m√≥dulo OCR impidieron a los empleados falsificar los escaneos de pasaportes</a></li>
<li><a href="../es489874/index.html">Compilaci√≥n cruzada Rust para ejecutables de Windows desde Linux</a></li>
<li><a href="../es489876/index.html">C√≥mo resolvimos el problema de tres monolitos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>