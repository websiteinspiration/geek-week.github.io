<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 ♏️ 👨🏼‍🔬 Acelere sua pesquisa em Eu fui transferido para 49 microssegundos (C ++) 🤷🏽 👨🏽‍🔬 ✌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há muito tempo que eu conheço o site Fui Pwned (HIBP) . É verdade que, até recentemente, ele nunca esteve lá. Eu sempre tive duas senhas. Um deles foi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Acelere sua pesquisa em Eu fui transferido para 49 microssegundos (C ++)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/rg/hn/furghncw9u08teobuskqawx2y7u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há muito tempo que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eu conheço o site Fui Pwned (HIBP)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . É verdade que, até recentemente, ele nunca esteve lá. Eu sempre tive duas senhas. Um deles foi usado repetidamente para correio de lixo e algumas contas em sites estranhos. Mas tive que recusar, porque o correio foi hackeado. E, para ser sincero, sou grato ao hacker porque esse evento me fez revisar minhas senhas - a maneira como as uso e as armazeno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, mudei senhas em todas as contas em que havia uma senha comprometida. Então me perguntei se a senha vazada estava no banco de dados HIBP. Como não quis inserir a senha no site, baixei o banco de dados (</font></font><code>pwned-passwords-sha1-ordered-by-count-v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">A base é muito impressionante. </font><font style="vertical-align: inherit;">Este é um arquivo de texto de 22,8 GB com um conjunto de hashes SHA-1, um em cada linha com um contador, quantas vezes a senha com esse hash ocorreu com vazamentos. </font><font style="vertical-align: inherit;">Eu descobri o SHA-1 da minha senha quebrada e tentei encontrá-la.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[G] rep</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura Trie</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa binária</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenação</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que voltar atrás?</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelismo</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não seja um bastardo egoísta</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B3</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação de inserção</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separado ou não?</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriedades da árvore HIBP</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivo de saída</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">okon - biblioteca e CLI</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links e discussão</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado pela leitura</font></font></a></li>
</ul><br>
<a name="1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[G] rep</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos um arquivo de texto com um hash em cada linha. </font><font style="vertical-align: inherit;">Provavelmente o melhor lugar para ir é grep. </font></font><br>
<br>
<code>grep -m 1 '^XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' pwned-passwords-sha1-ordered-by-count-v5.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minha senha estava no topo da lista com uma frequência de mais de 1.500 vezes, então é realmente péssimo. </font><font style="vertical-align: inherit;">Consequentemente, os resultados da pesquisa retornaram quase instantaneamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas nem todo mundo tem senhas fracas. </font><font style="vertical-align: inherit;">Eu queria verificar quanto tempo levaria para encontrar o pior cenário - o último hash do arquivo: </font></font><br>
<br>
<code>time grep -m 1 '^4541A1E4605EEBF3F4C166329C18502DF75D348A' pwned-passwords-sha1-ordered-by-count-v5.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultado: </font></font><code>33,35s user 23,39s system 41% cpu 2:15,35 total</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é triste. </font><font style="vertical-align: inherit;">Afinal, desde que meus emails foram invadidos, eu queria verificar a presença de todas as minhas senhas antigas e novas no banco de dados. </font><font style="vertical-align: inherit;">Mas um grep de dois minutos simplesmente não permite que você faça isso confortavelmente. </font><font style="vertical-align: inherit;">Claro, eu poderia escrever um script, executá-lo e dar um passeio, mas isso não é uma opção. </font><font style="vertical-align: inherit;">Eu queria encontrar uma solução melhor e aprender alguma coisa.</font></font><br>
<br>
<a name="2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura Trie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira ideia foi usar uma estrutura de dados trie. A estrutura parece ideal para armazenar hashes SHA-1. O alfabeto é pequeno, portanto os nós também serão pequenos, assim como o arquivo resultante. Talvez até caiba na RAM? A pesquisa de chaves deve ser muito rápida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então eu implementei essa estrutura. Em seguida, ele pegou os primeiros 1.000.000 de hashes do banco de dados de origem para criar o arquivo resultante e verificar se tudo está no arquivo criado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, eu consegui encontrar tudo no arquivo, então a estrutura funcionou bem. O problema era diferente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo resultante foi lançado no tamanho 2283686592B (2,2 GB). Isto não é bom. Vamos contar e ver o que acontece. Um nó é uma estrutura simples de dezesseis valores de 32 bits. Os valores são "ponteiros" para os seguintes nós com o símbolo de hash SHA-1 especificado. Portanto, um nó ocupa 16 * 4 bytes = 64 bytes. Parece ser um pouco? Mas se você pensar bem, um nó representa um caractere em um hash. Portanto, no pior dos casos, o hash SHA-1 terá 40 * 64 bytes = 2560 bytes. Isso é muito pior do que, por exemplo, uma representação textual de um hash que ocupa apenas 40 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura trie tem a vantagem de reutilizar nós. Se você tiver duas palavras </font></font><code>aaa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>abb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o nó para os primeiros caracteres será reutilizado, porque os caracteres são os mesmos - </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos voltar ao nosso problema. </font><font style="vertical-align: inherit;">Vamos calcular quantos nós estão armazenados no arquivo resultante: </font></font><code>file_size / node_size = 2283686592 / 64 = 35682603</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver quantos nós serão criados no pior caso a partir de um milhão de hashes: </font></font><code>1000000 * 40 = 40000000</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
assim, a estrutura trie reutiliza apenas </font></font><code>40000000 - 35682603 = 4317397</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós, o que representa 10,8% do pior cenário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esses indicadores, o arquivo resultante para todo o banco de dados HIBP levaria 1421513361920 bytes (1,02 TB). </font><font style="vertical-align: inherit;">Eu nem tenho disco rígido suficiente para verificar a velocidade da pesquisa de chaves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naquele dia, descobri que a estrutura trie não é adequada para dados relativamente aleatórios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos procurar outra solução.</font></font><br>
<br>
<a name="3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa binária</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os hashes SHA-1 têm dois recursos interessantes: são comparáveis ​​entre si e têm o mesmo tamanho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Graças a isso, podemos processar o banco de dados HIBP original e criar um arquivo a partir dos valores SHA-1 classificados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas como classificar um arquivo de 22 GB? </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Questão. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que classificar o arquivo de origem? </font><font style="vertical-align: inherit;">HIBP retorna um arquivo com seqüências de caracteres já classificadas por hashes. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Responda. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu simplesmente não pensei nisso. </font><font style="vertical-align: inherit;">Naquele momento, eu não sabia sobre o arquivo classificado.</font></font></i> <br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordenação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classificar todos os hashes na RAM não é uma opção; eu não tenho muita RAM. </font><font style="vertical-align: inherit;">A solução foi esta:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divida um arquivo grande em arquivos menores que cabem na RAM.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixe dados de arquivos pequenos, classifique na RAM e escreva de volta para os arquivos.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combine todos os arquivos pequenos e classificados em um grande.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com um arquivo classificado grande, você pode pesquisar nosso hash usando uma pesquisa binária. </font><font style="vertical-align: inherit;">O acesso ao disco rígido é importante. </font><font style="vertical-align: inherit;">Vamos calcular quantos hits são necessários em uma pesquisa binária: </font></font><code>log2(555278657) = 29.0486367039</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou seja, 30 hits. </font><font style="vertical-align: inherit;">Não é tão ruim. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No primeiro estágio, a otimização pode ser realizada. </font><font style="vertical-align: inherit;">Converta hashes de texto em dados binários. </font><font style="vertical-align: inherit;">Isso reduzirá o tamanho dos dados resultantes pela metade: de 22 para 11 GB. </font><font style="vertical-align: inherit;">Bem.</font></font><br>
<br>
<a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que voltar atrás?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naquele momento, percebi que você pode ser mais esperto. </font><font style="vertical-align: inherit;">E se você não combinar arquivos pequenos em um arquivo grande, mas realizar uma pesquisa binária em arquivos pequenos classificados na RAM? </font><font style="vertical-align: inherit;">O problema é como encontrar o arquivo desejado para procurar a chave. </font><font style="vertical-align: inherit;">A solução é muito simples. </font><font style="vertical-align: inherit;">Nova abordagem:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie 256 arquivos com os nomes "00" ... "FF".</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao ler hashes de um arquivo grande, escreva hashes que começam com "00 .." em um arquivo chamado "00", hashes que começam com "01 .." em um arquivo "01" e assim por diante.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixe dados de arquivos pequenos, classifique na RAM e escreva de volta para os arquivos.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo é muito simples. </font><font style="vertical-align: inherit;">Além disso, outra opção de otimização aparece. </font><font style="vertical-align: inherit;">Se o hash estiver armazenado no arquivo "00", sabemos que começa com "00". </font><font style="vertical-align: inherit;">Se o hash estiver armazenado no arquivo "F2", ele começará com "F2". </font><font style="vertical-align: inherit;">Assim, ao escrever hashes em arquivos pequenos, podemos omitir o primeiro byte de cada hash! </font><font style="vertical-align: inherit;">Isso representa 5% de todos os dados. </font><font style="vertical-align: inherit;">555 MB são salvos no total.</font></font><br>
<br>
<a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelismo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A separação em arquivos menores oferece outra oportunidade de otimização. </font><font style="vertical-align: inherit;">Os arquivos são independentes um do outro, para que possamos classificá-los em paralelo. </font><font style="vertical-align: inherit;">Lembramos que todos os seus processadores gostam de suar ao mesmo tempo;)</font></font><br>
<br>
<a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não seja um bastardo egoísta</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando implementei a solução acima, percebi que outras pessoas provavelmente tinham um problema semelhante. Provavelmente muitos outros também baixam e pesquisam o banco de dados HIBP. Então eu decidi compartilhar meu trabalho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes disso, revisei minha abordagem novamente e encontrei alguns problemas que gostaria de corrigir antes de publicar o código e as ferramentas no Github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, como usuário final, eu não gostaria de usar uma ferramenta que cria muitos arquivos estranhos com nomes estranhos, nos quais não está claro o que está armazenado, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, isso pode ser resolvido combinando os arquivos "00" .. "FF" um arquivo grande.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, ter um arquivo grande para classificação coloca um novo problema. </font><font style="vertical-align: inherit;">E se eu quiser inserir um hash neste arquivo? </font><font style="vertical-align: inherit;">Apenas um hash. </font><font style="vertical-align: inherit;">Isso é apenas 20 bytes. </font><font style="vertical-align: inherit;">Ah, o hash começa com "000000000 ..". </font><font style="vertical-align: inherit;">OK. </font><font style="vertical-align: inherit;">Vamos liberar espaço movendo 11 GB de outros hashes ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você entende qual é o problema. </font><font style="vertical-align: inherit;">Inserir dados no meio de um arquivo não é a operação mais rápida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra desvantagem dessa abordagem é que você precisa armazenar os primeiros bytes novamente - são 555 MB de dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E por último, mas não menos importante, a pesquisa binária dos dados armazenados no disco rígido é muito mais lenta que o acesso à RAM. </font><font style="vertical-align: inherit;">Quero dizer, são 30 leituras de disco versus 0 leituras de disco.</font></font><br>
<br>
<a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B3</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Novamente. </font><font style="vertical-align: inherit;">O que temos e o que queremos alcançar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos 11 GB de valores binários. </font><font style="vertical-align: inherit;">Todos os valores são comparáveis ​​e têm o mesmo tamanho. </font><font style="vertical-align: inherit;">Queremos descobrir se uma chave específica está presente nos dados armazenados e também queremos alterar o banco de dados. </font><font style="vertical-align: inherit;">E para que tudo funcione rapidamente. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/18c/851/d23/18c851d23c6bbe290fcccb763c6f09eb.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Árvore B? </font><font style="vertical-align: inherit;">Direita </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A árvore B permite minimizar o acesso ao disco ao pesquisar, modificar etc. Ele possui muito mais recursos, mas precisamos desses dois.</font></font><br>
<br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação de inserção</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira etapa é converter os dados do arquivo de origem HIBP na árvore B. Isso significa que você precisa extrair todos os hashes e inseri-los na estrutura. O algoritmo de inserção usual é adequado para isso. Mas no nosso caso, você pode fazer melhor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inserir muitos dados brutos em uma árvore B é um cenário bem conhecido. Pessoas sábias inventaram uma abordagem melhor para isso do que a inserção usual. Primeiro de tudo, você precisa classificar os dados. Isso pode ser feito como descrito acima (divida o arquivo em arquivos menores e classifique-os na RAM). Em seguida, insira os dados na árvore.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No algoritmo usual, se você encontrar o nó folha em que deseja inserir o valor e ele for preenchido, crie um novo nó (à direita) e distribua uniformemente os valores entre os dois nós, esquerdo e direito (mais um valor vai para o nó pai) mas não é importante aqui). Em resumo, os valores no nó esquerdo são sempre menores que os valores à direita. O fato é que, quando você insere os dados classificados, sabe que valores menores não serão mais inseridos na árvore e, portanto, nenhum outro valor irá para o nó esquerdo. O nó esquerdo permanece meio vazio o tempo todo. Além disso, se você inserir valores suficientes, poderá descobrir que o nó direito está cheio; portanto, é necessário mover metade dos valores para o novo nó direito. O nó de divisão permanece meio vazio, como no caso anterior. Etc…</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, depois de todas as inserções, você obtém uma árvore na qual quase todos os nós estão meio vazios. </font><font style="vertical-align: inherit;">Este não é um uso muito eficiente do espaço. </font><font style="vertical-align: inherit;">Nós podemos fazer melhor.</font></font><br>
<br>
<a name="10"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separado ou não?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso de inserir dados classificados, você pode fazer uma pequena modificação no algoritmo de inserção. </font><font style="vertical-align: inherit;">Se o nó no qual você deseja colar o valor estiver cheio, não o quebre. </font><font style="vertical-align: inherit;">Apenas crie um novo nó vazio e cole o valor no nó pai. </font><font style="vertical-align: inherit;">Em seguida, quando você insere os seguintes valores (maiores que os anteriores), insere-os em um nó novo e vazio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para preservar as propriedades da árvore B, após todas as inserções, é necessário classificar os nós mais à direita em cada camada da árvore (exceto a raiz) e dividir igualmente os valores desse nó extremo e seu vizinho esquerdo. </font><font style="vertical-align: inherit;">Então você obtém a menor árvore possível.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriedades da árvore HIBP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao projetar uma árvore B, você precisa escolher sua ordem. </font><font style="vertical-align: inherit;">Ele mostra quantos valores podem ser armazenados em um nó, bem como quantos filhos o nó pode ter. </font><font style="vertical-align: inherit;">Ao manipular esse parâmetro, podemos manipular a altura da árvore, o tamanho binário do nó etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No HIBP, temos </font></font><code>555278657</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashes. </font><font style="vertical-align: inherit;">Suponha que queremos uma árvore com três alturas de altura (portanto, não precisamos mais de três operações de leitura para verificar a presença de um hash). </font><font style="vertical-align: inherit;">Precisamos encontrar um valor de M tal que </font></font><code>logM(555278657) &lt; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eu escolhi 1024. Esse não é o menor valor possível, mas permite inserir mais hashes e preservar a altura da árvore.</font></font><br>
<br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivo de saída</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo de origem HIBP tem um tamanho de 22,8 GB. </font><font style="vertical-align: inherit;">O arquivo de saída com a árvore B é de 12,4 GB. </font><font style="vertical-align: inherit;">Demora cerca de 11 minutos para criá-lo na minha máquina (Intel Core i7-6700, 3,4 GHz, 16 GB RAM), disco rígido (não SSD).</font></font><br>
<br>
<a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A opção da árvore B mostra um resultado muito bom:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font><font style="vertical-align: inherit;">| </font><font style="vertical-align: inherit;">tempo [μs] | </font><font style="vertical-align: inherit;">% |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| -----------------: | ------------: | ------------: |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">okon </font><font style="vertical-align: inherit;">49 </font><font style="vertical-align: inherit;">100</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">grep '^ hash' | </font><font style="vertical-align: inherit;">135'350'000 | </font><font style="vertical-align: inherit;">276'224'489 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">grep | </font><font style="vertical-align: inherit;">135'480'000 | </font><font style="vertical-align: inherit;">276'489'795 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">C ++ linha por linha | </font><font style="vertical-align: inherit;">135'720'201 | </font><font style="vertical-align: inherit;">276'980'002 |</font></font></pre><br>
<a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">okon - biblioteca e CLI</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse, queria compartilhar meu trabalho com o mundo. Eu implementei uma biblioteca e uma interface de linha de comando para processar o banco de dados HIBP e pesquisar rapidamente por hashes. A pesquisa é tão rápida que pode, por exemplo, ser integrada a um gerenciador de senhas e fornecer feedback ao usuário cada vez que uma tecla é pressionada. Existem muitos usos possíveis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A biblioteca possui uma interface C, portanto pode ser usada em quase todos os lugares. CLI é uma CLI. Você pode simplesmente criar e executar (: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código está no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meu repositório</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isenção de responsabilidade: o okon ainda não fornece uma interface para inserir valores na árvore B criada. </font><font style="vertical-align: inherit;">Ele só pode processar o arquivo HIBP, criar uma árvore B e pesquisar nele. </font><font style="vertical-align: inherit;">Essas funções funcionam muito bem, então decidi compartilhar o código e continuar trabalhando na inserção e outras funções possíveis.</font></font><br>
<br>
<a name="15"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links e discussão</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura Trie</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árvore B</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site em que fui pwned</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositório de código</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / cpp</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / segurança</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notícias de hackers</font></font></a></li>
</ul><br>
<a name="16"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado pela leitura</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(:</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt490906/index.html">Yandex lançou uma versão beta de uma Aura independente - aura.top. É top?</a></li>
<li><a href="../pt490908/index.html">Armazenamento de dados da zona</a></li>
<li><a href="../pt490912/index.html">Como nós da Sportmaster escolhemos um sistema de cache. Parte 1</a></li>
<li><a href="../pt490916/index.html">Problemas de interação com equipes externas em grandes projetos</a></li>
<li><a href="../pt490918/index.html">Andrei Zaretsky, Alexander Trukhanov (continuação): "Não tínhamos nome, mas havia arrogância"</a></li>
<li><a href="../pt490924/index.html">O que é o Windows PowerShell e o que ele come? Parte 2: Introdução à linguagem de programação</a></li>
<li><a href="../pt490926/index.html">Trajetória de bola unitária 2d para iniciantes</a></li>
<li><a href="../pt490932/index.html">[Previsão] Motornet - uma rede de troca de dados para veículos robóticos</a></li>
<li><a href="../pt490936/index.html">Criar ML no iOS</a></li>
<li><a href="../pt490938/index.html">Escrevemos milhares de arquivos de log por vez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>