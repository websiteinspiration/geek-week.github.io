<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏾 👃🏾 💃🏿 À propos du cluster de serveurs 1C ⬅️ 🤷 🐈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un cluster est un type de système parallèle 
 ou distribué qui: 
 1. se compose de plusieurs 
 ordinateurs interconnectés ; 
 2. Utilisé comme une 
 r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>À propos du cluster de serveurs 1C</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1c/blog/493008/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cluster est un type de système parallèle </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ou distribué qui: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. se compose de plusieurs </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ordinateurs </font><font style="vertical-align: inherit;">interconnectés </font><font style="vertical-align: inherit;">; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Utilisé comme une </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ressource informatique </font><font style="vertical-align: inherit;">unique et </font><font style="vertical-align: inherit;">unifiée </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gregory F. Pfister, «A la recherche de clusters». </font></font></a></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il existe une application métier (par exemple, un système ERP) avec laquelle des milliers (voire des dizaines de milliers) d'utilisateurs travaillent simultanément. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est requis:</font></font></b><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre l'application évolutive, de sorte qu'avec une augmentation du nombre d'utilisateurs, il est possible en raison de l'augmentation des ressources matérielles de fournir les performances d'application nécessaires.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre l'application résistante à la défaillance des composants du système (logiciels et matériels), à la perte de connexion entre les composants et à d'autres problèmes possibles.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez les ressources système aussi efficacement que possible et fournissez les performances d'application souhaitées.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendez le système facile à déployer et à administrer.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ces problèmes, nous utilisons l'architecture de cluster dans la plateforme 1C: Enterprise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avons pas immédiatement atteint le résultat souhaité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous parlerons du type de clusters, de la façon dont nous avons choisi le type de cluster qui nous convient et de l'évolution de notre cluster d'une version à l'autre, et des approches qui nous ont finalement permis de créer un système qui dessert des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dizaines de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">milliers d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisateurs simultanés.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/mo/rq/0gmorqiise6fvaouym5mwpabl7y.png" alt="image"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme Gregory Pfister, l'auteur de l'épigraphe de cet article, l'a écrit dans son livre "A la recherche de clusters", le cluster n'a pas été inventé par un fabricant particulier de matériel ou de logiciels, mais par des clients qui n'avaient pas la puissance d'un ordinateur ou qui avaient besoin de redondance. </font><font style="vertical-align: inherit;">Cela s'est produit, selon Pfister, dans les années 60 du siècle dernier. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Distinguez traditionnellement les principaux types de grappes suivants:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusters de basculement (HA, clusters haute disponibilité)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusters d'équilibrage de charge (LBC)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusters de calcul (clusters de calcul haute performance, HPC)</font></font></li>
<li>   (grid)      ,              .   grid-      ,    .  grid-    HPC-,      .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre nos problèmes (résistance à la défaillance des composants du système et utilisation efficace des ressources), nous devions combiner les fonctionnalités d'un cluster à sécurité intégrée et d'un cluster avec équilibrage de charge. </font><font style="vertical-align: inherit;">Nous n'avons pas pris cette décision tout de suite, mais nous l'avons abordée de manière évolutive, étape par étape. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui ne sont pas à jour, je vais vous expliquer brièvement comment sont organisées les applications métiers 1C. </font><font style="vertical-align: inherit;">Ce sont des applications écrites dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langage thématique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , "affûté" pour l'automatisation des tâches métiers comptables. </font><font style="vertical-align: inherit;">Pour exécuter des applications écrites dans cette langue, un runtime de plate-forme 1C: Enterprise doit être installé sur l'ordinateur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C: Enterprise 8.0</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première version du serveur d'applications 1C (pas encore un cluster) est apparue dans la version 8.0 de la plateforme. Avant cela, 1C fonctionnait dans la version client-serveur, les données étaient stockées dans un fichier SGBD ou MS SQL, et la logique métier fonctionnait exclusivement sur le client. Dans la version 8.0, une transition a été effectuée vers l'architecture à trois niveaux "client - serveur d'applications - SGBD". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le serveur 1C dans la plate-forme 8.0 était </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COM +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un serveur capable d'exécuter du code d'application en 1C. </font><font style="vertical-align: inherit;">L'utilisation de COM + nous a fourni un transport prêt à l'emploi, permettant aux applications clientes de communiquer avec le serveur via le réseau. </font><font style="vertical-align: inherit;">Beaucoup de choses dans l'architecture de l'interaction client-serveur et des objets d'application disponibles pour le développeur 1C ont été conçues en tenant compte de l'utilisation de COM +. </font><font style="vertical-align: inherit;">À ce moment-là, la tolérance aux pannes n'était pas intégrée à l'architecture et une panne de serveur a entraîné l'arrêt de tous les clients. </font><font style="vertical-align: inherit;">Lorsque l'application serveur s'est arrêtée, COM + l'a levée lorsque le premier client y a accédé, et les clients ont commencé leur travail depuis le début - depuis la connexion au serveur. </font><font style="vertical-align: inherit;">À cette époque, tous les clients étaient servis par un seul processus.</font></font><br>
<img src="https://habrastorage.org/webt/fg/oo/en/fgooenmx-pqv5tuizcfcvbvbaqg.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C: Enterprise 8.1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la prochaine version, nous voulions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fournir une tolérance aux pannes à nos clients afin que les accidents et les erreurs de certains utilisateurs ne conduisent pas à des accidents et des erreurs d'autres utilisateurs. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Débarrassez-vous de la technologie COM +. </font><font style="vertical-align: inherit;">COM + ne fonctionnait que sous Windows, et à cette époque la possibilité de travailler sous Linux devenait déjà pertinente.</font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le même temps, nous ne voulions pas développer une nouvelle version de la plateforme à partir de zéro - elle serait trop gourmande en ressources. </font><font style="vertical-align: inherit;">Nous voulions utiliser au maximum nos réalisations, ainsi que maintenir la compatibilité avec les applications développées pour la version 8.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, dans la version 8.1, le premier cluster est apparu. </font><font style="vertical-align: inherit;">Nous avons implémenté notre protocole d'appel de procédure à distance (en plus de TCP), qui en apparence ressemblait presque à COM + pour le client final (c'est-à-dire que nous n'avions pratiquement pas à réécrire le code responsable des appels client-serveur). </font><font style="vertical-align: inherit;">Dans le même temps, nous avons rendu le serveur implémenté indépendant de la plateforme C ++, capable de fonctionner à la fois sur Windows et Linux.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La version 8.0 du serveur monolithique a été remplacée par 3 types de processus - un processus de travail qui sert les clients et 2 processus de service qui prennent en charge le fonctionnement du cluster:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rphost est un workflow au service des clients et exécutant du code d'application. </font><font style="vertical-align: inherit;">Un cluster peut avoir plusieurs workflows, différents workflows peuvent être exécutés sur différents serveurs physiques - en raison de cette évolutivité.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ragent - un processus d'agent de serveur qui démarre tous les autres types de processus, ainsi qu'une première liste de clusters situés sur ce serveur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rmngr est un gestionnaire de cluster qui contrôle le fonctionnement de l'ensemble du cluster (mais le code d'application ne fonctionne pas dessus). </font></font></li>
</ul><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous la coupe se trouve le diagramme de fonctionnement de ces trois processus dans le cluster.</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/mn/yh/tc/mnyhtcaf9zf3_nqddsbfq4xgpsg.png" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant la session, le client a travaillé avec un seul flux de travail, la baisse du flux de travail signifiait pour tous les clients que ce processus servait, la session s'est terminée de façon anormale. </font><font style="vertical-align: inherit;">Les autres clients ont continué de travailler.</font></font><br>
<img src="https://habrastorage.org/webt/wm/tm/mc/wmtmmcct7xd6v2ecl6vi7nlx5dk.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C: Enterprise 8.2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la version 8.2, nous voulions que les applications 1C puissent s'exécuter non seulement dans le client natif (exécutable), mais aussi dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navigateur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sans modifier le code de l'application). </font><font style="vertical-align: inherit;">À cet égard, en particulier, la tâche s'est posée de découpler l'état actuel de l'application de la connexion actuelle avec le flux de travail rphost et de le rendre sans état. </font><font style="vertical-align: inherit;">En conséquence, le concept d'une session et de données de session est apparu qui devait être stocké en dehors du workflow (car il était sans état). </font><font style="vertical-align: inherit;">Un service de données de session a été développé qui stocke et met en cache les informations de session. </font><font style="vertical-align: inherit;">D'autres services sont également apparus - un service de verrous transactionnels gérés, un service de recherche en texte intégral, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette version a également introduit plusieurs innovations importantes - une meilleure tolérance aux pannes, un équilibrage de charge et un mécanisme de redondance de cluster.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tolérance aux pannes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que le processus de travail est devenu sans état et que toutes les données nécessaires au travail ont été stockées en dehors de la connexion client-flux de travail actuelle, en cas de panne de flux de travail, le client est passé à un autre flux de travail "en direct" la prochaine fois qu'il a accédé au serveur. Dans la plupart des cas, un tel commutateur était invisible pour le client.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le mécanisme fonctionne comme ça. Si, pour une raison quelconque, l'appel du client au flux de travail n'a pas pu aboutir, la partie client est en mesure, après avoir reçu une erreur d'appel, de répéter cet appel en rétablissant la connexion au même flux de travail ou à un autre. Mais vous ne pouvez pas toujours répéter un appel; Répéter l'appel signifie que nous avons envoyé l'appel au serveur, mais que nous n'avons pas reçu le résultat. Nous essayons de répéter l'appel, tout en effectuant le deuxième appel, nous évaluons le résultat de l'appel précédent sur le serveur (les informations à ce sujet sont stockées sur le serveur dans les données de session), car si l'appel a eu le temps de «hériter» là (fermer la transaction, enregistrer les données de session etc.) - il est tout simplement impossible de le répéter, cela entraînera une incohérence des données. Si l'appel ne peut pas être répété, le client recevra un message concernant une erreur irrécupérable,et l'application cliente devra redémarrer. Si vous n'avez pas réussi à «hériter» de l'appel (et c'est la situation la plus courante, car de nombreux appels ne modifient pas les données, par exemple, les rapports, l'affichage des données sur un formulaire, etc., et ceux qui modifient les données n'ont pas de transaction ou jusqu'à ce qu'un changement des données de session ait été envoyé au gestionnaire - il n'y a aucune trace de l'appel) - il peut être répété sans risque d'incohérence des données. Si le flux de travail est tombé en panne ou si une connexion réseau a été interrompue, un tel appel est répété et ce «désastre» pour l'application client se produit complètement inaperçu.qui modifient les données - jusqu'à ce que la transaction soit validée ou jusqu'à ce que la modification des données de session soit envoyée au gestionnaire - il n'y a aucune trace de l'appel) - elle peut être répétée sans risque d'incohérence des données. Si le flux de travail est tombé en panne ou si une connexion réseau a été interrompue, un tel appel est répété et ce «désastre» pour l'application client se produit complètement inaperçu.qui modifient les données - jusqu'à ce que la transaction soit validée ou jusqu'à ce que la modification des données de session soit envoyée au gestionnaire - il n'y a aucune trace de l'appel) - elle peut être répétée sans risque d'incohérence des données. Si le flux de travail est tombé en panne ou si une connexion réseau a été interrompue, un tel appel est répété et ce «désastre» pour l'application client se produit complètement inaperçu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'équilibrage de charge</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tâche d'équilibrage de charge dans notre cas est la suivante: un nouveau client entre dans le système (ou un client déjà en fonction fait un autre appel). </font><font style="vertical-align: inherit;">Nous devons choisir le serveur et le workflow auxquels envoyer l'appel du client afin de fournir au client une vitesse maximale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une tâche standard pour un cluster à charge équilibrée. </font><font style="vertical-align: inherit;">Il existe plusieurs algorithmes typiques pour le résoudre, par exemple:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Round-Robin ()</a> –    ,      ,   –    . .    .           .    ,          «» .           (   )    .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Weighted Round Robin</a> –  Round-Robin:          ,    ́    .</li>
<li>Least Connections:     ,       .</li>
<li>Least Response Time:       :    ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour notre cluster, nous avons choisi un algorithme qui est essentiellement proche du temps de réponse le plus faible. Nous avons un mécanisme qui collecte des statistiques sur les performances des workflows sur tous les serveurs du cluster. Il effectue un appel de référence à chaque processus serveur du cluster; l'appel de référence implique un sous-ensemble des fonctions du sous-système de disque, de la mémoire, du processeur et évalue la rapidité avec laquelle un tel appel est effectué. Le résultat de ces mesures, moyenné au cours des 10 dernières minutes, est un critère - quel serveur du cluster est le plus productif et préféré pour lui envoyer des connexions client dans une période de temps donnée. Les demandes des clients sont réparties de manière à mieux charger le serveur le plus productif - chargez celui qui a de la chance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La demande du nouveau client est adressée au serveur le plus productif du moment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une demande d'un client existant est dans la plupart des cas adressée à ce serveur et au workflow auquel sa demande précédente a été adressée. </font><font style="vertical-align: inherit;">Un ensemble complet de données sur le serveur est associé à un client qui fonctionne; le transférer entre des processus (et plus encore entre des serveurs) est assez cher (bien que nous puissions le faire aussi). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une demande d'un client existant est transférée vers un autre workflow dans deux cas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a plus de processus: le workflow avec lequel le client a précédemment interagi n'est plus disponible (le processus est tombé, le serveur est devenu indisponible, etc.).</font></font></li>
<li>   :     ,            ,     ,   ,              .         ,  ,     –             .    –      (..   ).</li>
</ol><br>
<br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons décidé d'augmenter la résilience du cluster en recourant au schéma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actif / passif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il y avait une opportunité de configurer deux clusters - fonctionnant et réservant. </font><font style="vertical-align: inherit;">Si le cluster principal n'est pas disponible (problèmes de réseau ou, par exemple, maintenance planifiée), les appels clients sont redirigés vers le cluster de sauvegarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, cette conception était assez difficile à configurer. </font><font style="vertical-align: inherit;">L'administrateur a dû assembler manuellement deux groupes de serveurs en clusters et les configurer. </font><font style="vertical-align: inherit;">Parfois, les administrateurs ont fait des erreurs en définissant des paramètres conflictuels, comme </font><font style="vertical-align: inherit;">il n'y avait pas de mécanisme centralisé pour vérifier les paramètres. </font><font style="vertical-align: inherit;">Mais, néanmoins, cette approche a augmenté la tolérance aux pannes du système.</font></font><br>
<img src="https://habrastorage.org/webt/ik/k7/06/ikk7062chdd8qtpk0kzvfncq7vu.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C: Enterprise 8.3</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la version 8.3, nous avons considérablement réécrit le code côté serveur responsable de la tolérance aux pannes. Nous avons décidé d'abandonner le schéma de cluster actif / passif en raison de la complexité de sa configuration. Un seul cluster tolérant aux pannes est resté dans le système, composé d'un nombre quelconque de serveurs - ce qui est plus proche du schéma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actif / actif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans lequel les demandes pour un nœud défaillant sont réparties entre les nœuds de travail restants. Pour cette raison, le cluster est devenu plus facile à configurer. Un certain nombre d'opérations qui augmentent la tolérance aux pannes et améliorent l'équilibrage de charge sont devenues automatisées. Des innovations importantes:</font></font><br>
<br>
<ul>
<li>   « »: , ,               .                ,           «»          .</li>
<li>     ,  ,            .</li>
<li>  ,     ,     ,   ,   ,    :</li>
</ul><br>
<img src="https://habrastorage.org/webt/o7/aw/pz/o7awpzltn3jxnderotcyf_wbahm.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/v5/kc/rj/v5kcrjv3ldm96l3ovj1seqobrga.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'idée principale de ces développements est de simplifier le travail de l'administrateur, lui permettant de configurer le cluster dans des termes qui lui sont familiers, au niveau du fonctionnement du serveur, sans descendre plus bas, et aussi de minimiser le niveau de «contrôle manuel» du travail du cluster, en donnant au cluster des mécanismes pour résoudre la plupart des tâches et problèmes possibles » sur le pilote automatique. "</font></font><br>
<br>
<img src="https://habrastorage.org/webt/da/9i/zy/da9izy3cj4wlf80nr8s35tqnp3e.png" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois maillons de tolérance aux pannes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous le savez, même si les composants du système sont fiables séparément, des problèmes peuvent survenir lorsque les composants du système se causent mutuellement. </font><font style="vertical-align: inherit;">Nous voulions minimiser le nombre de places critiques pour les performances du système. </font><font style="vertical-align: inherit;">Une considération supplémentaire importante était la minimisation des altérations des mécanismes appliqués dans la plate-forme et l'exclusion des changements dans les solutions appliquées. </font><font style="vertical-align: inherit;">Dans la version 8.3, il y avait 3 liens pour assurer la tolérance de panne «au niveau des joints»:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kb/1g/s1/kb1gs1mfus_rsminiyizg4t5dma.png" alt="image"><br>
<ol>
<li>  ,   HTTP(S),  -.   -     -.    ,   HTTP  -,    (     HTTP)    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libcurl</a>    . </li>
<li>  ,                     .</li>
<li>  -   .       1,   -     .    -            .       ,         .           ,     –    .    -         (,     ,   ,         ) –          .</li>
<li>     ,    rmngr.    20 (    ) —   ,     ..                .     1:          .</li>
</ol><br>
<br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce au mécanisme de tolérance aux pannes, les applications créées sur la plate-forme 1C: Enterprise survivent avec succès à divers types de défaillances des serveurs de production du cluster, tandis que la plupart des clients continuent de fonctionner sans redémarrer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a des situations où nous ne pouvons pas répéter l'appel, ou un crash de serveur attrape la plateforme à un moment très malheureux, par exemple, au milieu d'une transaction et il n'est pas très clair que faire avec eux. Nous essayons d'assurer une survie statistiquement satisfaisante des clients lorsque les serveurs tombent dans le cluster. En règle générale, la perte moyenne de clients en cas de défaillance du serveur est de quelques pour cent. Dans ce cas, tous les clients "perdus" peuvent continuer à fonctionner dans le cluster après le redémarrage de l'application cliente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fiabilité du cluster de serveurs 1C dans la version 8.3 a considérablement augmenté. </font><font style="vertical-align: inherit;">Il n'est pas rare depuis longtemps d'introduire des produits 1C, où le nombre d'utilisateurs travaillant simultanément atteint plusieurs milliers. </font><font style="vertical-align: inherit;">Il existe des implémentations dans lesquelles 5 000 et 10 000 utilisateurs travaillent simultanément - par exemple, l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction à Beeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où l'application 1C: Trade Management dessert tous les </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">points de</font></a><font style="vertical-align: inherit;"> vente Beeline en Russie, ou la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mise en œuvre de Business Lines chez le transporteur de marchandises.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où l'application, créée de manière indépendante par les développeurs du département informatique des métiers sur la plateforme 1C: Enterprise, dessert le cycle complet du transport de marchandises. </font><font style="vertical-align: inherit;">Nos tests de charge de cluster interne simulent le fonctionnement simultané de jusqu'à 20 000 utilisateurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusion, je voudrais énumérer brièvement ce qui est utile dans notre cluster (la liste est incomplète):</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>,         . ,             ,   .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> – ,   ,   ,   (      – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a>  ..)      . ,   ,      (, )     ,   ERP, ,           ERP.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> – ,     (,  ,    ..).  ,  ,    ,     ,   ,        .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492994/index.html">Nouveautés de TestMace, partie 1. Synchronisation dans le cloud, interface mise à jour, etc.</a></li>
<li><a href="../fr492996/index.html">Marshaling et dé-marshalling des formats de date personnalisés dans Go</a></li>
<li><a href="../fr492998/index.html">Comment nous nous sommes trompés sur la pige pour un centre de données et ce qui en est arrivé</a></li>
<li><a href="../fr493000/index.html">Méthodes de traitement du code hérité en utilisant GitLab comme exemple</a></li>
<li><a href="../fr493002/index.html">350 personnes à distance: comment c'était</a></li>
<li><a href="../fr493010/index.html">Comment Quarkus combine la programmation impérative et réactive</a></li>
<li><a href="../fr493012/index.html">Air, relais, câble par la fenêtre: comment ne pas tomber sur un fournisseur monopoliste dans un centre d'affaires</a></li>
<li><a href="../fr493014/index.html">Entretien avec Vyacheslav Utochkin, directeur des programmes de développement éducatif à la Higher School of Economics, Higher School of Economics, Higher School of Economics; 20 questions sur Gamedev</a></li>
<li><a href="../fr493016/index.html">La rubrique «Lisez des articles pour vous». Janvier - février 2020</a></li>
<li><a href="../fr493018/index.html">Le développeur a apprécié la complexité des navigateurs modernes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>