<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå•Ô∏è üë©üèΩ‚Äç‚öñÔ∏è üêî Wie wir das Problem des nicht initialisierten Stapelspeichers in Windows l√∂sen üôèüèª üë©‚Äçüè´ üë≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Hinweis werde ich erl√§utern, wie Microsoft die mit nicht initialisiertem Stapelspeicher verbundenen Sicherheitsl√ºcken beseitigt und warum wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie wir das Problem des nicht initialisierten Stapelspeichers in Windows l√∂sen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Hinweis werde ich erl√§utern, wie Microsoft die mit nicht initialisiertem Stapelspeicher verbundenen Sicherheitsl√ºcken beseitigt und warum wir dies √ºberhaupt tun.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vereinfachung der Navigation ist die Notiz in Abschnitte unterteilt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten mit nicht initialisiertem Speicher: Problemverlauf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhilfe bei nicht initialisierten Speicherschwachstellen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - automatische Initialisierung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessante Beobachtungen zur Verwendung von InitAll</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistungsoptimierungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerwert</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zukunftspl√§ne</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Arbeit w√§re ohne eine enge Zusammenarbeit zwischen Visual Studio, Windows und MSRC nicht m√∂glich gewesen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten mit nicht initialisiertem Speicher: Problemverlauf</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Erstellung der Programmiersprachen C und C ++ lag der Schwerpunkt auf hoher Geschwindigkeit und flexibler Steuerung durch den Entwickler. </font><font style="vertical-align: inherit;">Aus diesem Grund erzwingen diese Sprachen keine Variableninitialisierung. </font><font style="vertical-align: inherit;">Das Arbeiten mit nicht initialisierten Variablen f√ºhrt zu undefiniertem Verhalten, daher m√ºssen sie vor der Verwendung initialisiert werden, und die Verantwortung f√ºr die Einhaltung dieser Regel liegt vollst√§ndig beim Entwickler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sicherheitsl√ºcken im Zusammenhang mit nicht initialisiertem Speicher werden auf zwei Typen reduziert:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offenlegung von Inhalten: Daten, die in nicht initialisierten Speicherbereichen gespeichert sind, werden au√üerhalb des vertrauensw√ºrdigen Bereichs kopiert und Personen bekannt, die nicht √ºber die entsprechende Berechtigung verf√ºgen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direkte Verwendung von nicht initialisiertem Speicher. </font><font style="vertical-align: inherit;">Beispiel: Schreiben mit nicht initialisiertem Zeiger.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu verstehen, dass Probleme auftreten k√∂nnen, unabh√§ngig davon, ob Speicher auf dem Stapel oder auf dem Heap zugewiesen ist. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um Stapelspeicher, und als n√§chstes werden wir √ºber Heap sprechen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr die Verwendung eines nicht initialisierten Speichers</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> size;  <font></font>
GetSize(&amp;size); <span class="hljs-comment">//       ?</span>
<span class="hljs-built_in">memcpy</span>(dest, src, size); <span class="hljs-comment">//  memcpy </span>
                         <span class="hljs-comment">//  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem hierbei ist, dass, wenn die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSize-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">der Variablen 'size' nicht in allen Zweigen des Programms einen Wert </font><i><font style="vertical-align: inherit;">zuweist</font></i><font style="vertical-align: inherit;"> , eine </font><font style="vertical-align: inherit;">nicht initialisierte Gr√∂√üe an den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufruf √ºbergeben wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aus diesem Grund kann ein Lese- oder Schreibfehler au√üerhalb des Puffers auftreten, wenn der Wert von 'size' gr√∂√üer als der Puffer 'src' oder 'dest' ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr eine nicht initialisierte Speichererweiterung</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
      <span class="hljs-keyword">uint8_t</span> field1;
      <span class="hljs-keyword">uint64_t</span> field2;<font></font>
};<font></font>
mystruct s {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">memcpy</span>(dest, &amp;s, <span class="hljs-keyword">sizeof</span>(s));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">kopiert eine Struktur au√üerhalb eines vertrauensw√ºrdigen Bereichs (d. H. Vom Kernelmodus in den Benutzermodus). Auf den ersten Blick scheint die Struktur vollst√§ndig initialisiert zu sein, aber zwischen 'field1' und 'field2' hat der Compiler Platzhalterbytes eingef√ºgt, die nicht explizit initialisiert wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis des Aufrufs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzhalterbytes werden zusammen mit ihrem nicht initialisierten Inhalt, der zuvor in diese virtuellen Adressen geschrieben wurde, au√üerhalb des vertrauensw√ºrdigen Bereichs kopiert. </font><font style="vertical-align: inherit;">Dies kann beispielsweise ein Teil eines geheimen Verschl√ºsselungsschl√ºssels (der im Benutzermodus sichtbar wird), ein Zeiger (der die ASLR zerst√∂rt) oder etwas anderes sein. </font><font style="vertical-align: inherit;">In einigen F√§llen kann leicht nachgewiesen werden, dass keine besonders kritischen Daten √ºbertragen werden, in anderen F√§llen ist dies sehr schwierig. </font><font style="vertical-align: inherit;">Auf jeden Fall ist es undankbar herauszufinden, wie ernst das Problem mit dem nicht initialisierten Ged√§chtnis ist, und wir w√ºrden gerne etwas anderes tun.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht initialisierte Speicherfehlerstatistik</font></font></h3><br>
<p><img src="https://habrastorage.org/webt/hb/la/gn/hblagnxiqxpsgewdennaq6tx8o8.png" alt="Bild 8"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: In dieser Abbildung bedeutet die Verwendung von nicht initialisiertem Speicher beide Arten von Problemen: direkte Verwendung und Offenlegung von Inhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den letzten Jahren hat die Anzahl solcher Fehler zugenommen. </font><font style="vertical-align: inherit;">Dies ist wahrscheinlich teilweise auf das wachsende Interesse der Forscher an ihnen und infolgedessen auf die Entstehung wirksamer Werkzeuge f√ºr ihre Suche zur√ºckzuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine detailliertere Klassifizierung dieser Fehler zeigt einige interessantere Trends.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/od/bg/sq/odbgsqun-kof4vx6j8ws_v9d9f8.png" alt="Bild 6"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: In diesem Diagramm beinhaltet die Verwendung von nicht initialisiertem Speicher NICHT die Offenlegung seines Inhalts.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/rl/ql/ee/rlqleezbmgk3oeo-bxztqaaphry.png" alt="Bild 5"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns diese Diagramme ansehen, k√∂nnen wir die folgenden Schlussfolgerungen ziehen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwischen 2017 und 2018 machten nicht initialisierte Speicherschwachstellen ungef√§hr 5-10% aller Schwachstellen in Microsoft-Berichten aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schwachstellen im Zusammenhang mit der Speicherzuweisung auf dem Stapel und die Schwachstellen im Zusammenhang mit der Speicherzuweisung auf dem Heap / Pool erwiesen sich als nahezu gleich.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt mehr F√§lle, in denen der Inhalt eines nicht initialisierten Speichers offengelegt wird, als F√§lle, in denen ein nicht initialisierter Speicher verwendet wird.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zus√§tzliche Literatur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ausf√ºhrlichere Einf√ºhrung in das Thema finden Sie in den folgenden Ressourcen:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhilfe bei nicht initialisierten Speicherschwachstellen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie versuchten die beschriebenen Probleme auf verschiedene Weise zu l√∂sen.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Analyse (sowohl w√§hrend als auch nach der Kompilierung)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code-Review</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatische Initialisierung</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Analyse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft verwendet zahlreiche statische Analysatorwarnungen, um nicht initialisierte Variablen abzufangen (einschlie√ülich C4700, C4701, C4703, C6001, C26494 und C26495). </font><font style="vertical-align: inherit;">Diese Diagnosen sind konservativ, d.h. </font><font style="vertical-align: inherit;">Um das Rauschen zu reduzieren, ignorieren sie einige Muster, die zu nicht initialisiertem Speicher f√ºhren k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurden auch eine Reihe strenger Regeln f√ºr den statischen Analysator </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semmle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geschrieben </font><font style="vertical-align: inherit;">, die auf einigen Windows-Codebasen ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Diese Diagnosen verursachen jedoch viel Rauschen und es ist schwierig, gro√üe Mengen an Code zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist die Einhaltung dieser Regeln und die Korrektur von Fehlern sehr zeitaufw√§ndig. </font><font style="vertical-align: inherit;">Als Ergebnis stellte sich heraus, dass es schwierig und teuer ist, sie zu verwenden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, ist das Fuzzing schwer zu skalieren. </font><font style="vertical-align: inherit;">Gute Fuzzers sind teuer in der Wartung und m√ºssen f√ºr bestimmte Aufgaben angepasst werden. </font><font style="vertical-align: inherit;">Mit einer Codebasis von Gr√∂√üen wie der von Microsoft ist es sehr schwierig, sie vollst√§ndig mit Fuzzing zu bedecken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn es m√∂glich w√§re, den gesamten Code perfekt mit ihnen abzudecken, k√∂nnen Fuzzers die Offenlegung des Inhalts des nicht initialisierten Speichers nicht erkennen, da dies nicht zu einem Programmabsturz f√ºhrt. </font><font style="vertical-align: inherit;">Um solche Defekte mithilfe von Fuzzing zu erkennen, ist eine von zwei L√∂sungen erforderlich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazzer, der das Protokoll versteht und die R√ºckgabe von nicht initialisiertem Speicher (oder vielmehr unerwarteten Daten) in das Protokoll erkennen kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein dynamischer Analysator, der den Zugriff auf nicht initialisierten Speicher erkennen kann.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code-Review</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Code√ºbersicht ist nicht skalierbar und √§u√üerst fehleranf√§llig. </font><font style="vertical-align: inherit;">Code mit Schwachstellen wird √ºberpr√ºft, aber sie sind so gut getarnt, dass Programmierer sie nicht bemerken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Teil des Codes, in dem wir auf die Offenlegung des Inhalts von nicht initialisiertem Speicher gesto√üen sind, wurde in den Tagen von 32-Bit-Windows zur√ºckgeschrieben, und es gab damals keine derartigen Fehler. </font><font style="vertical-align: inherit;">Beim √úbergang zu 64-Bit-Architekturen wurde die Gr√∂√üe der Zeiger von 32 auf 64 Bit erh√∂ht, weshalb einige Strukturen nicht initialisierte Platzhalterfelder aufweisen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - Automatische Initialisierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zu den genannten Ans√§tzen verwendet Microsoft seit einiger Zeit einen Mechanismus namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der </font><i><font style="vertical-align: inherit;">Stapelvariablen</font></i><font style="vertical-align: inherit;"> in der Kompilierungsphase automatisch initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Abschnitt werde ich beschreiben, wie diese Technologie in Windows verwendet wird und warum auf diese Weise.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuelle Windows-Einstellungen:</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Typen werden automatisch initialisiert:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalar (Arrays, Zeiger, Gleitkommazahlen)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiger-Arrays</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturen (einfache Datenstrukturen - POD)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Typen werden nicht automatisch initialisiert:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fl√ºchtige Variablen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays anderer Typen als Zeiger (d. H. Arrays von ganzen Zahlen, Arrays von Strukturen usw.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassen, die nicht POD sind</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In optimierten Einzelhandelsbaugruppen werden Variablen mit einem Wert von 0 initialisiert. F√ºr Gleitkommazahlen wird ein Wert von 0,0 verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debugging (CHK) -Baugruppen oder Baugruppen f√ºr Entwickler (d. H. Nicht optimierte Einzelh√§ndler) verwenden den Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xE2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Gleitkommazahlen werden auf 1,0 initialisiert. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gilt f√ºr folgende Komponenten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Code aus dem Windows-Repository wird im Kernelmodus ausgef√ºhrt (d. H. Der gesamte Code, der mit dem Schalter / KERNEL kompiliert wird). </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Hyper-V-bezogenen Codes (Hypervisor, Kernelmoduskomponenten, Benutzermoduskomponenten)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe anderer Projekte, z. B. Netzwerkdienste im Benutzermodus</font></font></li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> am Frontend des Compilers implementiert. </font><font style="vertical-align: inherit;">Alle Variablen, die die oben aufgef√ºhrten Kriterien erf√ºllen und nicht vom Programmierer initialisiert werden, werden bei der Deklaration vom Frontend initialisiert. </font><font style="vertical-align: inherit;">Einer der Vorteile dieses Ansatzes besteht darin, dass sich die automatische Initialisierung aus Sicht des Optimierers nicht von der Initialisierung durch den Entwickler unterscheidet. </font><font style="vertical-align: inherit;">Daraus folgt, dass die Optimierungen, die wir zur Beschleunigung der Arbeit mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzuf√ºgen, </font><font style="vertical-align: inherit;">nicht nur an diese Funktion gebunden sind und in den F√§llen funktionieren, in denen Sie die Variablen beim Deklarieren (oder vor der Verwendung) selbst initialisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie vermeiden wir das Sprachgabelproblem?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Haken bei der automatischen Nullinitialisierung: Null ist eine spezielle Bedeutung in einer Programmiersprache, insbesondere f√ºr Zeiger. Und dies ist vielleicht der h√§ufigste Wert, der einzelne Variablen initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Initialisierung auf Null kann ein Zeiger, der vom Programmierer nicht korrekt initialisiert wurde, in den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL-Zeigerzweig fallen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Als Ergebnis k√∂nnen Sie ein Programm erhalten, das nicht abst√ºrzt, aber nicht die gew√ºnschten Ergebnisse liefert. Wenn Sie den Zeiger mit einem Garbage-Wert initialisieren, f√§llt er nicht in den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL-Zeigerzweig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und f√ºhrt beim Versuch, ihn zu verwenden, zum Absturz des Programms.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir l√∂sen dieses Problem, indem wir einen Initialisierungswert ungleich Null (0xE2) in CHK-Builds und sogenannte Builds f√ºr Entwickler verwenden, bei denen es sich h√§ufig um nicht optimierte Release-Builds handelt. Aus diesem Grund ist es einerseits m√∂glich, eine hohe Leistung des an Clients gelieferten Codes aufrechtzuerhalten und andererseits ein Verhalten in Baugruppen zu erhalten, die getestet werden, wodurch es einfacher wird, verpasste Initialisierungen zu erkennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle fest, dass C ++ bereits eine automatische Nullinitialisierung aller statischen Elemente erfordert. </font><font style="vertical-align: inherit;">Diese Semantik hilft Entwicklern. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise eine statische Variable mit dem Wert Null sehen, wissen Sie, dass Sie sie initialisieren m√ºssen, da dies ihre erste Verwendung ist. </font><font style="vertical-align: inherit;">InitAll f√ºhrt eine √§hnliche Semantik f√ºr automatische (Stapel-) Variablen mit einer wichtigen Einschr√§nkung ein: Wir versuchen, Entwickler nicht an bestimmte Anfangswerte zu binden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir ausw√§hlen, f√ºr welche Komponenten InitAll verwendet werden soll</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Urspr√ºnglich war </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr zwei Komponenten geplant:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel-Modus-Code - haupts√§chlich aufgrund der gro√üen Anzahl beobachteter Sicherheitsl√ºcken im Zusammenhang mit nicht initialisiertem Kernel-Speicher.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyper-V-Code ist in erster Linie auf seine Bedeutung f√ºr Azure und auf entt√§uschende aktuelle Statistiken zu F√§llen der Offenlegung des Inhalts von nicht initialisiertem Stapelspeicher zur√ºckzuf√ºhren.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige bei Microsoft </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfuhren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font><i><font style="vertical-align: inherit;">InitAll</font></i><font style="vertical-align: inherit;"> und begannen, es aktiv auf ihren Komponenten zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund, warum wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht </font><font style="vertical-align: inherit;">sofort f√ºr den gesamten Code </font><font style="vertical-align: inherit;">bereitstellen, </font><font style="vertical-align: inherit;">ist, dass wir zuerst mindestens etwas </font><i><font style="vertical-align: inherit;">Gutes</font></i><font style="vertical-align: inherit;"> tun wollen und nicht scheitern wollen, indem wir versuchen, alles auf einmal zu tun. </font><font style="vertical-align: inherit;">Je mehr Code wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleichzeitig verarbeiten, desto schwieriger ist es, Leistungseinbu√üen zu debuggen, Kompatibilit√§tsprobleme zu l√∂sen usw. </font><font style="vertical-align: inherit;">Nachdem wir die Technologie erfolgreich auf den wichtigsten Komponenten implementiert haben, k√∂nnen Sie den Rest des Codes ausf√ºhren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterbricht InitAll die statische Analyse?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die statische Analyse ist √§u√üerst n√ºtzlich, da sie Entwickler an Variablen erinnert, die sie vor der Verwendung vergessen haben, zu initialisieren. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benachrichtigt sowohl den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREfast-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analysator </font><font style="vertical-align: inherit;">als auch das Compiler-Backend (beide geben Warnungen vor nicht initialisierten Variablen aus) √ºber die hinzugef√ºgten Initialisierungen. </font><font style="vertical-align: inherit;">Dank dessen k√∂nnen statische Analysatoren solche Stellen ignorieren und dennoch ihre Warnungen geben. </font><font style="vertical-align: inherit;">Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll aktiviert ist, erhalten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie weiterhin statische Analysatormeldungen zu nicht initialisierten Variablen - auch wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese f√ºr Sie initialisiert hat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum wir nicht alle Typen initialisieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend vorl√§ufiger Tests haben wir alle auf dem Stapel zugewiesenen Datentypen mit Nachdruck initialisiert und in mehreren wichtigen Szenarien Leistungsabf√§lle von mehr als 10% festgestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn nur POD-Strukturen initialisiert w√ºrden, w√ºrde die Leistung nicht so stark sinken, und Compiler-Optimierungen, die darauf abzielen, die Anzahl unn√∂tiger Schreibvorg√§nge (sowohl innerhalb als auch zwischen den Basiseinheiten) zu reduzieren, erm√∂glichten es uns, die Verlangsamung von einer erkennbaren Ebene auf die Fehlerstufe in weiter zu reduzieren die meisten Tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir planen, auf die Idee zur√ºckzukommen, alle Typen zu initialisieren (insbesondere jetzt, wo wir leistungsf√§higere Optimierungen haben). Wir haben diesen Punkt einfach noch nicht erreicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum initialisieren wir Variablen mit Null?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Initialisieren auf Null liefert die besten Ergebnisse in Bezug auf die Leistung (sowohl in Bezug auf Geschwindigkeit und Bin√§rgr√∂√üe) als auch in Bezug auf die Sicherheit.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus sicherheitstechnischer Sicht</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Nullinitialisierung bietet die folgenden Vorteile:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Nullzeiger l√∂st beim Dereferenzieren unter Windows eine SEH-Ausnahme aus (d. H. Im schlimmsten Fall f√ºhrt dies zu einem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denial-of-Service-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler </font><font style="vertical-align: inherit;">, eine Remotecodeausf√ºhrung ist jedoch nicht m√∂glich), der normalerweise mit einem Programmabsturz endet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Variable, die eine Gr√∂√üe oder einen Index angibt, erh√§lt einen Nullwert. </font><font style="vertical-align: inherit;">Dies sollte das Risiko minimieren, dass nicht initialisierte Gr√∂√üe an Funktionen wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy √ºbergeben wird,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die mit einem Puffer arbeiten, dessen Gr√∂√üe durch den Wert der √ºbergebenen Variablen angegeben wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem √úberpr√ºfen des Nullzeigers f√ºhrt das Programm den entsprechenden Zweig aus und versucht nicht, ihn zu verwenden. </font><font style="vertical-align: inherit;">Zumindest ist es also m√∂glich, die vom Entwickler vergessenen Zeiger korrekt zu verarbeiten (da ein Versuch, mit einem automatisch initialisierten Zeiger auf den Speicher zuzugreifen, immer zu einem Absturz f√ºhrt).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen vom Typ Boolean mit dem Wert 0 bedeuten "false", was in Tests auf einen Fehlerzustand hinweisen kann.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung mit Null hat auch einige Nachteile:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Variable NTSTATUS hat den Wert STATUS_SUCCESS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HRESULT wird S_OK sein </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die R√ºckgabewerte k√∂nnen jedoch sehr unterschiedlich sein, und es gibt keinen einzigen universellen Wert, mit dem alle initialisiert werden k√∂nnen, insbesondere wenn man bedenkt, dass sie auch f√ºr Gr√∂√üen, Indizes, Zeiger usw. verwendet werden m√ºssen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Sicht der Leistung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Programmgeschwindigkeit und die Codegr√∂√üe h√§ngen auch vom ausgew√§hlten Initialisierungswert ab. </font><font style="vertical-align: inherit;">Wir haben nicht gemessen, wie schlechter die Ergebnisse bei Verwendung eines Werts ungleich Null waren, da wir haupts√§chlich an den Sicherheitsvorteilen interessiert waren, die die Initialisierung mit Null ergibt, und wir wussten, dass dies gleichzeitig die Leistung (sowohl Geschwindigkeit als auch Codegr√∂√üe) positiv beeinflussen w√ºrde. </font><font style="vertical-align: inherit;">Unsere Kollegen von Google haben Messungen durchgef√ºhrt und gezeigt, dass bei Clang die Initialisierung mit Null derzeit sp√ºrbar rentabler ist als die Initialisierung mit einem Wert ungleich Null. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Folgenden werde ich anhand von Beispielen zeigen, warum beim Initialisieren mit Null weniger Code erhalten wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel 1: Initialisierung mit Universalregistern</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung durch Null:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">31</span> c0                            <span class="hljs-keyword">xor</span>    eax,eax
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung mit einem Wert ungleich Null:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> b8 e2 e2 e2 e2 e2 e2 e2 e2    movabs rax,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel interessieren uns zwei Punkte: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens ben√∂tigt das Setzen des RAX-Registers auf Null 2 ‚Äã‚ÄãByte Code gegen√ºber 10 Byte, wenn der Wert nicht Null ist. Es stellt sich heraus, dass sowohl die Codegr√∂√üe als auch die Geschwindigkeit zunehmen. Viele Prozessoren lesen Befehle mit jeweils 16 Bytes. Wenn Sie also eine feste Konstante mit einem 10-Byte-Befehl in das Register schreiben, werden die folgenden Befehle nicht ausgegeben, die parallel ausgef√ºhrt werden k√∂nnten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens m√ºssen Sie warten, bis der Schreibvorgang in RAX abgeschlossen ist, bevor der Wert in das RCX-Register geschrieben werden kann, was zu einem Leerlauf des Prozessors f√ºhren kann. </font><font style="vertical-align: inherit;">Sequenzen wie "xor eax, eax" werden an den fr√ºhesten Stellen der Pipeline erkannt, und eine echte Ausf√ºhrung des XOR-Befehls ist nicht erforderlich - die Prozessoren setzen einfach das RAX-Register zur√ºck. </font><font style="vertical-align: inherit;">Infolgedessen ist die Pipeline weniger inaktiv und das Programm l√§uft schneller.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel 2: Initialisierung mit XMM-Registern</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um gr√∂√üere Werte zu schreiben, verwendet der Compiler normalerweise XMM-Register (sowie YMM oder ZMM, je nachdem, ob die Unterst√ºtzung f√ºr die AVX- oder AVX512-Befehlss√§tze aktiviert ist). </font><font style="vertical-align: inherit;">In der Regel k√∂nnen Prozessoren nicht mehr als einen Schreibbefehl in einem Taktzyklus ausf√ºhren. Es ist daher ratsam, Befehle zu verwenden, die so viele Bytes wie m√∂glich festlegen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung durch Null:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">0f</span> <span class="hljs-number">57</span> c0                         xorps  xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung mit einem Wert ungleich Null (wird aus einer globalen Variablen geladen, was Compiler normalerweise tun):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">66</span> <span class="hljs-number">0f</span> <span class="hljs-number">6f</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movdqa xmm0,XMMWORD PTR ds:<span class="hljs-number">0x0</span>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung mit einem Wert ungleich Null (geladen von einer festen Konstante im Code, was Compiler nicht tun):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> ba e2 e2 e2 e2 e2 e2 e2 e2    movabs rdx,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">66</span> <span class="hljs-number">48</span> <span class="hljs-number">0f</span> <span class="hljs-number">6</span>e c2                   movq   xmm0,rdx
<span class="hljs-number">0f</span> <span class="hljs-number">16</span> c0                         movlhps xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, wird bei XMM-Registern das gleiche Bild beobachtet. Bei der Initialisierung auf Null ist der Code sehr klein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht m√∂glich, eine feste Konstante direkt in das XMM-Register zu schreiben. Zuerst m√ºssen Sie es im allgemeinen Register speichern, von dort in das XMM-Register verschieben und dann die niedrigen 64 Bit des XMM-Registers in seine hohen 64 Bit kopieren. Als Ergebnis erhalten wir einen langen Code und drei Befehle, von denen jeder warten muss, bis der vorherige abgeschlossen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu vermeiden, speichern Compiler in der Regel eine feste Konstante in Form einer globalen Variablen, aus der sie dann den Wert lesen k√∂nnen - dies f√ºhrt zu viel weniger Code. Leider m√ºssen Sie bis zum Ende des Schreibens in das XMM-Register warten, bevor es zur Verwendung verf√ºgbar wird. Wenn eine globale Variable aus dem Speicher entladen wird, kann die Operation mehrere tausend Taktzyklen dauern. Eine Leseoperation dauert selbst im besten Fall mehrere Taktzyklen, wenn Daten im L1-Cache gespeichert sind. Und selbst in diesem Fall ist der Code viel l√§nger als wenn Sie nur das Register zur√ºcksetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies zeigt einen weiteren Vorteil der Nullinitialisierung: deterministischere Ergebnisse. Die Initialisierungszeit h√§ngt nicht davon ab, ob sich die globale Variable im Cache L1, L2 oder L3 befindet, ob sie aus dem Speicher entladen wird usw.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessante Beobachtungen zur Verwendung von InitAll</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows 10 1903 (ver√∂ffentlicht im Fr√ºhjahr 2019) war die erste Version, in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standardm√§√üig </font><i><font style="vertical-align: inherit;">aktiviert</font></i><font style="vertical-align: inherit;"> war. </font><font style="vertical-align: inherit;">Bisher haben wir keine Beschwerden √ºber Leistungseinbu√üen erhalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompatibilit√§t</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegen Betrug</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz nach dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktivieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font><i><font style="vertical-align: inherit;">InitAll</font></i><font style="vertical-align: inherit;"> unter Windows erhielten wir Beschwerden √ºber </font><i><font style="vertical-align: inherit;">Kernelabst√ºrze</font></i><font style="vertical-align: inherit;"> , die durch einige Anti-Cheat-Programme verursacht wurden. </font><font style="vertical-align: inherit;">Nachdem wir das Problem untersucht hatten, stellten wir fest, dass diese Programme Kernel-Modus-Treiber enthielten, die das NT-Kernel-Image im Speicher durchsuchten und nach bestimmten Byte-Sequenzen suchten, die den Beginn undokumentierter Funktionen anzeigen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºgte zu Beginn dieser Funktionen zus√§tzliche Initialisierungen hinzu (deren Redundanz nicht nachgewiesen werden konnte), aufgrund derer sich ihre Signaturen ge√§ndert haben. </font><font style="vertical-align: inherit;">Wir haben die Entwickler dieser Anti-Cheats kontaktiert und auf unsere Anfrage hin ihre Treiber aktualisiert, damit sie keine Kernelabst√ºrze mehr verursachen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freigegebenen Speicher in FAT32 verwenden</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz nach dem Aktivieren von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr skalare Datentypen (d. H. Ganzzahlen, Gleitkommazahlen usw.) ist im FAT-Dateisystemtreiber ein interessantes Problem aufgetreten, bei dem interne Windows-Assemblys nicht von bootf√§higen USB-Flash-Laufwerken aktualisiert werden konnten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code, in dem das Problem aufgetreten ist, sah ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
{<font></font>
      <span class="hljs-keyword">int</span> tmp;<font></font>
      DoStuff(&amp;tmp, i);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine Schleife, in der eine Variable deklariert wird. Bei der ersten Iteration der Schleife </font><font style="vertical-align: inherit;">initialisiert </font><font style="vertical-align: inherit;">die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoStuff-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">die Variable 'tmp', deren Adresse als Argument an sie √ºbergeben wird. Bei jeder nachfolgenden Iteration wird die Variable 'tmp' als Eingabe- / Ausgabeparameter verwendet. Mit anderen Worten, sein Wert wird zuerst gelesen und dann aktualisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass die betreffende Variable zu Beginn jeder Iteration der Schleife in ihren G√ºltigkeitsbereich eintritt und sie am Ende der Iteration verl√§sst. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialisiert diese Variable vor jeder Iteration auf Null. In der </font><font style="vertical-align: inherit;">Tat erhalten wir eine </font><i><font style="vertical-align: inherit;">use-after freie</font></i><font style="vertical-align: inherit;"> Verwundbarkeit</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">F√ºr den normalen Betrieb des Codes ist es erforderlich, dass die Variable 'tmp' bei jeder Iteration ihren Wert beibeh√§lt, auch wenn sie am Ende der Iteration den G√ºltigkeitsbereich verl√§sst. </font><font style="vertical-align: inherit;">Leider f√ºhrte dieses Problem nicht zu einem Treiberabsturz, sondern zu einer falschen Funktionslogik und damit zu einem unvorhersehbaren Verhalten des Dateisystems. </font><font style="vertical-align: inherit;">W√§hrend des Debuggens hat das Kernel-Team die Ursache des Problems ermittelt und das Problem behoben, indem die Variable aus der Schleife genommen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Fall ist ein gutes Beispiel daf√ºr, wie Sicherheitsverbesserungen Code besch√§digen k√∂nnen, der seit Jahren nicht mehr untersucht wurde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistungsoptimierungen</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Leistungsoptimierungen von </font><i><font style="vertical-align: inherit;">InitAll verfolgen</font></i><font style="vertical-align: inherit;"> drei Ziele:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bieten Sie Entwicklern die M√∂glichkeit, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr kritischen Code </font><font style="vertical-align: inherit;">zu deaktivieren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie nach M√∂glichkeit unn√∂tige Schreibvorg√§nge</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschleunigen Sie die verbleibenden Schreibvorg√§nge so weit wie m√∂glich</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deaktivieren von InitAll f√ºr kritischen Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die offensichtlichsten Optimierungen sind, den Code zu lassen:</font></font><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll vollst√§ndig</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr einen bestimmten Typ (d.h. typedef Struktur)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr alle Speicherzuordnungsoperationen in der Funktion</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr eine bestimmte Variablendeklaration in Abh√§ngigkeit</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
derzeit </font><font style="vertical-align: inherit;">(aus Leistungsgr√ºnden) f√ºr einen einzelnen Typ deaktiviert - die _CONTEXT-Struktur, in der die Werte aller Register gespeichert werden. Die erzwungene Initialisierung f√ºhrte zu einer Leistungsminderung in Tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">hat eine Gr√∂√üe von mehr als 1000 Bytes, und dies reicht aus, um die Werte aller Register zu speichern. Wenn die ETW-Protokollierung aktiviert ist, um Kontextwechsel zu verfolgen, werden bei jeder √Ñnderung eines Kontexts die Werte aller Register protokolliert. Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur wird </font><font style="vertical-align: inherit;">in diesem Fall auf dem Stapel zugewiesen, mit einer Assembler-Funktion </font><i><font style="vertical-align: inherit;">gef√ºllt</font></i><font style="vertical-align: inherit;"> und dann an ETW √ºbergeben. Aufgrund der Tatsache, dass die Struktur von einer Assembler-Funktion initialisiert wird, kann der Compiler die durchgef√ºhrte Initialisierung nicht entfernen</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Da diese Struktur bereits kritische Daten enth√§lt (Status jedes Registers), gro√ü ist und in Zweigen verwendet wird, die extrem hohe Anforderungen an die Leistung stellen, haben wir beschlossen, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht darauf anzuwenden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr alle anderen Typen, Variablen und Funktionen wurde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht </font><i><font style="vertical-align: inherit;">deaktiviert</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen unn√∂tiger Schreibvorg√§nge</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Entfernen unn√∂tiger Schreibvorg√§nge ist eine vom Visual Studio-Compiler durchgef√ºhrte Optimierung, mit der Schreibvorg√§nge entfernt werden, die als redundant erwiesen werden k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Folgenden finden Sie Beispiele f√ºr verschiedene Optimierungsarten, die von Visual Studio verwendet werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Memsets entfernen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zu Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/Ldu7AP</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das folgende Codemuster (mit verschiedenen Variationen) ist √§u√üerst h√§ufig. Anf√§ngliche NT-Programmierregeln erfordern, dass alle Variablen zu Beginn der Funktion deklariert und so sp√§t wie m√∂glich initialisiert werden. Infolgedessen gibt es F√§lle, in denen eine Variable am Anfang einer Funktion deklariert und unmittelbar vor der Verwendung nur in einem Zweig initialisiert wird. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºgt seine Variableninitialisierung am Anfang der Funktion hinzu. Der Compiler kann das Duplikat entfernen, dies ist jedoch nicht immer einfach.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
  <font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/hq/dl/ee/hqdleeuo4icifkr9_ijrp0rt_ps.png" alt="Bild 4"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass dieses einfache Beispiel leicht optimiert werden sollte, jedoch k√∂nnen GCC 9.3 und Clang 10.0.0 (die neuesten auf Godbolt verf√ºgbaren Versionen) in diesem Fall den zus√§tzlichen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufruf nicht entfernen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich spreche nicht dar√ºber, um diese Compiler zu kritisieren - beide optimieren den Code sehr gut. </font><font style="vertical-align: inherit;">Ich m√∂chte nur zeigen, dass einige Muster selbst f√ºr die leistungsst√§rksten Compiler Schwierigkeiten verursachen k√∂nnen. </font><font style="vertical-align: inherit;">Vor dem Aufkommen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den damit verbundenen Optimierungen konnte Visual Studio den zus√§tzlichen Aufruf nicht entfernen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein noch einfacheres Beispiel:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Zwischen zwei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufrufen </font><font style="vertical-align: inherit;">gibt es nur einen Funktionsaufruf ohne Argumente. </font><font style="vertical-align: inherit;">Dieses Muster ist wie das vorherige im Microsoft-Code sehr verbreitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zu Godbolt:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/HqFMx_</font></font></a><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    Dummy();<font></font>
<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    DoStuff(&amp;s);<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fe/qo/7e/feqo7evdydknbjjwx9wwlvxt61a.png" alt="Bild 3"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC entfernt das √ºbersch√ºssige </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in diesem Beispiel. Clang 10.0.0 - auch, aber GCC 9.3 schl√§gt immer noch fehl. Es scheint, dass dieser Code leicht optimiert werden kann, aber daf√ºr muss der Compiler eine nicht triviale Analyse durchf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem hier (in MSVC) ist, dass der Compiler eine Objekterreichbarkeitsanalyse verwendet, unabh√§ngig von Verzweigung oder Thread-Ausf√ºhrung. Aus Sicht des Compilers entkommt die Variable 's' der aktuellen Funktion (mit anderen Worten, ihre Adresse wird irgendwo au√üerhalb dieser Funktion √ºbergeben), da ihre Adresse an die Funktion 'DoStuff' √ºbergeben wird. Der Compiler sieht auch einen Aufruf von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's', dann einen Aufruf von 'Dummy', gefolgt von einem weiteren Aufruf von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's'.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht des Compilers k√∂nnte die Funktion 'Dummy', da die Variable 's' aus der Funktion "entkommen" ist, theoretisch den Inhalt von 's' lesen oder √§ndern, bevor die Funktion 'DoStuff' aufgerufen wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass ein Aufruf von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weder vor noch nach 'Dummy' gel√∂scht werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen sehen, dass, obwohl die Variablen 's' und der aktuellen Funktion "entkommen", dies nicht geschieht, bevor die Funktion 'DoStuff' aufgerufen wird. </font><font style="vertical-align: inherit;">Der MSVC-Compiler versteht dies jetzt auch (bis zu dem einen oder anderen Grad) und kann den ersten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufruf entfernen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduzierung der Memset-Gr√∂√üe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zu Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/fyLVUF</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das folgende Muster ist ebenfalls nicht ungew√∂hnlich. </font><font style="vertical-align: inherit;">Die Struktur wird teilweise initialisiert und dann auf eine andere Funktion √ºbertragen. </font><font style="vertical-align: inherit;">Diese zweite Funktion initialisiert wahrscheinlich den Rest der Strukturdaten (oder liest sie zumindest nicht), aber der Compiler kann dies nicht beweisen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">320</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s)<span class="hljs-number">-0x160</span>);<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/qv/zv/ix/qvzvix4pxzqvazgvfzafdg_zraa.png" alt="Bild 2"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC kann jetzt die Gr√∂√üe des ersten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so </font><i><font style="vertical-align: inherit;">zuschneiden</font></i><font style="vertical-align: inherit;"> , dass nur die Elemente in der Struktur initialisiert werden, die das zweite </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht initialisiert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Auch hier wissen GCC 9.3 und Clang 10.0.0 noch nicht, wie diese Optimierung in diesem Beispiel durchgef√ºhrt werden soll.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effizienterer Memset-Sweep</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu Godbolt.</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Im folgenden Beispiel kann der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufruf </font><font style="vertical-align: inherit;">nicht entfernt werden. </font><font style="vertical-align: inherit;">Es sollte also so effizient wie m√∂glich durchgef√ºhrt werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">12</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
    DoStuff(&amp;s);<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fm/yf/7v/fmyf7vxnqesyecgskxvarcbgyc4.png" alt="Bild 1"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC (wie die meisten Compiler) kann kleine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufrufe </font><font style="vertical-align: inherit;">mit einer statisch definierten Gr√∂√üe und einem </font><i><font style="vertical-align: inherit;">Auff√ºllwert</font></i><font style="vertical-align: inherit;"> ‚Äûbereitstellen‚Äú </font><font style="vertical-align: inherit;">. Das hei√üt, der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufruf </font><font style="vertical-align: inherit;">wird durch eine Folge von Schreibbefehlen direkt in den Speicher ersetzt. Dank dieser Optimierung wird die Ausf√ºhrungszeit kleiner </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufrufe </font><font style="vertical-align: inherit;">(bis zu 128 Byte) mit einer geringeren Codemenge auf ein Viertel des √úblichen reduziert (es ist nicht erforderlich, die Werte der Register auf dem Stapel zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">Memset aufzurufen</font></i><font style="vertical-align: inherit;"> und dann den Status der Register wiederherzustellen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC zum Bereitstellen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf AMD64 unter Verwendung von Allzweckregistern. </font><font style="vertical-align: inherit;">Jetzt werden Vektorregister verwendet, mit denen Sie Anrufe mit der doppelten Gr√∂√üe bereitstellen k√∂nnen. </font><font style="vertical-align: inherit;">Dadurch erhalten wir ein schnelleres </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und lassen den Code nicht wachsen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Produktivere Memset-Implementierungen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. Wir werden dieses Element ein weiteres Mal detailliert </font><b><font style="vertical-align: inherit;">analysieren</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerwert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seit der Ver√∂ffentlichung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden viele der Sicherheitsl√ºcken, die Benutzer an MSRC gemeldet haben, in neueren Windows-Versionen nicht mehr abgespielt. Dank </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben </font><i><font style="vertical-align: inherit;">sich</font></i><font style="vertical-align: inherit;"> diese Sicherheitsl√ºcken von "Sicherheitsproblemen" zu " </font><i><font style="vertical-align: inherit;">Codefehlern entwickelt</font></i><font style="vertical-align: inherit;"> , die derzeit keine negativen Folgen haben". Dies bedeutet, dass wir keine Sicherheitsupdates mehr f√ºr bereits freigegebene Betriebssysteme mit installiertem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereitstellen </font><i><font style="vertical-align: inherit;">m√ºssen</font></i><font style="vertical-align: inherit;"> , wodurch Benutzer vor den Kopfschmerzen </font><i><font style="vertical-align: inherit;">gesch√ºtzt</font></i><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">, die mit der Installation von Patches einhergehen, und Microsoft vor den Kopfschmerzen, die mit ihrer Entwicklung einhergehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unseren aktiven Zweigen des Repositorys verbessern wir weiterhin den Code und beheben Fehler sowie nehmen √Ñnderungen an bereits freigegebenen Betriebssystemen vor, in denen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fehlen und die daher immer noch anf√§llig sind. </font><font style="vertical-align: inherit;">Mit der Zeit werden Versionen ohne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mehr unterst√ºtzt. </font><font style="vertical-align: inherit;">In diesem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">mit </font><i><font style="vertical-align: inherit;">InitAll</font></i><font style="vertical-align: inherit;"> neutralisierte Fehler </font><font style="vertical-align: inherit;">nur in aktiven Entwicklungszweigen korrigiert, und auf aktuellen Systemen muss diese Art von Fehlern nicht mehr behoben werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zukunftspl√§ne</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derzeit planen wir, zwei Hauptaufgaben im Zusammenhang mit Problemen mit nicht initialisierten Stapelvariablen zu behandeln:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untersuchung und Nutzung der M√∂glichkeit, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf alle zugewiesenen Datentypen </font><font style="vertical-align: inherit;">anzuwenden </font><font style="vertical-align: inherit;">(d. H. Arrays aller Typen und Klassen, nicht nur POD)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereitstellen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf allen Windows - </font><font style="vertical-align: inherit;">Code.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zukunft wollen wir herausfinden, ob es m√∂glich ist, den Prozess der Beseitigung der beschriebenen Problemtypen in C und C ++ zu standardisieren. Es ist nicht erforderlich, Variablen aus Leistungsgr√ºnden standardm√§√üig nicht zu initialisieren (insbesondere wenn der Compiler redundante Schreibvorg√§nge gut optimieren kann). Stattdessen ist es besser, vom Entwickler zu verlangen, dass er die Variablen vor der Verwendung initialisiert, "wenn ein solcher Bedarf nachgewiesen wurde", und dass diese Regel nur verletzt wird, wenn ein spezielles Schl√ºsselwort f√ºr nicht initialisierte Variablen verwendet wird. Eine solche L√∂sung w√ºrde eine hohe Leistung bewahren und gleichzeitig Programmierer vor unn√∂tigen Fehlern bewahren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir planen, einen weiteren Hinweis zu den laufenden Arbeiten zur Neutralisierung nicht initialisierter Speicherschwachstellen im Mechanismus zur Zuweisung eines Speicherpools im Windows-Kernel zu ver√∂ffentlichen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommentar des √úbersetzers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel hat fast nichts mit meinem urspr√ºnglichen Thema der statischen Code-Analyse zu tun, aber er schien mir interessant zu sein, und ich wollte die √úbersetzung einem russischsprachigen Publikum zug√§nglich machen. </font><font style="vertical-align: inherit;">Ich m√∂chte selbst hinzuf√ºgen, dass die Sicherheitsprobleme, die mit dem "Leck" privater Daten verbunden sind, normalerweise aus zwei Komponenten bestehen. </font><font style="vertical-align: inherit;">Erstens: Es gibt einen Ort, an dem private Daten gel√∂scht werden sollten, dies geschieht jedoch nicht ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Zweitens: Ungereinigte private Daten als Teil des nicht initialisierten Speichers k√∂nnen irgendwohin √ºbertragen werden ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505476/index.html">CRUD API auf Deno und PostegreSQL: Arbeiten mit einem Dinosaurier</a></li>
<li><a href="../de505478/index.html">Ersetzen eines CRM-Systems durch ein CRM-System</a></li>
<li><a href="../de505488/index.html">12 Tipps zum Implementieren von TypeScript in React-Anwendungen</a></li>
<li><a href="../de505494/index.html">Entwickler-Framing</a></li>
<li><a href="../de505496/index.html">Flutter Dev Podcast mit CTO Meduza Boris Goryachev: Die Hauptsache √ºber die Meduz-Anwendung und die Medienentwicklung</a></li>
<li><a href="../de505502/index.html">Omnichannel im Kundenservice: Worauf muss man achten und wie kann man alles richtig machen?</a></li>
<li><a href="../de505506/index.html">Er bei√üt nicht: wie man Industrieroboter f√ºr Arbeiter sicher macht</a></li>
<li><a href="../de505508/index.html">Nicht nur unbemannte Technologie: Die Zukunft der Automobilindustrie</a></li>
<li><a href="../de505510/index.html">Optimierung der Check Point-API mit dem Python SDK</a></li>
<li><a href="../de505516/index.html">Maschinelles Lernen: Wo soll ich anfangen oder wie erstelle ich das erste Modell?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>