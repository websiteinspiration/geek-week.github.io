<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¢ üê∏ üïç How TCP Reset Attack Works üßúüèø üòë üåû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A TCP reset attack is performed using a single data packet of no more than a few bytes in size. The TCP segment replaced by spoofing, created and tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How TCP Reset Attack Works</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499902/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A TCP reset attack is performed using a single data packet of no more than a few bytes in size. </font><font style="vertical-align: inherit;">The TCP segment replaced by spoofing, created and transmitted by the attacker, tricks the two victims to end the TCP connection, interrupting the connection between them, which could be critical.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/768/854/d0e7688544d90ce84fd01f7aae77b348.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This attack had consequences in the real world. </font><font style="vertical-align: inherit;">Fears of its use were caused by the introduction of changes to the TCP protocol itself. </font><font style="vertical-align: inherit;">The attack is believed to be an essential component of the Great Chinese Firewall (the Golden Shield), which is used by the Chinese government to censor the Internet outside of China. </font><font style="vertical-align: inherit;">Despite her impressive background, understanding the mechanisms behind this attack does not necessarily require in-depth knowledge of TCP. </font><font style="vertical-align: inherit;">Of course, an understanding of its subtleties can teach you a lot about the features of implementing the TCP protocol, and, as we will soon see, you can even carry out this attack against yourself using only one laptop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this post we:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learn the basics of TCP</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learn how the attack works.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's conduct an attack against ourselves with a simple Python script.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we begin to analyze the mechanics of attack, let's first see how it is used in the real world.</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How is TCP reset attack used in the Great Firewall?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Great Firewall (GFW) is a set of systems and techniques used by the Chinese government to censor the Internet for internal Chinese users. </font><font style="vertical-align: inherit;">GFW actively blocks and breaks connections with servers inside and outside the country, and also passively monitors Internet traffic of prohibited content. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To prevent users from even connecting to banned servers, GFW uses techniques such as </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNS pollution</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP blocking</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(both of them cost separate articles). </font><font style="vertical-align: inherit;">However, sometimes the GFW firewall needs to be allowed to make a connection, but then break it in the middle. </font><font style="vertical-align: inherit;">For example, this is necessary if you want to perform a slow, pending analysis of the connection, for example, its correlation with other actions. </font><font style="vertical-align: inherit;">Or it is used if the firewall needs to analyze the data exchanged during the connection process, and then use this information to decide whether to continue or block it. </font><font style="vertical-align: inherit;">For example, traffic to a news website may be allowed, but videos containing prohibited keywords will be censored. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this, GFW needs tools capable of interrupting already established connections. </font><font style="vertical-align: inherit;">One such tool is a TCP reset attack.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does a TCP reset attack work?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a TCP reset attack, the attacker breaks the connection between the two victims, sending one or both fake messages telling them to immediately disconnect. These messages are called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP reset segments</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In normal operation without the participation of an attacker, computers send TCP drop segments when they receive unexpected TCP traffic and want the sender to stop sending it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The TCP reset attack maliciously exploits this mechanism, tricking victims into ending TCP connections prematurely, sending them fake reset segments. If the false reset segment is made correctly, the recipient will take it for the real segment and close the connection for its part, interrupting further transmission of information on this connection. To continue the data exchange, victims may try to create a new TCP connection, but the attacker may have the opportunity to reset this new connection. Fortunately, since an attacker needs time to build and send a fake packet, dropping attacks are really effective only against long-term connections. Short term connections. for example, used to transfer small web pages, usually have time to fulfill their mission by the timewhen the attacker will be able to reset them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sending fake TCP segments is in some sense an easy process, because neither TCP nor IP have any of their own ways of verifying the identity of the sender. There is an IP extension called IPSec that provides authentication, but it is not so widely used. Internet service providers must refuse to transmit IP packets that come from an obviously false IP address, but it is alleged that this check is very mediocre. All that the recipient can do is take the source IP address and port inside the packet or segment at face value and, if possible, use higher-level protocols, such as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/2014/03/27/how-does-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , to identify the sender </font><font style="vertical-align: inherit;">. However, since TCP dump packets are part of the TCP protocol itself, they cannot be verified using these high-level protocols.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the simplicity of sending fake segments, making a fake segment and executing a successful TCP reset attack can still be a daunting task. </font><font style="vertical-align: inherit;">To understand why this happens, we need to understand the operation of the TCP protocol.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How TCP works</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The purpose of the TCP protocol is to send the recipient an exact copy of the data block. </font><font style="vertical-align: inherit;">For example, if my server sends HTML via TCP to your computer, then </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the TCP stack of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> your computer (the part of its operating system that processes TCP) should output my HTML in exactly the same form and order in which my server sent it.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54d/bf5/d64/54dbf5d644d0a3d8ece1cff6cde7b790.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, my HTML is not transmitted over the Internet in such a perfectly ordered manner. It is divided into many small fragments (called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP segments</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), each of which is individually transmitted over the Internet and recreated in the transferred order by the TCP stack of your computer. This restored output is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a TCP stream</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Each TCP segment is transmitted in its own </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP packet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , however, to understand the attack, we do not need to know any details about IP.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/904/175/4689041752b8fa9f66c57c696c4be2ef.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Converting segments to a stream requires care because the Internet is unreliable. </font><font style="vertical-align: inherit;">TCP segments may be lost. </font><font style="vertical-align: inherit;">They can come out of order, sent twice, get damaged and experience many other misadventures. </font><font style="vertical-align: inherit;">Therefore, the purpose of the TCP protocol is to ensure reliable data transmission over an unreliable network. </font><font style="vertical-align: inherit;">TCP performs this task, requiring both sides of the connection to maintain close contact between each other and to constantly transmit information about which data blocks were received. </font><font style="vertical-align: inherit;">This allows senders to understand what data the recipient has not yet received, and re-transmit the data that was lost. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand how the process works, we need to understand how senders and receivers use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP sequence numbers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for marking and tracking data transmitted over TCP.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP sequence numbers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each byte transmitted over a TCP connection has a sequence number assigned to it by the sender. </font><font style="vertical-align: inherit;">Receiving machines use serial numbers to move the received data into the original order.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/fbc/144/402fbc144a2864f986debfb2ea9b6412.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When two machines negotiate a TCP connection, each machine sends another random </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starting sequence number</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is the sequence number that the machine will assign to the first byte it sends. Each subsequent byte is assigned the sequence number of the previous byte plus 1. TCP segments contain </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP headers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which are metadata attached to the beginning of the segment. The sequence number of the first byte in the segment body is included in the TCP header of this segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be noted that TCP connections are bidirectional, that is, data can be transmitted in both directions, and each machine in a TCP connection acts both as a sender and a receiver. Because of this, each machine must assign and process its own independent set of sequence numbers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confirmation of receipt of data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When a machine receives a TCP segment, it tells the sender of the segment that it was received. </font><font style="vertical-align: inherit;">The recipient does this by sending a segment </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(short for ‚Äúacknowledge‚Äù), containing the sequence number of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte that he expects to receive from the sender. </font><font style="vertical-align: inherit;">The sender uses this information to understand that the receiver has successfully received all other bytes up to this number. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segment is </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicated by the presence of a flag </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the corresponding confirmation number in the TCP header of the segment. </font><font style="vertical-align: inherit;">There are only 6 flags in the TCP protocol, including (as we will see shortly) a flag </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(short for ‚Äúreset‚Äù - ‚Äúreset‚Äù), indicating the reset segment.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/452/e35/242452e35d360faf406441ab93f8c383.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: TCP also allows the use of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selective ACKs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which are transmitted when the receiver has received some, but not all, segments in the range of numbers. For example, "I received bytes 1000-3000 and 4000-5000, but not 3001-3999." For simplicity, I will not consider selective ACKs in our discussion of TCP reset attacks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the sender transmits data but does not receive</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for them during a certain time interval, he assumes that the data has been lost and resends it, giving them the same serial numbers. This means that if the receiver accepts the same bytes twice, then it trivially uses sequence numbers to get rid of duplicates without breaking the stream. The recipient can accept duplicate data because the original segment was received later, after it was sent again, or because the original segment was successfully received, but the corresponding one was </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lost on the way to the sender.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/22f/a09/e6d22fa098d7375dab30e6c8341ff358.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While such duplicate data is rare enough, the excessive waste of resources caused by it does not lead to problems. </font><font style="vertical-align: inherit;">If all the data sooner or later reaches the recipient, and the corresponding data </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reach the sender, then the TCP connection does its job.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choosing a serial number for a fake segment</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When creating a false segment, the </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attacker needs to give him a serial number. </font><font style="vertical-align: inherit;">The recipients are quite happy that you need to accept segments with inconsistent serial numbers and independently connect them in the right order. </font><font style="vertical-align: inherit;">However, their capabilities are limited. </font><font style="vertical-align: inherit;">If the recipient receives a segment with a sequence number that is ‚Äútoo‚Äù out of order, then it discards such a segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, for a successful TCP reset attack, a plausible sequence number is required. </font><font style="vertical-align: inherit;">But what is considered such a number? </font><font style="vertical-align: inherit;">For most segments (although, as we will see later, not for </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), the answer is determined by the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size of the TCP window</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP window size</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine an ancient computer of the early 1990s, connected to a modern gigabit fiber-optic network. An ultrafast network can transfer data to this elderly computer at an amazing rate, faster than the machine can process it. This will bother us, because the TCP segment cannot be considered received until the receiver can process it.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/299/76a/8a529976a3acd7a28babb9e8220bcb7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Computers have a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP buffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which new arriving data awaits processing while the computer is working on data arriving before it. However, this buffer has a limited size. If the recipient is unable to cope with the amount of data transmitted to him by the network, then the buffer will overflow. When the buffer is full, the recipient has no choice but to get rid of the redundant data. The recipient does not send </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for discarded data, so the sender has to resend them when there is free space in the recipient's buffer. It does not matter how fast the network can transmit data if the recipient does not have time to cope with them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine an overly zealous friend who sends you a whole stream of letters to your mail faster than you can read it. There is a certain buffer space inside your mailbox, but after it is full all non-placed letters will fall to the ground, where foxes and other creatures will eat them. A friend will have to resend the letters he has eaten, but for now you will have time to receive his previous messages. Sending too many letters or data volume that the recipient is unable to process is a waste of energy and transmission channel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúToo much‚Äù - how much data is it? How does the sender understand when to send more data, and when is it worth the wait? This is where the </font><em><font style="vertical-align: inherit;">TCP window size</font></em><font style="vertical-align: inherit;"> comes in handy.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The size of the recipient's window is the maximum number of unacknowledged bytes that the sender can transfer to him at any time. Suppose the recipient reports that its window size is 100,000 (we will soon find out how it passes this value), so the sender sends 100,000 bytes. Suppose that by the time the sender transmitted a hundred thousandth byte, the receiver sent the segments </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the first 10,000 of these bytes. This means that 90,000 bytes have not yet been confirmed. Since the window size is 100,000, the sender can transfer another 10,000 bytes before he has to wait for new ones </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If after sending these 10,000 additional bytes further</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if it was not received, then the sender will run into its limit of 100,000 unconfirmed bytes. Consequently, the sender will have to wait and stop sending data (except for the retransmission of data that he considers lost) until he receives new ones </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/5df/46f/afa5df46f3304b04abbf629ca6ef34a0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each side of the TCP connection notifies the other of the size of its window during the handshake process that is performed when the connection is opened. In addition, window sizes can be dynamically changed during the connection process. A computer with a large TCP buffer can announce a large window size to maximize throughput. This allows the machine that communicates with it to continuously transmit data over a TCP connection without pausing or waiting for confirmation. A computer with a small TCP buffer may be forced to report a small window size. Sometimes senders completely fill the window and are forced to wait until some of the segments are confirmed. Bandwidth suffers because of this, but it is necessary that TCP buffers do not overflow.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e3/d5e/5e0/8e3d5e5e0e4b574c6896e6ef7adc94bc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The size of the TCP window is a strict limit on the amount of transmitted unconfirmed data. </font><font style="vertical-align: inherit;">We can use it to calculate the maximum possible sequence number (which in the equation below I designated as </font></font><code>max_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), which the sender can send at the current time:</font></font><br>
<br>
<blockquote><code>max_seq_no = max_acked_seq_no + window_size</code></blockquote><br>
<code>max_acked_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is the maximum sequence number for which the recipient has sent </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the maximum sequence number that the sender knows that the recipient has exactly received. </font><font style="vertical-align: inherit;">Since the sender can only transmit </font></font><code>window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unconfirmed bytes, the maximum sequence number that it can send is </font></font><code>max_acked_seq_no + window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because of this, the TCP specification states that the recipient should ignore any data it receives that has serial numbers outside the valid window. For example, if the recipient has confirmed all bytes up to 15,000, and its window size is 30,000, then it will receive any data with a serial number in the range from 15,000 to (15,000 + 30,000 = 45,000). Moreover, the recipient completely ignores data with serial numbers outside this interval. If the segment contains data, some of which are within this window, and some outside it, then the data inside the window will be accepted and confirmed, but the data outside it will be discarded. Note that we still ignore the possibility of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selective ones</font></font><code>ACK</code></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that were briefly touched on at the beginning of the post.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of most TCP segments, this rule gives us an interval of acceptable sequence numbers. </font><font style="vertical-align: inherit;">However, as mentioned earlier, the </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restrictions </font><font style="vertical-align: inherit;">imposed on segments </font><font style="vertical-align: inherit;">are even stricter than the restrictions on ordinary data transmission segments. </font><font style="vertical-align: inherit;">As we will soon see, this was done to complicate the conduct of a variant of a TCP reset </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attack</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called a </font><em><font style="vertical-align: inherit;">‚Äúblind TCP reset attack‚Äù</font></em><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acceptable Sequence Numbers for RST Segments</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regular segments are accepted if their sequence number is between the next expected sequence number and this number plus the window size. However, packets </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are only received when their sequence number is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactly equal to the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> next expected sequence number. Let us return to the previous example, in which the recipient sent the confirmation number 15,000. For the packet to </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be received, its sequence number must be exactly 15,000. If the recipient receives a segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a sequence number not equal to 15,000, then he will not accept it.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/596/b55/1d9596b55bb0ac4946ed16ff6b878dff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the sequence number is outside the interval, then the receiver completely ignores it. </font><font style="vertical-align: inherit;">However, if it is within the window of the expected sequence numbers, the receiver sends a ‚Äúchallenge </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù (‚ÄúACK call‚Äù). </font><font style="vertical-align: inherit;">This is a segment that tells the sender that the segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has an invalid sequence number. </font><font style="vertical-align: inherit;">He also tells the sender the sequence number that the recipient expects. </font><font style="vertical-align: inherit;">The sender can use this information from the </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call to recreate and resend his </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Until 2010, TCP did not impose these additional segment restrictions </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Segments were </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepted or rejected in accordance with the same rules as any others. </font><font style="vertical-align: inherit;">However, this too simplified the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blind blind TCP reset attacks</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blind TCP attacks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the attacker has the ability to intercept the traffic exchanged between his victims, he can read the serial and confirmation numbers of the TCP packets of the victims. He can use this information to select which serial numbers to give to his fake segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, if the attacker cannot intercept the traffic of the victims, he will not know which sequence numbers to insert. But he can still transfer any number of segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with any number of different serial numbers, hoping that one of them turns out to be correct. Such an attack is called a blind TCP reset attack. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we have already said, in the initial version of the TCP protocol, the attacker only had to pick up the serial number</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">within the receiver's TCP window. </font><font style="vertical-align: inherit;">An article titled ‚ÄúSlipping in the Window‚Äù showed that this made the blind attacks too easy, since for an almost guaranteed success, an attacker just had to send tens of thousands of segments. </font><font style="vertical-align: inherit;">To counter this, the rule that forced the recipient to accept the segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was replaced with the more stringent criterion described above. </font><font style="vertical-align: inherit;">Thanks to the new rules for carrying out TCP reset attacks, millions of segments need to be sent blindly, which makes them practically unrealizable. </font><font style="vertical-align: inherit;">See </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC-5963 for</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> details </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perform a TCP reset attack against ourselves</font></font></h2><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: I tested this process on OSX, but received a few comments that it does not work properly on Linux. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we know everything about executing a TCP reset attack. </font><font style="vertical-align: inherit;">The attacker must:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Watch network traffic ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúsniff‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it) between two victims</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sniff the TCP segment with the flag enabled </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and read its confirmed number</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make a false TCP segment with the flag turned on </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a sequence number equal to the confirmed number of the intercepted segment (note that this implies a slow transmission, otherwise the selected sequence number will quickly become outdated. (To increase the chances of success, you can transfer several segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a large interval of sequence numbers .)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send fake segments to one or both victims, hoping this will break their TCP connection</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To practice, let's conduct a TCP attack on ourselves on the same computer, communicating with ourselves through </font></font><code>localhost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For this we need:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configure TCP connection between two terminal windows</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write an attack program that will deal with traffic sniffing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modify the program so that it produces and sends fake segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's get started.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Establishing a TCP connection between two terminal windows</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will configure the TCP connection using the tool </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><code>netcat</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which by default is available on many operating systems. </font><font style="vertical-align: inherit;">Any other </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP client will do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the first terminal window, we will execute the following command:</font></font><br>
<br>
<blockquote><code>nc -nvl 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This command starts a TCP server listening on a port on our local machine </font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the second terminal window, execute the following command:</font></font><br>
<br>
<blockquote><code>nc 127.0.0.1 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This command attempts to create a TCP connection to the machine by the IP address of </font></font><code>127.0.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the port </font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now, between the two windows of the terminal, a TCP connection should be established. </font><font style="vertical-align: inherit;">Try to enter something in one window - the data will have to be transmitted over the TCP connection and appear in another window.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/301/786/911301786c4f56287f80d38f67ef73f6.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Traffic sniffing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will write an attack program that performs traffic sniffing using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><code>scapy</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">popular Python network library. </font><font style="vertical-align: inherit;">This program uses scapy to read data transferred between two windows of the terminal, although it is not part of the connection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The program code is posted in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my repository on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The program sniffs the connection traffic and displays it on the terminal. </font><font style="vertical-align: inherit;">The main core of the code is the method call </font></font><code>sniff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the library </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">located at the end of the file:</font></font><br>
<br>
<pre><code class="python hljs">t = sniff(<font></font>
        iface=<span class="hljs-string">'lo0'</span>,<font></font>
        lfilter=is_packet_tcp_client_to_server(localhost_ip, localhost_server_port, localhost_ip),<font></font>
        prn=log_packet,<font></font>
        count=<span class="hljs-number">50</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This piece of code tells us </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to sniff packets on the interface </font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and capture details of all packets as part of our TCP connection. </font><font style="vertical-align: inherit;">The call has the following parameters:</font></font><br>
<br>
<ul>
<li><code>iface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- orders </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to listen to the network interface </font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or localhost</font></font></li>
<li><code>lfilter</code> ‚Äî  ,  <code>scapy</code>   ,      IP- localhost   .   ,        ,   <code>lo0</code>.     ,     .</li>
<li><code>prn</code> ‚Äî ,  <code>scapy</code>     ,    <code>lfilter</code>.          .       ,      <code>RST</code>.</li>
<li><code>count</code> ‚Äî  ,  <code>scapy</code>    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To test this program, configure the TCP connection from step 1. Clone my GitHub repository, follow the configuration instructions, and run the program in the third window of the terminal. </font><font style="vertical-align: inherit;">Enter some text into one of the terminals of the TCP connection. </font><font style="vertical-align: inherit;">You should see that the program will begin to record information about the connection segments.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sending fake packages </font></font><code>RST</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have established a connection, and the program can sniff all TCP segments passing through it. The only thing left for us is to modify the program so that it performs a TCP reset attack by transmitting fake segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. To do this, we will change the function </font></font><code>prn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(see the list of parameters above), called </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for packages that meet the requirements of the function </font></font><code>lfilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the modified version of the function, instead of simply fixing the corresponding package, we study it, extract the necessary parameters, and use these parameters to build and send the segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we intercepted a segment going from </font></font><code>(src_ip, src_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font><code>(dst_ip, dst_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. He has a flag set </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the confirmation number is 100,000. To manufacture and send a segment, we:</font></font><br>
<br>
<ul>
<li>  IP-   ,    .  ,         .          ,  .</li>
<li>  <code>RST</code> ,     ,    <code>RST</code></li>
<li>        ,      ,    </li>
<li>  <code>send</code>  <code>scapy</code>     ‚Äî   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To modify our previous program as needed, uncomment </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this line</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and comment out the line above it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we are ready for a full-scale attack. </font><font style="vertical-align: inherit;">Configure the TCP connection in accordance with step 1. Run the attack program from step 2 in the third window of the terminal. </font><font style="vertical-align: inherit;">Then enter some text in one of the terminals of the TCP connection. </font><font style="vertical-align: inherit;">In the terminal where you entered the text, the TCP connection will suddenly and mysteriously break. </font><font style="vertical-align: inherit;">The attack is done!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/2a2/b18/ad92a2b18c1533c47d88ab4ff10dedf7.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further work</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continue experimenting with the attack tool. </font><font style="vertical-align: inherit;">Track what happens if you add or subtract 1 from the sequence number of the package </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Make sure that it must be </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactly</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equal to the value of the </font></font><code>ack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intercepted packet.</font></font></li>
<li> Wireshark       <code>lo0</code>    .            TCP-,       <code>RST</code>.   <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code>       .</li>
<li>  ,      .           <code>RST</code>,       <code>RST</code>         ,      .   ,      <code>RST</code>,       .</li>
</ol><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The TCP reset attack is both deep and simple at the same time. </font><font style="vertical-align: inherit;">Good luck with your experiments and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let me know</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you have questions or comments.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499884/index.html">11 things I understood about CustDev</a></li>
<li><a href="../en499894/index.html">House of singing things. Chipolo ONE Smart Keychain Tracker Review</a></li>
<li><a href="../en499896/index.html">We are leaving to the remote site correctly: how to organize our work and the work of the project in Telegram?</a></li>
<li><a href="../en499898/index.html">How IT people relate to quarantine, what they do in self-isolation and what they use</a></li>
<li><a href="../en499900/index.html">Product analytics mitap: free, contactless, online</a></li>
<li><a href="../en499904/index.html">"I'm scared". What to do?</a></li>
<li><a href="../en499906/index.html">Examples of using AR in the toy industry</a></li>
<li><a href="../en499908/index.html">Diving Into the Depth: How to Realize Freedom of Choice in the Digital World</a></li>
<li><a href="../en499910/index.html">Balance in decision making. Fork "random experience"</a></li>
<li><a href="../en499920/index.html">SSH Little Tricks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>