<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎋 👨🏿‍🤝‍👨🏼 ▫️ Apprentissage automatique sur R: techniques expertes pour l'analyse prédictive 🤔 🤴🏻 💩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, habrozhiteli! Le langage R propose un ensemble puissant de méthodes d'apprentissage automatique qui vous permettent d'effectuer rapidement un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Apprentissage automatique sur R: techniques expertes pour l'analyse prédictive</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="image"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, habrozhiteli! Le langage R propose un ensemble puissant de méthodes d'apprentissage automatique qui vous permettent d'effectuer rapidement une analyse non triviale de vos données. Le livre est un guide qui aidera à appliquer des méthodes d'apprentissage automatique pour résoudre des problèmes quotidiens. Brett Lanz vous apprendra tout ce dont vous avez besoin pour l'analyse, la prévision et la visualisation des données. Vous trouverez ici des informations sur les bibliothèques nouvelles et améliorées, des conseils sur les aspects éthiques de l'apprentissage automatique et les problèmes de biais, ainsi qu'une formation approfondie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce livre - Fondements de l'apprentissage automatique et caractéristiques de la formation en informatique sur des exemples. </font><font style="vertical-align: inherit;">- Préparation des données à utiliser dans l'apprentissage automatique au moyen du langage R. - Classification de la signification des résultats. </font><font style="vertical-align: inherit;">- Prédiction d'événements à l'aide d'arbres de décision, de règles et de vecteurs de référence. </font><font style="vertical-align: inherit;">- Prédiction de données numériques et évaluation de données financières à l'aide de méthodes de régression. </font><font style="vertical-align: inherit;">- La modélisation de processus complexes à l'aide de réseaux de neurones est le fondement de l'apprentissage en profondeur. </font><font style="vertical-align: inherit;">- Évaluation des modèles et amélioration de leurs performances. </font><font style="vertical-align: inherit;">- Les dernières technologies de traitement du Big Data, notamment R 3.6, Spark, H2O et TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À qui s'adresse le livre?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le livre est destiné à ceux qui s'attendent à utiliser des données dans un domaine spécifique. </font><font style="vertical-align: inherit;">Vous êtes peut-être déjà un peu familier avec l'apprentissage automatique, mais vous n'avez jamais travaillé avec le langage R; </font><font style="vertical-align: inherit;">ou, inversement, vous en savez un peu sur R, mais vous ne savez presque pas sur l'apprentissage automatique. </font><font style="vertical-align: inherit;">Dans tous les cas, ce livre vous aidera à démarrer rapidement. </font><font style="vertical-align: inherit;">Il serait utile de rafraîchir un peu les concepts de base des mathématiques et de la programmation, mais aucune expérience préalable ne serait requise. </font><font style="vertical-align: inherit;">Tout ce dont vous avez besoin, c'est d'un désir d'apprendre.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que lirez-vous dans la publication</font></font></b><div class="spoiler_text"> 1 «   »    ,          ,      ,   ,     .<br>
<br>
 2 «    »            R.         ,   ,    .<br>
<br>
 3 « :      »      ,           :     .<br>
<br>
 4 « :      »     ,       .    ,      .<br>
<br>
 5 «  :       »    ,     ,    .      ,    .<br>
<br>
 6 «  :  »     ,    .        ,     ,     .<br>
<br>
 7 « “ ”:      »   ,     .        ,    ,    .<br>
<br>
 8 « :       »  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 «  :   k-»      .         -.<br>
<br>
 10 «  »    ,                  .<br>
<br>
 11 «  »  ,  ,        .                ,         .<br>
<br>
 12 «   »    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple: modélisation de la résistance du béton à l'aide d'un réseau neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le domaine du génie civil, il est extrêmement important de disposer d'estimations précises de l'efficacité des matériaux de construction. </font><font style="vertical-align: inherit;">Ces évaluations sont nécessaires pour élaborer des règles de sécurité régissant l'utilisation de matériaux dans la construction de bâtiments, de ponts et de routes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'évaluation de la résistance du béton est particulièrement intéressante. </font><font style="vertical-align: inherit;">Le béton est utilisé dans presque toutes les constructions, les caractéristiques de performance du béton sont très différentes, car il se compose d'un grand nombre d'ingrédients qui interagissent dans un complexe. </font><font style="vertical-align: inherit;">En conséquence, il est difficile de dire exactement quelle sera la résistance du produit fini. </font><font style="vertical-align: inherit;">Un modèle qui permettrait de déterminer la résistance du béton à coup sûr, en tenant compte de la composition des matériaux de départ, pourrait offrir un niveau de sécurité plus élevé pour les chantiers de construction.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 1. Collecte de données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cette analyse, nous utiliserons les données de résistance à la compression du béton fournies par I-Cheng Yeh au référentiel d'apprentissage automatique de l'UCI (http://archive.ics.uci.edu/ml). </font><font style="vertical-align: inherit;">Puisque Ai-Cheng Ye a utilisé avec succès des réseaux de neurones pour modéliser ces données, nous allons essayer de reproduire son travail en appliquant un modèle de réseau de neurones simple dans R.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À en juger par le site, cet ensemble de données contient 1030 enregistrements sur différentes marques de béton avec huit caractéristiques qui décrivent les composants utilisés dans la composition du mélange de béton. </font><font style="vertical-align: inherit;">On pense que ces caractéristiques affectent la résistance à la compression finale. </font><font style="vertical-align: inherit;">Il s'agit notamment de la quantité (en kilogrammes par mètre cube) de ciment, d'eau, de divers additifs, de grands et petits agrégats tels que la pierre concassée et le sable utilisés dans le produit fini, ainsi que le temps de prise (en jours).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour exécuter cet exemple, téléchargez le fichier concrete.csv et enregistrez-le dans le répertoire de travail R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 2. Recherche et préparation des données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme d'habitude, nous commençons l'analyse en chargeant les données dans l'objet R à l'aide de la fonction read.csv () et nous assurons que le résultat correspond à la structure attendue:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neuf variables dans la base de données correspondent à huit caractéristiques et à un résultat attendu, mais il est devenu évident qu'il y a un problème. </font><font style="vertical-align: inherit;">Les réseaux de neurones fonctionnent mieux lorsque les données d'entrée sont mises à l'échelle dans une plage étroite centrée autour de 0, et ici nous voyons des valeurs dans la plage de 0 à plus de 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En règle générale, la solution à ce problème consiste à mettre à l'échelle les données à l'aide de la fonction de normalisation ou de normalisation. Si la distribution des données correspond à une courbe en forme de cloche (distribution normale, voir chapitre 2), il peut être judicieux d'utiliser la normalisation à l'aide de la fonction intégrée scale (). Si la distribution des données est proche de l'uniforme ou très différente de la normale, la normalisation dans la plage de 0 à 1 peut être plus appropriée. Dans ce cas, nous utiliserons cette dernière option. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le chapitre 3, nous avons créé notre propre fonction normalize ():</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) — min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois ce code exécuté, vous pouvez appliquer la fonction normalize () à toutes les colonnes du bloc de données sélectionné à l'aide de la fonction lapply (): </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour vérifier que la normalisation a fonctionné, vous pouvez vérifier si les valeurs minimale et maximale de l'attribut de force sont respectivement 0 et 1:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A titre de comparaison: les valeurs initiales minimum et maximum de cet attribut étaient respectivement de 2,33 et 82,60:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toute conversion appliquée aux données avant l'apprentissage du modèle doit ensuite être appliquée dans l'ordre inverse pour reconvertir l'attribut aux unités d'origine. </font><font style="vertical-align: inherit;">Pour faciliter la mise à l'échelle, il est conseillé de sauvegarder les données source, ou au moins un résumé des statistiques des données source.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En suivant le scénario décrit par Ye dans l'article d'origine, nous diviserons les données en un ensemble de formation, qui comprend 75% de tous les exemples, et un ensemble de test, composé de 25%. </font><font style="vertical-align: inherit;">Le fichier CSV utilisé est trié dans un ordre aléatoire, nous ne pouvons donc le diviser qu'en deux parties: </font><font style="vertical-align: inherit;">
nous utiliserons un ensemble de données d'apprentissage pour construire un réseau de neurones et un ensemble de données de test pour évaluer dans quelle mesure le modèle se généralise pour les résultats futurs. </font><font style="vertical-align: inherit;">Étant donné que le réseau neuronal est facilement amené à un état de recyclage, cette étape est très importante.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 3. Formation du modèle sur les données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour modéliser la relation entre les ingrédients utilisés dans la production de béton et la résistance du produit fini, nous allons construire un réseau neuronal multicouche à distribution directe. Le package neuralnet, développé par Stefan Fritsch et Frauke Guenther, fournit une implémentation standard et facile à utiliser de tels réseaux. Ce package comprend également une fonction de création d'une topologie de réseau. L'implémentation de neuralnet est un bon moyen d'obtenir des informations supplémentaires sur les réseaux de neurones, bien que cela ne signifie pas non plus qu'il ne peut pas être utilisé pour faire du vrai travail - comme vous le verrez bientôt, c'est un outil plutôt puissant.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    —  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque le paquet neuralnet n'est pas inclus dans la base R, vous devrez l'installer en tapant install.packages ("neuralnet") et le télécharger en utilisant la commande library (neuralnet). </font><font style="vertical-align: inherit;">La fonction neuralnet () du package peut être utilisée pour entraîner des réseaux de neurones dans la prédiction numérique en utilisant la syntaxe suivante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxe du réseau neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisation de la fonction neuralnet () du package neuralnet </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Construction d'un modèle:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• cible - un modèle qui sera construit à la suite de la formation sur la base de données mydata; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• prédicteurs - formule R qui détermine les caractéristiques du bloc de données mydata à utiliser dans les prévisions; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• données - bloc de données auquel appartiennent la cible et les prédicteurs; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• caché - le nombre de neurones dans la couche cachée (la valeur par défaut est 1). Remarque: pour décrire plusieurs couches cachées, un vecteur d'entiers est utilisé, par exemple, c (2, 2); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• act.fct - fonction d'activation: "logistique" ou "tanh". Remarque: toute autre fonction différenciable peut également être utilisée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction renvoie un objet de réseau neuronal qui peut être utilisé pour la prévision. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prédiction:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- calculer (m, test)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• m - modèle formé à l'aide de la fonction neuralnet (); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• test - une trame de données contenant des données de test ayant les mêmes caractéristiques que les données d'apprentissage utilisées pour construire le classificateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction renvoie une liste composée de deux composants: $ neurones, où les neurones sont stockés pour chaque couche de réseau, et $ net.result, où les valeurs prédites à l'aide de ce modèle sont stockées.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par former le réseau de distribution directe à plusieurs niveaux le plus simple avec des paramètres par défaut, qui n'a qu'un seul nœud caché:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, comme le montre la fig. </font><font style="vertical-align: inherit;">7.11, vous pouvez visualiser la topologie du réseau en utilisant la fonction plot () et en lui passant l'objet modèle résultant:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce modèle simple, il y a un nœud d'entrée pour chacune des huit entités, puis il y a un nœud caché et un nœud de sortie, ce qui donne une prévision de la résistance du béton. </font><font style="vertical-align: inherit;">Le diagramme montre également les poids pour chaque connexion et la valeur de décalage indiquée pour les nœuds marqués du numéro 1. La valeur de décalage est une constante numérique qui vous permet de décaler la valeur dans le nœud spécifié vers le haut ou vers le bas, approximativement comme un décalage dans une équation linéaire.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un réseau neuronal avec un nœud caché peut être considéré comme le «cousin» des modèles de régression linéaire discutés au chapitre 6. Les poids entre les nœuds d'entrée et le nœud caché sont similaires aux coefficients bêta, et le poids de décalage est comme un décalage.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au bas de la figure, le nombre d'étapes d'apprentissage et l'ampleur de l'erreur sont affichés - l'erreur quadratique moyenne totale (somme des erreurs quadratiques, SSE), qui, comme prévu, est la somme des différences quadratiques entre les valeurs prévues et réelles. </font><font style="vertical-align: inherit;">Plus le SSE est petit, plus le modèle correspond aux données de formation, ce qui indique l'efficacité de ces données, mais en dit peu sur la façon dont le modèle fonctionnera avec des données inconnues.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 4. Évaluation de l'efficacité du modèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le diagramme de topologie du réseau donne l'occasion d'examiner la boîte noire d'un réseau neuronal, mais il ne fournit pas beaucoup d'informations sur la façon dont le modèle correspond aux données futures. Pour générer des prévisions sur un ensemble de données de test, vous pouvez utiliser la fonction compute (): </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction compute () fonctionne un peu différemment des fonctions Predict () que nous avons utilisées jusqu'à présent. Il renvoie une liste composée de deux composants: $ neurones, où les neurones sont stockés pour chaque couche de réseau, et $ net.result, où les valeurs prédites sont stockées. C'est $ net.result dont nous avons besoin:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que nous avons pour tâche la prévision numérique et non la classification, nous ne pouvons pas utiliser la matrice des incohérences pour vérifier l'exactitude du modèle. </font><font style="vertical-align: inherit;">Nous mesurons la corrélation entre la valeur prévue et la valeur réelle de la résistance du béton. </font><font style="vertical-align: inherit;">Si les valeurs prévues et réelles sont fortement corrélées, alors, probablement, le modèle sera utile pour déterminer la résistance du béton. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de vous rappeler que pour obtenir la corrélation entre deux vecteurs numériques, la fonction cor () est utilisée:</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne vous inquiétez pas si votre résultat diffère du nôtre. </font><font style="vertical-align: inherit;">Puisque le réseau neuronal commence à travailler avec des poids aléatoires, les prédictions présentées dans le livre peuvent être différentes pour différents modèles. </font><font style="vertical-align: inherit;">Si vous souhaitez faire correspondre précisément les résultats, essayez la commande set.seed (12345) avant de commencer à construire un réseau neuronal.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la corrélation est proche de 1, cela indique une forte relation linéaire entre les deux variables. </font><font style="vertical-align: inherit;">Par conséquent, une corrélation d'environ 0,806 indique une relation plutôt forte. </font><font style="vertical-align: inherit;">Cela signifie que le modèle fonctionne assez bien même avec un seul nœud caché. </font><font style="vertical-align: inherit;">Étant donné que nous n'avons utilisé qu'un seul nœud caché, il est probable que nous puissions améliorer l'efficacité du modèle, ce que nous allons essayer de faire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 5. Amélioration de l'efficacité du modèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que les réseaux avec une topologie plus complexe peuvent étudier des concepts plus complexes, voyons ce qui se passe si vous augmentez le nombre de nœuds masqués à cinq. </font><font style="vertical-align: inherit;">Nous utiliserons la fonction neuralnet (), comme précédemment, mais ajouterons le paramètre hidden = 5:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir reconstruit le schéma du réseau (Fig. 7.12), nous verrons une forte augmentation du nombre de connexions. Comment cela a-t-il affecté l'efficacité? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que l'erreur résultante (à nouveau mesurée comme SSE) est passée de 5,08 dans le modèle précédent à 1,63. De plus, le nombre d'étapes de formation est passé de 4882 à 86 849, ce qui n'est pas surprenant compte tenu de la complexité du modèle. Plus le réseau est complexe, plus il faut d'itérations pour trouver les poids optimaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En appliquant les mêmes étapes pour comparer les valeurs prédites avec les vraies, nous obtenons une corrélation d'environ 0,92, ce qui est beaucoup mieux par rapport au résultat précédent de 0,80 pour un réseau avec un nœud caché:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré d'importantes améliorations, vous pouvez aller encore plus loin pour augmenter l'efficacité du modèle. En particulier, il est possible d'introduire des couches cachées supplémentaires et de changer la fonction d'activation du réseau. En faisant ces changements, nous jetons les bases de la construction d'un simple réseau de neurones profonds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le choix de la fonction d'activation est très important pour l'apprentissage en profondeur. La meilleure fonction pour une tâche d'apprentissage particulière se trouve généralement expérimentalement, puis est largement utilisée par la communauté des chercheurs en apprentissage automatique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Récemment, la fonction d'activation, appelée fonction de distillation, ou redresseur, est devenue très populaire en raison de son application réussie dans des tâches complexes, telles que la reconnaissance d'image. Un nœud de réseau neuronal dans lequel un redresseur est utilisé comme fonction d'activation est appelé unité linéaire rectifiée (ReLU). Comme le montre la fig. 7.13, la fonction d'activation du type redresseur est décrite de telle manière que renvoie x si x est supérieur ou égal à 0, et 0 sinon. L'importance de cette fonction est que, d'une part, elle est non linéaire et, d'autre part, qu'elle a des propriétés mathématiques simples qui la rendent peu coûteuse en calcul et très efficace pour la descente de gradient. Malheureusement, pour x = 0, la dérivée du redresseur n'est pas définie,par conséquent, le redresseur ne peut pas être utilisé conjointement avec la fonction neuralnet ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la place, vous pouvez utiliser une approximation lissée de ReLU appelée softplus ou SmoothReLU, une fonction d'activation définie comme log (1 + ex). </font><font style="vertical-align: inherit;">Comme le montre la fig. </font><font style="vertical-align: inherit;">7.13, la fonction softplus est proche de zéro pour x valeurs inférieures à 0 et approximativement égale à x pour x supérieur à 0.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour définir la fonction softplus () dans R, nous utilisons le code suivant: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une telle fonction d'activation peut être fournie à l'entrée neuralnet () en utilisant le paramètre act.fct. </font><font style="vertical-align: inherit;">De plus, nous ajoutons une deuxième couche cachée composée de cinq nœuds, affectant au paramètre caché la valeur du vecteur entier c (5, 5). </font><font style="vertical-align: inherit;">En conséquence, nous obtenons un réseau à deux couches, dont chacune des couches a cinq nœuds, et tous utilisent la fonction d'activation softplus:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme précédemment, le réseau peut être visualisé (Fig. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La corrélation entre la résistance prévue et réelle du béton peut être calculée comme suit:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La corrélation entre la force prévue et la force réelle était de 0,935, ce qui est le meilleur indicateur obtenu jusqu'à présent. Fait intéressant, dans la publication originale, Ye a rapporté une corrélation de 0,885. Cela signifie qu'avec relativement peu d'efforts, nous avons pu obtenir un résultat comparable et même dépasser les résultats d'un expert dans ce domaine. Certes, les résultats de Ye ont été publiés en 1998, ce qui nous a donné une longueur d'avance sur plus de 20 ans de recherches supplémentaires dans le domaine des réseaux de neurones! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre détail important doit être pris en compte: puisque nous avons normalisé les données avant de former le modèle, les prévisions sont également dans l'intervalle normalisé de 0 à 1. Par exemple, le code suivant montre un cadre de données qui compare ligne par ligne les valeurs de résistance du béton de l'ensemble de données initial avec les prévisions correspondantes:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En examinant la corrélation, nous voyons que le choix des données normalisées ou anormalisées n'affecte pas les statistiques de performance calculées - tout comme auparavant, la corrélation est de 0,935: </font><font style="vertical-align: inherit;">
mais si nous calculons un autre indicateur de performance, par exemple, la différence absolue entre les valeurs prévues et réelles, alors le choix de l'échelle serait très important. </font><font style="vertical-align: inherit;">
Dans cet esprit, vous pouvez créer la fonction unlormalize (), qui effectuerait l'inverse de la normalisation minimax et vous permettrait de convertir les prévisions normalisées à l'échelle d'origine:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir appliqué la fonction Unormalize () que nous avons écrite aux prévisions, il devient clair que l'échelle des nouvelles prévisions est similaire aux valeurs initiales de résistance du béton. </font><font style="vertical-align: inherit;">Cela vous permet de calculer la valeur significative de l'erreur absolue. </font><font style="vertical-align: inherit;">De plus, la corrélation entre les valeurs de résistance anormale et initiale reste inchangée:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new — strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En appliquant des réseaux de neurones à vos projets, vous devez suivre une séquence d'étapes similaire pour ramener les données à leur échelle d'origine.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également constater que les réseaux de neurones deviennent rapidement plus complexes car ils sont utilisés pour des tâches d'apprentissage de plus en plus difficiles. Par exemple, vous pouvez rencontrer le problème de petit gradient dit «disparaissant» et le problème de gradient «explosif» étroitement lié lorsque l'algorithme de propagation inverse ne trouve pas de solution utile car il ne converge pas dans un délai raisonnable. Pour résoudre ces problèmes, vous pouvez essayer de changer le nombre de nœuds cachés, appliquer diverses fonctions d'activation, telles que ReLU, ajuster la vitesse d'apprentissage, etc. Sur la page d'aide de la fonction neuralnet, vous trouverez des informations supplémentaires sur les différents paramètres qui peuvent être configurés. Cependant, cela conduit à un autre problème,lorsque le goulot d'étranglement dans la construction d'un modèle très efficace est la vérification d'un grand nombre de paramètres. C'est le prix de l'utilisation des réseaux de neurones, et plus encore des réseaux d'apprentissage en profondeur: leur énorme potentiel nécessite beaucoup de temps et de puissance de traitement.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode SVM (Support Vector Machine) peut être représentée comme une surface qui forme la frontière entre les points de données tracés dans un espace multidimensionnel qui décrit des exemples et des valeurs de leurs attributs. Le but de SVM est de construire une bordure plate - un hyperplan qui divise l'espace de telle manière que des groupes homogènes se forment des deux côtés de celui-ci. Ainsi, la formation SVM combine des aspects de la formation du plus proche voisin basés sur les instances décrites dans le chapitre 3 et la modélisation de régression linéaire, discutée dans le chapitre 6. Il s'agit d'une combinaison extrêmement puissante qui permet aux SVM de modéliser des relations très complexes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le fait que les mathématiques de base sous-jacentes à la SVM existent depuis des décennies, l'intérêt pour ces méthodes a considérablement augmenté après qu'elles ont commencé à être appliquées au ML. La popularité de ces méthodes a augmenté après des réussites de haut niveau dans la résolution de problèmes d'apprentissage complexes, ainsi qu'après le développement d'algorithmes SVM, qui ont été récompensés et mis en œuvre dans des bibliothèques bien prises en charge dans de nombreux langages de programmation, y compris R. Après cela, les méthodes SVM ont été acceptées par un large public. Sinon, il serait probablement impossible d'appliquer les mathématiques complexes requises pour implémenter SVM. La bonne nouvelle est que même si les mathématiques sont peut-être complexes, les concepts de base sont compréhensibles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les méthodes SVM peuvent être adaptées pour utiliser presque n'importe quel type de tâche de formation, y compris la classification et la prévision numérique. </font><font style="vertical-align: inherit;">De nombreux succès clés de cet algorithme sont liés à la reconnaissance des formes. </font><font style="vertical-align: inherit;">Les applications les plus connues de ces méthodes sont les suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classification des données sur l'expression des gènes de puces à ADN en bioinformatique pour la détection du cancer et d'autres maladies génétiques;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catégorisation de texte, telle que la détermination de la langue utilisée dans un document ou la classification de documents par sujet;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Détection d'événements rares mais importants, tels que la panne d'un moteur à combustion interne, une violation de la sécurité ou un tremblement de terre.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les méthodes SVM sont plus faciles à comprendre en utilisant la classification binaire comme exemple - c'est ainsi qu'elles sont généralement utilisées. </font><font style="vertical-align: inherit;">Par conséquent, dans les sections restantes, nous nous concentrerons uniquement sur les classificateurs SVM. </font><font style="vertical-align: inherit;">Des principes similaires à ceux présentés ici sont également utilisés lors de l'adaptation des méthodes SVM pour la prévision numérique.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A propos de l'auteur</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) utilise des techniques innovantes de traitement des données pour étudier le comportement humain depuis plus d'une décennie. </font><font style="vertical-align: inherit;">Sociologue de formation, Brett s'est d'abord intéressé à l'apprentissage automatique tout en explorant une grande base de données de profils d'adolescents sur les réseaux sociaux. </font><font style="vertical-align: inherit;">Brett est enseignant au DataCamp et fait souvent des présentations lors de conférences et de séminaires d'apprentissage automatique à travers le monde. </font><font style="vertical-align: inherit;">Il est un passionné bien connu dans le domaine de l'application pratique de la science des données dans le domaine des sports, des véhicules sans pilote, de l'étude des langues étrangères et de la mode, ainsi que dans de nombreuses autres industries. </font><font style="vertical-align: inherit;">Brett espère un jour écrire sur tout cela sur dataspelunking.com, un échange de connaissances sur la recherche de modèles dans les données.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos de Science Editor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - chercheur principal de l'une des plus grandes organisations de soins de santé au monde. Il est engagé dans la recherche et le développement de solutions d'entreprise basées sur l'apprentissage automatique, l'apprentissage profond et le traitement du langage naturel pour une utilisation dans les soins de santé et l'assurance. Dans son poste précédent chez Intel, il a participé à des initiatives proactives dans le domaine des technologies de l'information, basées sur les mégadonnées, utilisant le traitement du langage naturel, l'apprentissage en profondeur et les méthodes statistiques traditionnelles. Chez American Express, il a travaillé dans l'engagement numérique et la fidélisation de la clientèle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav est l'auteur de plusieurs livres publiés par de grands éditeurs. </font><font style="vertical-align: inherit;">Son dernier livre porte sur la dernière étude en matière de transfert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav est diplômé de l'Institut international des technologies de l'information de Bangalore et possède une maîtrise (avec distinction). </font><font style="vertical-align: inherit;">Dans ces rares moments où il n'est pas occupé à résoudre des problèmes scientifiques, Raghav aime lire et photographier tout de suite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»De plus amples informations sur le livre sont disponibles </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le site Web de l'éditeur</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
pour Khabrozhiteley 25% de réduction sur le coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machine Learning</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496242/index.html">Le cyberpunk est déjà là: les écoliers étudient à Minecraft et les élèves passent des tests physiques dans CS: GO</a></li>
<li><a href="../fr496248/index.html">Défis, têtes chauves et vin. Comment nous, HFLabs, supportons l'auto-isolement</a></li>
<li><a href="../fr496250/index.html">Comment un code étrange cache-t-il les erreurs? Analyse TensorFlow.NET</a></li>
<li><a href="../fr496252/index.html">Avion de centrage à décalage aérodynamique</a></li>
<li><a href="../fr496254/index.html">Comment Rostelecom a redirigé par erreur le trafic vers Google, AWS, Cloudflare, etc.</a></li>
<li><a href="../fr496258/index.html">Holivar en ligne: un nouveau format pour l'échange d'expériences. Ce samedi</a></li>
<li><a href="../fr496260/index.html">Conseils de cybersécurité pour travailler à domicile</a></li>
<li><a href="../fr496262/index.html">Obtenir l'ID CVE</a></li>
<li><a href="../fr496266/index.html">Coronavirus: mourrons-nous tous?</a></li>
<li><a href="../fr496268/index.html">Produits et solutions de mise en réseau d'entreprise Huawei pour les entreprises en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>