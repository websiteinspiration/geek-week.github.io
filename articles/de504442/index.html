<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üñïüèº üëáüèΩ Ein bisschen √ºber Umz√ºge im Linux-Kernel ‚Ü©Ô∏è üïú üåΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir werden ein einfaches Problem l√∂sen - w√§hlen Sie einen Speicherblock im Bereich des Linux-Kernels aus, f√ºgen Sie Bin√§rcode ein und f√ºhren Sie ihn a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ein bisschen √ºber Umz√ºge im Linux-Kernel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden ein einfaches Problem l√∂sen - w√§hlen Sie einen Speicherblock im Bereich des Linux-Kernels aus, f√ºgen Sie Bin√§rcode ein und f√ºhren Sie ihn aus. </font><font style="vertical-align: inherit;">Dazu schreiben wir ein Kernelmodul, definieren darin die Funktion foo, die die Rolle des ben√∂tigten Bin√§rcodes spielt, w√§hlen dann mit der Funktion module_alloc den Speicherblock aus, kopieren diese gesamte Funktion √ºber memcpy und geben ihr die Kontrolle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion exe_init wird beim Laden des Moduls aufgerufen. </font><font style="vertical-align: inherit;">Wir betrachten das Ergebnis der Arbeit im Kernel-Protokoll:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles funktioniert richtig. </font><font style="vertical-align: inherit;">Und jetzt f√ºgen wir die Funktion printk zu foo hinzu, um das Argument anzuzeigen:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und sichern Sie 25 Bytes des Inhalts der Funktion new_foo (), bevor Sie die Kontrolle an sie √ºbergeben:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dump ist definiert als</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir laden das Modul und erhalten einen Absturz mit der folgenden Meldung im Protokoll:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Irgendwie sind wir in der Funktion irq_create_direct_mapping gelandet, obwohl wir printk aufrufen mussten. </font><font style="vertical-align: inherit;">Lassen Sie uns herausfinden, was passiert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich zun√§chst die zerlegte Liste der foo-Funktion an. </font><font style="vertical-align: inherit;">Holen Sie es sich mit dem Befehl objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion foo befindet sich am Anfang des Textabschnitts. Bei Offset 0xC befindet sich der Opcode des Near-Call-Befehls e8 - Near √§ndert sich nicht, da er im aktuellen Codesegment ausgef√ºhrt wird. Die n√§chsten 4 Bytes sind der Versatz relativ zu dem Wert im RIP-Register, an den die Steuerung √ºbertragen wird, d. H. RIP = RIP + Offset gem√§√ü Intel-Dokumentation (Entwicklerhandbuch f√ºr Intel 64- und IA-32-Architekturen-Software, Befehlssatzreferenz AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein relativer Versatz (rel16 oder rel32) wird im Assemblycode im Allgemeinen als Beschriftung angegeben. </font><font style="vertical-align: inherit;">Auf der Ebene des Maschinencodes wird es jedoch als vorzeichenbehafteter 16- oder 32-Bit-Sofortwert codiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Wert wird zum Wert im EIP-Register (RIP) addiert. </font><font style="vertical-align: inherit;">Im 64-Bit-Modus ist der relative Offset immer ein 32-Bit-Sofortwert, dessen Vorzeichen auf 64 Bit erweitert wird, bevor er dem Wert im RIP-Register f√ºr die Zielberechnung hinzugef√ºgt wird.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kennen die Adresse der Funktion foo, sie ist 0xffffffffc0000000, also in RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc ist der Offset zum Befehl e8, 1 Byte des Befehls und 4 Bytes des Offsets). </font><font style="vertical-align: inherit;">Wir kennen den Offset, weil </font><font style="vertical-align: inherit;">gedumpte K√∂rperfunktionen. </font><font style="vertical-align: inherit;">Berechnen wir, wohin der Anruf, der uns an die Funktion foo senden soll, gesendet wird:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Adresse der printk-Funktion:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt gilt das Gleiche f√ºr new_foo, dessen Adresse 0xffffffffc0007000 lautet</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In kallsyms gibt es keine solche Adresse, aber 0xffffffff810badf9 - 0x79 = 0xffffffff810bad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist genau die Funktion, bei der der Absturz passiert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Absturz zu verhindern, berechnen Sie einfach den Offset neu und kennen die Adresse der Funktion new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dieser Korrektur gibt es keinen Absturz, die Funktion new_foo wird erfolgreich ausgef√ºhrt und gibt die Steuerung zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist behoben. </font><font style="vertical-align: inherit;">Es bleibt nur zu verstehen, warum in der Disassembler-Liste der Offset nach dem e8-Opcode Null ist, aber es gibt keine Funktion im Dump. </font><font style="vertical-align: inherit;">√úberlegen Sie sich dazu, was Verschiebungen sind und wie der Kernel mit ihnen arbeitet. </font><font style="vertical-align: inherit;">Aber zuerst ein wenig zum ELF-Format.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF steht f√ºr Executable and Linkable Format - das Format f√ºr ausf√ºhrbare und zusammensetzbare Dateien. Eine ELF-Datei ist eine Sammlung von Abschnitten. Der Abschnitt speichert eine Reihe von Objekten, die der Linker ben√∂tigt, um ein ausf√ºhrbares Bild zu erstellen - Anweisungen, Daten, Symboltabellen, Aufzeichnungen von Verschiebungen usw. Jeder Abschnitt wird durch eine √úberschrift beschrieben. Alle Header werden in einer Tabelle mit Headern gesammelt und sind im Wesentlichen ein Array, in dem jedes Element einen Index hat. Der Abschnittskopf enth√§lt einen Versatz zum Anfang des Abschnitts und andere Overhead-Informationen, z. B. Links zu anderen Abschnitten, indem ein Index in der Kopfzeilentabelle angegeben wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Zusammenstellen unseres Testfalls kennt der Compiler die Adresse der printk-Funktion nicht, f√ºllt daher den Aufrufort mit einem Nullwert und teilt dem Kernel mithilfe eines Verschiebungsdatensatzes mit, dass diese Position mit einem g√ºltigen Wert gef√ºllt werden muss. Ein Umzugsdatensatz enth√§lt einen Versatz zu der Position, an der Sie √Ñnderungen vornehmen m√∂chten (Umzugsposition), die Art des Umzugs und den Index des Symbols in der Symboltabelle, dessen Adresse durch den angegebenen Versatz ersetzt werden muss. Wof√ºr ist die Art des Umzugs? Wir betrachten unten. Die √úberschrift des Abschnitts der Umzugsdatens√§tze verweist durch Indizes auf die √úberschriften des Abschnitts mit einer Tabelle von Zeichen und Abschnitten, zu deren Beginn ein Versatz zur Position des Umzugs angegeben ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen den Inhalt von Verschiebungsdatens√§tzen mit dem Dienstprogramm objdump mit der Option -r anzeigen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus der zerlegten Auflistung wissen wir, dass es bei Offset 0xD notwendig ist, die Adresse der printk-Funktion zu schreiben, daher suchen wir nach einer objdump-Ausgabe mit der folgenden Position:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also den erforderlichen Umzugsdatensatz, der die Position am Versatz 0xD angibt, und den Namen des Symbols, dessen Adresse an diese Position geschrieben werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wert (-4). </font><font style="vertical-align: inherit;">Die zur Adresse der printk-Funktion hinzugef√ºgte Funktion wird als Nachtrag bezeichnet und bei der Berechnung des Endergebnisses der Verlagerung ber√ºcksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich nun das printk-Symbol an:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Symbol, es ist innerhalb des Moduls undefiniert (undefiniert), daher werden wir es im Kernel suchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird informativer sein, die Aufzeichnungen √ºber Umz√ºge und Symbole in bin√§rer Form zu betrachten. </font><font style="vertical-align: inherit;">Dies kann mit Wireshark erfolgen und das ELF-Format analysieren. </font><font style="vertical-align: inherit;">Hier ist unser Umzugseintrag (Kopieren Einf√ºgen von Writeshark, LSB links):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie diesen Eintrag mit der Definition der entsprechenden Struktur aus &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir 8 Bytes Offset 0x00000000d, 4 Bytes Typ 0x00000002, 4 Bytes Index in der Zeichentabelle 0x00000022 (oder 34 in Dezimalzahl) und 8 Bytes Nachtrag -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist der Eintrag aus der Symboltabelle unter Nummer 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und verwandte Struktur</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten 4 Bytes 0x00000101 sind der Index in der Tabelle der Zeichenfolgen .strtab zum Namen dieses Zeichens, d. H. printk. Das Feld st_info definiert den Symboltyp. Es kann sich um eine Funktion, ein Datenobjekt usw. handeln. Weitere Informationen finden Sie in der ELF-Spezifikation. Wir werden das Feld st_other √ºberspringen, jetzt ist es f√ºr uns nicht mehr von Interesse, und uns die letzten drei Felder st_shndx, st_value und st_size ansehen. st_shndx - der Header-Index des Abschnitts, in dem das Zeichen definiert ist. Wir sehen hier einen Nullwert, weil Das Symbol ist im Modul nicht definiert und befindet sich nicht in den verf√ºgbaren Abschnitten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend sind auch sein st_value-Wert und seine st_size-Gr√∂√üe Null. Diese Felder werden beim Laden des Moduls vom Kernel ausgef√ºllt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich zum Vergleich das Symbol foo an, das deutlich vorhanden ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Symbol definiert eine Funktion, die sich im Textabschnitt an der Adresse relativ zum Anfang des Abschnitts 0x00000000 befindet, d. H. </font><font style="vertical-align: inherit;">Ganz am Anfang des Abschnitts, wie wir in der zerlegten Liste gesehen haben, betr√§gt die Funktionsgr√∂√üe 22 Bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objdump zeigt uns die gleichen Informationen dazu:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Kernel das Modul l√§dt, findet er alle undefinierten Zeichen und f√ºllt die Felder st_value und st_size mit g√ºltigen Werten. </font><font style="vertical-align: inherit;">Dies erfolgt in der Funktion simplify_symbols, Datei kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Parametern der Funktion wird die load_info-Struktur des folgenden Formulars √ºbergeben</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Felder sind f√ºr uns von Interesse: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - ELF-Dateikopf </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - Zeiger auf die Abschnittskopfzeilentabelle </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - Symbolnamentabelle - eine Reihe von Zeichenfolgen, die durch Nullen getrennt sind </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - index.sym - Index des Abschnittskopfes, der die Symboltabelle enth√§lt </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst erh√§lt die Funktion Zugriff zu dem Abschnitt mit der Symboltabelle. </font><font style="vertical-align: inherit;">Die Symboltabelle ist ein Array von Elementen vom Typ Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes gehen wir in der Schleife alle Zeichen in der Tabelle durch und bestimmen f√ºr jedes den Namen:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Feld st_shndx enth√§lt den Header-Index des Abschnitts, in dem dieses Zeichen definiert ist. </font><font style="vertical-align: inherit;">Wenn es einen Nullwert gibt (unser Fall), befindet sich dieses Symbol nicht im Modul. Sie m√ºssen es im Kernel suchen:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann kommt die Umzugswarteschlange in der Funktion apply_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Schleife suchen wir nach Verschiebungsabschnitten und verarbeiten die Datens√§tze jedes Abschnitts, die in der Funktion apply_relocate_add gefunden wurden:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Zeiger auf eine Abschnitts√ºberschriftentabelle, ein Zeiger auf eine Symbolnamentabelle, ein Abschnitts√ºberschriftenindex mit einer Symboltabelle und ein Verschiebungsabschnitts√ºberschriftenindex werden an apply_relocate_add √ºbergeben:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst befassen wir uns mit dem Abschnitt Umz√ºge:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann iterieren Sie in einer Schleife √ºber das Array seiner Eintr√§ge:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir finden den Abschnitt f√ºr den Umzug und die Position darin, d.h. </font><font style="vertical-align: inherit;">wo wir √Ñnderungen vornehmen m√ºssen. </font><font style="vertical-align: inherit;">Das Feld sh_info des Verschiebungsabschnittskopfs ist der Index des Abschnittskopfs f√ºr den Umzug, das Feld r_offset des Umzugsdatensatzes ist der Versatz zur Position innerhalb des Abschnitts f√ºr den Umzug:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Adresse des Zeichens, das an dieser Stelle unter Ber√ºcksichtigung des Nachtrags ersetzt werden soll. </font><font style="vertical-align: inherit;">Das Feld r_info des Umzugseintrags enth√§lt den Index dieses Symbols in der Symboltabelle:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Art der Verlagerung bestimmt das Endergebnis der Berechnungen. In unserem Beispiel ist dies R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir den endg√ºltigen Wert selbst berechnen, wobei wir wissen, dass sym-&gt; st_value die Adresse der printk-Funktion 0xffffffff810b3df9 ist, r_addend (-4) ist, der Versatz zur Position der Verschiebung 0xd vom Anfang des Modultextabschnitts oder vom Beginn der foo-Funktion ist, d. H. </font><font style="vertical-align: inherit;">wird ffffffffc000000d sein. </font><font style="vertical-align: inherit;">Ersetzen Sie alle diese Werte und erhalten Sie:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den Dump der foo-Funktion an, den wir ganz am Anfang haben:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Offset 0xD wird der Wert 0xc10b3de8 gefunden, der mit dem von uns berechneten identisch ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise verarbeitet der Kernel Verschiebungen und erh√§lt den erforderlichen Offset f√ºr den Befehl zum Schlie√üen des Aufrufs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Vorbereitung des Artikels wurde der Linux-Kernel Version 5.4.27 verwendet.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504414/index.html">Wie Microsoft AppGet get√∂tet hat</a></li>
<li><a href="../de504420/index.html">Schreiben einer rundenbasierten PvP-Arena mit gleichzeitigen Bewegungen</a></li>
<li><a href="../de504430/index.html">Alltag Tinkoff Security Operations Center: Analyse einzelner Bootloader</a></li>
<li><a href="../de504434/index.html">Bildungsprogramm f√ºr Eltern: Wie man Kinder im Internet vor Gefahren sch√ºtzt</a></li>
<li><a href="../de504438/index.html">30 Mitaps pro Woche. Wir er√∂ffnen die Sommersaison 2020</a></li>
<li><a href="../de504444/index.html">Verwenden von Docker mehrstufig zum Erstellen von Windows-Images</a></li>
<li><a href="../de504448/index.html">Gamers Generation II</a></li>
<li><a href="../de504450/index.html">Modernes JavaScript: eine Seitenansicht</a></li>
<li><a href="../de504452/index.html">Ontology startet Layer 2 und tr√§gt so zu einer st√§rker integrierten Plattform f√ºr √∂ffentliche Ketten bei</a></li>
<li><a href="../de504454/index.html">Beste GitHub-Repositories f√ºr Webentwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>