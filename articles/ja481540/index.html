<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏽 📑 💧 DMABUFを介したOpenGLESv2テクスチャの再読み込み 🖖🏽 🍴 🏇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、DMABUFを使用してOpenGLESテクスチャを更新するのがいかに簡単かについてお話します。私はHabrを調べましたが、驚いたことに、このトピックに関する記事は1つも見つかりませんでした。 Habrでは、Q＆Aでもこれについて何も見つかりませんでした。そして、これは私には少し奇妙です...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DMABUFを介したOpenGLESv2テクスチャの再読み込み</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、DMABUFを使用してOpenGLESテクスチャを更新するのがいかに簡単かについてお話します。私はHabrを調べましたが、驚いたことに、このトピックに関する記事は1つも見つかりませんでした。 Habrでは、Q＆Aでもこれについて何も見つかりませんでした。そして、これは私には少し奇妙です。このテクノロジーはかなり前に登場しましたが、実際にはネットワーク上にはあまり情報がありませんが、すべて曖昧で矛盾しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上のデモのようなビデオプレーヤーを作成する前に、さまざまなソースからこの情報を少しずつ収集しました。ここで、デモでは、gstreamerライブラリに基づく私の自作のビデオプレーヤーが、ビデオフレームをレンダリングする前に毎回OpenGLESv2テクスチャにロードします。 Raspberry Pi4を搭載。フレームは、特別に割り当てられたメモリにコピーされるだけです。DMAはフレームをGPUメモリ、テクスチャに転送します。次に、私がどのようにしたかをお話します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、OpenGLESv2を使用するプログラマは、テクスチャを1回だけ作成し、それをシーンオブジェクトにレンダリングします。これは、キャラクターのコスチュームがめったに変更されず、glTexSubImage2D（）を使用してテクスチャーを再ロードすることが難しくないためです。ただし、実際の問題は、テクスチャが動的で、レンダリング中にほぼすべてのフレームで更新する必要がある場合に始まります。 glTexSubImage2D（）関数は非常に遅いです。まあ、どれだけ遅いですか-もちろん、それはすべてコンピュータとグラフィックカードに依存します。 Raspberryのような弱いシングルボードカードでも機能するソリューションを見つけたかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SoCシングルボードを含む多くの最近のコンピューターのアーキテクチャーは、プロセッサー・メモリーがGPUメモリーから分離されているようなものです。通常、ユーザープログラムはGPUメモリに直接アクセスできないため、同じglTexSubImage2D（）などのさまざまなAPI関数を使用する必要があります。さらに、テクスチャの内部表現が、ピクセルのシーケンスとしての画像の従来の表現とは異なる場合があることをどこかで読みました。これがどれほど本当かわからない。多分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、DMABUFテクノロジは何をもたらすのでしょうか？メモリは特別に割り当てられ、任意のスレッドのプロセスは、必要なときにいつでもそこにピクセルを書き込むことができます。 DMA自体は、GPUのメモリ内のテクスチャへのすべての変更を転送します。きれいじゃないですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PBO-Pixel Buffer Objectについて知っていることをすぐに言わなければなりません。通常、テクスチャのPBO動的更新が使用され、DMAもそこで使用されているようですが、PBOはOpenGLESv3でのみ表示され、すべての実装では表示されません。だから、いや、ああ、これは私のやり方ではない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、Raspberryプログラマーとゲーム開発者の両方、そしておそらくAndroidプログラマーにも興味があるかもしれません。OpenGLESもそこで使用されており、このDMABUFテクノロジーもそこに存在していると確信しています（少なくともAndroidから使用できると確信しています）。 NDK）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raspberry Pi4でDMABUFを使用してプログラムを作成します。プログラムは、ubuntuの下など、通常のIntel x86 / x86_64コンピュータでも動作するはずです（動作します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、OpenGLESv2 APIを使用してグラフィックをプログラミングする方法をすでに知っていると想定しています。</font><font style="vertical-align: inherit;">ただし、これらの課題の多くはありません。</font><font style="vertical-align: inherit;">ほとんどの場合、ioctlマジックを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初に行うことは、プラットフォームで使用可能なAPIがDMABUFをサポートする必要があることを確認することです。</font><font style="vertical-align: inherit;">これを行うには、EGL拡張のリストを確認します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">char</span>* EglExtString = (<span class="hljs-keyword">char</span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS );
<span class="hljs-keyword">if</span>( <span class="hljs-built_in">strstr</span>( EglExtString, <span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span>) )<font></font>
{<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、DMABUFを使用する希望があるかどうか、または希望がないかどうかがすぐにわかります。</font><font style="vertical-align: inherit;">たとえば、Raspberry Pi3およびそれ以前のすべてのボードでは、希望はありません。</font><font style="vertical-align: inherit;">そこでは、一般的に、OpenGLESv2でさえも、BRCMブローチを備えた特別なライブラリーによって、なんらかの形で取り除かれています。</font><font style="vertical-align: inherit;">そして、ここRaspberry Pi4ですでに-実際のOpenGLESで、拡張機能EGL_EXT_image_dma_buf_importがありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルボードPi4のOSをすぐに確認します。そうしないと、これに問題が発生する可能性があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a<font></font>
No LSB modules are available.<font></font>
Distributor ID: Raspbian<font></font>
Description:    Raspbian GNU/Linux 10 (buster)<font></font>
Release:        10<font></font>
Codename:       buster<font></font>
pi@raspberrypi:~ $ uname -a<font></font>
Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EGL_EXT_image_dma_buf_import拡張機能がOrange Pi PC（Mali-400）/ PC2（Mali-450）にあることにも注意します。もちろん、これらのボードでMali GPUを実行できる場合を除きます（公式アセンブリでは実行できません。Armbianにインストールしましたが、自分でインストールしました）カーネルドライバーアセンブリ）。つまり、DMABUFはほとんどどこにでもあります。服用して使用するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ファイル/ dev / dri / card0または/ dev / dri / card1を開く必要があります-それらの1つは、プラットフォームによって異なりますが、状況は異なります。DRM_CAP_DUMB_BUFFERをサポートするファイルを探す必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">OpenDrm</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">"/dev/dri/card0"</span>, O_RDWR | O_CLOEXEC);
	<span class="hljs-keyword">if</span>( fd &lt; <span class="hljs-number">0</span> )<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"cannot open /dev/dri/card0\n"</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">uint64_t</span> hasDumb = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number">0</span> )<font></font>
	{<font></font>
		close( fd );<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span>;<font></font>
<font></font>
		<span class="hljs-comment">//maybe Raspberry Pi4 or other platform</span>
		fd = open(<span class="hljs-string">"/dev/dri/card1"</span>, O_RDWR | O_CLOEXEC);
		<span class="hljs-keyword">if</span>( fd &lt; <span class="hljs-number">0</span> )<font></font>
		{<font></font>
			<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"cannot open /dev/dri/card1\n"</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
		}<font></font>
<font></font>
		hasDumb = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number">0</span> )<font></font>
		{<font></font>
			close( fd );<font></font>
			<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"/dev/dri/card1 has no support for DUMB_BUFFER\n"</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">if</span>( !hasDumb )<font></font>
	{<font></font>
		close( fd );<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"no support for DUMB_BUFFER\n"</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//Get DRM authorization</span>
	<span class="hljs-keyword">drm_magic_t</span> magic;
	<span class="hljs-keyword">if</span>( drmGetMagic(fd, &amp;magic) )<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"no DRM magic\n"</span>;<font></font>
		close( fd );<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
<font></font>
	Window root = DefaultRootWindow( x_display );<font></font>
	<span class="hljs-keyword">if</span>( !DRI2Authenticate( x_display, root, magic ) )<font></font>
	{<font></font>
		close( fd );<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed DRI2Authenticate\n"</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DRM fd "</span>&lt;&lt; fd &lt;&lt;<span class="hljs-string">"\n"</span>;
	<span class="hljs-keyword">return</span> fd;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで、ちなみに私には不可解な微妙さがあります。</font><font style="vertical-align: inherit;">一部のプラットフォームには、DRI2Authenticate（）関数を提供するライブラリーがありません。</font><font style="vertical-align: inherit;">たとえば、Orange Pi PCの32ビットバージョンでは、これは現状ではありません。</font><font style="vertical-align: inherit;">これはすべて奇妙です。</font><font style="vertical-align: inherit;">しかし、私はGITHUBでそのようなリポジトリを見つけました：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/robclark/libdri2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは取得、アセンブル、</font><font style="vertical-align: inherit;">インストールでき</font><font style="vertical-align: inherit;">、すべて問題ありません。</font><font style="vertical-align: inherit;">ラップトップ上の私のUbuntu 18（64ビット）では、これに問題がないのは奇妙です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
/ dev / dri / cardXを見つけて開くことができれば、次に進むことができます。</font><font style="vertical-align: inherit;">KHR（Khronos）の3つの非常に必要な機能にアクセスする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC  funcEglCreateImageKHR = <span class="hljs-literal">nullptr</span>;<font></font>
PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal">nullptr</span>;<font></font>
PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
...<font></font>
funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string">"eglCreateImageKHR"</span>);<font></font>
funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string">"eglDestroyImageKHR"</span>);<font></font>
funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string">"glEGLImageTargetTexture2DOES"</span>);
<span class="hljs-keyword">if</span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES )<font></font>
{<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DMA_BUF feature supported!!!\n"</span>;<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	CloseDrm();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、DMABUFのメモリ領域を作成する関数が必要です。</font><font style="vertical-align: inherit;">この関数は、ビットマップの幅、高さ、およびDmaFdファイル記述子ハンドラーへのポインターと、プレーンビットマップメモリ​​へのポインターとしてパラメーターを受け取ります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">nt <span class="hljs-title">CreateDmaBuf</span><span class="hljs-params">( <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height, <span class="hljs-keyword">int</span>* DmaFd, <span class="hljs-keyword">void</span>** Plane )</span>
</span>{
	<span class="hljs-keyword">int</span> dmaFd = *DmaFd = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">void</span>* pplane = *Plane = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-comment">// Create dumb buffer</span>
	drm_mode_create_dumb buffer = { <span class="hljs-number">0</span> };<font></font>
	buffer.width = Width;<font></font>
	buffer.height = Height;<font></font>
	buffer.handle = <span class="hljs-number">0</span>;<font></font>
	buffer.bpp = <span class="hljs-number">32</span>; <span class="hljs-comment">//Bits per pixel</span>
	buffer.flags = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">int</span> ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer);
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DRM_IOCTL_MODE_CREATE_DUMB "</span> &lt;&lt; buffer.handle &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ret &lt;&lt; <span class="hljs-string">"\n"</span>;
	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Get the dmabuf for the buffer</span><font></font>
	drm_prime_handle prime;<font></font>
	<span class="hljs-built_in">memset</span>(&amp;prime, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> prime);<font></font>
	prime.handle = buffer.handle;<font></font>
	prime.flags = <span class="hljs-comment">/*DRM_CLOEXEC |*/</span> DRM_RDWR;<font></font>
<font></font>
	ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime);<font></font>
	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD "</span> &lt;&lt; errno &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ret &lt;&lt;<span class="hljs-string">"\n"</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
	dmaFd = prime.fd;<font></font>
	<span class="hljs-comment">// Map the buffer to userspace</span>
	<span class="hljs-keyword">int</span> Bpp = <span class="hljs-number">32</span>;<font></font>
	pplane = mmap(<span class="hljs-literal">NULL</span>, Width*Height*Bpp/<span class="hljs-number">8</span>, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span>( pplane == MAP_FAILED )<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error cannot mmap\n"</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//return valid values</span><font></font>
	*DmaFd = dmaFd;<font></font>
	*Plane = pplane;<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DMABUF created "</span>&lt;&lt; dmaFd &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; (<span class="hljs-keyword">void</span>*)Plane &lt;&lt;<span class="hljs-string">"\n"</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、DmaFdハンドラーに関連付けられたEGLイメージを作成する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateDmaBufferImage</span><span class="hljs-params">( ESContext* esContext, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height, <span class="hljs-keyword">int</span>* DmaFd, <span class="hljs-keyword">void</span>** Plane, EGLImageKHR* Image )</span>
</span>{
	<span class="hljs-keyword">int</span> dmaFd = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">void</span>* planePtr = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">int</span> Bpp = <span class="hljs-number">32</span>;
	<span class="hljs-keyword">int</span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr );
	<span class="hljs-keyword">if</span>( ret0&lt;<span class="hljs-number">0</span> )
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
	EGLint img_attrs[] = {<font></font>
		EGL_WIDTH, Width,<font></font>
		EGL_HEIGHT, Height,<font></font>
		EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888,<font></font>
		EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd,<font></font>
		EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number">0</span>,<font></font>
		EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number">8</span>,<font></font>
		EGL_NONE<font></font>
	};<font></font>
<font></font>
	EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number">0</span>, &amp;img_attrs[<span class="hljs-number">0</span>] );<font></font>
<font></font>
	*Plane = planePtr;<font></font>
	*DmaFd  = dmaFd;<font></font>
	*Image = image;<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DMA_BUF pointer "</span> &lt;&lt; (<span class="hljs-keyword">void</span>*)planePtr &lt;&lt; <span class="hljs-string">"\n"</span>;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DMA_BUF fd "</span> &lt;&lt; (<span class="hljs-keyword">int</span>)dmaFd &lt;&lt; <span class="hljs-string">"\n"</span>;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"EGLImageKHR "</span> &lt;&lt; image &lt;&lt; <span class="hljs-string">"\n"</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、試練はほぼ終わり、EGLイメージとOpenGLESv2イメージをリンクする必要があります。</font><font style="vertical-align: inherit;">この関数は、プロセスのアドレス空間のメモリへのポインタを返します。</font><font style="vertical-align: inherit;">そこでは、任意のプロセッサスレッドから単純に書き込むことができ、時間の経過に伴うすべての変更は、DMABUFを介してGPUテクスチャに自動的に表示されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">CreateVideoTexture</span><span class="hljs-params">( ESContext* esContext, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height )</span>
</span>{<font></font>
	CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR );<font></font>
	GLuint texId;<font></font>
	glGenTextures ( <span class="hljs-number">1</span>, &amp;texId );<font></font>
	glBindTexture ( GL_TEXTURE_2D, texId );<font></font>
	glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );<font></font>
	glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );<font></font>
	glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );<font></font>
	glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );<font></font>
	funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR );<font></font>
	checkGlError( __LINE__ );<font></font>
	UserData *userData = (UserData*)esContext-&gt;userData;<font></font>
	userData-&gt;textureV = texId;<font></font>
	userData-&gt;textureV_ready = <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">return</span> esContext-&gt;Plane;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GlEGLImageTargetTexture2DOES（..）関数はこのバインディングを行うだけです。</font><font style="vertical-align: inherit;">通常のテクスチャIDの作成であるglGenTextures（..）を使用し、以前に作成されたesContext-&gt; ImageKHR EGL画像に関連付けます。</font><font style="vertical-align: inherit;">その後、テクスチャuserData-&gt; textureVを通常のシェーダーで使用できます。</font><font style="vertical-align: inherit;">また、esContext-&gt; Planeポインタは、テクスチャを更新するために書き込む必要があるメモリ内の領域へのポインタです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオフレームをコピーするコードスニペットを次に示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">GstFlowReturn <span class="hljs-title">on_new_sample</span><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span>
</span>{<font></font>
	GstFlowReturn ret = GST_FLOW_OK;<font></font>
	GstSample *Sample = gst_app_sink_pull_sample(pAppsink);<font></font>
	<span class="hljs-keyword">if</span>( Sample )<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span>( VideoWidth==<span class="hljs-number">0</span> || VideoHeight==<span class="hljs-number">0</span> )<font></font>
		{<font></font>
			GstCaps* caps = gst_sample_get_caps( Sample );<font></font>
			GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number">0</span>);<font></font>
			gst_structure_get_int (structure, <span class="hljs-string">"width"</span>, &amp;VideoWidth);<font></font>
			gst_structure_get_int (structure, <span class="hljs-string">"height"</span>, &amp;VideoHeight);
			<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Stream Resolution "</span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
		}<font></font>
<font></font>
		GstBuffer *Buffer = gst_sample_get_buffer( Sample );<font></font>
		<span class="hljs-keyword">if</span>( Buffer )<font></font>
		{<font></font>
			GstMapInfo MapInfo;<font></font>
			<span class="hljs-built_in">memset</span>(&amp;MapInfo, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(MapInfo));<font></font>
			gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ );<font></font>
			<span class="hljs-keyword">if</span>( Mapped )<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span>( dmabuf_ptr )
					<span class="hljs-built_in">memcpy</span>( dmabuf_ptr, MapInfo.data, MapInfo.size );<font></font>
				gst_buffer_unmap( Buffer, &amp;MapInfo);<font></font>
				frame_ready = <span class="hljs-literal">true</span>;<font></font>
				update_cv.notify_one();<font></font>
			}<font></font>
		}<font></font>
		gst_sample_unref( Sample );<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、新しいビデオフレームが表示されるたびにgstreamer自体によって呼び出されます。 gst_app_sink_pull_sample（）を使用して取得します。この関数には、フレームをDMABUFメモリにコピーするmemcpy（）があります。次に、frame_readyフラグが設定され、std :: condition_variable update_cv.notify_one（）を介して、レンダリングするストリームが起こされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはおそらくすべてです... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、私は嘘をついています。まだ同期の問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、プロセッサはメモリに書き込みますが、これらのレコードは最終的にプロセッサのキャッシュに保存され、そこに保持される可能性があります。記録後、キャッシュキャッシュを作成する必要があります。 2番目-DMAが既に機能していて、レンダリングを開始できる時期を正確に知ることは悪くありません。正直なところ、最初の方法がまだどうすればよいか想像している場合、2番目の方法は-いいえ。アイデアがあればコメントに書いてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして一瞬。ビデオファイルを再生するgstreamerを使用しています。ビデオフレームを受け取る一般的なアプリシンクをパイプラインに追加しました。ビデオフレームからピクセルを取り出し、それらをmemcpy（）をDMABUFメモリ領域にコピーします。レンダリングは別のスレッドmain（）で行われます。しかし、私はこのコピーを削除したいと思います。すべてのコピーは悪です。そのような用語ゼロコピーさえあります。また、ドキュメントから判断すると、gstreamer自体がDMABUFですぐにフレームをレンダリングできるようです。残念ながら、実際の例は1つも見つかりませんでした。私はgstreamerのソースを見ました-それについて何かがありますが、それを正確に使用する方法は明確ではありません。 OpenGLESv2テクスチャでgstreamerを使用して実際のゼロコピーフレームを作成する方法を知っている場合は、書き込んでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく最後のポイント：私のプロジェクトでは32ビットのビットマップを使用していますが、これは私の場合には良くありません。</font><font style="vertical-align: inherit;">gstreamerからYUVを取得する方がはるかに合理的です。ビデオフレームサイズは大幅に小さくなりますが、ロジックは複雑です-3つのテクスチャに対して3つのDMABUFをY、U、Vに個別に実行する必要があります。シェーダーで。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクト全体</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をgithubで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、クリーンで正しいコード/スタイルの愛好家には、事前に謝罪します。</font><font style="vertical-align: inherit;">Google-mine-pasteの助けを借りて不注意に書かれたことを認めます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481530/index.html">ネヴァンゲル：スピードを求めて</a></li>
<li><a href="../ja481532/index.html">メモリフォレンジック、ラバーダック、GPOパスワード。r0ot-miによる問題解決。パート2</a></li>
<li><a href="../ja481534/index.html">デルファイは瀕死ですか-False</a></li>
<li><a href="../ja481536/index.html">ドメインネームシステムの歴史：「戦争」プロトコル</a></li>
<li><a href="../ja481538/index.html">2020年に死ぬ20のSEO神話</a></li>
<li><a href="../ja481542/index.html">デジタル回路の検証。概観</a></li>
<li><a href="../ja481544/index.html">畳み込みニューラルネットワークを使用して（Kerasで）Lifeをプレイする</a></li>
<li><a href="../ja481546/index.html">マイクロプロセッサとパーソナルコンピュータの歴史：1947-1974</a></li>
<li><a href="../ja481548/index.html">JavaScriptのSymbol.iterator</a></li>
<li><a href="../ja481550/index.html">インマルサット：自宅で衛星信号を受信して​​デコード</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>