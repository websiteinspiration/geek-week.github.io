<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåô üôãüèº ‚ôªÔ∏è Implementing the RAFT Consensus Algorithm for Distributed KV Storage in Java üèçÔ∏è üìô üë≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again. A few days ago, training began in a new group on the course ‚ÄúSoftware Architect‚Äù , and today we would like to share an article written by...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Implementing the RAFT Consensus Algorithm for Distributed KV Storage in Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/495356/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello again. A few days ago, training began in a new group on the course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúSoftware Architect‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and today we would like to share an article written by one of the students of the course, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Pleshakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (head of development at Program Logistics and co-founder at Clusterra).</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/pb/5h/qq/pb5hqqeunfv8gkvyvspmegwuj4w.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Currently, distributed microservice systems have become virtually the industry standard, and not only in the enterprise world. The benefits of using distributed systems have been described and discussed more than once. The advantages of microservices have long been known to everyone: technologies for the task, composability, scalability, development scaling, TTM reduction, and so on. It is obvious that the development of distributed applications provides more options for timely response to growing business demands and digitalization of everything around.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also important to note that at the moment a very important factor affecting the choice of a development strategy in favor of microservices is the availability of all kinds of ready-made infrastructure solutions that take on the solution of problems associated with the additional costs of operating a distributed system. We are talking about container orchestration systems, service mash, means of distributed tracing, monitoring, logging and so on. It can be safely stated that most of the factors previously mentioned as the minuses of the microservice approach today do not have as much influence as a couple of years ago.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on modern realities, most developers seek at the first opportunity to switch from a monolithic structure to a microservice one. One of the first steps that can be taken without resorting to total refactoring and serious decomposition is to achieve a horizontal scalability system. That is, to turn your monolithic application into a cluster, possibly even consisting of the same monoliths, but allowing you to dynamically vary their number.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When trying to achieve horizontal scalability, the question of data synchronization within a cluster very quickly and very acutely arises. Fortunately, all modern DBMSs support data replication between nodes in one way or another. The developer just needs to select the DBMS for the task and decide what properties of the system (according to the CAP theorem) he needs, CP or AP, and the issue is resolved. In the case when CP is required and the requirements for consistency are high, one of the methods to solve the data synchronization problem is to use a cluster that supports the RAFT consensus algorithm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This rather new algorithm (was developed in 2012) gives a high guarantee of consistency and is very popular. I decided to figure out how it works, and wrote my implementation of a consistent key-value repository in Java (Spring Boot).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Does it make sense to implement any distributed algorithm yourself? It is clear that you can take a ready-made implementation of a distributed algorithm, and with the highest degree of probability this implementation will be better than a home-made ‚Äúbicycle‚Äù. For example, you can use a DBMS that maintains the required level of consistency. Or you can deploy </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zookeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Or you can find a framework suitable for your language. For java, there is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which perfectly solves the problems of synchronizing distributed data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But on the other side. If you take a turnkey solution, then using an external application is usually adding an additional point of failure to your system. And frameworks can be redundant or difficult to operate and learn, or they may not exist at all for your programming language. In addition, the independent implementation of the consensus algorithm is an extremely interesting engineering task that broadens your horizons and gives you an understanding of how to solve the problems that arise when services interact in a cluster using the more optimal method.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the specification of the algorithm contains a set of measures to maintain data integrity, you can use the acquired knowledge and even use the algorithm in its entirety. Any part of the algorithm can be useful in real life. Suppose you have a set of workers for parsing files in parallel. Workers are equivalent, but you want to designate one of the workers as a coordinator, and when the coordinating worker falls, assign any other free worker as coordinator. The first half of the RAFT algorithm, which describes how to choose a leader among equivalent nodes, will help you with this. Or, for example, if you have only two nodes in relation to master-slave, you can very well use the replication rules described in the RAFT specification for organizing data exchange in your simpler case.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The article is essentially a practical guide on how to implement RAFT yourself. </font><font style="vertical-align: inherit;">The algorithm itself and the theoretical aspects of its work will not be understood. </font><font style="vertical-align: inherit;">You can read a brief description here in this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excellent article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or study the full specification </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There you can find a very clear visualization of the algorithm.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General Solution Description</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The part of the code that is directly related to the implementation of the algorithm is analyzed in the article. </font><font style="vertical-align: inherit;">At the end of the article there is a link to the repository, where you can see the whole code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The task was as follows. </font><font style="vertical-align: inherit;">Develop a distributed system that allows you to store data in a key-value database. </font><font style="vertical-align: inherit;">The data of each node must be consistent, namely, if the data fell into the database of one node and most of the nodes confirmed that they also received this data, then sooner or later this data will be in the database of each node. </font><font style="vertical-align: inherit;">When a part of the cluster is disconnected and when it is connected back, the nodes that were outside the cluster must catch up with the main cluster and synchronize. </font><font style="vertical-align: inherit;">Each node provides a REST API for writing and reading database data. </font><font style="vertical-align: inherit;">The system consists of two modules for two types of nodes: client and server. </font><font style="vertical-align: inherit;">Below we consider the features of the implementation of the server itself. </font><font style="vertical-align: inherit;">The client code is in the repository. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A server node can operate in three states:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Follower (follower). </font><font style="vertical-align: inherit;">Accepts read requests from the client. </font><font style="vertical-align: inherit;">Takes a heartbeat from the leader</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candidate (candidate). </font><font style="vertical-align: inherit;">Accepts read requests from the client. </font><font style="vertical-align: inherit;">Sends vote requests to other nodes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leader </font><font style="vertical-align: inherit;">Accepts read and write requests. </font><font style="vertical-align: inherit;">Sends heartbeat requests to other nodes. </font><font style="vertical-align: inherit;">Sends append requests data to other nodes.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The period of ‚Äúleadership‚Äù of one of the nodes is called the round (term). </font><font style="vertical-align: inherit;">A new candidate opens a new round.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data storage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each node provides access to the repository of the operation log, in which operations for changing data are sequentially recorded.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/operations/OperationsLog.java<br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OperationsLog</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(Operation operation)</span></span>;
   <span class="hljs-function">Operation <span class="hljs-title">get</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">List&lt;Operation&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function">Long <span class="hljs-title">getTerm</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">Integer <span class="hljs-title">getLastIndex</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">Long <span class="hljs-title">getLastTerm</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAllFromIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newOperationIndex)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each operation, in addition to data and type (insert, change, delete), contains the number of the round in which it was created. In addition, each operation has an index that increases sequentially. It is important that all operations are inserted into the logs of followers in the same order in which they are inserted into the leader‚Äôs log. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each node has access to a database in which data is stored directly.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/storage/Storage.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Storage</span> </span>{
   <span class="hljs-function">List&lt;Entry&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(Long key)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long key)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the current implementation, embedded in-memory solutions are used both for the log and for the database (ordinary competitive List and Map). If necessary, you can simply implement the appropriate interface to support other types of storage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The application of operations from the log to the database is carried out by a distributed state machine. A state machine is such a mechanism that is responsible for changing the state of a cluster by restricting the use of incorrect changes (out-of-order operations or a disconnected node that considers itself a leader). In order for the changes to be considered valid and in order for them to be applied to the database, they must pass a series of checks and meet certain criteria, which is exactly what the state machine provides.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a leader, an operation is applied to the database if most of the nodes have confirmed the fact that the operation is replicated to their log too. </font><font style="vertical-align: inherit;">For a follower, the operation is applied to the database if a signal is received from the leader that she got into his database.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each node provides data exchange with other nodes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two types of queries are supported:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vote when conducting a round of voting</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">append, aka heartbeat (if without data), to replicate log data to followers and to prevent the start of a new round of voting.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The fact of the onset of an event is determined by the timer. </font><font style="vertical-align: inherit;">Two types of timers are launched on the node:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vote. </font><font style="vertical-align: inherit;">To start a round of voting. </font><font style="vertical-align: inherit;">Each node has its own interval, after which it will try to start a new vote. </font><font style="vertical-align: inherit;">The countdown starts anew when receiving a heartbeat from the leader.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heartbeat. </font><font style="vertical-align: inherit;">To send a request to followers by the append leader. </font><font style="vertical-align: inherit;">If the node does not receive a heartbeat and the voting timer has expired, it becomes a candidate and initiates elections, increases the number of the voting round and sends out voting requests to other nodes. </font><font style="vertical-align: inherit;">If the node collects the majority of votes, then it becomes the leader and starts sending out heartbeat.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current state of the node</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each node stores data about the current state.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/context/Context.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Context</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//: , ,  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getVotedFor</span><span class="hljs-params">()</span></span>; 
               <span class="hljs-comment">//          </span>
   <span class="hljs-function">Long <span class="hljs-title">getCurrentTerm</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getCommitIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">List&lt;Peer&gt; <span class="hljs-title">getPeers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//      </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A leader node also stores metadata for the nodes to which it replicates data.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/node/peers/Peer.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Peer</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getNextIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  ,    </span>
   <span class="hljs-function">Integer <span class="hljs-title">getMatchIndex</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//   </span>
   <span class="hljs-function">Boolean <span class="hljs-title">getVoteGranted</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//     </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Node metadata is updated by the leader when receiving responses from followers. </font><font style="vertical-align: inherit;">They are used to determine by the leader which next index operation the follower is ready to accept and which operations have already been added to the follower's log.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voting</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">ElectionService</font></a><font style="vertical-align: inherit;"> class is responsible for voting</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectionService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processElection</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO requestVoteDTO)</span></span>;<font></font>
} </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sending a request for voting </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the node is a follower and does not receive a heartbeat for the period set for the wait, then it increases its current round, declares itself a candidate and begins to send vote requests to other nodes. </font><font style="vertical-align: inherit;">If he manages to gather a quorum and most of the nodes cast his vote, he will become the new leader. </font><font style="vertical-align: inherit;">In RAFT terms, quorum is more than half of all nodes (51%). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's analyze the </font></font><code>processElection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font><font style="vertical-align: inherit;">method </font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is called by the vote-timer when the vote expires and sends the nodes a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">request for voting</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
 <br>
<pre><code class="java hljs"><span class="hljs-comment">//1</span><font></font>
context.setState(CANDIDATE); <font></font>
Long term = context.incCurrentTerm(); <font></font>
context.setVotedFor(context.getId()); <font></font>
<font></font>
List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<span class="hljs-keyword">long</span> voteGrantedCount = <span class="hljs-number">1L</span>;
<span class="hljs-keyword">long</span> voteRevokedCount = <span class="hljs-number">0L</span>;<font></font>
<font></font>
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">while</span> (checkCurrentElectionStatus(term)) {<font></font>
   List&lt;AnswerVoteDTO&gt; answers = getVoteFromAllPeers(term, peersIds);<font></font>
   peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">for</span> (AnswerVoteDTO answer : answers) {
       <span class="hljs-comment">//3</span>
       <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
           <span class="hljs-comment">//4</span>
           <span class="hljs-keyword">if</span> (answer.getTerm()&gt;context.getCurrentTerm()) {<font></font>
               context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
               <span class="hljs-keyword">return</span>;<font></font>
           }<font></font>
           <span class="hljs-keyword">if</span> (answer.isVoteGranted()) {
               <span class="hljs-comment">//5 </span>
               context.getPeer(answer.getId()).setVoteGranted(<span class="hljs-keyword">true</span>);<font></font>
               voteGrantedCount++;<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-comment">//6 </span><font></font>
               voteRevokedCount++;<font></font>
       } <span class="hljs-keyword">else</span> {<font></font>
          peersIds.add(answer.getId());<font></font>
       }<font></font>
   }<font></font>
  <span class="hljs-comment">//7</span>
  <span class="hljs-keyword">if</span> (voteGrantedCount &gt;= context.getQuorum()) {<font></font>
       winElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (voteRevokedCount &gt;= context.getQuorum()) {<font></font>
       loseElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } </code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set the status of ‚ÄúCandidate‚Äù. </font><font style="vertical-align: inherit;">Raise the round number and vote for ourselves.</font></font></li>
<li>  ,       (    ).  -  ,        ,           heartbeat                 .</li>
<li> -  ,    .    ,      ,     -. </li>
<li>       ,                            .     ,      heartbeat     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The node voted for us! </font><font style="vertical-align: inherit;">We increase the number of nodes casting votes for us and fix that this node voted for us.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voted not for us, we also believe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the quorum is collected and the node won the election, we establish the status of ‚ÄúLeader‚Äù. </font><font style="vertical-align: inherit;">Otherwise, we become a follower and wait.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should also be noted that when a node becomes a leader, the Next Index is set for each node in the list of nodes stored at the leader, which is equal to the last index in the leader‚Äôs log plus 1. Starting from this index, the leader will try to update the follower logs. </font><font style="vertical-align: inherit;">In fact, this index stored by the leader may not correspond to the real index of the follower‚Äôs log and the actual value will be obtained only when exchanging data with the follower and will be adjusted. </font><font style="vertical-align: inherit;">But some </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starting point is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> needed </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">winElection</span><span class="hljs-params">(Long term)</span> </span>{<font></font>
       context.setState(LEADER);<font></font>
       context.getPeers().forEach(peer -&gt;<font></font>
               peer.setNextIndex(operationsLog.getLastIndex()+<span class="hljs-number">1</span>)<font></font>
<font></font>
       );<font></font>
   }</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voting request processing </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When voting, each node receives a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">request of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> following </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">form</font></a><font style="vertical-align: inherit;"> from the candidate </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestVoteDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer candidateId; <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer lastLogIndex; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long lastLogTerm; <span class="hljs-comment">//       </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at the </font></font><code>vote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font><font style="vertical-align: inherit;">procedure </font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it processes the vote request from the candidate and returns a decision regarding his candidacy for the role of leader.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/election/ElectionServiceImpl.java#L178 <br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO dto)</span> </span>{<font></font>
   <font></font>
       <span class="hljs-keyword">boolean</span> termCheck;
       <span class="hljs-comment">//1</span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm())
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>);
       <span class="hljs-keyword">else</span> <span class="hljs-comment">//2</span>
       <span class="hljs-keyword">if</span> (dto.getTerm().equals(context.getCurrentTerm())) {<font></font>
           termCheck = (context.getVotedFor() == <span class="hljs-keyword">null</span>||<font></font>
                          context.getVotedFor().equals(dto.getCandidateId()));<font></font>
       }<font></font>
       <span class="hljs-keyword">else</span>
       {   <span class="hljs-comment">//3</span>
           termCheck = <span class="hljs-keyword">true</span>;<font></font>
             context.setTermGreaterThenCurrent(dto.getTerm());<font></font>
       }<font></font>
<font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">boolean</span> logCheck = !((operationsLog.getLastTerm() &gt; dto.getLastLogTerm()) ||<font></font>
               ((operationsLog.getLastTerm().equals(dto.getLastLogTerm())) &amp;&amp;<font></font>
                       (operationsLog.getLastIndex() &gt; dto.getLastLogIndex())));<font></font>
<font></font>
<font></font>
       <span class="hljs-keyword">boolean</span> voteGranted = termCheck&amp;&amp;logCheck;<font></font>
<font></font>
       <span class="hljs-comment">//5</span>
       <span class="hljs-keyword">if</span> (voteGranted) {<font></font>
           context.setVotedFor(dto.getCandidateId());<font></font>
       }<font></font>
       <span class="hljs-comment">//6   </span>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),voteGranted);<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Upon receiving a request from a candidate, the node makes two checks: checks the candidate‚Äôs round and the length of his log. </font><font style="vertical-align: inherit;">If the candidate‚Äôs round is higher and its log is longer or equal, then the node gives its node a vote for the candidate</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the current round of the knot is larger than the round of the candidate, we refuse, because this is a request of some lagging knot, which, apparently, was outside the cluster for some time and started the election procedure because it did not see the current leader. </font></font></li>
<li>   ,   , ,           ,        ,     ,       ;       .              ‚Äî    .</li>
<li>     ,     </li>
<li> .                   ,            ,  ,        ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With a positive outcome, we fix the fact that the node took part in the elections and cast a vote for the candidate.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send the result back to the candidate</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surely, the conditions could be written somewhat shorter and more elegant, but I left such a more ‚Äúnaive‚Äù option so as not to get confused myself and not to confuse anyone. </font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replication </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The timer leader sends heartbeat followers to all nodes to reset their voting timers. Since the leader stores in his metadata indices of the last operations of all followers, he can evaluate whether sending the operation to nodes is required. If the leader‚Äôs operations log becomes longer than the log of any follower, then he, along with heartbeat, sequentially sends him the missing operations. Call it append request. If most nodes confirm receipt of new operations, the leader applies these operations to his database and increases the index of the last applied operation. This index is also sent to followers along with a heartbeat request. And if the leader index is higher than the follower index, then the follower also applies operations to its database in order to equalize the indices. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This kind of append request the leader sends to the follower</font></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestAppendDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderId; <span class="hljs-comment">//   </span><font></font>
<font></font>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer prevLogIndex;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long prevLogTerm;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderCommit;<span class="hljs-comment">//      </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Operation operation; <span class="hljs-comment">//</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are implementations in which operations are transferred in batches of several per request. </font><font style="vertical-align: inherit;">In the current implementation, only one operation can be transmitted per </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
request. The class responds to sending and processing the heartbeat-append request:</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationService.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReplicationService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO requestAppendDTO)</span></span>;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Submit a data change request </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a fragment of a </font></font><code>sendAppendForOnePeer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font></font><code>ReplicationServiceImpl</code><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method. The method is responsible for generating a request to the follower and sending it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> CompletableFuture&lt;AnswerAppendDTO&gt; <span class="hljs-title">sendAppendForOnePeer</span><span class="hljs-params">(Integer id)</span> </span>{
   <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
       <span class="hljs-keyword">try</span> {
           <span class="hljs-comment">//1</span><font></font>
           Peer peer = context.getPeer(id);<font></font>
<font></font>
           Operation operation;<font></font>
           Integer prevIndex;<font></font>
           <span class="hljs-comment">//2    </span>
           <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex()) {<font></font>
               operation = operationsLog.get(peer.getNextIndex());<font></font>
               prevIndex = peer.getNextIndex() - <span class="hljs-number">1</span>;<font></font>
           } <span class="hljs-keyword">else</span> 
           <span class="hljs-comment">//3  </span><font></font>
           {<font></font>
               operation = <span class="hljs-keyword">null</span>;<font></font>
               prevIndex = operationsLog.getLastIndex();<font></font>
           }<font></font>
<font></font>
<font></font>
           RequestAppendDTO requestAppendDTO = <span class="hljs-keyword">new</span> RequestAppendDTO(<font></font>
                   context.getCurrentTerm(), <span class="hljs-comment">//   </span>
                   context.getId(), <span class="hljs-comment">//  </span>
                   prevIndex,<span class="hljs-comment">//      </span>
                   operationsLog.getTerm(prevIndex),<span class="hljs-comment">//  </span><font></font>
                   context.getCommitIndex(),<font></font>
                               <span class="hljs-comment">//      </span>
                   Operation <span class="hljs-comment">//</span><font></font>
           );<font></font>
<font></font>
...<font></font>
<span class="hljs-comment">/*   http     */</span>
}</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Follower metadata</font></font></li>
<li>   ,   .             (      ),          ,      ,  ,   .    ,       ,    ,   ,     </li>
<li>   ,    ,       ;        ,     ,       ,  </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, consider the </font></font><code>appendRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font><font style="vertical-align: inherit;">method </font></font><code>ReplicationServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is responsible for sending the append request and processing the result to all followers.</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationServiceImpl.java#L109</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span> </span>{<font></font>
       List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<font></font>
       <span class="hljs-comment">//1 </span>
       <span class="hljs-keyword">while</span> (peersIds.size() &gt; <span class="hljs-number">0</span>) {
           <span class="hljs-comment">//2 </span><font></font>
           List&lt;AnswerAppendDTO&gt; answers = sendAppendToAllPeers(peersIds);<font></font>
           peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
           <span class="hljs-keyword">for</span> (AnswerAppendDTO answer : answers) {
               <span class="hljs-comment">//3</span>
               <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
                   <span class="hljs-comment">//4</span>
                   <span class="hljs-keyword">if</span> (answer.getTerm() &gt; context.getCurrentTerm()) {<font></font>
                        context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
                       <span class="hljs-keyword">return</span>;<font></font>
                   }<font></font>
                   Peer peer = context.getPeer(answer.getId());<font></font>
                   <span class="hljs-comment">//5     </span>
                   <span class="hljs-keyword">if</span> (answer.getSuccess()) {                      <font></font>
                       peer.setNextIndex(answer.getMatchIndex() + <span class="hljs-number">1</span>);<font></font>
                       peer.setMatchIndex(answer.getMatchIndex());<font></font>
                       <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex())<font></font>
                           peersIds.add(answer.getId());<font></font>
                   <span class="hljs-comment">//6      </span>
                   } <span class="hljs-keyword">else</span> {<font></font>
                       peer.decNextIndex();<font></font>
                       peersIds.add(answer.getId());<font></font>
                   }<font></font>
               }<font></font>
           }<font></font>
           <span class="hljs-comment">//7</span><font></font>
           tryToCommit();<font></font>
       }<font></font>
}<font></font>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We repeat the request until we receive a response from all followers that the replication was successful. </font><font style="vertical-align: inherit;">Since one operation is sent per request, it may take several iterations to synchronize the logs of followers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send requests to all followers and get a list with answers </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We consider answers only from available followers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it turns out that the round of one of the followers is more than the leader‚Äôs round, we stop everything and turn into a follower </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the follower replied that everything was successful, we update the follower metadata: we save the last index of the follower‚Äôs log and the index of the next operation expected by the follower. </font></font></li>
<li>  ,    ,  ,           ,           .  ,                  ,      .     ,         .    ,          .</li>
<li>        ,      .     . </li>
</ol><br>
<h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how exactly the follower processes the append request from the leader. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
method</font></font><code>append</code><font style="vertical-align: inherit;"></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO dto)</span> </span>{<font></font>
     <font></font>
       <span class="hljs-comment">//1     </span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm()) {
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dto.getTerm() &gt; context.getCurrentTerm()) {
           <span class="hljs-comment">//2 </span><font></font>
           context.setCurrentTerm(dto.getTerm());<font></font>
           context.setVotedFor(<span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
       <span class="hljs-comment">//3  </span>
       applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> ResetElectionTimerEvent(<span class="hljs-keyword">this</span>));<font></font>
<font></font>
       <span class="hljs-keyword">if</span> (!context.getState().equals(FOLLOWER)) {<font></font>
           context.setState(FOLLOWER);<font></font>
       }<font></font>
        <font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">if</span> ((dto.getPrevLogIndex() &gt; operationsLog.getLastIndex()) ||                                                                                        !dto.getPrevLogTerm().equals(operationsLog.getTerm(dto.getPrevLogIndex()))) {
                      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
<font></font>
<font></font>
       Operation newOperation = dto.getOperation();<font></font>
       <span class="hljs-keyword">if</span> (newOperation != <span class="hljs-keyword">null</span>) {
           <span class="hljs-keyword">int</span> newOperationIndex = dto.getPrevLogIndex() + <span class="hljs-number">1</span>;<font></font>
           <font></font>
         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
               <span class="hljs-comment">//5</span>
               <span class="hljs-keyword">if</span> ((newOperationIndex &lt;= operationsLog.getLastIndex()) &amp;&amp;<font></font>
                      (!newOperation.getTerm().equals(operationsLog.getTerm(newOperationIndex)))){<font></font>
                   operationsLog.removeAllFromIndex(newOperationIndex);<font></font>
               }<font></font>
               <span class="hljs-comment">//6</span>
               <span class="hljs-keyword">if</span> (newOperationIndex &lt;= operationsLog.getLastIndex())<font></font>
               {<font></font>
                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>,      operationsLog.getLastIndex());<font></font>
               }<font></font>
               <span class="hljs-comment">//7</span><font></font>
               operationsLog.append(newOperation);<font></font>
           }<font></font>
        }<font></font>
        <span class="hljs-comment">//8 </span>
        <span class="hljs-keyword">if</span> (dto.getLeaderCommit() &gt; context.getCommitIndex()) {<font></font>
           context.setCommitIndex(Math.min(dto.getLeaderCommit(), operationsLog.getLastIndex()));<font></font>
       }<font></font>
<font></font>
                 <font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>, operationsLog.getLastIndex());<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the leader‚Äôs round is less than the follower‚Äôs round, then we send our leader a round and a sign that his request has been rejected. </font><font style="vertical-align: inherit;">As soon as the leader receives a round larger than his in response, he will turn into a follower</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the leader‚Äôs round is more than the follower‚Äôs round, set this round to the follower.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the request was received from the leader, regardless of whether there is data there or not, we reset the vote timer and, if we were not a follower, we become it </font></font></li>
<li>   ,   ,            ,  ,   ,    ,   .        ,    ,      </li>
<li>              ,   .            .   ,     , - ,   ,      ,      ,      .             ,    .</li>
<li>  ,   .  ,    </li>
<li>  ,     </li>
<li>        ,   ,       ,    . </li>
</ol><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It remains only to figure out how the leader applies operations from the log to the database. In the process of sending operations to followers and processing responses from them, the leader updates the metadata of the nodes. As soon as the number of nodes whose index of the last operation in the log is greater than the index of the last operation applied to the database by the leader becomes equal to the quorum, we can state that most nodes received the operation and we can apply it to the leader database. In other words, if a leader sent an operation to followers and most of them inserted it into his log and answered the leader, then we can apply this operation to the leader‚Äôs database and increase the index of the last operation applied. This index with the next append-heartbeat request will fly to the follower and it will </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apply the operation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the same index from its log to its database.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's analyze the </font></font><code>tryToCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font><font style="vertical-align: inherit;">method</font></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryToCommit</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
           <span class="hljs-comment">//1</span>
           <span class="hljs-keyword">int</span> N = context.getCommitIndex() + <span class="hljs-number">1</span>;
           <span class="hljs-comment">//2</span><font></font>
           Supplier&lt;Long&gt; count = () -&gt;<font></font>
               context.getPeers().stream().map(Peer::getMatchIndex).<font></font>
                       filter(matchIndex -&gt; matchIndex &gt;= N).count() + <span class="hljs-number">1</span>;<font></font>
<font></font>
           <span class="hljs-comment">//3 </span>
           <span class="hljs-keyword">if</span> (operationsLog.getLastIndex() &gt;= N &amp;&amp;<font></font>
                   operationsLog.getTerm(N).equals(context.getCurrentTerm())&amp;&amp;<font></font>
                      count.get()&gt;=context.getQuorum()<font></font>
           )<font></font>
           {<font></font>
               context.setCommitIndex(N);<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-keyword">return</span>;<font></font>
       }<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We get the following index of the operation applied to the database</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We count how many followers have an operation with such an index in their logs, and do not forget to add a leader </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the number of such followers is quorum and the operation with such an index is in the leader‚Äôs log, and the round of this operation is equivalent to the current one, then the leader applies the operation to the database and increases the index of the last applied operation. </font><font style="vertical-align: inherit;">Operations from the previous round cannot be applied, because another leader was responsible for them and a conflict could arise. </font><font style="vertical-align: inherit;">Each leader applies operations only of his current round.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any distributed algorithm, the representative of the family of which is RAFT, is a powerful integrated solution that guarantees the achievement of the result, subject to all the rules described in the specification. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many distributed algorithms and they are different. There is ZAB, which is implemented in Zookeeper and is used, for example, to synchronize data in Kafka. There are algorithms with less stringent requirements for consistency, for example, the mass of implementations of the Gossip protocol that are used in AP systems. There are algorithms that follow the principles of RAFT, and at the same time use the gossip protocol for exchanging logs such as MOKKA, which also uses encryption.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I believe that trying to figure out any of these algorithms is extremely useful for any developer, and as I mentioned above, solutions can be interesting both comprehensively and in separate parts. </font><font style="vertical-align: inherit;">And obviously, you definitely need to look in this direction to those whose activities are related to the development of distributed systems and regarding data synchronization issues, even if they use standard industrial solutions.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specification</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Short description</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We hope the material was useful to you. </font><font style="vertical-align: inherit;">And if you want </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to catch a course</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you can do it right now.</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en495344/index.html">Unify it: how Lamoda makes its Go services consistent</a></li>
<li><a href="../en495346/index.html">From error to alert with actions</a></li>
<li><a href="../en495348/index.html">Research: How Covid-19 Affects Email Marketing Performance</a></li>
<li><a href="../en495350/index.html">Home web server, or your own hosting provider</a></li>
<li><a href="../en495354/index.html">How to release products continuously in 20 languages ‚Äã‚Äãand not die?</a></li>
<li><a href="../en495360/index.html">How we automated porting products from C # to C ++</a></li>
<li><a href="../en495362/index.html">Self-isolate and program: how not to go crazy at home and spend time usefully</a></li>
<li><a href="../en495364/index.html">API Style Guide, or don't make users think</a></li>
<li><a href="../en495366/index.html">16 types of programmers, or Developers are not the same robots</a></li>
<li><a href="../en495368/index.html">We self-register for self-walking self-dogs in conditions of self-isolation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>