<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦉 🌴 📸 環境マップ上の光源の認識 🕶️ 🧠 🤰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、正距円筒図法を使用して環境マップ（LDRまたはHDR）上の光源を認識するためのアルゴリズムのPython実装について説明します。ただし、小さな変更を加えた後は、単純な背景画像やキュービックマップでも使用できます。アルゴリズムの可能なアプリケーションの例：光線追跡プログラム。光線を放出す...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>環境マップ上の光源の認識</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458598/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、正距円筒図法を使用して環境マップ（LDRまたはHDR）上の光源を認識するためのアルゴリズムのPython実装について説明します。</font><font style="vertical-align: inherit;">ただし、小さな変更を加えた後は、単純な背景画像やキュービックマップでも使用できます。</font><font style="vertical-align: inherit;">アルゴリズムの可能なアプリケーションの例：光線追跡プログラム。光線を放出するために、主要な光源を認識する必要があります。</font><font style="vertical-align: inherit;">ラスタライズされたレンダラーでは、環境マップを使用して影を落とすために使用できます。</font><font style="vertical-align: inherit;">さらに、このアルゴリズムは、スポットライト除去プログラム、たとえばARでも使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは次のステップで構成されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の画像の解像度を1024などに下げます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像を明るさ（輝度）に変換し、必要に応じて画像をぼかします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準モンテカルロ法の適用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">球座標から等距離座標への変換。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近傍の明るさに基づいてサンプルをフィルタリングします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明るさに基づいてサンプルを並べ替えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユークリッドメトリックに基づいてサンプルをフィルタリングします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bresenhamアルゴリズムを使用したサンプルのマージ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明るさに基づいた照明クラスターの位置の計算。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像の解像度を下げるための多くのアルゴリズムがあります。</font><font style="vertical-align: inherit;">双一次フィルタリングは、実装が最も高速または簡単であり、さらに、ほとんどの場合に最適です。</font><font style="vertical-align: inherit;">LDR画像とHDR画像の両方の明るさを変換するには、次の標準的な公式を使用できます。</font></font><br>
<br>
<pre><code class="python hljs">  lum = img[:, :, <span class="hljs-number">0</span>] * <span class="hljs-number">0.2126</span> + img[:, :, <span class="hljs-number">1</span>] * <span class="hljs-number">0.7152</span> + img[:, :, <span class="hljs-number">2</span>] * <span class="hljs-number">0.0722</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、明るさの画像にわずかなぼかし（たとえば、解像度が1024の画像の1〜2ピクセル）を適用して、（特に解像度の低下によって引き起こされる）すべての高周波の詳細を取り除くことができます。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等距離図法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
環境マップで最も一般的な投影は、等距離投影です</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私のアルゴリズムは他の投影法、たとえばパノラママップや3次マップなどでも機能しますが、この記事では等間隔の投影法のみを考慮します。</font><font style="vertical-align: inherit;">まず、画像座標を正規化する必要があります。</font></font><br>
<br>
<pre><code class="python hljs">pos[<span class="hljs-number">0</span>] = x / width<font></font>
pos[<span class="hljs-number">1</span>] = y / height </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、球面座標を使用してデカルト座標との間で変換を行う必要があります。</font><font style="vertical-align: inherit;">θおよびφ、ただしθ= x *2π、およびφ= y *π。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sphereToEquirectangular</span>(<span class="hljs-params">pos</span>):</span>
  invAngles = (<span class="hljs-number">0.1591</span>, <span class="hljs-number">0.3183</span>)<font></font>
  xy = (math.atan2(pos[<span class="hljs-number">1</span>], pos[<span class="hljs-number">0</span>]), math.asin(pos[<span class="hljs-number">2</span>]))<font></font>
  xy = (xy[<span class="hljs-number">0</span>] * invAngles[<span class="hljs-number">0</span>], xy[<span class="hljs-number">1</span>] * invAngles[<span class="hljs-number">1</span>])
  <span class="hljs-keyword">return</span> (xy[<span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span>, xy[<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equirectangularToSphere</span>(<span class="hljs-params">pos</span>):</span>
  angles = (<span class="hljs-number">1</span> / <span class="hljs-number">0.1591</span>, <span class="hljs-number">1</span> / <span class="hljs-number">0.3183</span>)<font></font>
  thetaPhi = (pos[<span class="hljs-number">0</span>] - <span class="hljs-number">0.5</span>, pos[<span class="hljs-number">1</span>] - <span class="hljs-number">0.5</span>)<font></font>
  thetaPhi = (thetaPhi[<span class="hljs-number">0</span>] * angles[<span class="hljs-number">0</span>], thetaPhi[<span class="hljs-number">1</span>] * angles[<span class="hljs-number">1</span>])<font></font>
<font></font>
  length = math.cos(thetaPhi[<span class="hljs-number">1</span>])  
  <span class="hljs-keyword">return</span> (math.cos(thetaPhi[<span class="hljs-number">0</span>]) * length, math.sin(thetaPhi[<span class="hljs-number">0</span>]) * length, math.sin(thetaPhi[<span class="hljs-number">1</span>]))</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hammersleyサンプリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、準モンテカルロ法を適用することです。たとえば、Hammersley </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリング</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f9/b07/70f/4f9b0770f72e69ede59e56a25258343d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Holton </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの他のサンプリング方法を使用できます</font><font style="vertical-align: inherit;">が、Hammersleyの方が高速で、球全体にサンプルを適切に分散できます。</font><font style="vertical-align: inherit;">ホルトンは、環境マップの代わりに単純な画像を使用する場合、平面サンプルに適しています。</font><font style="vertical-align: inherit;">Hammersleyをサンプリングするための必須の要件は、ファンデルコーピュートの根（行）の反転です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細については、リンク</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2を</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここにその迅速な実装があります：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vdcSequence</span>(<span class="hljs-params">bits</span>):</span>
    bits = (bits &lt;&lt; <span class="hljs-number">16</span>) | (bits &gt;&gt; <span class="hljs-number">16</span>)<font></font>
    bits = ((bits &amp; <span class="hljs-number">0x55555555</span>) &lt;&lt; <span class="hljs-number">1</span>) | ((bits &amp; <span class="hljs-number">0xAAAAAAAA</span>) &gt;&gt; <span class="hljs-number">1</span>)<font></font>
    bits = ((bits &amp; <span class="hljs-number">0x33333333</span>) &lt;&lt; <span class="hljs-number">2</span>) | ((bits &amp; <span class="hljs-number">0xCCCCCCCC</span>) &gt;&gt; <span class="hljs-number">2</span>)<font></font>
    bits = ((bits &amp; <span class="hljs-number">0x0F0F0F0F</span>) &lt;&lt; <span class="hljs-number">4</span>) | ((bits &amp; <span class="hljs-number">0xF0F0F0F0</span>) &gt;&gt; <span class="hljs-number">4</span>)<font></font>
    bits = ((bits &amp; <span class="hljs-number">0x00FF00FF</span>) &lt;&lt; <span class="hljs-number">8</span>) | ((bits &amp; <span class="hljs-number">0xFF00FF00</span>) &gt;&gt; <span class="hljs-number">8</span>)
    <span class="hljs-keyword">return</span> float(bits) * <span class="hljs-number">2.3283064365386963e-10</span> <span class="hljs-comment"># / 0x100000000</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammersleySequence</span>(<span class="hljs-params">i, N</span>):</span>
    <span class="hljs-keyword">return</span> (float(i) / float(N), vdcSequence(i))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、球に均一のオーバーレイを使用します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sphereSample</span>(<span class="hljs-params">u, v</span>):</span>
  PI = <span class="hljs-number">3.14159265358979</span>
  phi = v * <span class="hljs-number">2.0</span> * PI<font></font>
  cosTheta = <span class="hljs-number">2.0</span> * u - <span class="hljs-number">1.0</span> <span class="hljs-comment"># map to -1,1</span>
  sinTheta = math.sqrt(<span class="hljs-number">1.0</span> - cosTheta * cosTheta);
  <span class="hljs-keyword">return</span> (math.cos(phi) * sinTheta, math.sin(phi) * sinTheta, cosTheta)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hammersleyサンプリングでは、画像の解像度に応じて固定数のサンプルを使用し、球面座標から直交座標に変換してから等距離に変換します。</font></font><br>
<br>
<pre><code class="python hljs">  samplesMultiplier = <span class="hljs-number">0.006</span>  <font></font>
  samples = int(samplesMultiplier * width * height)<font></font>
<font></font>
  samplesList = []<font></font>
  <span class="hljs-comment"># apply hammersley sampling</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, samples):<font></font>
    xi = hammersleySequence(i, samples)<font></font>
    xyz = sphereSample(xi[<span class="hljs-number">0</span>], xi[<span class="hljs-number">1</span>]) <span class="hljs-comment"># to cartesian</span><font></font>
    imagePos = sphereToEquirectangular(xyz)<font></font>
<font></font>
    luminance = lum[imagePos[<span class="hljs-number">0</span>] * width, imagePos[<span class="hljs-number">1</span>] * height]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、光源の存在をチェックするサンプルの適切な分布が得られます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/0a6/470/aa80a64703ef6e38cd0b73f9b02a5852.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光源のフィルタリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィルタリングの最初のパスでは、明るさのしきい値を超えないすべてのサンプルを無視し（HDRカードの場合はそれよりも高い場合があります）、すべてのサンプルを明るさで並べ替えます。</font></font><br>
<br>
<pre><code class="python hljs">  localSize = int(float(<span class="hljs-number">12</span>) * (width / <span class="hljs-number">1024.0</span>)) + <span class="hljs-number">1</span><font></font>
<font></font>
  samplesList = []<font></font>
  <span class="hljs-comment"># apply hammersley sampling</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, samples):<font></font>
    xi = hammersleySequence(i, samples)<font></font>
    xyz = sphereSample(xi[<span class="hljs-number">0</span>], xi[<span class="hljs-number">1</span>]) <span class="hljs-comment"># to cartesian</span><font></font>
    imagePos = sphereToEquirectangular(xyz)<font></font>
<font></font>
    luminance = lum[imagePos [<span class="hljs-number">0</span>] * width, imagePos [<span class="hljs-number">1</span>] * height]<font></font>
    sample = Sample(luminance, imagePos , xyz)<font></font>
<font></font>
    luminanceThreshold = <span class="hljs-number">0.8</span>
    <span class="hljs-comment">#do a neighbour search for the maximum luminance</span><font></font>
    nLum = computeNeighborLuminance(lum, width, height, sample.imagePos, localSize)<font></font>
    <span class="hljs-keyword">if</span> nLum &gt; luminanceThreshold:<font></font>
      samplesList.append(sample)<font></font>
<font></font>
  samplesList = sorted(samplesList, key=<span class="hljs-keyword">lambda</span> obj: obj.luminance, reverse=<span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパスでは、ユークリッドメトリックとピクセル間のしきい値距離（画像の解像度に応じて異なります）に基づいてフィルタリングを実行します。これは、O（N </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">複雑さを取り除くために使用できる空間データ構造です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">  euclideanThreshold = int(float(euclideanThresholdPixel) * (width / <span class="hljs-number">2048.0</span>))<font></font>
<font></font>
  <span class="hljs-comment"># filter based euclidian distance</span><font></font>
  filteredCount = len(samplesList)<font></font>
  localIndices = np.empty(filteredCount); localIndices.fill(<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, filteredCount):<font></font>
    cpos = samplesList[i].pos<font></font>
    <span class="hljs-keyword">if</span> localIndices[i] == <span class="hljs-number">-1</span>:<font></font>
      localIndices[i] = i<font></font>
<font></font>
      <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, filteredCount):
        <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> localIndices[j] == <span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> distance2d(cpos, samplesList[j].pos) &lt; euclideanThreshold:<font></font>
          localIndices[j] = i</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として得られるサンプルは、光源の数をさらに減らすためにマージステージを通過します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/152/e1e/d39152e1e587c40c3ed29888faf02120.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光源のマージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の段階で、同じ照明クラスターに属するサンプルのマージが実行されます。</font><font style="vertical-align: inherit;">これを行うには、Bresenhamアルゴリズムを使用して、明るさが最も高いサンプルから始めます。</font><font style="vertical-align: inherit;">Bresenhamテストを満たす光源を見つけたら、その位置を使用して、実行の重みに基づいて光源の位置を変更します。</font></font><br>
<br>
<pre><code class="python hljs">  <span class="hljs-comment"># apply bresenham check and compute position of the light clusters</span><font></font>
  lights = []<font></font>
  finalIndices = np.empty(filteredCount); finalIndices.fill(<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> localIndices:<font></font>
    sample = samplesList[i]<font></font>
    startPos = sample.pos<font></font>
    <span class="hljs-keyword">if</span> finalIndices[i] == <span class="hljs-number">-1</span>:<font></font>
      finalIndices[i] = i<font></font>
<font></font>
      light = Light()<font></font>
      light.originalPos = np.array(sample.pos)  <span class="hljs-comment"># position of the local maxima</span><font></font>
      light.worldPos = np.array(sample.worldPos)<font></font>
      light.pos = np.array(sample.pos)<font></font>
      light.luminance = sample.luminance<font></font>
<font></font>
      <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> localIndices:
        <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> finalIndices[j] == <span class="hljs-number">-1</span>:<font></font>
          endPos = samplesList[j].pos<font></font>
          <font></font>
          <span class="hljs-keyword">if</span> bresenhamCheck(lum, width, height, startPos[<span class="hljs-number">0</span>], startPos[<span class="hljs-number">1</span>], endPos[<span class="hljs-number">0</span>], endPos[<span class="hljs-number">1</span>]):<font></font>
            finalIndices[j] = i<font></font>
<font></font>
            <span class="hljs-comment"># compute final position of the light source</span><font></font>
            sampleWeight = samplesList[j].luminance / sample.luminance<font></font>
            light.pos = light.pos + np.array(endPos) * sampleWeight<font></font>
            light.pos = light.pos / (<span class="hljs-number">1.0</span> + sampleWeight)<font></font>
<font></font>
      imagePos = light.pos * np.array([<span class="hljs-number">1.0</span> / width, <span class="hljs-number">1.0</span> / height)<font></font>
      light.worldPos = equirectangularToSphere(imagePos)<font></font>
<font></font>
      lights.append(light)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bresenham関数は、同じ明るさの連続線をチェックします。</font><font style="vertical-align: inherit;">現在のピクセルのデルタが特定のしきい値を超えると、検証は失敗します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bresenhamCheck</span>(<span class="hljs-params">lum, imageSize, x0, y0, x1, y1</span>):</span><font></font>
<font></font>
  dX = int(x1 - x0)<font></font>
  stepX = int((dX &gt; <span class="hljs-number">0</span>) - (dX &lt; <span class="hljs-number">0</span>))<font></font>
  dX = abs(dX) &lt;&lt; <span class="hljs-number">1</span><font></font>
<font></font>
  dY = int(y1 - y0)<font></font>
  stepY = int((dY &gt; <span class="hljs-number">0</span>) - (dY &lt; <span class="hljs-number">0</span>))<font></font>
  dY = abs(dY) &lt;&lt; <span class="hljs-number">1</span><font></font>
<font></font>
  luminanceThreshold = <span class="hljs-number">0.15</span><font></font>
  prevLum = lum[x0][y0]<font></font>
  sumLum = <span class="hljs-number">0.0</span>
  c = <span class="hljs-number">0</span>
  <span class="hljs-keyword">if</span> (dX &gt;= dY):
      <span class="hljs-comment"># delta may go below zero</span>
      delta = int (dY - (dX &gt;&gt; <span class="hljs-number">1</span>))<font></font>
<font></font>
      <span class="hljs-keyword">while</span> (x0 != x1):
          <span class="hljs-comment"># reduce delta, while taking into account the corner case of delta == 0</span>
          <span class="hljs-keyword">if</span> ((delta &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (delta == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (stepX &gt; <span class="hljs-number">0</span>))):<font></font>
              delta -= dX<font></font>
              y0 += stepY<font></font>
<font></font>
          delta += dY<font></font>
          x0 += stepX<font></font>
          sumLum = sumLum + min(lum[x0][y0], <span class="hljs-number">1.25</span>)<font></font>
          c = c + <span class="hljs-number">1</span>
          <span class="hljs-keyword">if</span>(abs(sumLum / c - prevLum) &gt; luminanceThreshold <span class="hljs-keyword">and</span> (sumLum / c) &lt; <span class="hljs-number">1.0</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span>:
      <span class="hljs-comment"># delta may go below zero</span>
      delta = int(dX - (dY &gt;&gt; <span class="hljs-number">1</span>))<font></font>
<font></font>
      <span class="hljs-keyword">while</span> (y0 != y1):
          <span class="hljs-comment"># reduce delta, while taking into account the corner case of delta == 0</span>
          <span class="hljs-keyword">if</span> ((delta &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (delta == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (stepY &gt; <span class="hljs-number">0</span>))):<font></font>
              delta -= dY<font></font>
              x0 += stepX<font></font>
<font></font>
          delta += dX<font></font>
          y0 += stepY<font></font>
          sumLum = sumLum + min(lum[x0][y0], <span class="hljs-number">1.25</span>)<font></font>
          c = c + <span class="hljs-number">1</span>
          <span class="hljs-keyword">if</span>(abs(sumLum / c - prevLum) &gt; luminanceThreshold <span class="hljs-keyword">and</span> (sumLum / c) &lt; <span class="hljs-number">1.0</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要に応じて、ブレゼンハムテストを改善して、サンプルをより適切にマージできるようにすることができます。たとえば、画像の端にある光源の水平転送を考慮することができます。</font><font style="vertical-align: inherit;">さらに、機能は光源の面積に近づくように簡単に拡張できます。</font><font style="vertical-align: inherit;">別の改善点：距離のしきい値を追加して、遠すぎるサンプルを結合しないようにすることができます。</font><font style="vertical-align: inherit;">最終結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/4a8/fd9/4224a8fd98cec4203235bb4678ee6826.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
青は照明クラスタの極大値を示し、青は光源の最終位置を示し、赤は同じ照明クラスタの一部であり、線で接続されているサンプルを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の他の例：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png"></div><br>
<hr><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maciej Laskowskiによるデジタル写真の光源の検出</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holger Dammertzによる半球上のハンマースリーポイント</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポール・リードによる正距円筒図法</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハンマーズリーとハルトンポイントでのサンプリング</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458584/index.html">Webinar Group-IB 7月11日、「初心者のためのマルウェア分析：基本的なアプローチ」</a></li>
<li><a href="../ja458590/index.html">iOSアプリケーションのアーキテクチャアプローチ</a></li>
<li><a href="../ja458592/index.html">高CephレイテンシからeBPF / BCCを使用したカーネルパッチまで</a></li>
<li><a href="../ja458594/index.html">L7バランシングで繰り返し要求を使用してクライアントへの応答の可能性を高めることを忘れないでください</a></li>
<li><a href="../ja458596/index.html">ささいな喜び＃6：OpenAIジム-ゲームをプレイしてロボットを操作する</a></li>
<li><a href="../ja458600/index.html">電動自転車とは（2つのメーカーの5つのモデルの2つの部分でのグループレビュー）、パート1</a></li>
<li><a href="../ja458602/index.html">Great Chinese Firewallをどのように貫通したか（パート1）</a></li>
<li><a href="../ja458604/index.html">2つの最大の電子機器メーカーが新しいGPUプロジェクトに力を合わせた理由</a></li>
<li><a href="../ja458606/index.html">DockerでOpenVPNを2秒で実行する</a></li>
<li><a href="../ja458608/index.html">Node.js開発者ツール ジョブキュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>