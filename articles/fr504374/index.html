<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐽 📚 💏 Traversée de graphe simple: recherche en profondeur et étendue en utilisant JavaScript comme exemple 🤸🏻 👇🏻 🍦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne journée. 
 
 Je vous présente la traduction de l'article «Algorithmes sur les graphiques: parlons de la recherche en profondeur d'abord (DFS) et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Traversée de graphe simple: recherche en profondeur et étendue en utilisant JavaScript comme exemple</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504374/"><img src="https://habrastorage.org/webt/_f/kf/kl/_fkfkl3gfkmnwtes2eypbueifxe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bonne journée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vous présente la traduction de l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Algorithmes sur les graphiques: parlons de la recherche en profondeur d'abord (DFS) et de la recherche en largeur (BFS)»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Try Khov.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qu'un parcours de graphe?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes simples, une traversée de graphe est une transition d'un de ses sommets à l'autre à la recherche des propriétés de connexion de ces sommets. </font><font style="vertical-align: inherit;">Les liens (lignes reliant les sommets) sont appelés directions, tracés, faces ou arêtes d'un graphique. </font><font style="vertical-align: inherit;">Les sommets du graphique sont également appelés nœuds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux principaux algorithmes de traversée de graphe sont la recherche en profondeur d'abord, DFS et la recherche en largeur d'abord, BFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le fait que les deux algorithmes sont utilisés pour parcourir le graphique, ils ont quelques différences. </font><font style="vertical-align: inherit;">Commençons par DFS.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche de profondeur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFS suit le concept de «aller en profondeur, tête la première». L'idée est que nous nous déplaçons du pic de départ (point, lieu) dans une certaine direction (le long d'un certain chemin) jusqu'à ce que nous atteignions la fin du chemin ou de la destination (pic souhaité). Si nous avons atteint la fin du chemin, mais que ce n'est pas une destination, alors nous retournons (au point de chemins bifurqués ou divergents) et suivons un itinéraire différent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons un exemple. Supposons que nous ayons un graphe orienté qui ressemble à ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous sommes au point "s" et nous devons trouver le sommet "t". À l'aide de DFS, nous étudions l'un des chemins possibles, le déplaçons jusqu'à la fin et, si nous ne trouvons pas t, revenons en arrière et explorons un autre chemin. Voici à quoi ressemble le processus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous nous déplaçons le long du chemin (p1) jusqu'au pic le plus proche et voyons que ce n'est pas la fin du chemin. Par conséquent, nous passons au prochain pic. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons atteint la fin de p1, mais n'avons pas trouvé t, nous retournons donc à s et nous nous déplaçons le long du deuxième chemin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir atteint le sommet du chemin «p2» le plus proche du point «s», nous voyons trois directions possibles pour un mouvement ultérieur. Puisque nous avons déjà visité le sommet couronnant la première direction, nous nous déplaçons le long de la seconde. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons de nouveau atteint la fin du chemin, mais n'avons pas trouvé t, alors nous revenons. Nous suivons le troisième chemin et, enfin, nous atteignons le pic "t" souhaité. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment fonctionne DFS. Nous nous déplaçons le long d'un certain chemin jusqu'à la fin. Si la fin du chemin est le pic souhaité, nous avons terminé. Sinon, revenez en arrière et avancez sur un chemin différent jusqu'à ce que nous explorions toutes les options.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous suivons cet algorithme pour chaque sommet visité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La nécessité d'une répétition répétée de la procédure indique la nécessité d'utiliser la récursivité pour implémenter l'algorithme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici le code JavaScript:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A: [B,C], B:[D,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">adj, v, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// v -   ()</span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-comment">//    ,    </span>
	<span class="hljs-keyword">if</span>(v === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">if</span>(v.visited) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	v.visited = <span class="hljs-literal">true</span>
	<span class="hljs-comment">//    (  ) v</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">if</span>(!neighbor.visited) {
			<span class="hljs-comment">//     ,      </span>
			<span class="hljs-keyword">let</span> reached = dfs(adj, neighbor, t)
			<span class="hljs-comment">//  true,  </span>
			<span class="hljs-keyword">if</span>(reached) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-comment">//   v  t  </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: Cet algorithme DFS spécial vous permet de vérifier s'il est possible d'aller d'un endroit à un autre. </font><font style="vertical-align: inherit;">DFS peut être utilisé à diverses fins. </font><font style="vertical-align: inherit;">Ces objectifs détermineront l'aspect de l'algorithme lui-même. </font><font style="vertical-align: inherit;">Cependant, le concept général ressemble exactement à cela.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse DFS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analysons cet algorithme. Puisque nous contournons chaque «voisin» de chaque nœud, en ignorant ceux que nous avons visités précédemment, nous avons un temps d'exécution égal à O (V + E). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une brève explication de ce que V + E signifie: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V est le nombre total de sommets. E est le nombre total de faces (arêtes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut sembler plus approprié d'utiliser V * E, mais réfléchissons à ce que signifie V * E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * E signifie qu'en ce qui concerne chaque sommet, nous devons étudier toutes les faces du graphique, que ces faces appartiennent ou non à un sommet particulier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En revanche, V + E signifie que pour chaque sommet, nous évaluons uniquement les arêtes qui lui sont adjacentes. </font><font style="vertical-align: inherit;">Pour revenir à l'exemple, chaque sommet a un certain nombre de faces et, dans le pire des cas, on fait le tour de tous les sommets (O (V)) et on examine toutes les faces (O (E)). </font><font style="vertical-align: inherit;">Nous avons V sommets et E faces, donc nous obtenons V + E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, puisque nous utilisons la récursivité pour parcourir chaque sommet, cela signifie qu'une pile est utilisée (une récursion infinie entraîne une erreur de débordement de pile). </font><font style="vertical-align: inherit;">Par conséquent, la complexité spatiale est O (V). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons maintenant le BFS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche large</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFS suit le concept de "s'étendre large, s'élevant à la hauteur du vol d'un oiseau" ("aller large, vue plongeante"). Au lieu de se déplacer le long d'un certain chemin jusqu'à la fin, BFS implique d'avancer un voisin à la fois. Cela signifie ce qui suit: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de suivre le chemin, BFS signifie visiter les voisins les plus proches de s en une seule étape (étape), puis visiter les voisins des voisins et ainsi de suite jusqu'à ce que t soit détecté. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/vb/ny/1uvbnygi83vt6bxqnmv1hbwuzyq.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/en/jq/tgenjqvsz1zipcv3obsicrhq78a.png"><br>
<br>
<img src="https://habrastorage.org/webt/tf/j9/on/tfj9on04zudfmelpbn00xeh_tpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En quoi DFS est-il différent de BFS? J'aime à penser que DFS va de l'avant et que BFS n'est pas pressé, mais étudie tout en une seule étape. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La question se pose alors: comment savoir quels voisins doivent être visités en premier?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, nous pouvons utiliser le concept de "premier entré, premier sorti" (premier entré, premier sorti, FIFO) de la file d'attente. </font><font style="vertical-align: inherit;">Nous mettons d'abord en file d'attente le pic le plus proche de nous, puis ses voisins non visités, et continuons ce processus jusqu'à ce que la file d'attente soit vide ou jusqu'à ce que nous trouvions le sommet que nous recherchons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici le code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A:[B,C,D], B:[E,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">adj, s, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// s -  </span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">let</span> queue = []
	<span class="hljs-comment">//  s  </span><font></font>
	queue.push(s)<font></font>
	<span class="hljs-comment">//  s         </span>
	s.visited = <span class="hljs-literal">true</span>
	<span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-comment">//   ()   </span>
		<span class="hljs-keyword">let</span> v = queue.shift()
		<span class="hljs-comment">// abj[v] -  v</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
			<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span>(!neighbor.visited) {
				<span class="hljs-comment">//    </span><font></font>
				queue.push(neighbor)<font></font>
				<span class="hljs-comment">//    </span>
				neighbor.visited = <span class="hljs-literal">true</span>
				<span class="hljs-comment">//     ,  </span>
				<span class="hljs-keyword">if</span>(neighbor === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
			}<font></font>
		} <font></font>
	}<font></font>
	<span class="hljs-comment">//  t  ,     </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse BFS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut sembler que BFS est plus lent. Cependant, si vous regardez attentivement les visualisations, vous pouvez voir qu'elles ont le même temps d'exécution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une file d'attente implique de traiter chaque sommet avant d'atteindre une destination. Cela signifie que, dans le pire des cas, BFS explore tous les sommets et faces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le fait que BFS puisse sembler plus lent, il est en fait plus rapide, car lorsque vous travaillez avec des graphiques de grande taille, il s'avère que DFS passe beaucoup de temps à suivre des chemins qui se révèlent finalement faux. BFS est souvent utilisé pour trouver le chemin le plus court entre deux pics. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le runtime BFS est également O (V + E), et puisque nous utilisons une file d'attente contenant tous les sommets, sa complexité spatiale est O (V).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analogies réelles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous donnez des analogies de la vie réelle, c'est ainsi que j'imagine le travail de DFS et BFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quand je pense à DFS, j'imagine une souris dans un labyrinthe à la recherche de nourriture. </font><font style="vertical-align: inherit;">Pour atteindre la cible, la souris est obligée de se retrouver à plusieurs reprises dans une impasse, de revenir et de se déplacer d'une manière différente, et ainsi de suite jusqu'à ce qu'elle trouve un moyen de sortir du labyrinthe ou de la nourriture. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/f3/ji/-ef3ji72zi8egr3xa26zqvt1x4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une version simplifiée ressemble à ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/hb/dr/kqhbdrkv6xstug0ss3l5bpr1l9k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
à mon tour, quand je pense à BFS, j'imagine des cercles sur l'eau. </font><font style="vertical-align: inherit;">La chute d'une pierre dans l'eau entraîne la propagation de perturbations (cercles) dans toutes les directions depuis le centre. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/lz/zp/pvlzzpnzfssjv8yzpkc49ovtsho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une version simplifiée ressemble à ceci:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/w9/sc/s-w9scwvyp93tvyk2zwimmfc_um.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des recherches en profondeur et en largeur sont utilisées pour parcourir le graphique.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS se déplace le long des bords d'avant en arrière, et BFS se propage à travers les voisins à la recherche d'une cible.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS utilise la pile et BFS la file d'attente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le temps d'exécution des deux est O (V + E) et la complexité spatiale est O (V).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces algorithmes ont une philosophie différente, mais sont tout aussi importants pour travailler avec des graphiques.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque </font><font style="vertical-align: inherit;">Per.: Je ne suis pas un spécialiste des algorithmes et des structures de données, par conséquent, si des erreurs, des inexactitudes ou des formulations incorrectes sont trouvées, veuillez écrire dans une lettre personnelle pour correction et clarification. </font><font style="vertical-align: inherit;">Je serai reconnaissant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci de votre attention.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504354/index.html">Réduisez la taille du modèle ML sans inscription ni SMS</a></li>
<li><a href="../fr504356/index.html">PHP 8 en huit morceaux de code</a></li>
<li><a href="../fr504358/index.html">PuppetConf 2016. Kubernetes pour les administrateurs système. Partie 2</a></li>
<li><a href="../fr504362/index.html">Chargez rapidement de grandes quantités de données dans Google Colab</a></li>
<li><a href="../fr504370/index.html">Office 365 et équipes Microsoft - Commodité de collaboration et impact sur la sécurité</a></li>
<li><a href="../fr504382/index.html">Comment je (PhD Neurobiologie) est devenu Data Scientist en 6 mois</a></li>
<li><a href="../fr504384/index.html">Introduisez progressivement TypeScript dans votre projet React</a></li>
<li><a href="../fr504386/index.html">Variables virtuelles Vassbotn H. Class</a></li>
<li><a href="../fr504392/index.html">De combien de programmeurs et de mots avez-vous besoin pour reconnaître un passeport manuscrit?</a></li>
<li><a href="../fr504400/index.html">Mise en cache. Partie 2: 60 jours avant la sortie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>