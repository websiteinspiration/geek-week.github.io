<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùî üìÇ ‚ÑπÔ∏è Neuronale Netze und Process Mining: Freunde finden üë©‚Äçüíª ‚ö±Ô∏è üëºüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Process Mining ist ein Datenanalysefeld, mit dem Sie Prozesse anhand der Protokolle von Informationssystemen analysieren k√∂nnen. Da es auf Habr√© nur s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Neuronale Netze und Process Mining: Freunde finden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vtb/blog/493152/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Process Mining ist ein Datenanalysefeld, mit dem Sie Prozesse anhand der Protokolle von Informationssystemen analysieren k√∂nnen. Da es auf Habr√© nur sehr wenige Ver√∂ffentlichungen zum Thema des Einsatzes von maschinellem Lernen in diesem Bereich gibt, haben wir uns entschlossen, unsere Erfahrungen bei der Entwicklung von Vorhersagemodellen zur L√∂sung prozessorientierter Probleme zu teilen. Im Rahmen des VTB-Programms, einem IT-Junior f√ºr angehende IT-Experten, testeten Praktikanten des Process Mining-Teams die Methoden des maschinellen Lernens im Rahmen der Aufgaben der Untersuchung von Bankprozessen. Im Rahmen des Schnitts werden wir dar√ºber sprechen, wann und wie wir auf die Idee gekommen sind, solche Probleme zu l√∂sen, was wir getan haben und welche Ergebnisse wir erzielt haben.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/hi/lg/6nhilgitc0hyxrpmzuypu6w0irg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das IT Junior Program ist ein j√§hrliches Praktikumsprogramm f√ºr IT-Anf√§nger bei der VTB Bank, das erstmals im September 2019 begann. </font><font style="vertical-align: inherit;">Das Praktikum dauert sechs Monate. </font><font style="vertical-align: inherit;">Nach den Ergebnissen des Programms 2019 trat mehr als die H√§lfte der Praktikanten in die Belegschaft ein und wurde Mitarbeiter des Unternehmens. </font><font style="vertical-align: inherit;">Weitere Informationen zum Programm, zum Auswahlbeginn und zu den Anforderungen an die Kandidaten finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So n√§herten sich die Auszubildenden dieses Programms den Aufgaben der Bank. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im klassischen Koordinatensystem ist es notwendig, um den Prozess zu verstehen und zu formalisieren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Interview mit Mitarbeitern f√ºhren;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analysieren Sie verf√ºgbare Berichte und Dokumentationen.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Process Mining-Ansatz wird ein digitales Prozessmodell auf der Grundlage nicht nur der Expertenmeinung der Prozessteilnehmer, sondern auch relevanter Daten aus Informationssystemen gebildet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis erhalten wir ein objektives digitales Modell des Prozesses, das die Bewegung realer Daten in den IT-Systemen des Prozesses widerspiegelt. Das resultierende Modell arbeitet in Echtzeit und erm√∂glicht es Ihnen, den aktuellen Status des Prozesses mit dem erforderlichen Detaillierungsgrad anzuzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem vorherigen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sprachen √ºber unsere Process Mining-Plattform und die eigentlichen Aufgaben der Bank, die mit ihrer Hilfe gel√∂st werden. </font><font style="vertical-align: inherit;">Die implementierte L√∂sung erm√∂glichte es uns, den Zeitaufwand f√ºr die Erstellung von Pflichtberichten an Regierungsbeh√∂rden erheblich zu verk√ºrzen und Prozessfehler zu identifizieren und zu optimieren, um eine t√§gliche Darstellung des aktuellen Status der Eink√§ufe in der Arbeit zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Folge mussten unsere Kunden nicht nur den aktuellen Stand des Prozesses qualitativ bestimmen, sondern auch die zuk√ºnftigen Bedingungen vorhersagen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes beschreiben wir Schritt f√ºr Schritt, wie wir das Problem der Vorhersage der Dauer des Beschaffungsprozesses (am Beispiel des BPI Challenge 2019-Datensatzes) anhand einer Reihe bekannter Ereignisse mithilfe der Hochleistungs-DGX-Station gel√∂st haben, die uns freundlicherweise von NVIDIA f√ºr Forschungszwecke zur Verf√ºgung gestellt wurde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendung f√ºr maschinelles Lernen f√ºr Process Mining</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem zu l√∂sen, haben wir mit CatBoostRegressor eine Baseline erstellt und anschlie√üend eine L√∂sung mit einem neuronalen Netzwerk und der Einbettung kategorialer Variablen entwickelt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des Vorhandenseins von kategorialen und materiellen Merkmalen in den Quelldaten wurde beschlossen, Boosting zu verwenden, das kategoriale Merkmale ohne Codierung verarbeiten und das Problem auch bei einer diskreten und materiellen Eingabe l√∂sen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Netze wurden verwendet, um vollst√§ndig Materialattribute zu erstellen und das Problem mit dem gesamten Materialeinsatz zu l√∂sen. Anschlie√üend wurden diese beiden Ans√§tze verglichen und entschieden, ob mit den Netzen gearbeitet werden soll.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten Beschreibung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde beschlossen, externe Daten zu verwenden, die f√ºr uns im Gesch√§ftsbereich geeignet sind und √§hnliche Merkmale aufweisen. </font><font style="vertical-align: inherit;">Der verwendete BPI Challenge 2019-Datensatz enth√§lt 250.000 F√§lle - das sind 1,5 Millionen Ereignisse. </font><font style="vertical-align: inherit;">Die Anfangsdaten werden durch einen Satz von 21 Zeichen beschrieben: 18 kategoriale (es gibt Indexzeichen), zwei boolesche und ein reales. </font><font style="vertical-align: inherit;">Die Ausf√ºhrungszeit des Beschaffungsprozesses wurde als Zielvariable ausgew√§hlt, die den tats√§chlichen Anforderungen des Unternehmens entsprach. </font><font style="vertical-align: inherit;">Eine detaillierte Beschreibung der Merkmale finden Sie in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung des Datensatzes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basislinie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor dem Modelltraining wurden die Daten im Verh√§ltnis 0,8 / 0,2 in Trainings- (Zug) und Testproben (Test) unterteilt. Dar√ºber hinaus erfolgte die Aufteilung nicht nach Ereignissen, sondern nach F√§llen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um festzustellen, wie angemessen es ist, eine komplexe propriet√§re L√∂sung in Form eines neuronalen Netzwerks zu verwenden, wurde die Basislinie mit CatBoost erstellt, einer erweiterten Bibliothek zur Gradientenverst√§rkung auf Entscheidungsb√§umen. Um eine Basislinie zu erstellen, wurde eine minimale Datenvorverarbeitung durchgef√ºhrt (Codierung von kategorialen Merkmalen mit der entsprechenden H√§ufigkeit in den Daten), eine Zielvariable (Falldauer) und eine Reihe neuer Merkmale wurden entwickelt (zus√§tzlich zu denen, die bereits im urspr√ºnglichen Datensatz enthalten sind):</font></font><br>
<br>
<ul>
<li>   .  ,        :      ,         ,     ,          ,   ,      .<br>
</li>
<li>Exponential Moving Average     . EMA     ,         .<br>
</li>
<li>     (, ,  ).<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Training des CatBoostRegressor im Trainingssatz haben wir das folgende Ergebnis erhalten: MAE (Mean Absolute Error) = 17,5 Tage (dh der Wert der vorhergesagten Zielvariablen unterscheidet sich durchschnittlich 17,5 Tage vom wahren Wert). Dieses Ergebnis wurde verwendet, um die Wirksamkeit eines neuronalen Netzwerks zu testen.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der wichtigen Details hierbei ist die Entwicklung der Zielvariablen f√ºr die Basislinie.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Fall haben. Wir bezeichnen es mit c_i aus der Menge C (der Menge aller F√§lle in unserem Datensatz). Jeder Fall ist eine geordnete Folge von Ereignissen, d. H. C_i = (e_0, ‚Äã‚Äã..., e_ni), wobei ni die L√§nge des i-ten Falls ist. F√ºr jede Veranstaltung haben wir einen Zeitstempel - die genaue Zeit, zu der sie begonnen hat. Mit diesen tempor√§ren Stempeln k√∂nnen Sie die Dauer des Falls ohne das letzte Ereignis berechnen. Es ist jedoch nicht sehr gut, jedem Ereignis ein solches Ziel zuzuweisen, dh eine Korrespondenz ek ‚àà ‚Äã‚Äãci, ek ‚Üí ti (ti ist die Dauer des i-ten Falls) zu erstellen. Erstens k√∂nnen √§hnliche Ereignisse (typisch) bei unterschiedlicher Dauer auftreten. Zweitens m√∂chten wir die Dauer des Falls anhand einer bestimmten (zeitlich geordneten) Teilsequenz von Ereignissen vorhersagen (dies ist darauf zur√ºckzuf√ºhren, dass wir nicht die gesamte Abfolge von Ereignissen kennen, dh den Fall vorher nicht kennenwie es passiert ist, aber wir m√∂chten eine Bewertung der Dauer des gesamten Falls anhand einiger bekannter (aufgetretener) Ereignisse aus diesem Fall vornehmen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher m√ºssen wir jeden Fall in Teilsequenzen der L√§nge von eins bis zur L√§nge des Falls zeitlich geordneter Ereignisse aufteilen und eine Zielvariable zuweisen, die der Dauer des Falls entspricht, aus dem diese Teilsequenzen erhalten werden, dh die Entsprechungen ci ‚àà C, ci ‚Üí {sub_cj} ni (ni) nach wie vor ist die L√§nge des i-ten Falls), j = 1 und len (sub_cj) = j. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher teilen wir jeden Fall in Teilsequenzen auf und weisen jeder solchen Teilsequenz die Dauer des gesamten Falls zu. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen zu Teilsequenzen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie bereits erw√§hnt, teilen wir den Fall in Teilsequenzen auf und weisen jedem von ihnen die Dauer des Falls zu. Wir werden Boosting verwenden, das genau auf die Gr√∂√üe der Eingabedaten abgestimmt ist. Jetzt haben wir also X = {{sub_c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ni </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1 N</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sub_c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ik</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die k-te </font><font style="vertical-align: inherit;">Teilsequenz </font><font style="vertical-align: inherit;">des i-ten Falls, t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die L√§nge des i-ten Falls, N ist die Anzahl der F√§lle. Das hei√üt, die Dimension [‚àë </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sc, 17], </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Variable, die der L√§nge der Teilsequenz des entsprechenden Falls entspricht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir kategoriale Variablen nach ihrer H√§ufigkeit codiert haben, haben wir reale und boolesche Variablen sowie codierte kategoriale Variablen (Indexvariablen werden im Lernprozess nicht verwendet). Wir k√∂nnen auch Durchschnittswerte √ºber eine Teilsequenz berechnen, w√§hrend wir in kategorialen Merkmalen die durchschnittliche H√§ufigkeit auftretender kategorialer Werte erhalten, die auch als ein Merkmal betrachtet werden kann, das die Aggregation einer Teilmenge von Ereignissen in einem Fall beschreibt, dh als ein Merkmal, das eine Teilsequenz beschreibt. Lass es und schau was passiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Mittelung von sc √ºber die Dimension erhalten wir die folgende Dimension: [‚àë </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 17]. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modellbau</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den F√§llen teilen wir den Zug in einen anderen Zug und ein Validierungsmuster auf, nehmen einen CatBoostRegressor mit Standardparametern, √ºbergeben ihm ein Trainingsmuster, validieren anhand eines Validierungsmusters, nehmen die beste Iteration und verwenden MAE als Validierungsmetrik. Wir erhalten Folgendes (in der folgenden Abbildung) zum Test (wir bereiten den Test separat f√ºr dieselbe Pipeline vor, auf der der Zug gebaut wurde. Alle Zeichen basieren auf den Daten, die im Test enthalten sind, dh wir haben keine Zeichen, die sich auf die Zielvariable konzentrieren. Die einzige Einschr√§nkung: Wenn die kategorialen Merkmale im Test nicht dem Wert entsprechen, den wir im Zug gesehen haben, ber√ºcksichtigen wir die H√§ufigkeit dieses Werts im Test und aktualisieren das W√∂rterbuch f√ºr die Codierung. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisergebnisse</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90b/f18/386/90bf183863f8ad2cdb50098c58d06a37.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
‚Ä¢ Iterationen: 500. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Lernrate: 0,1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trainingsparameter:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Trainingszeit: weniger als 2 Minuten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Eisen: Tesla k80 (aus Colab). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ergebnisse: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Test MAE: 17,5 Tage. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Die durchschnittliche Dauer des Falls im Test: 66,3 Tage.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neurales Netzwerk</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das neuronale Netzwerk zu trainieren, wurden die Daten verbessert: Einbettungen f√ºr kategoriale Variablen wurden erstellt und die Verteilung der Zielvariablen wurde angepasst. </font><font style="vertical-align: inherit;">Als n√§chstes wurde das neuronale Netzwerk auf dem NVIDIA Tesla K80 (Google Colab) und auf der NVIDIA DGX Station trainiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Ergebnisse wurden erhalten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schulungszeit auf NVIDIA K80 (Google Colab): 20 Minuten.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schulungszeit an der NVIDIA DGX Station: 8 Minuten.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Trainingszeit des neuronalen Netzwerks ist auf die unterschiedlichen technischen Eigenschaften der verwendeten GPUs zur√ºckzuf√ºhren:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA Tesla K80 (Google Colab)</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA DGX Station</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1X NVIDIA Tesla K80 12 GB</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4X NVIDIA Tesla V100 32 GB</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorverarbeitung</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue Zeichen</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EMA zum Wert der Veranstaltung: Wir wollen den Trend bei den Kosten der Aktivit√§ten f√ºr jeden Fall erfassen.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art des Fehlers: In der Datensatzbeschreibung finden Sie Informationen zu vier Arten einiger beschreibender Statistiken des Kaufs (Ereignisses). Diese Typen sind im urspr√ºnglichen Datensatz in die Werte von zwei Variablen unterteilt. </font><font style="vertical-align: inherit;">Wir aggregieren es einfach zur√ºck (wenn Sie sich die Beschreibung des Datensatzes ansehen, wird klar, wovon wir sprechen).</font></font><br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kategoriale Zeichen Wir</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
codieren einfach die eindeutigen Werte von kategorialen Zeichen mit nat√ºrlichen Zahlen, damit wir sp√§ter Einbettungen unterrichten k√∂nnen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einbettungen f√ºr kategoriale Variablen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wir bestimmen die Dimension der Einbettungen f√ºr jede kategoriale Variable:</font></font><br>
<br>
<ul>
<li>,   ÃÜ  ÃÜ ÃÜ.    ÃÜ ,         ÃÜ  ÃÜ ,    ÃÜ,  .  : MUi&nbsp; = min(CAT_EMBEDDING_DIM; (len(uniquei) + 1) // 2), CAT_EMBEDDING_DIM ‚Äî , uniquei ‚Äî   i-  .<br>
</li>
<li> ,      3,       i-ÃÜ ÃÜ   max(3;MUi)+1,  1,        ,     train,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unk</a>-.<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir passen die Verteilung des Ziels in der Zugstichprobe an. Die</font></font></b>&nbsp;<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
anf√§ngliche Verteilung hat sich aufgrund von Ausrei√üern (F√§lle, die 250.000 Tage dauerten) und einer gro√üen Anzahl von Kurzf√§llen stark nach links verschoben. Daher z√§hlen wir die Perzentile 0,05 und 0,95 und belassen die Daten aus dem Zug mit dem Ziel dazwischen diese Stromschnellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach haben wir immer noch F√§lle, die ungef√§hr einen und ungef√§hr 100 Tage dauern, dh die Zielvariable durchl√§uft mehrere Gr√∂√üenordnungen. Daher wird die Annahme, dass die Varianz in der Verteilung der Zielvariablen um den Entscheidungsalgorithmus konstant ist, kaum erf√ºllt, dh die Verteilung der Zielvariablen ist nahezu normal, aber die Varianz ist nicht konstant, da die Zielvariable entweder kleiner als 1 oder gr√∂√üer als 100 sein kann Irgendwie diesen Effekt ausgleichen, normalisieren wir die Daten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis ist in der folgenden Grafik dargestellt (schwarze Linie ist die Normalverteilung).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k4/qs/vz/k4qsvz1egedfnm9q4y6nljidoam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann teilen wir unsere Daten nach Fall in Zug und Validierung auf. </font><font style="vertical-align: inherit;">Hier gibt es auch eine offensichtliche Nuance: Wir normalisieren das Ziel mit dem Durchschnitt und der Abweichung, die anhand aller Daten berechnet werden, und teilen dann durch Zug und Validierung, das hei√üt, es stellt sich wie ein Gesicht im Zug heraus, aber da wir hier ein Hilfsproblem l√∂sen, scheint dieses Gesicht nicht kritisch.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geb√§udeschilder</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idee</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nehmen nur kategorische Zeichen aus unserem Zug, die durch nat√ºrliche Zahlen codiert sind.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nehmen keine Teilzeichenfolgen aus F√§llen, sondern lediglich Ereignisse, dh eine Zeile in unseren Daten f√ºr Einbettungen - dies ist ein Ereignis, das durch codierte kategoriale Merkmale gekennzeichnet ist.</font></font><br>
</li>
<li> :     ,   ÃÜ,      ,   ,        ,            ÃÜ  ÃÜ    ÃÜ. - ,         ÃÜ,  ,  ,     ÃÜ (    ),      (     ,  - ÃÜ  ).<br>
</li>
<li>       ÃÜ        .<br>
</li>
<li>     ,     8-ÃÜÃÜ   elu   ÃÜ,   (  ,   ,     ,  L2-)     .<br>
</li>
<li>,           , ‚Äî    ,      ,    .<br>
</li>
<li>Summary:    ‚Äî ÃÜ  ÃÜ ÃÜ ÃÜ        ‚Äî  ÃÜ.<br>
</li>
</ul><br>
<h3>   </h3><br>
<ul>
<li>Batch size = 1000</li>
<li>Learning rate = 3e-04.</li>
<li>  = 15.</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station .</li>
<li> (colab) ‚Äì 50 .</li>
<li> (Nvidia DGX Station) ‚Äî 18 .</li>
</ul><br>
<img src="https://habrastorage.org/webt/53/4y/gh/534yghkinehatjl8cm1xwg5j0oi.png"><br>
<br>
<h3> </h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenvorbereitung</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jetzt haben wir Einbettungen f√ºr kategoriale Variablen (hier gibt es eine Nuance: Wir haben ehrlich gesagt eindeutige Werte f√ºr kategoriale Variablen in unserem Zug verwendet (nicht f√ºr die, die wir f√ºr Trainingseinbettungen zugewiesen haben, sondern f√ºr die, die wir zu Beginn zugewiesen haben Training), daher besteht die M√∂glichkeit, dass die Testdaten einen Wert von kategorialen Variablen enthalten, die wir im Zug nicht gesehen haben, dh wir haben keine Einbettung f√ºr diesen Wert trainiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr solche Werte wird eine separate Zeile in den Einbettungsmatrizen erstellt. In unserem Fall besteht das Problem jedoch darin, dass sie w√§hrend des Trainings nicht beteiligt sind und daher nicht studieren. Wenn wir davon ausgehen, dass wir einen Wert einer zuvor nicht gesehenen kategorialen Variablen treffen, nehmen wir diesen Vektor, aber tats√§chlich wird er einfach aus der Initialisierungsverteilung entnommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Trainieren dieses Vektors gibt es eine Richtung zur Verbesserung des Modells. Die Idee ist, dass sehr seltene Werte im Zug mit diesem Vektor codiert werden k√∂nnen, denn wenn wir nur im Test einen neuen Wert sehen, der bedingt 20% der gesamten Anfangsstichprobe ausmacht, ist dieser Wert selten und verh√§lt sich wahrscheinlich Gleich wie seltene Werte im Zug.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Fall ersetzen wir die kategorialen Variablen durch die entsprechende Einbettung, verbinden uns mit den reellen und booleschen Attributen und erhalten eine Matrix der Gr√∂√üe [N, F], wobei F die Summe der Dimensionen der Einbettungen f√ºr kategoriale Variablen, die Anzahl der reellen und booleschen Attribute ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir f√ºhren eine Gruppierung von Ereignissen in einer Teilsequenz durch (wie zuvor durchgef√ºhrt). </font><font style="vertical-align: inherit;">Die Zielvariable f√ºr die Teilsequenz ist die Dauer des Falls, aus dem die Teilsequenz erhalten wurde. </font><font style="vertical-align: inherit;">Addieren Sie die Anzahl der Ereignisse und die Summe der Kosten der Ereignisse in dieser Teilsequenz zum Vektor der Teilsequenz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir eine Matrix fester Gr√∂√üe - Sie k√∂nnen sie in das Modell einspeisen (vorher normalisieren wir die Matrix). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelisierungsmethode</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen einen Turm f√ºr jede GPU.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jedem Schritt teilen wir die Parameter auf die T√ºrme auf.</font></font><br>
</li>
<li>       .<br>
</li>
<li> ÃÜ   ,   .<br>
</li>
<li>       (      ,       ÃÜ ÃÜ         ).<br>
</li>
<li>        .<br>
</li>
<li>     ,   -  (   ,  word2vec-style,     ).<br>
</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>          ()   ()  ().<br>
</li>
<li>ÃÜ :   ‚Äî   ,     gpu     ,    ,   gpu     .<br>
</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>: 7-ÃÜÃÜ    elu.<br>
</li>
<li>   ÃÜ ,    .<br>
</li>
<li>Batch size = 1000.<br>
</li>
<li>Learning rate = 3e-04.<br>
</li>
<li>  = 15.<br>
</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station.<br>
</li>
<li> (colab) = 20 .<br>
</li>
<li> (Nvidia DGX Station) = 8 .<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Teil des Modelldiagramms. </font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/u5/4e/3e/u54e3eoth5n5kmcdryndbpqgcua.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressourcenverbrauch und Parallelisierung. Das</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Training neuronaler Netze auf einer CPU dauert etwa viermal so lange wie auf einer NVIDIA DGX-Station. In diesem Fall scheint der Unterschied unbedeutend zu sein - acht Minuten auf der NVIDIA DGX Station und 32 Minuten auf der CPU. Dies ist jedoch ein kleines Modell mit einer kleinen Datenmenge. Bei der Implementierung realer Projekte, bei denen es mehrmals mehr F√§lle und Ereignisse geben wird, dauert die Schulung der CPU mindestens eine Woche. In diesem Fall reduziert die Verwendung der NVIDIA DGX Station die Schulungszeit auf zwei Tage, was die Arbeitseffizienz erheblich erh√∂ht.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es zeigte sich auch, dass die Geschwindigkeit des Lernprozesses stark von der Anzahl der verwendeten GPUs abh√§ngt, was den Vorteil der NVIDIA DGX Station zeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wird durch fr√ºhere Experimente mit der NVIDIA DGX Station-CPU und -GPU unter Verwendung des Originaldatensatzes ohne vorherige Verarbeitung best√§tigt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lernzeit auf der CPU: 6 Minuten 18 Sekunden.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU-Trainingszeit: 34 Sekunden.</font></font><br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU- </font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f1/015/d82/6f1015d82101dda1e0af40e599ee96a2.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lastvisualisierung CPU-Lastvisualisierung</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/efe/3ae/f3b/efe3aef3b801dcbd14655b3851ae9ad3.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse des neuronalen Netzes</font></font></h3><br>
<img src="https://habrastorage.org/webt/-g/2g/p1/-g2gp1o1sdktbwtspcurjfdiwqu.png"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test MAE = 10 Tage.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die durchschnittliche Testdauer = 67 Tage.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inferenzzeit = 20 Sekunden.</font></font><br>
</li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben ein Pilotprojekt implementiert, um Methoden des maschinellen Lernens im Rahmen von Process Mining-Aufgaben zu bewerten.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Liste unserer Tools getestet und erweitert, mit denen wir gesch√§ftliche Probleme l√∂sen k√∂nnen.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der interessanten Ergebnisse war das Schreiben unserer eigenen Implementierung von Parallel Computing auf 4 Tesla v100-Karten, mit denen die DGX-Station ausgestattet ist: Die Verwendung mehrerer GPUs beschleunigt das Lernen fast im Einklang mit der Anzahl der GPUs (der Code ist parallelisiert).</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der √úbergang zu einem vollst√§ndig kontinuierlichen Eintrag und die Verwendung eines neuronalen Netzwerks erm√∂glichten es, eine Woche Pause von der Grundlinie einzulegen.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zeit erh√∂ht sich von einigen Minuten auf eineinhalb Stunden (Schulung in endg√ºltiger Architektur und Einbettungen, aber Einbettungen k√∂nnen vorab trainiert verwendet werden, sodass die Zeit auf 20 Minuten reduziert wird).</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beschriebenen Experimente zeigen, dass im Bereich Process Mining maschinelle und Deep-Learning-Algorithmen erfolgreich angewendet werden k√∂nnen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus wurde festgestellt, dass die Geschwindigkeit des Lernprozesses stark von der Anzahl der verwendeten GPUs abh√§ngt, was den Vorteil der NVIDIA DGX Station zeigt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was und wie kann verbessert werden</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einbettungen im Word2vec-Stil f√ºr Ereignisse</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei der </font><b><font style="vertical-align: inherit;">Erstellung</font></b><font style="vertical-align: inherit;"> unseres Modells, einschlie√ülich Einbettungen f√ºr kategoriale Variablen, haben wir die Reihenfolge der Ereignisse relativ zueinander, </font><b><font style="vertical-align: inherit;">dh</font></b><font style="vertical-align: inherit;"> die eigent√ºmliche Semantik von Ereignissen in F√§llen, nicht ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Um aus der Reihenfolge der Ereignisse in den F√§llen etwas N√ºtzliches zu lernen, m√ºssen Sie Einbettungen f√ºr diese Ereignisse trainieren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idee</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nehmen ein kategoriales Merkmal und ein Real, teilen das Real in einen Bucket auf, dann wird jede Transaktion durch den Wert der kategorialen Variablen und den Bucket charakterisiert, in den der Wert der Realvariablen f√§llt. </font><font style="vertical-align: inherit;">Kombinieren Sie diese beiden Werte, erhalten Sie sozusagen ein Analogon des Wortes f√ºr das Ereignis.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir betrachten den Fall als einen Satz (die Menge der W√∂rter im Satz entspricht der Menge der Ereignisse im Fall).</font></font><br>
</li>
<li> ÃÜ      ,          ÃÜ   ÃÜ,    ,             .<br>
</li>
<li>   ÃÜ,     Skipgram  CBOW   .<br>
</li>
<li>  ,      ÃÜ,            .<br>
</li>
</ul><br>
<b> </b><br>
<br>
<ul>
<li>  Skipgram.<br>
</li>
<li>  ‚Äî 5.<br>
</li>
</ul><br>
<ul>
<li>Batch size = 1000.<br>
</li>
<li>Learning rate = 3e-04.<br>
</li>
<li>  = 10.<br>
</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station.<br>
</li>
<li> (colab) ‚Äî 20 .<br>
</li>
<li> (Nvidia DGX Station) ‚Äî 8 .<br>
</li>
<li>Test MAE    : 10 ÃÜ.&nbsp;<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl Die</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/438/137/cb8/438137cb87ac22637e44a01da4a56dfc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Verwendung von Funktionen aus Einbettungen erh√∂ht sich um einige Zehntel eines Tages. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einbettungen erwiesen sich nat√ºrlich als ungebildet, weil sie ein wenig trainierten.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt ungef√§hr 290 Features aus kategorialen Einbettungen und 20 Features aus semantischen Einbettungen (dies ist nicht mehr sinnvoll, da die Gr√∂√üe des W√∂rterbuchs gering ist), sodass der Einfluss dieser semantischen Features aufgrund eines Ungleichgewichts im Anteil der Features ausgeglichen werden kann.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Semantik zwischen Ereignissen muss irgendwie zum Trainingssatz hinzugef√ºgt werden, da aufgrund der Tatsache, dass die Abfolgen von Ereignissen (F√§llen) geordnet sind, die Reihenfolge wichtig ist und Informationen daraus extrahiert werden k√∂nnen.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen komplexere Architekturen f√ºr Einbettungen verwenden.</font></font><br>
</li>
<li>      ,       ,    ‚Äî     .<br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493138/index.html">Sprechen Sie mit mir: Was Voice Bots heute k√∂nnen</a></li>
<li><a href="../de493140/index.html">Die Abenteuer von Cipollino: Quarant√§ne IT Quest von Flant</a></li>
<li><a href="../de493142/index.html">"Lass uns Kubernetes benutzen!" Sie haben jetzt 8 Probleme</a></li>
<li><a href="../de493146/index.html">Spannende Nebenprojekte, die Sie heute durchf√ºhren k√∂nnen</a></li>
<li><a href="../de493150/index.html">"Remote" mit einem Cisco-Router</a></li>
<li><a href="../de493158/index.html">Loghouse 0.3 - das lang erwartete Update unseres Protokollierungssystems in Kubernetes</a></li>
<li><a href="../de493160/index.html">Wie wir die intelligente Suche auf hh.ru im Jahr 2019 verbessert haben: Infografiken</a></li>
<li><a href="../de493162/index.html">Eine offene Liste von Online-Meetings und Konferenzen</a></li>
<li><a href="../de493164/index.html">Es stellt sich heraus, dass das Online-Gesch√§ft in der aktuellen Umgebung √ºberlebt. Warum? DNA gel√∂scht</a></li>
<li><a href="../de493166/index.html">Ontol: eine Auswahl von Artikeln √ºber "Burnout" [100+]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>