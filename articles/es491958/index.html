<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê£ üôÖüèª üë©üèø‚Äçü§ù‚Äçüë©üèΩ Gu√≠a de compresi√≥n de animaci√≥n esqueleto üèáüèΩ üè¶ üë©‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo ser√° una breve descripci√≥n de c√≥mo implementar un esquema simple de compresi√≥n de animaci√≥n y algunos conceptos relacionados. De ninguna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de compresi√≥n de animaci√≥n esqueleto</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491958/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/6v/gp/o16vgpz4u-9_ntko92qweoxqzx0.png" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo ser√° una breve descripci√≥n de c√≥mo implementar un esquema simple de compresi√≥n de animaci√≥n y algunos conceptos relacionados. </font><font style="vertical-align: inherit;">De ninguna manera soy un experto en este asunto, pero hay muy poca informaci√≥n sobre este tema y est√° bastante fragmentada. </font><font style="vertical-align: inherit;">Si desea leer m√°s art√≠culos sobre este tema, le recomiendo que vaya a los siguientes enlaces:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://nfrechette.github.io/2016/10/21/anim_compression_toc/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technology.riotgames.com/news/compressing-skeletal-animation-data</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2011/10/low-level-animation-part-2.html</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar, vale la pena dar una breve introducci√≥n a la animaci√≥n esquel√©tica y algunos de sus conceptos b√°sicos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conceptos b√°sicos de animaci√≥n y compresi√≥n.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La animaci√≥n esquel√©tica es un tema bastante simple, si te olvidas del desollado. Tenemos un concepto de un esqueleto que contiene transformaciones de los huesos de un personaje. Estas transformaciones √≥seas se almacenan en un formato jer√°rquico; de hecho, se almacenan como un delta entre su posici√≥n global y la posici√≥n de los padres. La terminolog√≠a aqu√≠ es confusa, porque en el motor del juego, el local a menudo se llama espacio modelo / personaje, y global es el espacio mundial. En terminolog√≠a de animaci√≥n, local se llama el espacio del padre del hueso, y global es el espacio del personaje o el espacio mundial, dependiendo de si hay movimiento del hueso ra√≠z; pero no nos preocupemos tanto por eso. Lo importante es que las transformaciones √≥seas se almacenan localmente en relaci√≥n con sus padres. Esto tiene muchas ventajas, y especialmente al mezclar (mezclar):Si la mezcla de las dos posiciones fuera global, entonces se interpolar√≠an linealmente en la posici√≥n, lo que conducir√≠a a un aumento y disminuci√≥n de los huesos y la deformaci√≥n del personaje.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y si usa deltas, la mezcla se realiza de una diferencia a otra, por lo que si la transformaci√≥n delta para un hueso entre dos poses es la misma, entonces la longitud del hueso permanece constante. Creo que es m√°s f√°cil (pero no del todo exacto) tomarlo de esta manera: el uso de deltas conduce a un movimiento "esf√©rico" de las posiciones √≥seas durante la mezcla, y la mezcla de transformaciones globales conduce a un movimiento lineal de las posiciones √≥seas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La animaci√≥n esquel√©tica es solo una lista ordenada de fotogramas clave con una frecuencia de fotogramas (generalmente) constante. El marco clave es la pose del esqueleto. Si queremos obtener una pose entre los fotogramas clave, tomamos muestras de ambos fotogramas clave y mezclamos entre ellos, usando la fracci√≥n del tiempo entre ellos como el peso de la mezcla. La imagen a continuaci√≥n muestra una animaci√≥n creada a 30 fps. La animaci√≥n tiene un total de 5 cuadros y necesitamos obtener la pose 0.52 s despu√©s del comienzo. Por lo tanto, necesitamos muestrear la pose en el cuadro 1 y la pose en el cuadro 2, y luego mezclarlas entre ellas con un peso de mezcla de aproximadamente el 57%.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/f11/c43/733f11c43022b935901e6f20f8a70fab.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de una animaci√≥n de 5 cuadros y una solicitud de una pose en un tiempo de cuadro intermedio</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Teniendo la informaci√≥n anterior y considerando que la memoria no es un problema para nosotros, el guardado secuencial de la pose ser√≠a la forma ideal de almacenar la animaci√≥n, como se muestra a continuaci√≥n:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/7c5/f3c/d287c5f3cbfd9a8144d20432c3a258dc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almacenamiento de datos de animaci√≥n simple</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© es esto perfecto? El muestreo de cualquier fotograma clave se reduce a una simple operaci√≥n de memoria. El muestreo de una pose intermedia requiere dos operaciones memcpy y una operaci√≥n de mezcla. Desde el punto de vista del cach√©, copiamos usando memcpy dos bloques de datos en orden, es decir, despu√©s de copiar el primer fotograma, uno de los cach√©s ya tendr√° un segundo fotograma. Puedes decir: espera, cuando hacemos la mezcla, necesitamos mezclar todos los huesos; ¬øQu√© pasa si la mayor√≠a de ellos no cambian entre cuadros? ¬øNo ser√≠a mejor almacenar huesos como registros y mezclar solo transformaciones cambiadas? Bueno, si esto se implementa, pueden producirse un poco m√°s de errores de cach√© al leer registros individuales, y luego deber√° realizar un seguimiento de las conversiones que necesita mezclar, y as√≠ sucesivamente ... La mezcla puede parecer mucho trabajo que lleva mucho tiempo,pero en esencia es la aplicaci√≥n de una instrucci√≥n a dos bloques de memoria que ya est√°n en el cach√©. Adem√°s, el c√≥digo de mezcla es relativamente simple, a menudo solo un conjunto de instrucciones SIMD sin ramificaci√≥n, y un procesador moderno las procesar√° en cuesti√≥n de segundos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema con este enfoque es que requiere una cantidad extremadamente grande de memoria, especialmente en juegos donde las siguientes condiciones son verdaderas para el 95% de los datos.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los huesos tienen una longitud constante.</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los personajes en la mayor√≠a de los juegos no estiran los huesos, por lo tanto, dentro de la misma animaci√≥n, los registros de las transformaciones son constantes.</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usualmente no escalamos los huesos.</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La escala rara vez se usa en animaciones de juegos. </font><font style="vertical-align: inherit;">Se usa bastante activamente en pel√≠culas y efectos visuales, pero muy poco en juegos. </font><font style="vertical-align: inherit;">Incluso cuando se usa, generalmente se usa la misma escala.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, en la mayor√≠a de las animaciones que cre√© en tiempo de ejecuci√≥n, aprovech√© este hecho y mantuve toda la transformaci√≥n √≥sea en 8 variables flotantes: 4 para rotar el cuaterni√≥n, 3 para mover y 1 para escalar. </font><font style="vertical-align: inherit;">Esto reduce significativamente el tama√±o de la pose en el tiempo de ejecuci√≥n, proporcionando una mayor productividad al mezclar y copiar.</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con todo esto en mente, si observa el formato de datos original, puede ver cu√°n ineficiente est√° gastando memoria. </font><font style="vertical-align: inherit;">Duplicamos los valores de desplazamiento y escala de cada hueso, incluso si no cambian. </font><font style="vertical-align: inherit;">Y la situaci√≥n se est√° yendo r√°pidamente de las manos. </font><font style="vertical-align: inherit;">Por lo general, los animadores crean animaciones a una frecuencia de 30 fps, y en los juegos de nivel AAA, un personaje generalmente tiene alrededor de 100 huesos. </font><font style="vertical-align: inherit;">Seg√∫n esta cantidad de informaci√≥n y un formato de 8 flotantes, como resultado necesitamos alrededor de 3 KB por pose y 94 KB por segundo de animaci√≥n. </font><font style="vertical-align: inherit;">Los valores se acumulan r√°pidamente y en algunas plataformas pueden obstruir f√°cilmente toda la memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces hablemos de compresi√≥n; </font><font style="vertical-align: inherit;">Al intentar comprimir datos, hay varios aspectos a considerar:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√çndice de compresi√≥n</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°nto logramos reducir la cantidad de memoria ocupada?</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calidad</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cu√°nta informaci√≥n perdimos de los datos de origen</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasa de compresi√≥n</font></font></strong><ul>
<li>     </li>
</ul></li>
<li><strong> </strong><ul>
<li>           .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me preocupa principalmente la calidad y la velocidad, y me preocupa menos la memoria. Adem√°s, trabajo con animaciones de juegos, y puedo aprovechar el hecho de que, de hecho, para reducir la carga en la memoria, no tenemos que usar el desplazamiento y la escala en los datos. Debido a esto, podemos evitar una disminuci√≥n en la calidad causada por una disminuci√≥n en el n√∫mero de cuadros y otras soluciones con p√©rdidas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n es extremadamente importante tener en cuenta que no debe subestimar el efecto de la compresi√≥n de animaci√≥n en el rendimiento: en uno de mis proyectos anteriores, la tasa de muestreo disminuy√≥ en aproximadamente un 35%, y tambi√©n hubo algunos problemas de calidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando comenzamos a trabajar con la compresi√≥n de datos de animaci√≥n, hay dos √°reas importantes a tener en cuenta:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCon qu√© rapidez podemos comprimir elementos individuales de informaci√≥n en un cuadro clave (cuaterniones, flotante, etc.).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo podemos comprimir la secuencia de fotogramas clave para eliminar informaci√≥n redundante?</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discretizaci√≥n de datos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Casi toda esta secci√≥n se puede reducir a un principio: discretizar datos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La discretizaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una forma dif√≠cil de decir que queremos convertir un valor de un intervalo continuo a un conjunto discreto de valores.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flotador de discretizaci√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se trata de muestrear valores flotantes, nos esforzamos por tomar ese valor flotante y representarlo como un entero usando menos bits. El truco es que un n√∫mero entero puede no representar realmente un n√∫mero fuente, sino un valor en un intervalo discreto asignado a un intervalo continuo. Por lo general, se utiliza un enfoque muy simple. Para muestrear un valor, primero necesitamos un intervalo para el valor original; Habiendo recibido este intervalo, normalizamos el valor inicial para este intervalo. Luego, este valor normalizado se multiplica por el valor m√°ximo posible para el tama√±o de salida dado en bits deseado. Es decir, para 16 bits multiplicamos el valor por 65535. Luego, el valor resultante se redondea al entero m√°s cercano y se almacena. Esto se muestra claramente en la imagen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e73/827/f7be73827067126fd51c0bf6f2396b10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de muestreo de un flotante de 32 bits a un entero de 16 bits sin signo</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para obtener nuevamente el valor original, simplemente realizamos las operaciones en el orden inverso. Es importante tener en cuenta aqu√≠ que necesitamos registrar en alg√∫n lugar el intervalo inicial del valor; de lo contrario, no podremos decodificar el valor muestreado. El n√∫mero de bits en el valor muestreado determina el tama√±o del paso en el intervalo normalizado y, por lo tanto, el tama√±o del paso en el intervalo original: el valor descodificado ser√° un m√∫ltiplo de este tama√±o de paso, lo que nos permite calcular f√°cilmente el error m√°ximo que se produce debido al proceso de muestreo, por lo que podemos determinar el n√∫mero de bits requerido para nuestra aplicaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No dar√© ejemplos del c√≥digo fuente, porque hay una biblioteca bastante conveniente y simple para realizar operaciones de muestreo b√°sicas, que es una buena fuente sobre este tema: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/r-lyeh-archived/quant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Dir√≠a que no deber√≠a usar su funci√≥n de discretizaci√≥n de cuaterni√≥n, sino m√°s sobre esto m√°s adelante).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi√≥n Quaternion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compresi√≥n Quaternion es un tema bien estudiado, por lo que no repetir√© lo que otras personas explicaron mejor. </font><font style="vertical-align: inherit;">Aqu√≠ hay un enlace a una publicaci√≥n de compresi√≥n de instant√°neas que proporciona la mejor descripci√≥n sobre este tema: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://gafferongames.com/post/snapshot_compression/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, tengo algo que decir sobre el tema. </font><font style="vertical-align: inherit;">Las publicaciones de bitsquid, que hablan sobre la compresi√≥n del cuaterni√≥n, sugieren comprimir el cuaterni√≥n a 32 bits utilizando aproximadamente 10 bits de datos para cada componente del cuaterni√≥n. </font><font style="vertical-align: inherit;">Esto es exactamente lo que hace Quant, porque se basa en publicaciones de bitsquid. </font><font style="vertical-align: inherit;">En mi opini√≥n, dicha compresi√≥n es demasiado grande y en mis pruebas caus√≥ fuertes sacudidas. </font><font style="vertical-align: inherit;">Quiz√°s los autores usaron jerarqu√≠as menos profundas del personaje, pero si multiplica m√°s de 15 cuaterniones de mis ejemplos de animaci√≥n, el error combinado resulta ser bastante grave. </font><font style="vertical-align: inherit;">En mi opini√≥n, el </font><font style="vertical-align: inherit;">m√≠nimo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absoluto</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de precisi√≥n es de 48 bits por cuaterni√≥n.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reducci√≥n de tama√±o debido al muestreo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar a considerar los diferentes m√©todos de compresi√≥n y la disposici√≥n de los registros, veamos qu√© tipo de compresi√≥n obtenemos si simplemente aplicamos la discretizaci√≥n en el circuito original. Usaremos el mismo ejemplo que antes (un esqueleto de 100 huesos), as√≠ que si usamos 48 bits (3 x 16 bits) por cuaterni√≥n, 48 bits (3 √ó 16) para mover y 16 bits para escalar, entonces en total para la conversi√≥n Necesitamos 14 bytes en lugar de 32 bytes. Esto es 43.75% del tama√±o original. Es decir, durante 1 segundo de animaci√≥n con una frecuencia de 30 FPS, redujimos el volumen de aproximadamente 94 KB a aproximadamente 41 KB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto no est√° nada mal, la discretizaci√≥n es una operaci√≥n de costo relativamente bajo, por lo que esto no afectar√° demasiado el tiempo de desempaque. </font><font style="vertical-align: inherit;">Encontramos un buen punto de partida para el inicio, y en algunos casos esto incluso ser√° suficiente para implementar animaciones dentro del presupuesto de recursos y garantizar una excelente calidad y rendimiento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabar compresi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ todo se vuelve muy complicado, especialmente cuando los desarrolladores comienzan a probar t√©cnicas como reducir el marco clave, el ajuste de curvas, etc. </font><font style="vertical-align: inherit;">Tambi√©n en esta etapa realmente estamos comenzando a reducir la calidad de las animaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En casi todas estas decisiones, se supone que las caracter√≠sticas de cada hueso (rotaci√≥n, desplazamiento y escala) se almacenan como un registro separado. </font><font style="vertical-align: inherit;">Por lo tanto, podemos voltear el circuito, como lo mostr√© antes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/752/16a/f6475216adb6ac795e1737de30aef6af.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar datos de huesos como registros</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aqu√≠ simplemente guardamos todos los registros secuencialmente, pero tambi√©n podr√≠amos agrupar todos los registros de rotaciones, desplazamientos y escalas. La idea b√°sica es pasar de almacenar datos de cada pose a almacenar registros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez hecho esto, podemos usar otras formas para reducir a√∫n m√°s la memoria ocupada. El primero es comenzar a soltar cuadros. Nota: esto no requiere un formato de registro y este m√©todo se puede aplicar en el esquema anterior. Este m√©todo funciona, pero conduce a la p√©rdida de peque√±os movimientos en la animaci√≥n, porque descartamos la mayor√≠a de los datos. Esta t√©cnica se utiliz√≥ activamente en la PS3, y a veces tuvimos que rebajarnos a frecuencias de muestreo incre√≠blemente bajas, por ejemplo, hasta 7 cuadros por segundo (generalmente para animaciones no muy importantes). Tengo malos recuerdos de esto, como programador de animaci√≥n veo claramente los detalles perdidos y la expresividad, pero si se mira desde el punto de vista del programador del sistema, podemos decir que la animaci√≥n es "casi" la misma, porque en general el movimiento se conserva, pero al mismo tiempo Ahorre mucha memoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omitamos este enfoque (en mi opini√≥n, es demasiado destructivo) y consideremos otras opciones posibles. Otro enfoque popular es crear una curva para cada registro y realizar la reducci√≥n de fotogramas clave en la curva, es decir eliminar fotogramas clave duplicados. Desde el punto de vista de las animaciones de juegos, con este enfoque, las grabaciones de movimiento y escala se comprimen perfectamente, a veces se reducen a un fotograma clave. Esta soluci√≥n no es destructiva, pero requiere desempaquetar, porque cada vez que necesitamos obtener la transformaci√≥n, tenemos que calcular la curva, porque ya no podemos simplemente ir a los datos en la memoria. La situaci√≥n se puede mejorar un poco si </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcula las animaciones en una sola direcci√≥n.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y almacene el estado de la muestra de cada animaci√≥n para cada hueso (es decir, de d√≥nde obtener el c√°lculo de la curva), pero debe pagar esto con un aumento en la memoria y un aumento significativo en la complejidad del c√≥digo. En los sistemas de animaci√≥n modernos, a menudo no reproducimos animaciones de principio a fin. A menudo, en ciertas compensaciones de tiempo, hacen transiciones a nuevas animaciones gracias a cosas como la combinaci√≥n sincronizada o la coincidencia de fases. A menudo, tomamos muestras de poses individuales pero no consecutivas para implementar cosas como mezclar apuntar / mirar un objeto, y a menudo las animaciones se reproducen en orden inverso. Por lo tanto, no recomiendo usar una soluci√≥n de este tipo, simplemente no vale la pena la molestia causada por la complejidad y los posibles errores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n existe el concepto de no solo eliminar claves id√©nticas en las curvas, sino tambi√©n especificar un umbral en el que se eliminen claves similares; Esto lleva al hecho de que la animaci√≥n se desvanece, similar al m√©todo de soltar cuadros, porque el resultado final es el mismo en t√©rminos de datos. A menudo se utilizan esquemas de compresi√≥n de animaci√≥n, en los que se establecen par√°metros de compresi√≥n para cada registro, y los animadores se atormentan constantemente con estos valores, tratando de mantener la calidad y reducir el tama√±o al mismo tiempo. Este es un flujo de trabajo doloroso y estresante, pero es necesario si trabaja con la memoria limitada de las generaciones anteriores de consolas. Afortunadamente, hoy tenemos un gran presupuesto de memoria y no necesitamos cosas tan terribles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos estos aspectos se revelan en las publicaciones de Riot / BitSquid y Nicholas (ver enlaces al comienzo de mi art√≠culo). No hablar√© de ellos en detalle. En cambio, hablar√© sobre lo que decid√≠ sobre comprimir los registros ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yo ... decid√≠ no comprimir los registros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar a agitar, perm√≠tame explicar ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando guardo los datos en los registros, almaceno los datos de rotaci√≥n para todos los cuadros. Cuando se trata de movimiento y escala, hago un seguimiento de si el movimiento y la escala son est√°ticos durante la compresi√≥n, y si es as√≠, guardo solo un valor por registro. Es decir, si el registro se mueve a lo largo de X, pero no a lo largo de Y y Z, entonces guardo todos los valores de mover el registro a lo largo de X, pero solo un valor de mover el registro a lo largo de Y y Z.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta situaci√≥n surge para la mayor√≠a de los huesos en aproximadamente el 95% de nuestras animaciones, por lo que al final podemos reducir significativamente la memoria ocupada, absolutamente sin perder calidad. Esto requiere trabajo desde el punto de vista de la creaci√≥n de contenido (DCC): no queremos que los huesos tengan ligeros movimientos y aumentos en el flujo de trabajo de creaci√≥n de animaci√≥n, pero tal beneficio vale el costo adicional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro ejemplo de animaci√≥n, solo hay dos registros con movimiento y no hay registros con escala. Luego, durante 1 segundo de animaci√≥n, el volumen de datos disminuye de 41 KB a 18.6 KB (es decir, hasta el 20% del volumen de los datos originales). La situaci√≥n se vuelve a√∫n mejor cuando aumenta la duraci√≥n de la animaci√≥n, gastamos recursos solo en grabar turnos y movimientos din√°micos, y los costos de las grabaciones est√°ticas permanecen constantes, lo que ahorra m√°s en animaciones largas. Y no tenemos que experimentar una p√©rdida de calidad causada por el muestreo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con toda esta informaci√≥n en mente, mi esquema de datos final se ve as√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f5/347/eb0/9f5347eb09718967ebacbe89d443e992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de un esquema de datos de animaci√≥n comprimido (3 cuadros por registro)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Adem√°s, guardo el desplazamiento en el bloque de datos para iniciar los datos de cada hueso. </font><font style="vertical-align: inherit;">Esto es necesario porque a veces necesitamos muestrear datos para un solo hueso sin leer la pose completa. </font><font style="vertical-align: inherit;">Esto nos proporciona una forma r√°pida de acceder directamente a los datos de registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de los datos de animaci√≥n almacenados en un bloque de memoria, tambi√©n tengo opciones de compresi√≥n para cada registro:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/b3d/7a3/4d7b3d7a3f1362c0429d72591268dbce.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de par√°metros de compresi√≥n para registros de mi motor Kruger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Estos par√°metros almacenan todos los datos que necesito para decodificar los valores muestreados de cada registro. </font><font style="vertical-align: inherit;">Tambi√©n monitorean la est√°tica de los registros para que yo sepa c√≥mo manejar los datos comprimidos cuando me tropiezo con un registro est√°tico durante el muestreo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n puede observar que la discretizaci√≥n para cada registro es individual: durante la compresi√≥n, sigo los valores m√≠nimos y m√°ximos de cada caracter√≠stica (por ejemplo, movi√©ndome a lo largo de la X) de cada registro para asegurar que los datos se discreticen dentro del intervalo m√≠nimo / m√°ximo y mantenga la m√°xima precisi√≥n. </font><font style="vertical-align: inherit;">No creo que en general sea posible crear intervalos de muestreo globales sin destruir sus datos (cuando los valores est√°n fuera del intervalo) y sin cometer errores significativos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sea como fuere, aqu√≠ hay un breve resumen de mis est√∫pidos intentos de implementar la compresi√≥n de animaci√≥n: al final, casi uso la compresi√≥n.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491942/index.html">C√≥mo usamos item2vec para recomendar productos similares</a></li>
<li><a href="../es491944/index.html">C√≥mo combinar dos plataformas en una y no ofender a los usuarios. Yandex.Kew Developers Experience</a></li>
<li><a href="../es491946/index.html">Leyes de programaci√≥n</a></li>
<li><a href="../es491948/index.html">Los tokens de dise√±o pueden hacer m√°s: crear una √∫nica fuente de informaci√≥n sobre los componentes de la interfaz de usuario</a></li>
<li><a href="../es491956/index.html">Versi√≥n Rust 1.42.0: plantillas de corte y mensajes de p√°nico m√°s convenientes</a></li>
<li><a href="../es491960/index.html">Era cuando es dif√≠cil perderse</a></li>
<li><a href="../es491962/index.html">VPN asesino. Acceso remoto adecuado a servidores de batalla</a></li>
<li><a href="../es491964/index.html">Ejecuci√≥n remota de c√≥digo en SMB v3: CVE-2020-0796</a></li>
<li><a href="../es491974/index.html">Coronavirus: por qu√© necesitas actuar ahora</a></li>
<li><a href="../es491976/index.html">Convertimos la econom√≠a de UNIT para una tienda o producci√≥n en l√≠nea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>