<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 🏴󠁧󠁢󠁳󠁣󠁴󠁿 🖥️ なぜSQLではないのですか？ 🧒🏾 🥂 ❌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="誇張することなく、SQLは世界で最も一般的な言語の1つであると言えます。情報システムは、Java、Python、JavaScript、C＃、PHP、およびその他の数十の言語で記述できますが、SQLデータベースは、そのようなシステムの大部分に存在します。ビジネスアプリケーションの中で、SQLを使用する...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>なぜSQLではないのですか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lsfusion/blog/463095/"><img src="https://habrastorage.org/webt/s1/uz/ze/s1uzzeivaxmzx7jk-1osyp0xeyy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誇張することなく、SQLは世界で最も一般的な言語の1つであると言えます。</font><font style="vertical-align: inherit;">情報システムは、Java、Python、JavaScript、C＃、PHP、およびその他の数十の言語で記述できますが、SQLデータベースは、そのようなシステムの大部分に存在します。</font><font style="vertical-align: inherit;">ビジネスアプリケーションの中で、SQLを使用するシステムの割合は100％になる傾向があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、ハブ上のSQLやその他のリソースに関する既存の資料のほとんどは、「接続の種類」、「左の接続と右の接続の違い」、「トリガーとは」などの簡単な質問に分類されます。さらに、これらの資料では、SQLの問題（およびその実装）についてはほとんど何も言われていません。したがって、私たちはこれらのギャップの両方を埋めることに決めました。一方ではSQLでいくつ物が内部から機能するのか、もう一方では必要な/期待どおりに機能しない理由を伝えるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、記事は「フェルトペンの味と色」についてではありません。</font><font style="vertical-align: inherit;">関係するすべての問題は根本的なものです。それらはほとんどすべての情報システムの開発中に存在し、「コードの美しさ」に限定されるものではなく、ある程度、生産性の重大な低下、エントリしきい値の大幅な増加、または開発者側の大幅な人件費につながります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事はかなり膨大であることが判明し、誰もが一度にそれを習得できるわけではありません。</font><font style="vertical-align: inherit;">したがって、その中をナビゲートしやすくするため、および「災害の規模」を評価できるようにするために、対処するすべての問題のリストを含む目次から始めます。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー：ビューの具体化は、非常に特殊なケースでサポートされています。</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー：ビューでは、制約とトリガーはサポートされていません。</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">View:     FROM    </a><br>
</li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Join Predicate Push Down (JPPD)</a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">JPPD:        CTE</a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">JPPD:       </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">JPPD:     </a><br>
</li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">     JOIN  WHERE</a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  OR</a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">      </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">      </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> N+1</a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">     </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">       JOIN</a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> (AO)</a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">AO:     </a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">AO:      </a><br>
</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては、PostgreSQL、MS SQL Server、Oracleの3つのRDBMSでテストされます。</font><font style="vertical-align: inherit;">最新のDBMSはすべて、それぞれ11、2019、19cです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始める前に、商品、請負業者、および入庫と出荷のドキュメントを含むデータベースを作成します。</font><font style="vertical-align: inherit;">大量のデータでのクエリ/パフォーマンスの最適化の問題を示す例がさらに多くあるため、データと大量のデータを入力します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracleのデータベースフィルスクリプト</font></font></b><div class="spoiler_text"><pre><code class="sql">CREATE TABLE customer (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100)<font></font>
);<font></font>
<font></font>
CREATE TABLE stock (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100)<font></font>
);<font></font>
<font></font>
CREATE TABLE product (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100),<font></font>
    "group" INT<font></font>
);<font></font>
CREATE INDEX product_group ON product ("group");<font></font>
<font></font>
CREATE TABLE receipt (<font></font>
    id INT PRIMARY KEY,<font></font>
    customer INT NOT NULL,<font></font>
   	"date" DATE NOT NULL,<font></font>
    CONSTRAINT receipt_customer_fk<font></font>
        FOREIGN KEY (customer) REFERENCES customer (id),<font></font>
   	stock INT NOT NULL,<font></font>
    CONSTRAINT receipt_stock_fk<font></font>
        FOREIGN KEY (stock) REFERENCES stock (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX receipt_customer_fk ON receipt (customer);<font></font>
CREATE INDEX receipt_stock_fk ON receipt (stock);<font></font>
<font></font>
CREATE TABLE shipment (<font></font>
    id INT PRIMARY KEY,<font></font>
    customer INT NOT NULL,<font></font>
   	"date" DATE NOT NULL,<font></font>
    CONSTRAINT shipment_customer_fk<font></font>
        FOREIGN KEY (customer) REFERENCES customer (id),<font></font>
    stock INT NOT NULL,<font></font>
    CONSTRAINT shipment_stock_fk<font></font>
        FOREIGN KEY (stock) REFERENCES stock (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX shipment_customer_fk ON shipment (customer);<font></font>
CREATE INDEX shipment_stock_fk ON shipment (stock);<font></font>
CREATE TABLE receiptdetail (<font></font>
    id INT PRIMARY KEY,<font></font>
    receipt INT NOT NULL,<font></font>
	product INT NOT NULL,<font></font>
	quantity NUMERIC(16,3),<font></font>
    CONSTRAINT receiptdetail_receipt_fk<font></font>
        FOREIGN KEY (receipt) REFERENCES receipt (id),<font></font>
    CONSTRAINT receiptdetail_product_fk<font></font>
    	FOREIGN KEY (product) REFERENCES product (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX receiptdetail_receipt_fk ON receiptdetail (receipt);<font></font>
CREATE INDEX receiptdetail_product_fk ON receiptdetail (product);<font></font>
<font></font>
CREATE TABLE shipmentdetail (<font></font>
    id INT PRIMARY KEY,<font></font>
    shipment INT NOT NULL,<font></font>
	product INT NOT NULL,<font></font>
	quantity NUMERIC(16,3),<font></font>
    CONSTRAINT shipmentdetail_shipment_fk<font></font>
        FOREIGN KEY (shipment) REFERENCES shipment (id),<font></font>
    CONSTRAINT shipmentdetail_product_fk<font></font>
    	FOREIGN KEY (product) REFERENCES product (id),<font></font>
    sd INT,<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX shipmentdetail_shipment_fk ON shipmentdetail (shipment);<font></font>
CREATE INDEX shipmentdetail_product_fk ON shipmentdetail (product);<font></font>
CREATE INDEX shipmentdetail_sd ON shipmentdetail (sd);<font></font>
CREATE INDEX shipmentdetail_p_s ON shipmentdetail (product,shipment);<font></font>
<font></font>
INSERT INTO stock (id, name)<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10<font></font>
)<font></font>
SELECT n, 'Stock '||n FROM numbers;<font></font>
<font></font>
INSERT INTO customer (id, name)<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 1000<font></font>
)<font></font>
SELECT n, 'Customer '||n FROM numbers;<font></font>
<font></font>
INSERT INTO product (id, name, "group")<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 50000<font></font>
)<font></font>
SELECT n, 'Product '||n, round(dbms_random.value() * 1000) + 1 FROM numbers;<font></font>
<font></font>
INSERT INTO receipt (id, customer, stock, "date", data)<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10000<font></font>
)<font></font>
SELECT n, round(dbms_random.value() * 1000) + 1, round(dbms_random.value() * 10) + 1, CURRENT_DATE - round(dbms_random.value() * 300), 'data'||n FROM numbers;<font></font>
<font></font>
INSERT INTO receiptdetail (id, receipt, product, quantity, data)<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 1000000<font></font>
)<font></font>
SELECT n, round(dbms_random.value() * 10000) + 1, round(dbms_random.value() * 50000) + 1, round(dbms_random.value() * 100) + 1, 'data'||n FROM numbers;<font></font>
<font></font>
INSERT INTO shipment (id, customer, stock, "date", data)<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 100000<font></font>
)<font></font>
SELECT n, round(dbms_random.value() * 1000) + 1, round(dbms_random.value() * 10) + 1, CURRENT_DATE - round(dbms_random.value() * 300), 'data'||n FROM numbers;<font></font>
<font></font>
INSERT INTO shipmentdetail (id, shipment, product, quantity, data, sd)<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10000000<font></font>
)<font></font>
SELECT n, round(dbms_random.value() * 100000) + 1, round(dbms_random.value() * 50000) + 1, round(dbms_random.value() * 10) + 1, 'data'||n, CASE WHEN REMAINDER(n, 100000) = 0 THEN n+1 ELSE NULL END FROM numbers;<font></font>
<font></font>
exec DBMS_STATS.GATHER_DATABASE_STATS;<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSSQLのデータベース入力スクリプト</font></font></b><div class="spoiler_text"><pre><code class="sql">CREATE TABLE customer (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100)<font></font>
);<font></font>
<font></font>
CREATE TABLE stock (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100)<font></font>
);<font></font>
<font></font>
CREATE TABLE product (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100),<font></font>
    [group] INT<font></font>
);<font></font>
CREATE INDEX product_group ON product ([group]);<font></font>
<font></font>
CREATE TABLE receipt (<font></font>
    id INT PRIMARY KEY,<font></font>
    customer INT NOT NULL,<font></font>
	date DATE NOT NULL,<font></font>
    CONSTRAINT receipt_customer_fk<font></font>
        FOREIGN KEY (customer) REFERENCES customer (id),<font></font>
	stock INT NOT NULL,<font></font>
    CONSTRAINT receipt_stock_fk<font></font>
        FOREIGN KEY (stock) REFERENCES stock (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX receipt_date ON receipt (date);<font></font>
CREATE INDEX receipt_customer_fk ON receipt (customer);<font></font>
CREATE INDEX receipt_stock_fk ON receipt (stock);<font></font>
<font></font>
CREATE TABLE shipment (<font></font>
    id INT PRIMARY KEY,<font></font>
    customer INT NOT NULL,<font></font>
	date DATE NOT NULL,<font></font>
    CONSTRAINT shipment_customer_fk<font></font>
        FOREIGN KEY (customer) REFERENCES customer (id),<font></font>
	stock INT NOT NULL,<font></font>
    CONSTRAINT shipment_stock_fk<font></font>
        FOREIGN KEY (stock) REFERENCES stock (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX shipment_date ON shipment (date);<font></font>
CREATE INDEX shipment_customer_fk ON shipment (customer);<font></font>
CREATE INDEX shipment_stock_fk ON shipment (stock);<font></font>
CREATE TABLE receiptdetail (<font></font>
    id INT PRIMARY KEY,<font></font>
    receipt INT NOT NULL,<font></font>
	product INT NOT NULL,<font></font>
	quantity NUMERIC(16,3),<font></font>
    CONSTRAINT receiptdetail_receipt_fk<font></font>
        FOREIGN KEY (receipt) REFERENCES receipt (id),<font></font>
    CONSTRAINT receiptdetail_product_fk<font></font>
    	FOREIGN KEY (product) REFERENCES product (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX receiptdetail_receipt_fk ON receiptdetail (receipt);<font></font>
CREATE INDEX receiptdetail_product_fk ON receiptdetail (product);<font></font>
<font></font>
CREATE TABLE shipmentdetail (<font></font>
    id INT PRIMARY KEY,<font></font>
    shipment INT NOT NULL,<font></font>
	product INT NOT NULL,<font></font>
	quantity NUMERIC(16,3),<font></font>
    CONSTRAINT shipmentdetail_shipment_fk<font></font>
        FOREIGN KEY (shipment) REFERENCES shipment (id),<font></font>
    CONSTRAINT shipmentdetail_product_fk<font></font>
    	FOREIGN KEY (product) REFERENCES product (id),<font></font>
    sd INT,<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX shipmentdetail_shipment_fk ON shipmentdetail (shipment);<font></font>
CREATE INDEX shipmentdetail_product_fk ON shipmentdetail (product);<font></font>
CREATE INDEX shipmentdetail_sd ON shipmentdetail (sd);<font></font>
CREATE INDEX shipmentdetail_p_s ON shipmentdetail (product,shipment);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10<font></font>
)<font></font>
INSERT INTO stock (id, name)<font></font>
SELECT n, CONCAT('Stock ',n) FROM numbers option (maxrecursion 0);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 1000<font></font>
)<font></font>
INSERT INTO customer (id, name)<font></font>
SELECT n, CONCAT('Customer ',n) FROM numbers option (maxrecursion 0);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 50000<font></font>
)<font></font>
INSERT INTO product (id, name, [group])<font></font>
SELECT n, CONCAT('Product ',n),  ABS(checksum(NewId()))% 1000 + 1 FROM numbers option (maxrecursion 0);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10000<font></font>
)<font></font>
INSERT INTO receipt (id, customer, stock, date, data)<font></font>
SELECT n,  ABS(checksum(NewId()))% 1000 + 1, ABS(checksum(NewId()))% 10 + 1, DATEADD(day, -ABS(checksum(NewId()))% 300, GETDATE()), CONCAT('data',n) FROM numbers option (maxrecursion 0);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 1000000<font></font>
)<font></font>
INSERT INTO receiptdetail (id, receipt, product, quantity, data)<font></font>
SELECT n,  ABS(checksum(NewId()))% 10000 + 1,  ABS(checksum(NewId()))% 50000 + 1,  ABS(checksum(NewId()))% 100 + 1, CONCAT('data',n) FROM numbers option (maxrecursion 0);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 100000<font></font>
)<font></font>
INSERT INTO shipment (id, customer, stock, date, data)<font></font>
SELECT n,  ABS(checksum(NewId()))% 1000 + 1, ABS(checksum(NewId()))% 10 + 1, DATEADD(day, -ABS(checksum(NewId()))% 300, GETDATE()), CONCAT('data',n) FROM numbers option (maxrecursion 0);<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10000000<font></font>
)<font></font>
INSERT INTO shipmentdetail (id, shipment, product, quantity, data, sd)<font></font>
SELECT n,  ABS(checksum(NewId()))% 100000 + 1,  ABS(checksum(NewId()))% 50000 + 1,  ABS(checksum(NewId()))% 10 + 1, CONCAT('data',n), CASE WHEN n % 100000 = 0 THEN n+1 ELSE NULL END FROM numbers option (maxrecursion 0);<font></font>
<font></font>
EXEC sp_updatestats;   <font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLデータベースのfillスクリプト</font></font></b><div class="spoiler_text"><pre><code class="sql">CREATE TABLE customer (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100)<font></font>
);<font></font>
<font></font>
CREATE TABLE stock (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100)<font></font>
);<font></font>
<font></font>
CREATE TABLE product (<font></font>
    id INT PRIMARY KEY,<font></font>
    name VARCHAR(100),<font></font>
    "group" INT<font></font>
);<font></font>
CREATE INDEX product_group ON product ("group");<font></font>
<font></font>
CREATE TABLE receipt (<font></font>
    id INT PRIMARY KEY,<font></font>
    customer INT NOT NULL,<font></font>
	"date" DATE NOT NULL,<font></font>
    CONSTRAINT receipt_customer_fk<font></font>
        FOREIGN KEY (customer) REFERENCES customer (id),<font></font>
   	stock INT NOT NULL,<font></font>
    CONSTRAINT receipt_stock_fk<font></font>
        FOREIGN KEY (stock) REFERENCES stock (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX receipt_customer_fk ON receipt (customer);<font></font>
CREATE INDEX receipt_stock_fk ON receipt (stock);<font></font>
<font></font>
CREATE TABLE shipment (<font></font>
    id INT PRIMARY KEY,<font></font>
    customer INT NOT NULL,<font></font>
	"date" DATE NOT NULL,<font></font>
    CONSTRAINT shipment_customer_fk<font></font>
        FOREIGN KEY (customer) REFERENCES customer (id),<font></font>
    stock INT NOT NULL,<font></font>
    CONSTRAINT shipment_stock_fk<font></font>
        FOREIGN KEY (stock) REFERENCES stock (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX shipment_customer_fk ON shipment (customer);<font></font>
CREATE INDEX shipment_stock_fk ON shipment (stock);<font></font>
<font></font>
CREATE TABLE receiptdetail (<font></font>
    id INT PRIMARY KEY,<font></font>
    receipt INT NOT NULL,<font></font>
	product INT NOT NULL,<font></font>
	quantity NUMERIC(16,3),<font></font>
    CONSTRAINT receiptdetail_receipt_fk<font></font>
        FOREIGN KEY (receipt) REFERENCES receipt (id),<font></font>
    CONSTRAINT receiptdetail_product_fk<font></font>
    	FOREIGN KEY (product) REFERENCES product (id),<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX receiptdetail_receipt_fk ON receiptdetail (receipt);<font></font>
CREATE INDEX receiptdetail_product_fk ON receiptdetail (product);<font></font>
<font></font>
CREATE TABLE shipmentdetail (<font></font>
    id INT PRIMARY KEY,<font></font>
    shipment INT NOT NULL,<font></font>
	product INT NOT NULL,<font></font>
	quantity NUMERIC(16,3),<font></font>
    CONSTRAINT shipmentdetail_shipment_fk<font></font>
        FOREIGN KEY (shipment) REFERENCES shipment (id),<font></font>
    CONSTRAINT shipmentdetail_product_fk<font></font>
    	FOREIGN KEY (product) REFERENCES product (id),<font></font>
    sd INT,<font></font>
    data VARCHAR(400)<font></font>
);<font></font>
CREATE INDEX shipmentdetail_shipment_fk ON shipmentdetail (shipment);<font></font>
CREATE INDEX shipmentdetail_product_fk ON shipmentdetail (product);<font></font>
CREATE INDEX shipmentdetail_sd ON shipmentdetail (sd);<font></font>
CREATE INDEX shipmentdetail_p_s ON shipmentdetail (product,shipment);<font></font>
<font></font>
INSERT INTO stock (id, name)<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10<font></font>
)<font></font>
SELECT n, 'Stock '||n FROM numbers;<font></font>
<font></font>
INSERT INTO customer (id, name)<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 1000<font></font>
)<font></font>
SELECT n, 'Customer '||n FROM numbers;<font></font>
<font></font>
INSERT INTO product (id, name, "group")<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 50000<font></font>
)<font></font>
SELECT n, 'Product '||n, floor(random() * 1000) + 1 FROM numbers;<font></font>
<font></font>
INSERT INTO receipt (id, customer, stock, "date", data)<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10000<font></font>
)<font></font>
SELECT n, floor(random() * 1000) + 1, floor(random() * 10) + 1, CURRENT_DATE-CAST(floor(random() * 300) AS int), 'data'||n FROM numbers;<font></font>
<font></font>
INSERT INTO receiptdetail (id, receipt, product, quantity, data)<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 1000000<font></font>
)<font></font>
SELECT n, floor(random() * 10000) + 1, floor(random() * 50000) + 1, floor(random() * 100) + 1, 'data'||n FROM numbers;<font></font>
<font></font>
INSERT INTO shipment (id, customer, stock, "date", data)<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 100000<font></font>
)<font></font>
SELECT n, floor(random() * 1000) + 1, floor(random() * 10) + 1, CURRENT_DATE-CAST(floor(random() * 300) AS int), 'data'||n FROM numbers;<font></font>
<font></font>
INSERT INTO shipmentdetail (id, shipment, product, quantity, data, sd)<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt;= 10000000<font></font>
)<font></font>
SELECT n, floor(random() * 100000) + 1, floor(random() * 50000) + 1, floor(random() * 10) + 1, 'data'||n, CASE WHEN n % 100000 = 0 THEN n+1 ELSE NULL END FROM numbers;<font></font>
<font></font>
ANALYZE;<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストが実行された、すでに満たされたデータベース、およびそれらへの接続パラメーターは、次の場所にあります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle接続設定</font></font></b><div class="spoiler_text">Hostname:116.203.61.136<br>
Port:1521<br>
SID:orclcdb<br>
User/DB:test<br>
Password:test<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQL接続オプション</font></font></b><div class="spoiler_text">Hostname:195.201.126.177<br>
DB:test<br>
User:guest<br>
Password:Guest111<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL接続オプション</font></font></b><div class="spoiler_text">Hostname:159.69.8.94<br>
Port:5432<br>
DB:test<br>
User:guest<br>
Password:guest<br>
</div></div><br>
<a name="view"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、SQLはユーザーがシステムと直接対話するための一連のコマンドとして考えられていました。</font><font style="vertical-align: inherit;">このアイデアは非常に迅速かつ予測どおりに失敗し、その後SQLが開発ツールになりました。つまり、他の開発ツールと同様に、最初に抽象化の必要性が出てきました。</font><font style="vertical-align: inherit;">したがって、ビュー（ビュー）が生まれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビューを使用すると、SQLは機能宣言を実装から分離できます。</font><font style="vertical-align: inherit;">したがって、たとえば、開発者は残りのビューを作成できます。</font></font><br>
<br>
<pre><code class="sql">CREATE VIEW balance AS<font></font>
SELECT stock, product, SUM(quantity) AS quantity<font></font>
	FROM<font></font>
		(SELECT receipt.stock, product, quantity<font></font>
		FROM receiptDetail <font></font>
			JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
		UNION ALL <font></font>
		SELECT shipment.stock, product, -quantity<font></font>
			FROM shipmentDetail <font></font>
			JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
		) details<font></font>
	GROUP BY stock, product<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、このビューを通常のテーブルとして参照します。</font></font><br>
<br>
<pre><code class="sql">SELECT product.name, balance.stock, balance.quantity <font></font>
FROM product<font></font>
JOIN balance ON product.id = balance.product <font></font>
WHERE product.name = 'Product 8693'<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、残差を計算するロジックを変更する必要がある場合、残差の表現を変更するだけで簡単にこれを実行できます。その後、この表現を使用したすべてのクエリが新しい実装で機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造化プログラミングの場合と同様に、抽象化によりSQLには2つの非常に重要な機能が与えられました。</font><font style="vertical-align: inherit;">それは思われるでしょう-ここでそれは幸せですが、彼らが言うように、何かがうまくいかなかった。</font></font><br>
<br>
<a name="matview"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー：ビューの具体化は、非常に特殊なケースでサポートされています。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の残差の表現を実際のデータベースで使用し始めると、パフォーマンスの低下をすぐに発見する可能性があります。実際、残高は通常非常に頻繁に使用されるため、残高にアクセスするたびに残高を計算するのは非常にコストがかかります。したがって、これらのコストを回避するには、そのようなビューを「具体化」する、つまり、テーブルに保存し、このビューが使用するデータを変更するときに自動的に更新することが論理的です。これにより、記録速度が少し遅くなりますが、読み取り速度が大幅に向上します。それはもっと簡単かもしれません。しかし、問題は、そのような具体化をサポートすること、穏やかに言えば、見た目ほど簡単ではないことです。いずれにせよ、これが大きなボリュームで効率的に機能するためです。上記の残基の表現では、たとえば、ドキュメント内の倉庫を変更するときは、ドキュメント内のすべての商品について、古い倉庫内の残高からこのドキュメント内の数量を差し引き、この数量を新しい倉庫内の残高に追加する必要があります。また、ドキュメントのラインの数量を変更する場合は、新旧の数量の差を倉庫の残高に追加する必要があります。たとえば、残差のロジックに内部変位を追加すると、すべてが完全に混乱します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この点に関して、最新のDBMSで何ができるかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLでは、すべてがシンプルで、実体化された表現をサポートしていますが、特にトランザクションを適用するとすぐに実行される増分更新はサポートしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MS SQLには、段階的に更新できるいわゆるインデックス付きビュー（基本的には同じマテリアライズドビュー）がありますが、</font><font style="vertical-align: inherit;">そこに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある制限</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リスト</font></a><font style="vertical-align: inherit;">は印象的です。</font><font style="vertical-align: inherit;">実際には、SUM GROUP BYとINNER JOINのみがサポートされています。つまり、前述の基本的な例でさえ、MS SQLの残高では機能しません。</font><font style="vertical-align: inherit;">さらに、MS SQLでは他のビューを参照できないため、MS SQLでのビューの具体化はまったくサポートされていないと想定しても安全です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルは少しトリッキーです</font></font></b><div class="spoiler_text">      FAST REFRESH.<br>
<br>
  FAST REFRESH  Oracle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>     MS SQL,      :<br>
<br>
<ul>
<li>    GROUP BY   SUM    ( COUNT, AVERAGE)<br>
</li>
<li>   ,  ,      «» .<br>
</li>
<li>  ( )  GROUP BY, UNION ALL, OUTER JOIN   .<br>
</li>
<li> OUTER JOIN    -    (,  ,  )<br>
</li>
<li>  ,    SUM,    COUNT,         , UNION'        UNION ALL  ..<br>
</li>
</ul><br>
    ,      - ,           /  , , -,    ,  -,        .      ,       ,   ,  ,              : , , ,     .. ,           / ,         ,    .<br>
<br>
        ,   ,           ,       :        .<br>
<br>
 ,     :<br>
<br>
<pre><code class="sql">START TRANSACTION ;<font></font>
…<font></font>
UPDATE receiptDetail SET quantity = quantity + 1;<font></font>
...<font></font>
SELECT quantity FROM balance WHERE stock = 14 AND sku=65<font></font>
…<font></font>
COMMIT;<font></font>
</code></pre><br>
,   balance  ,     (    ),   ,      .  :<br>
<br>
<ul>
<li>    —   /            <br>
</li>
<li> ,           <br>
</li>
</ul></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Oracleでの具体化のサポートはMSSQLでのサポートよりも優れているように見えますが、それでも実行可能性にはほど遠いものです。したがって、ほとんどの開発者は、具体化されたアイデアについて尋ねられると、そのような機会を聞いたことがあるように見えますが、実際にはそれを使用したことはありません。一方、これらの同じ開発者に同じ残基の具体化の問題を解決する方法を尋ねると、トリガー、残基の一般的な変化点、間違った物理モデルなどについて何かが聞こえる可能性があります。そして、質問を明確にする上で-これらの一般的なポイントと物理モデルをどのように正確に整理するかをトリガーします。おそらく、「私は戦略家ではなく、戦術家です」、そして一般的には「医師、どこでそのような写真を撮るのか」という答えを聞きます。遭遇しませんでした。その人の中ではこれはISを開発しており、残高（まあ、借金や他の同様の指標）の保存と更新のタスクに直面したことがないので、どういうわけか私は本当に信じていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、具体化のタスクは通常、「なんとなく」正確に解決されます。</font><font style="vertical-align: inherit;">ロジック計算とビューの更新が重複しています。</font><font style="vertical-align: inherit;">一部の更新スクリプトは禁止されています（たとえば、ドキュメントの変更を完全に禁止します）。</font><font style="vertical-align: inherit;">それでも、「再実行」などのトリックを使用する場合があります。最初に古いデータ（ドキュメント全体など）の完全な削除をエミュレートし、次に新しいデータを追加します（つまり、ドキュメントを再度作成します）。</font><font style="vertical-align: inherit;">この場合、削除と追加のロジックのみを実装するだけで十分です。これは、はるかに単純ですが、生産性ははるかに低くなります（たとえば、ドキュメントの1行のみが変更される場合）。</font></font><br>
<br>
<a name="consview"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー：ビューでは、制約とトリガーはサポートされていません。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例のように残差の表現を作成し、それをさまざまな計算に使用するとします。ここで、新しいビジネス要件があり、残りは0より大きい必要があります。このデータがプライマリであり、テーブルに格納されている場合、簡単にこれを解決できます。目的のフィールドに適切な制限を作成することによる問題ですが、これはビューであり、プレゼンテーションの場合、既存の最新のDBMSは制限を作成する機能をサポートしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この点で一部の商用DBMS（MS SQLおよびOracle）が提供できる唯一のものは、ビューを具体化してそれに対する制限を作成することです。しかし、ここで再び実体化された表現の膨大な数の制限に戻ります。ただし、ここでは、トランザクションで実体化された表現を更新しないという問題は制限に関係しないことに注意してください。ただし、別の問題があります。制限はトランザクションの最後にチェックされます。つまり、システムのすべてのビジネスロジックが最初に実行され（これはかなりの量の作業になる可能性があります）、最終的にある種の制限に違反すると、実行されたすべての作業がキャンセルされ、リソースを意味しますサーバーとユーザーの時間が無駄になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、実体化された表現（および実体化された表現一般）に関する制限の主題は</font><font style="vertical-align: inherit;">、Oracle Donald Burlesonのかなり権威のある専門家の1人の著書</font><font style="vertical-align: inherit;">で詳細に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">議論さ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、一般的に、私は私と同じ結論に達しました：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、これは実用的な観点からは無意味です。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確かに、次の段落：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅かれ早かれ、増分更新の制限は解除されます。</font><font style="vertical-align: inherit;">この本でさらに制約を調べるために、すでに起こったように見せかけましょう。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この本は2005年に書かれ、現在は2019年になっており、過去14年間で制限のリストに変更はないことを考えると、非常に皮肉なことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、制限のために、具体化された表現を使用したこのような回避策が何らかの形で機能する場合は、トリガーを使用すると一般的におもしろいです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マテリアライズド・ビューの実表にトリガーを作成する場合、マテリアライズド・ビューのリフレッシュ中にトリガーが起動しないようにする必要があります。</font><font style="vertical-align: inherit;">リフレッシュ中、DBMS_MVIEWプロシージャI_AM_A_REFRESHはTRUEを返します。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、トリガーは作成できますが、実体化された表現では非常に予測できない動作をするため、トリガーでは何も実行できません。</font><font style="vertical-align: inherit;">このようなシュレディンガー猫は、トリガーのようですが、そうではありません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Ask Tomに関するこのトピックのもう少し詳細な説明を見つけることができます。</font></font><br>
<br>
<a name="paramview"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー：FROMでパラメーター化されたビューに渡すことができるのは定数のみです</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、残高だけでなく日付の残高も取得する必要があると想像してください。</font><font style="vertical-align: inherit;">「すべて」の日付（日付など）を含むテーブルがある場合、次のビューを作成できます。</font></font><br>
<br>
<pre><code class="sql">CREATE VIEW balance AS<font></font>
SELECT stock, product, dates.value AS date, SUM(quantity) AS quantity<font></font>
	FROM<font></font>
		(SELECT receipt.stock, product, receipt.date, quantity<font></font>
		FROM receiptDetail <font></font>
			JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
		UNION ALL <font></font>
		SELECT shipment.stock, product, shipment.date, -quantity<font></font>
			FROM shipmentDetail <font></font>
			JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
		) details<font></font>
		JOIN dates ON details.date &lt; dates.value<font></font>
	GROUP BY stock, product, dates.value<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このようなテーブルはSQLには存在しないため、この問題を解決するには、別のテーブルを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MS SQLのこのような問題を解決するために、いわゆるテーブルインライン関数があります。これらの関数では、パラメーターを宣言してクエリ内で使用できます。</font></font><br>
<br>
<pre><code class="sql">CREATE FUNCTION balance (<font></font>
    @date DATE<font></font>
)<font></font>
RETURNS TABLE<font></font>
AS<font></font>
RETURN<font></font>
SELECT stock, product, SUM(quantity) AS quantity<font></font>
	FROM<font></font>
		(SELECT receipt.stock, product, quantity<font></font>
		FROM receiptDetail <font></font>
			JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
			WHERE receipt.date &lt; @date<font></font>
		UNION ALL <font></font>
		SELECT shipment.stock, product, -quantity<font></font>
			FROM shipmentDetail <font></font>
			JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
			WHERE shipment.date &lt; @date<font></font>
		) details<font></font>
	GROUP BY stock, product<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、FROMでは、これらの関数に引数を渡すことができますが、ONではなく、括弧で渡すことができます。</font></font><br>
<br>
<pre><code class="sql">SELECT product.name, balance.stock, balance.quantity <font></font>
	FROM product <font></font>
	JOIN balance('07.07.2019') ON product.id = balance.product <font></font>
	WHERE product.name = 'Product 8693'<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外の場合、これらの関数は表現とまったく同じように動作します（多くの場合、これらはパラメーター化表現と呼ばれます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLでプリミティブ型のパラメーターを操作するには別の抽象化が必要であるという事実を無視しても、このメカニズムには1つの非常に不快な制限があり、その使用は非常に制限されます。</font><font style="vertical-align: inherit;">したがって、FROMで使用する場合、これらの関数をFROMから他のテーブルの列に引数として渡すことはできません。</font><font style="vertical-align: inherit;">つまり、次のクエリを実行しようとすると、</font></font><br>
<br>
<pre><code class="sql">SELECT shipmentDetail.id, b.quantity<font></font>
	FROM shipmentDetail <font></font>
	JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
	JOIN balance(shipment.date) b ON b.stock = shipment.stock AND b.product = shipmentDetail.product <font></font>
	WHERE shipmentDetail.quantity = 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLサーバーは、出荷テーブルが見つからなかったというエラーを出します。ここではもちろん、これが必要であると考えるかもしれません。パラメーター化された表現の引数でFROMからのテーブルを使用すると、JOINの自由な順列のイデオロギーに違反するためです（つまり、JOINは任意の順序で再配置できます。したがって、SQLでのそのような可能性は理論的には不可能です。しかし実際には、多くのSQLサーバーはサブクエリで既に結合されたテーブルのフィールドを使用できます（これについては、結合述語のプッシュダウンに関する次のセクションで説明します）。これにより、JOINを切り替えるときにオプションを削除するだけで、開発者はこれを実行できます。パラメータ化されたビュー（または一般に任意のサブクエリ）は、それが使用するフィールドを持つテーブルに結合されます。そして、単一のDBMSメーカーがこれを行わなかった理由正直に言うと、私にとって謎です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：聴衆からのヒントは、DBMSメーカーが特別なAPPLY構文（またはJOINのLATERALオプション）の形でこの機会をまだ実装しているというものです。</font><font style="vertical-align: inherit;">繰り返しになりますが、基本的に特定のケースを実装するために別の抽象化を使用する必要性を捨てたとしても、APPLYアプローチには2つの欠点があります（その1つは非常に重要です）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APPLYの問題</font></font></b><div class="spoiler_text"><ul>
<li>       ON,  OUTER APPLY    ( CROSS APPLY      WHERE):<br>
<pre><code class="sql">SELECT shipmentDetail.id, b.quantity<font></font>
	FROM shipmentDetail <font></font>
	JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
	OUTER APPLY (<font></font>
		SELECT quantity <font></font>
			FROM balance(shipment.date) <font></font>
			WHERE stock = shipment.stock AND product = shipmentDetail.product<font></font>
		) b<font></font>
	WHERE shipmentDetail.quantity = 5<font></font>
</code></pre><br>
</li>
<li>  , APPLY    —    nested loop join.  ,      ,    :<br>
<br>
<div class="spoiler"><b class="spoiler_title"> MS SQL</b><div class="spoiler_text"><pre>SELECT shipmentDetail.id, b.quantity   FROM shipmentDetail    JOIN shipment ON shipmentDetail.shipment = shipment.id   CROSS APPLY balance(shipment.date) b   WHERE shipmentDetail.quantity = 5 AND b.stock = shipment.stock AND b.product = shipmentDetail.product  OPTION (MAXDOP 1)<font></font>
  |--Filter(WHERE:([Union1013]=[test].[dbo].[shipment].[stock]))<font></font>
       |--Nested Loops(Inner Join, OUTER REFERENCES:([test].[dbo].[shipmentdetail].[product], [test].[dbo].[shipment].[date]))<font></font>
            |--Hash Match(Inner Join, HASH:([test].[dbo].[shipment].[id])=([test].[dbo].[shipmentdetail].[shipment]))<font></font>
            |    |--Clustered Index Scan(OBJECT:([test].[dbo].[shipment].[PK__shipment__3213E83F4B7B4D07]))<font></font>
            |    |--Clustered Index Scan(OBJECT:([test].[dbo].[shipmentdetail].[PK__shipment__3213E83F996CFFF4]), WHERE:([test].[dbo].[shipmentdetail].[quantity]=(5.000)))<font></font>
            |--Compute Scalar(DEFINE:([Expr1016]=CASE WHEN [Expr1023]=(0) THEN NULL ELSE [Expr1024] END))<font></font>
                 |--Stream Aggregate(GROUP BY:([Union1013]) DEFINE:([Expr1023]=COUNT_BIG([Union1015]), [Expr1024]=SUM([Union1015])))<font></font>
                      |--Sort(ORDER BY:([Union1013] ASC))<font></font>
                           |--Concatenation<font></font>
                                |--Nested Loops(Inner Join, OUTER REFERENCES:([test].[dbo].[receiptdetail].[receipt]))<font></font>
                                |    |--Index Spool(SEEK:([test].[dbo].[receiptdetail].[product]=[test].[dbo].[shipmentdetail].[product]))<font></font>
                                |    |    |--Clustered Index Scan(OBJECT:([test].[dbo].[receiptdetail].[PK__receiptd__3213E83FE8063B8C]))<font></font>
                                |    |--Clustered Index Seek(OBJECT:([test].[dbo].[receipt].[PK__receipt__3213E83FE2F580DF]), SEEK:([test].[dbo].[receipt].[id]=[test].[dbo].[receiptdetail].[receipt]),  WHERE:([test].[dbo].[receipt].[date]&lt;[test].[dbo].[shipment].[date]) ORDERED FORWARD)<font></font>
                                |--Nested Loops(Inner Join, OUTER REFERENCES:([test].[dbo].[shipmentdetail].[shipment], [Expr1022]) WITH UNORDERED PREFETCH)<font></font>
                                     |--Index Spool(SEEK:([test].[dbo].[shipmentdetail].[product]=[test].[dbo].[shipmentdetail].[product]))<font></font>
                                     |    |--Compute Scalar(DEFINE:([Expr1012]= -[test].[dbo].[shipmentdetail].[quantity]))<font></font>
                                     |         |--Clustered Index Scan(OBJECT:([test].[dbo].[shipmentdetail].[PK__shipment__3213E83F996CFFF4]))<font></font>
                                     |--Clustered Index Seek(OBJECT:([test].[dbo].[shipment].[PK__shipment__3213E83F4B7B4D07]), SEEK:([test].[dbo].[shipment].[id]=[test].[dbo].[shipmentdetail].[shipment]),  WHERE:([test].[dbo].[shipment].[date]&lt;[test].[dbo].[shipment].[date]) ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"> Oracle</b><div class="spoiler_text"><pre>---------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation               | Name            | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |<font></font>
---------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT        |                 |   637K|    44M|       |    26G  (1)|288:02:33 |<font></font>
|   1 |  NESTED LOOPS           |                 |   637K|    44M|       |    26G  (1)|288:02:33 |<font></font>
|*  2 |   HASH JOIN             |                 |   901K|    30M|  2736K| 15542   (1)| 00:00:01 |<font></font>
|   3 |    TABLE ACCESS FULL    | SHIPMENT        |   100K|  1562K|       |   137   (1)| 00:00:01 |<font></font>
|*  4 |    TABLE ACCESS FULL    | SHIPMENTDETAIL  |   909K|    16M|       | 13935   (1)| 00:00:01 |<font></font>
|*  5 |   VIEW                  | VW_LAT_F55B5580 |     1 |    39 |       | 29439   (1)| 00:00:02 |<font></font>
|   6 |    SORT GROUP BY        |                 |   393K|  8061K|   167M| 29439   (1)| 00:00:02 |<font></font>
|   7 |     VIEW                |                 |  5457K|   109M|       | 15337   (1)| 00:00:01 |<font></font>
|   8 |      UNION-ALL          |                 |       |       |       |            |          |<font></font>
|*  9 |       HASH JOIN         |                 |   498K|    13M|       |  1252   (1)| 00:00:01 |<font></font>
|* 10 |        TABLE ACCESS FULL| RECEIPT         |  4984 | 74760 |       |    15   (0)| 00:00:01 |<font></font>
|  11 |        TABLE ACCESS FULL| RECEIPTDETAIL   |  1000K|    12M|       |  1234   (1)| 00:00:01 |<font></font>
|* 12 |       HASH JOIN         |                 |  4959K|   137M|       | 14085   (1)| 00:00:01 |<font></font>
|* 13 |        TABLE ACCESS FULL| SHIPMENT        | 50001 |   781K|       |   137   (1)| 00:00:01 |<font></font>
|  14 |        TABLE ACCESS FULL| SHIPMENTDETAIL  |    10M|   123M|       | 13921   (1)| 00:00:01 |<font></font>
---------------------------------------------------------------------------------------------------<font></font>
 <font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   2 - access("SHIPMENTDETAIL"."SHIPMENT"="SHIPMENT"."ID")<font></font>
   4 - filter("SHIPMENTDETAIL"."QUANTITY"=5)<font></font>
   5 - filter("B"."STOCK"="SHIPMENT"."STOCK" AND "B"."PRODUCT"="SHIPMENTDETAIL"."PRODUCT")<font></font>
   9 - access("RECEIPTDETAIL"."RECEIPT"="RECEIPT"."ID")<font></font>
  10 - filter("RECEIPT"."date"&lt;"SHIPMENT"."date")<font></font>
  12 - access("SHIPMENTDETAIL"."SHIPMENT"="SHIPMENT"."ID")<font></font>
  13 - filter("SHIPMENT"."date"&lt;"SHIPMENT"."date")<font></font>
</pre><br>
</div></div><br>
     shipmentDetail  quantity &gt; 5     ,    .            estimate .</li>
</ul></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、事実は残っており、そのような場合の開発者にとっての唯一の方法は、トップコンテキストを個別にビューにプッシュダウンすることです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問い合わせ</font></font></b><div class="spoiler_text"><pre><code class="sql">SELECT shipmentDetail.id, b.quantity<font></font>
	FROM shipmentDetail <font></font>
	JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
	JOIN (SELECT stock, product, dates.date, SUM(quantity) AS quantity<font></font>
		FROM<font></font>
			(SELECT receipt.stock, product, receipt.date, quantity<font></font>
			FROM receiptDetail <font></font>
				JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
			UNION ALL <font></font>
			SELECT shipment.stock, product, shipment.date, -quantity<font></font>
				FROM shipmentDetail <font></font>
				JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
			) details<font></font>
		JOIN <font></font>
			(SELECT shipment.date<font></font>
				FROM shipmentDetail <font></font>
				JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
				WHERE shipmentDetail.quantity = 5<font></font>
				GROUP BY shipment.date<font></font>
			) dates ON details.date &lt; dates.date<font></font>
		GROUP BY stock, product, dates.date<font></font>
	) b ON b.stock = shipment.stock AND b.product = shipmentDetail.product AND b.date = shipment.date<font></font>
	WHERE shipmentDetail.quantity = 5<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、さまざまなクエリでこの表現を計算するロジックを繰り返し繰り返すことにより、プログラミングの重要な原則の1つに違反します-繰り返してはいけません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表現に関する上記のすべてを要約すると、ビューはテーブルのように見えますが、実際には、テーブルが実行できることの4分の1も実行できないため、残念ながら、SQLで最も基本的な抽象化レベルしか提供できません（またはむしろ、上記のすべての機能が一般的なケースでサポートされていた場合に比べて非常に低い）</font></font><br>
<br>
<a name="jppd"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">述語プッシュダウンに参加（JPPD）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語をサブクエリにプッシュすることは、SQL Serverオプティマイザの最も重要な機能の1つです。</font><font style="vertical-align: inherit;">このメカニズムにより、データベース内のすべてのデータではなく（したがって、パフォーマンスの壊滅的な低下を招く可能性がある）サブクエリの結果を計算できますが、最上位のクエリで必要なデータについてのみ計算できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このメカニズムが最新のDBMSでどのように機能するか</font></font></b><div class="spoiler_text">   ,     ,           (    predicate push down,  join):<br>
<br>
<pre><code class="sql">SELECT balance.quantity<font></font>
	FROM (SELECT product, SUM(quantity) AS quantity<font></font>
		FROM<font></font>
			(SELECT product, quantity<font></font>
			FROM receiptDetail <font></font>
				JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
			UNION ALL <font></font>
			SELECT product, -quantity<font></font>
				FROM shipmentDetail <font></font>
				JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
			) details<font></font>
		GROUP BY product<font></font>
	) balance<font></font>
	WHERE balance.product = 345<font></font>
</code></pre><br>
   SQL  ,      ,   product     345,      . ,          product, SQL       BY (      ),     BY   ,    GROUP BY .    :<br>
<br>
<pre><code class="sql">SELECT balance.quantity<font></font>
	FROM (SELECT SUM(quantity) AS quantity<font></font>
		FROM<font></font>
			(SELECT product, quantity<font></font>
			FROM receiptDetail <font></font>
				JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
			UNION ALL <font></font>
			SELECT product, -quantity<font></font>
				FROM shipmentDetail <font></font>
				JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
			) details<font></font>
			WHERE details.product = 345<font></font>
	) balance<font></font>
</code></pre><br>
 SQL       UNION          UNION:<br>
<br>
<pre><code class="sql">SELECT balance.quantity<font></font>
	FROM (SELECT SUM(quantity) AS quantity<font></font>
		FROM<font></font>
			(SELECT product, quantity<font></font>
			FROM receiptDetail <font></font>
				JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
				WHERE product = 345<font></font>
			UNION ALL <font></font>
			SELECT product, -quantity<font></font>
				FROM shipmentDetail <font></font>
				JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
				WHERE product = 345<font></font>
			) details<font></font>
	) balance<font></font>
</code></pre><br>
      product  shipmentDetail   receiptDetail      .<br>
<br>
    :<br>
<br>
<pre><code class="sql">SELECT balance.quantity<font></font>
	FROM product<font></font>
	JOIN<font></font>
		(SELECT product, SUM(quantity) AS quantity<font></font>
			FROM<font></font>
				(SELECT product, quantity<font></font>
				FROM receiptDetail <font></font>
					JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
				UNION ALL <font></font>
				SELECT product, -quantity<font></font>
					FROM shipmentDetail <font></font>
					JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
				) details<font></font>
			GROUP BY product<font></font>
		) balance ON balance.product = product.id<font></font>
	WHERE product.group = 54<font></font>
</code></pre><br>
       SQL      join.    ,   join'  product            group (,   ).        balance,    nested loop join (      ,    —  product,    group).    SQL  ,      balance.product = product.id,  product.id — ,  , --    ,       predicate push,     . <br>
<br>
<div class="spoiler"><b class="spoiler_title"> MSSQL</b><div class="spoiler_text">  : 128<br>
<pre>Rows	Executes  Stmt Text<font></font>
41	1	  |--Nested Loops(Inner Join, OUTER REFERENCES:([test].[dbo].[product].[id]))<font></font>
41	1	       |--Index Seek(OBJECT:([test].[dbo].[product].[product_group]), SEEK:([test].[dbo].[product].[group]=(54)) ORDERED FORWARD)<font></font>
0	0	       |--Compute Scalar(DEFINE:([Expr1013]=CASE WHEN [globalagg1020]=(0) THEN NULL ELSE [globalagg1022] END))<font></font>
41	41	            |--Stream Aggregate(DEFINE:([globalagg1020]=SUM([partialagg1019]), [globalagg1022]=SUM([partialagg1021])))<font></font>
82	41	                 |--Concatenation<font></font>
41	41	                      |--Stream Aggregate(DEFINE:([partialagg1019]=COUNT_BIG([test].[dbo].[receiptdetail].[quantity]), [partialagg1021]=SUM([test].[dbo].[receiptdetail].[quantity])))<font></font>
809	41	                      |    |--Nested Loops(Inner Join, OUTER REFERENCES:([test].[dbo].[receiptdetail].[id]))<font></font>
809	41	                      |         |--Index Seek(OBJECT:([test].[dbo].[receiptdetail].[receiptdetail_product_fk]), SEEK:([test].[dbo].[receiptdetail].[product]=[test].[dbo].[product].[id]) ORDERED FORWARD)<font></font>
809	809	                      |         |--Clustered Index Seek(OBJECT:([test].[dbo].[receiptdetail].[PK__receiptd__3213E83F930DCBDA]), SEEK:([test].[dbo].[receiptdetail].[id]=[test].[dbo].[receiptdetail].[id]) LOOKUP ORDERED FORWARD)<font></font>
41	41	                      |--Stream Aggregate(DEFINE:([partialagg1019]=COUNT_BIG([Expr1010]), [partialagg1021]=SUM([Expr1010])))<font></font>
0	0	                           |--Compute Scalar(DEFINE:([Expr1010]= -[test].[dbo].[shipmentdetail].[quantity]))<font></font>
8383	41	                                |--Nested Loops(Inner Join, OUTER REFERENCES:([test].[dbo].[shipmentdetail].[id], [Expr1023]) WITH UNORDERED PREFETCH)<font></font>
8383	41	                                     |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_product_fk]), SEEK:([test].[dbo].[shipmentdetail].[product]=[test].[dbo].[product].[id]) ORDERED FORWARD)<font></font>
8383	8383	                                     |--Clustered Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[PK__shipment__3213E83F2FF9E454]), SEEK:([test].[dbo].[shipmentdetail].[id]=[test].[dbo].[shipmentdetail].[id]) LOOKUP ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"> Oracle</b><div class="spoiler_text">  : 80<br>
<pre>-----------------------------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                                 | Name                      | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
-----------------------------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT                          |                           |       |       | 11247 (100)|          |<font></font>
|   1 |  NESTED LOOPS                             |                           |    50 |  1100 | 11247   (1)| 00:00:01 |<font></font>
|   2 |   TABLE ACCESS BY INDEX ROWID BATCHED     | PRODUCT                   |    50 |   450 |    45   (0)| 00:00:01 |<font></font>
|*  3 |    INDEX RANGE SCAN                       | PRODUCT_GROUP             |    50 |       |     1   (0)| 00:00:01 |<font></font>
|   4 |   VIEW PUSHED PREDICATE                   |                           |     1 |    13 |   224   (0)| 00:00:01 |<font></font>
|*  5 |    FILTER                                 |                           |       |       |            |          |<font></font>
|   6 |     SORT AGGREGATE                        |                           |     1 |    26 |            |          |<font></font>
|   7 |      VIEW                                 |                           |   218 |  5668 |   224   (0)| 00:00:01 |<font></font>
|   8 |       UNION-ALL                           |                           |       |       |            |          |<font></font>
|   9 |        TABLE ACCESS BY INDEX ROWID BATCHED| RECEIPTDETAIL             |    20 |   180 |    23   (0)| 00:00:01 |<font></font>
|* 10 |         INDEX RANGE SCAN                  | RECEIPTDETAIL_PRODUCT_FK  |    20 |       |     3   (0)| 00:00:01 |<font></font>
|  11 |        TABLE ACCESS BY INDEX ROWID BATCHED| SHIPMENTDETAIL            |   198 |  1584 |   201   (0)| 00:00:01 |<font></font>
|* 12 |         INDEX RANGE SCAN                  | SHIPMENTDETAIL_PRODUCT_FK |   198 |       |     3   (0)| 00:00:01 |<font></font>
-----------------------------------------------------------------------------------------------------------------------<font></font>
<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   3 - access("PRODUCT"."group"=54)<font></font>
   5 - filter(COUNT(*)&gt;0)<font></font>
  10 - access("RECEIPTDETAIL"."PRODUCT"="PRODUCT"."ID")<font></font>
  12 - access("SHIPMENTDETAIL"."PRODUCT"="PRODUCT"."ID")<font></font>
</pre><br>
</div></div><br>
   balance       54,        (,  ,        ,      54). <br>
<br>
, ,  ,   JPPD     nested loop join,    , SQL     hash join.       balance.product = ,  «»  hash(balance.product) =  («»,          SQL,        ).<br>
<br>
   JPPD  ,  «»  —   . ,      :<br>
<br>
<pre><code class="sql">SELECT balance.quantity<font></font>
	FROM product<font></font>
	JOIN<font></font>
		(SELECT SUM(quantity) AS quantity<font></font>
			FROM<font></font>
				(SELECT quantity<font></font>
				FROM receiptDetail <font></font>
					JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
					WHERE receiptDetail.product = product.id<font></font>
				UNION ALL <font></font>
				SELECT -quantity<font></font>
					FROM shipmentDetail <font></font>
					JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
					WHERE shipmentDetail.product = product.id<font></font>
				) details<font></font>
		) balance ON TRUE<font></font>
	WHERE product.group = 54<font></font>
</code></pre><br>
     (  )  JPPD   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> Oracle. ,   ,     ,      SQL  (   Oracle)         (  ,  ,       ,     ),  , ,    JPPD,     .<br>
<br>
 ,  ,  SQL        .   ,      predicate push down,     ,                .        ,    .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JPPDエンジンは、上記のプレゼンテーションエンジンにとって特に重要です。</font><font style="vertical-align: inherit;">また、JPPDが存在しない場合、アクセスするたびにデータベース全体（！）のビューが計算されるため、表示メカニズムもほとんど意味がありません。つまり、ビューのパフォーマンスはひどいものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、DBMSのJPPDメカニズムは比較的単純に実装されていますが、この単純さには欠点もあります。</font></font><br>
<br>
<a name="windowjppd"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPPD：ウィンドウ関数および再帰CTEでは機能しません</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントの行番号を取得して、次のクエリを作成するとします。</font></font><br>
<br>
<pre><code class="sql">SELECT id, seqnum<font></font>
	FROM <font></font>
		(SELECT id, row_number() OVER (PARTITION BY shipment ORDER BY id) AS seqnum<font></font>
			FROM shipmentdetail<font></font>
		) t<font></font>
	WHERE t.id=6770436<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 1.2<br>
<pre>Rows	Executes  Stmt Text<font></font>
1	1	  |--Filter(WHERE:([test].[dbo].[shipmentdetail].[id]=(6770436)))<font></font>
10000001	1	       |--Window Aggregate(DEFINE:([Expr1002]=row_number), PARTITION COLUMNS:([test].[dbo].[shipmentdetail].[shipment]), ROWS BETWEEN:(UNBOUNDED, CURRENT ROW))<font></font>
10000001	1	            |--Index Scan(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_shipment_fk]), ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 14<br>
<pre>----------------------------------------------------------------------------------------------<font></font>
| Id  | Operation           | Name           | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |<font></font>
----------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT    |                |       |       |       | 57555 (100)|          |<font></font>
|*  1 |  VIEW               |                |    10M|   247M|       | 57555   (1)| 00:00:03 |<font></font>
|   2 |   WINDOW SORT       |                |    10M|   104M|   191M| 57555   (1)| 00:00:03 |<font></font>
|   3 |    TABLE ACCESS FULL| SHIPMENTDETAIL |    10M|   104M|       | 13841   (1)| 00:00:01 |<font></font>
----------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   1 - filter("T"."ID"=6770436)<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プランからわかるように、SQLサーバーはデータベース内のすべてのドキュメントの行番号を計算し、その結果、クエリは（数ミリ秒ではなく）1秒間実行されます。</font></font><br>
<br>
<a name="denormjppd"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPPD：非正規化データでのパフォーマンスの低下</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顧客に出荷された合計量と一緒に日付から日付までのすべての出荷を取得したいとします（少し遠く離れたケースでは、たとえば顧客の負債の額について話す方がより正確ですが、基本的な例は非常に簡単ですが、それ以上に進みたくありません。したがって、次のものを使用します）：</font></font><br>
<br>
<pre><code class="sql">SELECT shipment.id, supplied.quantity<font></font>
	FROM shipment<font></font>
	JOIN (<font></font>
		SELECT customer, SUM(quantity) AS quantity<font></font>
			FROM shipmentDetail<font></font>
			JOIN shipment ON shipment.id = shipmentDetail.shipment<font></font>
			GROUP BY customer<font></font>
	) supplied ON supplied.customer = shipment.customer<font></font>
	WHERE shipment.date = DATEADD(day, -10, CAST(GETDATE() AS date))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、SQLサーバーは、これらの日付の出荷があったすべての異なる顧客の金額を計算するのではなく、これらの日付のすべての出荷の金額を計算します。つまり、各クライアントの金額を数回計算できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、この問題は主に、選択条件と接続条件の間に（つまり、この例では、出荷日とクライアントの間に）相関があるときに現れます。</font><font style="vertical-align: inherit;">実際には、これは非常に頻繁に発生します（たとえば、特定の期間中にのみ多くのクライアントに出荷が行われます）が、特にこの記事のテストベースでは、均等に分散されたデータを生成したため、残念ながら、このベースで説明されている問題を実証することはできません。</font></font><br>
<br>
<a name="commjppd"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPPD：商用DBMSでのみサポート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JPPDは実装が簡単ですが、PostgreSQLではサポートされていません。</font><font style="vertical-align: inherit;">最も原始的な場合でも：</font></font><br>
<br>
<pre><code class="sql">SELECT income.quantity<font></font>
	FROM product<font></font>
	JOIN<font></font>
		(SELECT product, SUM(quantity) AS quantity<font></font>
			FROM shipmentDetail <font></font>
			JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
			GROUP BY product<font></font>
		) income ON income.product = product.id<font></font>
	WHERE product."group" = 54<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Hash Join  (cost=252901.05..254168.34 rows=49 width=32) (actual time=11580.152..11607.399 rows=48 loops=1)"<font></font>
"  Hash Cond: (shipmentdetail.product = product.id)"<font></font>
"  -&gt;  HashAggregate  (cost=252763.56..253394.04 rows=50439 width=36) (actual time=11579.912..11603.696 rows=50000 loops=1)"<font></font>
"        Group Key: shipmentdetail.product"<font></font>
"        -&gt;  Hash Join  (cost=2985.02..202764.28 rows=9999855 width=9) (actual time=46.117..5967.219 rows=10000001 loops=1)"<font></font>
"              Hash Cond: (shipmentdetail.shipment = shipment.id)"<font></font>
"              -&gt;  Seq Scan on shipmentdetail  (cost=0.00..173528.55 rows=9999855 width=13) (actual time=0.017..1158.157 rows=10000001 loops=1)"<font></font>
"              -&gt;  Hash  (cost=1735.01..1735.01 rows=100001 width=4) (actual time=45.798..45.798 rows=100001 loops=1)"<font></font>
"                    Buckets: 131072  Batches: 1  Memory Usage: 4540kB"<font></font>
"                    -&gt;  Seq Scan on shipment  (cost=0.00..1735.01 rows=100001 width=4) (actual time=0.018..19.940 rows=100001 loops=1)"<font></font>
"  -&gt;  Hash  (cost=136.88..136.88 rows=49 width=4) (actual time=0.202..0.202 rows=48 loops=1)"<font></font>
"        Buckets: 1024  Batches: 1  Memory Usage: 10kB"<font></font>
"        -&gt;  Bitmap Heap Scan on product  (cost=4.67..136.88 rows=49 width=4) (actual time=0.045..0.181 rows=48 loops=1)"<font></font>
"              Recheck Cond: ("group" = 54)"<font></font>
"              Heap Blocks: exact=46"<font></font>
"              -&gt;  Bitmap Index Scan on product_group  (cost=0.00..4.66 rows=49 width=0) (actual time=0.025..0.025 rows=48 loops=1)"<font></font>
"                    Index Cond: ("group" = 54)"<font></font>
"Planning Time: 0.658 ms"<font></font>
"Execution Time: 11608.602 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそれが起こったのか、そしてなぜPostgreSQL開発者は何かで忙しいのですが、問題の解決策ではありません。同じ理由で、同じビューを使用すること、正直に言うと、私にとって謎です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく問題はJPPD特許にあり、Oracleは2028年まで存続します（彼らは常にそれを更新し、小さな変更を加えています）。</font><font style="vertical-align: inherit;">ただし、上記で見たように、マイクロソフトはそのような特許の存在を妨害しません。</font></font><br>
<br>
<a name="jppdgen"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧のように、説明されているJPPDの問題はすべて、致命的ではありませんが、非常に不快です。</font><font style="vertical-align: inherit;">より一般的なJPPDメカニズムを使用してそれらを解決できます。外部クエリから述語を収集し、結合条件でグループ化し、サブクエリ内でJOINを使用して結果のクエリを追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、たとえば、ウィンドウ関数による書き換えられたリクエストは次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問い合わせ</font></font></b><div class="spoiler_text"><pre><code class="sql">SELECT id, seqnum<font></font>
	FROM <font></font>
		(SELECT id, row_number() OVER (PARTITION BY shipment ORDER BY id) AS seqnum<font></font>
			FROM shipmentdetail<font></font>
			JOIN <font></font>
				(SELECT t.shipment AS ps<font></font>
					FROM shipmentdetail t <font></font>
					WHERE t.id = 6770436<font></font>
			) pushed ON pushed.ps = shipment<font></font>
		) t<font></font>
	WHERE t.id=6770436<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 60<br>
<pre>Rows	Executes  Stmt Text<font></font>
1	1	  |--Filter(WHERE:([test].[dbo].[shipmentdetail].[id]=(6770436)))<font></font>
97	1	       |--Sequence Project(DEFINE:([Expr1003]=row_number))<font></font>
97	1	            |--Segment<font></font>
97	1	                 |--Nested Loops(Inner Join, OUTER REFERENCES:([t].[shipment]))<font></font>
1	1	                      |--Clustered Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[PK__shipment__3213E83F2FF9E454] AS [t]), SEEK:([t].[id]=(6770436)) ORDERED FORWARD)<font></font>
97	1	                      |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_shipment_fk]), SEEK:([test].[dbo].[shipmentdetail].[shipment]=[test].[dbo].[shipmentdetail].[shipment] as [t].[shipment]) ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 30<br>
<pre>---------------------------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                              | Name                       | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
---------------------------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT                       |                            |       |       |   106 (100)|          |<font></font>
|*  1 |  VIEW                                  |                            |    99 |  2574 |   106   (1)| 00:00:01 |<font></font>
|   2 |   WINDOW SORT                          |                            |    99 |  2178 |   106   (1)| 00:00:01 |<font></font>
|   3 |    NESTED LOOPS                        |                            |    99 |  2178 |   105   (0)| 00:00:01 |<font></font>
|   4 |     TABLE ACCESS BY INDEX ROWID        | SHIPMENTDETAIL             |     1 |    11 |     3   (0)| 00:00:01 |<font></font>
|*  5 |      INDEX UNIQUE SCAN                 | SYS_C007881                |     1 |       |     2   (0)| 00:00:01 |<font></font>
|   6 |     TABLE ACCESS BY INDEX ROWID BATCHED| SHIPMENTDETAIL             |    99 |  1089 |   102   (0)| 00:00:01 |<font></font>
|*  7 |      INDEX RANGE SCAN                  | SHIPMENTDETAIL_SHIPMENT_FK |    99 |       |     2   (0)| 00:00:01 |<font></font>
---------------------------------------------------------------------------------------------------------------------<font></font>
</pre><br>
 <br>
Predicate Information (identified by operation id):<br>
 —  <br>
 1 — filter(«T».«ID»=6770436)<br>
 5 — access(«T».«ID»=6770436)<br>
 7 — access(«T».«SHIPMENT»=«SHIPMENT»)<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Subquery Scan on t  (cost=400.40..403.62 rows=1 width=12) (actual time=0.810..0.891 rows=1 loops=1)"<font></font>
"  Filter: (t.id = 6770436)"<font></font>
"  Rows Removed by Filter: 105"<font></font>
"  -&gt;  WindowAgg  (cost=400.40..402.38 rows=99 width=16) (actual time=0.688..0.869 rows=106 loops=1)"<font></font>
"        -&gt;  Sort  (cost=400.40..400.65 rows=99 width=8) (actual time=0.651..0.668 rows=106 loops=1)"<font></font>
"              Sort Key: shipmentdetail.shipment, shipmentdetail.id"<font></font>
"              Sort Method: quicksort  Memory: 29kB"<font></font>
"              -&gt;  Nested Loop  (cost=5.63..397.12 rows=99 width=8) (actual time=0.094..0.593 rows=106 loops=1)"<font></font>
"                    -&gt;  Index Scan using shipmentdetail_pkey on shipmentdetail t_1  (cost=0.43..8.45 rows=1 width=4) (actual time=0.021..0.023 rows=1 loops=1)"<font></font>
"                          Index Cond: (id = 6770436)"<font></font>
"                    -&gt;  Bitmap Heap Scan on shipmentdetail  (cost=5.19..387.69 rows=98 width=8) (actual time=0.065..0.520 rows=106 loops=1)"<font></font>
"                          Recheck Cond: (shipment = t_1.shipment)"<font></font>
"                          Heap Blocks: exact=106"<font></font>
"                          -&gt;  Bitmap Index Scan on shipmentdetail_shipment_fk  (cost=0.00..5.17 rows=98 width=0) (actual time=0.029..0.029 rows=106 loops=1)"<font></font>
"                                Index Cond: (shipment = t_1.shipment)"<font></font>
"Planning Time: 0.671 ms"<font></font>
"Execution Time: 0.984 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非正規化されたデータを操作するための書き換えられたリクエスト：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問い合わせ</font></font></b><div class="spoiler_text"><pre><code class="sql">SELECT shipment.id, supplied.quantity<font></font>
	FROM shipment<font></font>
	JOIN (<font></font>
		SELECT customer, SUM(quantity) AS quantity<font></font>
			FROM shipmentDetail<font></font>
			JOIN shipment ON shipment.id = shipmentDetail.shipment<font></font>
			JOIN (<font></font>
				SELECT customer AS pcust<font></font>
					FROM shipment<font></font>
					WHERE shipment.date = DATEADD(day, -10, CAST(GETDATE() AS date))<font></font>
					GROUP BY customer<font></font>
			) pushcust ON pushcust.pcust = customer<font></font>
			GROUP BY customer<font></font>
	) supplied ON supplied.customer = shipment.customer<font></font>
	WHERE shipment.date = DATEADD(day, -10, CAST(GETDATE() AS date))<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、この手法はPostgreSQLでクエリを最適化するために使用できます。</font><font style="vertical-align: inherit;">したがって、JPPD記述の例は、次のように書き換えることができます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問い合わせ</font></font></b><div class="spoiler_text"><pre><code class="sql">SELECT balance.quantity<font></font>
	FROM product<font></font>
	JOIN<font></font>
		(SELECT product, SUM(quantity) AS quantity<font></font>
			FROM<font></font>
				(SELECT product, quantity<font></font>
				FROM receiptDetail <font></font>
					JOIN receipt ON receiptDetail.receipt = receipt.id<font></font>
					JOIN product ON product.id = receiptDetail.product<font></font>
					WHERE product.group = 54<font></font>
				UNION ALL <font></font>
				SELECT product, -quantity<font></font>
					FROM shipmentDetail <font></font>
					JOIN shipment ON shipmentDetail.shipment = shipment.id<font></font>
					JOIN product ON product.id = shipmentDetail.product<font></font>
					WHERE product.group = 54<font></font>
				) details<font></font>
		 	GROUP BY product<font></font>
		) balance ON balance.product = product.id<font></font>
	WHERE product.group = 54<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Hash Join  (cost=43596.42..43601.45 rows=1 width=32) (actual time=93.861..93.898 rows=48 loops=1)"<font></font>
"  Hash Cond: (receiptdetail.product = product.id)"<font></font>
"  -&gt;  HashAggregate  (cost=43458.93..43461.43 rows=200 width=36) (actual time=93.685..93.707 rows=48 loops=1)"<font></font>
"        Group Key: receiptdetail.product"<font></font>
"        -&gt;  Append  (cost=9.54..43405.03 rows=10780 width=34) (actual time=0.056..89.656 rows=10672 loops=1)"<font></font>
"              -&gt;  Nested Loop  (cost=9.54..4448.35 rows=980 width=9) (actual time=0.056..7.524 rows=913 loops=1)"<font></font>
"                    -&gt;  Nested Loop  (cost=9.26..4151.50 rows=980 width=13) (actual time=0.043..3.946 rows=913 loops=1)"<font></font>
"                          -&gt;  Bitmap Heap Scan on product product_1  (cost=4.67..136.88 rows=49 width=4) (actual time=0.017..0.124 rows=48 loops=1)"<font></font>
"                                Recheck Cond: ("group" = 54)"<font></font>
"                                Heap Blocks: exact=46"<font></font>
"                                -&gt;  Bitmap Index Scan on product_group  (cost=0.00..4.66 rows=49 width=0) (actual time=0.011..0.011 rows=48 loops=1)"<font></font>
"                                      Index Cond: ("group" = 54)"<font></font>
"                          -&gt;  Bitmap Heap Scan on receiptdetail  (cost=4.59..81.72 rows=21 width=13) (actual time=0.017..0.072 rows=19 loops=48)"<font></font>
"                                Recheck Cond: (product = product_1.id)"<font></font>
"                                Heap Blocks: exact=910"<font></font>
"                                -&gt;  Bitmap Index Scan on receiptdetail_product_fk  (cost=0.00..4.58 rows=21 width=0) (actual time=0.012..0.012 rows=19 loops=48)"<font></font>
"                                      Index Cond: (product = product_1.id)"<font></font>
"                    -&gt;  Index Only Scan using receipt_pkey on receipt  (cost=0.29..0.30 rows=1 width=4) (actual time=0.003..0.003 rows=1 loops=913)"<font></font>
"                          Index Cond: (id = receiptdetail.receipt)"<font></font>
"                          Heap Fetches: 913"<font></font>
"              -&gt;  Nested Loop  (cost=10.93..38794.98 rows=9800 width=36) (actual time=0.170..80.715 rows=9759 loops=1)"<font></font>
"                    -&gt;  Nested Loop  (cost=10.64..35728.52 rows=9800 width=13) (actual time=0.151..35.242 rows=9759 loops=1)"<font></font>
"                          -&gt;  Bitmap Heap Scan on product product_2  (cost=4.67..136.88 rows=49 width=4) (actual time=0.030..0.170 rows=48 loops=1)"<font></font>
"                                Recheck Cond: ("group" = 54)"<font></font>
"                                Heap Blocks: exact=46"<font></font>
"                                -&gt;  Bitmap Index Scan on product_group  (cost=0.00..4.66 rows=49 width=0) (actual time=0.020..0.020 rows=48 loops=1)"<font></font>
"                                      Index Cond: ("group" = 54)"<font></font>
"                          -&gt;  Bitmap Heap Scan on shipmentdetail  (cost=5.97..724.38 rows=198 width=13) (actual time=0.071..0.678 rows=203 loops=48)"<font></font>
"                                Recheck Cond: (product = product_2.id)"<font></font>
"                                Heap Blocks: exact=9745"<font></font>
"                                -&gt;  Bitmap Index Scan on shipmentdetail_product_fk  (cost=0.00..5.92 rows=198 width=0) (actual time=0.037..0.037 rows=203 loops=48)"<font></font>
"                                      Index Cond: (product = product_2.id)"<font></font>
"                    -&gt;  Index Only Scan using shipment_pkey on shipment  (cost=0.29..0.31 rows=1 width=4) (actual time=0.004..0.004 rows=1 loops=9759)"<font></font>
"                          Index Cond: (id = shipmentdetail.shipment)"<font></font>
"                          Heap Fetches: 9759"<font></font>
"  -&gt;  Hash  (cost=136.88..136.88 rows=49 width=4) (actual time=0.166..0.166 rows=48 loops=1)"<font></font>
"        Buckets: 1024  Batches: 1  Memory Usage: 10kB"<font></font>
"        -&gt;  Bitmap Heap Scan on product  (cost=4.67..136.88 rows=49 width=4) (actual time=0.041..0.151 rows=48 loops=1)"<font></font>
"              Recheck Cond: ("group" = 54)"<font></font>
"              Heap Blocks: exact=46"<font></font>
"              -&gt;  Bitmap Index Scan on product_group  (cost=0.00..4.66 rows=49 width=0) (actual time=0.028..0.028 rows=48 loops=1)"<font></font>
"                    Index Cond: ("group" = 54)"<font></font>
"Planning Time: 1.553 ms"<font></font>
"Execution Time: 94.071 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、この場合、製品とのJOINは3回実行されますが、これはデータベース全体のサブクエリを計算するよりもはるかに簡単です。</font></font><br>
<br>
<a name="joinwhere"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件付きロジックのJOINとWHERE型への分離</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに気づく人はほとんどいませんが、SQLの結果のテーブルに表示されるレコードに影響を与えるロジックは、2つの部分に分かれています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左側のテーブル、右側のテーブル、両方のテーブル、またはどちらか一方のテーブルからレコードを選択するかどうかを決定するJOINタイプ。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHEREは、AND、OR、およびNOTを含む論理式であり、選択するレコードも決定します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この分割で本当に理解できないのは、JOIN型が通常のブールロジックに完全に変換されるため、JOINロジックがWHEREに含まれなかった理由です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INNER JOIN BはIN JOIN AおよびIN JOIN Bに対応します</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左結合B-結合A</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しい結合B-結合B</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A FULL JOIN B-IN JOIN AまたはIN JOIN B</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、要求は次のとおりです。</font></font><br>
<br>
<pre><code class="sql">SELECT COALESCE(X.id, D.id) <font></font>
	FROM <font></font>
		(SELECT A.id <font></font>
			FROM A <font></font>
			INNER JOIN B ON A.id = B.id <font></font>
			LEFT JOIN C ON C.id = A.id<font></font>
		) X <font></font>
	FULL JOIN D ON X.id = D.id<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは次のようになります：</font></font><br>
<br>
<pre><code class="sql">SELECT A.id <font></font>
	FROM A <font></font>
	AUTO JOIN B ON A.id = B.id <font></font>
	AUTO JOIN C ON C.id=A.id <font></font>
	AUTO JOIN D ON D.id=A.id <font></font>
	WHERE (IN JOIN A AND IN JOIN B) OR IN JOIN D<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この分割の最悪の部分は、結果の列にCOALESCEを使用する必要があるため、実際にはFULL JOINの状況であり、PPD最適化の可能性がすぐに失われます。</font><font style="vertical-align: inherit;">したがって、実際には、FULL JOINの代わりに、UNIONがより頻繁に使用されます。</font></font><br>
<br>
<pre><code class="sql">SELECT COALESCE(A.id, B.id) <font></font>
FROM A <font></font>
FULL JOIN B ON A.id=B.id<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは書きます：</font></font><br>
<br>
<pre><code class="sql">SELECT id FROM A <font></font>
UNION <font></font>
SELECT id FROM B<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、AとBから2つの列の合計を計算する必要がある場合、すべてが著しく悪化します（いくつかのLEFT JOINを実行する必要があります）。</font><font style="vertical-align: inherit;">したがって、リクエスト：</font></font><br>
<br>
<pre><code class="sql">SELECT COALESCE(A.id, B.id), COALESCE(A.f,0)+COALESCE(B.f,0) <font></font>
FROM A <font></font>
FULL JOIN B ON A.id=B.id<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UNIONでは、次のようになります。</font></font><br>
<br>
<pre><code class="sql">SELECT A.id, A.f + COALESCE(B.f,0) <font></font>
FROM A <font></font>
LEFT JOIN B ON A.id = B.id<font></font>
UNION<font></font>
SELECT B.id, B.f + COALESCE(A.f,0) <font></font>
FROM B <font></font>
LEFT JOIN A ON A.id = B.id<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、条件（Af = 1 OR Bf = 2）AND（Cf = 3 OR Df = 4）によってテーブルA、B、C、Dからエントリを選択する必要がある場合、すべてが非常に悲しくなります。</font><font style="vertical-align: inherit;">そのため、FULL JOINを使用して、可能なすべての最適化をいくつかのCOALESCEで再び終了します。UNIONを使用すると、開発者は自分で条件をDNFに持ってきて、次のように記述する必要があります。</font></font><br>
<br>
<pre><code class="sql">SELECT A.id<font></font>
	FROM A <font></font>
	JOIN C ON A.id = C.id<font></font>
	WHERE A.f=1 AND C.f=3<font></font>
UNION<font></font>
SELECT A.id<font></font>
	FROM A <font></font>
	JOIN D ON A.id = D.id<font></font>
	WHERE A.f=1 AND D.f=4<font></font>
UNION<font></font>
SELECT B.id<font></font>
	FROM B <font></font>
	JOIN C ON B.id = C.id<font></font>
	WHERE B.f=2 AND C.f=3<font></font>
UNION<font></font>
SELECT B.id<font></font>
	FROM B <font></font>
	JOIN D ON B.id = D.id<font></font>
	WHERE B.f=2 AND D.f=4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、A、B、C、Dのフィールドからいくつかの数式を計算する必要がある場合は、LEFT JOINが原因で、クエリがさらに2倍になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではもちろん、多くの人が「どのような奇妙な物理モデルを持っていますか」と言いますが、最初に、彼らは物理モデルを選択しない（つまり、実際のモデルをそのまま使用する）場合が多く、次に次に説明するように、セクションでは、これらのすべてのフィールドが同じテーブルにある場合でも、問題が発生します（理由は少し異なります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれの場合でも、JOINタイプが論理述語IN JOINによって指定された場合、特に条件から推定できる場合（たとえば、IN JOIN AはAf = 1から続く）、クエリは次のように記述できます。</font></font><br>
<br>
<pre><code class="sql">SELECT A.id <font></font>
	FROM A <font></font>
	AUTO JOIN B ON A.id = B.id <font></font>
	AUTO JOIN C ON A.id = C.id <font></font>
	AUTO JOIN D ON A.id = D.id <font></font>
	WHERE (A.f=1 OR B.f=2) AND (C.f=3 OR D.f=4)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLサーバー自体は、このクエリをUNION / FULL JOINに分割する方法と、受信したサブクエリでどのタイプのJOINを置き換えるかを決定できます。</font><font style="vertical-align: inherit;">この作業は、開発者が直接行う必要があります。</font></font><br>
<br>
<a name="oropt"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不十分なOR最適化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションの例に戻りましょう。</font><font style="vertical-align: inherit;">4つの異なるテーブルA、B、C、Dではなく、1つのテーブルmytableと4つのフィールドA、B、C、Dがあるとします。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mytable MS SQLテーブルを作成および設定するスクリプト</font></font></b><div class="spoiler_text"><pre><code class="sql">CREATE TABLE mytable (cid INT, A INT, B INT, C INT , D INT, data VARCHAR(400));<font></font>
<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt; 10000000<font></font>
)<font></font>
INSERT INTO mytable (cid, A, B, C, D, data)<font></font>
SELECT n, ABS(checksum(NewId())) % 100 + 1, ABS(checksum(NewId())) % 100 + 1, ABS(checksum(NewId())) % 100 + 1, ABS(checksum(NewId())) % 100 + 1, CONCAT('data',n)  FROM numbers option (maxrecursion 0);<font></font>
<font></font>
CREATE INDEX AC ON mytable(A,C);<font></font>
CREATE INDEX AD ON mytable(A,D);<font></font>
CREATE INDEX BC ON mytable(B,C);<font></font>
CREATE INDEX BD ON mytable(B,D);<font></font>
<font></font>
EXEC sp_updatestats;<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mytableテーブルOracleを作成および設定するスクリプト</font></font></b><div class="spoiler_text"><pre><code class="sql">CREATE TABLE mytable (cid INT, A INT, B INT, C INT , D INT, "data" VARCHAR(400));<font></font>
<font></font>
INSERT INTO mytable (cid, A, B, C, D, "data")<font></font>
WITH<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n FROM dual<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt; 10000000<font></font>
)<font></font>
SELECT n, round(dbms_random.value() * 100) + 1, round(dbms_random.value() * 100) + 1, round(dbms_random.value() * 100) + 1, round(dbms_random.value() * 100) + 1, CONCAT('data',n)  FROM numbers;<font></font>
<font></font>
CREATE INDEX AC ON mytable(A,C);<font></font>
CREATE INDEX AD ON mytable(A,D);<font></font>
CREATE INDEX BC ON mytable(B,C);<font></font>
CREATE INDEX BD ON mytable(B,D);<font></font>
<font></font>
EXEC DBMS_STATS.GATHER_DATABASE_STATS;<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mytable PostgreSQLテーブルを作成および設定するスクリプト</font></font></b><div class="spoiler_text"><pre><code class="sql">CREATE TABLE mytable (cid INT, A INT, B INT, C INT , D INT, "data" VARCHAR(400));<font></font>
<font></font>
INSERT INTO mytable (cid, A, B, C, D, "data")<font></font>
WITH RECURSIVE<font></font>
numbers ( n ) AS (<font></font>
   SELECT 1 AS n<font></font>
   UNION ALL<font></font>
   SELECT n + 1 AS n<font></font>
   FROM   numbers<font></font>
   WHERE  n &lt; 10000000<font></font>
)<font></font>
SELECT n, floor(random() * 100) + 1, floor(random() * 100) + 1, floor(random() * 100) + 1, floor(random() * 100) + 1, CONCAT('data',n)  FROM numbers;<font></font>
<font></font>
CREATE INDEX AC ON mytable(A,C);<font></font>
CREATE INDEX AD ON mytable(A,D);<font></font>
CREATE INDEX BC ON mytable(B,C);<font></font>
CREATE INDEX BD ON mytable(B,D);<font></font>
<font></font>
ANALYZE;<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この場合のリクエストは次のようになります。</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM mytable WHERE (A=1 OR B=2) AND (C=3 OR D=4)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクエリを高速にするために、テーブルを作成するときに、これらの列のさまざまな組み合わせ（AC、BC、AD、BD）にインデックスを追加しました。</font></font><br>
<br>
<pre><code class="sql">CREATE INDEX AC ON mytable(A,C);<font></font>
CREATE INDEX AD ON mytable(A,D);<font></font>
CREATE INDEX BC ON mytable(B,C);<font></font>
CREATE INDEX BD ON mytable(B,D);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストを実行します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 320<br>
<pre>--------------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                            | Name    | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |<font></font>
--------------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT                     |         |       |       |       | 12436 (100)|          |<font></font>
|   1 |  SORT AGGREGATE                      |         |     1 |    16 |       |            |          |<font></font>
|*  2 |   TABLE ACCESS BY INDEX ROWID BATCHED| MYTABLE |  3882 | 62112 |       | 12436   (1)| 00:00:01 |<font></font>
|   3 |    BITMAP CONVERSION TO ROWIDS       |         |       |       |       |            |          |<font></font>
|   4 |     BITMAP OR                        |         |       |       |       |            |          |<font></font>
|   5 |      BITMAP CONVERSION FROM ROWIDS   |         |       |       |       |            |          |<font></font>
|   6 |       SORT ORDER BY                  |         |       |       |  1568K|            |          |<font></font>
|*  7 |        INDEX RANGE SCAN              | AC      |       |       |       |   241   (1)| 00:00:01 |<font></font>
|   8 |      BITMAP CONVERSION FROM ROWIDS   |         |       |       |       |            |          |<font></font>
|   9 |       SORT ORDER BY                  |         |       |       |  1568K|            |          |<font></font>
|* 10 |        INDEX RANGE SCAN              | BC      |       |       |       |   235   (1)| 00:00:01 |<font></font>
--------------------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   2 - filter(("C"=3 OR "D"=4))<font></font>
   7 - access("A"=1)<font></font>
       filter("A"=1)<font></font>
  10 - access("B"=2)<font></font>
       filter("B"=2)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Aggregate  (cost=81577.07..81577.08 rows=1 width=8) (actual time=255.927..255.928 rows=1 loops=1)"<font></font>
"  -&gt;  Bitmap Heap Scan on mytable  (cost=3863.84..81567.12 rows=3980 width=0) (actual time=60.368..255.477 rows=3886 loops=1)"<font></font>
"        Recheck Cond: ((a = 1) OR (b = 2))"<font></font>
"        Filter: ((c = 3) OR (d = 4))"<font></font>
"        Rows Removed by Filter: 195540"<font></font>
"        Heap Blocks: exact=68751"<font></font>
"        -&gt;  BitmapOr  (cost=3863.84..3863.84 rows=208664 width=0) (actual time=43.859..43.859 rows=0 loops=1)"<font></font>
"              -&gt;  Bitmap Index Scan on ad  (cost=0.00..1924.43 rows=103999 width=0) (actual time=32.954..32.954 rows=100496 loops=1)"<font></font>
"                    Index Cond: (a = 1)"<font></font>
"              -&gt;  Bitmap Index Scan on bd  (cost=0.00..1937.42 rows=104665 width=0) (actual time=10.902..10.902 rows=100014 loops=1)"<font></font>
"                    Index Cond: (b = 2)"<font></font>
"Planning Time: 0.603 ms"<font></font>
"Execution Time: 256.078 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、SQLサーバーは条件を操作しようとすることさえせず、見たとおりに実行するだけでした。</font><font style="vertical-align: inherit;">つまり、私は最初のブラケットを取り、ORを見て、それをインデックスに分割し、2番目のブラケットを上に適用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、最も優れているのはMS SQLです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 1.8<br>
<pre>Rows	Executes  Stmt Text<font></font>
0	0	  |--Compute Scalar(DEFINE:([Expr1003]=CONVERT_IMPLICIT(int,[Expr1006],0)))<font></font>
1	1	       |--Stream Aggregate(DEFINE:([Expr1006]=Count(*)))<font></font>
3918	1	            |--Table Scan(OBJECT:([test2].[dbo].[mytable]), WHERE:(([test2].[dbo].[mytable].[A]=(1) OR [test2].[dbo].[mytable].[B]=(2)) AND ([test2].[dbo].[mytable].[C]=(3) OR [test2].[dbo].[mytable].[D]=(4))))<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼はインデックスをまったく使用しないことにしました。</font><font style="vertical-align: inherit;">しかし、さらに多くの種類の列があるかどうかを確認したところ、MS SQLはOracleやPostgreSQLと同様のインデックスを使用してプランを構築できるため、これを構成の機能に書き留めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、2番目のブラケットを開いても、次のようになります。</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM mytable WHERE ((A=1 OR B=2) AND C=3) OR ((A=1 OR B=2) AND D=4)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは役に立ちません-計画は同じままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリクエストが正常に実行される唯一のオプションは、初期条件をDNFに変換することです。</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM mytable WHERE (A=1 AND C=3) OR (B=2 AND C=3) OR (A=1 AND D=4) OR (B=2 AND D=4)
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 30<br>
<pre>-----------------------------------------------------------------------------------------<font></font>
| Id  | Operation                        | Name | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
-----------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT                 |      |       |       |    18 (100)|          |<font></font>
|   1 |  SORT AGGREGATE                  |      |     1 |    16 |            |          |<font></font>
|   2 |   BITMAP CONVERSION COUNT        |      |  3010 | 48160 |    18   (0)| 00:00:01 |<font></font>
|   3 |    BITMAP OR                     |      |       |       |            |          |<font></font>
|   4 |     BITMAP CONVERSION FROM ROWIDS|      |       |       |            |          |<font></font>
|*  5 |      INDEX RANGE SCAN            | BC   |       |       |     5   (0)| 00:00:01 |<font></font>
|   6 |     BITMAP CONVERSION FROM ROWIDS|      |       |       |            |          |<font></font>
|*  7 |      INDEX RANGE SCAN            | BD   |       |       |     5   (0)| 00:00:01 |<font></font>
|   8 |     BITMAP CONVERSION FROM ROWIDS|      |       |       |            |          |<font></font>
|*  9 |      INDEX RANGE SCAN            | AC   |       |       |     4   (0)| 00:00:01 |<font></font>
|  10 |     BITMAP CONVERSION FROM ROWIDS|      |       |       |            |          |<font></font>
|* 11 |      INDEX RANGE SCAN            | AD   |       |       |     4   (0)| 00:00:01 |<font></font>
-----------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   5 - access("B"=2 AND "C"=3)<font></font>
   7 - access("B"=2 AND "D"=4)<font></font>
   9 - access("A"=1 AND "C"=3)<font></font>
  11 - access("A"=1 AND "D"=4)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 60<br>
<pre>Rows	Executes  Stmt Text<font></font>
0	0	  |--Compute Scalar(DEFINE:([Expr1003]=CONVERT_IMPLICIT(int,[Expr1006],0)))<font></font>
1	1	       |--Stream Aggregate(DEFINE:([Expr1006]=Count(*)))<font></font>
3918	1	            |--Stream Aggregate(GROUP BY:([Bmk1000]))<font></font>
3951	1	                 |--Merge Join(Concatenation)<font></font>
2986	1	                      |--Merge Join(Concatenation)<font></font>
1978	1	                      |    |--Merge Join(Concatenation)<font></font>
941	1	                      |    |    |--Index Seek(OBJECT:([test2].[dbo].[mytable].[AC]), SEEK:([test2].[dbo].[mytable].[A]=(1) AND [test2].[dbo].[mytable].[C]=(3)) ORDERED FORWARD)<font></font>
1037	1	                      |    |    |--Index Seek(OBJECT:([test2].[dbo].[mytable].[BC]), SEEK:([test2].[dbo].[mytable].[B]=(2) AND [test2].[dbo].[mytable].[C]=(3)) ORDERED FORWARD)<font></font>
1008	1	                      |    |--Index Seek(OBJECT:([test2].[dbo].[mytable].[AD]), SEEK:([test2].[dbo].[mytable].[A]=(1) AND [test2].[dbo].[mytable].[D]=(4)) ORDERED FORWARD)<font></font>
965	1	                      |--Index Seek(OBJECT:([test2].[dbo].[mytable].[BD]), SEEK:([test2].[dbo].[mytable].[B]=(2) AND [test2].[dbo].[mytable].[D]=(4)) ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Aggregate  (cost=13171.55..13171.56 rows=1 width=8) (actual time=18.442..18.443 rows=1 loops=1)"<font></font>
"  -&gt;  Bitmap Heap Scan on mytable  (cost=93.97..13161.50 rows=4020 width=0) (actual time=3.493..17.545 rows=3886 loops=1)"<font></font>
"        Recheck Cond: (((a = 1) AND (c = 3)) OR ((b = 2) AND (c = 3)) OR ((a = 1) AND (d = 4)) OR ((b = 2) AND (d = 4)))"<font></font>
"        Heap Blocks: exact=3793"<font></font>
"        -&gt;  BitmapOr  (cost=93.97..93.97 rows=4020 width=0) (actual time=1.773..1.774 rows=0 loops=1)"<font></font>
"              -&gt;  Bitmap Index Scan on ac  (cost=0.00..22.76 rows=1033 width=0) (actual time=0.516..0.516 rows=993 loops=1)"<font></font>
"                    Index Cond: ((a = 1) AND (c = 3))"<font></font>
"              -&gt;  Bitmap Index Scan on bc  (cost=0.00..22.83 rows=1040 width=0) (actual time=0.440..0.440 rows=960 loops=1)"<font></font>
"                    Index Cond: ((b = 2) AND (c = 3))"<font></font>
"              -&gt;  Bitmap Index Scan on ad  (cost=0.00..22.14 rows=971 width=0) (actual time=0.224..0.224 rows=958 loops=1)"<font></font>
"                    Index Cond: ((a = 1) AND (d = 4))"<font></font>
"              -&gt;  Bitmap Index Scan on bd  (cost=0.00..22.20 rows=977 width=0) (actual time=0.592..0.592 rows=1020 loops=1)"<font></font>
"                    Index Cond: ((b = 2) AND (d = 4))"<font></font>
"Planning Time: 0.296 ms"<font></font>
"Execution Time: 18.539 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの例からわかるように、SQL Serverは論理式を最適化することすらしません。</font><font style="vertical-align: inherit;">このような最適化はNP完了のタスクであり、SQLサーバーの作成者は明らかにそれを好まなかったため、これは一般的に理解できます。</font><font style="vertical-align: inherit;">したがって、JOIN型と同様に、このタスクを開発者に移すことを決定しました。</font></font><br>
<br>
<a name="nullopt"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スパースデータを使用する場合の最適化の悪さ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を想像してみてください。</font><font style="vertical-align: inherit;">大きなテーブル（shipmentdetail）があり、新しい列（sid）とインデックス（shipment_sd）を追加することにしました。</font><font style="vertical-align: inherit;">この列はデフォルトではnullであり、ごく一部のデータが入力されています。</font><font style="vertical-align: inherit;">sidのすべての重複を見つける必要があるため、次のクエリを作成します。</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM ShipmentDetail s1, ShipmentDetail s2 WHERE s1.sd=s2.sd AND s1.id &lt;&gt; s2.id
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 3.5<br>
<pre>Rows	Executes  Stmt Text<font></font>
1	1	  |--Compute Scalar(DEFINE:([Expr1002]=CONVERT_IMPLICIT(int,[Expr1008],0)))<font></font>
1	1	       |--Hash Match(Aggregate, HASH:() DEFINE:([Expr1008]=COUNT(*)))<font></font>
0	1	            |--Nested Loops(Inner Join, OUTER REFERENCES:([s1].[id], [s1].[sd], [Expr1007]) WITH UNORDERED PREFETCH)<font></font>
10000001	1	                 |--Index Scan(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_sd] AS [s1]))<font></font>
0	10000001	                 |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_sd] AS [s2]), SEEK:([s2].[sd]=[test].[dbo].[shipmentdetail].[sd] as [s1].[sd]),  WHERE:([test].[dbo].[shipmentdetail].[id] as [s1].[id]&lt;&gt;[test].[dbo].[shipmentdetail].[id] as [s2].[id]) ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、MS SQLは、shippingdetail_sdインデックスで実行しようとしたときに、IS NOT NULLにフィルターを設定する必要があることを認識していないため、このクエリのパフォーマンスは非常に低くなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
s1.sdおよびs2.sdがNOT NULLである明示的な条件を追加すると、状況は劇的に改善されます。</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM ShipmentDetail s1, ShipmentDetail s2 WHERE s1.sd=s2.sd AND s1.id &lt;&gt; s2.id AND s1.sd IS NOT NULL AND s2.sd IS NOT NULL
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 100<br>
<pre>Rows	Executes  Stmt Text<font></font>
0	0	  |--Compute Scalar(DEFINE:([Expr1002]=CONVERT_IMPLICIT(int,[Expr1005],0)))<font></font>
1	1	       |--Stream Aggregate(DEFINE:([Expr1005]=Count(*)))<font></font>
0	1	            |--Nested Loops(Inner Join, OUTER REFERENCES:([s1].[id], [s1].[sd]))<font></font>
100	1	                 |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_sd] AS [s1]), SEEK:([s1].[sd] IsNotNull) ORDERED FORWARD)<font></font>
0	100	                 |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_sd] AS [s2]), SEEK:([s2].[sd]=[test].[dbo].[shipmentdetail].[sd] as [s1].[sd]),  WHERE:([test].[dbo].[shipmentdetail].[id] as [s1].[id]&lt;&gt;[test].[dbo].[shipmentdetail].[id] as [s2].[id] AND [test].[dbo].[shipmentdetail].[sd] as [s2].[sd] IS NOT NULL) ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがPostgreSQLで複雑になりますが、基本的なクエリは機能し、うまく機能しますが、フィルターを追加するためではありませんが、マージ結合を使用し、明らかに、その中でNULL値をスキップできるためです（MS SQLが適切なヒントを追加すると、奇妙で​​すが、それは助けにはなりません）：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Aggregate  (cost=1216467.81..1216467.82 rows=1 width=8) (actual time=1.021..1.021 rows=1 loops=1)"<font></font>
"  -&gt;  Merge Join  (cost=0.87..1216467.81 rows=1 width=0) (actual time=1.017..1.017 rows=0 loops=1)"<font></font>
"        Merge Cond: (s1.sd = s2.sd)"<font></font>
"        Join Filter: (s1.id &lt;&gt; s2.id)"<font></font>
"        Rows Removed by Join Filter: 100"<font></font>
"        -&gt;  Index Scan using shipmentdetail_sd on shipmentdetail s1  (cost=0.43..583234.26 rows=9999855 width=8) (actual time=0.047..0.136 rows=101 loops=1)"<font></font>
"        -&gt;  Index Scan using shipmentdetail_sd on shipmentdetail s2  (cost=0.43..583234.26 rows=9999855 width=8) (actual time=0.015..0.757 rows=101 loops=1)"<font></font>
"Planning Time: 0.332 ms"<font></font>
"Execution Time: 1.089 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、見積もりとコストを見ると、PostgreSQLがテーブル内のすべてのレコードを実行する予定であることがわかります。</font><font style="vertical-align: inherit;">したがって、クエリをわずかに変更して、たとえば条件を追加すると、数量が7を超える重複を見つけます</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM shipmentDetail s1, shipmentDetail s2 WHERE s1.sd=s2.sd AND s1.id &lt;&gt; s2.id AND s1.quantity &gt; 7 AND s2.quantity &gt; 7;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、MS SQLと同じ問題が発生します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Aggregate  (cost=1165667.15..1165667.16 rows=1 width=8) (actual time=5203.586..5203.586 rows=1 loops=1)"<font></font>
"  -&gt;  Merge Join  (cost=1128001.01..1165667.15 rows=1 width=0) (actual time=5203.580..5203.580 rows=0 loops=1)"<font></font>
"        Merge Cond: (s1.sd = s2.sd)"<font></font>
"        Join Filter: (s1.id &lt;&gt; s2.id)"<font></font>
"        Rows Removed by Join Filter: 29"<font></font>
"        -&gt;  Sort  (cost=564000.51..571533.73 rows=3013290 width=8) (actual time=2802.648..2802.658 rows=30 loops=1)"<font></font>
"              Sort Key: s1.sd"<font></font>
"              Sort Method: external merge  Disk: 41120kB"<font></font>
"              -&gt;  Seq Scan on shipmentdetail s1  (cost=0.00..198528.19 rows=3013290 width=8) (actual time=0.051..2193.193 rows=2999089 loops=1)"<font></font>
"                    Filter: (quantity &gt; '7'::numeric)"<font></font>
"                    Rows Removed by Filter: 7000912"<font></font>
"        -&gt;  Materialize  (cost=564000.51..579066.96 rows=3013290 width=8) (actual time=2400.884..2400.894 rows=30 loops=1)"<font></font>
"              -&gt;  Sort  (cost=564000.51..571533.73 rows=3013290 width=8) (actual time=2400.876..2400.882 rows=30 loops=1)"<font></font>
"                    Sort Key: s2.sd"<font></font>
"                    Sort Method: external merge  Disk: 41120kB"<font></font>
"                    -&gt;  Seq Scan on shipmentdetail s2  (cost=0.00..198528.19 rows=3013290 width=8) (actual time=0.033..1833.562 rows=2999089 loops=1)"<font></font>
"                          Filter: (quantity &gt; '7'::numeric)"<font></font>
"                          Rows Removed by Filter: 7000912"<font></font>
"Planning Time: 0.398 ms"<font></font>
"Execution Time: 5233.873 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、s1.sdおよびs2.sdがNOT NULLである明示的な条件の追加と同じように処理されます。</font></font><br>
<br>
<pre><code class="sql">SELECT COUNT(*) FROM shipmentDetail s1, shipmentDetail s2 WHERE s1.sd=s2.sd AND s1.id &lt;&gt; s2.id AND s1.quantity &gt; 7 AND s2.quantity &gt; 7 AND s1.sd IS NOT NULL AND s2.sd IS NOT NULL
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Aggregate  (cost=16.93..16.94 rows=1 width=8) (actual time=4.624..4.624 rows=1 loops=1)"<font></font>
"  -&gt;  Nested Loop  (cost=0.87..16.93 rows=1 width=0) (actual time=4.617..4.617 rows=0 loops=1)"<font></font>
"        Join Filter: ((s1.id &lt;&gt; s2.id) AND (s1.sd = s2.sd))"<font></font>
"        Rows Removed by Join Filter: 841"<font></font>
"        -&gt;  Index Scan using shipmentdetail_sd on shipmentdetail s1  (cost=0.43..8.46 rows=1 width=8) (actual time=0.055..0.201 rows=29 loops=1)"<font></font>
"              Index Cond: (sd IS NOT NULL)"<font></font>
"              Filter: (quantity &gt; '7'::numeric)"<font></font>
"              Rows Removed by Filter: 71"<font></font>
"        -&gt;  Index Scan using shipmentdetail_sd on shipmentdetail s2  (cost=0.43..8.46 rows=1 width=8) (actual time=0.013..0.142 rows=29 loops=29)"<font></font>
"              Index Cond: (sd IS NOT NULL)"<font></font>
"              Filter: (quantity &gt; '7'::numeric)"<font></font>
"              Rows Removed by Filter: 71"<font></font>
"Planning Time: 0.570 ms"<font></font>
"Execution Time: 4.705 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オラクルは、この場合に誤解されていない唯一のものであり、そのような述語自体を追加すると推測しました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 30<br>
<pre>------------------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                              | Name              | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
------------------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT                       |                   |       |       |   201 (100)|          |<font></font>
|   1 |  SORT AGGREGATE                        |                   |     1 |    16 |            |          |<font></font>
|   2 |   NESTED LOOPS                         |                   |    99 |  1584 |   201   (0)| 00:00:01 |<font></font>
|   3 |    NESTED LOOPS                        |                   |   100 |  1584 |   201   (0)| 00:00:01 |<font></font>
|   4 |     TABLE ACCESS BY INDEX ROWID BATCHED| SHIPMENTDETAIL    |   100 |   800 |   101   (0)| 00:00:01 |<font></font>
|*  5 |      INDEX FULL SCAN                   | SHIPMENTDETAIL_SD |   100 |       |     1   (0)| 00:00:01 |<font></font>
|*  6 |     INDEX RANGE SCAN                   | SHIPMENTDETAIL_SD |     1 |       |     0   (0)|          |<font></font>
|*  7 |    TABLE ACCESS BY INDEX ROWID         | SHIPMENTDETAIL    |     1 |     8 |     1   (0)| 00:00:01 |<font></font>
------------------------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   5 - filter("S1"."SD" IS NOT NULL)<font></font>
   6 - access("S1"."SD"="S2"."SD")<font></font>
       filter("S2"."SD" IS NOT NULL)<font></font>
   7 - filter("S1"."ID"&lt;&gt;"S2"."ID")<font></font>
</pre><br>
</div></div><br>
<a name="lastopt"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新の値で作業する際の不十分な最適化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OLTPビジネスアプリケーションのグループ化要求で最も一般的に使用される集計関数は、合計と最後の値です（たとえば、1Cでは、これらはそれぞれ累積レジスターと情報レジスターです）。合計すると、すべてがある程度明確になりますが、最後の値については、SQLサーバーでのこのような機能の一般的なサポートとそのさらなる最適化の両方に関して、多くの疑問があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、製品の最終出荷を取得したいとしましょう。まず、最後の出荷は、この出荷の内部番号（日付ではなく）で検索する必要があると想定します。 Stackoverflow検索で最初に提供されるのはクエリです。</font></font><br>
<br>
<pre><code class="sql">SELECT MAX(shipment) AS ls FROM ShipmentDetail s WHERE s.product = 123
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最上位のクエリをすばやく実行するために、製品、出荷のインデックスは明らかであり、実際にそれを作成してクエリを実行すると、かなり効果的な実行プランが得られます（これはPostgreSQLでも驚くべきことです）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSSQLで計画する</font></font></b><div class="spoiler_text">  : 70<br>
<pre>Rows	Executes  Stmt Text<font></font>
1	1	  |--Stream Aggregate(DEFINE:([Expr1001]=MAX([test].[dbo].[shipmentdetail].[shipment] as [s].[shipment])))<font></font>
1	1	       |--Top(TOP EXPRESSION:((1)))<font></font>
1	1	            |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_p_s] AS [s]), SEEK:([s].[product]=(123)) ORDERED BACKWARD)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 30<br>
<pre>---------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                    | Name               | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
---------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT             |                    |       |       |     3 (100)|          |<font></font>
|   1 |  SORT AGGREGATE              |                    |     1 |    10 |            |          |<font></font>
|   2 |   FIRST ROW                  |                    |     1 |    10 |     3   (0)| 00:00:01 |<font></font>
|*  3 |    INDEX RANGE SCAN (MIN/MAX)| SHIPMENTDETAIL_P_S |     1 |    10 |     3   (0)| 00:00:01 |<font></font>
---------------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   3 - access("S"."PRODUCT"=123)<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLプラン</font></font></b><div class="spoiler_text"><pre>"Result  (cost=4.47..4.48 rows=1 width=4) (actual time=0.173..0.174 rows=1 loops=1)"<font></font>
"  InitPlan 1 (returns $0)"<font></font>
"    -&gt;  Limit  (cost=0.43..4.47 rows=1 width=4) (actual time=0.165..0.166 rows=1 loops=1)"<font></font>
"          -&gt;  Index Only Scan Backward using shipmentdetail_p_s on shipmentdetail s  (cost=0.43..808.43 rows=200 width=4) (actual time=0.163..0.163 rows=1 loops=1)"<font></font>
"                Index Cond: ((product = 123) AND (shipment IS NOT NULL))"<font></font>
"                Heap Fetches: 1"<font></font>
"Planning Time: 0.949 ms"<font></font>
"Execution Time: 0.241 ms"<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、この点に関して、すべてのSQLサーバーは、1つの行を正確に数えるのに十分であるというチェックを挿入すると推測しています（最初の行-Oracle、LIMIT-MS SQLおよびPostgreSQL）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、要求を少し複雑にして、1つの製品ではなく、たとえば製品86以降のすべての製品（JPPDは原則としてサポートしていないため、PostgreSQLはすぐに競争を去ります）に対して実行してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oracleから始めましょう。</font></font><br>
<br>
<pre><code class="sql">SELECT SUM(cc.ls) <font></font>
        FROM Product pr<font></font>
        LEFT JOIN (SELECT MAX(shipment) AS ls, s.product<font></font>
            FROM shipmentDetail s<font></font>
            GROUP BY s.product) cc ON cc.product=pr.id<font></font>
        WHERE pr.name LIKE 'Product 86%';<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 60<br>
<pre>--------------------------------------------------------------------------------------------<font></font>
| Id  | Operation             | Name               | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
--------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT      |                    |       |       |   120 (100)|          |<font></font>
|   1 |  SORT AGGREGATE       |                    |     1 |    13 |            |          |<font></font>
|   2 |   VIEW                | VM_NWVW_1          |  4898 | 63674 |   120   (2)| 00:00:01 |<font></font>
|   3 |    HASH GROUP BY      |                    |  4898 |   157K|   120   (2)| 00:00:01 |<font></font>
|   4 |     NESTED LOOPS      |                    |  4898 |   157K|   118   (0)| 00:00:01 |<font></font>
|*  5 |      TABLE ACCESS FULL| PRODUCT            |    25 |   575 |    68   (0)| 00:00:01 |<font></font>
|*  6 |      INDEX RANGE SCAN | SHIPMENTDETAIL_P_S |   198 |  1980 |     2   (0)| 00:00:01 |<font></font>
--------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   5 - filter("PR"."NAME" LIKE 'Product 86%')<font></font>
   6 - access("S"."PRODUCT"="PR"."ID")<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリは引き続き迅速に実行されますが、1つの行のチェックが消えたということは憂慮すべきことであり、これは多くのレコードがある場合に非常に重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、今、私たちはすべての商品の要求を満たします。</font></font><br>
<br>
<pre><code class="sql">SELECT MAX(cc.ls) <font></font>
        FROM Product pr<font></font>
        LEFT JOIN (SELECT MAX(shipment) AS ls, s.product<font></font>
            FROM shipmentDetail s<font></font>
            GROUP BY s.product) cc ON cc.product=pr.id<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 2.6<br>
<pre>-------------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                | Name               | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |<font></font>
-------------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT         |                    |       |       |       | 22222 (100)|          |<font></font>
|   1 |  SORT AGGREGATE          |                    |     1 |    31 |       |            |          |<font></font>
|   2 |   NESTED LOOPS SEMI      |                    | 50001 |  1513K|       | 22222   (2)| 00:00:01 |<font></font>
|   3 |    VIEW                  |                    | 50536 |  1283K|       | 22219   (2)| 00:00:01 |<font></font>
|   4 |     HASH GROUP BY        |                    | 50536 |   493K|   191M| 22219   (2)| 00:00:01 |<font></font>
|   5 |      INDEX FAST FULL SCAN| SHIPMENTDETAIL_P_S |    10M|    95M|       |  7871   (1)| 00:00:01 |<font></font>
|*  6 |    INDEX UNIQUE SCAN     | SYS_C007890        | 49472 |   241K|       |     0   (0)|          |<font></font>
-------------------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   6 - access("CC"."PRODUCT"="PR"."ID")<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、Oracleは1つの行にチェックを挿入することを推測していませんが、通常、JPPDなしのHash Group Byに切り替え（ただし、1つの行をチェックしなくても論理的です）、この要求を数秒間実行しています。</font><font style="vertical-align: inherit;">同時に、このクエリをORDER BYおよびrownum = 1のサブクエリ式に書き換えると（つまり、本質的に、1つのレコードを選択するようにOracleに明示的に指示します）、計画は大幅に改善されます。</font></font><br>
<br>
<pre><code class="sql">SELECT MAX(l) FROM (SELECT (SELECT shipment FROM (SELECT shipment FROM ShipmentDetail s WHERE s.product = pr.id ORDER BY s.shipment DESC) s WHERE rownum = 1) AS l FROM product pr)
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクルプラン</font></font></b><div class="spoiler_text">  : 300<br>
<pre>----------------------------------------------------------------------------------------------------<font></font>
| Id  | Operation                     | Name               | Rows  | Bytes | Cost (%CPU)| Time     |<font></font>
----------------------------------------------------------------------------------------------------<font></font>
|   0 | SELECT STATEMENT              |                    |       |       |   139K(100)|          |<font></font>
|*  1 |  COUNT STOPKEY                |                    |       |       |            |          |<font></font>
|   2 |   VIEW                        |                    |     2 |    26 |     3   (0)| 00:00:01 |<font></font>
|*  3 |    INDEX RANGE SCAN DESCENDING| SHIPMENTDETAIL_P_S |   198 |  1980 |     3   (0)| 00:00:01 |<font></font>
|   4 |  SORT AGGREGATE               |                    |     1 |     5 |            |          |<font></font>
|   5 |   INDEX FAST FULL SCAN        | SYS_C007890        | 50001 |   244K|    27   (0)| 00:00:01 |<font></font>
----------------------------------------------------------------------------------------------------<font></font>
Predicate Information (identified by operation id):<font></font>
---------------------------------------------------<font></font>
 <font></font>
   1 - filter(ROWNUM=1)<font></font>
   3 - access("S"."PRODUCT"=:B1)<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、リクエストは数百ミリ秒で実行され、10倍高速です。等価述語の定数が明示的に設定されていて、JPPDからのクエリである場合に、Oracleがクエリをさまざまな方法で最適化する理由は謎です。しかし実際には、通常のパフォーマンスのために、開発者は上記のリクエストにあるような松葉杖を挿入する必要があります。さらに、データベースに必要なインデックスがない場合、またはデータベースが「空」の場合（つまり、まだ出荷がなく、商品が多い場合）、そのような松葉杖を使用したリクエストは、基本的なリクエストとOracleが実行する方法に比べてはるかに劣ります。 。つまり、このような最適化はDBMS自体のソリューションであり、統計情報やシステム内のインデックスがわからない開発者ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MS SQLについては、前のセクションでMS SQLに問題があったが、Oracleには問題がなかった場合、すべてが逆になります。</font><font style="vertical-align: inherit;">MS SQLは、トップ1を計画に組み込むと推測しています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 300<br>
<pre>Rows	Executes  Stmt Text<font></font>
1	1	  |--Hash Match(Aggregate, HASH:() DEFINE:([Expr1005]=MAX([Expr1003])))<font></font>
50001	1	       |--Nested Loops(Left Outer Join, OUTER REFERENCES:([pr].[id]))<font></font>
50001	1	            |--Index Scan(OBJECT:([test].[dbo].[product].[product_group] AS [pr]))<font></font>
0	0	            |--Compute Scalar(DEFINE:([Expr1003]=[test].[dbo].[shipmentdetail].[shipment] as [s].[shipment]))<font></font>
50000	50001	                 |--Top(TOP EXPRESSION:((1)))<font></font>
50000	50001	                      |--Index Seek(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_p_s] AS [s]), SEEK:([s].[product]=[test].[dbo].[product].[id] as [pr].[id]) ORDERED BACKWARD)<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、必要に応じてこのリクエストを実行します。</font><font style="vertical-align: inherit;">確かに、LEFのJOINをINNERに置き換えると、トップ1が魔法のように消えて（違いが何であるか、またSQLサーバーが複数のレコードを必要とする理由は明らかではありません）、Oracleと同じ問題があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQLプラン</font></font></b><div class="spoiler_text">  : 2.8<br>
<pre>Rows	Executes  Stmt Text<font></font>
1	1	  |--Hash Match(Aggregate, HASH:() DEFINE:([Expr1003]=MAX([Expr1002])))<font></font>
50000	1	       |--Stream Aggregate(GROUP BY:([s].[product]) DEFINE:([Expr1002]=MAX([test].[dbo].[shipmentdetail].[shipment] as [s].[shipment])))<font></font>
10000001	1	            |--Index Scan(OBJECT:([test].[dbo].[shipmentdetail].[shipmentdetail_p_s] AS [s]), ORDERED FORWARD)<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、実際には、MS SQLでは、MAXを含むすべてのINNER JOINサブクエリをLEFT JOINに変換する必要があります。</font><font style="vertical-align: inherit;">ただし、これはOracleに比べるとそれほど危険ではありません（MAXを使用したサブクエリのすべてのJOINは、rownum = 1を使用したサブクエリ式に変換する必要があります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、上記の最適化にもかかわらず、MAX / MINアプローチには2つの非常に重大な欠点があります。</font><font style="vertical-align: inherit;">つまり、何をすべきか明確ではありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後の値ではなく、最後の値を持つ別のレコードフィールドを返す必要がある場合（配達は日付で最後だとしましょう）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のフィールドの最後のレコードを一度に検索する必要がある場合：つまり、最初に1つのフィールドで、このフィールドが一致する場合は2番目のフィールドで（たとえば、日付で、次に内部識別子で）。 </font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、2つのオプションがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じスタックオーバーフローが提供するのと同じようにウィンドウ関数を使用します。これは、グループの値を取得する必要がある場合にはあまり便利ではありません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタム集計LAST関数の作成。これも、特に同じMS SQLではC＃でこれを実行する必要があり、作成されたファイルをコンパイルしてからサーバーにアップロードする必要があります（ただし、これはずっと前のことですが、おそらく最近のバージョンでは）何かが変わった）</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最も重要なのは、どちらのアプローチにも大きなパフォーマンスの問題があることです。したがって、ウィンドウ関数の場合、JPPDは原則としてサポートされません。また、カスタム集計関数では、上記のFIRST ROW / LIMIT 1最適化は使用されません。もちろん、その欠如の問題は多少誇張されているように見えるかもしれませんが、実際には過小評価することはできません。この問題は、データ量が増えるにつれて特に重要になります。つまり、システムの1か月の運用後、すべてが正常に機能しますが、5〜10年が経過すると、クエリを実行して頻繁に変更されるデータの最後の値を計算すると（たとえば、毎日来る人気のあるミルクのある位置の到着）、DBMSは非常に古いデータ。最初に、プロセッサだけでなくストレージシステムにも追加の負荷がかかります。2番目に、SQLサーバー上のデータキャッシュのローテーションにつながり、システム全体のパフォーマンスに大きな影響を与える可能性があります。</font></font><br>
<br>
<a name="nplusone"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題N + 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムがSQL（またはその拡張機能PL / SQL、T-SQLなど）で記述されている場合、同じクエリを繰り返し実行しても、パラメータが異なるため、自動的に問題が発生しないという意見が広まっています。</font><font style="vertical-align: inherit;">そして、これは完全に真実ではありません。</font><font style="vertical-align: inherit;">概して、SQL拡張機能では、N + 1の問題は、同じORMフレームワークの同じ問題と大差ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のようなストアドプロシージャがあります。</font></font><br>
<br>
<pre><code class="sql">   -- <font></font>
   CREATE PROCEDURE TestProcedure <font></font>
   (<font></font>
        -- <font></font>
        @CategoryId INT,<font></font>
        @ProductName VARCHAR(100),<font></font>
        @Price MONEY = 0<font></font>
   )<font></font>
   AS<font></font>
   BEGIN<font></font>
        --,   <font></font>
        <font></font>
        --  <font></font>
        --         <font></font>
        SET @ProductName = LTRIM(RTRIM(@ProductName));<font></font>
        <font></font>
        --  <font></font>
        INSERT INTO TestTable(CategoryId, ProductName, Price)<font></font>
                VALUES (@CategoryId, @ProductName, @Price)<font></font>
<font></font>
        -- <font></font>
        SELECT * FROM TestTable<font></font>
        WHERE CategoryId = @CategoryId<font></font>
   END<font></font>
<font></font>
   GO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この手順を1000レコードに対して実行する必要があります。</font><font style="vertical-align: inherit;">そして、ここには2つのオプションがあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストアドプロシージャをループで実行し、1000 INSERTおよび1000 SELECTを取得します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の手順を実行しますが、一時テーブル/テーブル変数を使用して、開発者に貴重な時間を費やすと同時に、DRYの原則に違反して技術的負債を増やします。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのパラメータが一時テーブル/テーブル変数で転送されるようにすべてのストアドプロシージャを設計できることは明らかですが、これは、控えめに言っても、あまり便利ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ストアドプロシージャで何らかの回避策がまだある場合は、多くのSQLサーバーでトリガーを使用すると、さらに事態が悪化します。</font><font style="vertical-align: inherit;">ここでは、トリガーが呼び出されるタイミングがわからないため、書き換える必要はありません。</font><font style="vertical-align: inherit;">理論的には、SQLサーバーのN + 1の問題を解決するために、ステートメントごとのトリガーがあります（行ごとではありません）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OracleとPostgreSQLでは、それらの新しい値と以前の値にアクセスすることはできません。つまり、そのようなトリガーは完全ではなく少し役に立たないです。</font></font><br>
</li>
<li> MS SQL  per statement     inserted  deleted,   ,   .      N+1,  ,        . <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、公平に言うと、MS SQLではすべてのトリガーが挿入と削除を使用して行われ、どこでも同じテーブルへのすべての変更は1つのコマンドで実行する必要があるというルールに従います（ただし、上記のN + 1の問題のコンテキストでこれを実現する方法は明確ではありません）。ストアドプロシージャを使用すると）、N + 1の問題をほぼ完全に解消し、システム内のすべての既存のビジネスルールを最小限のSQLクエリでサポートできます。この意味で、MS SQLはOracleに有利なスタートを切ります（正直に言うと、Oracleが同様の仮想テーブルをサポートすることで何が問題であったのかはまだわかりません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD：バージョン10以降のPostgreSQLの聴衆からのもう1つのヒントは、いわゆる遷移テーブル（new_tableおよびold_table）です。その機能は、MS SQLでの挿入および削除に似ています。</font></font><br>
<br>
<a name="physmodel"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベース設計における高額のエラー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の問題の大部分をデータベース開発者に示す場合、最初に聞こえるのは「はい、データベースモデルが間違っています」です。</font><font style="vertical-align: inherit;">さらに、この「間違ったモデル」は、すべての問題を解決する理由と手段の両方であると想定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての問題の原因として「間違ったモデル」を見ると、「間違った」という用語の使用はまったく明確ではありません。通常、システムを作成するとき、そこにどんな統計が存在するかだけでなく、このシステムのどのような機能が原則として5〜10年後に予測できるかは不可能です。絶えず変化することは、あらゆるビジネス（特に競争市場における）の主要な機能の1つであり、ビジネス自体とともに、ITシステムを（このビジネスのミラーとして）変更することも必要です。そして、最初は正しかったことは、その後すぐに間違ってしまう可能性があります。したがって、誰かがデータベースを誤って設計したと非難した場合、その人に安全に石を投げることができます。彼のデータベースの要件が正しい方法で変更された場合（これは避けられないことです）、彼のモデルも間違っていると確信しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を解決する手段として「間違ったモデル」を使用することはさらに困難です。最初のセクションで見たように、最新のSQLサーバーにおけるデータベースの正規化/非正規化は、それほど単純で透過的なプロセスではありません。全然言葉から。ただし、いくつかのフィールドを別のテーブルから1つのテーブルに移動したり、その逆を行ったりして、1つのテーブルのいくつかのフィールドを別のテーブルに分解する必要がある場合でも、ほとんど問題なく、かなりの数のクエリをレコードとして書き直す必要があります。そして読書。ここではもちろん、すべての同じビューが役立つ可能性がありますが、残りのセクションで見たように、ビューはテーブルがサポートするすべて（特に、制約、トリガー、インデックス）をサポートしているわけではなく、問題がありますFULL JOINなどを使用した場合のパフォーマンスしたがって、テーブルを取得してビューに置き換えるのは非常に簡単です。ほとんどの場合、機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、データベース開発者の作業は危険で困難であり、優れた分析的思考だけでなく、特別な感覚能力も必要とします。これは、データベースの設計ミスは非常に高くつくためです。</font></font><br>
<br>
<a name="manyjoins"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多数のJOINを処理する場合の予測不可能な最適化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近のSQLサーバーでは、いわゆるコストベースオプティマイザー（CBO）を使用して、クエリプランを構築します（特に、JOIN順序を決定します）。多くの場合、これは非常に複雑でスマートなメカニズムとして提示され、関数のインデックスからパーティションテーブルやインデックスまで、内部の膨大な量の情報が実際に考慮されますが、この量の情報が残酷なジョークを演じます-アルゴリズム的にはこれは単なるバストにすぎません。これは、他の列挙と同様に、CBOの作業の複雑さがjoin'ovの数から指数関数的に増加することを意味します。さらに、これはサブセットではなく順列の列挙であるため、この列挙の複雑さは一般に宇宙-O（n！）です。つまり、12個のjoin'ovの選択肢でさえ、その順列は約4800万になります。プラン検索アルゴリズムにクリッピングがあることは明らかですしかし、非常に多くのオプションがあり、それでも助けにはなりません。したがって、多数のjoin'ovを備えたほとんどすべてのSQLサーバーは、さまざまなヒューリスティックに切り替えます。ここで、一部のSQLサーバーに問題があります。そのため、PostgreSQL GEQOでは、アルゴリズムは非常に明白なオプションをスキップします。たとえば、クエリでは、共通の条件を持つテーブルからjoin'ovの距離が8を超えるクエリにある1つの小さなテーブルがあり、この場合、テーブルは最後に結合されます。クエリには、単一の小さなテーブルが1つ存在する可能性があります。これは、クエリ内に、共通の条件があるテーブルからjoin'ovの距離が8を超えている場合です。この場合、テーブルは最後に結合されます。クエリには、単一の小さなテーブルが1つ存在する可能性があります。これは、共通の条件を持つテーブルからjoin'ovの距離が8を超えるクエリにあり、この場合、テーブルは最後に結合されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、経験から、多数の結合を処理する場合、次のアプローチが最も効果的であることがわかります。最小限の先読みで貪欲にして、最も明白な結合順序を決定し、この結合順序（指定された結合順序ではなく）でコストベースの最適化で検索を開始します。リクエストに応じて）。</font><font style="vertical-align: inherit;">MS SQLとOracleがそれを行うことは可能ですが、それらが使用するヒューリスティックに関する特定の情報を見つけることは非常に困難です（PostgreSQLとは異なります）。</font><font style="vertical-align: inherit;">Everywhereは、次のスタイルで何かが書かれています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このヒューリスティックでは、高度な方法を使用</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
して、ほぼ最適であるか、少なくとも非常に</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優れた実行プラン</font><font style="vertical-align: inherit;">である可能性が高い検索スペース内の</font><font style="vertical-align: inherit;">特定の</font><font style="vertical-align: inherit;">プラン</font><font style="vertical-align: inherit;">を瞬時に見つけ</font><font style="vertical-align: inherit;">ます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残念ながら、これらのスクリプトをMS SQLとOracleでライブでテストすることはできませんでした（これらのスクリプトは同時に大量のデータと複雑なロジックを必要とするため）、将来的にはこれが可能になることを願って、追加しますこの情報の記事。</font></font><br>
<br>
<a name="inherit"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遺伝の欠如と多型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承とポリモーフィズム（以下、サブタイプポリモーフィズムと呼ぶ）は、SQLが登場するずっと前に登場しました。また、システムの複雑さが増大してもタスクを効率的に分解し、技術的負債を増加させないため、プログラミングに小さな革命を起こし、システムをより多く作成することができました。以前存在していたものよりも複雑です（ところで、プログラミングの同じ革命は、一度に抽象化され、世界に、特に構造化プログラミングを与えました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なプロジェクトでこれら2つのメカニズムの有用性がそれほど明白でない場合、このプロジェクトが成長するにつれて、コードを1つの大きな「スパゲッティコード」に変換することの主な障壁の1つは継承と多態性です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この点に関して、最近のSQLサーバーで何ができるか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MS SQLは単純です-彼らはどちらの継承もサポートしようとはしませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLは正式にテーブルを継承しますが、それ以上のものはありません。</font><font style="vertical-align: inherit;">また、ポリモーフィズムなしでは継承に実質的な意味がないことを考えると、PostgreSQLで継承がまったく追加された理由は不明です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、構造プログラミングとの類似性を描くと、SQLのポリモーフィズムは、理論的には、さまざまなUNIONを実装として追加できる抽象表現を作成する機能に似ているはずです。つまり、次のようになります。</font></font><br>
<br>
<pre><code class="sql">CREATE ABSTRACT VIEW detail (document LONG, quantity NUMBER);<font></font>
<font></font>
EXTEND VIEW Detail<font></font>
	SELECT receipt AS document, quantity FROM receiptDetail;<font></font>
…<font></font>
EXTEND VIEW X<font></font>
	SELECT shipment AS document, quantity FROM shipmentDetail;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、PostgreSQLでも他のSQLサーバーでもそのような可能性はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オラクルは「ヘビとヘビ」を横断することにしました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス、オブジェクト、およびカプセル化を使用して、古典的なOOPを言語に追加する</font></font><br>
</li>
<li>        .<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、それは非常にあいまいです。まず、メソッド（MEMBER FUNCTION / PROCEDURE）では、N + 1の問題があります。第2に、複数のキーを持つテーブル（たとえば、Product and Warehouse）をどうするかは明確ではありません。もちろん、商品倉庫のような代理クラスを作成することもできますが、その継承をどうするかは明確ではありません。クラスProductMagazinとTovarcを作成しますか？次に、ジェネリックが存在しないクラスでは、ストアと商品をリンクするときにストアが製品を取得する必要があるため、SQLサーバーがどのように検出する必要があるかが明確でないため、一般的な混乱が生じます。一般に、結果のメカニズムには、回答よりも多くの質問があります。その結果、Oracleでの型とその継承の状況は、実体化された表現の場合とほぼ同じです-多くの人が聞いたことはありますが、特定のケースで実際に使用されている人はほとんどいません。</font></font><br>
<br>
<a name="abst"></a><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存じのとおり、SQLはリレーショナル代数の言語、つまりテーブルを操作するための言語です。さらに、データベース内のテーブルの大部分は、原則として、第2正規形（キーを持つ）です。つまり、どのテーブルも関数のセットと見なすことができます。つまり、キー（関数パラメーター）の列（関数値）へのマッピングです。さらに、テーブルに対するすべての操作は依然としてリレーショナル代数で実行されます。つまり、結合および結合操作の助けを借りて、不要な複雑さがさらに発生します。たとえば、結合操作は2つのテーブルのデカルト積であり、たとえば、普通の人にとってはそれほど明白ではありません（いずれにしても、生活の中で、このような操作に遭遇することはほとんどありません）。また、SQLの経験がない人にこの操作を正式に説明しようとしましたが、成功しませんでした。結局のところ、それはすべてトレーニングの「サルの方法」に帰着しました。そのような情報を取得する必要があります-このリクエストを使用して、他の情報-別のリクエストなど。しかし、公平に言えば、どうなるかと聞いても、LEFT JOINテーブルを作成し、接続条件にすべてのキーを指定しないと、真剣に頭を痛めざるを得ません。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとします。また、私はリリースノートで個人的に言及されていました（クエリは結合からのものだったためです）と=、つまり、バグの中心となる場所はありません）そのような情報を取得する必要があります-この要求を使用し、別の情報-別の要求などを使用します。しかし、公平に言えば、どうなるかと聞いても、LEFT JOINテーブルを作成し、接続条件にすべてのキーを指定しないと、真剣に頭を痛めざるを得ません。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとします。また、私はリリースノートで個人的に言及されていました（クエリは結合からのものだったためです）と=、つまり、バグの中心となる場所はありません）そのような情報を取得する必要があります-この要求を使用し、別の情報-別の要求などを使用します。しかし、公平に言えば、どうなるかと聞いても、LEFT JOINテーブルを作成し、接続条件にすべてのキーを指定しないと、真剣に頭を痛めざるを得ません。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとしましょう。また、リリースノートで個人的に言及されたことさえあります（クエリは結合からのものだったためです）と=、つまり、バグの中心となる場所はありません）その他の情報-別のリクエストなど。しかし、公平に言えば、どうなるのかと尋ねても、LEFT JOINテーブルを作成して、接続条件にすべてのキーを指定しないと、真剣に頭を痛めざるを得なくなります。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとしましょう。また、リリースノートで個人的に言及されたことさえあります（クエリは結合からのものだったためです）と=、つまり、バグの中心となる場所はありません）その他の情報-別のリクエストなど。しかし、公平に言えば、どうなるかと聞いても、LEFT JOINテーブルを作成して、接続条件にすべてのキーを指定しないと、真剣に頭を痛めざるを得なくなります。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとしましょう。また、リリースノートで個人的に言及されたことさえあります（クエリは結合からのものだったためです）と=、つまり、バグの中心となる場所はありません）私は真剣に脳を壊さなければなりません。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとします。また、私はリリースノートで個人的に言及されていました（クエリは結合からのものだったためです）と=、つまり、バグの中心となる場所はありません）私は真剣に脳を壊さなければなりません。つまり、テーブルを作成できますが、論理的には意味のないデータになります。あるカルトシリーズで述べたように、「彼女は理解していますが、彼女は理解していません。」私はSQLの経験があります。たとえば、最小ではなく、PostgreSQLのバグにつながるような複雑なクエリを使用しなければならなかったとします。また、私はリリースノートで個人的に言及されていました（クエリは結合からのものだったためです）と=、つまり、中心的なバグはどこにもありません）彼らはPostgreSQLのバグを引き起こし、リリースノートで個人的に私に言及したことさえありました（リクエストは結合と=からのものだけだったので、つまり、バグはより集中的に進む場所がありません）。それらはPostgreSQLのバグにつながり、リリースノートで個人的に私に言及したことさえあります（リクエストは結合と=からのものだけだったため、バグはより集中的に進むべき場所がありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過度に複雑な問題を解決する別の方法は、SQLでリレーショナル代数ではなく-テーブル、結合ではなく、関数や構成で-関数的に使用することです。</font><font style="vertical-align: inherit;">しかし、この話題はすでに別々に詳細に論じた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、ここで私は（明確にこれら二つのアプローチの違いを実証するための）2 *との問題の例を与える、</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能代数</font></font></b><br>
<br>
<pre><code class="sql">SELECT Person a, Person b, Person c WHERE <font></font>
    likes(a, c) AND NOT friends(a, c) AND <font></font>
    (friends(a, b) OR friends(b, a)) AND <font></font>
    (friends(b, c) OR friends(c, b));<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関係代数</font></font></b><br>
<br>
<pre><code class="sql">WITH PersonRelationShipCollapsed AS (<font></font>
  SELECT pl.PersonAID<font></font>
        ,pl.PersonBID<font></font>
        ,pl.Relation <font></font>
  FROM #PersonRelationShip      AS pl <font></font>
  <font></font>
  UNION <font></font>
<font></font>
  SELECT pl.PersonBID AS PersonAID<font></font>
        ,pl.PersonAID AS PersonBID<font></font>
        ,pl.Relation<font></font>
  FROM #PersonRelationShip      AS pl <font></font>
)<font></font>
SELECT <font></font>
   pl.PersonAID<font></font>
  ,pf.PersonBID<font></font>
  ,pff.PersonBID<font></font>
FROM #Persons                      AS p<font></font>
--                      <font></font>
JOIN PersonRelationShipCollapsed  AS pl ON pl.PersonAID = p.PersonID<font></font>
                                 AND pl.Relation  = 'Like'                                  <font></font>
--                          <font></font>
JOIN PersonRelationShipCollapsed  AS pf ON pf.PersonAID = p.PersonID <font></font>
                                 AND pf.Relation = 'Friend'<font></font>
--                    <font></font>
JOIN PersonRelationShipCollapsed  AS pff ON pff.PersonAID = pf.PersonBID<font></font>
                                 AND pff.PersonBID = pl.PersonBID<font></font>
                                 AND pff.Relation = 'Friend'<font></font>
--                     <font></font>
LEFT JOIN PersonRelationShipCollapsed AS pnf ON pnf.PersonAID = p.PersonID<font></font>
                                   AND pnf.PersonBID = pff.PersonBID<font></font>
                                   AND pnf.Relation = 'Friend'<font></font>
WHERE pnf.[PersonAID] IS NULL <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてすでに読者自身がこれらのアプローチのどちらがより簡単であるかを決めることができます。</font></font><br>
<br>
<a name="ao"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適応最適化（AO）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効果的な実行プランを構築するための重要な条件の1つは、テーブル/サブクエリの結合結果の統計を正しく評価することです。したがって、両方の結合されたテーブルにレコードが少ないか、どちらか一方のテーブルにそれらがほとんどなく、2番目に結合条件に従ってインデックスがある場合、（ネストされたループ結合）を使用して、他の場合には原則としてこれらのテーブルを結合できます、ハッシュ結合またはマージ結合を使用する方が効率的です。しかし、計画担当者がレコードが少ないと思ったが、実際にはたくさんあったとしたらどうなるでしょうか。実際には何も良いことではありません。さらに、最も壊滅的な結果は、プランナが両方のテーブルにレコードが少ないと考えた場合ですが、たとえば、それぞれのレコードが10kレコードであることがわかりました。この場合、SQLクエリの実行中に、サーバーは1億レコードを実行する（またはそのようなテーブルを構築する）必要があり、プロセッサー（特に並列処理が有効になっている場合）とメモリー（永続的、つまりストレージを含む）の両方に大きな負荷がかかります。 。また、SQL Serverの統計情報は多くの場合誤っている可能性があり、最も一般的なものは不均一な統計情報とデータの相関です。もちろん、SQL Serverはできる限りこれらの現象と戦います（たとえば、最も一般的な値、列間統計、さまざまなヒストグラムなどを格納します）。ただし、これらのすべての手法を使用しても、クエリに多数のテーブルがある場合、確率は統計のエラーはまだかなり高いです。メモリー用（永続的、つまりストレージを含む）。また、SQL Serverの統計情報は多くの場合誤っている可能性があり、最も一般的なものは不均一な統計情報とデータの相関です。もちろん、SQL Serverはできる限りこれらの現象と戦います（たとえば、最も一般的な値、列間統計、さまざまなヒストグラムなどを格納します）。ただし、これらのすべての手法を使用しても、クエリに多数のテーブルがある場合、確率は統計のエラーはまだかなり高いです。メモリー用（永続的、つまりストレージを含む）。また、SQL Serverの統計情報は多くの場合誤っている可能性があり、最も一般的なものは不均一な統計情報とデータの相関です。もちろん、SQL Serverはできる限りこれらの現象と戦います（たとえば、最も一般的な値、列間統計、あらゆる種類のヒストグラムなどを格納します）。ただし、これらすべての手法を使用しても、クエリに多数のテーブルがある場合、確率は統計のエラーはまだかなり高いです。列間統計、すべての種類のヒストグラムなど）ですが、これらの手法をすべて使用しても、クエリに多数のテーブルがある場合でも、統計のエラーの確率は非常に高くなります。列間統計、あらゆる種類のヒストグラムなど）ですが、これらの手法をすべて使用しても、クエリに多数のテーブルがある場合でも、統計のエラーの確率は非常に高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなエラーに対するサーバーの耐性を高めるために、SQLサーバーは次の手法を使用します。レコードの予測数が特定のしきい値未満である場合、理論的にはネストされたループ結合を使用する必要がある場合、プランに代替ブランチ（いわゆるアダプティブ結合）を挿入します。実際のレコード数が予測を大幅に超えた場合にアクティブになります。</font><font style="vertical-align: inherit;">特に、この手法は、前述の最も「破壊的な」シナリオを排除します-ネストされたループ結合を使用して2つの巨大なテーブルを結合します。</font><font style="vertical-align: inherit;">ただし、JPPDと同様に、AOにはいくつかの欠点があります。</font></font><br>
<br>
<a name="commao"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AO：商用DBMSでのみサポート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムはPostgreSQLではサポートされていません。実際、MSSQLでさえ、そのサポートは2年前に登場しただけなので、近い将来にPostgreSQLでサポートされることを期待する理由はありません。さらに悪いことに、PostgreSQLはまれな楽天家です。したがって、PostgreSQLが選択性を認識していない場合、0.3に等しいと見なされます（実際にそのような定数はコードにハードコーディングされています）。さらに、2つの接続条件について何も認識していない場合、それらは無相関であると見なし、単に選択性を増加させます。その結果、彼は中間テーブルに1つのレコードがあると非常によく考えます。たとえば、クエリに複数のサブクエリ（「不明」クラスに分類されることが多い情報）が含まれている場合、彼はうらやましいほどの規則性で自分自身を撃ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、JPPDの欠如とGEQOの予測不能性を考えると、PostgreSQLが複雑なクエリで効率的に動作するように当初計画されていなかったと思われます。</font><font style="vertical-align: inherit;">したがって、AOの欠如と過度の楽観性は、このパラダイムに完全に適合します。</font></font><br>
<br>
<a name="incorrao"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AO：エラーの確率はまだ十分に高い</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されているアダプティブジョイン手法は、極端なケースを排除しますが、特定の脆弱性がまだあります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、しきい値は推定値に依存するため、正確な推定値は依然として重要です。 </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、オプティマイザが下側ではなく上側でミスをした場合、アダプティブ結合は作成されません。たとえば、SQLサーバーは、必要なときにインデックスを使用しない可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、このようなスキームでは、統計が誤って小さい結合が最初に正しく配置されず、「正しい」結合が最初から開始されない場合があります。</font><font style="vertical-align: inherit;">同時に、SQLサーバーがエラーを検出すると、手遅れになります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アダプティブプランでは結合順序を変更できないため、より優れた結合方法または並列分散方法を使用しても、実行計画は最適ではない可能性があります。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの問題の少なくとも部分的な解決策として、適応型結合に加えて、Oracleはいわゆる適応型統計もサポートしています。</font><font style="vertical-align: inherit;">実行中のクエリの各結合について実際の統計を収集し、次に同じクエリを実行するときにそれを使用して、必要に応じて再スケジュールすることができます。</font><font style="vertical-align: inherit;">ただし、このメカニズムにはいくつかの問題もあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストの2回目の実行時にのみオンになります（この場合、たとえば、リクエストで別の一時テーブルが使用されている場合、別のリクエストと見なされます。つまり、このメカニズム全体が機能しません）。</font></font><br>
</li>
<li>            (  99%     ),     .   ,   Oracle           OLTP .<br>
<blockquote>The reasoning for this is many of these optimizations are more appropriate for data warehousing, where there optimization time is is a small proportion of the query runtime. In OLTP environments, where SQL runtime is typically smaller, the additional optimization time may become a significant part of the elapsed time, for little extra benefit.</blockquote></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、より簡単で多くの点でさらに効果的な適応最適化手法があります。その意味は、リクエストを実行するための合計推定時間を（ある程度のマージンを確保して）決定し、それを超える場合は、リクエストをキャンセルし、その中のサブクエリの一部を具体化し（スコアリングによって最も適切なものを決定する）、このリクエストを再度実行してみます。サブクエリは一時テーブルに保存され、サブクエリには非常に詳細な統計があるため、基本的なクエリと比較して、オプティマイザが効果的なプランを作成するのがはるかに簡単になります。当然、新しいランタイムに関するすべての情報、サブクエリの具体化がリクエストの迅速な実行に役立ちました。キャッシュして、後続の実行で使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ここでは、このアプローチにはいくつかの追加条件を満たす必要があると言わざるを得ません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブクエリを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マテリアライズ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">前に、「一般的なケースのJPPD」</font></a><font style="vertical-align: inherit;">を実行する必要があります</font><font style="vertical-align: inherit;">（つまり、プッシュされた上位クエリの述語を収集し、それらをグループ化するなど）。それ以外の場合、サブクエリは、上位クエリが必要とするデータだけでなく、データベース全体に対して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">マテリアライズされ</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">したがって、少なくともそのようなJPPDの可能性をサポートする必要があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムアーキテクチャは、リクエストのキャンセルをサポートする必要があります。したがって、トランザクション全体を、その後の再起動でサポートする必要があります。</font><font style="vertical-align: inherit;">ただし、更新の競合やデッドロックの操作も含め、このような操作のサポートが必要であるため、まだ実装する必要があります（もちろん、手動ロックに悩まされたくない場合は、次の記事で詳しく説明します）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の手法により、正確にサブクエリの統計を絞り込むことができます。</font><font style="vertical-align: inherit;">もちろん、これを使用して結合結合の中間結果の統計を改善することもできますが、はるかに複雑で信頼性が低くなります。</font><font style="vertical-align: inherit;">さらに、ほとんどの場合、SQLサーバーはサブクエリの統計で正確に誤っており、実際に示されているように、サブクエリの具体化は、適応最適化のメカニズムとして機能し、非常にうまく機能します。</font><font style="vertical-align: inherit;">一方、アダプティブジョインと組み合わせると、このメカニズムはさらにうまく機能し、ご存知のように最高のものは善の敵です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、商用SQLサーバーは多くの複雑な機能と最適化をサポートしていますが、ほとんどの場合、実際にこれらの機能を使用する方がコストがかかるような方法でそれを行います。</font><font style="vertical-align: inherit;">ほとんどすべてのステップで足を撃つことができ、一部の最適化の使用はLinuxでのウイルスのインストールに関する冗談に似ています-これらの最適化は開発者を保護する必要があるので、逆に機能させる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLは基本的な最適化機能（特にJPPD）もサポートしていないため、MS SQLやOracleでよく行われているように、ビジネスロジックの主要部分を開発するためにそのまま使用することは、率直に言って非常に面倒でリスクが伴います。</font><font style="vertical-align: inherit;">2つのオプションがあるので、誰かがクロスプラットフォームのDBMS（PostgreSQLを含む）を持っていると主張するのはさらに楽しいです。</font></font><br>
<br>
<ul>
<li>      ORM,   , ,   ,          . <br>
</li>
<li> PostgreSQL  ,       100 ,     ,  : “       ,  MS SQL  Oracle”. - , ,     . ,    ,       Oracle  PostgreSQL              Oracle (   ).        : « ?    PostgreSQL  ,        »<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者の視点から問題を見ると、これですべてです。 DBAの観点から見ると、それはさらに悪いことです。物理モデルを個別に変更（つまり、データの正規化/非正規化、テーブル間のデータ転送）することはできません。 DBAが実行できる最大のことは、追加のインデックスを作成することです。それ以外の場合は、開発者に連絡する必要があります。後者には異なるKPIがあり、一般に「彼はすべてを正しく書き込んだため、MS SQL / Oracleが遅くなり、何らかの方法で構成します。同氏は、「状況は、急速に行き詰まっている。そして、最良の場合はスキャンダルにつながり、最悪の場合はシステム全体を変更/書き直すことになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、もちろん、問題が発生する可能性があります。なぜこの記事を愚か者が批判すべきなのでしょうか。そして、正直なところ、説明されているすべての問題が解決できることを知らなかった場合は、この記事を書きません。はい、簡単ではありません。非常に難しいと言ってもいいでしょうが、商用DBMSは世界最大の企業の1つです。そして、彼らは「世界で最高のエンジニア」を持っています。したがって、問題を解決しなければならないとき、「ここで何かがおかしい」と思わずに思わずに気づくでしょう。しかし、それは彼らの良心に任せます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、彼らが言うように、広告の分。上記の問題はすべて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">lsFusionで</font></a><font style="vertical-align: inherit;">解決され</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、一般的なケースでそれを行います。データの透過的な実体化（非正規化）、計算データに対する制限とトリガー、一般的なJPPD、動的物理モデル、ブールロジックのコンパクトで同時に高速なオプティマイザー、クエリへのサイクルのコンパイルとその逆、スパースデータと最近の値を使用した作業の最適化、多重継承ポリモーフィズム-そしてこれは氷山の一角にすぎません。これらすべてに加えて、プレゼンテーションロジックや他の多くの純粋な言語機能もありますが、これはSQLに直接関係していないため、次の記事で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、なぜlsFusionとDBMSを比較するのかについて常に批判されており、この記事がこの質問に対する回答の少なくとも一部を提供したことを願っています。はい、ラストマイル（JOIN実行タイプの定義-ループ/ハッシュ/マージ、ACIDサポートなど）lsFusionは閉じず、RDBMSを使用しますが、概してlsFusion実装の機能であり、開発者はそれを認識しません（望まない場合） 、 もちろん）。さらに、重要な点は、すべてのクエリを最適化する責任はlsFusionにあるため、RDBMSとして最も基本的なPostgreSQLを使用できることです。この意味で、lsFusionはPostgreSQLの一種のアイアンマンコスチュームと見なすことができ、クエリの最適化に関して、MS SQLとOracleの「超能力」を提供します。その中で、通常のエディションで後者がコアあたり14,000ドルの場合、lsFusion + PostgreSQLバンドルは完全に無料です。ただし、この事実には裏返りがあり、MS SQLまたはOracleを商用運用するようにお客様に確信していないため、商用DBMSの多くの事柄がテストベンチでのみテストされました。いくつかのエラー。誰かがそのようなエラーをどこかで見つけた場合、コメントでそれについて書いてください、そして私たちは間違いなくそれを修正します。したがって、商用DBMSの多くのものがテストベンチでのみテストされました。これは、記事にエラーが含まれている可能性があることを意味しています。誰かがそのようなエラーをどこかで見つけた場合、コメントでそれについて書いてください、そして私たちは間違いなくそれを修正します。したがって、商用DBMSの多くのものがテストベンチでのみテストされました。これは、記事にエラーが含まれている可能性があることを意味しています。誰かがそのようなエラーをどこかで見つけた場合、コメントでそれについて書いてください、そして私たちは間違いなくそれを修正します。</font></font><br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463073/index.html">QUICの実際：Uberがパフォーマンスを最適化するためにどのように実装したか</a></li>
<li><a href="../ja463075/index.html">新しいオープンソースライセンス</a></li>
<li><a href="../ja463083/index.html">iPhoneバックアップの保護</a></li>
<li><a href="../ja463085/index.html">ケージリモートファイルアクセスシステム</a></li>
<li><a href="../ja463089/index.html">ローコードプラットフォームを使用した機械設計者向けの企業検索システムの実装</a></li>
<li><a href="../ja463097/index.html">ゴー製品開発：1つのプロジェクト履歴</a></li>
<li><a href="../ja463099/index.html">1000と1フィードバック。自分にフィードバックを与え、他人にラモダの経験を教える方法</a></li>
<li><a href="../ja463101/index.html">負荷テストのための何百ものサーバーの管理：自動スケーリング、カスタムモニタリング、DevOpsカルチャ</a></li>
<li><a href="../ja463105/index.html">Haikuでの4日目：インストールとブートの問題</a></li>
<li><a href="../ja463107/index.html">ShIoTiny：小さな自動化、モノのインターネット、または「休暇の6か月前」</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>