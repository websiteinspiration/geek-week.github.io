<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👟 👩🏾‍🏭 👇🏾 Complicação dos comandos do console, 1979-2020 🔂 🌠 👩🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meu hobby é abrir a “Filosofia UNIX” de McIlroy em um monitor enquanto lê mana em outro. 
 
 O primeiro dos princípios de McIlroy é frequentemente ref...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Complicação dos comandos do console, 1979-2020</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499090/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meu hobby</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é abrir </font><font style="vertical-align: inherit;">a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Filosofia UNIX”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de McIlroy em um monitor enquanto lê mana em outro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro dos princípios de McIlroy é frequentemente reformulado como "Faça uma coisa, mas faça bem". </font><font style="vertical-align: inherit;">Esta é uma abreviação para suas palavras: “Crie programas que fazem uma coisa bem. </font><font style="vertical-align: inherit;">Para novos trabalhos, crie novos programas, em vez de complicar os antigos, adicionando novas "funções". ” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
McIlroy dá um exemplo:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece surpreendente para os estrangeiros que os compiladores UNIX não emitem listagens: a impressão é melhor realizada e configurada com mais flexibilidade usando um programa separado.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você abrir a ajuda para </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ele começará com </font></font><br>
<br>
<code>ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]</code> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, os sinalizadores de uma letra para </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incluir todas as letras minúsculas, exceto </font></font><code>{jvyz}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 letras maiúsculas </font></font><code>@</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">São 22 + 14 + 2 = 38 apenas opções de caractere único.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Ubuntu 17, a ajuda para </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não mostrará um resumo normal, mas você verá que </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existem 58 opções (incluindo </font></font><code>--help</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>--version</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver se esta é uma situação única ou uma situação normal. </font><font style="vertical-align: inherit;">Vamos fazer uma lista de alguns comandos comuns, classificados por frequência de uso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/sp/zk/qxspzkpgmcfhcurcd_z7st49s2y.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela mostra o número de opções de linha de comando para vários comandos v7 Unix (1979), slackware 3.1 (1996), ubuntu 12 (2015) e ubuntu 17 (2017). </font><font style="vertical-align: inherit;">Quanto mais parâmetros, mais escuras as células (em escala logarítmica). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que, ao longo dos anos, o número de opções aumenta drasticamente: como regra, os registros escurecem da esquerda para a direita (mais opções) e não há casos em que os registros se tornam mais claros (menos opções). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
McIlroy </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">há muito tempo condenou o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aumento no número de opções, tamanho e funcionalidade geral das equipes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup></a><a name="1_1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote>  ,     ,     Linux … [].   ,      ,    .   ,     <i></i>,        …      Unix  : « ?    ?»     ,        - ,         .  ,   , ,     .        …   ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ironicamente, uma das razões para o crescente número de opções de linha de comando é o outro ditado de McIlroy: "Escreva programas para processar fluxos de texto porque é uma interface universal" (veja </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como exemplo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se dados ou objetos estruturados foram transmitidos, a formatação pode ser deixada no estágio final. Mas no caso de texto sem formatação, formatação e conteúdo são misturados; como a formatação só pode ser feita analisando o conteúdo, os comandos geralmente adicionam opções de formatação por conveniência. Além disso, o formato pode ser realizada quando um usuário aplica seu conhecimento da estrutura de dados, e "codifica" o conhecimento dos argumentos para </font></font><code>cut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>awk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>sed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. (o usuário também usa seu conhecimento de como esses programas funcionam com a formatação, porque é diferente para diferentes programas; portanto, o usuário deve saber, por exemplo, como </font></font><code>cut -f4</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">difere</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><code>awk '{ print $4 }</code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></a><a name="2_2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Isso é muito mais complicado do que passar um ou dois argumentos para o próximo comando em uma sequência, e isso transfere a complexidade da ferramenta para o usuário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Às vezes, as pessoas dizem que não desejam oferecer suporte a dados estruturados, porque, em uma ferramenta universal, seria necessário oferecer suporte a vários formatos. Mas eles já precisam suportar vários formatos para criar uma ferramenta universal. Alguns comandos padrão não podem ler a saída de outros comandos porque eles usam formatos diferentes. Por exemplo, o </font></font><code>wc -w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unicode não lida corretamente com isso, etc. Dizer que "texto" é um formato universal é o mesmo que dizer que "binário" é um formato universal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dizem que não há alternativa para essa complicação das ferramentas de linha de comando. </font><font style="vertical-align: inherit;">Mas as pessoas que dizem isso nunca tentaram uma alternativa, algo como o PowerShell. </font><font style="vertical-align: inherit;">Tenho muitas reclamações sobre o PowerShell, mas a transferência de dados estruturados e a capacidade de trabalhar facilmente com dados estruturados sem ter que manter os metadados em minha mente, para que eu possa transferi-los para as ferramentas de linha de comando certas nos lugares certos no pipeline não é uma das minhas reclamações </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></a><a name="3_3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você é informado de que os programas devem ser simples e compatíveis durante o processamento de texto, essas pessoas fingem que os dados de texto não têm uma estrutura para analisar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup></a><a name="4_4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em alguns casos, podemos representar tudo como uma única linha, separada por espaços, ou como uma tabela com separadores de linha e coluna ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com comportamento que, é claro, não é consistente com outras ferramentas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Isso adiciona um pouco de dificuldade. Ainda há casos em que a serialização de dados em um formato de texto sem formatação adiciona complexidade significativa, pois, devido à estrutura de dados, a serialização simples do texto requer subseqüentemente esforços de análise significativos para re-assimilar os dados de maneira significativa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro motivo pelo qual as equipes agora têm mais opções é porque as pessoas adicionaram sinalizadores convenientes para funcionalidades que poderiam ser implementadas por um pipeline de várias equipes. Essa prática vem ocorrendo desde o Unix v7, em que</font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apareceu uma opção para alterar a ordem de classificação (embora isso possa ser feito passando a saída para </font></font><code>tac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o tempo, por conveniência, foram adicionados parâmetros adicionais. Por exemplo, um comando </font></font><code>mv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que </font><font style="vertical-align: inherit;">estava originalmente sem parâmetros </font><font style="vertical-align: inherit;">agora pode mover o arquivo e </font><font style="vertical-align: inherit;">criar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simultaneamente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma cópia de backup (três opções; duas maneiras diferentes de especificar um backup, uma das quais aceita um argumento e a outra não aceita argumentos, lê um argumento implícito de uma variável de ambiente </font></font><code>VERSION_CONTROL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; outra opção permite substituir o sufixo de backup padrão). Agora </font></font><code>mv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda existem opções para nunca sobrescrever arquivos ou sobrescrever apenas arquivos mais novos.</font></font><br>
<br>
<code>mkdir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outro programa que anteriormente não tinha opções. Hoje, todos os seus sinalizadores, com exceção das opções de segurança para SELinux ou SMACK, bem como os números de ajuda e versão, são adicionados apenas por conveniência: definindo permissões para o novo diretório e criando diretórios pai, caso não existam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><code>tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">início, havia apenas uma opção </font></font><code>-number</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, indicando o ponto de partida do trabalho. Em seguida, adicionamos formatação e opções para a conveniência da formatação. O sinalizador </font></font><code>-z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substitui o separador de linhas por </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aqui estão outros exemplos de opções adicionadas por conveniência: </font></font><code>-f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imprimir quando novas alterações aparecerem, </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definir o intervalo de tempo limite entre a verificação de alterações / código&gt; -f e também </font></font><code>-retry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentar acessar novamente o arquivo, se ele não estiver disponível.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
McIlroy critica os desenvolvedores por adicionar todas essas opções, mas eu pessoalmente me sinto melhor. Embora eu nunca tenha usado alguns deles, raramente usei outros, mas essa é a beleza dos parâmetros da linha de comando - ao contrário da interface gráfica, adicionar esses parâmetros não atrapalha a interface. Sim, mana e ajuda a aumentar, mas na era do Google e Stackoverflow, em qualquer caso, muitos pesquisam qualquer pergunta no Google, em vez de ler mana.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, adicionar opções aumenta a carga sobre os mantenedores. Mas este é um pagamento justo pelos benefícios que eles trazem. Dada a proporção do número de mantenedores e usuários, é lógico impor um ônus adicional ao primeiro, não ao segundo. Isso é semelhante à observação de Gary Bernhardt de que é aconselhável ensaiar uma apresentação 50 vezes. Se o público for de 300 pessoas, a proporção de tempo gasto assistindo o desempenho e o tempo gasto em ensaios ainda será de 6: 1. Para ferramentas populares de linha de comando, essa proporção é ainda mais extrema.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns podem argumentar que todas essas opções adicionais sobrecarregam os usuários. Isso não está totalmente errado, mas esse fardo de complexidade sempre existirá. A questão é onde exatamente. Se você imagina que um conjunto de ferramentas de linha de comando, juntamente com um shell, forma uma linguagem na qual todos podem escrever um novo método e, em caso de popularidade, o método é efetivamente adicionado à biblioteca padrão e os padrões são determinados por axiomas como "Gravar programas para processar fluxos de texto, porque é universal interface ”, o idioma se tornará um caos incoerente somente para gravação, se você o levar por completo. Pelo menos, graças às ferramentas com uma ampla gama de opções e funcionalidades, os usuários do Unix podem substituir um conjunto gigante de ferramentas extremamente inconsistentes por apenas um grande conjunto de ferramentas que,embora sejam inconsistentes um com o outro por fora, eles têm alguma consistência interna.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
McIlroy implica falta de consideração na caixa de ferramentas. Assim, os pais fundadores do Unix devem sentar-se na mesma sala e pensar com cuidado até encontrar um conjunto de ferramentas seqüenciais de "extraordinária simplicidade". Mas não será escalável, a filosofia do próprio Unix inevitavelmente levou à bagunça em que estamos. Não é que alguém não pense muito ou muito. O ponto é uma filosofia que não ultrapassa uma equipe relativamente pequena, com um entendimento cultural comum que pode caber em uma sala. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se alguém quiser escrever uma ferramenta baseada na “filosofia Unix”, pessoas diferentes terão opiniões diferentes sobre o que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“simplicidade”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> significa </font><font style="vertical-align: inherit;">ou o princípio de “fazer uma coisa” </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup></a><a name="5_5"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como a ferramenta deve funcionar corretamente - e a inconsistência florescerá em cores exuberantes, resultando em uma enorme complexidade, semelhante a linguagens extremamente inconsistentes como o PHP. As pessoas tiram sarro do PHP e do JavaScript por várias esquisitices e inconsistências, mas, como uma linguagem e uma biblioteca padrão, qualquer shell popular com uma coleção de ferramentas * nix populares, tomadas em conjunto, é muito pior e contém uma complexidade muito mais aleatória devido a inconsistências, mesmo na mesma distribuição Linux . Não pode ser de outra maneira. Se você comparar as distribuições de Linux, BSD, Solaris, AIX, etc., a quantidade de complexidade aleatória que os usuários devem ter em mente ao trocar de sistema, obscurece a inconsistência de PHP ou JavaScript.As linguagens de programação mais amplamente ridicularizadas são exemplos reais de ótimo design em comparação a elas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para maior clareza, não estou dizendo que eu ou outra pessoa poderia lidar melhor com o desenvolvimento nos anos 70, levando em consideração o conhecimento disponível na época, e criar um sistema que seria útil naquele momento e elegante hoje. Obviamente, é fácil olhar para trás e encontrar problemas em retrospecto. Simplesmente discordo dos comentários de alguns conhecedores do Unix, como McIlroy, que sugerem que esquecemos ou não entendemos o valor da simplicidade. Ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ken Thompson, que diz que C é um idioma tão seguro quanto qualquer outro e, se não queremos que apareçam erros, precisamos escrever código sem erros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comentários desse tipo implicam que pouco mudou ao longo dos anos. </font><font style="vertical-align: inherit;">Alegadamente, nos anos 70, construímos sistemas da mesma maneira que hoje e, durante cinco décadas de experiência coletiva, dezenas de milhões de pessoas-ano não nos ensinaram nada. </font><font style="vertical-align: inherit;">E se nos voltarmos para as origens, para os criadores do Unix, tudo ficará bem. </font><font style="vertical-align: inherit;">Com todo o respeito, não concordo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicação: memória</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora as queixas de McIlroy sobre binários inchados estejam um pouco fora do escopo deste artigo, observarei que em 2017 comprei um Chromebook com 16 GB de RAM por US $ 300. O binário de 1 megabyte pode ser um problema sério em 1979, quando o Apple II padrão era equipado com 4 kilobytes de memória. O Apple II custou US $ 1.298 em 1979 ou US $ 4.612 em 2020. Hoje você pode comprar um Chromebook barato que custa menos de 1/15 desse preço, enquanto ele tem quatro milhões de vezes mais memória. As reclamações de que o uso da memória aumentou mil vezes parecem um pouco ridículas quando (portátil!) A máquina é muito mais barata e tem quatro milhões de vezes mais memória.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu gosto da otimização, então reduzi minha página inicial a dois pacotes (haveria um se o CDN suportasse brotli de alto nível), mas esse é um requisito puramente estético, eu faço isso por diversão. </font><font style="vertical-align: inherit;">O gargalo das ferramentas de linha de comando não está usando memória, e o tempo para otimizar a memória da ferramenta com um tamanho de um megabyte é como reduzir uma página inicial a um pacote. </font><font style="vertical-align: inherit;">Talvez um hobby divertido, mas nada mais.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metodologia de compilação de tabela</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A frequência de uso de comandos é obtida nos arquivos públicos do histórico de comandos no github, não corresponde necessariamente à sua experiência pessoal. Somente comandos "simples" foram contados, excluindo instâncias como curl, git, gcc (o último possui mais de 1000 opções) e wget. O conceito de simplicidade é relativo. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comandos internos do shell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como </font></font><code>cd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, também não foram levados em consideração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A repetição de sinalizadores não foi considerada uma opção separada. Por exemplo, u </font></font><code>git blame -C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>git blame -C -C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>git blame -C -C -C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um comportamento diferente, mas todos eles vão ser considerado como um argumento, embora </font></font><code>-C -C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eles </font></font><code>-C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;são realmente diferentes argumentos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As subopções na tabela são contadas como uma opção. Por exemplo, ele </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suporta o seguinte: </font></font><br>
<br>
<code>--format=WORD across -x, commas -m, horizontal -x, long -l, single-column -1, verbose -l, vertical -C</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar de sete opções </font></font><code>format</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isso conta como uma opção.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As opções que são explicitamente indicadas como inúteis ainda são consideradas opções, por exemplo </font></font><code>ls -g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que é ignorado também é considerado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Várias versões da mesma opção são consideradas uma opção. </font><font style="vertical-align: inherit;">Por exemplo, </font></font><code>-A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>--almost-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o certificado disser que a opção existe, mas, na realidade, ela não existe, ela não será levada em consideração. </font><font style="vertical-align: inherit;">Por exemplo, a ajuda para v7 mv diz:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SACOS </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o arquivo1 e o arquivo2 estiverem em sistemas de arquivos diferentes, o mv deverá copiar o arquivo e excluir o original. </font><font style="vertical-align: inherit;">Nesse caso, o nome do proprietário se torna o nome do processo de cópia e qualquer conexão com outros arquivos é perdida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mv deve aceitar o sinalizador </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-f</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como rm para suprimir uma mensagem sobre a existência de um arquivo de destino que não seja gravável.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas </font></font><code>-f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não é considerado um sinalizador na tabela, porque a opção realmente não existe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela termina em 2017 porque o primeiro rascunho deste artigo foi escrito. </font><font style="vertical-align: inherit;">Só agora eles conseguiram ler.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste tópico</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A discussão de Mjd sobre a filosofia Unix, com pensamentos sobre a bagunça / usr / bin / time versus o tempo incorporado</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A piada do mjd sobre a distribuição de opções de comando em 1991</font></font></a><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com HN:</font></font><br>
<br>
<blockquote><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1mrx: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É estranho que o ls tenha aumentado para 58 opções, mas ainda não possa exibir nomes de arquivos que terminam com \ 0.</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como exercício, tente classificar o diretório por tamanho ou data e transfira o resultado para xargs, enquanto suporta todos os nomes de arquivos válidos. </font><font style="vertical-align: inherit;">No final, desisti e coloquei no script ignorar todos os arquivos com \ n no nome.</font></font></blockquote><br>
whelming_wave:<br>
<br>
        ,      (whitespace-in-filenames-safe).  <code>printf (od -&gt; sed)</code>    ,  ,  ,   ,      ,   ,  . , <code>sort --zero-terminated</code>&nbsp;—   GNU    ,      macOS,    ,   .<br>
<br>
<pre><code class="bash hljs">      <span class="hljs-built_in">printf</span> <span class="hljs-string">'%b'</span> $(<font></font>
        find . -maxdepth 1 -<span class="hljs-built_in">exec</span> sh -c <span class="hljs-string">'
          printf '</span>\<span class="hljs-string">''</span>%s %s\0<span class="hljs-string">'\'</span><span class="hljs-string">' "$(stat -f '</span>\<span class="hljs-string">''</span>%m<span class="hljs-string">'\'</span><span class="hljs-string">' "$1")" "$1"
        '</span> sh {} \; | \<font></font>
        sort --zero-terminated | \<font></font>
        od -v -b | \<font></font>
        sed <span class="hljs-string">'s/^[^ ]*//
      s/ *$//
      s/  */ \\/g
      s/\\000/\\012/g'</span>)</code></pre><br>
    zsh,      ,    'command',   printf,   zsh,     escape-    . ,          .<br>
<br>
  POSIX,   ,   sort.</blockquote></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">  Unix</a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">   ?</a></li>
</ul><br>
<sub>  ,  ,  -,       //.</sub><br>
<br>
<hr><br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Essa citação é um pouco diferente da versão comum, porque eu assisti o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vídeo original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pelo que sei, todas as cópias dessa citação na Internet (índices Bing, DuckDuckGo e Google) são retiradas da mesma transcrição de uma pessoa. </font><font style="vertical-align: inherit;">Há uma certa ambiguidade, porque o som é de baixa qualidade e ouço palavras ligeiramente diferentes das que essa pessoa ouviu. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[para retornar]</font></font></a><br>
<br>
<a name="2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Outro exemplo de como a complexidade é passada para o usuário, porque equipes diferentes lidam com a formatação de maneira diferente, é a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formatação da hora</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O tempo de shell interno é </font></font><code>time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obviamente, incompatível com </font></font><code>/usr/bin/time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O usuário deve estar ciente desse fato e saber como lidar com ele. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[para retornar]</font></font></a><br>
<br>
<a name="3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Por exemplo, para qualquer objeto que você possa usar </font></font><code>ConvertTo-Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>ConvertTo-CSV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"cmdlets" para alterar a exibição das propriedades do objeto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Você pode gravar arquivos de configuração de formatação que definem seus métodos de formatação preferidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra maneira de ver isso é através do prisma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da lei de Conway</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se tivermos um conjunto de ferramentas de linha de comando criadas por pessoas diferentes, geralmente de organizações diferentes, essas ferramentas serão extremamente inconsistentes se alguém não puder determinar o padrão e forçar as pessoas a aceitá-lo. Na verdade, isso funciona relativamente bem no Windows, não apenas no PowerShell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma reclamação comum contra a Microsoft é a rotatividade massiva da API, geralmente por razões organizacionais não técnicas (por exemplo, veja as ações de Stephen Sinofsky, conforme descrito nas respostas a um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tweet remoto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). É verdade. No entanto, do ponto de vista de um usuário ingênuo, o software padrão do Windows, via de regra, transmite dados não textuais muito melhores que o * nix. A cobertura de dados não textuais no Windows remonta a pelo menos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em 1999 (e possivelmente OLE e DDE, lançado em 1990 e 1987, respectivamente). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, se você copiar do Foo, que suporta o formato binário, </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na Barra, que suporta formatos, </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depois copiar do Bar para o Baz, que suporta </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tudo funcionará bem, mesmo que Foo e Baz não tenham formatos suportados comuns. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você recorta ou copia algo, o aplicativo basicamente “informa” a área de transferência em quais formatos ele pode fornecer dados. Quando colado em um aplicativo, o aplicativo final pode solicitar dados em qualquer um dos formatos disponíveis. Se os dados já estiverem na área de transferência, o Windows os fornecerá. Se não for esse o caso, o Windows recebe dados do aplicativo de origem e os transfere para o aplicativo de destino, e uma cópia é armazenada por algum tempo. Se você "cortar" no Excel, ele dirá "você" que ele possui dados disponíveis em várias dezenas de formatos. Esse sistema é muito bom para compatibilidade, embora certamente não possa ser chamado de simples ou minimalista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além do bom suporte de muitos formatos, é suficiente para que muitos programas comecem a lidar bem com esses recursos; no Windows, fora da caixa, geralmente há um bom suporte à área de transferência.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que você copie e cole uma pequena quantidade de texto. Na maioria dos casos, nenhuma surpresa ocorrerá no Windows ou no Linux. Mas agora suponha que você copiou algum texto, fechou o programa do qual copiou e o colou. Muitos usuários tendem a pensar que, ao copiar dados, eles são armazenados na área de transferência e não no programa em que são copiados. No Windows, o software geralmente é escrito de acordo com essa expectativa (embora tecnicamente os usuários da API da área de transferência não devam fazer isso). Isso é menos comum no Linux com X, onde o modelo mental correto para a maioria dos programas é que a cópia salva um ponteiro para os dados que ainda pertencem ao programa do qual estão sendo copiados. Ou seja, a inserção não funcionará se o programa estiver fechado.Quando entrevistei programadores (informalmente), eles geralmente ficaram surpresos com isso, a menos que realmente trabalhassem com a função copiar + colar para seu aplicativo. Quando entrevistei não programadores, eles geralmente acharam esse comportamento não apenas surpreendente, mas também confuso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A desvantagem de transferir a área de transferência para o sistema operacional é que copiar grandes quantidades de dados é caro. Suponha que você copie uma quantidade muito grande de texto, muitos gigabytes ou algum tipo de objeto complexo e depois não o cole. Na verdade, você não deseja copiar esses dados do seu programa para o sistema operacional para que sejam armazenados lá e disponíveis. O Windows faz isso com sabedoria: os aplicativos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">só</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">fornecer dados sob demanda</font></a><font style="vertical-align: inherit;"> , se considerados benéficos. No nosso caso, quando o usuário fecha o programa, ele pode determinar se deve colocar os dados na área de transferência ou excluí-los. Nesse caso, muitos programas (por exemplo, o Excel) oferecerão "salvar" dados na área de transferência ou excluí-los, o que é bastante razoável. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns desses recursos podem ser implementados no Linux. Por exemplo,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A especificação ClipboardManager</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descreve o mecanismo de salvamento, e os aplicativos GNOME geralmente o suportam (embora </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com alguns bugs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), mas a situação no * nix realmente difere do onipresente suporte para aplicativos Windows, onde uma área de transferência competente geralmente é implementada. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[para retornar]</font></font></a><br>
<br>
<a name="4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Outro exemplo são as ferramentas em cima dos compiladores modernos. Vamos voltar e ver o exemplo canônico de Macilroy, onde os compiladores Unix certos são tão especializados que a listagem é feita por uma ferramenta separada. Hoje, porém, isso mudou, embora uma ferramenta de listagem separada tenha permanecido. Alguns compiladores Linux populares têm literalmente milhares de opções - e são extremamente ricos em recursos. Por exemplo, uma das muitas funções do moderno </font></font><code>clang</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;é a análise estática. No momento da redação deste artigo, existem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79 testes de rotina de análise estática e 44 testes experimentais.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se fossem comandos separados, eles ainda dependeriam da mesma infraestrutura básica do compilador e imporiam a mesma carga de manutenção - não é razoável que essas ferramentas de análise estática trabalhem com texto sem formatação e redefinam toda a cadeia de ferramentas do compilador necessária para chegando ao ponto em que eles podem realizar análises estáticas. Eles podem ser comandos separados em vez de serem combinados no clang, mas ainda dependem do mesmo mecanismo e impõem a carga de manutenção e complexidade ao compilador (que deve suportar interfaces estáveis ​​para ferramentas que funcionam sobre ele), ou serão constantes quebrar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fazer tudo no texto por simplicidade parece bonito, mas, na verdade, a representação textual dos dados geralmente não é o que você precisa se deseja fazer um trabalho realmente útil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mesmo clang é simplesmente mais funcional do que qualquer compilador que existisse em 1979, ou mesmo todos os compiladores que existiam em 1979 combinados, independentemente de ter sido executado por um comando monolítico ou por milhares de instruções menores. É fácil dizer que em 1979 tudo foi mais simples e que nós, programadores modernos, nos perdemos. Mas, na realidade, é difícil oferecer um design muito mais simples e que seja verdadeiramente aceito por todos. É impossível que esse design possa preservar toda a funcionalidade e configurabilidade existente e ser tão simples quanto algo de 1979. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[para retornar]</font></font></a><br>
<br>
<a name="5"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Desde a sua criação, o curl passou de suportar três protocolos para 40. Isso significa que ele "faz 40 coisas" e a filosofia do Unix exige que ele seja dividido em 40 comandos separados? </font><font style="vertical-align: inherit;">Depende de quem perguntar. </font><font style="vertical-align: inherit;">Se cada protocolo fosse sua própria equipe, criada e apoiada por outra pessoa, teríamos a mesma bagunça que as equipes. </font><font style="vertical-align: inherit;">Parâmetros de linha de comando inconsistentes, formatos de saída inconsistentes, apesar de todos serem fluxos de texto, etc. Isso nos aproxima da simplicidade que McIlroy defende? </font><font style="vertical-align: inherit;">Depende de quem perguntar. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[para retornar]</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt499062/index.html">Pequenos problemas de física</a></li>
<li><a href="../pt499064/index.html">Compreensão contextual alternativa usando um modelo de linguagem estatística</a></li>
<li><a href="../pt499068/index.html">Definindo parâmetros de transformação da nuvem de pontos</a></li>
<li><a href="../pt499070/index.html">Sobre AndroidStudio ou como usar as ferramentas VCS ao máximo</a></li>
<li><a href="../pt499086/index.html">Dask Home Cluster</a></li>
<li><a href="../pt499092/index.html">Modelo de referência BIAN. Que novidade e útil para a arquitetura corporativa do banco oferece?</a></li>
<li><a href="../pt499096/index.html">Lógica confusa em belas fotos. Superfícies de resposta para diferentes funções de associação</a></li>
<li><a href="../pt499102/index.html">Kubernetes, microsserviços, CI / CDs e Dockers para retrógrados: dicas de aprendizado</a></li>
<li><a href="../pt499104/index.html">IoT para suas feridas: por que a Internet das coisas é mais bem-vinda na era dos coronavírus</a></li>
<li><a href="../pt499106/index.html">HTML avançado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>