<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙉 ▪️ #⃣ QRコードのローカライズは重要なタスクであり、当然のことながら注意を奪われます 📓 👩🏾‍🍳 🙅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今日では、QRコードに慣れていないHabrリーダーは1人もいないはずです。これらの2次元バーコードはいたるところにあります。世界にある程度の効率でQRコードをプロジェクトに追加できるツールがたくさんあるのは当然です。重要なのは、この効率は、QRコードの認識に使用されるツールの品質に直接依存するという...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>QRコードのローカライズは重要なタスクであり、当然のことながら注意を奪われます</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/smartengines/blog/496528/"><img src="https://habrastorage.org/webt/5g/mo/eg/5gmoegkwyn0bmh_t_kewswuiboc.png" width="250" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今日では、QRコードに慣れていないHabrリーダーは1人もいないはずです。これらの2次元バーコードはいたるところにあります。世界にある程度の効率でQRコードをプロジェクトに追加できるツールがたくさんあるのは当然です。重要なのは、この効率は、QRコードの認識に使用されるツールの品質に直接依存するということです。そしてここに古典的なプラグがあります：あなたは問題を（非常に）よくそして（非常に）高価に解決することができます、またはあなたは無料でそして何とかして解決できます。それでも問題をうまく解決するように無料を変更することは可能ですか？興味があれば、猫の下を見てください。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写真のQRコードを認識することは、マシンビジョンの適切な作業です。まず、タスクでは、もともと「便利な」認識のために特別に設計されたオブジェクトが調査されます。次に、タスク自体がいくつかの独立した理解可能なサブタスクに分割されます。QRコードのローカライズ、QRコードの向き、QRコードの直接デコードです。パブリックドメインには、QRコードの向きとデコードという最後の2つの問題を解決できる優れたライブラリが長い間存在していることが判明しました。 1つの問題：高品質のデコードの場合、そのようなライブラリは、バーコードの直接の適切なバイナリイメージが入力されることを期待しています。逆に、画像内のバーコードの位置特定のタスクにはほとんど注意が払われていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの経験では、認識オブジェクトをより正確にローカライズするほど、適切な前処理ツールを選択し、実際にそれを認識することが容易になります。したがって、プロジェクトでQRコードの認識の品質を向上させたい場合は、QRコードをローカライズする方法の最新化から始めます。実際、後で画像を2値化する必要がある場合でも、バーコードで領域を2値化すると、元の画像全体よりもはるかに効率的です（計算上および定性的な観点から）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、古典的な画像処理方法を使用してQRコードのローカライズの品質を簡単に改善する方法を説明し、提案されたアルゴリズムの有効性の数値特性も示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更されたビオラとジョーンズの方法を基礎として使用して、画像上のQRコードをローカライズする元の方法について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事のトピックに関する情報メモ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、ローカライズ方法の構築に使用されるQRコードの主要な機能と、ViolaおよびJonesメソッドの元のバージョンの簡単な説明について説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QRコード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QRコード（Quick Response Codeの略）は、90年代半ばに自動車業界向けに日本で開発された2次元バーコードです。</font><font style="vertical-align: inherit;">リニアバーコードに比べて読み取り速度が速く容量が大きいため、QRコードシステムはさまざまな分野で世界的に普及しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常ハードウェアでスキャンされる標準のリニアバーコードとは異なり、QRコードはカメラでスキャンされることがよくあります。</font><font style="vertical-align: inherit;">QRコードの構造は、ISO / IEC 18004（ISO / IEC規格18004）で完全に説明されています。</font><font style="vertical-align: inherit;">このような画像の堅牢な認識アルゴリズムを構築するために、QRコードには関数パターンを形成するいくつかの参照点があります。バーコード画像の隅にある3つの正方形（ファインダーパターンと呼ばれます）とバーコード画像全体の小さな同期正方形（アライメントパターンと呼ばれます） 。</font><font style="vertical-align: inherit;">このようなポイントにより、画像のサイズと向きを正規化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qp/ut/kn/qputknsphjra1c0nwyoxpfnwniy.png"><br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">QRコードの構造</font></font></i></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視覚的にはすべてのQRコードは互いに似ていますが、エンコードされたデータの量に応じて、QRコードのコピーが異なると、内部要素のレイアウトが異なる場合があります。</font><font style="vertical-align: inherit;">さらに、いわゆるデザイナーQRコードは非常に人気があり、バーコードの高品質な認識を保証する追加情報の一部の代わりに、サードパーティのグラフィック要素（ロゴ、エンブレム、銘刻文字など）が使用されます。</font><font style="vertical-align: inherit;">QRコードのローカライズと認識のためのメソッドを構築するときは、QRコードのこれらすべての機能を考慮する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1k/f2/f0/1kf2f024blycs3yruzzsk3cnxr0.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">さまざまな有効なQRコードオプション</font></font></i></p><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビオラとジョーンズの方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハブレの怠け者だけがビオラとジョーンズの方法についてまだ書いていませんでした。私たちのブロックでさえ、これを数回行いました（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。それでも、私たちは文字通り2つの段落で非常に簡潔にそれが何であるかを伝える必要があると考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビオラとジョーンズのオブジェクト検出方法は、画像内の顔をリアルタイムで検索するために開発されました。この方法は、各画像点での検出問題をバイナリ分類問題に減らします。つまり、あらゆる種類のシフトとスケールで撮影された各長方形の画像領域について、事前トレーニングされた分類器を使用して、領域内に目的のオブジェクトが存在するという仮説をチェックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特徴空間として、Viola and Jonesメソッドは、Haarの長方形の特徴を使用します。その値は、隣接する長方形の内側の画像領域のピクセルの明るさの合計の差として計算されます。 Haarフィーチャの値を効果的に計算するために、統合された画像が使用されます。これは、文献ではsummed-area tableという用語で知られています。バイナリの「弱い」分類子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Χ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> →{-1、+ 1}。通常、1つのブランチを持つ認識ツリーとして表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y7/ly/se/y7lyseencrhtwi3hefy1xsl3kya.png" width="237"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">θ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-属性のしきい値と分類子のパリティ。</font><font style="vertical-align: inherit;">さらに、AdaBoost機械学習法を使用して、「強い」分類器は、上記の「弱い」分類器の線形重ね合わせとして構築されます。</font><font style="vertical-align: inherit;">Viola and Jonesメソッドの高速性は、「強力な」分類子のカスケードを使用することで保証されます。これにより、少数の計算で「空の」（オブジェクトのない）画像領域をローカライズできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QRコード検出アルゴリズム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QRコードをローカライズするためのメソッドを構築するとき、タスクの次の機能に依存しました。第一に、開発された方法は、リアルタイムで動作する認識システムで使用するための高性能を備えている必要があります。第二に、この方法は、画像内のバーコードの許容される歪みに耐性がなければなりません。第三に、この方法では、QRコードの既存の変動性をすべて考慮する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、基本的な方法としてビオラとジョーンズの方法を選択しました。このメソッドは、剛体オブジェクトを検索するさまざまなタスクで実証されていますが、このメソッドは必要なパフォーマンスを提供します。ただし、元のバージョンでは、次の理由により、Viola and Jonesメソッドを使用できません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビオラとジョーンズの古典的な方法では、オブジェクトのテクスチャの特徴を「強調」するHaar属性のファミリーが使用されます。この場合、QRコードは白黒のバーセルで構成されていますが、その分布はバーコードとバーコードで大きく異なります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古典的なビオラとジョーンズの方法は、特定の方向にあるオブジェクトの同じタイプの検出用に設計されていますが、これもこのタスクでは観察されません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビオラとジョーンズの方法を適用して問題を解決できるように、境界フィーチャの元のファミリと、決定木の形式で高レベルの分類器を使用します。</font><font style="vertical-align: inherit;">最初の変更により、テクスチャではなく、調査対象のオブジェクトの境界フィーチャに焦点を合わせることができます。</font><font style="vertical-align: inherit;">2番目の変更では、変数オブジェクトを検出できる単一の分類子を作成できます。</font><font style="vertical-align: inherit;">次に、各変更についてもう少し詳しく説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハールのグラデーションの兆候。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QRコードの効果的な検出器を構築するために、勾配機能の特別なファミリを使用しました[1]。</font><font style="vertical-align: inherit;">これらの標識は、指示された境界のマップの上で計算されたHaar長方形標識であり、一般化能力を大幅に向上させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方向境界のマップは、勾配係数のイメージであり、点（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">での勾配の優先方向をさらに考慮し、</font><font style="vertical-align: inherit;">水平、垂直、+ 45°および-45°方向への境界の角度の離散化として定義されます。</font><font style="vertical-align: inherit;">QRコード検出器を構築するために、2種類の方向境界マップを使用しました。直線境界マップと対角面マップです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元の画像を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。次に、ソーベル演算子を用いて水平方向および垂直方向に沿って導関数の近似値を計算することができる。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pf/yg/_p/pfyg_pwalnr_vdg6dm-fi_jnv9o.png" width="466"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、使用して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G </font></font></i><sub><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のx</font></font></i></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G </font></font></i><sub><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yは</font></font></i></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、イメージ内の各点における勾配方向を算出することができる：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/28/7w/w1/287ww1jnk9sr3fbrtgsr-q4ygoc.png" width="301"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレート境界のマップは、主に水平方向および垂直方向の境界を含み、次のように計算される：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vi/bj/ie/vibjieyjzpf4rmokqrwozdru7ba.png" width="328"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地図対角線の境界線は、主に対角線に沿った境界線を含み、次のように計算されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kg/zy/zy/kgzyzyc1owgaxci7skuiotoirw4.png" width="405"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構築された有向境界線（対角線または直線）のマップの上に、長方形のハール記号が計算されます。従来のハールフィーチャとは異なり、このような境界フィーチャは、多数の境界を含むウェルオブジェクトを一般化します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/mo/fd/mvmofd__pwr9myrhvp4xxh9-_gi.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">有向ボーダーのマップのイラスト：（a）QRコードの元のイメージ、（b）直線ボーダーのマップ、（c）回転したQRコードのイメージ（d）回転したQRコードの対角ボーダーのマップ</font></font></i></p><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強力な分類子の決定的なツリー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
強力な分類子のツリー[2]は一種の二分決定木です。ツリーノードは強力な分類子であり、その右端にはおそらくオブジェクトを含むサブウィンドウがあり、左側にはオブジェクトとして認識されなかったサブウィンドウがあります。</font><font style="vertical-align: inherit;">最終的な答えは葉でのみ与えられます。</font><font style="vertical-align: inherit;">ビオラとジョーンズのオリジナルの作品で説明されている古典的なカスケード分類器は、実際には、1つの「正の」出力（葉）と多くの「負の」出力を含むツリー分類器です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2]では、ツリー分類子のルートから最下位ノードまでのパスは、個々の強力な分類子が逆の回答で入るカスケードとして表すことができることが示されています。</font><font style="vertical-align: inherit;">これのおかげで、古典的なカスケード分類器のトレーニング手順を使用して個々のパスを教えるツリー分類器の学習アルゴリズムを構築することが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリー分類子を使用すると、従来のカスケード分類子と比較して、変数オブジェクトの完全性の点でより効果的な分類子をトレーニングできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実験結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本稿で提案するバーコード定位法の有効性を評価する実験の一環として、264枚の画像からなるバーコード画像のセットを作成しました。</font><font style="vertical-align: inherit;">画像の物理的なサイズは約1 MPixでした。</font><font style="vertical-align: inherit;">各画像には任意の向きのQRコードが1つだけ含まれ、バーコード領域は画像領域全体の少なくとも10％でした。</font><font style="vertical-align: inherit;">下の図は、組み立てられたセットの画像の例を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rb/vv/bd/rbvvbdyp8t7mffaqa38b4olv-_m.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">組み立てられたバーコード画像セットからの画像の例</font></font></i></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準備された画像のセットは、トレーニングセットとテストセットに分けられました。トレーニングサンプルのサイズは88画像、テストサンプルのサイズは176画像でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングセットは、ポジティブな例の準備とネガティブな例の準備の両方に使用されました。肯定的な例の最初の数は少なかったので、データ拡張技術を使用しました[3]。特に、バーコードの中心を中心に15度ずつ回転させました。増加後、ポジティブな例の数は2088例でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ正と負の例を使用して、3つのQRコード検出器をトレーニングしました。標準のHaar機能を備えたクラシックなカスケード分類器、境界機能を備えたクラシックなカスケード分類器、および境界機能を備えたツリー分類器です。</font><font style="vertical-align: inherit;">最初のカスケード分類子は12のレベルで構成され、合計58の属性を含みました。</font><font style="vertical-align: inherit;">2番目のカスケード分類子は8つのレベルで構成され、合計39の属性を含みました。</font><font style="vertical-align: inherit;">訓練されたツリー分類子は39の頂点で構成され、合計110文字を含み、上から葉までの最大パスは9でした。以下は、訓練されたツリー分類子の図です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0e/pp/rx/0epprxrwsrqho130ykkanqj_cs8.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">訓練されたツリー分類器のスキーム</font></font></i></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QRコードの構築された検出器の品質を評価するために、OpenCVオープンソースコンピュータービジョンライブラリのバーコードデコードモジュールを使用しました。</font><font style="vertical-align: inherit;">準備された画像セット（前述のように、176個の画像で構成されています）で、特別な前処理なしで、トレーニング済みの検出器を使用してQRコードを予備検索した後、デコードモジュールを起動しました。</font><font style="vertical-align: inherit;">以下は、バーコードのデコード結果です。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番号。</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試験的なタイトル</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デコードされた画像の数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デコード品質</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCVのみ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">104</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59.09％</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VJ（グレースケール機能、カスケード分類子）+ OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">105</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59.66％</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VJ（エッジ機能、カスケード分類子）+ OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">123</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69.89％</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VJ（エッジ機能、ツリー分類子）+ OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">136</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77.27％</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この表は、前述の方法を使用してQRコードを事前に特定することで、バーコードのデコード品質を大幅に向上できることを示しています（デコードエラーの数が44％減少）。さらに、結果は、オリジナルのビオ​​ラとジョーンズの方法（古典的なハール機能とカスケード分類器を使用）の適用がQRコードのローカライズタスクでは効果的でないことも示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、各分類子がどの程度正確にバーコードをローカライズするかを見てみましょう。</font><font style="vertical-align: inherit;">左から右の図は、標準のHaar機能を備えたクラシックカスケード分類器、境界機能を備えたクラシックカスケード分類器、および境界機能を備えたツリー分類器で同じバーコードを検出した結果を示しています。</font><font style="vertical-align: inherit;">ツリー分類器は、QRコードの変動性を考慮することにより、バーコードのローカリゼーション精度を向上させることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o-/um/wr/o-umwrnaxpniz5oziynxxm-bjja.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">同じ画像上の訓練された検出器の作業の図</font></font></i></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、QRコードは生活のさまざまな分野で使用されています。URLをエンコードするための広告業界や、電子サービスの一部としての州のセグメントなどです。</font><font style="vertical-align: inherit;">このようなバーコードの分布は非常に多いにもかかわらず、既存のオープンソースライブラリはローカリゼーションの問題ではなく、デコードプロセスに重点を置いています。</font><font style="vertical-align: inherit;">しかし、正直に言うと、この記事の真の目的は、QRコードをローカライズする効果的な方法を説明することではなく、科学的思考とシステム分析の使用方法、古典的なデジタル画像処理ツールの使用方法の理解を伝えることです。図書館は実際の産業レベルをもたらします。</font><font style="vertical-align: inherit;">ご清聴ありがとうございました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されているソースのリスト</font></font></b><div class="spoiler_text">[1] A.A. Kotov, S.A. Usilin, S.A. Gladilin, and D.P. Nikolaev, “Construction of robust features for detection and classification of objects without characteristic brightness contrasts,” Journal of information technologies and computing systems, 1, 53-60, (2014).<br>
[2] A. Minkina, D. Nikolaev, S. Usilin, and V. Kozyrev, “Generalization of the Viola-Jones method as a decision tree of strong classifiers for real-time object recognition in video stream,” in Seventh International Conference on Machine Vision (ICMV 2014), 9445, International Society for Optics and Photonics, (2015), doi:10.1117/12.2180941.<br>
[3] D. P. Matalov, S. A. Usilin, and V. V. Arlazarov, “Modification of the viola-jones approach for the detection of the government seal stamp of the russian federation,” in Eleventh International Conference on Machine Vision (ICMV 2018), 11041, International Society for Optics and Photonics, (2019), doi:10.1117/12.2522793.</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496510/index.html">ゲームデザイナーにならない方法</a></li>
<li><a href="../ja496512/index.html">＃05-そして、バイト全体では十分ではありません... | アニメ</a></li>
<li><a href="../ja496514/index.html">LinuxマシンとNATプロバイダーの背後にあるMikrotik間のIPIP IPsec VPNトンネル</a></li>
<li><a href="../ja496516/index.html">PythonとCOVID-19の電報ボット</a></li>
<li><a href="../ja496518/index.html">どうやってリモコンに行きましたか</a></li>
<li><a href="../ja496532/index.html">私たちは自分自身をチェックします：1Cの展開方法と管理方法：1C企業内のドキュメントフロー</a></li>
<li><a href="../ja496536/index.html">DeepCode：側面図</a></li>
<li><a href="../ja496538/index.html">Pythonのフラクタル。ウォークスルー</a></li>
<li><a href="../ja496542/index.html">ヨーロッパのインターネットトラフィックは1.5倍に増加しています。バックボーンプロバイダーは負荷レコードを記録します</a></li>
<li><a href="../ja496544/index.html">自営業のプロジェクトのオンラインハッカソン：連邦税務局からのアイデアとサポートのための50万ルーブル</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>