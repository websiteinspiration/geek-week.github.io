<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¶ğŸ¼ ğŸ¦‚ ğŸ‘‹ Pemrograman fungsional adalah apa yang Anda (mungkin) diberitahu. Jika kamu mendengarkan ğŸ‘¨ğŸ¾ ğŸ‘©ğŸ¿â€ğŸ¨ ğŸ‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya suka percakapan dengan topik "Saya dulu diberitahu di sekolah / institut / orang tua, tapi sekarang saya tahu." Jika, secara kebetulan, saya mend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pemrograman fungsional adalah apa yang Anda (mungkin) diberitahu. Jika kamu mendengarkan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492460/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya suka percakapan dengan topik "Saya dulu diberitahu di sekolah / institut / orang tua, tapi sekarang saya tahu." Jika, secara kebetulan, saya mendapati diri saya setidaknya sedikit kompeten dalam hal yang sedang dibahas, maka percakapan seperti itu biasanya mengarah ke salah satu dari tiga pilihan: "di mana Anda pernah mendengar omong kosong seperti itu sebelumnya?" (jika teman bicara itu benar), "dan di mana Anda mendapatkan ini begitu?" (jika dia salah) dan â€œAnda benar, tetapi ini tidak bertentangan dengan apa yang Anda katakan sebelumnyaâ€ (dalam sebagian besar kasus). Saya suka percakapan ini karena alasan berikut: biasanya penggagasnya tidak dibebani dengan pengetahuan awal yang berlebihan tentang masalah ini, yang dalam beberapa kasus memungkinkannya untuk menunjukkan beberapa poin yang diterima sebagai sesuatu yang jelas, tetapi tidak benar-benar seperti itu. Dan salah satu topik untuk percakapan tersebut adalah pemrograman fungsional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, begitu banyak yang telah ditulis dan dikatakan tentang FP sehingga tampaknya semua pertanyaan tentang penerapannya, kesejukan, kinerja, dll. digerogoti sumsum tulang. Namun demikian, pertanyaan seperti itu muncul berulang-ulang, dan akan selalu ada seseorang yang ingin berbicara tentang apa yang Anda semua salah pahami, tetapi kenyataannya seperti itu. Mungkin hari ini saya akan mencoba sendiri peran tidak tahu berterima kasih ini, karena beberapa posting tentang topik lama ini baru-baru ini menarik perhatian saya. Yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sekali lagi mengatakan bahwa AF adalah sampah dan mempelajarinya hanya akan merusak karma spesialis masa depan Anda. Lainnya ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) jauh lebih memadai, di dalamnya penulis bertujuan untuk menjelaskan bahwa semua lambda Anda, kombinator, kategori tidak lebih dari debu di mata, dan FP itu sendiri adalah hal yang sederhana, dapat dimengerti dan menyenangkan dalam hidup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seberapa benar ini?</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum beralih ke inti masalah, saya akan membuat sedikit penyimpangan dan memberi penekanan. Isi dari dua posting pertama ini, saya pikir benar-benar omong kosong dari seorang spesialis yang buta huruf yang, dengan jari-jarinya yang terbuka, membahas hal-hal yang ia bahkan tidak menghabiskan sedikit waktu yang berharga untuk belajar. Orang-orang baik dari kalangan komentator telah mengindikasikan bahwa ini tidak lebih dari olok-olok. Masalahnya adalah, ternyata, saya tidak dapat memahami tesis yang diajukan dalam terjemahan ini sebagai olok-olok, karena saya harus mendengar sebagian besar dari mereka hidup. Rupanya, Anda dapat mendiagnosis adanya trauma psikologis yang disebabkan oleh kelebihan pasokan omong kosong yang telah melewati otak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua yang kedua lebih cenderung membangkitkan emosi positif, karena di dalamnya penulis menerapkan praktik FP untuk tugas-tugas yang dipahami pengembang OOP. Meskipun ada ketidaksepakatan dengan pesan dasar dari publikasi pertama yang tercermin dalam judul dan keraguan tentang kewajaran penerapan konsep monad dalam bentuk eksplisit dalam bahasa yang berorientasi pada OOP, penulis tidak dapat ditegur karena kurangnya elaborasi materi. Tetapi ada satu aspek dasar, yang tidak bisa saya abaikan. Ini adalah semacam vulgarisasi pemrograman fungsional, suatu upaya untuk menganggapnya sebagai seperangkat alat dan pendekatan sederhana untuk desain program. Yang, menurut saya, tidak sepenuhnya benar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, dalam artikel ini, upaya dilakukan untuk menunjukkan bahwa sifat-sifat program fungsional yang penulis coba untuk mereproduksi dalam kode-nya bukan fondasi pemrograman fungsional, tidak ditetapkan oleh pencipta bijih Haskell dan solusi desain sejenisnya, tetapi juga konsekuensi langsung dari konsep dan model yang benar-benar diletakkan di atas fondasinya, atau, cukup aneh, upaya untuk mengimbangi kekurangan yang dihasilkan yayasan ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi intinya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam sains, cukup sering Anda dapat mengamati metamorfosis berikut. Pertama, sebagai bagian dari pertimbangan proses / fenomena / teori tertentu, objek tertentu muncul yang memiliki beberapa sifat penting dan berguna. Tetapi biasanya juga ternyata menjadi agak rumit dalam strukturnya, yang membatasi kegunaan praktisnya. Oleh karena itu, mereka sering bertindak dengan cara ini: mereka mengambil properti dari objek yang diberikan sebagai dasar dan atas dasar ini membangun teori / model / deskripsi baru, di mana objek yang diinginkan menjadi sederhana atau bahkan sepele, atau sifat-sifat inheren yang diperlukan muncul di objek yang lebih sederhana. Sesuatu seperti ini terkait dengan pemrograman fungsional "nyata" dan "elemen pemrograman fungsional", yang tersedia dalam bahasa modern tingkat tinggi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena biasanya berguna untuk membiasakan diri dengan sejarah asal usulnya untuk memahami suatu fenomena, marilah kita mengingat kembali saat-saat sejarah teori komputasi dan pemrograman yang penting untuk pertanyaan kita. Pada akhir abad kesembilan belas dan awal abad kedua puluh ada restrukturisasi yang signifikan dari dasar ilmu matematika. Ini tidak hanya memecahkan sejumlah masalah yang diidentifikasi dan kontradiksi yang merangkak ke inti gagasan pada waktu itu bahwa ada bukti matematika dan matematika, tetapi juga menimbulkan sejumlah pertanyaan baru. Salah satunya adalah sebagai berikut: apa algoritma? Atau, apa yang sama, kelas masalah apa yang dapat dipecahkan sepenuhnya secara mekanis. Saya tidak akan menyebarkan mengapa pertanyaan ini ternyata penting, saya lebih baik langsung ke jawaban yang diberikan oleh Alan Turing, yang dikenal luas di kalangan yang tidak terlalu sempit. Dia merumuskan tesis:"Hanya fungsi yang dapat membuat mesin Turing dapat dihitung." Pernyataan ini tidak terbukti. Faktanya, Turing hanya memberikan definisi formal yang ketat tentang apa yang dianggap sebagai fungsi yang dapat dihitung, konsisten dengan representasi intuitif yang biasanya tertanam dalam konsep ini. Definisi ini terbukti dapat memuaskan pelamar, karena mereka sangat menyadari apa itu mesin, bahkan dengan pita tanpa batas, dan bagaimana fungsinya. Tetapi bagi banyak matematikawan, definisi ini tidak terlalu memuaskan.yang biasanya diinvestasikan dalam konsep ini. Definisi seperti itu mampu memuaskan pelamar, karena mereka sangat menyadari apa itu mesin, bahkan dengan pita tanpa batas, dan bagaimana fungsinya. Tetapi bagi banyak matematikawan, definisi ini tidak terlalu memuaskan.yang biasanya diinvestasikan dalam konsep ini. Definisi ini terbukti dapat memuaskan pelamar, karena mereka sangat menyadari apa itu mesin, bahkan dengan pita tanpa batas, dan bagaimana fungsinya. Tetapi bagi banyak matematikawan, definisi ini tidak terlalu memuaskan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya, konsep yang dioperasikan Turing bagi mereka tampaknya tidak cukup ... abstrak. </font><font style="vertical-align: inherit;">Dalam hal ini, mereka tidak meninggalkan upaya untuk memberikan definisi yang berbeda, yang akan mencakup kelas fungsi matematika yang lebih besar dan pada saat yang sama masih sesuai dengan ide-ide intuitif kita. </font><font style="vertical-align: inherit;">Upaya ini tidak membuahkan hasil. </font><font style="vertical-align: inherit;">Setiap definisi alternatif yang diajukan dan bertahan dari kritik ternyata setara dengan definisi Turing dalam arti bahwa ia menggambarkan kelas fungsi matematika yang persis sama. </font><font style="vertical-align: inherit;">Namun, studi ini tidak berarti sia-sia. </font><font style="vertical-align: inherit;">Upaya untuk melihat objek studi dari sudut pandang yang berbeda biasanya jarang sia-sia. </font><font style="vertical-align: inherit;">Dalam kasus kami, ini menyebabkan munculnya beberapa teori, salah satunya adalah kalkulus lambda yang diusulkan oleh Gereja Alonzo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemalasan adalah mesin kemajuan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang sangat berguna dalam kalkulus lambda dan mengapa semua orang begitu sibuk dengannya? Semuanya sederhana. Dalam model yang diusulkan oleh Turing, algoritme adalah urutan instruksi yang tidak asing lagi bagi kita, yang lagi-lagi harus dijalankan oleh pemain biasa. Itu intuitif. Tetapi definisi Gereja berbeda. Mekanisme pembangunan utama (dan satu-satunya satu-satunya) dalam kerangka teori ini adalah apa yang disebut istilah lambda, yang dalam istilah kita saat ini dapat (secara kondisional) disebut fungsi anonim. Program (algoritma) dalam hal ini adalah kombinasi dari istilah-istilah yang dibangun sesuai dengan aturan tertentu, data awal adalah nilai-nilai variabel bebas dari istilah lambda, dan proses perhitungan tidak lebih dari pengurangan (penyederhanaan) dari istilah lambda (fungsi), yang dapat dilakukansegera setelah beberapa variabel gratis mendapat nilai. Fakta berikut ternyata tidak terduga di sini: segera setelah variabel menerima nilai - yaitu, segera setelah kami menyajikan bagian dari data awal ke program - kami dapat melakukan pengurangan, tetapi tidak dalam satu, tetapi dengan dua cara. Dalam kasus pertama, proses perhitungan ternyata setara dengan yang direproduksi oleh kalkulator mekanik khas seperti mesin Turing. Aturannya sesuai dengan itu: argumen fungsi harus dihitung sebelum fungsi itu sendiri dihitung. Tetapi ada opsi lain - yang disebut perhitungan parsial. Dalam hal ini, jika hanya sebagian dari argumen yang dihitung, kami masih dapat menghitung (mengurangi) bagian dari fungsi yang hanya menggunakan argumen ini. Pendekatan ini biasanya disebut model komputasi "malas".Berbeda dengan ini, model komputasi Turing kadang-kadang disebut "energik" atau "serakah", bahasa pemrograman yang dibangun atas dasar akan disebut imperatif di bawah ini. Fitur penting dari perhitungan "malas" adalah bahwa jika subrutin ditulis sebagai fungsi, katakanlah, tiga argumen, tetapi dalam kenyataannya hanya menggunakan dua, maka tidak perlu menghitung argumen ketiga ini untuk menghitung nilai fungsi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ini memberi kita kemungkinan praktis yang menarik. </font><font style="vertical-align: inherit;">Misalnya, kemampuan untuk bekerja dengan urutan yang tak terbatas. </font><font style="vertical-align: inherit;">Hal ini tidak sulit bagi siapa saja yang mulai mengenal pemrograman fungsional pada umumnya dan dengan bahasa Haskell khususnya untuk memahami cara ini untuk mendapatkan pertama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angka Fibonacci:</font></font><br>
<br>
<pre><code class="haskell">fibonacci2 a b = a : (fibonacci2 b (a+b))<font></font>
fibonacci = fibonacci2 1 1<font></font>
<font></font>
nfibonacci n = take n fibonacci</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjelasan untuk Orang Asing dengan Haskell</font></font></b><div class="spoiler_text"><i>fibonacci2</i>      ,       ,         fibonacci2    b   (a+b).  ( !)     :<br>
<pre><code class="python">def fibonacci2(a, b) :<font></font>
    return [a] + fibonacci2(b, a+b)<font></font>
<font></font>
def fibonacci() :<font></font>
    return fibonacci2(1, 1)<font></font>
<font></font>
def nfibonacci(n) :<font></font>
    res = []<font></font>
    data = fibonacci()<font></font>
    for i in range(n) :<font></font>
      res.append( data[i] )<font></font>
    return res<font></font>
</code></pre><br>
   nfibonacci.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dan inilah tepatnya fungsinya) menghasilkan daftar angka tanpa akhir. Jika kita menggunakan model komputasi yang akrab bagi kita, maka nfibonacci tidak akan pernah berakhir (yang, saya ingat, sangat dapat diterima dan tidak bertentangan dengan gagasan "komputabilitas" -nya). Tetapi jika kita menggunakan model perhitungan "malas", mudah untuk memperhatikan bahwa begitu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengambil nilai tertentu, untuk mendapatkan nilai fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nfibonacci,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita hanya perlu elemen n pertama dari daftar yang merupakan hasil dari fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam hal ini, kita dapat bertindak seperti ini: dapatkan item daftar - melakukan reduksi, elemen berikutnya adalah langkah reduksi lain, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argumen ke-10 - reduksi menghasilkan nilai fungsi. Artinya, dalam hal ini kita mendapatkan hasil untuk waktu yang terbatas meskipun ada "loop" dari prosedur untuk membangun daftar angka Fibonacci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, seorang pembaca yang berpikiran imperatif sangat bersemangat berseru: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi tunggu, hanya orang bodoh jujur â€‹â€‹yang akan mengimplementasikan konstruksi daftar angka Fibonacci dengan cara ini! Ada solusi yang jelas yang tidak mengarah ke satu lingkaran.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Dan dia, tentu saja, akan benar. Pemindahan bodoh dari sebuah solusi yang melibatkan implementasi model perhitungan" malas "ke dalam sebuah program untuk perhitungan" serakah "sebenarnya bukanlah indikator kecerdasan yang hebat. Jika Anda menawarkan tugas ini kepada seorang programmer yang telah mempertahankan seluruh kehidupan profesionalnya. Loyalitas, katakanlah, untuk bahasa C, maka ia kemungkinan besar akan menawarkan varian dengan satu siklus dengan penghitung dan dua variabel status.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi intinya bukan angka Fibonacci itu sendiri. Faktanya adalah bahwa aturan untuk membangun urutan dalam contoh ini dipisahkan dari metode pemrosesan elemen-elemennya. Dan ini adalah properti yang berguna yang diinginkan untuk dapat mereproduksi dalam kasus-kasus yang lebih kompleks, ketika elemen-elemen dari urutan diproses dihasilkan dalam cara yang agak rumit dan transfer sederhana dari solusi "langsung" untuk urutan Fibonacci dalam kasus ini tidak efektif dalam waktu, memori, atau hanya mengarah ke kode, pemahaman yang tidak dapat diakses oleh manusia belaka. Aspirasi semacam itu wajar dan dapat diwujudkan, misalnya, melalui penggunaan iterator atau generator. Dalam python, misalnya, kita bisa melakukan ini:</font></font><br>
<br>
<pre><code class="python">def fibonacci() :<font></font>
    a = 1<font></font>
    b = 1<font></font>
    yield a<font></font>
    yield b<font></font>
    while True :<font></font>
      c = a + b<font></font>
      yield c<font></font>
      a = b<font></font>
      b = c<font></font>
     <font></font>
def nfibonacci(n) :<font></font>
    return [e for e in itertools.islice(fibonacci(), n)]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah generator yang membuat elemen urutan dengan elemen. Dan dalam hal ini, alih-alih </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci, mungkin ada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fungsi generator dari kompleksitas. Jika kita membawa kode sepenuhnya, termasuk kode kap mesin, kita mendapatkan desain perangkat lunak yang sangat kompleks dan sangat penting. Tetapi versi finalnya cukup "fungsional". Dalam C ++, seseorang dapat melakukan trik serupa dengan memiliki kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibonachi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> khusus </font><font style="vertical-align: inherit;">dan iterator untuk itu. Keputusan akan bervariasi tergantung pada fitur bahasa pemrograman dan preferensi programmer, tetapi tujuannya akan tetap sama - untuk membagi di tingkat organisasi program cara untuk membangun urutan panjang yang sebelumnya tidak diketahui dan cara untuk memproses elemen-elemennya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perbedaannya adalah bahwa dalam kerangka pendekatan fungsional, organisasi program semacam itu adalah alami dan dipaksakan oleh metode pelaksanaannya, sedangkan dalam kerangka program imperatif itu membutuhkan kerja kreatif tambahan, termasuk penciptaan konsep tambahan dan pola desain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebersihan adalah kunci kesehatan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Properti lain, di mana mereka berbicara tentang pendekatan fungsional untuk pemrograman, adalah "kemurnian" fungsi. </font><font style="vertical-align: inherit;">Ini adalah tidak adanya efek samping. </font><font style="vertical-align: inherit;">Yaitu, pemanggilan fungsi dengan argumen yang sama harus mengarah pada hasil yang sama. </font><font style="vertical-align: inherit;">Penulis </font><font style="vertical-align: inherit;">posting yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dikutip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menjelaskan secara rinci mengapa dalam program yang dijalankan dengan gaya imperatif, properti ini juga diinginkan. </font><font style="vertical-align: inherit;">Namun, itu tidak lebih dari konsekuensi dari model perhitungan yang digunakan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasan bahwa semua fungsi dalam program fungsional harus bersih adalah sederhana. Dengan asumsi adanya efek samping ini, ternyata urutan di mana argumen fungsi mendapatkan nilainya secara langsung mempengaruhi hasil fungsi. Kita dapat mengatakan bahwa ini juga benar dalam kerangka pendekatan imperatif, tetapi dalam kasus "kemalasan" perhitungan, semuanya jauh lebih buruk. Bahkan jika kita mengasumsikan bahwa argumen fungsi dapat dihitung secara independen dari satu sama lain dalam urutan yang sewenang-wenang, maka "kemalasan" masih menyiratkan bahwa (secara kondisional) tidak semua kode fungsi akan dieksekusi dalam satu duduk. Ini akan dieksekusi dalam bagian-bagian, tergantung pada dua hal - pada kenyataannya, struktur fungsi yang akan disediakan oleh kompiler bersyarat kepada kami, dan urutan di mana kami akan menyajikan fungsi dengan argumennya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wajar bagi kita untuk berharap bahwa jika kita pertama mendefinisikan suatu fungsi </font></font><br>
<br>
<pre><code class="python">def f(x,y) :<font></font>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan setelahnya </font></font><br>
<pre><code class="python">def g(x, y) :<font></font>
  return f(y, x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maka hasil pemanggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (a, b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan sama dengan hasil pemanggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (b, a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk setiap nilai yang dapat dihitung secara independen dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki efek samping yang memengaruhi perhitungan nilai argumen, maka harapan kita bisa tertipu secara brutal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Misalnya, ketika menghitung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , membaca dari file terjadi - dan ketika menghitung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , membaca dari file yang sama juga terjadi. </font><font style="vertical-align: inherit;">Dalam perhitungan "malas", kami tidak tahu sebelumnya bagian mana dari kode (untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) akan dieksekusi terlebih dahulu. Itu artinya kita tidak tahu hasil apa yang akan diberikan program walaupun kita tahu isi file yang seharusnya dibaca. Perilaku seperti itu pada prinsipnya tidak dapat diterima dan karenanya harus dikecualikan secara kategoris. Jadi, dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kerangka model perhitungan "malas" (tidak terkendali) efek samping dari fungsi harus dilarang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika urutan perhitungan serakah diterapkan, efek sampingnya jauh lebih dapat diprediksi. Untuk ini dan hanya untuk alasan ini mereka diizinkan dalam pemrograman imperatif. Tetapi jika Anda menyalahgunakannya, maka fitur tersebut akan berubah menjadi bug. Jadi, Anda tidak harus menyalahgunakannya. Jadi, sekali lagi, konsep "kemurnian" yang alami dalam pemrograman fungsional sangat diminati di dunia imperatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konsekuensinya, tesis</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program fungsional - program yang terdiri dari fungsi murni </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salah jika dilihat sebagai definisi. </font><font style="vertical-align: inherit;">Ya, program fungsional terdiri dari fungsi "murni", tetapi program yang terdiri dari fungsi murni tidak harus "fungsional" sama sekali. </font><font style="vertical-align: inherit;">Ini adalah miliknya, tetapi bukan properti yang menentukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, ada masalah. Kemampuan untuk menyelamatkan keadaan dan bahkan input-output dangkal adalah hal-hal yang berhubungan langsung dengan efek samping. Dan hidup tanpa mereka penuh dengan rasa sakit dan penderitaan. Timbul pertanyaan: bagaimana mengawinkan efek samping dan perhitungan "malas"? Jawabannya secara umum tidak mungkin. Jawabannya benar - dalam setiap kasus solusi khusus yang memuaskan harus dicari. Ternyata banyak cara mereproduksi perhitungan dengan efek samping tanpa melanggar konsep â€œkemurnianâ€ perhitungan yang sesuai dengan konsep umum monad, yang dipinjam dari teori kategori. Saya tidak ingin mencoba lagi untuk menjelaskan apa itu dan apa yang dimakan, jika hanya karena dalam hal apa pun itu tidak akan menggantikan (dan dalam pengalaman saya itu bahkan tidak akan menyederhanakan) penjelasan tentang bagaimana variabel keadaan dapat diterapkan secara spesifik,pengecualian dan hal serupa dalam bahasa fungsional "murni". Moral utama adalah bahwa pemrograman imperatif adalah sumber inspirasi untuk fungsional maupun fungsional untuk imperatif. Selain itu, kadang-kadang sebuah ide melewati konsep yang bersaing seperti melalui filter, kembali dalam bentuk yang diubah dan mengarah ke tampilan alat baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah monad dibutuhkan di dunia imperatif? Saya tidak memiliki opini yang kuat tentang masalah ini. Penulis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puasa yakin itu dibutuhkan. Saya cenderung meragukan pernyataan ini, karena penggunaan konsep monad dalam program fungsional biasanya dihubungkan dengan fakta bahwa algoritma tertentu dapat dirumuskan terlepas dari efek samping spesifik apa yang disembunyikan monad ini. Dengan kata lain, jika tipe data yang ditentukan pengguna (hipotetis, belum dibuat oleh manusia) memenuhi persyaratan untuk monad, maka algoritma tertulis untuknya akan bekerja dengan benar. Ini nyaman terutama dalam studi teoritis. Namun ada beberapa nuansa. Pertama, tidak terlalu jelas mengapa bersembunyi di bungkus efek samping efektif dalam bahasa yang mereka adalah fenomena alam. Kedua,ketika menulis program spesifik dengan tipe data spesifik dan arsitektur target spesifik, algoritma umum seperti itu paling sering dipaksa untuk menjalani restrukturisasi untuk meningkatkan produktivitas. Menulis algoritma umum menggunakan monad dalam gaya imperatif adalah mungkin, tetapi kesesuaian pendekatan ini menimbulkan keraguan saya. Fakta bahwa beberapa analog Mungkin dari tipe std :: opsional dari C ++ akan dinyatakan sebagai monad tidak mungkin mempengaruhi praktik penggunaannya.</font></font><br>
<br>
<h3>   ?</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi tingkat tinggi adalah alat yang begitu banyak digunakan dalam program fungsional sehingga fakta mendukung sesuatu yang serupa dalam beberapa bahasa pemrograman sudah cukup bagi beberapa individu aneh untuk mengenali bahasa ini sebagai fungsional. Apa itu "fungsi tingkat tinggi"? Ini adalah fungsi yang beroperasi pada fungsi lain sebagai argumen, atau mengembalikan fungsi sebagai hasilnya. Tampaknya di sini dapat menyebabkan perdebatan? Ternyata banyak. Untuk memulainya, apa yang umumnya dipahami dengan istilah "fungsi". Pemrogram biasanya beralasan sederhana: jika sesuatu dapat disebut sebagai fungsi, maka itu dapat dianggap sebagai fungsi. Dalam kerangka pendekatan imperatif, ini masuk akal, karena secara intuitif fungsi adalah bahwa untuk serangkaian argumen tertentu ia memberikan hasil tertentu.Jika kita mengakui adanya efek samping, maka dalam arti praktis benar-benar tidak ada perbedaan antara fungsi "normal" bahasa dan, katakanlah, objek kelas memiliki operator kelebihan beban ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi dalam pemrograman fungsional, definisi fungsi semacam itu tidak cukup konstruktif, karena tidak memungkinkan untuk menafsirkan konsep perhitungan parsial dari fungsi ini sendiri. Dalam pemrograman fungsional, fungsi bukan "salah satu" elemen struktural dari suatu program, tetapi dalam arti tertentu sebaliknya: semua elemen program adalah fungsi. Karena itu, pada kenyataannya, ini adalah "pemrograman fungsional". Dan sekali lagi, jika semuanya adalah fungsi, yaitu, setiap argumen dari fungsi apa pun adalah fungsi, maka setiap fungsi dengan argumen adalah fungsi tingkat tinggi. Oleh karena itu, fungsi tingkat tinggi adalah elemen alami dari program fungsional. Sedemikian rupa sehingga bahkan alokasi mereka di kelas yang terpisah tidak masuk akal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai fungsi urutan yang lebih tinggi, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font><i><font style="vertical-align: inherit;">lipatan</font></i><font style="vertical-align: inherit;"> biasanya diberikan.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tetapi kami akan mempertimbangkan fungsi yang lebih sepele dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sembarang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumen dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x, y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam kerangka model perhitungan "malas", argumen fungsi ini akan dihitung hanya ketika mereka benar-benar diperlukan. Misalkan argumen pertama adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menghitung argumen ini, memberikan nilainya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan, di samping itu, menghitung semua yang dapat kami hitung tanpa menggunakan nilai argumen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kemudian sisa perhitungan dapat direpresentasikan sebagai fungsi baru, sudah </font><font style="vertical-align: inherit;">independen </font><font style="vertical-align: inherit;">dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , misalnya, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi dalam kasus ini, tidak ada yang mencegah kita secara formal menyajikan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bukan sebagai fungsi dari dua argumen, tetapi sebagai fungsi dari satu argumen</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang hasilnya adalah fungsi lain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dengan kata lain, dalam kerangka pendekatan fungsional, setiap fungsi </font><font style="vertical-align: inherit;">argumen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N&gt; 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah fungsi urutan yang lebih tinggi, karena dapat diartikan sebagai fungsi dari satu argumen, yang hasilnya adalah fungsi </font><font style="vertical-align: inherit;">argumen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisakah kita menerapkan perilaku ini sebagai bagian dari pendekatan imperatif? Tentu saja kita bisa. Dengan python, kita akan menulis sesuatu seperti berikut:</font></font><br>
<br>
<pre><code class="python">def partial(f, x) :<font></font>
	def g(*args) :<font></font>
		return f(x, *args)<font></font>
	return g<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan memanggil fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parsial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , argumen pertama yang merupakan fungsi </font><font style="vertical-align: inherit;">argumen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan yang kedua adalah nilai argumen pertama, kita mendapatkan fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1 dari</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumen. Sekarang kita bisa menggunakan fungsi baru di mana pun kita bisa menggunakan fungsi </font><font style="vertical-align: inherit;">argumen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Artinya, mereka mendapat hal yang sama seperti pada program fungsional. Begitu? Tidak tidak seperti ini. Jika kita berurusan dengan program yang benar-benar fungsional, maka ketika kita memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parsial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kita akan menghitung sebagian dari nilai untuk argumen pertama. Dalam beberapa kasus, bahkan mungkin ternyata </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah nilai konstan. Apa yang kita miliki dalam analog imperatif? Nilai argumen yang dilewati </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baru ingat (ditambahkan ke konteks fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ketika kita memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan dikeluarkan dari nampan dan diganti menjadi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Artinya, tidak ada perbedaan dalam bentuk, tetapi dalam konten - signifikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan fungsi dari fungsi itu nyaman karena memungkinkan Anda untuk menggambarkan banyak algoritma penting secara alami. Jadi, mereka diwajibkan untuk tampil dalam bahasa pemrograman imperatif. Dan mereka muncul. Tetapi karena mereka menggunakan model perhitungan yang berbeda, ini akan membutuhkan pengembangan konsep baru. Dan mereka dikembangkan. Misalnya, penutupan yang dijelaskan di atas. Yaitu, fungsi orde yang lebih tinggi dalam bahasa imperatif sesuai dengan apa yang dapat diamati dalam bahasa fungsional, hanya secara eksternal. Tetapi isinya sangat berbeda. Apakah ini penting bagi programmer? Mungkin tidak, tetapi hanya jika dia mengerti dengan baik bagaimana mekanisme itu bekerja yang mengimplementasikan fitur serupa dalam bahasa pemrograman favoritnya. Jika tidak, Anda dapat, misalnya, menerapkan "sebagian aplikasi", tutup ketika membangun fungsi baru (baik, atauapa yang dalam kasus Anda akan terlihat seperti fungsi) tautan dan bukan nilai dan dapatkan perilaku program yang menarik. Dan setelah itu, berteriak tentang inferioritas pendekatan fungsional.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi siapa yang curang pada siapa?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap presentasi ini, sangat mungkin untuk meletakkan titik koma dan kembali ke pertanyaan utama. </font><font style="vertical-align: inherit;">Karena sekarang kita dapat merumuskan pernyataan berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan utama antara pemrograman fungsional dan pemrograman imperatif bukanlah sifat kemurnian fungsi, keberadaan fungsi anonim, fungsi tingkat tinggi, monad, polimorfisme parametrik, atau apa pun. </font><font style="vertical-align: inherit;">Perbedaan utama adalah penggunaan model perhitungan yang berbeda. </font><font style="vertical-align: inherit;">Segala sesuatu yang lain tidak lebih dari konsekuensi.</font></font></li>
<li>,         ,       .    .     ,      Â«Â»  Â«Â» .    ,                  .  .</li>
<li>  ,      ,        ,           .        .   â€” .</li>
<li>      ,      .       ,        Â«Â» ;   ,       .           ,      -     ,   -      .    .</li>
<li>   ,                 .     ,        . , ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>    ,                           .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemrograman fungsional adalah apa yang Anda (mungkin) diberitahu tentang. Ini adalah pengurangan beta, kombinator titik tetap, monad, pengetikan Hindley-Milner, dan banyak lagi. Jangan bingung pembungkus dengan konten. FP tidak didasarkan pada matematika yang paling sederhana, itu tidak dapat dikuasai untuk beberapa malam dengan segelas teh; tidak mungkin diproyeksikan secara langsung ke masalah dan proyek mendesak Anda, Anda tidak akan mendapatkan keuntungan yang dijamin dan cepat dari pengetahuan ini. Tetapi banyak elemen dari apa yang ada dalam pendekatan fungsional dipinjam, diproses, dan pada akhirnya diimplementasikan dalam bahasa pemrograman yang berorientasi pada pengembangan proyek-proyek besar. Ya, mereka diatur secara berbeda dari leluhur fungsional mereka, tetapi ini tidak membuat mereka kurang berguna. Hanya idiot klinis yang akan menyiarkan pesan serius bahwa Haskell adalah bahasa yang buruk,karena sulit untuk menulis program untuk segala jenis akuntansi. Seseorang dibebani dengan kehadiran kecerdasan, bahkan dari sudut pandang aktivitas profesionalnya, tanpa membenamkan dalam seluk-beluk teori cukup mampu memahami dengan tepat praktik mana dari pemrograman fungsional yang harus diadopsi untuk membuat kode Anda lebih baik. Untuk demonstrasi yang meyakinkan yang saya sampaikan terima kasih</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psyhast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelajari pemrograman fungsional. </font><font style="vertical-align: inherit;">Atas nama dirimu sendiri.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492448/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 406 (9-15 Maret, 2020)</a></li>
<li><a href="../id492450/index.html">Diperbarui 03.31. Apakah coronavirus ditularkan melalui udara? Apa yang diketahui saat ini</a></li>
<li><a href="../id492454/index.html">Kami menjual Arsitektur Refactoring ke klien atau apa masalah pengembang</a></li>
<li><a href="../id492456/index.html">Cara memvisualisasikan dan menghidupkan model (geofisika). Tampilkan data mentah</a></li>
<li><a href="../id492458/index.html">GUI sederhana untuk M5Stack (Arduino)</a></li>
<li><a href="../id492462/index.html">Sumber kebenaran: bagaimana seorang analis mengajar manajer dan pengembang untuk bekerja bersama</a></li>
<li><a href="../id492464/index.html">DBA: kompeten mengatur sinkronisasi dan impor</a></li>
<li><a href="../id492466/index.html">Cara pindah dari penyedia host mana pun dengan cPanel ke Plesk di Rusonix hanya dalam lima langkah</a></li>
<li><a href="../id492468/index.html">Lenovo Thinkserver SE350: pahlawan dari pinggiran</a></li>
<li><a href="../id492474/index.html">Kami menyusun informasi pada kotak Android dan menganalisis apa yang bisa dilakukan oleh awalan normal.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>