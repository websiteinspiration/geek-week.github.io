<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐊 🛠️ 🕢 PEP 572 (expressions d'affectation en python 3.8) 💃🏻 🥅 🈳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr. Cette fois, nous examinerons le PEP 572, qui parle d'expressions d'affectation. Si vous êtes toujours sceptique vis-à-vis de l'opérateu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572 (expressions d'affectation en python 3.8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr. </font><font style="vertical-align: inherit;">Cette fois, nous examinerons le PEP 572, qui parle d'expressions d'affectation. </font><font style="vertical-align: inherit;">Si vous êtes toujours sceptique vis-à-vis de l'opérateur ": =" ou si vous ne comprenez pas parfaitement les règles de son utilisation, cet article est pour vous. </font><font style="vertical-align: inherit;">Vous trouverez ici de nombreux exemples et réponses à la question: «Pourquoi en est-il ainsi?» </font><font style="vertical-align: inherit;">Cet article s'est avéré être aussi complet que possible, et si vous avez peu de temps, alors regardez la section que j'ai écrite. </font><font style="vertical-align: inherit;">À ses débuts, les principales «thèses» sont rassemblées pour un travail confortable avec des expressions d'affectation. </font><font style="vertical-align: inherit;">Pardonnez-moi à l'avance si vous trouvez des erreurs (écrivez-moi, je vais les corriger). </font><font style="vertical-align: inherit;">Commençons:</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572 - Expressions d'affectation</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamisme</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Titre:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressions d'affectation</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auteurs:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;rosuav at gmail.com&gt;, Tim Peters &lt;tim.peters at gmail.com&gt;, Guido van Rossum &lt;guido at python.org&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussion:</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doc-sig sur python.org</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statut:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accepté</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un type:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la norme</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créé:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-févr.-2018</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version Python:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Histoire de poste:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-févr.-2018, 02-mars-2018, 23-mars-2018, 04-avr-2018, 17-avr-2018, 25-avr-2018, 09-juil-2018, 05-août-2019</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorisation d'adopter la norme:</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (avec VPN depuis longtemps, mais il se charge)</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annotation</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justification</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxe et sémantique</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifications des spécifications lors de la mise en œuvre</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatives rejetées</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objections fréquentes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recommandations de style</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe A: Conclusions de Tim Peters</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe B: Un interpréteur de code approximatif pour les générateurs</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe C: Aucun changement dans la sémantique de la portée</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">droits d'auteur</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ma partie</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annotation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette convention parlera de la possibilité d'affectation à l'intérieur des expressions, en utilisant la nouvelle notation NAME: = expr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cadre des innovations, la procédure de calcul des générateurs de dictionnaire (compréhension de dictionnaire) a été mise à jour. Cela garantit que l'expression de clé est évaluée avant l'expression de valeur (cela vous permet de lier la clé à une variable, puis de réutiliser la variable créée dans le calcul de la valeur correspondant à la clé). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cours d'une discussion sur ce PEP, cet opérateur est devenu officieusement connu sous le nom d'opérateur de morse. Le nom officiel de la construction est «Expression d'affectation» (selon le titre PEP: Expressions d'affectation), mais il peut être appelé «Expressions nommées». Par exemple, l'implémentation de référence dans CPython utilise ce même nom.</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justification</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nommage est une partie importante de la programmation qui vous permet d'utiliser un nom «descriptif» au lieu d'une expression plus longue, et facilite également la réutilisation des valeurs. </font><font style="vertical-align: inherit;">Actuellement, cela ne peut se faire que sous forme d'instructions, ce qui rend cette opération indisponible lors de la génération de listes (compréhension de liste), ainsi que dans d'autres expressions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, le fait de nommer des parties d'une grande expression peut aider au débogage interactif en fournissant des outils pour afficher des invites et des résultats intermédiaires. </font><font style="vertical-align: inherit;">Sans la possibilité de capturer les résultats d'expressions imbriquées, vous devrez modifier le code source, mais en utilisant les expressions d'affectation, il vous suffit d'insérer quelques "marqueurs" du formulaire "nom: = expression". </font><font style="vertical-align: inherit;">Cela élimine le refactoring inutile et réduit donc la probabilité de modifications de code involontaires pendant le débogage (une cause courante des Heisenbugs est des erreurs qui modifient les propriétés du code pendant le débogage et peuvent apparaître de manière inattendue en production]), et ce code sera plus compréhensible pour un autre au programmeur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'importance du vrai code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cours de l'élaboration de ce PEP, de nombreuses personnes (partisans et critiques) se sont trop concentrées sur les exemples de jouets d'une part et les exemples trop complexes de l'autre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le danger des exemples de jouets est double: ils sont souvent trop abstraits pour faire dire à quelqu'un "oh, c'est irrésistible", et ils sont aussi facilement rejetés avec les mots "je n'écrirais jamais ça". Le danger d'exemples trop complexes est qu'ils fournissent un environnement pratique pour les critiques suggérant que cette fonctionnalité soit supprimée («C'est trop déroutant», disent de telles personnes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, ces exemples sont utiles: ils aident à clarifier la sémantique voulue. Par conséquent, nous en donnerons certains ci-dessous. Cependant, pour être </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convaincant</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les exemples doivent être basés sur</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un vrai</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code qui a été écrit sans penser à ce PEP. Autrement dit, le code qui fait partie d'une application vraiment utile (aucune différence: qu'il soit grand ou petit). Tim Peters nous a beaucoup aidés en consultant ses répertoires personnels et en choisissant des exemples de code qu'il a écrit, qui (à son avis) seraient plus compréhensibles s'ils étaient réécrits (sans fanatisme) à l'aide d'expressions d'affectation. Sa conclusion est la suivante: les changements actuels apporteraient une amélioration modeste mais évidente dans quelques morceaux de son code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre exemple de code réel est l'observation indirecte de la façon dont les programmeurs apprécient la compacité. Guido van Rossum a vérifié la base de code Dropbox et a trouvé des preuves que les programmeurs préfèrent écrire moins de lignes de code que d'utiliser quelques petites expressions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemple: Guido a trouvé plusieurs points illustratifs lorsqu'un programmeur répète une sous-expression (ralentissant ainsi le programme), mais enregistre une ligne de code supplémentaire. </font><font style="vertical-align: inherit;">Par exemple, au lieu d'écrire:</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les programmeurs ont préféré cette option:</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un autre exemple montrant que les programmeurs sont parfois prêts à faire plus de travail pour maintenir le «niveau précédent» d'indentation:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code calcule pattern2, même si pattern1 correspond déjà (dans ce cas, la deuxième sous-condition ne sera jamais remplie). </font><font style="vertical-align: inherit;">Par conséquent, la solution suivante est plus efficace, mais moins attrayante:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxe et sémantique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la plupart des cas où Python utilise des expressions arbitraires, vous pouvez désormais utiliser des expressions d'affectation. </font><font style="vertical-align: inherit;">Ils ont la forme NAME: = expr, où expr est n'importe quelle expression Python valide, à l'exception du tuple non parenthésé, et NAME est l'identifiant. </font><font style="vertical-align: inherit;">La valeur d'une telle expression coïncide avec l'original, mais un effet supplémentaire est l'attribution d'une valeur à l'objet cible:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cas exceptionnels</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe plusieurs endroits où les expressions d'affectation ne sont pas autorisées afin d'éviter toute ambiguïté ou confusion parmi les utilisateurs:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les expressions d'affectation non incluses entre parenthèses sont interdites au niveau «supérieur»:</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette règle permettra au programmeur de choisir plus facilement entre un opérateur d'affectation et une expression d'affectation - il n'y aura pas de situation syntaxique dans laquelle les deux options sont équivalentes.</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une expression d'affectation n'introduit pas de nouvelle étendue. Dans la plupart des cas, l'étendue dans laquelle la variable sera créée ne nécessite aucune explication: elle sera à jour. Si la variable a utilisé les mots clés non locaux ou globaux auparavant, l'expression d'affectation en tiendra compte. Seul lambda (étant une définition anonyme d'une fonction) est considéré comme une portée distincte à ces fins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un cas particulier: une expression d'affectation qui se produit dans les générateurs de listes, d'ensembles, de dictionnaires ou dans les «expressions des générateurs» eux-mêmes (ci-après collectivement appelés «générateurs» (compréhensions)) lie la variable à la portée que contient le générateur, en observant le modificateur globab ou non global, s'il en existe un.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La justification de ce cas spécial est double. </font><font style="vertical-align: inherit;">Premièrement, cela nous permet de capturer facilement le «membre» dans les expressions any () et all (), par exemple:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxièmement, il fournit un moyen compact de mettre à jour une variable à partir d'un générateur, par exemple:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, le nom de la variable de l'expression d'affectation ne peut pas correspondre au nom déjà utilisé dans les générateurs par la boucle for pour itérer. </font><font style="vertical-align: inherit;">Les noms de famille sont locaux au générateur dans lequel ils apparaissent. </font><font style="vertical-align: inherit;">Il serait incohérent si les expressions d'affectation faisaient également référence à la portée dans le générateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, [i: = i + 1 pour i dans la plage (5)] n'est pas valide: la boucle for détermine que i est local au générateur, mais la partie «i: = i + 1» insiste sur le fait que i est une variable de l'extérieur portée </font><font style="vertical-align: inherit;">Pour la même raison, les exemples suivants ne fonctionneront pas:</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien qu'il soit techniquement possible d'attribuer une sémantique cohérente à de tels cas, il est difficile de déterminer si la façon dont nous comprenons cette sémantique fonctionnera dans votre code réel. C'est pourquoi l'implémentation de référence garantit que de tels cas déclenchent SyntaxError plutôt que d'être exécutés avec un comportement non défini, selon l'implémentation matérielle particulière. Cette restriction s'applique même si une expression d'affectation n'est jamais exécutée:</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le corps du générateur (la partie avant le premier mot-clé «pour») et l'expression de filtre (la partie après le «si» et avant tout «pour» imbriqué), cette restriction s'applique exclusivement aux noms de variable qui sont simultanément utilisés comme variables itératives. Comme nous l'avons déjà dit, les expressions Lambda introduisent une nouvelle portée explicite de la fonction et peuvent donc être utilisées dans les expressions des générateurs sans restrictions supplémentaires. [environ. à nouveau, sauf dans de tels cas: [i pour i dans la plage (2, (lambda: (s: = 2) ()))]]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison des limites de conception dans l'implémentation de référence (l'analyseur de table de symboles ne peut pas reconnaître si les noms de la partie gauche du générateur sont utilisés dans la partie restante où se trouve l'expression itérable), par conséquent, les expressions d'affectation sont complètement interdites dans le cadre de l'itérable (dans la partie après chaque «in» et avant tout mot clé "si" ou "pour"). </font><font style="vertical-align: inherit;">Autrement dit, tous ces cas sont inacceptables:</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre exception se produit lorsqu'une expression d'affectation est utilisée dans des générateurs qui se trouvent dans la portée d'une classe. </font><font style="vertical-align: inherit;">Si, lors de l'utilisation des règles ci-dessus, la création d'une classe remesurée dans la portée devait se produire, alors une telle expression d'affectation n'est pas valide et entraînera une SyntaxError:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(La raison de la dernière exception est la portée implicite de la fonction créée par le générateur - il n'y a actuellement aucun mécanisme d'exécution pour que les fonctions se réfèrent à une variable située dans la portée de la classe, et nous ne voulons pas ajouter un tel mécanisme. Si ce problème est résolu, ce cas spécial (éventuellement) sera supprimé de la spécification des expressions d'affectation. Notez que ce problème se produira même si vous avez créé une variable plus tôt dans la portée de la classe et essayez de la changer avec une expression d'affectation du générateur.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voir l'annexe B pour des exemples de la façon dont les expressions d'affectation trouvées dans les générateurs sont converties en code équivalent.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorité relative: =</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'opérateur: = est groupé plus fort que la virgule dans toutes les positions syntaxiques lorsque cela est possible, mais plus faible que tous les autres opérateurs, y compris ou, et, non, et les expressions conditionnelles (A si C sinon B). Comme indiqué dans la section «Cas exceptionnels» ci-dessus, les expressions d'affectation ne fonctionnent jamais au même «niveau» que l'affectation classique =. Si un ordre d'opérations différent est requis, utilisez des parenthèses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'opérateur: = peut être utilisé directement lors de l'appel de l'argument positionnel d'une fonction. Cependant, cela ne fonctionnera pas directement dans l'argument. Quelques exemples clarifiant ce qui est techniquement autorisé et ce qui n'est pas possible:</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des exemples «valides» ci-dessus ne sont pas recommandés dans la pratique, car les personnes qui analysent rapidement votre code source peuvent ne pas comprendre correctement sa signification. </font><font style="vertical-align: inherit;">Mais dans des cas simples, cela est autorisé:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce PEP vous recommande de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toujours</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mettre des espaces autour: =, similaire à la recommandation du PEP 8 pour = pour une affectation classique. </font><font style="vertical-align: inherit;">(La différence de la dernière recommandation est qu'elle interdit les espaces autour de =, qui est utilisé pour passer des arguments clés à la fonction.)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez l'ordre des calculs.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin d'avoir une sémantique bien définie, cet accord nécessite que la procédure d'évaluation soit clairement définie. </font><font style="vertical-align: inherit;">Techniquement, ce n'est pas une nouvelle exigence. </font><font style="vertical-align: inherit;">Python a déjà une règle selon laquelle les sous-expressions sont généralement évaluées de gauche à droite. </font><font style="vertical-align: inherit;">Cependant, les expressions d'affectation rendent ces «effets secondaires» plus visibles, et nous proposons un changement dans l'ordre de calcul actuel:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les générateurs de dictionnaire {X: Y pour ...}, Y est actuellement évalué avant X. Nous suggérons de le changer pour que X soit calculé avant Y. (Dans un dict classique tel que {X: Y}, ainsi que dans dict ((X, Y) pour ...) ceci a déjà été implémenté. Par conséquent, les générateurs de dictionnaire doivent respecter ce mécanisme)</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différences entre les expressions d'affectation et les instructions d'affectation.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus important encore, ": =" est une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expression</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui signifie qu'elle peut être utilisée dans les cas où les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne </font><b><font style="vertical-align: inherit;">sont</font></b><font style="vertical-align: inherit;"> pas valides, y compris les fonctions lambda et les générateurs. </font><font style="vertical-align: inherit;">Inversement, les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressions d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affectation ne prennent pas en charge la fonctionnalité étendue qui peut être utilisée dans les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affectation:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'affectation en cascade n'est pas prise en charge directement</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les "cibles" séparées, à l'exception du nom de variable simple NAME, ne sont pas prises en charge:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonctionnalité et la priorité des virgules «autour» diffèrent:</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les valeurs de déballage et d'emballage n'ont pas d'équivalence «pure» ou ne sont pas du tout prises en charge</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les annotations de type en ligne ne sont pas prises en charge:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas d'opération abrégée:</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifications des spécifications lors de la mise en œuvre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les modifications suivantes ont été apportées sur la base de notre expérience et d'une analyse supplémentaire après la première rédaction de ce PEP et avant la sortie de Python 3.8:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garantir la cohérence avec d'autres exceptions similaires et pour ne pas introduire un nouveau nom qui pourrait ne pas convenir aux utilisateurs finaux, la sous-classe initialement proposée de TargetScopeError pour SyntaxError a été supprimée et réduite à la SyntaxError habituelle. </font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison des limitations de l'analyse de la table de caractères CPython, l'implémentation de référence de l'expression d'affectation déclenche une SyntaxError pour toutes les utilisations au sein des itérateurs. </font><font style="vertical-align: inherit;">Auparavant, cette exception ne se produisait que si le nom de la variable en cours de création coïncidait avec celui déjà utilisé dans l'expression itérative. </font><font style="vertical-align: inherit;">Ceci peut être révisé s'il existe des exemples suffisamment convaincants, mais la complexité supplémentaire semble inappropriée pour des cas d'utilisation purement «hypothétiques».</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples de bibliothèques standard Python</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base est utilisé uniquement dans une condition, de sorte que l'affectation peut être placée dans if, comme "en-tête" d'un bloc logique.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code actuel:</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code amélioré:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez éviter les if imbriqués, supprimant ainsi un niveau d'indentation.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code actuel:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code amélioré:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code semble plus classique et évite également l'imbrication multiple des instructions conditionnelles. </font><font style="vertical-align: inherit;">(Voir l'annexe A pour en savoir plus sur l'origine de cet exemple.)</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code actuel:</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code amélioré:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz est utilisé uniquement pour s + = tz. </font><font style="vertical-align: inherit;">Le déplacer vers l'intérieur permet de montrer sa zone logique d'utilisation.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code actuel:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code amélioré:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'appel de fp.readline () en tant que «condition» dans la boucle while (ainsi que l'appel de la méthode .match ()) dans la condition if rend le code plus compact sans compliquer sa compréhension.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code actuel:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code amélioré:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifier les générateurs de listes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, le générateur de liste peut être efficacement filtré en "capturant" la condition:</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, la variable peut être réutilisée dans une autre expression:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter à nouveau que dans les deux cas, la variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la même portée que les variables result et stuff.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capturer des valeurs dans des conditions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les expressions d'affectation peuvent être utilisées efficacement dans les conditions d'une instruction if ou while:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En particulier, cette approche peut éliminer la nécessité de créer une boucle infinie, l'affectation et la vérification des conditions. </font><font style="vertical-align: inherit;">Il vous permet également de tracer un parallèle harmonieux entre un cycle qui utilise un appel de fonction comme condition, ainsi qu'un cycle qui vérifie non seulement la condition, mais utilise également la valeur réelle renvoyée par la fonction à l'avenir.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fourchette</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple du monde bas niveau d'UNIX: [env. </font><font style="vertical-align: inherit;">Fork () est un appel système sur les systèmes d'exploitation de type Unix qui crée un nouveau sous-processus par rapport au parent.]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatives rejetées</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, des suggestions similaires sont assez courantes dans la communauté python. </font><font style="vertical-align: inherit;">Vous trouverez ci-dessous un certain nombre de syntaxes alternatives pour les expressions d'affectation qui sont trop spécifiques pour être comprises et ont été rejetées en faveur de ce qui précède.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changer la portée des générateurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une version précédente de ce PEP, des modifications subtiles des règles de portée pour les générateurs ont été proposées pour les rendre plus utilisables dans la portée de classe. </font><font style="vertical-align: inherit;">Cependant, ces propositions entraîneraient une incompatibilité en amont et ont donc été rejetées. </font><font style="vertical-align: inherit;">Par conséquent, ce PEP a pu se concentrer entièrement uniquement sur les expressions d'affectation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orthographes alternatives</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, les expressions d'affectation proposées ont la même sémantique, mais sont écrites différemment.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPR comme NOM:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette syntaxe est moins en conflit avec les autres qu'en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tant que</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sauf si vous comptez l'augmentation des constructions Exc), mais sinon elle est comparable à elles. </font><font style="vertical-align: inherit;">Au lieu d'un parallèle avec avec expr comme cible: (ce qui peut être utile, mais cela peut aussi prêter à confusion), cette option n'a aucun parallèle avec quoi que ce soit, mais elle est étonnamment mieux mémorisée.</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cas particuliers dans les déclarations conditionnelles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un des cas d'utilisation les plus courants pour les expressions d'affectation est les instructions if et while. </font><font style="vertical-align: inherit;">Au lieu d'une solution plus générale, l'utilisation de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> améliore la syntaxe de ces deux instructions en ajoutant un moyen de capturer la valeur à comparer:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne bien, mais </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNIQUEMENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lorsque la condition souhaitée est basée sur la «justesse» de la valeur de retour. </font><font style="vertical-align: inherit;">Ainsi, cette méthode est efficace pour des cas spécifiques (recherche d'expressions régulières, lecture de sockets, retour d'une chaîne vide à la fin de l'exécution), et est complètement inutile dans des cas plus complexes (par exemple, lorsque la condition est f (x) &lt;0, et que vous voulez enregistrer la valeur de f (x)). </font><font style="vertical-align: inherit;">En outre, cela n'a aucun sens dans les générateurs de listes. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avantages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Aucune ambiguïté syntaxique. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inconvénients</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : même si vous ne l'utilisez que dans les instructions if / while, cela ne fonctionne bien que dans certains cas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cas particuliers dans les générateurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre cas d'utilisation courant pour les expressions d'affectation est les générateurs (list / set / dict et genexps). </font><font style="vertical-align: inherit;">Comme ci-dessus, des suggestions ont été faites pour des solutions spécifiques.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">où, loué ou donné:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette méthode entraîne une sous-expression entre la boucle for et l'expression principale. </font><font style="vertical-align: inherit;">Il introduit également un mot-clé de langue supplémentaire, qui peut créer des conflits. </font><font style="vertical-align: inherit;">Des trois options, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">où</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la plus propre et la plus lisible, mais des conflits potentiels existent toujours (par exemple, SQLAlchemy et numpy ont leurs méthodes where, ainsi que tkinter.dnd.Icon dans la bibliothèque standard).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec NAME = EXPR:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle que soit la méthode choisie, une nette différence sémantique sera introduite entre les générateurs et leurs versions déployées via une boucle for. </font><font style="vertical-align: inherit;">Il deviendrait impossible d'envelopper un cycle dans un générateur sans traiter l'étape de création des variables. </font><font style="vertical-align: inherit;">Le seul mot-clé qui pourrait être réorienté pour cette tâche est le mot </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais cela lui donnera une sémantique différente dans différentes parties du code, ce qui signifie que vous devez créer un nouveau mot-clé, mais cela implique beaucoup de coûts.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorité inférieure de l'opérateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'opérateur: = a deux priorités logiques. Ou il doit avoir une priorité aussi faible que possible (au même niveau que l'opérateur d'affectation). Ou il doit avoir une priorité supérieure aux opérateurs de comparaison. Placer sa priorité entre les opérateurs de comparaison et les opérations arithmétiques (pour être précis: légèrement inférieur à OR au niveau du bit) vous permettra de vous passer de crochets dans la plupart des cas quand et si vous l'utilisez, car il est plus probable que vous souhaitiez conserver la valeur de quelque chose avant comment la comparaison sera effectuée dessus:</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dès que find () renvoie -1, la boucle se termine. </font><font style="vertical-align: inherit;">Si: = lie les opérandes aussi librement que =, alors le résultat de find () sera d'abord «capturé» dans l'opérateur de comparaison et retournera généralement True ou False, ce qui est moins utile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que ce comportement soit pratique en pratique dans de nombreuses situations, il serait plus difficile à expliquer. </font><font style="vertical-align: inherit;">Et nous pouvons donc dire que "l'opérateur: = se comporte de la même manière que l'opérateur d'affectation habituel." </font><font style="vertical-align: inherit;">Autrement dit, la priorité pour: = a été sélectionnée le plus près possible de l'opérateur = (sauf que: = a une priorité supérieure à la virgule).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous donnez des virgules à droite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains critiques soutiennent que les expressions d'affectation devraient reconnaître les tuples sans ajouter de crochets afin que les deux entrées soient équivalentes:</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Dans la version actuelle de la norme, le dernier enregistrement sera équivalent à l'expression ((point: = x), y).) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il est logique que dans ce scénario, lors de l'utilisation de l'expression d'affectation dans l'appel de fonction, il aurait également une priorité inférieure à la virgule, nous avons donc obtenu serait l'équivalence déroutante suivante:</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous obtenons la seule issue moins confuse: faire de l'opérateur: = une priorité inférieure à la virgule.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toujours besoin de supports</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il a toujours été proposé de mettre entre crochets les expressions d'affectation. </font><font style="vertical-align: inherit;">Cela nous éviterait bien des ambiguïtés. </font><font style="vertical-align: inherit;">En effet, des parenthèses seront souvent nécessaires pour extraire la valeur souhaitée. </font><font style="vertical-align: inherit;">Mais dans les cas suivants, la présence de parenthèses nous a clairement paru superflue:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objections fréquentes</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas simplement transformer les instructions d'affectation en expressions?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C et les langages similaires définissent l'opérateur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme une expression, et non comme une instruction, comme le fait Python. </font><font style="vertical-align: inherit;">Cela permet une affectation dans de nombreuses situations, y compris aux endroits où les variables sont comparées. </font><font style="vertical-align: inherit;">Les similitudes syntaxiques entre if (x == y) et if (x = y) contredisent leur sémantique très différente. </font><font style="vertical-align: inherit;">Ainsi, ce PEP introduit l'opérateur: = pour clarifier leurs différences.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi s'embêter avec des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressions d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affectation </font><font style="vertical-align: inherit;">s'il existe des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affectation?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux formes ont des flexibilités différentes. </font><font style="vertical-align: inherit;">L'opérateur: = peut être utilisé dans une expression plus grande, et dans l'opérateur = il peut être utilisé par la "famille des mini-opérateurs" de type "+ =". </font><font style="vertical-align: inherit;">Aussi = vous permet d'affecter des valeurs par attributs et index.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas utiliser la portée locale et éviter la pollution de l'espace de noms?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les versions précédentes de cette norme comprenaient une véritable portée locale (limitée à une instruction) pour les expressions d'affectation, empêchant la fuite de nom et la pollution de l'espace de nom. </font><font style="vertical-align: inherit;">Malgré le fait que dans certaines situations cela a donné un certain avantage, dans beaucoup d'autres cela complique la tâche, et les avantages ne sont pas justifiés par les avantages de l'approche existante. </font><font style="vertical-align: inherit;">Cela se fait dans l'intérêt de la simplicité de la langue. </font><font style="vertical-align: inherit;">Vous n'avez plus besoin de cette variable? </font><font style="vertical-align: inherit;">Il existe une solution: supprimez la variable à l'aide du mot clé del ou ajoutez un trait de soulignement inférieur à son nom. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(L'auteur tient à remercier Guido van Rossum et Christophe Groth pour leurs suggestions visant à faire avancer la norme PEP dans cette direction. [2])</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recommandations de style</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que les expressions d'affectation peuvent parfois être utilisées sur un pied d'égalité avec un opérateur d'affectation, la question se pose, qu'est-ce qui est toujours préféré? .. Conformément à d'autres conventions de style (comme PEP 8), il y a deux recommandations:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous pouvez utiliser les deux options d'affectation, privilégiez les opérateurs. </font><font style="vertical-align: inherit;">Ils expriment le plus clairement vos intentions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'utilisation d'expressions d'affectation entraîne une ambiguïté dans l'ordre d'exécution, réécrivez le code à l'aide de l'opérateur classique.</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les auteurs de cette norme tiennent à remercier Nick Coghlan et Steven D'Aprano pour leurs contributions significatives à ce PEP, ainsi que les membres du Python Core Mentorship pour leur aide dans la mise en œuvre de celui-ci.</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe A: Conclusions de Tim Peters</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un court essai que Tim Peters a écrit sur ce sujet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'aime pas le code "confus", et je n'aime pas non plus mettre la logique sans rapport conceptuel sur une seule ligne. </font><font style="vertical-align: inherit;">Ainsi, par exemple, au lieu de:</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je préfère écrire:</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, je pense que je vais trouver plusieurs endroits où je veux utiliser des expressions d'affectation. </font><font style="vertical-align: inherit;">Je ne veux même pas parler de leur utilisation dans des expressions qui sont déjà étirées sur la moitié de l'écran. </font><font style="vertical-align: inherit;">Dans d'autres cas, des comportements tels que:</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup mieux que cela:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux codes ont des concepts complètement différents et les mélanger serait fou. </font><font style="vertical-align: inherit;">Dans d'autres cas, la combinaison d'expressions logiques rend le code plus difficile à comprendre. </font><font style="vertical-align: inherit;">Par exemple, réécriture:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une forme plus courte, nous avons perdu la «logique». </font><font style="vertical-align: inherit;">Vous devez comprendre comment ce code fonctionne. </font><font style="vertical-align: inherit;">Mon cerveau ne veut pas faire ça:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais de tels cas sont rares. </font><font style="vertical-align: inherit;">La tâche de préserver le résultat est très courante et «clairsemé vaut mieux que dense» ne signifie pas que «presque vide vaut mieux que clairsemé» [env. </font><font style="vertical-align: inherit;">une référence à Zen Python]. </font><font style="vertical-align: inherit;">Par exemple, j'ai de nombreuses fonctions qui renvoient None ou 0 pour dire "Je n'ai rien d'utile, mais comme cela se produit souvent, je ne veux pas vous déranger avec des exceptions." </font><font style="vertical-align: inherit;">En fait, ce mécanisme est également utilisé dans les expressions régulières qui renvoient None lorsqu'il n'y a pas de correspondance. </font><font style="vertical-align: inherit;">Par conséquent, dans cet exemple, beaucoup de code:</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je trouve l'option suivante plus compréhensible et bien sûr plus lisible:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début, je n'y attachais pas beaucoup d'importance, mais une construction si courte est apparue si souvent qu'elle a rapidement commencé à m'ennuyer que je ne pouvais pas l'utiliser. </font><font style="vertical-align: inherit;">Ça m'a étonné! </font><font style="vertical-align: inherit;">[environ. </font><font style="vertical-align: inherit;">apparemment, cela a été écrit avant la sortie officielle de Python 3.8.] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a d'autres cas où les expressions d'affectation "tirent" vraiment. </font><font style="vertical-align: inherit;">Au lieu de fouiller à nouveau dans mon code, Kirill Balunov a donné un bel exemple de la fonction copy () de la bibliothèque copy.py standard:</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'indentation toujours croissante est trompeuse: après tout, la logique est plate: le premier test réussi «gagne»:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La simple utilisation des expressions d'affectation permet à la structure visuelle du code de mettre en valeur le «plan» de la logique. </font><font style="vertical-align: inherit;">Mais l'indentation toujours croissante la rend implicite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un autre petit exemple de mon code, qui m'a fait très plaisir car il m'a permis de mettre une logique liée en interne sur une seule ligne et de supprimer le niveau d'indentation "artificiel" ennuyeux. </font><font style="vertical-align: inherit;">C'est exactement ce que je veux de l'instruction if et cela facilite la lecture. </font><font style="vertical-align: inherit;">Le code suivant:</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transformé en:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, dans la plupart des lignes où l'affectation de variable se produit, je n'utiliserais pas d'expressions d'affectation. </font><font style="vertical-align: inherit;">Mais cette conception est si fréquente qu'il y a encore de nombreux endroits où je saisirais cette opportunité. </font><font style="vertical-align: inherit;">Dans les cas les plus récents, j'ai gagné un peu, comme ils apparaissaient souvent. </font><font style="vertical-align: inherit;">Dans la sous-partie restante, cela a conduit à des améliorations moyennes ou importantes. </font><font style="vertical-align: inherit;">Ainsi, j'utiliserais des expressions d'affectation beaucoup plus souvent qu'un triple si, mais beaucoup moins souvent qu'une affectation augmentée [env. </font><font style="vertical-align: inherit;">options courtes: * =, / =, + =, etc.].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple numérique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai un autre exemple qui m'a frappé plus tôt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si toutes les variables sont des entiers positifs et que la variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> supérieure à la nième racine de x, alors cet algorithme renvoie l'arrondi «inférieur» de la nième racine de x (et double approximativement le nombre de bits exacts par itération):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On ne sait pas pourquoi, mais une telle variante de l'algorithme est moins évidente qu'une boucle infinie avec une rupture de branche conditionnelle (boucle et demie). Il est également difficile de prouver l'exactitude de cette implémentation sans s'appuyer sur un énoncé mathématique («moyenne arithmétique - inégalité moyenne géométrique») et ne pas savoir certaines choses non triviales sur la façon dont les fonctions d'arrondi imbriquées se comportent vers le bas. Mais ici, le problème est déjà en mathématiques et non en programmation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et si vous savez tout cela, alors l'option utilisant des expressions d'affectation est lue très facilement, comme une simple phrase: "Vérifiez la" supposition "actuelle et si elle est trop grande, réduisez-la" et la condition vous permet d'enregistrer immédiatement la valeur intermédiaire de la condition de boucle. À mon avis, la forme classique est plus difficile à comprendre:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe B: Un interpréteur de code approximatif pour les générateurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette annexe tente de clarifier (sans préciser) les règles selon lesquelles une variable doit être créée dans les expressions de générateur. </font><font style="vertical-align: inherit;">Pour un certain nombre d'exemples illustratifs, nous montrons le code source où le générateur est remplacé par une fonction équivalente en combinaison avec certains «échafaudages». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque [x pour ...] est équivalent à list (x pour ...), les exemples ne perdent pas leur généralité. </font><font style="vertical-align: inherit;">Et comme ces exemples ne visent qu'à clarifier les règles générales, ils ne prétendent pas être réalistes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: les générateurs sont désormais implémentés par la création de fonctions génératrices imbriquées (similaires à celles données dans cette annexe). </font><font style="vertical-align: inherit;">Les exemples montrent la nouvelle partie, qui ajoute la fonctionnalité appropriée pour travailler avec la portée des expressions d'affectation (telle que la portée comme si l'affectation était effectuée dans un bloc contenant le générateur le plus externe). </font><font style="vertical-align: inherit;">Pour simplifier l '«inférence de type», ces exemples illustratifs ne prennent pas en compte le fait que les expressions d'affectation sont facultatives (mais elles prennent en compte la portée de la variable créée à l'intérieur du générateur). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelons d'abord quel code est généré «sous le capot» pour les générateurs sans expressions d'affectation:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code source (EXPR utilise le plus souvent la variable VAR):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code converti (ne nous inquiétons pas des conflits de noms):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutons une expression d'affectation simple.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code converti:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutons maintenant l'instruction TARGET globale à la déclaration de la fonction f ().</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code converti:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou vice versa, ajoutons TARGET non local à la déclaration de la fonction f ().</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code converti:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, mettons deux générateurs.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code converti:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annexe C: Aucun changement dans la sémantique de la portée</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez qu'en Python, la sémantique des portées n'a pas changé. </font><font style="vertical-align: inherit;">L'étendue des fonctions locales est toujours déterminée au moment de la compilation et a une durée indéfinie au moment de l'exécution (fermeture). </font><font style="vertical-align: inherit;">Exemple:</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en œuvre de la preuve de concept</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussion de la sémantique des expressions d'affectation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VPN est serré mais chargé)</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussion de TargetScopeError dans PEP 572</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (chargé de manière similaire à la précédente)</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">droits d'auteur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce document a été rendu public. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ma partie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, résumons:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que les </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gens n'essaient pas</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de supprimer la dualité sémantique, dans de nombreux endroits «classiques» où vous pouvez utiliser à la fois «=» et «: =», il y a des restrictions, donc l'opérateur :: = doit souvent être placé entre crochets. </font><font style="vertical-align: inherit;">Ces cas devront être examinés dans la section </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décrivant l'utilisation de base.</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La priorité des expressions d'affectation est légèrement supérieure à celle d'une virgule. </font><font style="vertical-align: inherit;">Pour cette raison, les tuples ne sont pas formés pendant l'affectation. </font><font style="vertical-align: inherit;">Il permet également d'utiliser l'opérateur: = lors du passage d'arguments à une fonction.</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au final, je tiens à dire que j'ai aimé le nouvel opérateur. </font><font style="vertical-align: inherit;">Il vous permet d'écrire du code plus plat dans des conditions, de «filtrer» les listes, et aussi (enfin) de supprimer la «même» ligne solitaire avant if. </font><font style="vertical-align: inherit;">Si les gens utilisent des expressions d'affectation pour leur objectif, ce sera un outil très pratique qui augmentera la lisibilité et la beauté du code (bien que cela puisse être dit à propos de n'importe quel langage fonctionnel ...)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499654/index.html">Comment implémenter CRM sur un site distant et gagner?</a></li>
<li><a href="../fr499656/index.html">Simulation de régulateur de température PID</a></li>
<li><a href="../fr499658/index.html">Un ouvrier au lieu d'un testeur? Vaut-il la peine d'étudier le sélénium en 2020?</a></li>
<li><a href="../fr499662/index.html">Racine de confiance pour l'IoT et les autres tendances de sécurité IoT</a></li>
<li><a href="../fr499664/index.html">Portage d'API vers TypeScript comme solutionneur de problèmes</a></li>
<li><a href="../fr499668/index.html">Dépendances JavaScript de Road to Hell</a></li>
<li><a href="../fr499670/index.html">Я перехожу на JavaScript</a></li>
<li><a href="../fr499674/index.html">Une autre étape vers les ordinateurs optiques</a></li>
<li><a href="../fr499676/index.html">Plus de 90 outils utiles pour Kubernetes: déploiement, gestion, surveillance, sécurité et plus</a></li>
<li><a href="../fr499680/index.html">Learning Kubernetes: Basic 14-16 May, Advanced 18-20 May</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>