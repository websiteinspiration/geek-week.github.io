<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💭 👩🏽‍🚀 👨🏿‍🤝‍👨🏽 Web套接字和Socket.IO之间的区别 🈲 🐷 👩🏼‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="朋友们，美好的一天！
 
 Web套接字和Socket.IO可能是两种最常见的实时通信方式（以下称为实时通信）。但是它们有何不同？
 
 在构建用于实时通信的应用程序时，有时需要选择一种用于在客户端和服务器之间交换数据的工具。Web套接字和Socket.IO是现代Web上最流行的实时通信方式。选择哪...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Web套接字和Socket.IO之间的区别</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498996/"><img src="https://habrastorage.org/webt/zk/qg/qc/zkqgqcvkytdtggi3q1nujijam_8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
朋友们，美好的一天！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web套接字和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socket.IO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能是两种最常见的实时通信方式（以下称为实时通信）。</font><font style="vertical-align: inherit;">但是它们有何不同？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在构建用于实时通信的应用程序时，有时需要选择一种用于在客户端和服务器之间交换数据的工具。</font><font style="vertical-align: inherit;">Web套接字和Socket.IO是现代Web上最流行的实时通信方式。</font><font style="vertical-align: inherit;">选择哪一个？</font><font style="vertical-align: inherit;">这些技术之间有什么区别？</font><font style="vertical-align: inherit;">让我们找出答案。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络插座</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
说到网络套接字，我们指的是网络通信协议，它表示通过简单TCP连接的全双工通信通道。</font><font style="vertical-align: inherit;">简而言之，这项技术使您能够以最小的成本在客户端和服务器之间建立通信，从而使您能够创建利用实时通信所有优点的应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，假设您正在创建聊天：您需要尽快接收和发送数据，对吗？</font><font style="vertical-align: inherit;">Web套接字就可以了！</font><font style="vertical-align: inherit;">您可以打开一个TCP连接，并在需要时保持打开状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web套接字于2010年出现在Google Chrome 4中，第一个RFC（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6455</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）于2011年发布。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在以下情况下使用Web套接字：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聊天室</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多人游戏</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协同编辑</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">社会（新闻）提要</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于位置的应用</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等等</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">套接字</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Socket.IO是一个基于Web套接字...和其他技术的JavaScript库（写在顶部）。</font><font style="vertical-align: inherit;">如果可用，则使用Web套接字；如果不可用，则使用Flash Socket，AJAX Long Polling，AJAX Multipart Stream等技术。</font><font style="vertical-align: inherit;">一个简单的类比是Fetch API和Axios的比较。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web套接字和Socket.IO之间的区别</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Socket.IO的主要优点如下：</font></font><br>
<br>
<ul>
<li>   -, Socket.IO      . ,            .         .   -,              .</li>
<li> -      . Socket.IO     .</li>
<li>  , Socket.IO   () .</li>
<li>Socket.IO      .</li>
<li> Socket.IO  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎Socket.IO是实时通信的最佳工具。</font><font style="vertical-align: inherit;">但是，在某些情况下，最好使用Web套接字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，所有现代浏览器都支持Web套接字。</font><font style="vertical-align: inherit;">因此，您很少需要Socket.IO提供的其他技术的支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们谈论网络流量，则Web套接字仅发送两个请求：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取以获取HTML页面</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">升级用于连接Web套接字</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这使您可以连接到服务器。</font><font style="vertical-align: inherit;">Socket.IO呢？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取以获取HTML页面</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socket.IO客户端库（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">207kb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三个长轮询Ajax请求</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">升级用于连接Web套接字</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在JS的世界中，207kb非常多。</font><font style="vertical-align: inherit;">多么不合理地使用网络流量！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在npm中，有一个软件包</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ websocket-vs-socket.io”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可让您比较以下技术的网络流量：</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web套接字网络流量：</font></font></h4><br>
<img src="https://habrastorage.org/webt/sp/fy/hq/spfyhql2fnceonu6316fktpamaq.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socket.IO网络流量：</font></font></h4><br>
<img src="https://habrastorage.org/webt/lx/0v/3d/lx0v3dq1tdafi1wxhsef5lh56d4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区别很明显！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写代码</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单的Web套接字服务器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Node.js上的程序中，我们将创建一个在端口3001上运行的服务器。每次客户端连接时，我们都会为其分配一个唯一的ID。</font><font style="vertical-align: inherit;">向客户发送消息时，我们将通知他成功：[&lt;client-id&gt;]：&lt;message&gt;</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ws'</span>)
<span class="hljs-keyword">const</span> UUID = <span class="hljs-built_in">require</span>(<span class="hljs-string">'uuid'</span>)
<span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> WebSocket.Server({ <span class="hljs-attr">port</span>: <span class="hljs-number">3001</span> })<font></font>
<font></font>
wss.on(<span class="hljs-string">'connection'</span>, ws =&gt; {<font></font>
  ws.id = UUID()<font></font>
<font></font>
  ws.on(<span class="hljs-string">'message'</span>, message =&gt; {<font></font>
    ws.send(<span class="hljs-string">`[<span class="hljs-subst">${ws.id}</span>]: <span class="hljs-subst">${message}</span>`</span>)<font></font>
  })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细！</font><font style="vertical-align: inherit;">但是，如果我们想向每个连接的客户端发送消息怎么办？</font><font style="vertical-align: inherit;">Web套接字默认情况下不支持邮件。</font><font style="vertical-align: inherit;">可以如下实现：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ws"</span>)
<span class="hljs-keyword">const</span> UUID      = <span class="hljs-built_in">require</span>(<span class="hljs-string">"uuid"</span>)
<span class="hljs-keyword">const</span> wss       = <span class="hljs-keyword">new</span> WebSocket.Server({ <span class="hljs-attr">port</span>: <span class="hljs-number">3001</span> })<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">clientId, message</span>) </span>{<font></font>
  wss.clients.forEach(<span class="hljs-function"><span class="hljs-params">client</span> =&gt;</span> {
    <span class="hljs-keyword">if</span>(client.readyState === WebSocket.OPEN) {<font></font>
      client.send(<span class="hljs-string">`[<span class="hljs-subst">${clientId}</span>]: <span class="hljs-subst">${message}</span>`</span>)<font></font>
    }<font></font>
  })<font></font>
}<font></font>
<font></font>
wss.on(<span class="hljs-string">'conection'</span>, ws =&gt; {<font></font>
  ws.id = UUID()<font></font>
  ws.on(<span class="hljs-string">'message'</span>, message =&gt; broadcast(ws.id, message))<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简单轻松！</font><font style="vertical-align: inherit;">如您所见，WebSocket.Server会保留每个连接的客户端的记录，因此我们可以迭代并向每个人发送消息。</font><font style="vertical-align: inherit;">您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算机（MacOS）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器（Chrome）中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试代码</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socket.IO上的简单服务器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这并不困难。</font><font style="vertical-align: inherit;">Socket.IO可以使它更容易吗？</font><font style="vertical-align: inherit;">我们如何在Socket.IO上写入同一服务器？</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">'socket.io'</span>)
<span class="hljs-keyword">const</span> server = io.listen(<span class="hljs-number">3002</span>)<font></font>
<font></font>
server.on(<span class="hljs-string">'connection'</span>, socket =&gt; {<font></font>
  socket.on(<span class="hljs-string">'message'</span>, message =&gt; {<font></font>
    socket.emit(<span class="hljs-string">`[<span class="hljs-subst">${socket.id}</span>]: <span class="hljs-subst">${message}</span>`</span>)<font></font>
    socket.broadcast.emit(<span class="hljs-string">`[<span class="hljs-subst">${socket.id}</span>]: <span class="hljs-subst">${message}</span>`</span>)<font></font>
  })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代码几乎短了一半！如您所见，广播方法不会将通知发送给发件人，因此我们被迫手动执行此操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个问题：无法在常规的Web套接字客户端上测试代码。如前所述，这是由于Socket.IO不使用纯Web套接字，而是使用许多技术来支持所有可能的客户端的事实。那么我们如何测试其性能呢？</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// head</span>
&lt;script src=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/socket.io-client@2.3.0/dist/socket.io.slim.js"</span>&gt;&lt;/script&gt;<font></font>
<font></font>
<span class="hljs-comment">// body</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  ioClient = io.connect(<span class="hljs-string">'http://localhost:3002'</span>)
  ioClient.on(<span class="hljs-string">'connect'</span>, socket =&gt; {
    ioClient.send(<span class="hljs-string">'hello world'</span>)
    ioClient.on(<span class="hljs-string">'message'</span>, msg =&gt; <span class="hljs-built_in">console</span>.log(msg))
  })
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您必须使用特殊的客户端。</font><font style="vertical-align: inherit;">在上面的示例中，我们从CDN加载它。</font><font style="vertical-align: inherit;">该客户端允许我们在浏览器中进行快速（脏）测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们的示例并没有太大不同。</font><font style="vertical-align: inherit;">但是，如果我们谈论兼容性，则应记住Socket.IO使用其自己的库，不能将其用于与Web开发无关的目的。</font><font style="vertical-align: inherit;">同时，Web套接字可用于解决各种任务，例如P2P通信，服务器之间的实时数据交换等。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在笔记上</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
水平缩放。假设您的聊天越来越流行，您需要添加其他服务器和负载平衡器来处理请求。好吧，如果您打开到“服务器1”的连接，那么平衡器会将您切换到“服务器2”，您将收到错误：“ WebSocket握手期间错误：意外的响应代码：400”。 Socket.IO通过使用cookie（或通过基于源地址的路由连接）解决了此问题，并且Web套接字没有这种机制。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
性能。</font><font style="vertical-align: inherit;">如前所述，Socket.IO在Web套接字的传输层之上提供了几个抽象层。</font><font style="vertical-align: inherit;">另外，此处使用将数据打包为JSON格式，因此不可能将二进制数据发送到服务器（反之亦然）。</font><font style="vertical-align: inherit;">如果需要这种功能，则必须“构想”库代码以确保所需的行为。</font><font style="vertical-align: inherit;">使用Web套接字不会出现此类问题。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么该选择什么呢？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你决定。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Socket.IO使生活更轻松，您无需担心与负载平衡，断开连接或发送消息有关的问题……但是您是否需要这种功能？</font><font style="vertical-align: inherit;">Socket.IO客户端库的重量超过React，Redux和React-Redux软件包的总和。</font><font style="vertical-align: inherit;">确定要限制自己使用网络套接字吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要记住的另一件事是，在服务器端使用Socket.IO时，大多数代码将以该库提供的抽象形式编写。</font><font style="vertical-align: inherit;">如果您需要用Go，Elixir，Java或其他编程语言重写Node.js微服务，则必须重写几乎所有逻辑。</font><font style="vertical-align: inherit;">例如，要将消息发送到Socket.IO，则使用“广播”方法（在Web套接字上手动实现），因此在重构时，您将必须了解该方法的工作方式。</font><font style="vertical-align: inherit;">在这种情况下，应该首选Web套接字，因为它们更容易适应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感谢您的关注。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498978/index.html">使用Graylog和NLog从C＃应用程序收集日志。个人经验</a></li>
<li><a href="../zh-CN498982/index.html">Dreamcast的软盘</a></li>
<li><a href="../zh-CN498984/index.html">隐形学校：隐形游戏中的5种小工具</a></li>
<li><a href="../zh-CN498988/index.html">海外求职和移民加拿大</a></li>
<li><a href="../zh-CN498990/index.html">手柄支持Omega Red模拟器</a></li>
<li><a href="../zh-CN498998/index.html">Rust 1.43.0发行版：改进了编译器和基元，宏项中的类型推断</a></li>
<li><a href="../zh-CN499004/index.html">如何在孤立的环境中玩耍或使用声卡传输数据</a></li>
<li><a href="../zh-CN499008/index.html">为什么开发人员这么慢：常见问题及其解决方案</a></li>
<li><a href="../zh-CN499010/index.html">我们研究了Mediastreamer2 VoIP引擎。第11部分</a></li>
<li><a href="../zh-CN499014/index.html">JavaScript面试的23个难题</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>