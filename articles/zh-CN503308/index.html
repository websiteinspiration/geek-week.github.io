<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😜 🧗🏼 🤞🏾 Angular应用程序架构师需要掌握的6个概念 🖼️ 🏇🏾 👏🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular是现有的最大的Web框架之一。它包括许多内置功能。这意味着，为了全面开发Angular，您需要处理大量概念。 该材料的作者（我们今天将其翻译发表）认为Angular开发人员需要六个知识，才能创建精心设计的应用程序。但是，尽管他本人有时不得不研究代码，但他并不是在研究用于实现这些概念的源...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Angular应用程序架构师需要掌握的6个概念</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503308/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular是现有的最大的Web框架之一。</font><font style="vertical-align: inherit;">它包括许多内置功能。</font><font style="vertical-align: inherit;">这意味着，为了全面开发Angular，您需要处理大量概念。</font><font style="vertical-align: inherit;">
该材料的作者（我们今天将其翻译发表）认为Angular开发人员需要六个知识，才能创建精心设计的应用程序。</font><font style="vertical-align: inherit;">但是，尽管他本人有时不得不研究代码，但他并不是在研究用于实现这些概念的源代码。</font><font style="vertical-align: inherit;">这是关于了解相关机制以及将其付诸实践的能力。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/-u/uw/os/-uuwosp185not6lscdhhwrucgyk.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.体系结构，模块和库</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Web开发世界中，Angular的模块化体系结构很特别。</font><font style="vertical-align: inherit;">可能这是比初学者采用的想法差的想法之一。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里最难的部分是Web开发已经使用了模块化体系结构。</font><font style="vertical-align: inherit;">当然，我说的是ES6导入。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于Angular模块向系统添加了附加级别的逻辑分组，因此重要的是，它们的结构应尽可能与它们的帮助下解决的任务相对应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道如何使用设计良好的模块分离和组合应用程序功能是创建Angular应用程序体系结构的基本部分。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各种类型的Angular模块</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有多种类型的Angular模块需要注意：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声明/小部件模块。</font><font style="vertical-align: inherit;">具有各种实体声明的模块。</font><font style="vertical-align: inherit;">此类模块的一个示例是一组用户界面组件，指令，管道。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务模块。</font><font style="vertical-align: inherit;">服务模块 </font><font style="vertical-align: inherit;">例如- </font></font><code>HttpClientModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路由模块。</font><font style="vertical-align: inherit;">路由模块</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域功能模块。</font><font style="vertical-align: inherit;">实现应用程序关键任务的模块。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">核心/共享模块。</font><font style="vertical-align: inherit;">核心模块是用于声明全局服务的模块。</font><font style="vertical-align: inherit;">共享模块是其中声明要共享的组件的模块。</font></font></li>
</ul><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可以找到有关Angular模块的详细信息。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍库或模块？</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想说模块之间的上述区别可以扩展到库。</font><font style="vertical-align: inherit;">通过这种方法，事实证明可能存在一个仅包含服务的库，一个代表路线的库等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，是否创建模块或库取决于项目的类型，以及项目是由单一存储库还是由多个存储库表示。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creating在创建模块之前要问自己的问题</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是编写模块之前要问的一些问题：</font></font><br>
<br>
<ul>
<li>       ?         —  ,         .   ,             .  ,        .</li>
<li>       ,      ?       .  ,    ,       . ,   ,  .</li>
</ul><br>
<h2><font color="#3AC1EF">2.    ,   </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从理论上讲，分担责任很简单。</font><font style="vertical-align: inherit;">但是实际上，这已经更加困难。</font><font style="vertical-align: inherit;">自Angular.js诞生以来，开发人员就知道组件应尽可能紧凑，并且服务应更大。</font><font style="vertical-align: inherit;">在新版本的Angular中，这些想法没有太大变化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如今，重要的是要有一个概念，到底什么应该是组件的一部分，什么是服务的一部分，并且还要考虑到指令可能是Angular的一个非常被低估的功能这一事实。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍条件</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于组件状态确切存储在哪里的问题的答案取决于需要相应数据的位置。</font><font style="vertical-align: inherit;">即，它们可能仅在组件中是必需的，是局部的和封装的，或者可能在组件外部是必需的。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果组件共享状态，或者需要从服务访问状态，则应将状态存储在服务中。</font><font style="vertical-align: inherit;">此外，如果状态存储在服务中，则使用哪些特定状态管理工具不会发挥特殊作用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果状态是局部的（例如，我们正在谈论表单）并且仅在组件内部使用，则状态应仅保存在组件中。</font></font></li>
</ul><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with使用DOM</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能大多数DOM操作都应在指令中完成。</font><font style="vertical-align: inherit;">想象一下，其中一个组件具有拖放功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我敢肯定，在这种情况下，您可以创建一个组件并从中绑定相应的事件，但是如果这样做，则会混合两种现象：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件外观的描述。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定组件行为。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指令是Angular功能，可让您描述可重用的机制。</font><font style="vertical-align: inherit;">在我从事的几乎每个项目中，我都注意到没有充分使用指令。</font><font style="vertical-align: inherit;">指令可以承担相当大的部分责任。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个练习：通过代码行数查找当前项目中最大的组件。</font><font style="vertical-align: inherit;">是用它</font></font><code>Renderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还是</font></font><code>ElementRef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">相应的逻辑很可能可以转移到指令中。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.变更检测和渲染</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当涉及到重新渲染用户界面时，在Angular中，一切都使用框架的内部机制通过魔术来完成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果您需要优化应用程序，以便仅在必要时才重新渲染接口，则必须处理这种“魔术”。</font><font style="vertical-align: inherit;">而且，要改善渲染效果，您不仅必须依赖知识，还必须依赖直觉。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angular应用程序架构师可能应该意识到，使用更改检测策略来优化渲染性能</font></font><code>onPush</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是在工作过程中，一切并不一定总是按预期进行。</font><font style="vertical-align: inherit;">尤其是当模板不使用可观察对象和异步管道时。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change改进变更检测</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了改进项目中使用的变更检测过程，从以下想法开始是有意义的：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有必要将所有数据视为不可变的。</font><font style="vertical-align: inherit;">基于Rx的状态管理库在这里可能非常有用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要在模板中输出数据，仅（或主要）使用可观察对象是值得的。</font><font style="vertical-align: inherit;">使用本地状态时，值得应用</font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您要开发高性能Angular应用程序，则只需要很好地处理变更检测问题即可。</font><font style="vertical-align: inherit;">事实是，高性能甚至没有“在需要时更新接口”。</font><font style="vertical-align: inherit;">这是“仅在需要时更新接口”。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍克服角度性能限制</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
减少应用程序界面的重新渲染次数是使您能够创建快速有效的应用程序的秘密之一。</font><font style="vertical-align: inherit;">但是有时应用程序性能必须超出Angular设备本身定义的范围。</font><font style="vertical-align: inherit;">在此类应用程序中，可以注意到游戏，经常更新其数据的项目，显示大型和复杂列表的页面等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您确实需要从Angular性能中挤出绝对最大值，则意味着您应该诉诸一种技术，该技术涉及摆脱Zone.js并使用最新的Ivy功能准确地更新接口。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关它</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">材料。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.路由</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
路由不仅以多种虚拟页面的形式表示SPA。它还使用Angular路由子系统材料的延迟加载功能按需加载应用程序包。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您在大型应用程序上工作，并且此应用程序的捆绑包大小超过1 MB，那么您可能已经知道为什么这很重要。确实，没有人会发现下载大量数据以与某个应用程序一起使用的前景。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
路由不仅应用于分隔顶层路由，还应用于对接口的较浅和较深部分进行组织。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这使您可以按主要路线拆分分发包的内容，并有助于将应用程序划分为小部分，直到明确要求下载它们之后才将其转移给用户。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍示例：选项卡式组件</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们正在开发使用选项卡的用户界面。</font><font style="vertical-align: inherit;">此外，每个选项卡都彼此独立。</font><font style="vertical-align: inherit;">这是一种理想情况，其中可以为每个选项卡分配自己的路由并组织延迟数据加载，在此期间，仅将所选选项卡的数据传输到客户端。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想要另一个例子吗？</font><font style="vertical-align: inherit;">弹出式窗口和模式窗口如何？</font><font style="vertical-align: inherit;">他们的代码绝对不需要包含在项目原始包装中的材料中。</font><font style="vertical-align: inherit;">此类窗口的代码仅在需要时才加载，而不是更早加载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您想在应用此类想法之前获得启发，建议您看一下</font><font style="vertical-align: inherit;">实现上述模式</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ angular / material / tabs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件的文档</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.表格</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大多数CRUD应用程序基本上由许多形式组成。您很可能会花费大量时间创建表单。因此，对于想要成为Angular架构师的人来说，正确掌握表单的使用非常重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您的大多数表单都可能使用模块</font></font><code>ReactiveFormsModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果它们不由单个控件组成，则使用它们，</font></font><code>ngModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将实现双向数据绑定。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用表单的Angular API非常容易学习。通常，为了在使用此API方面获得卓越的表现，适当地研究文档并知道使用表单时可能会出现什么问题就足够了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得知道的主要问题是Angular中的表单未绑定到构成其基础的数据类型。</font><font style="vertical-align: inherit;">对于使用本来就很好制作的机制来说，这可能是最不愉快的事情。</font><font style="vertical-align: inherit;">结果，结果表明开发人员需要仔细监视表单是否与使用它们时使用的数据结构相对应。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. RxJS</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而我们名单上的最后一个（尽管并非最不重要）是RxJS技术。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我坚信Angular最强大的功能之一就是将该框架与Rx和功能性反应式编程进行了深度集成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了真正掌握Angular，为设计高质量的应用程序铺平道路，您首先需要研究Rx，或者至少是最重要的运算符。如果不花大量时间了解Rx，很难成为真正的高级Angular开发人员。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学习Rx可以帮助您开发Angular应用程序的原因有两个：性能和异步数据处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在现代，高度交互的应用程序中，异步数据处理是一项特别困难的任务。</font><font style="vertical-align: inherit;">因此，您应该忘记oh </font></font><code>setTimeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和oh的</font><font style="vertical-align: inherit;">诺言，</font><font style="vertical-align: inherit;">并</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以Rx样式开始工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学习Rx的另一个重要原因是优化应用程序性能。</font><font style="vertical-align: inherit;">当然，首先使用异步管道就足够了，但是有时这还不够。</font><font style="vertical-align: inherit;">例如，您可以通过仅将那些事件传递通过管道来控制组件的重新渲染，发生这些事件意味着需要重新渲染。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rx为开发人员提供了许多运算符，可以帮助他缓存某些内容或将某些内容构建到包中。</font><font style="vertical-align: inherit;">结果，这导致了优化的应用程序性能。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有关RxJS模式的材料。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在这里给出了一些简短的主题，对于想要成为高性能Angular开发人员或想要成为Angular应用程序架构师的人来说，值得探讨。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在此列表中添加更多内容。</font><font style="vertical-align: inherit;">但是，除其他外，我建议不要忘记，为了真正了解Web开发领域，您需要从基础开始。</font><font style="vertical-align: inherit;">这些是JavaScript，CSS，设计模式，简洁的代码编写技术，工具等等。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于那些想学习如何设计高质量Angular应用程序的人，您有什么建议学习呢？</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN503282/index.html">在车辆监控设备上使用Modbus协议</a></li>
<li><a href="../zh-CN503288/index.html">我们如何使用机器学习搜索候选人</a></li>
<li><a href="../zh-CN503290/index.html">DJI Matrice 300 RTK工业直升机评测</a></li>
<li><a href="../zh-CN503300/index.html">《瑞克与莫蒂》一书。所有星系中最杰出的卡通指南»</a></li>
<li><a href="../zh-CN503302/index.html">加快基于CMake + GCC的项目构建：头文件的预编译</a></li>
<li><a href="../zh-CN503310/index.html">高级程序员怎么看？</a></li>
<li><a href="../zh-CN503312/index.html">如何在Angular应用程序中导致内存泄漏？</a></li>
<li><a href="../zh-CN503318/index.html">职业：程序员。并非一切都清楚</a></li>
<li><a href="../zh-CN503322/index.html">固件开发：简介</a></li>
<li><a href="../zh-CN503324/index.html">Brad Stalberg和Steve Magness的“巅峰时期”：防止自燃（第一部分）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>