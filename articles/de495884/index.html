<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 👨🏾‍🌾 🤸🏼 Zeitreihenvorhersage mit wiederkehrenden neuronalen Netzen 🤙🏽 ❌ 👱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Fernbedienung vor dem Hintergrund der universellen Selbstisolation kann zu sehr schlimmen Folgen führen. Und emotionales Burnout - es ist immer no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zeitreihenvorhersage mit wiederkehrenden neuronalen Netzen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Fernbedienung vor dem Hintergrund der universellen Selbstisolation kann zu sehr schlimmen Folgen führen. Und emotionales Burnout - es ist immer noch da, wo es hingeht: Immerhin ist es nicht weit vom Dach entfernt. In dieser Hinsicht versuchte er, wie viele andere auch, sich zu "beruhigen", indem er Zeit für andere Klassen zur Verfügung stellte - und begann, die interessantesten Artikel aus dem Englischen ins Russische zu übersetzen: "Sie geben </font><font style="vertical-align: inherit;">den Massen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maschinelles Lernen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !".) Wir müssen Tribut zollen: Es ist sehr ablenkend. Wenn Sie Vorschläge für den semantischen Inhalt und die Übersetzung dieses Textes für einen russischsprachigen Leser haben, nehmen Sie an der Diskussion teil.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="Bild"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine Übersetzung der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreihen-Prognoseseite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Abschnitt zum Tensorflow-Handbuch: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Meine Ergänzungen zusammen mit Abbildungen für die Übersetzung sollen helfen, die Grundideen in einem der interessantesten Bereiche der ML und der Ökonometrie im Allgemeinen zu verstehen - der Vorhersage von Zeitreihen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine kleine Einführung vor der Übersetzung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Handbuch beschreibt die Lufttemperaturvorhersage anhand eindimensionaler Zeitreihen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(univariate Zeitreihen)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und multivariater Zeitreihen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(multivariate Zeitreihen)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Geben Sie für jedes Teil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte entsprechend vorbereitet sein. Unter Berücksichtigung des in diesem Handbuch berücksichtigten meteorologischen Datensatzes lautet die Trennung wie folgt: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Fragen, was für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und was für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu beachten </font><font style="vertical-align: inherit;">ist, dh wie Daten für die Klasse des überwachten Trainings vorzubereiten sind, wird dies aus den folgenden Abbildungen deutlich. Ich stelle nur fest, dass die Bildung des Zielvektors (Y) für die Arbeit mit eindimensionalen und mehrdimensionalen Zeitreihen gleich ist: Der </font><i><font style="vertical-align: inherit;">Zielvektor</font></i><font style="vertical-align: inherit;"> wird auf der Basis des Vorzeichens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T (degC) zusammengestellt.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Lufttemperatur). Der Unterschied zwischen ihnen liegt in der Bildung einer Reihe von Merkmalen, die der Modelleingabe zugeführt werden: Bei einer eindimensionalen Zeitreihe zur Vorhersage der Temperatur in der Zukunft besteht der Eingabevektor (X) aus einem Merkmal: Lufttemperatur; und für mehrdimensionale - mehr als eine: Zusätzlich zur Lufttemperatur werden im Beispiel dieses Handbuchs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p (mbar)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atmosphärischer Druck) und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho (g / m ** 3)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Luftfeuchtigkeit) </font><font style="vertical-align: inherit;">verwendet </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst sieht ein weit flaches Aussehen, ein Beispiel mit Temperaturvorhersage, unter dem Gesichtspunkt der Verwendung einer mehrdimensionalen Eingabe nicht überzeugend aus: Für die Temperaturvorhersage ist die Temperatur das relevanteste Zeichen. Dies ist jedoch absolut nicht der Fall: Um eine qualitative Vorhersage der Lufttemperatur zu erstellen, müssen viele Faktoren bis zur Luftreibung auf der Erdoberfläche usw. berücksichtigt werden. Darüber hinaus sind in der Praxis einige Dinge alles andere als offensichtlich, und der Zielvektor kann in Form dieses Durcheinander (oder Borschtsches) vorliegen. In dieser Hinsicht ist eine explorative Datenanalyse mit der Auswahl der relevantesten Merkmale für die nachfolgende Bildung einer mehrdimensionalen Eingabe die einzig richtige Entscheidung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher wird die Übersetzung des Handbuchs unten dargestellt. Zusätzlicher Text wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kursiv dargestellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreihenprognose</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Leitfaden ist eine Einführung in die Vorhersage von Zeitreihen unter Verwendung wiederkehrender neuronaler Netze (RNS, vom English </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recurrent Neural Network, RNN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Es besteht aus zwei Teilen: Der erste beschreibt die Vorhersage der Lufttemperatur anhand einer eindimensionalen Zeitreihe und der zweite Teil basiert auf einer mehrdimensionalen Zeitreihe.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe von meteorologischen Daten</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alle Beispiele für die manuelle Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen von Wetterdaten,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die an einer hydrometeorologischen Station </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des nach ihr benannten Instituts für Biogeochemie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgezeichnet wurden </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Max Planck</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Datensatz enthält Messungen von 14 verschiedenen meteorologischen Indikatoren (wie Lufttemperatur, Luftdruck, Luftfeuchtigkeit), die seit 2003 alle 10 Minuten durchgeführt wurden. </font><font style="vertical-align: inherit;">Um Zeit und Speicherplatz zu sparen, werden im Handbuch Daten für den Zeitraum von 2009 bis 2016 verwendet. </font><font style="vertical-align: inherit;">Dieser Abschnitt des Datensatzes wurde von François Chollet für sein Buch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep Learning with Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorbereitet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was wir haben.</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass der Beobachtungszeitraum 10 Minuten beträgt, kann anhand der obigen Tabelle überprüft werden. Somit haben Sie in einer Stunde 6 Beobachtungen. Pro Tag werden wiederum 144 (6x24) Beobachtungen gesammelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie möchten die Temperatur vorhersagen, die in 6 Stunden in der Zukunft liegen wird. Sie erstellen diese Prognose basierend auf den Daten, die Sie für einen bestimmten Zeitraum haben: Sie entscheiden sich beispielsweise für eine Beobachtung von 5 Tagen. Um das Modell zu trainieren, müssen Sie daher ein Zeitintervall erstellen, das die letzten 720 (5x144) Beobachtungen enthält (da unterschiedliche Konfigurationen möglich sind, ist dieser Datensatz eine gute Grundlage für Experimente). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Funktion gibt die obigen Zeitintervalle für das Training des Modells zurück. Streit</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die Größe des letzten Zeitintervalls. </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ein Argument, das bestimmt, wie weit das Modell in die Zukunft voraussagen sollte. </font><font style="vertical-align: inherit;">Mit anderen Worten, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist der Zielvektor, der vorhergesagt werden muss.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In beiden Teilen des Handbuchs werden die ersten 300.000 Datenzeilen zum Trainieren des Modells verwendet, die restlichen zur Validierung (Validierung). </font><font style="vertical-align: inherit;">In diesem Fall beträgt die Menge der Trainingsdaten ungefähr 2100 Tage.</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um reproduzierbare Ergebnisse zu gewährleisten, wird die Seed-Funktion eingestellt.</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1. Prognose basierend auf einer eindimensionalen Zeitreihe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ersten Teil trainieren Sie das Modell mit nur einem Attribut - Temperatur; </font><font style="vertical-align: inherit;">Das trainierte Modell wird verwendet, um zukünftige Temperaturen vorherzusagen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst extrahieren wir nur die Temperatur aus dem Datensatz.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und mal sehen, wie sich diese Daten im Laufe der Zeit ändern.</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="Bild"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor dem Training eines künstlichen neuronalen Netzwerks (im Folgenden - ANN) ist die Datenskalierung ein wichtiger Schritt. </font><font style="vertical-align: inherit;">Eine der gebräuchlichen Methoden zur Durchführung der Skalierung ist die Standardisierung ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardisierung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), bei der der Mittelwert subtrahiert und für jedes Merkmal durch die Standardabweichung dividiert wird. </font><font style="vertical-align: inherit;">Sie können auch eine Methode verwenden </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Werte auf den Bereich [0,1] skaliert. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Standardisierung sollte nur anhand von Trainingsdaten durchgeführt werden.</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen eine Datenstandardisierung durch.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes bereiten wir die Daten für das Modell mit einer eindimensionalen Eingabe vor. </font><font style="vertical-align: inherit;">Die letzten 20 aufgezeichneten Beobachtungen der Temperatur werden dem Eingang des Modells zugeführt, und das Modell muss trainiert werden, um die Temperatur im nächsten Zeitschritt vorherzusagen.</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse der Anwendung der Funktion </font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergänzung: Die Vorbereitung von Daten für ein Modell mit einer eindimensionalen Eingabe ist in der folgenden Abbildung schematisch dargestellt (der Einfachheit halber werden die Daten in dieser und den folgenden Abbildungen vor der Standardisierung in einer „Rohform“ und auch ohne das Attribut 'Datum / Uhrzeit' als Index dargestellt):</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jetzt, da die Daten Betrachten Sie ein konkretes Beispiel, wenn Sie entsprechend vorbereitet sind. </font><font style="vertical-align: inherit;">Die an das ANN übertragenen Informationen sind blau hervorgehoben. Ein rotes Kreuz zeigt den zukünftigen Wert an, den das ANN vorhersagen sollte.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basislösung (ohne maschinelles Lernen)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vor Beginn des Modelltrainings installieren wir eine einfache Basislösung ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baseline</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Es besteht aus Folgendem: Für einen bestimmten Eingabevektor „scannt“ die grundlegende Lösungsmethode den gesamten Verlauf und sagt den nächsten Wert als Durchschnitt der letzten 20 Beobachtungen voraus.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, ob wir das Ergebnis der „Mittelwertbildung“ mithilfe eines wiederkehrenden neuronalen Netzwerks übertreffen können. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederkehrendes neuronales Netzwerk Ein</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wiederkehrendes neuronales Netzwerk (RNS) ist eine Art von ANN, die sich gut zur Lösung von Zeitreihenproblemen eignet. RNS verarbeitet Schritt für Schritt die zeitliche Abfolge von Daten, sortiert ihre Elemente und behält den internen Zustand bei, der durch die Verarbeitung der vorherigen Elemente erhalten wird. Weitere Informationen zu RNS finden Sie in der folgenden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anleitung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In diesem Handbuch wird eine spezielle RNC-Schicht namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Long Short-Term Memory ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Verwendung</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mische den Datensatz, staple ihn und speichere ihn zwischen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergänzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu den </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Shuffle-</font></a><font style="vertical-align: inherit;"> , Batch- und Cache-Methoden finden Sie auf der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Tensorflow-</font></a><font style="vertical-align: inherit;"> Seite </font><font style="vertical-align: inherit;">:</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Visualisierung soll Ihnen helfen, zu verstehen, wie die Daten nach der Stapelverarbeitung aussehen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass LSTM eine bestimmte Form der Dateneingabe erfordert, die ihm bereitgestellt wird.</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie die Modellausgabe.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergänzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen arbeiten RNSs mit Sequenzen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die an die Eingabe des Modells gelieferten Daten die folgende Form haben sollten: </font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Form der Trainingsdaten für das Modell mit einer eindimensionalen Eingabe hat die folgende Form:</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes werden wir das Modell untersuchen. </font><font style="vertical-align: inherit;">Aufgrund der Größe des Datensatzes und um Zeit zu sparen, durchläuft jede Epoche nur 200 Schritte ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">step_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) anstelle der vollständigen Trainingsdaten, wie dies normalerweise der </font><i><font style="vertical-align: inherit;">Fall</font></i><font style="vertical-align: inherit;"> ist.</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorhersage mit einem einfachen LSTM-Modell</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Abschluss der Erstellung eines einfachen LSTM-Modells werden wir mehrere Vorhersagen treffen.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht besser aus als das Basislevel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie sich mit den Grundlagen vertraut gemacht haben, fahren wir mit dem zweiten Teil fort, in dem die Arbeit mit einer mehrdimensionalen Zeitreihe beschrieben wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2: Mehrdimensionale Zeitreihenprognose</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, enthält der Originaldatensatz 14 verschiedene meteorologische Indikatoren. </font><font style="vertical-align: inherit;">Der Einfachheit und Bequemlichkeit halber werden im zweiten Teil nur drei davon betrachtet - Lufttemperatur, atmosphärischer Druck und Luftdichte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um weitere Funktionen verwenden zu können, müssen deren Namen zur Liste </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzugefügt werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie sich diese Indikatoren im Laufe der Zeit ändern.</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach wie vor besteht der erste Schritt darin, den Datensatz mit der Berechnung des Durchschnittswerts und der Standardabweichung der Trainingsdaten zu standardisieren.</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergänzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter im Handbuch werden wir über Punkt- und Intervallprognosen sprechen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Endergebnis ist wie folgt. Wenn Sie das Modell benötigen, um einen Wert in der Zukunft vorherzusagen (z. B. den Temperaturwert nach 12 Stunden) (Ein-Schritt- / Einzelschritt-Modell), müssen Sie das Modell so trainieren, dass es in Zukunft nur einen Wert vorhersagt. Wenn die Aufgabe darin besteht, den Wertebereich in der Zukunft vorherzusagen (z. B. stündliche Temperaturwerte in den nächsten 12 Stunden) (mehrstufiges Modell), sollte das Modell auch darauf trainiert werden, den Wertebereich in der Zukunft vorherzusagen. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punktvorhersage</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Fall wird das Modell darauf trainiert, einen Wert in der Zukunft basierend auf einer verfügbaren Historie vorherzusagen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Funktion führt dieselbe Aufgabe zum Organisieren von Zeitintervallen nur mit dem Unterschied aus, dass hier die neuesten Beobachtungen basierend auf einer bestimmten Schrittgröße ausgewählt werden.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Handbuch verarbeitet das ANN Daten für die letzten fünf (5) Tage, d. H. 720 Beobachtungen (6 x 24 x 5). </font><font style="vertical-align: inherit;">Angenommen, die Auswahl der Daten erfolgt nicht alle 10 Minuten, sondern jede Stunde: Innerhalb von 60 Minuten sind keine starken Änderungen zu erwarten. </font><font style="vertical-align: inherit;">Daher besteht die Geschichte der letzten fünf Tage aus 120 Beobachtungen (720/6). </font><font style="vertical-align: inherit;">Für ein Modell, das eine Punktvorhersage durchführt, ist das Ziel der Temperaturwert nach 12 Stunden in der Zukunft. </font><font style="vertical-align: inherit;">In diesem Fall ist der Zielvektor die Temperatur nach 72 (12x6) Beobachtungen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siehe folgenden Zusatz. -</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ungefährer </font><i><font style="vertical-align: inherit;">Übersetzer</font></i><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie das Zeitintervall.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unsere Stichprobe überprüfen und Verlustkurven in den Phasen des Trainings und der Überprüfung ableiten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="Bild"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergänzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datenvorbereitung für ein Modell mit einer mehrdimensionalen Eingabe zur Punktvorhersage ist in der folgenden Abbildung schematisch dargestellt. </font><font style="vertical-align: inherit;">Zur Vereinfachung und eine visuelle Darstellung der Datenaufbereitung, das Argument </font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist 1. Man </font><font style="vertical-align: inherit;">beachte , </font><font style="vertical-align: inherit;">daß in den gegebenen Generatorfunktionen, die </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich Argument </font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur für die Bildung der Geschichte bestimmt</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und nicht für den Zielvektor. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="Bild"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall hat es </font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Form </font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wann </font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat das Formular die folgende Form: </font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Geschwindigkeit der Funktion wird erheblich erhöht. </font><font style="vertical-align: inherit;">Im Allgemeinen müssen Sie dem Programmierer Anerkennung zollen: Die im Handbuch vorgestellten Generatoren sind hinsichtlich des Speicherverbrauchs sehr unersättlich. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchführen einer Punktvorhersage</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem das Modell trainiert wurde, werden wir mehrere Testvorhersagen durchführen. Die stündlich ausgewählte Beobachtungshistorie von 3 Zeichen für die letzten fünf Tage (Zeitintervall = 120) wird der Modelleingabe zugeführt. Da unser Ziel darin besteht, nur die Temperatur vorherzusagen, werden die vergangenen Temperaturwerte ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verlauf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">in der Grafik blau angezeigt </font><font style="vertical-align: inherit;">. Die Prognose wurde einen halben Tag in die Zukunft erstellt (daher die Lücke zwischen der Geschichte und dem vorhergesagten Wert).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intervallprognose</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Fall wird das Modell auf der Grundlage einer verfügbaren Historie trainiert, um das Intervall zukünftiger Werte vorherzusagen. </font><font style="vertical-align: inherit;">Im Gegensatz zu einem Modell, das in Zukunft nur einen Wert vorhersagt, sagt dieses Modell daher eine Folge von Werten in der Zukunft voraus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wie im Fall des Modells, das eine Punktvorhersage durchführt, sind die Trainingsdaten für das Modell, das eine Intervallvorhersage durchführt, die stündlichen Messungen der letzten fünf Tage (720/6). </font><font style="vertical-align: inherit;">In diesem Fall muss das Modell jedoch darauf trainiert werden, die Temperatur für die nächsten 12 Stunden vorherzusagen. </font><font style="vertical-align: inherit;">Da Beobachtungen alle 10 Minuten aufgezeichnet werden, sollte die Ausgabe des Modells aus 72 Vorhersagen bestehen. </font><font style="vertical-align: inherit;">Um diese Aufgabe abzuschließen, muss der Datensatz erneut vorbereitet werden, jedoch mit einem anderen Zielintervall.</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie die Auswahl.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: Der Unterschied in der Bildung des Zielvektors für das „Intervallmodell“ gegenüber dem „Punktmodell“ ist in der folgenden Abbildung dargestellt. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Visualisierung vorbereiten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem und den folgenden ähnlichen Diagrammen sind der Verlauf und zukünftige Daten stündlich.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da diese Aufgabe etwas komplizierter ist als die vorherige, besteht das Modell aus zwei LSTM-Schichten. </font><font style="vertical-align: inherit;">Schließlich hat die Ausgangsschicht 72 Neuronen, da 72 Vorhersagen durchgeführt werden.</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unsere Stichprobe überprüfen und Verlustkurven in den Phasen des Trainings und der Überprüfung ableiten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchführen einer Intervallvorhersage</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lassen Sie uns herausfinden, wie erfolgreich ein trainierter ANN mit Vorhersagen zukünftiger Temperaturwerte umgeht.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="Bild"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nächste Schritte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Leitfaden ist eine kurze Einführung in die Vorhersage von Zeitreihen mit RNS. Jetzt können Sie versuchen, den Aktienmarkt vorherzusagen und Milliardär zu werden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(im Original einfach so :). - Hinweis Übersetzer)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können Sie anstelle der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion uni / multivariate_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen eigenen Generator zum Vorbereiten von Daten schreiben </font><font style="vertical-align: inherit;">, um den Speicher effizienter zu nutzen. Sie können sich auch mit der Arbeit des „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreihenfensters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ </font><font style="vertical-align: inherit;">vertraut machen </font><font style="vertical-align: inherit;">und seine Ideen in diesen Leitfaden einbringen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besseren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verständnis wird empfohlen, Kapitel 15 des Buches </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">„Angewandtes maschinelles Lernen mit Scikit-Learn, Keras und TensorFlow“</font></a><font style="vertical-align: inherit;"> (Aurelien Geron, 2. Auflage) und Kapitel 6 des Buches zu </font><font style="vertical-align: inherit;">lesen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Deep Learning in Python"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Francois Scholl). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letzte Ergänzung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie während Ihres Aufenthalts zu Hause nicht nur auf Ihre Gesundheit, sondern auch auf den Computer, indem Sie Beispiele des Handbuchs für einen abgeschnittenen Datensatz ausführen. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise den Anteil von 70 x 30 (Schulung / Test) berücksichtigen, können Sie ihn wie folgt einschränken:</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495850/index.html">Alltag von Scrum-Masters: Team- und Selbsttransformation</a></li>
<li><a href="../de495852/index.html">LDA auf LiveJournal-Artikeln + Visualisierung</a></li>
<li><a href="../de495854/index.html">Wie kann man Covid und der Überwachung entkommen?</a></li>
<li><a href="../de495856/index.html">Intel DevCloud für oneAPI - ein Cloud-Service für Entwickler, die zu Hause sitzen</a></li>
<li><a href="../de495858/index.html">Fern und Selbstisolation: Weltraumerfahrung, um Erdbewohnern zu helfen</a></li>
<li><a href="../de495888/index.html">PyCon Russia hat die GFP für zukünftige Redner geöffnet. Teilnahmeformulare und erwartete Themen</a></li>
<li><a href="../de495890/index.html">Konfigurieren eines Nginx / LetsEncrypt-Bundles in Docker Swarm</a></li>
<li><a href="../de495892/index.html">Wissen Sie wirklich, was Arrays sind?</a></li>
<li><a href="../de495894/index.html">Javascript-Leistungsmessung</a></li>
<li><a href="../de495896/index.html">Use-Sound-Paket: Soundeffekte in React-Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>