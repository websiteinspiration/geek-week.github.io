<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèæ üë®üèæ‚Äçüåæ ü§∏üèº Zeitreihenvorhersage mit wiederkehrenden neuronalen Netzen ü§ôüèΩ ‚ùå üë±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Fernbedienung vor dem Hintergrund der universellen Selbstisolation kann zu sehr schlimmen Folgen f√ºhren. Und emotionales Burnout - es ist immer no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zeitreihenvorhersage mit wiederkehrenden neuronalen Netzen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Fernbedienung vor dem Hintergrund der universellen Selbstisolation kann zu sehr schlimmen Folgen f√ºhren. Und emotionales Burnout - es ist immer noch da, wo es hingeht: Immerhin ist es nicht weit vom Dach entfernt. In dieser Hinsicht versuchte er, wie viele andere auch, sich zu "beruhigen", indem er Zeit f√ºr andere Klassen zur Verf√ºgung stellte - und begann, die interessantesten Artikel aus dem Englischen ins Russische zu √ºbersetzen: "Sie geben </font><font style="vertical-align: inherit;">den Massen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maschinelles Lernen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !".) Wir m√ºssen Tribut zollen: Es ist sehr ablenkend. Wenn Sie Vorschl√§ge f√ºr den semantischen Inhalt und die √úbersetzung dieses Textes f√ºr einen russischsprachigen Leser haben, nehmen Sie an der Diskussion teil.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="Bild"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine √úbersetzung der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreihen-Prognoseseite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Abschnitt zum Tensorflow-Handbuch: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Meine Erg√§nzungen zusammen mit Abbildungen f√ºr die √úbersetzung sollen helfen, die Grundideen in einem der interessantesten Bereiche der ML und der √ñkonometrie im Allgemeinen zu verstehen - der Vorhersage von Zeitreihen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine kleine Einf√ºhrung vor der √úbersetzung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Handbuch beschreibt die Lufttemperaturvorhersage anhand eindimensionaler Zeitreihen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(univariate Zeitreihen)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und multivariater Zeitreihen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(multivariate Zeitreihen)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Geben Sie f√ºr jedes Teil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte entsprechend vorbereitet sein. Unter Ber√ºcksichtigung des in diesem Handbuch ber√ºcksichtigten meteorologischen Datensatzes lautet die Trennung wie folgt: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Fragen, was f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und was f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu beachten </font><font style="vertical-align: inherit;">ist, dh wie Daten f√ºr die Klasse des √ºberwachten Trainings vorzubereiten sind, wird dies aus den folgenden Abbildungen deutlich. Ich stelle nur fest, dass die Bildung des Zielvektors (Y) f√ºr die Arbeit mit eindimensionalen und mehrdimensionalen Zeitreihen gleich ist: Der </font><i><font style="vertical-align: inherit;">Zielvektor</font></i><font style="vertical-align: inherit;"> wird auf der Basis des Vorzeichens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T (degC) zusammengestellt.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Lufttemperatur). Der Unterschied zwischen ihnen liegt in der Bildung einer Reihe von Merkmalen, die der Modelleingabe zugef√ºhrt werden: Bei einer eindimensionalen Zeitreihe zur Vorhersage der Temperatur in der Zukunft besteht der Eingabevektor (X) aus einem Merkmal: Lufttemperatur; und f√ºr mehrdimensionale - mehr als eine: Zus√§tzlich zur Lufttemperatur werden im Beispiel dieses Handbuchs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p (mbar)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atmosph√§rischer Druck) und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho (g / m ** 3)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Luftfeuchtigkeit) </font><font style="vertical-align: inherit;">verwendet </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst sieht ein weit flaches Aussehen, ein Beispiel mit Temperaturvorhersage, unter dem Gesichtspunkt der Verwendung einer mehrdimensionalen Eingabe nicht √ºberzeugend aus: F√ºr die Temperaturvorhersage ist die Temperatur das relevanteste Zeichen. Dies ist jedoch absolut nicht der Fall: Um eine qualitative Vorhersage der Lufttemperatur zu erstellen, m√ºssen viele Faktoren bis zur Luftreibung auf der Erdoberfl√§che usw. ber√ºcksichtigt werden. Dar√ºber hinaus sind in der Praxis einige Dinge alles andere als offensichtlich, und der Zielvektor kann in Form dieses Durcheinander (oder Borschtsches) vorliegen. In dieser Hinsicht ist eine explorative Datenanalyse mit der Auswahl der relevantesten Merkmale f√ºr die nachfolgende Bildung einer mehrdimensionalen Eingabe die einzig richtige Entscheidung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher wird die √úbersetzung des Handbuchs unten dargestellt. Zus√§tzlicher Text wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kursiv dargestellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreihenprognose</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Leitfaden ist eine Einf√ºhrung in die Vorhersage von Zeitreihen unter Verwendung wiederkehrender neuronaler Netze (RNS, vom English </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recurrent Neural Network, RNN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Es besteht aus zwei Teilen: Der erste beschreibt die Vorhersage der Lufttemperatur anhand einer eindimensionalen Zeitreihe und der zweite Teil basiert auf einer mehrdimensionalen Zeitreihe.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe von meteorologischen Daten</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alle Beispiele f√ºr die manuelle Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen von Wetterdaten,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die an einer hydrometeorologischen Station </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des nach ihr benannten Instituts f√ºr Biogeochemie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgezeichnet wurden </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Max Planck</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Datensatz enth√§lt Messungen von 14 verschiedenen meteorologischen Indikatoren (wie Lufttemperatur, Luftdruck, Luftfeuchtigkeit), die seit 2003 alle 10 Minuten durchgef√ºhrt wurden. </font><font style="vertical-align: inherit;">Um Zeit und Speicherplatz zu sparen, werden im Handbuch Daten f√ºr den Zeitraum von 2009 bis 2016 verwendet. </font><font style="vertical-align: inherit;">Dieser Abschnitt des Datensatzes wurde von Fran√ßois Chollet f√ºr sein Buch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep Learning with Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorbereitet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was wir haben.</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass der Beobachtungszeitraum 10 Minuten betr√§gt, kann anhand der obigen Tabelle √ºberpr√ºft werden. Somit haben Sie in einer Stunde 6 Beobachtungen. Pro Tag werden wiederum 144 (6x24) Beobachtungen gesammelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie m√∂chten die Temperatur vorhersagen, die in 6 Stunden in der Zukunft liegen wird. Sie erstellen diese Prognose basierend auf den Daten, die Sie f√ºr einen bestimmten Zeitraum haben: Sie entscheiden sich beispielsweise f√ºr eine Beobachtung von 5 Tagen. Um das Modell zu trainieren, m√ºssen Sie daher ein Zeitintervall erstellen, das die letzten 720 (5x144) Beobachtungen enth√§lt (da unterschiedliche Konfigurationen m√∂glich sind, ist dieser Datensatz eine gute Grundlage f√ºr Experimente). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Funktion gibt die obigen Zeitintervalle f√ºr das Training des Modells zur√ºck. Streit</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die Gr√∂√üe des letzten Zeitintervalls. </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ein Argument, das bestimmt, wie weit das Modell in die Zukunft voraussagen sollte. </font><font style="vertical-align: inherit;">Mit anderen Worten, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist der Zielvektor, der vorhergesagt werden muss.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In beiden Teilen des Handbuchs werden die ersten 300.000 Datenzeilen zum Trainieren des Modells verwendet, die restlichen zur Validierung (Validierung). </font><font style="vertical-align: inherit;">In diesem Fall betr√§gt die Menge der Trainingsdaten ungef√§hr 2100 Tage.</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um reproduzierbare Ergebnisse zu gew√§hrleisten, wird die Seed-Funktion eingestellt.</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1. Prognose basierend auf einer eindimensionalen Zeitreihe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ersten Teil trainieren Sie das Modell mit nur einem Attribut - Temperatur; </font><font style="vertical-align: inherit;">Das trainierte Modell wird verwendet, um zuk√ºnftige Temperaturen vorherzusagen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst extrahieren wir nur die Temperatur aus dem Datensatz.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und mal sehen, wie sich diese Daten im Laufe der Zeit √§ndern.</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="Bild"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor dem Training eines k√ºnstlichen neuronalen Netzwerks (im Folgenden - ANN) ist die Datenskalierung ein wichtiger Schritt. </font><font style="vertical-align: inherit;">Eine der gebr√§uchlichen Methoden zur Durchf√ºhrung der Skalierung ist die Standardisierung ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardisierung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), bei der der Mittelwert subtrahiert und f√ºr jedes Merkmal durch die Standardabweichung dividiert wird. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch eine Methode verwenden </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Werte auf den Bereich [0,1] skaliert. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Standardisierung sollte nur anhand von Trainingsdaten durchgef√ºhrt werden.</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir f√ºhren eine Datenstandardisierung durch.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes bereiten wir die Daten f√ºr das Modell mit einer eindimensionalen Eingabe vor. </font><font style="vertical-align: inherit;">Die letzten 20 aufgezeichneten Beobachtungen der Temperatur werden dem Eingang des Modells zugef√ºhrt, und das Modell muss trainiert werden, um die Temperatur im n√§chsten Zeitschritt vorherzusagen.</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse der Anwendung der Funktion </font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erg√§nzung: Die Vorbereitung von Daten f√ºr ein Modell mit einer eindimensionalen Eingabe ist in der folgenden Abbildung schematisch dargestellt (der Einfachheit halber werden die Daten in dieser und den folgenden Abbildungen vor der Standardisierung in einer ‚ÄûRohform‚Äú und auch ohne das Attribut 'Datum / Uhrzeit' als Index dargestellt):</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jetzt, da die Daten Betrachten Sie ein konkretes Beispiel, wenn Sie entsprechend vorbereitet sind. </font><font style="vertical-align: inherit;">Die an das ANN √ºbertragenen Informationen sind blau hervorgehoben. Ein rotes Kreuz zeigt den zuk√ºnftigen Wert an, den das ANN vorhersagen sollte.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisl√∂sung (ohne maschinelles Lernen)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vor Beginn des Modelltrainings installieren wir eine einfache Basisl√∂sung ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baseline</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Es besteht aus Folgendem: F√ºr einen bestimmten Eingabevektor ‚Äûscannt‚Äú die grundlegende L√∂sungsmethode den gesamten Verlauf und sagt den n√§chsten Wert als Durchschnitt der letzten 20 Beobachtungen voraus.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, ob wir das Ergebnis der ‚ÄûMittelwertbildung‚Äú mithilfe eines wiederkehrenden neuronalen Netzwerks √ºbertreffen k√∂nnen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederkehrendes neuronales Netzwerk Ein</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wiederkehrendes neuronales Netzwerk (RNS) ist eine Art von ANN, die sich gut zur L√∂sung von Zeitreihenproblemen eignet. RNS verarbeitet Schritt f√ºr Schritt die zeitliche Abfolge von Daten, sortiert ihre Elemente und beh√§lt den internen Zustand bei, der durch die Verarbeitung der vorherigen Elemente erhalten wird. Weitere Informationen zu RNS finden Sie in der folgenden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anleitung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In diesem Handbuch wird eine spezielle RNC-Schicht namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Long Short-Term Memory ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Verwendung</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mische den Datensatz, staple ihn und speichere ihn zwischen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erg√§nzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu den </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Shuffle-</font></a><font style="vertical-align: inherit;"> , Batch- und Cache-Methoden finden Sie auf der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Tensorflow-</font></a><font style="vertical-align: inherit;"> Seite </font><font style="vertical-align: inherit;">:</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Visualisierung soll Ihnen helfen, zu verstehen, wie die Daten nach der Stapelverarbeitung aussehen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass LSTM eine bestimmte Form der Dateneingabe erfordert, die ihm bereitgestellt wird.</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie die Modellausgabe.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erg√§nzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen arbeiten RNSs mit Sequenzen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die an die Eingabe des Modells gelieferten Daten die folgende Form haben sollten: </font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Form der Trainingsdaten f√ºr das Modell mit einer eindimensionalen Eingabe hat die folgende Form:</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes werden wir das Modell untersuchen. </font><font style="vertical-align: inherit;">Aufgrund der Gr√∂√üe des Datensatzes und um Zeit zu sparen, durchl√§uft jede Epoche nur 200 Schritte ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">step_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) anstelle der vollst√§ndigen Trainingsdaten, wie dies normalerweise der </font><i><font style="vertical-align: inherit;">Fall</font></i><font style="vertical-align: inherit;"> ist.</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorhersage mit einem einfachen LSTM-Modell</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Abschluss der Erstellung eines einfachen LSTM-Modells werden wir mehrere Vorhersagen treffen.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht besser aus als das Basislevel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie sich mit den Grundlagen vertraut gemacht haben, fahren wir mit dem zweiten Teil fort, in dem die Arbeit mit einer mehrdimensionalen Zeitreihe beschrieben wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2: Mehrdimensionale Zeitreihenprognose</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, enth√§lt der Originaldatensatz 14 verschiedene meteorologische Indikatoren. </font><font style="vertical-align: inherit;">Der Einfachheit und Bequemlichkeit halber werden im zweiten Teil nur drei davon betrachtet - Lufttemperatur, atmosph√§rischer Druck und Luftdichte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um weitere Funktionen verwenden zu k√∂nnen, m√ºssen deren Namen zur Liste </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzugef√ºgt werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie sich diese Indikatoren im Laufe der Zeit √§ndern.</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach wie vor besteht der erste Schritt darin, den Datensatz mit der Berechnung des Durchschnittswerts und der Standardabweichung der Trainingsdaten zu standardisieren.</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erg√§nzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter im Handbuch werden wir √ºber Punkt- und Intervallprognosen sprechen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Endergebnis ist wie folgt. Wenn Sie das Modell ben√∂tigen, um einen Wert in der Zukunft vorherzusagen (z. B. den Temperaturwert nach 12 Stunden) (Ein-Schritt- / Einzelschritt-Modell), m√ºssen Sie das Modell so trainieren, dass es in Zukunft nur einen Wert vorhersagt. Wenn die Aufgabe darin besteht, den Wertebereich in der Zukunft vorherzusagen (z. B. st√ºndliche Temperaturwerte in den n√§chsten 12 Stunden) (mehrstufiges Modell), sollte das Modell auch darauf trainiert werden, den Wertebereich in der Zukunft vorherzusagen. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punktvorhersage</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Fall wird das Modell darauf trainiert, einen Wert in der Zukunft basierend auf einer verf√ºgbaren Historie vorherzusagen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Funktion f√ºhrt dieselbe Aufgabe zum Organisieren von Zeitintervallen nur mit dem Unterschied aus, dass hier die neuesten Beobachtungen basierend auf einer bestimmten Schrittgr√∂√üe ausgew√§hlt werden.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Handbuch verarbeitet das ANN Daten f√ºr die letzten f√ºnf (5) Tage, d. H. 720 Beobachtungen (6 x 24 x 5). </font><font style="vertical-align: inherit;">Angenommen, die Auswahl der Daten erfolgt nicht alle 10 Minuten, sondern jede Stunde: Innerhalb von 60 Minuten sind keine starken √Ñnderungen zu erwarten. </font><font style="vertical-align: inherit;">Daher besteht die Geschichte der letzten f√ºnf Tage aus 120 Beobachtungen (720/6). </font><font style="vertical-align: inherit;">F√ºr ein Modell, das eine Punktvorhersage durchf√ºhrt, ist das Ziel der Temperaturwert nach 12 Stunden in der Zukunft. </font><font style="vertical-align: inherit;">In diesem Fall ist der Zielvektor die Temperatur nach 72 (12x6) Beobachtungen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siehe folgenden Zusatz. -</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ungef√§hrer </font><i><font style="vertical-align: inherit;">√úbersetzer</font></i><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie das Zeitintervall.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unsere Stichprobe √ºberpr√ºfen und Verlustkurven in den Phasen des Trainings und der √úberpr√ºfung ableiten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="Bild"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erg√§nzung: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datenvorbereitung f√ºr ein Modell mit einer mehrdimensionalen Eingabe zur Punktvorhersage ist in der folgenden Abbildung schematisch dargestellt. </font><font style="vertical-align: inherit;">Zur Vereinfachung und eine visuelle Darstellung der Datenaufbereitung, das Argument </font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist 1. Man </font><font style="vertical-align: inherit;">beachte , </font><font style="vertical-align: inherit;">da√ü in den gegebenen Generatorfunktionen, die </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich Argument </font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur f√ºr die Bildung der Geschichte bestimmt</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und nicht f√ºr den Zielvektor. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="Bild"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall hat es </font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Form </font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wann </font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat das Formular die folgende Form: </font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Geschwindigkeit der Funktion wird erheblich erh√∂ht. </font><font style="vertical-align: inherit;">Im Allgemeinen m√ºssen Sie dem Programmierer Anerkennung zollen: Die im Handbuch vorgestellten Generatoren sind hinsichtlich des Speicherverbrauchs sehr uners√§ttlich. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchf√ºhren einer Punktvorhersage</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem das Modell trainiert wurde, werden wir mehrere Testvorhersagen durchf√ºhren. Die st√ºndlich ausgew√§hlte Beobachtungshistorie von 3 Zeichen f√ºr die letzten f√ºnf Tage (Zeitintervall = 120) wird der Modelleingabe zugef√ºhrt. Da unser Ziel darin besteht, nur die Temperatur vorherzusagen, werden die vergangenen Temperaturwerte ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verlauf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">in der Grafik blau angezeigt </font><font style="vertical-align: inherit;">. Die Prognose wurde einen halben Tag in die Zukunft erstellt (daher die L√ºcke zwischen der Geschichte und dem vorhergesagten Wert).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intervallprognose</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Fall wird das Modell auf der Grundlage einer verf√ºgbaren Historie trainiert, um das Intervall zuk√ºnftiger Werte vorherzusagen. </font><font style="vertical-align: inherit;">Im Gegensatz zu einem Modell, das in Zukunft nur einen Wert vorhersagt, sagt dieses Modell daher eine Folge von Werten in der Zukunft voraus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wie im Fall des Modells, das eine Punktvorhersage durchf√ºhrt, sind die Trainingsdaten f√ºr das Modell, das eine Intervallvorhersage durchf√ºhrt, die st√ºndlichen Messungen der letzten f√ºnf Tage (720/6). </font><font style="vertical-align: inherit;">In diesem Fall muss das Modell jedoch darauf trainiert werden, die Temperatur f√ºr die n√§chsten 12 Stunden vorherzusagen. </font><font style="vertical-align: inherit;">Da Beobachtungen alle 10 Minuten aufgezeichnet werden, sollte die Ausgabe des Modells aus 72 Vorhersagen bestehen. </font><font style="vertical-align: inherit;">Um diese Aufgabe abzuschlie√üen, muss der Datensatz erneut vorbereitet werden, jedoch mit einem anderen Zielintervall.</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie die Auswahl.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: Der Unterschied in der Bildung des Zielvektors f√ºr das ‚ÄûIntervallmodell‚Äú gegen√ºber dem ‚ÄûPunktmodell‚Äú ist in der folgenden Abbildung dargestellt. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Visualisierung vorbereiten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem und den folgenden √§hnlichen Diagrammen sind der Verlauf und zuk√ºnftige Daten st√ºndlich.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da diese Aufgabe etwas komplizierter ist als die vorherige, besteht das Modell aus zwei LSTM-Schichten. </font><font style="vertical-align: inherit;">Schlie√ülich hat die Ausgangsschicht 72 Neuronen, da 72 Vorhersagen durchgef√ºhrt werden.</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unsere Stichprobe √ºberpr√ºfen und Verlustkurven in den Phasen des Trainings und der √úberpr√ºfung ableiten.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="Bild"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchf√ºhren einer Intervallvorhersage</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lassen Sie uns herausfinden, wie erfolgreich ein trainierter ANN mit Vorhersagen zuk√ºnftiger Temperaturwerte umgeht.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="Bild"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√§chste Schritte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Leitfaden ist eine kurze Einf√ºhrung in die Vorhersage von Zeitreihen mit RNS. Jetzt k√∂nnen Sie versuchen, den Aktienmarkt vorherzusagen und Milliard√§r zu werden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(im Original einfach so :). - Hinweis √úbersetzer)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus k√∂nnen Sie anstelle der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion uni / multivariate_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen eigenen Generator zum Vorbereiten von Daten schreiben </font><font style="vertical-align: inherit;">, um den Speicher effizienter zu nutzen. Sie k√∂nnen sich auch mit der Arbeit des ‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreihenfensters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú </font><font style="vertical-align: inherit;">vertraut machen </font><font style="vertical-align: inherit;">und seine Ideen in diesen Leitfaden einbringen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besseren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verst√§ndnis wird empfohlen, Kapitel 15 des Buches </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">‚ÄûAngewandtes maschinelles Lernen mit Scikit-Learn, Keras und TensorFlow‚Äú</font></a><font style="vertical-align: inherit;"> (Aurelien Geron, 2. Auflage) und Kapitel 6 des Buches zu </font><font style="vertical-align: inherit;">lesen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Deep Learning in Python"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Francois Scholl). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letzte Erg√§nzung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie w√§hrend Ihres Aufenthalts zu Hause nicht nur auf Ihre Gesundheit, sondern auch auf den Computer, indem Sie Beispiele des Handbuchs f√ºr einen abgeschnittenen Datensatz ausf√ºhren. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise den Anteil von 70 x 30 (Schulung / Test) ber√ºcksichtigen, k√∂nnen Sie ihn wie folgt einschr√§nken:</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495850/index.html">Alltag von Scrum-Masters: Team- und Selbsttransformation</a></li>
<li><a href="../de495852/index.html">LDA auf LiveJournal-Artikeln + Visualisierung</a></li>
<li><a href="../de495854/index.html">Wie kann man Covid und der √úberwachung entkommen?</a></li>
<li><a href="../de495856/index.html">Intel DevCloud f√ºr oneAPI - ein Cloud-Service f√ºr Entwickler, die zu Hause sitzen</a></li>
<li><a href="../de495858/index.html">Fern und Selbstisolation: Weltraumerfahrung, um Erdbewohnern zu helfen</a></li>
<li><a href="../de495888/index.html">PyCon Russia hat die GFP f√ºr zuk√ºnftige Redner ge√∂ffnet. Teilnahmeformulare und erwartete Themen</a></li>
<li><a href="../de495890/index.html">Konfigurieren eines Nginx / LetsEncrypt-Bundles in Docker Swarm</a></li>
<li><a href="../de495892/index.html">Wissen Sie wirklich, was Arrays sind?</a></li>
<li><a href="../de495894/index.html">Javascript-Leistungsmessung</a></li>
<li><a href="../de495896/index.html">Use-Sound-Paket: Soundeffekte in React-Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>