<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏼 ↙️ 🏓 Wie ich meinem Computer beigebracht habe, Dobble mit OpenCV und Deep Learning zu spielen ♒️ ☘️ ❤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo liebe Abonnenten! Sie wissen wahrscheinlich bereits, dass wir einen neuen Kurs "Computer Vision" gestartet haben , dessen Unterricht in den komm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie ich meinem Computer beigebracht habe, Dobble mit OpenCV und Deep Learning zu spielen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/498800/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo liebe Abonnenten! </font><font style="vertical-align: inherit;">Sie wissen wahrscheinlich bereits, dass wir einen neuen Kurs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Computer Vision"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gestartet haben </font><font style="vertical-align: inherit;">, dessen Unterricht in den kommenden Tagen beginnen wird. </font><font style="vertical-align: inherit;">Im Vorgriff auf den Beginn des Unterrichts haben wir eine weitere interessante Übersetzung für das Eintauchen in die Welt des Lebenslaufs vorbereitet.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/q9/rm/5j/q9rm5jisb3ecqro7lnwivk2wwqc.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein Hobby ist das Spielen von Brettspielen. Da ich mit Faltungs-Neuronalen Netzen ein wenig vertraut bin, habe ich beschlossen, eine Anwendung zu erstellen, die eine Person in einem Kartenspiel schlagen kann. </font><font style="vertical-align: inherit;">Ich wollte ein Modell von Grund auf mit meinem eigenen Datensatz erstellen und sehen, wie gut es mit einem kleinen Datensatz funktioniert. </font><font style="vertical-align: inherit;">Ich beschloss, mit dem einfachen Dobble-Spiel (auch bekannt als Spot it!) Zu beginnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nicht wissen, was Dobble ist, erinnere ich mich kurz an die Spielregeln: Dobble ist ein einfaches Mustererkennungsspiel, bei dem die Spieler versuchen, ein Bild zu finden, das gleichzeitig auf zwei Karten abgebildet ist. </font><font style="vertical-align: inherit;">Jede Karte im ursprünglichen Dobble-Spiel enthält acht verschiedene Charaktere und auf verschiedenen Karten sind sie unterschiedlich groß. </font><font style="vertical-align: inherit;">Zwei beliebige Karten haben nur ein gemeinsames Symbol. </font><font style="vertical-align: inherit;">Wenn Sie das Symbol zuerst finden, nehmen Sie eine Karte. </font><font style="vertical-align: inherit;">Wenn das Kartenspiel mit 55 Karten endet, gewinnt das mit den meisten Karten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qt/b7/sw/qtb7swvb0bghekmkzqswukrkwoy.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probieren Sie es aus: Welches Symbol haben diese beiden Karten gemeinsam?</font></font></i><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wo soll ich anfangen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Schritt bei der Lösung einer Datenanalyseaufgabe besteht darin, Daten zu sammeln. </font><font style="vertical-align: inherit;">Ich habe sechs Fotos von jeder Karte am Telefon gemacht. </font><font style="vertical-align: inherit;">Insgesamt sind 330 Fotos entstanden. </font><font style="vertical-align: inherit;">Vier davon sehen Sie unten. </font><font style="vertical-align: inherit;">Sie fragen sich vielleicht, ob dies ausreicht, um ein gutes neuronales Faltungsnetzwerk zu schaffen? </font><font style="vertical-align: inherit;">Wir werden darauf zurückkommen!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cf/8s/c5/cf8sc5csfihv8q9ngt4r5wipzom.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildverarbeitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, die Daten, die wir haben, wie geht es weiter? </font><font style="vertical-align: inherit;">Der wahrscheinlich wichtigste Teil auf dem Weg zum Erfolg: die Bildverarbeitung. </font><font style="vertical-align: inherit;">Wir müssen Zeichen aus jedem Bild erhalten. </font><font style="vertical-align: inherit;">Hier erwarten uns einige Schwierigkeiten. </font><font style="vertical-align: inherit;">Auf den Fotos oben ist zu erkennen, dass einige Zeichen schwieriger zu unterscheiden sind als andere: Der Schneemann und der Geist (auf dem dritten Foto) und die Nadel (auf dem vierten) in hellen Farben sowie die Flecken (auf dem zweiten Foto) und das Ausrufezeichen (auf dem vierten Foto) bestehen aus mehreren Teilen . </font><font style="vertical-align: inherit;">Um helle Zeichen zu verarbeiten, fügen wir Kontrast hinzu. </font><font style="vertical-align: inherit;">Danach ändern wir die Größe und speichern das Bild.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontrast hinzufügen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Kontrast zu erhöhen, verwenden wir den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lab-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farbraum </font><i><font style="vertical-align: inherit;">. </font></i><i><font style="vertical-align: inherit;">L</font></i><font style="vertical-align: inherit;"> ist die Helligkeit, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die chromatische Komponente im Bereich von grün bis magenta und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die chromatische Komponente im Bereich von blau bis gelb. </font><font style="vertical-align: inherit;">Wir können diese Komponenten einfach mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> extrahieren </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">import cv2<font></font>
import imutils<font></font>
imgname = 'picture1'<font></font>
image = cv2.imread(f’{imgname}.jpg’)<font></font>
lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)<font></font>
l, a, b = cv2.split(lab)</code></pre><br>
<img src="https://habrastorage.org/webt/2u/rf/xs/2urfxs4kcjdhokrytfnpggg_l3s.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von links nach rechts: das Originalbild, die Helligkeitskomponente, Komponente a und Komponente b</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nun fügen wir der Helligkeitskomponente einen Kontrast hinzu, kombinieren erneut alle Komponenten miteinander und konvertieren sie in ein normales Bild:</font></font><br>
<br>
<pre><code class="plaintext hljs">clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))<font></font>
cl = clahe.apply(l)<font></font>
limg = cv2.merge((cl,a,b))<font></font>
final = cv2.cvtColor(limg, cv2.COLOR_LAB2BGR)</code></pre><br>
<img src="https://habrastorage.org/webt/6i/fc/wy/6ifcwytem84rmka2rwsn8e2iicu.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von links nach rechts: das Originalbild, die Helligkeitskomponente, das kontrastreiche Bild und das zurück in RGB konvertierte Bild</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größenänderung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ändern Sie nun die Größe und speichern Sie das Bild:</font></font><br>
<br>
<pre><code class="plaintext hljs">resized = cv2.resize(final, (800, 800))<font></font>
# save the image<font></font>
cv2.imwrite(f'{imgname}processed.jpg', blurred)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erledigt!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karten- und Zeichenerkennung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem das Bild verarbeitet wurde, können wir eine Karte im Bild erkennen. </font><font style="vertical-align: inherit;">Mit OpenCV suchen wir nach externen Konturen. </font><font style="vertical-align: inherit;">Anschließend konvertieren wir das Bild in Halbtöne, wählen den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwellenwert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in unserem Fall 190) aus, um ein Schwarzweißbild zu erstellen, und suchen nach einem Pfad. </font><font style="vertical-align: inherit;">Der Code:</font></font><br>
<br>
<pre><code class="plaintext hljs">image = cv2.imread(f’{imgname}processed.jpg’)<font></font>
gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)<font></font>
thresh = cv2.threshold(gray, 190, 255, cv2.THRESH_BINARY)[1]<font></font>
# find contours<font></font>
cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)<font></font>
cnts = imutils.grab_contours(cnts)<font></font>
output = image.copy()<font></font>
# draw contours on image<font></font>
for c in cnts:<font></font>
    cv2.drawContours(output, [c], -1, (255, 0, 0), 3)</code></pre><br>
<img src="https://habrastorage.org/webt/bh/y6/24/bhy624atzopnzxchn5gz0navg0e.jpeg"><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verarbeitetes Bild, das mithilfe des Schwellenwerts und der Auswahl externer Konturen in Halbtöne umgewandelt wurde</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn wir die externen Konturen nach Fläche sortieren, finden wir die Kontur mit der größten Fläche - dies ist unsere Karte. </font><font style="vertical-align: inherit;">Um die Zeichen zu extrahieren, können wir einen weißen Hintergrund erstellen.</font></font><br>
<br>
<pre><code class="plaintext hljs"># sort by area, grab the biggest one<font></font>
cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[0]<font></font>
# create mask with the biggest contour<font></font>
mask = np.zeros(gray.shape,np.uint8)<font></font>
mask = cv2.drawContours(mask, [cnts], -1, 255, cv2.FILLED)<font></font>
# card in foreground<font></font>
fg_masked = cv2.bitwise_and(image, image, mask=mask)<font></font>
# white background (use inverted mask)<font></font>
mask = cv2.bitwise_not(mask)<font></font>
bk = np.full(image.shape, 255, dtype=np.uint8)<font></font>
bk_masked = cv2.bitwise_and(bk, bk, mask=mask)<font></font>
# combine back- and foreground<font></font>
final = cv2.bitwise_or(fg_masked, bk_masked)</code></pre><br>
<img src="https://habrastorage.org/webt/j3/lh/dn/j3lhdnzj07y84s5uqiiuphysety.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maske, Hintergrund, Vordergrundbild, endgültiges Bild</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jetzt ist es Zeit für die Zeichenerkennung! </font><font style="vertical-align: inherit;">Wir können das resultierende Bild verwenden, um wieder externe Konturen darauf zu erkennen. Diese Konturen sind Symbole. </font><font style="vertical-align: inherit;">Wenn wir um jedes Symbol ein Quadrat erstellen, können wir diesen Bereich extrahieren. </font><font style="vertical-align: inherit;">Hier ist der Code etwas länger:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># just like before (with detecting the card)</span><font></font>
gray = cv2.cvtColor(final, cv2.COLOR_RGB2GRAY)<font></font>
thresh = cv2.threshold(gray, <span class="hljs-number">195</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)[<span class="hljs-number">1</span>]<font></font>
thresh = cv2.bitwise_not(thresh)<font></font>
cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)<font></font>
cnts = imutils.grab_contours(cnts)<font></font>
cnts = sorted(cnts, key=cv2.contourArea, reverse=<span class="hljs-literal">True</span>)[:<span class="hljs-number">10</span>]
<span class="hljs-comment"># handle each contour</span>
i = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cnts:
    <span class="hljs-keyword">if</span> cv2.contourArea(c) &gt; <span class="hljs-number">1000</span>:
        <span class="hljs-comment"># draw mask, keep contour</span><font></font>
        mask = np.zeros(gray.shape, np.uint8)<font></font>
        mask = cv2.drawContours(mask, [c], <span class="hljs-number">-1</span>, <span class="hljs-number">255</span>, cv2.FILLED)
        <span class="hljs-comment"># white background</span><font></font>
        fg_masked = cv2.bitwise_and(image, image, mask=mask)<font></font>
        mask = cv2.bitwise_not(mask)<font></font>
        bk = np.full(image.shape, <span class="hljs-number">255</span>, dtype=np.uint8)<font></font>
        bk_masked = cv2.bitwise_and(bk, bk, mask=mask)<font></font>
        finalcont = cv2.bitwise_or(fg_masked, bk_masked)<font></font>
        <span class="hljs-comment"># bounding rectangle around contour</span><font></font>
        output = finalcont.copy()<font></font>
        x,y,w,h = cv2.boundingRect(c)<font></font>
        <span class="hljs-comment"># squares io rectangles</span>
        <span class="hljs-keyword">if</span> w &lt; h:<font></font>
            x += int((w-h)/<span class="hljs-number">2</span>)<font></font>
            w = h<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            y += int((h-w)/<span class="hljs-number">2</span>)<font></font>
            h = w<font></font>
        <span class="hljs-comment"># take out the square with the symbol</span><font></font>
        roi = finalcont[y:y+h, x:x+w]<font></font>
        roi = cv2.resize(roi, (<span class="hljs-number">400</span>,<span class="hljs-number">400</span>))
        <span class="hljs-comment"># save the symbol</span>
        cv2.imwrite(<span class="hljs-string">f"<span class="hljs-subst">{imgname}</span>_icon<span class="hljs-subst">{i}</span>.jpg"</span>, roi)<font></font>
        i += <span class="hljs-number">1</span></code></pre><br>
<img src="https://habrastorage.org/webt/qf/pf/vk/qfpfvkmhh5u674jgxpbiecjcovg.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwarzweißbild (Schwellenwert), erkannte Umrisse, ein Geistersymbol und ein Herzsymbol (mit Masken extrahierte Zeichen)</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichensortierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt das langweiligste! </font><font style="vertical-align: inherit;">Sie müssen die Zeichen sortieren. </font><font style="vertical-align: inherit;">Sie benötigen die Zug-, Test- und Validierungsverzeichnisse mit jeweils 57 Verzeichnissen (wir haben insgesamt 57 verschiedene Zeichen). </font><font style="vertical-align: inherit;">Die Ordnerstruktur ist wie folgt:</font></font><br>
<br>
<pre><code class="python hljs">symbols<font></font>
 ├── test<font></font>
 │   ├── anchor<font></font>
 │   ├── apple<font></font>
 │   │   ...<font></font>
 │   └── zebra<font></font>
 ├── train<font></font>
 │   ├── anchor<font></font>
 │   ├── apple<font></font>
 │   │   ...<font></font>
 │   └── zebra<font></font>
 └── validation<font></font>
     ├── anchor<font></font>
     ├── apple<font></font>
     │   ...<font></font>
     └── zebra</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird einige Zeit dauern, bis die extrahierten Zeichen (mehr als 2500 Teile) in den erforderlichen Verzeichnissen gespeichert sind! </font><font style="vertical-align: inherit;">Ich habe Code zum Erstellen von Unterordnern, eine Testsuite und ein Validierungskit auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vielleicht ist es beim nächsten Mal besser, die Sortierung basierend auf dem Clustering-Algorithmus durchzuführen ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faltungs-Training für neuronale Netze</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem langweiligen Teil kommt der Spaß wieder! </font><font style="vertical-align: inherit;">Es ist Zeit, ein Faltungsnetzwerk zu erstellen und zu trainieren. </font><font style="vertical-align: inherit;">Informationen zu Faltungs-Neuronalen Netzen finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modellarchitektur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Aufgabe, mehrere Klassen mit einem Etikett zu klassifizieren. </font><font style="vertical-align: inherit;">Für jedes Zeichen benötigen wir ein Etikett. </font><font style="vertical-align: inherit;">Aus diesem Grund benötigen wir eine Funktion zum Aktivieren der Ausgabe- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Softmax-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schicht </font><font style="vertical-align: inherit;">mit 57 Knoten und kategorialer Kreuzentropie als Verlustfunktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Architektur des endgültigen Modells ist wie folgt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># imports</span>
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> layers
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> models
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> optimizers
<span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-comment"># layers, activation layer with 57 nodes (one for every symbol)</span><font></font>
model = models.Sequential()<font></font>
model.add(layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, input_shape=(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>, <span class="hljs-number">3</span>)))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))  <font></font>
model.add(layers.Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">256</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">256</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.Flatten())<font></font>
model.add(layers.Dropout(<span class="hljs-number">0.5</span>)) <font></font>
model.add(layers.Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.Dense(<span class="hljs-number">57</span>, activation=<span class="hljs-string">'softmax'</span>))<font></font>
model.compile(loss=<span class="hljs-string">'categorical_crossentropy'</span>,       optimizer=optimizers.RMSprop(lr=<span class="hljs-number">1e-4</span>), metrics=[<span class="hljs-string">'acc'</span>])</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenerweiterung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Leistung zu verbessern, habe ich die Datenerweiterung verwendet. </font><font style="vertical-align: inherit;">Bei der Datenerweiterung werden das Volumen und die Vielfalt der Eingabedaten erhöht. </font><font style="vertical-align: inherit;">Dies kann durch Drehen, Verschieben, Skalieren, Zuschneiden und Spiegeln vorhandener Bilder erfolgen. </font><font style="vertical-align: inherit;">Keras kann Daten leicht erweitern:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># specify the directories</span>
train_dir = <span class="hljs-string">'symbols/train'</span>
validation_dir = <span class="hljs-string">'symbols/validation'</span>
test_dir = <span class="hljs-string">'symbols/test'</span>
<span class="hljs-comment"># data augmentation with ImageDataGenerator from Keras (only train)</span>
train_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>, rotation_range=<span class="hljs-number">40</span>, width_shift_range=<span class="hljs-number">0.1</span>, height_shift_range=<span class="hljs-number">0.1</span>, shear_range=<span class="hljs-number">0.1</span>, zoom_range=<span class="hljs-number">0.1</span>, horizontal_flip=<span class="hljs-literal">True</span>, vertical_flip=<span class="hljs-literal">True</span>)<font></font>
test_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<font></font>
train_generator = train_datagen.flow_from_directory(train_dir, target_size=(<span class="hljs-number">400</span>,<span class="hljs-number">400</span>), batch_size=<span class="hljs-number">20</span>, class_mode=<span class="hljs-string">'categorical'</span>)<font></font>
validation_generator = test_datagen.flow_from_directory(validation_dir, target_size=(<span class="hljs-number">400</span>,<span class="hljs-number">400</span>), batch_size=<span class="hljs-number">20</span>, class_mode=<span class="hljs-string">'categorical'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie interessiert waren, sieht der erweiterte Geist folgendermaßen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hj/wq/_c/hjwq_ckmzjkvmyr9xu9fr5pyq0w.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Originalbild des Geistes links, erweiterte Geister in allen anderen Bildern</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelltraining</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns das Modell trainieren, speichern, um es für Vorhersagen zu verwenden, und die Ergebnisse überprüfen.</font></font><br>
<br>
<pre><code class="python hljs">history = model.fit_generator(train_generator, steps_per_epoch=<span class="hljs-number">100</span>, epochs=<span class="hljs-number">100</span>, validation_data=validation_generator, validation_steps=<span class="hljs-number">50</span>)
<span class="hljs-comment"># don't forget to save your model!</span>
model.save(<span class="hljs-string">'models/model.h5'</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/uz/c2/qm/uzc2qml9v4-zezvickpgjezm8ly.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perfekte Vorhersagen!</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Grundmodell, das ich ohne Datenerweiterung, Aussetzer und mit weniger Ebenen trainiert habe. </font><font style="vertical-align: inherit;">Dieses Modell ergab die folgenden Ergebnisse: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/tg/u3/lctgu3nfsj3felc31tuhtg68neg.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse des Grundmodells</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mit bloßem Auge ist klar, dass dieses Modell umgeschult wird. </font><font style="vertical-align: inherit;">Die Ergebnisse der endgültigen Version des Modells (der Code wird in den vorherigen Abschnitten vorgestellt) sind viel besser. </font><font style="vertical-align: inherit;">In der folgenden Grafik sehen Sie die Genauigkeit und Verluste während des Trainings und im Validierungssatz. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/tn/s2/bwtns2xrfdgnlzuxmwppzdqhyom.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse des endgültigen Modells.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Auf dem Testset machte dieses Modell nur einen Fehler, es erkannte die Bombe als Tropfen. </font><font style="vertical-align: inherit;">Ich entschied mich für dieses Modell, die Genauigkeit des Testsatzes betrug 0,995.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erkennung eines gemeinsamen Symbols auf zwei Karten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie auf zwei Karten nach gemeinsamen Symbolen suchen. </font><font style="vertical-align: inherit;">Wir verwenden zwei Fotos, machen Vorhersagen für jedes Bild separat und verwenden den Schnittpunkt von Mengen, um herauszufinden, welches Symbol sich auf beiden Karten befindet. </font><font style="vertical-align: inherit;">Wir haben 3 Arbeitsmöglichkeiten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während der Vorhersage ist etwas schiefgegangen: Es wurden keine gemeinsamen Zeichen gefunden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An der Kreuzung befindet sich ein Symbol (Vorhersage kann wahr oder falsch sein).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt mehr als ein Zeichen an der Kreuzung. </font><font style="vertical-align: inherit;">In diesem Fall wähle ich das Symbol mit der höchsten Wahrscheinlichkeit (den Durchschnitt beider Vorhersagen).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code für die </font><font style="vertical-align: inherit;">ganze Kombination auf den beiden Bildern in den Katalog liegt bei der </font><font style="vertical-align: inherit;">Vorhersage </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist </font></font><code>main.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier sind die Ergebnisse:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/6h/em/kz6hemmqhp7bhdq25ywzipipdou.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Ist das nicht das perfekte Modell? Leider gibt es keine. Als ich neue Fotos von den Karten machte und ihnen die Modelle zur Vorhersage gab, gab es einige Probleme mit dem Schneemann. Manchmal erkannte er das Auge oder Zebra als Schneemann! Infolgedessen waren die Ergebnisse manchmal seltsam: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b0/y4/e8/b0y4e8nw6kq7juigw_oekx2jjtk.jpeg"> <br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, wo ist der Schneemann hier?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ist dieses Modell besser als der Mensch? Je nachdem, was wir brauchen: Die Leute erkennen perfekt, aber das Modell macht es schneller! Ich bemerkte die Zeit, für die der Computer zurechtkommt: Ich gab ein Kartenspiel mit 55 Karten und musste für jede Kombination von zwei Karten ein gemeinsames Symbol erhalten. Insgesamt sind dies 1485 Kombinationen. Der Computer hat es in weniger als 140 Sekunden geschafft. Er hat ein paar Fehler gemacht, aber er wird definitiv jeden schlagen, wenn es um Geschwindigkeit geht!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/pn/ce/t2pncemklqifymf39ixawz9ejsg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Ich denke nicht, dass es schwierig ist, ein funktionierendes 100% -Modell zu erstellen. </font><font style="vertical-align: inherit;">Dies kann durch Transfer-Training erreicht werden. </font><font style="vertical-align: inherit;">Um zu verstehen, was das Modell tut, könnten wir Ebenen für das Testbild visualisieren. </font><font style="vertical-align: inherit;">Du kannst es das nächste Mal tun!</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahren Sie mehr über den Kurs und bestehen Sie den Eingangstest</font></font></a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498768/index.html">Verwendung eines Rauchmelders in Fahrzeugen</a></li>
<li><a href="../de498782/index.html">Kampfexperimentatoren - Sand and Stick Science - Inokulation des wissenschaftlichen Denkens in die Öffentlichkeit</a></li>
<li><a href="../de498788/index.html">Einen Mini-Schrittmotor lernen</a></li>
<li><a href="../de498796/index.html">Inhaltssicherheitsrichtlinie in Magento 2</a></li>
<li><a href="../de498798/index.html">Lernen Sie weiter und lernen Sie mit JetBrains</a></li>
<li><a href="../de498808/index.html">Vim mit YAML-Unterstützung für Kubernetes</a></li>
<li><a href="../de498814/index.html">Sie haben eine theoretische Frage zur sozialen Sicherheit nicht beantwortet, und sie haben Ihnen ein Ende gesetzt. Es ist in Ordnung? // Wir sind zum Scheitern verurteilt # 3</a></li>
<li><a href="../de498816/index.html">Die Wahrheit zuallererst oder warum das System basierend auf dem Datenbankgerät entworfen werden muss</a></li>
<li><a href="../de498820/index.html">Einige weitere knifflige Fragen zu .NET und C #</a></li>
<li><a href="../de498826/index.html">SIL und Salesforce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>