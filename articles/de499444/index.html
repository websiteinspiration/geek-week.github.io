<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèΩ üëÅ‚Äçüó® üêæ Postgres: Aufbl√§hen, pg_repack und verz√∂gerte Einschr√§nkungen üë®‚ÄçüöÄ üë®üèª üìü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Effekt des Aufbl√§hens von Tabellen und Indizes (Aufbl√§hen) ist weithin bekannt und tritt nicht nur bei Postgres auf. Es gibt M√∂glichkeiten, wie "V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Postgres: Aufbl√§hen, pg_repack und verz√∂gerte Einschr√§nkungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/miro/blog/499444/"><img src="https://habrastorage.org/webt/vf/eu/y5/vfeuy53s9e1md_jhdwxbkkmr-8e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Effekt des Aufbl√§hens von Tabellen und Indizes (Aufbl√§hen) ist weithin bekannt und tritt nicht nur bei Postgres auf. </font><font style="vertical-align: inherit;">Es gibt M√∂glichkeiten, wie "VACUUM FULL" oder "CLUSTER" "out of the box" damit umzugehen, aber sie sperren Tabellen w√§hrend des Betriebs und k√∂nnen daher nicht immer verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel wird ein wenig Theorie dar√ºber enthalten, wie Aufbl√§hen auftritt, wie damit umgegangen wird, √ºber verz√∂gerte Einschr√§nkungen und die Probleme, die sie bei der Verwendung der Erweiterung pg_repack mit sich bringen.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel basiert auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meiner Pr√§sentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der PgConf.Russia 2020.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8vaVeCKuz6M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum Bl√§hungen auftreten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres basiert auf dem Multi-Version-Modell ( </font></font><abbr title="Parallelit√§tskontrolle f√ºr mehrere Versionen"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVCC</font></font></a></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Das Wesentliche ist, dass jede Zeile in der Tabelle mehrere Versionen haben kann, w√§hrend Transaktionen nicht mehr als eine dieser Versionen sehen, aber nicht unbedingt dieselbe. Dadurch k√∂nnen mehrere Transaktionen gleichzeitig ausgef√ºhrt werden und haben praktisch keine Auswirkungen aufeinander. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich m√ºssen alle diese Versionen gespeichert werden. Postgres arbeitet Seite f√ºr Seite mit dem Speicher und die Seite ist die minimale Datenmenge, die von der Festplatte gelesen oder geschrieben werden kann. Schauen wir uns ein kleines Beispiel an, um zu verstehen, wie dies geschieht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben eine Tabelle, in der wir mehrere Datens√§tze hinzugef√ºgt haben. Auf der ersten Seite der Datei, auf der die Tabelle gespeichert ist, wurden neue Daten angezeigt. Hierbei handelt es sich um Live-Versionen von Zeichenfolgen, die nach einem Commit f√ºr andere Transaktionen verf√ºgbar sind (der Einfachheit halber wird davon ausgegangen, dass die Isolationsstufe Read Committed verwendet wird). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pb/ep/av/pbepavyhm5_alpqup33j8vfcocm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann haben wir einen der Eintr√§ge aktualisiert und damit die alte Version als irrelevant markiert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/na/tr/tg/natrtgitck2f7ymtdalnr_coecu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schritt f√ºr Schritt, indem wir die Version der Zeilen aktualisieren und l√∂schen, erhalten wir eine Seite, auf der etwa die H√§lfte der Daten "M√ºll" ist. Diese Daten sind f√ºr keine Transaktion sichtbar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_j/8d/ji/_j8djifah3idpuohxwseop01xcw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres hat einen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">VACUUM-</font></a><font style="vertical-align: inherit;"> Mechanismus</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch irrelevante Versionen bereinigt und Speicherplatz f√ºr neue Daten frei wird. Wenn es jedoch nicht aggressiv genug konfiguriert ist oder in anderen Tabellen arbeitet, bleiben die ‚ÄûJunk-Daten‚Äú erhalten, und wir m√ºssen zus√§tzliche Seiten f√ºr neue Daten verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Beispiel besteht die Tabelle zu einem bestimmten Zeitpunkt aus vier Seiten, enth√§lt jedoch nur die H√§lfte der Live-Daten. Infolgedessen lesen wir beim Zugriff auf die Tabelle viel mehr Daten als erforderlich. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/ni/rn/nznirnw2kenpvkn7kv7hqwi1k08.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn VACUUM jetzt alle irrelevanten Versionen von Zeichenfolgen l√∂scht, wird sich die Situation nicht dramatisch verbessern. Wir haben freien Speicherplatz auf den Seiten oder sogar ganze Seiten f√ºr neue Zeilen, aber wir werden weiterhin mehr Daten als n√∂tig lesen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn sich √ºbrigens eine vollst√§ndig leere Seite (die zweite in unserem Beispiel) am Ende der Datei befindet, kann VACUUM sie zuschneiden. </font><font style="vertical-align: inherit;">Aber jetzt ist sie in der Mitte, also kann nichts mit ihr gemacht werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/ix/rq/fyixrqdxzpivbooplfjoqpeyc-q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Anzahl solcher leeren oder sehr flachen Seiten gro√ü wird, was als Aufbl√§hen bezeichnet wird, beginnt dies die Leistung zu beeintr√§chtigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was oben beschrieben wurde, ist die Mechanik des Auftretens von Aufbl√§hungen in Tabellen. </font><font style="vertical-align: inherit;">In Indizes geschieht dies √§hnlich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habe ich ein Aufbl√§hen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt verschiedene M√∂glichkeiten, um festzustellen, ob Sie eine Aufbl√§hung haben. Die Idee der ersten besteht darin, interne Postgres-Statistiken zu verwenden, die ungef√§hre Informationen √ºber die Anzahl der Zeilen in Tabellen, die Anzahl der "aktiven" Zeilen usw. enthalten. Im Internet finden Sie viele Variationen vorgefertigter Skripte. Wir haben ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von PostgreSQL Experts zugrunde gelegt, das Bloat-Tabellen zusammen mit Toast- und Bloat-Btree-Indizes auswerten kann. Nach unserer Erfahrung betr√§gt der Fehler 10-20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere M√∂glichkeit ist die Verwendung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgstattuple-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erweiterung </font><font style="vertical-align: inherit;">, mit der Sie in die Seiten schauen und sowohl gesch√§tzte als auch genaue Aufbl√§hungswerte erhalten k√∂nnen. Im zweiten Fall m√ºssen Sie jedoch die gesamte Tabelle scannen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einen kleinen Aufbl√§hungswert von bis zu 20% halten wir f√ºr akzeptabel. </font><font style="vertical-align: inherit;">Es kann als Analogon des F√ºllfaktors f√ºr </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indizes betrachtet werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bei 50% und mehr k√∂nnen Leistungsprobleme auftreten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂glichkeiten, mit Aufbl√§hen umzugehen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt verschiedene M√∂glichkeiten, mit dem Aufbl√§hen in Postgres umzugehen, aber sie sind bei weitem nicht immer f√ºr jeden geeignet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie AUTOVACUUM so ein, dass kein Aufbl√§hen auftritt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Und genauer gesagt, um es f√ºr Sie auf einem akzeptablen Niveau zu halten. Dies scheint der Rat eines Kapit√§ns zu sein, aber in Wirklichkeit ist dies nicht immer leicht zu erreichen. Beispielsweise entwickeln Sie sich aktiv mit regelm√§√üigen √Ñnderungen am Datenschema oder es findet eine Art Datenmigration statt. Infolgedessen kann sich Ihr Lastprofil h√§ufig √§ndern und in der Regel f√ºr verschiedene Tabellen unterschiedlich sein. Dies bedeutet, dass Sie st√§ndig ein St√ºck vor der Kurve arbeiten und AUTOVACUUM an das sich √§ndernde Profil jeder Tabelle anpassen m√ºssen. Es ist jedoch offensichtlich, dass dies nicht einfach ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer h√§ufiger Grund daf√ºr, dass AUTOVACUUM keine Zeit zum Verarbeiten von Tabellen hat, ist das Vorhandensein langwieriger Transaktionen, die verhindern, dass Daten gel√∂scht werden, da sie f√ºr diese Transaktionen verf√ºgbar sind. Die Empfehlung hier ist auch offensichtlich - beseitigen Sie h√§ngende Transaktionen und minimieren Sie die Zeit aktiver Transaktionen. Wenn die Last Ihrer Anwendung jedoch eine Mischung aus OLAP und OLTP ist, k√∂nnen Sie gleichzeitig viele h√§ufige Aktualisierungen und kurze Anforderungen sowie langwierige Vorg√§nge ausf√ºhren, z. B. das Erstellen eines Berichts. In einer solchen Situation lohnt es sich, √ºber eine Verteilung der Last auf verschiedene Basen nachzudenken, um eine feinere Abstimmung der einzelnen Basen zu erm√∂glichen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel: Selbst wenn das Profil einheitlich ist, die Datenbank jedoch sehr stark ausgelastet ist, kann es sein, dass selbst das aggressivste AUTOVACUUM nicht zurechtkommt und ein Aufbl√§hen auftritt. Die Skalierung (vertikal oder horizontal) ist die einzige L√∂sung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist mit der Situation, als Sie AUTOVACUUM konfiguriert haben, aber das Aufbl√§hen w√§chst weiter? </font><b><font style="vertical-align: inherit;">VACUUM FULL</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 
Befehl</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstellt den Inhalt von Tabellen und Indizes neu und bel√§sst nur relevante Daten darin. Um das Aufbl√§hen zu vermeiden, funktioniert es einwandfrei. W√§hrend der Ausf√ºhrung wird jedoch eine exklusive Sperre f√ºr die Tabelle (AccessExclusiveLock) erfasst, die keine Abfragen f√ºr diese Tabelle zul√§sst, selbst wenn diese ausgew√§hlt werden. Wenn Sie es sich leisten k√∂nnen, Ihren Dienst oder einen Teil davon f√ºr eine Weile einzustellen (von zehn Minuten bis zu mehreren Stunden, abh√§ngig von der Gr√∂√üe der Datenbank und Ihrer Hardware), ist diese Option die beste. Leider haben wir w√§hrend der geplanten Wartung keine Zeit, VACUUM FULL auszuf√ºhren, sodass diese Methode nicht zu uns passt. </font><b><font style="vertical-align: inherit;">CLUSTER-</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Befehl</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem wird der Inhalt von Tabellen neu erstellt, ebenso wie VACUUM FULL. Gleichzeitig k√∂nnen Sie den Index angeben, nach dem die Daten physisch auf der Festplatte sortiert werden (in Zukunft ist die Reihenfolge jedoch nicht garantiert). In bestimmten Situationen ist dies eine gute Optimierung f√ºr eine Reihe von Abfragen - mit dem Lesen mehrerer Datens√§tze nach Index. Der Nachteil des Befehls ist der gleiche wie der von VACUUM FULL - er sperrt die Tabelle w√§hrend des Betriebs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Befehl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REINDEX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √§hnelt den beiden vorherigen, erstellt jedoch einen bestimmten Index oder alle Indizes in der Tabelle neu. Sperren sind etwas schw√§cher: ShareLock f√ºr die Tabelle (verhindert √Ñnderungen, aber Sie k√∂nnen ausw√§hlen) und AccessExclusiveLock f√ºr den wiederherstellbaren Index (blockiert Anforderungen, die diesen Index verwenden). In Version 12 von Postgres jedoch der Parameter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONCURRENTLY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hiermit k√∂nnen Sie den Index neu erstellen, ohne das parallele Hinzuf√ºgen, √Ñndern oder L√∂schen von Datens√§tzen zu blockieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fr√ºheren Versionen von Postgres k√∂nnen Sie mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE INDEX CONCURRENTLY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein √§hnliches Ergebnis wie REINDEX CONCURRENTLY </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">erzielen</font></a><font style="vertical-align: inherit;"> . Sie k√∂nnen einen Index ohne strikte Blockierung erstellen (ShareUpdateExclusiveLock, der parallele Abfragen nicht beeintr√§chtigt), dann den alten Index durch einen neuen ersetzen und den alten Index l√∂schen. Dadurch werden aufgebl√§hte Indizes eliminiert, ohne Ihre Anwendung zu beeintr√§chtigen. Es ist wichtig zu ber√ºcksichtigen, dass beim Neuerstellen von Indizes das Festplattensubsystem zus√§tzlich belastet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es also M√∂glichkeiten f√ºr Indizes gibt, das Aufbl√§hen ‚Äûhei√ü‚Äú zu beseitigen, gibt es f√ºr Tabellen keine. Hier kommen verschiedene externe Erweiterungen ins </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Spiel</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_repack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(fr√ºher pg_reorg), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgcompact</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgcompacttable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und andere. </font><font style="vertical-align: inherit;">Im Rahmen dieses Artikels werde ich sie nicht vergleichen und nur √ºber pg_repack sprechen, das wir nach einiger Verfeinerung zu Hause verwenden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie pg_repack funktioniert</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5j/bp/ng/5jbpng5ietzdlekjqc32gdf_5cs.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben eine ganz normale Tabelle f√ºr uns - mit Indizes, Einschr√§nkungen und leider mit Aufbl√§hen. Der erste Schritt ist, dass pg_repack eine Protokolltabelle erstellt, in der Daten zu allen √Ñnderungen w√§hrend des Betriebs gespeichert werden. Der Trigger repliziert diese √Ñnderungen bei jedem Einf√ºgen, Aktualisieren und L√∂schen. Anschlie√üend wird eine Tabelle erstellt, die in ihrer Struktur dem Original √§hnelt, jedoch keine Indizes und Einschr√§nkungen aufweist, um das Einf√ºgen von Daten nicht zu verlangsamen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes √ºbertr√§gt pg_repack Daten von der alten in die neue Tabelle, filtert automatisch alle irrelevanten Zeilen und erstellt dann Indizes f√ºr die neue Tabelle. W√§hrend der Ausf√ºhrung all dieser Vorg√§nge werden √Ñnderungen in der Protokolltabelle gesammelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Schritt besteht darin, die √Ñnderungen in die neue Tabelle zu √ºbertragen. </font><font style="vertical-align: inherit;">Die Migration wird in mehreren Iterationen durchgef√ºhrt. Wenn weniger als 20 Eintr√§ge in der Protokolltabelle verbleiben, erfasst pg_repack eine strikte Sperre, √ºbertr√§gt die neuesten Daten und ersetzt die alte Tabelle durch die neue in den Postgres-Systemtabellen. </font><font style="vertical-align: inherit;">Dies ist der einzige und sehr kurze Zeitpunkt, an dem Sie nicht mit der Tabelle arbeiten k√∂nnen. </font><font style="vertical-align: inherit;">Danach werden die alte Tabelle und die Tabelle mit den Protokollen gel√∂scht und Speicherplatz im Dateisystem freigegeben. </font><font style="vertical-align: inherit;">Der Vorgang ist abgeschlossen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theoretisch sieht alles gut aus, was in der Praxis? </font><font style="vertical-align: inherit;">Wir haben pg_repack ohne Last getestet und unter Last die Funktion im Falle eines vorzeitigen Stopps √ºberpr√ºft (mit anderen Worten, Strg + C). </font><font style="vertical-align: inherit;">Alle Tests waren positiv. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gingen zum Produkt - und dann lief alles schief, wie wir es erwartet hatten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Pfannkuchen auf Prod</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim ersten Cluster wurde ein Fehler bez√ºglich der Verletzung einer eindeutigen Einschr√§nkung angezeigt:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span><font></font>
DETAIL:  Key (id, index)=(100500, 42) already exists.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Einschr√§nkung hatte den automatisch generierten Namen index_16508 - er wurde von pg_repack erstellt. </font><font style="vertical-align: inherit;">Durch die in seiner Zusammensetzung enthaltenen Attribute haben wir ‚Äûunsere‚Äú Einschr√§nkung bestimmt, die dieser entspricht. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies keine gew√∂hnliche Einschr√§nkung ist, sondern eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verz√∂gerte Einschr√§nkung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , d.h. </font><font style="vertical-align: inherit;">Die √úberpr√ºfung erfolgt sp√§ter als der Befehl sql, was zu unerwarteten Konsequenzen f√ºhrt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgeschobene Einschr√§nkungen: Warum werden sie ben√∂tigt und wie funktionieren sie?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bisschen Theorie √ºber verz√∂gerte Einschr√§nkungen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich ein einfaches Beispiel vor: Wir haben eine Fahrzeugreferenztabelle mit zwei Attributen - dem Namen und der Reihenfolge des Fahrzeugs im Verzeichnis.</font></font><br>
<img src="https://habrastorage.org/webt/n8/1s/td/n81stdw9kie5wll03ylnel18aie.png" align="right"><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> cars<font></font>
(<font></font>
  <span class="hljs-type">name</span> <span class="hljs-type">text</span> <span class="hljs-keyword">constraint</span> pk_cars <span class="hljs-keyword">primary key</span>,<font></font>
  ord <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> uk_cars <span class="hljs-keyword">unique</span><font></font>
);<font></font>
</code></pre><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir mussten das erste und das zweite Auto tauschen. </font><font style="vertical-align: inherit;">Die L√∂sung "in der Stirn" besteht darin, den ersten Wert auf den zweiten und den zweiten auf den ersten zu aktualisieren:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">begin</span>;
  <span class="hljs-keyword">update</span> cars <span class="hljs-keyword">set</span> ord = <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">'audi'</span>;
  <span class="hljs-keyword">update</span> cars <span class="hljs-keyword">set</span> ord = <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">'bmw'</span>;
<span class="hljs-keyword">commit</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Ausf√ºhrung dieses Codes wird jedoch eine Verletzung der Einschr√§nkung erwartet, da die Reihenfolge der Werte in der Tabelle eindeutig ist:</font></font><br>
<br>
<pre><code class="bash hljs">[23305] ERROR: duplicate key value violates unique constraint ‚Äúuk_cars‚Äù<font></font>
Detail: Key (ord)=(2) already exists.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie mache ich das anders? Option 1: F√ºgen Sie einen zus√§tzlichen Ersatz des Werts durch eine Bestellung hinzu, die garantiert nicht in der Tabelle vorhanden ist, z. B. "-1". In der Programmierung wird dies als "Austausch der Werte zweier Variablen durch die dritte" bezeichnet. Der einzige Nachteil dieser Methode ist das zus√§tzliche Update. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Option 2: Entwerfen Sie die Tabelle neu, um anstelle von Ganzzahlen einen Gleitkomma-Datentyp f√ºr den Auftragswert zu verwenden. Wenn Sie dann den Wert von beispielsweise 1 auf 2,5 aktualisieren, wird der erste Datensatz automatisch zwischen dem zweiten und dem dritten Datensatz "aufstehen". Diese L√∂sung funktioniert, es gibt jedoch zwei Einschr√§nkungen. Erstens funktioniert es f√ºr Sie nicht, wenn der Wert irgendwo in der Schnittstelle verwendet wird. Zweitens haben Sie abh√§ngig von der Genauigkeit des Datentyps eine begrenzte Anzahl m√∂glicher Einf√ºgungen, bevor Sie die Werte aller Datens√§tze neu berechnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Option 3: Verschieben Sie die Einschr√§nkung so, dass sie nur zum Zeitpunkt des Festschreibens √ºberpr√ºft wird:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> cars<font></font>
(<font></font>
  <span class="hljs-type">name</span> <span class="hljs-type">text</span> <span class="hljs-keyword">constraint</span> pk_cars <span class="hljs-keyword">primary key</span>,<font></font>
  ord <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> uk_cars <span class="hljs-keyword">unique</span> <span class="hljs-keyword">deferrable</span> <span class="hljs-keyword">initially</span> <span class="hljs-keyword">deferred</span>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Logik unserer ersten Anforderung sicherstellt, dass alle Werte zum Zeitpunkt des Festschreibens eindeutig sind, ist dies erfolgreich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das obige Beispiel ist nat√ºrlich sehr synthetisch, aber es zeigt die Idee. </font><font style="vertical-align: inherit;">In unserer Anwendung verwenden wir verz√∂gerte Einschr√§nkungen, um Logik zu implementieren, die f√ºr die L√∂sung von Konflikten verantwortlich ist, w√§hrend gleichzeitig mit allgemeinen Widget-Objekten auf der Karte gearbeitet wird. </font><font style="vertical-align: inherit;">Durch die Verwendung solcher Einschr√§nkungen k√∂nnen wir den Anwendungscode etwas vereinfachen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abh√§ngig von der Art der Einschr√§nkung in Postgres gibt es im Allgemeinen drei Granularit√§tsebenen, um sie zu √ºberpr√ºfen: Zeilenebene, Transaktion und Ausdruck. </font></font><br>
<img src="https://habrastorage.org/webt/vn/bw/qq/vnbwqqmhgjpnd7kb8dtxpixb8xi.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begriffs</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CHECK und NOT NULL werden immer auf Zeilenebene √ºberpr√ºft. F√ºr andere Einschr√§nkungen gibt es, wie aus der Tabelle hervorgeht, verschiedene Optionen. </font><font style="vertical-align: inherit;">Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz zusammengefasst ergeben ausstehende Einschr√§nkungen in einigen Situationen mehr lesbaren Code und weniger Befehle. </font><font style="vertical-align: inherit;">Sie m√ºssen dies jedoch bezahlen, indem Sie den Debug-Prozess komplizieren, da der Moment, in dem der Fehler aufgetreten ist und der Moment, in dem Sie davon erfahren, zeitlich getrennt sind. </font><font style="vertical-align: inherit;">Ein weiteres m√∂gliches Problem besteht darin, dass der Scheduler nicht immer den optimalen Plan erstellen kann, wenn die Anforderung eine verz√∂gerte Einschr√§nkung enth√§lt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verfeinerung pg_repack</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben herausgefunden, welche Einschr√§nkungen noch ausstehen, aber wie h√§ngen sie mit unserem Problem zusammen? </font><font style="vertical-align: inherit;">Erinnern Sie sich an den Fehler, den wir zuvor erhalten haben:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span>
DETAIL:  Key (id, index)=(100500, 42) already exists.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es tritt zum Zeitpunkt des Kopierens von Daten aus der Protokolltabelle in die neue Tabelle auf. Es sieht komisch aus, weil Die Daten in der Protokolltabelle werden zusammen mit den Daten in der Originaltabelle festgeschrieben. Wenn sie die Einschr√§nkungen der urspr√ºnglichen Tabelle erf√ºllen, wie k√∂nnen sie dann dieselben Einschr√§nkungen in der neuen Tabelle verletzen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie sich herausstellte, liegt die Wurzel des Problems im vorherigen Schritt von pg_repack, f√ºr den nur Indizes erstellt werden, jedoch keine Einschr√§nkungen: Die alte Tabelle hatte eine eindeutige Einschr√§nkung, und die neue Tabelle erstellte stattdessen einen eindeutigen Index.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_y/da/fc/_ydafcxizllawi1jo3o5ai-x-kg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierbei ist zu beachten, dass, wenn die Einschr√§nkung normal und nicht zur√ºckgestellt ist, der stattdessen erstellte eindeutige Index dieser Einschr√§nkung entspricht, da </font><font style="vertical-align: inherit;">Postgres-eindeutige Einschr√§nkungen werden durch Erstellen eines eindeutigen Index implementiert. </font><font style="vertical-align: inherit;">Im Fall einer verz√∂gerten Einschr√§nkung ist das Verhalten jedoch nicht dasselbe, da der Index nicht verz√∂gert werden kann und immer zum Zeitpunkt der Ausf√ºhrung des Befehls sql √ºberpr√ºft wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wesentliche des Problems liegt also in der ‚ÄûVerschiebung‚Äú der Pr√ºfung: In der urspr√ºnglichen Tabelle tritt sie zum Zeitpunkt des Festschreibens und in der neuen Tabelle zum Zeitpunkt der Ausf√ºhrung des Befehls sql auf. </font><font style="vertical-align: inherit;">Wir m√ºssen also sicherstellen, dass die √úberpr√ºfungen in beiden F√§llen auf die gleiche Weise durchgef√ºhrt werden: entweder immer zur√ºckgestellt oder immer sofort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Welche Ideen hatten wir?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen Index √§hnlich dem verz√∂gerten</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Idee besteht darin, beide √úberpr√ºfungen im Sofortmodus durchzuf√ºhren. Dies kann zu mehreren falsch positiven Ausl√∂sern der Einschr√§nkung f√ºhren. Wenn jedoch nur wenige davon vorhanden sind, sollte dies die Arbeit der Benutzer nicht beeintr√§chtigen, da solche Konflikte f√ºr sie eine normale Situation sind. Sie treten beispielsweise auf, wenn zwei Benutzer gleichzeitig dasselbe Widget bearbeiten und der Client des zweiten Benutzers keine Zeit hat, Informationen abzurufen, dass das Widget bereits f√ºr die Bearbeitung durch den ersten Benutzer gesperrt ist. In dieser Situation lehnt der Server den zweiten Benutzer ab, und sein Client setzt die √Ñnderungen zur√ºck und blockiert das Widget. Wenig sp√§ter, wenn der erste Benutzer die Bearbeitung beendet hat, erh√§lt der zweite Benutzer die Information, dass das Widget nicht mehr gesperrt ist, und kann seine Aktion wiederholen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dw/oq/jw/dwoqjwhuqva3veavihajfcd5t4c.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um sicherzustellen, dass sich die √úberpr√ºfungen immer im Notfallmodus befinden, haben wir einen neuen Index erstellt, der der urspr√ºnglichen verz√∂gerten Einschr√§nkung √§hnelt:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">CONCURRENTLY</span> uk_tablename__immediate <span class="hljs-keyword">ON</span> tablename (id, <span class="hljs-keyword">index</span>);
<span class="hljs-comment">-- run pg_repack</span>
<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">CONCURRENTLY</span> uk_tablename__immediate;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Testumgebung haben wir nur wenige erwartete Fehler erhalten. Erfolg! Wir haben pg_repack erneut auf dem Produkt gestartet und 5 Fehler im ersten Cluster innerhalb einer Arbeitsstunde erhalten. Dies ist ein akzeptables Ergebnis. Bereits im zweiten Cluster hat sich die Anzahl der Fehler jedoch um ein Vielfaches erh√∂ht, und wir mussten pg_repack stoppen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das geschehen? Die Wahrscheinlichkeit eines Fehlers h√§ngt davon ab, wie viele Benutzer gleichzeitig mit denselben Widgets arbeiten. Anscheinend gab es zu diesem Zeitpunkt mit den im ersten Cluster gespeicherten Daten viel weniger Wettbewerbs√§nderungen als im Rest, d. H. Wir hatten einfach "Gl√ºck". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee hat nicht funktioniert. In diesem Moment sahen wir zwei weitere L√∂sungsoptionen: Schreiben Sie unseren Anwendungscode neu, um ausstehende Einschr√§nkungen aufzuheben, oder ‚Äûlehren‚Äú Sie pg_repack, mit ihnen zu arbeiten. Wir haben die zweite gew√§hlt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen Sie Indizes in einer neuen Tabelle durch verz√∂gerte Einschr√§nkungen aus der Quelltabelle</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck der √úberarbeitung lag auf der Hand: Wenn die urspr√ºngliche Tabelle eine verz√∂gerte Einschr√§nkung aufweist, m√ºssen Sie f√ºr die neue Tabelle eine solche Einschr√§nkung erstellen, keinen Index. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um unsere √Ñnderungen zu testen, haben wir einen einfachen Test geschrieben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle mit aufgeschobener Einschr√§nkung und einem Datensatz;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie Daten in die Schleife ein, die mit dem vorhandenen Datensatz in Konflikt stehen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update durchf√ºhren - die Daten stehen nicht mehr in Konflikt;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver√§nderung begehen.</font></font></li>
</ul><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_table<font></font>
(<font></font>
  id <span class="hljs-type">serial</span>,<font></font>
  val <span class="hljs-type">int</span>,
  <span class="hljs-keyword">constraint</span> uk_test_table__val <span class="hljs-keyword">unique</span> (val) <span class="hljs-keyword">deferrable</span> <span class="hljs-keyword">initially</span> <span class="hljs-keyword">deferred</span> <font></font>
);<font></font>
</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table (val) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>);
<span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10000</span> <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>) <span class="hljs-keyword">RETURNING</span> id <span class="hljs-keyword">INTO</span> v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id;
    <span class="hljs-keyword">COMMIT</span>;
  <span class="hljs-keyword">END</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Originalversion von pg_repack st√ºrzte beim ersten Einf√ºgen immer ab, die √ºberarbeitete Version funktionierte fehlerfrei. </font><font style="vertical-align: inherit;">Fein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen zum Produkt und erhalten erneut einen Fehler in derselben Phase des Kopierens von Daten aus der Protokolltabelle in die neue:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span>
DETAIL:  Key (id, index)=(100500, 42) already exists.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassische Situation: Alles funktioniert in Testumgebungen, aber nicht auf Produkten ?!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APPLY_COUNT und die Verbindung zweier Chargen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir begannen, den Code buchst√§blich Zeile f√ºr Zeile zu analysieren und fanden einen wichtigen Punkt: Daten werden mit Stapeln von der Protokolltabelle in die neue √ºbertragen. Die Konstante APPLY_COUNT gab die Gr√∂√üe des Stapels an:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
num = apply_log(connection, table, APPLY_COUNT);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (num &gt; MIN_TUPLES_BEFORE_SWITCH)
     <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">/* there might be still some tuples, repeat. */</span><font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem besteht darin, dass die Daten der urspr√ºnglichen Transaktion, bei denen mehrere Vorg√§nge m√∂glicherweise gegen die Beschr√§nkung versto√üen k√∂nnen, w√§hrend der √úbertragung auf zwei Chargen √ºbertragen werden k√∂nnen - die H√§lfte der Teams wird im ersten Spiel und die andere H√§lfte im zweiten Spiel festgeschrieben. Und so viel Gl√ºck: Wenn die Teams in der ersten Partie nichts verletzen, ist alles in Ordnung, aber wenn sie verletzen, tritt ein Fehler auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APPLY_COUNT entspricht 1000 Eintr√§gen, was erkl√§rt, warum unsere Tests erfolgreich waren - sie deckten nicht den Fall der ‚ÄûVerbindung von Chargen‚Äú ab. Wir haben zwei Befehle verwendet - Einf√ºgen und Aktualisieren, sodass immer genau 500 Transaktionen von zwei Teams im Stapel platziert wurden und wir keine Probleme hatten. Nach dem Hinzuf√ºgen des zweiten Updates funktionierte unsere Bearbeitung nicht mehr:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10000</span> <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">RETURNING</span> id <span class="hljs-keyword">INTO</span> v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id; <span class="hljs-comment">-- one more update</span>
    <span class="hljs-keyword">COMMIT</span>;
  <span class="hljs-keyword">END</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die n√§chste Aufgabe besteht also darin, sicherzustellen, dass die Daten aus der Quelltabelle, die sich in einer Transaktion ge√§ndert haben, auch innerhalb derselben Transaktion in die neue Tabelle fallen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablehnung des Schlachtens</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wieder hatten wir zwei L√∂sungen. </font><font style="vertical-align: inherit;">Erstens: Lassen Sie uns die Stapelverarbeitung vollst√§ndig aufgeben und die Daten√ºbertragung in einer Transaktion durchf√ºhren. </font><font style="vertical-align: inherit;">F√ºr diese L√∂sung war ihre Einfachheit von Vorteil - die erforderlichen Code√§nderungen waren minimal (in √§lteren Versionen funktionierte pg_reorg √ºbrigens genau so). </font><font style="vertical-align: inherit;">Aber es gibt ein Problem - wir schaffen eine lange Transaktion, und dies ist, wie bereits gesagt, eine Bedrohung f√ºr die Entstehung eines neuen Aufbl√§hens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite L√∂sung ist komplizierter, aber wahrscheinlich korrekter: Erstellen Sie eine Spalte in der Protokolltabelle mit der Kennung der Transaktion, die die Daten zur Tabelle hinzugef√ºgt hat. Wenn wir dann Daten kopieren, k√∂nnen wir sie nach diesem Attribut gruppieren und sicherstellen, dass die zugeh√∂rigen √Ñnderungen zusammen √ºbertragen werden. Ein Stapel wird aus mehreren Transaktionen (oder einer gro√üen) gebildet und seine Gr√∂√üe h√§ngt davon ab, wie viele Daten sich in diesen Transaktionen ge√§ndert haben. Es ist wichtig zu beachten, dass, da die Daten verschiedener Transaktionen in zuf√§lliger Reihenfolge in die Protokolltabelle fallen, es nicht m√∂glich ist, sie wie zuvor nacheinander zu lesen. seqscan f√ºr jede von tx_id gefilterte Anfrage ist zu teuer. Sie ben√∂tigen einen Index, verlangsamen jedoch die Methode aufgrund des Aktualisierungsaufwands. Im Allgemeinen m√ºssen Sie wie immer etwas opfern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshalb haben wir uns entschlossen, mit der ersten Option zu beginnen, als einer einfacheren. Zun√§chst musste verstanden werden, ob eine lange Transaktion ein echtes Problem darstellt. Da die Hauptdaten√ºbertragung von der alten zur neuen Tabelle auch in einer langen Transaktion erfolgt, hat sich die Frage in "Wie viel werden wir diese Transaktion erh√∂hen?" Die Dauer der ersten Transaktion h√§ngt haupts√§chlich von der Gr√∂√üe der Tabelle ab. Die Dauer der neuen h√§ngt davon ab, wie viele √Ñnderungen sich w√§hrend der Daten√ºbertragung in der Tabelle ansammeln, d. H. von der Intensit√§t der Last. Der Lauf pg_repack trat w√§hrend der minimalen Auslastung des Dienstes auf, und der √Ñnderungsbetrag war im Vergleich zur urspr√ºnglichen Tabellengr√∂√üe unvergleichlich gering. Wir haben beschlossen, die Zeit der neuen Transaktion zu vernachl√§ssigen (zum Vergleich sind dies durchschnittlich 1 Stunde und 2-3 Minuten).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Experimente waren positiv. Laufen auch auf Prod. Aus Gr√ºnden der √úbersichtlichkeit ein Bild mit der Gr√∂√üe einer der Basen nach dem Lauf: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/ps/gu/z4psgu_s8jsbhwnxst2pogfcsfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da diese L√∂sung vollst√§ndig zu uns passte, haben wir nicht versucht, die zweite zu implementieren, sondern erw√§gen, sie mit den Entwicklern der Erweiterung zu diskutieren. Leider ist unsere aktuelle Version noch nicht zur Ver√∂ffentlichung bereit, da wir das Problem nur mit eindeutigen ausstehenden Einschr√§nkungen gel√∂st haben und f√ºr einen vollwertigen Patch andere Typen unterst√ºtzt werden m√ºssen. Wir hoffen, dies in Zukunft tun zu k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht haben Sie eine Frage, warum wir uns mit der Fertigstellung von pg_repack auf diese Geschichte eingelassen haben und zum Beispiel ihre Analoga nicht verwendet haben? </font><font style="vertical-align: inherit;">Irgendwann haben wir auch dar√ºber nachgedacht, aber die positive Erfahrung, es fr√ºher auf Tabellen ohne ausstehende Einschr√§nkungen zu verwenden, hat uns motiviert, zu versuchen, das Wesentliche des Problems zu verstehen und es zu beheben. </font><font style="vertical-align: inherit;">Um andere L√∂sungen zu verwenden, dauert es auch einige Zeit, um Tests durchzuf√ºhren. Daher haben wir beschlossen, zun√§chst zu versuchen, das Problem darin zu beheben. Wenn wir feststellen, dass wir dies nicht in angemessener Zeit tun k√∂nnen, werden wir Analoga in Betracht ziehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wir aufgrund unserer eigenen Erfahrung empfehlen k√∂nnen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberwachen Sie Ihr Aufbl√§hen. </font><font style="vertical-align: inherit;">Anhand der √úberwachungsdaten k√∂nnen Sie nachvollziehen, wie gut das Autovakuum konfiguriert ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie AUTOVACUUM so ein, dass das Aufbl√§hen auf einem vern√ºnftigen Niveau bleibt.</font></font></li>
<li>   bloat           ‚Äú ‚Äù,     .  ‚Äì   .</li>
<li>        ‚Äì        ,     .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499434/index.html">So implementieren Sie Wissensmanagement: Nutzen Sie ‚ÄûBeutel‚Äú, ‚ÄûPapageienstrafen‚Äú und Clip-Denken</a></li>
<li><a href="../de499436/index.html">Das ferngesteuerte Enzym beschleunigt die Behandlung von Schlaganf√§llen und Wirbels√§ulenverletzungen</a></li>
<li><a href="../de499438/index.html">Stream f√ºr Tester und nicht nur</a></li>
<li><a href="../de499440/index.html">Da haben wir den coolsten Autopiloten der Welt f√ºr eine Rangierlok geschrieben</a></li>
<li><a href="../de499442/index.html">Erstellen eines Pseudo-3D-Rennspiels: Implementieren der H√ºgel und Beenden des Spiels</a></li>
<li><a href="../de499446/index.html">Testen von Bootloadern im STEP-Format f√ºr VR</a></li>
<li><a href="../de499448/index.html">Implementierung von SOLID und Layered Architecture in Node.js mit TypeScript und InversifyJS</a></li>
<li><a href="../de499450/index.html">Auswahl der Ausr√ºstung f√ºr ein persisches Spiel unter Verwendung von Genetik / Evolution in Python</a></li>
<li><a href="../de499452/index.html">Alltag eines Augenarztes in der Klinik: Wenn √Ñrzte nicht genug sind</a></li>
<li><a href="../de499460/index.html">Parallelit√§t, Coroutinen, Ereignismaschinen, ... lebende Mathematik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>