<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèæ üõåüèΩ üìñ Problems and features of UEFI implementation on various platforms üëµüèº üëäüèΩ üö≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About nineteen years have passed since the release of the first EFI specification in the year 2000. It took the interface ten years to enter the user ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Problems and features of UEFI implementation on various platforms</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gaz-is/blog/493822/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About nineteen years have passed since the release of the first EFI specification in the year 2000. It took the interface ten years to enter the user market and gain a foothold on it. At the moment, rarely can you see a modern computer without UEFI in the firmware of the motherboard. The interface standard has increased the "meat" and several thousand pages in the official documentation. For the average user, nothing has changed, except for occasional collisions with Secure Boot enabled. But if the plane of work shifts to development, everything becomes more interesting.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1f/ek/as/1fekaswnox-diqt-hgzmaiqnq4g.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The very concept of the modular architecture of UEFI implies that these modules can not only be used in the standard configuration, but also download something of their own. A file system driver (not limited to native efi-shy FAT?), Peripheral drivers, applications, bootloaders - you can load everything by hand, it would be nice to load a bit of Shell. You can take a step "deeper" and look at the contents of the firmware, saving yourself from dancing with SecureBoot and the need to write a layer of scripts (there are enough articles on the pages of the hub).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On this basis, the idea was born of creating functional modules that perform various security functions before loading the OS, which can further unite and become a kind of integrated trusted boot environment affecting both services of the boot and runtime interface so that between the modules in the firmware and the modules on the disk nothing could be "pushed" without low-level intervention, and after them - only with the permission of the security administrator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implementation of this idea introduced us to a huge number of nuances and subtleties of UEFI - starting with many undocumented or poorly documented features, bugs, and ending with the undefined behavior so beloved by all developers. </font><font style="vertical-align: inherit;">Let's start in order.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platform Dependence</font></font></h4><br>
<img src="https://habrastorage.org/webt/wn/pz/1f/wnpz1fwi6hrqqhoogamysefkdic.png" width="770"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing you need to find out when integrating into the platform is whether we can work with it? The version of the UEFI specification is important, and on most devices it is presented in the range between 2.1 and 2.7. The newer has not yet hit the research stand. The older one is found, and its performance may be limited due to the lack of the necessary protocols or crookedly written drivers for their implementation. For example, UnicodeCollation is often not enough, when accessing smbios there are undocumented errors, the language change functions through SetVariable () do not work. Anything can happen, depending on the vendor and freshness, because sometimes you have to put your protocols even on relatively new boards.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even in our practice, I was lucky enough to stumble upon two mini-computers with Intel Bay Trail D and 32-bit firmware on board. The case is rare, but at one time it made it necessary to urgently recompile the modules. Actually, like the question: will we meet with a more modern platform of the same capacity in the future? And if we meet, then where?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next step is to determine how to integrate. The modules are built into the firmware, the firmware is located in the SPI chip on the board, and PCH with Intel ME is located nearby. And here the most interesting question arises - how to get there? Good old programmer with a "crocodile" - this is good, it is reliable. Even if you don‚Äôt catch on to the end, you can always look at the burning LEDs on the board, they have enough power from the programmer. It works almost flawlessly, with the exception of some older HP models, where mikruha SOIC-16 with firmware is so accessible that it‚Äôs easier to contrive and solder the adapter to her legs than to squeeze the clip. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/uu/ce/6b/uuce6bumbvwdovmxow0ntfoeynm.png" width="770"><br>
<img src="https://habrastorage.org/webt/qj/kf/k1/qjkfk14esp5_ol1vchn8fkaiwt4.png" width="770"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know that there are people on Habr√© who have contributed to the writing of flashrom, thanks to them separately.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But, despite the reliability and reliability of dump removal by the programmer, this method is not suitable if you need to install something in UEFI on several machines, or if the target platform for installation is not on your desk. Fortunately for us, manufacturers left behind native firmware utilities: FPT (Flash programming tool) from Intel (CS) ME System Tools, and AFU (AMI Firmware Update) for Aptio from American Megatrends. These utilities are launched both from the EFI environment and from the Windows, Linux, and DOS operating systems. The utilities are somewhat interchangeable, both allow you to consider the image, if not the whole, then certain regions for sure. And sometimes they even let you write back. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/hk/vz/pp/hkvzppckxwb02epv3ieytikh5y0.png" width="770"><br>
<img src="https://habrastorage.org/webt/we/qx/3y/weqx3ysvpinegiv9gxh9biw7xdg.png" width="770"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He writes and does not write</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is where the first serious stumbling block on the path of integration appears. Not all motherboards allow you to read the entire firmware, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banning access</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the ME region (ME is almost sacred, Intel will not allow it to be read in a good way, but </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a bad way</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we don‚Äôt always want to). Even less - pour something even into the BIOS region, unless it is a signed capsule. The likelihood of success varies greatly depending on the manufacturer and the freshness of the chipset. On some models of motherboards, you can observe a funny picture: that which was not recorded on the old vendor boards, flies at new times. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sometimes </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">IFR parser</font></a><font style="vertical-align: inherit;"> helps fight write protection</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which opens the curtain on hidden settings and variables. </font><font style="vertical-align: inherit;">And sometimes only a hardcore jumper helps, allowing access to the recording or "turning off" ME (if one is provided, of course).</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The complex nature of systems</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Acer, Asus, AsRock, and Gigabyte boards in most cases are written without unnecessary difficulties. </font><font style="vertical-align: inherit;">Intel, HP and server hardware stand apart. </font><font style="vertical-align: inherit;">HP not only does not allow writing in itself programmatically, it also swears at any attempt to modify the firmware (in</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CodeRush</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there are </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on finding and disabling integrity checking). Intel more or less recorded up to the 87th chipset, then it became deaf to requests to open the gates of the BIOS region. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With Intel, the first time was funny. The modules were imported into the firmware using the UEFITool utility, and we came across an interesting bug: if you insert ffs modules at the end of the DXE volume, after all freeforms, then the assembled image ‚Äúbricked‚Äù the board. The solution was to add modules after any native DXE driver. We did not immediately get to this, and at first it looked like Intel was monitoring the integrity of the firmware, like HP. Later it became clear that one could not do without an automatic utility for importing modules, and the problem came to naught after writing it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Server-side hardware is simpler and more complex at the same time. On the one hand, there are always additional ways to update and modify BIOSes on servers, on the other hand, the volume of customization in these same BIOSes is overwhelming, since they don‚Äôt skimp on servers and install quite capacious flash memory chips, often also backing them up. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When installing on a server, it is always nice to be able to remotely update the BIOS via IPMI. True, for this in a good way you need a license, of course paid. If it does not appear at the right time, it is quite possible to get into a funny situation similar to the one we got by introducing modules into the Supermicro server BIOS.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the introduction of the modules, the load freezes tightly due to blocking by one of the security modules (they did not take into account the waywardness of the server BIOSs, with whom it does not happen!). In the absence of the ability to force the BIOS to be rolled back through IPMI, the hand itself reached for the programmer, but it was a bad luck - the standard SOIC-8 clip was not enough for a SOIC-16 chip! Well, okay, because in theory the server board has the ability to backup from the connected media, picking up the SUPER.ROM image in the root. But this mechanism does not start, because according to the system everything is OK, everything works, therefore, the BIOS rollback is not needed! What to do?! .. The story ended up running around the city in search of the right clip, an emergency re-soldering of wires, smeared by the Chinese in an incomprehensible order for us, and finally - a flashing.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lenovo came out even more interesting. On the switches received from the vendor, under the cover of the case, a control board was found with two ‚Äúmikruhs‚Äù for firmware, with an SSD for OSes and with a fixed battery. The BIOS turned out to be a tough nut, I didn‚Äôt want to eat a modified image in any way, succumbing only to the programmer. In one of the attempts to write something down, they inserted a flash drive with console ubuntu into the switch (the terminal did not give out graphics) and booted quite safely. Having done what was required, they turned off the system using the halt -p command from the old memory. The switch, by its nature not adapted for any shutdown, except for the lack of power, was not ready for this and did not want to start anymore. The link on the face burned through once, the fans rustled quietly, and all the ports gave out nothing. Re-flashing did not help,the battery sat like a glove - we were afraid to break the mount. As a result, a thin dielectric plate crawled under the force of perseverance and verbal inspiration under the contacts, the volatile memory was erased, the switch came to life.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The study of dumps taken from two chips showed a lot of interesting things. In particular, a huge number of "Invalid" entries in the NVRAM of the main firmware and several similar ones in the backup. Well, and not a previously encountered data hash in the volume with DXE drivers. One could only guess about the exact cause of the problem of starting the switch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the software part is rarely deprived of its unexpected nuances. Many motherboards that came to us before the 87th chipset (from different manufacturers) have an unpleasant feature to produce an endless stream of errors when entering the ‚Äúdh -v‚Äù command in the shell console. With manual entry, this is not critical, but when collecting data into a file, it ends in an unfortunate hang. In both cases, you have to restart the machine. I am glad that at the same time the data file does not swell to immense sizes.</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/z-/rr/_k/z-rr_k9f6o7pmt_ezbza-ysrjzw.png" width="770"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kraftway BIOS with ASRock H81M-DGS board proved to be very wayward. So, it responds to Ctrl Alt Del Del by hanging, from which only Reset can output it. There were problems with skipping the startup script &lt;startup.nsh&gt; in Shell'e - a split second to choose from instead of five default ones. Perhaps these problems are caused by the modification by the KSS proprietary modules, perhaps the matter is inaccurately ‚Äúunscrewed‚Äù ME.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the Asus H97-PLUS board, the firmware has the following feature - BootOrder overflows over time. Most likely, the reason lies in the errors in the code. Although, perhaps, the manufacturer wanted to keep all the boot devices that were ever connected in the board, but did not calculate that there could be more than a dozen in one day. So, when BootOrder overflows, the system hangs during the boot process. To clean it, you must turn off all boot devices and turn on the system. The firmware clears itself and the system boots directly into the BIOS Setup shell. Performance remains until the next overflow.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Summarizing the experience of working with boards of various vendors, you come to the conclusion that it is almost impossible to find out what surprises at the EFI level you will deal with on the next board, even if it already has a well-known model. </font><font style="vertical-align: inherit;">This is a kind of lottery, because sometimes difficulties may arise at the stage of collecting information about the system. </font><font style="vertical-align: inherit;">Perhaps this has a share of unquenchable research idealism and faith in the manufacturer, because how else could some of the freshest motherboards with ME v11 and v12 hang when running FPT or MEInfo of older versions on them?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems of work with hardware protocols</font></font></h4><br>
<img src="https://habrastorage.org/webt/j2/yo/ze/j2yozeg6zdyfa--juz_ycvvobbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some problems pop up when we start working with USB devices - drives and tokens. This happens often because the BIOS code for working with peripherals is a dangerous cocktail of drivers and applications from Independent Hardware Vendor (IHV) for a specific peripheral, code from the chipset manufacturer (in our case, from Intel), code from the BIOS manufacturer and code from the manufacturer of the motherboard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following ‚Äúinteresting‚Äù situations </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
arose </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Token ‚Äúnot detected‚Äù. At the same time, an LED is lit on it. Most likely, the host controller does not go through the initial reset procedure of the USB device, that is, the power is supplied, but the reset through changing the D + and D- lines does not work correctly, and without it, any further manipulations with the token are meaningless.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The computer freezes before loading the shell (again, with a token connected). In this case, without a token, the PC starts normally. Live, it looks like this: the computer seems to crash right after the start, while the token sticks out in the connector. You take it out - loading suddenly continues. Connect - hanging again. The obvious problem is in UEFI, and one can only speculate about the reasons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The situation when it is not possible to open the USB_IO interface. Perhaps it is connected only with the interface for working with smart cards - USB CCID. Some AMI driver has already opened USB_IO with the EFI_OPEN_PROTOCOL_BY_DRIVER parameter. The driver has a protocol with a GUID:</font></font><br>
<br>
<pre><code class="plaintext hljs">#define EFI_AMI_USB_CCID_PROTOCOL_GUID	 { 0x5FDEE00D, 0xDA40, 0x405A, { 0xB9, 0x2E, 0xCF, 0x4A, 0x80, 0xEA, 0x8F, 0x76} }<font></font>
 // Workaround.      EFI_OPEN_PROTOCOL_BY_DRIVER,  ,     EFI_OPEN_PROTOCOL_GET_PROTOCOL.<font></font>
 //<font></font>
 // Open USB I/O Protocol<font></font>
 //<font></font>
 Status = gBS-&gt;OpenProtocol (<font></font>
 ControllerHandle,<font></font>
 &amp;gEfiUsbIoProtocolGuid,<font></font>
 (VOID **) &amp;UsbIo,<font></font>
 This-&gt;DriverBindingHandle,<font></font>
 ControllerHandle,<font></font>
 EFI_OPEN_PROTOCOL_BY_DRIVER<font></font>
 );<font></font>
<font></font>
 if (EFI_ACCESS_DENIED == Status)<font></font>
 {		// AMI BIOS workaround (BindingStop will not be invoked)<font></font>
	 Status = gBS-&gt;OpenProtocol(<font></font>
		 ControllerHandle,<font></font>
		 &amp;gEfiUsbIoProtocolGuid,<font></font>
		 (VOID **)&amp;UsbIo,<font></font>
		 This-&gt;DriverBindingHandle,<font></font>
		 ControllerHandle,<font></font>
		 EFI_OPEN_PROTOCOL_GET_PROTOCOL<font></font>
	 );<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, BindingStop () will not be called, i.e. the device extraction event is not monitored, and the driver will try to use invalid handle. This was observed with the HP Compaq Elite 8300 SFF PC and some others. This is either a kind of vendor protection from unwanted drivers, or a regular development bug. Perhaps AMI is constantly doing something in the direction of USB CCID, but the interfering driver cannot be unloaded, since it is located in the same AMI UHCI module along with USB HID, USB MassStorage. With UninstallInterface (), things are similar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Or another interesting feature. In one of the UEFI BIOS, where the token was not detected, USB_IO allowed to read the device descriptors, but EFI_INVALID_PARAMETER returned to the next UsbBulkTransfer (). Moreover, this happened only with some types of tokens, with absolutely the same parameters, others worked perfectly.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the protocol UsbBulkTransfer () is interestingly implemented in the EFI_USB_IO_PROTOCOL protocol. </font><font style="vertical-align: inherit;">It is intended for guaranteed package delivery for an unlimited time, or for the time specified in the Timeout parameter. </font><font style="vertical-align: inherit;">But an experiment was conducted with a MassStorage device: when copying a large file to a USB flash drive, it was removed. </font><font style="vertical-align: inherit;">PC hangs tight. </font><font style="vertical-align: inherit;">When connecting the USB flash drive, the PC sagged and continued to write the file as if nothing had happened. </font><font style="vertical-align: inherit;">The same situation was with tokens, but with its own specifics. </font><font style="vertical-align: inherit;">This is an architectural problem, in EFI there are no interrupts except a timer, and the devices operate according to a poll. </font><font style="vertical-align: inherit;">That is, the system crashed somewhere in the USB poll, but did not reach the timeout, when the device reappeared, it simply continued and completed the operation.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtualization</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We should also say about virtual environments. Currently there are two main platforms on the market that support emulation of the EFI environment: VMware and VirtualBox. Both have their advantages and disadvantages when interacting with them as with ‚Äúreal‚Äù systems. The VMware environment adequately provides work with NVRAM variables, but stumbles when displaying messages visually during the initialization of DXE modules: in the best case, preference will be given to native messages about finding bootable media, leaving behind what we need. VirtualBox, on the contrary, perfectly renders everything required, but does not want to remember long variables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another small stone in the VMware garden - the FAT32 driver built into it supports the creation and editing of files only in 8.3 notation. </font><font style="vertical-align: inherit;">It is not clear why this was done, but this is a limitation that clearly requires attention. </font><font style="vertical-align: inherit;">It is likely that a similar implementation of the driver can be observed on real platforms, but so far we have not come across those. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, in virtual machines there are no dances with firmware utilities, programmers, jumpers, uncomfortable chips. </font><font style="vertical-align: inherit;">A separate ROM file, UEFITool and a line in the config file. </font><font style="vertical-align: inherit;">Almost an idyll.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end</font></font></h4><br>
<img src="https://habrastorage.org/webt/cb/qg/va/cbqgvany9ens-l7ippxwgzox9co.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A slice of the request from CHIPSEC. </font><font style="vertical-align: inherit;">Where do they teach such sacraments? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As already mentioned, the development and implementation in the UEFI shell is a fascinating and creative process. </font><font style="vertical-align: inherit;">You can always come across something new even on a famous field. </font><font style="vertical-align: inherit;">On the one hand, it is encouraging that the standard is developing, on the other, it is saddening that concrete implementations of it by the producers are too ‚Äúcreative‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main problems were and remain:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Departure of vendors from the UEFI specification when developing firmware.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Errors in the code during implementation.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NDV in code, pop-up during integration.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And last, but not least, the absence of many things in the official (read, open) documentation, such as, for example, descriptions of the protocol for communicating with ME via PCI devices like MEI, HECI. </font><font style="vertical-align: inherit;">You can find a description of the registers, but not the commands. </font><font style="vertical-align: inherit;">Find a GUID, but not its purpose. </font><font style="vertical-align: inherit;">Which once again returns the work to a long analysis, collecting data and statistics on platforms and using the disassembler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be noted that the situation is slowly but surely correcting, and I want to believe that the moment is not far off when the development of the standard will become a fairly predictable and very pleasant process. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Onipchuk, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Head of the group of hardware and software protection products of </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gazinformservice LLC</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en493810/index.html">Five years of intensive development of the market for document recognition</a></li>
<li><a href="../en493814/index.html">How we conduct interviews in Barcelona</a></li>
<li><a href="../en493816/index.html">Git Guide Part number 1: everything you need to know about the .git directory</a></li>
<li><a href="../en493818/index.html">Git Guide Part number 2: the golden rule and other basics of rebase</a></li>
<li><a href="../en493820/index.html">Kubernetes load balancing and scaling long-lived connections</a></li>
<li><a href="../en493826/index.html">Divide and conquer: improving the electrolysis of water</a></li>
<li><a href="../en493828/index.html">How the interface tells stories in video games</a></li>
<li><a href="../en493830/index.html">What questions are asked by Junior iOS developer at the first interviews</a></li>
<li><a href="../en493832/index.html">Coronavirus COVID-19 Distribution Dashboard (React + Chart.js + BootstrapTable)</a></li>
<li><a href="../en493840/index.html">Reviews: Asana, Jira, Bitrix-24, Trello, YouGile. What do you like and what infuriates?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>