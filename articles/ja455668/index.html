<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 👩🏻 🍅 HDLなしのFPGAで記述します。高レベル開発ツールの比較 👃🏼 💇🏽 ▪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近、FPGAメーカーとサードパーティ企業は、高レベルの開発ツールを使用する従来のアプローチとは異なるFPGAの開発方法を積極的に開発しています。
 
 FPGA開発者として、私はVerilogのハードウェア記述言語（HDL）をメインツールとして使用していますが、新しい方法の人気の高まりが私の興味を...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HDLなしのFPGAで記述します。高レベル開発ツールの比較</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近、FPGAメーカーとサードパーティ企業は、高レベルの開発ツールを使用する従来のアプローチとは異なるFPGAの開発方法を積極的に開発しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGA開発者として、私は</font><font style="vertical-align: inherit;">Verilogの</font><font style="vertical-align: inherit;">ハードウェア記述言語（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HDL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">をメインツールとして使用しています</font><font style="vertical-align: inherit;">が、新しい方法の人気の高まりが私の興味をそそりました。そのため、この記事で何が起こっているのかを理解することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、使用のためのガイドや説明ではありません。これは、FPGAの世界に飛び込もうとするFPGA開発者またはプログラマーにさまざまな高レベル開発ツールが与えることができるものについての私のレビューと結論です。</font><font style="vertical-align: inherit;">私の意見で最も興味深い開発ツールを比較するために、いくつかのテストを作成し、結果を分析しました。</font><font style="vertical-align: inherit;">カットの下-それから来たもの。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGAに高レベルの開発ツールが必要なのはなぜですか？</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの開発を加速するために</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -高級言語ですでに書かれたコードを再利用することによって; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ゼロからコードを作成する場合、高水準言語のすべての利点を使用する。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -コンパイル時間とコード検証を削減します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のFPGAファミリで機能するユニバーサルコードを作成する機能。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、「クロック周波数」やその他の低レベルエンティティの概念を回避して、FPGAの開発しきい値を削減します。</font><font style="vertical-align: inherit;">HDLに精通していない開発者にFPGAのコードを書く能力。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高レベルの開発ツールはどこから来るのですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 今では多くの人が高度な開発のアイデアに惹かれています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quokka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonコードジェネレーター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの愛好家と、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mathworks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの企業</font><font style="vertical-align: inherit;">、およびFPGAメーカーである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ザイリンクスは、</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
それぞれ独自の方法とツールを使用してこれを実現しています。完璧で美しい世界を求めて闘う熱狂者は、PythonやC＃などのお気に入りの開発言語を使用します。企業は、クライアントを満足させるために、独自のツールを提供するか、既存のツールを適応させます。 Mathworksは、mスクリプトとSimulinkモデルからHDLコードを生成するための独自のHDLコーダーツールを提供しています。一方、インテルとザイリンクスは、一般的なC / C ++用のコンパイラーを提供しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、重要な財政的および人的資源を持つ企業はより大きな成功を収めていますが、愛好家はやや遅れています。</font><font style="vertical-align: inherit;">この記事では、Mathworksの製品HDLコーダーとIntelのHLSコンパイラについて考察します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ザイリンクスはどうですか</font></font></b><div class="spoiler_text">      HLS  Xilinx,       Intel  Xilinx,       .   ,  Xilinx HLS,   Intel HLS,   C/C++    .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MathworksとIntel HLSコンパイラーのHDLコーダーを比較してみましょう。さまざまなアプローチを使用していくつかの問題を解決しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高レベル開発ツールの比較</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つをテストします。</font><font style="vertical-align: inherit;">「2つの乗算器と1つの加算器」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 この問題の解決策には実用的な価値はありませんが、最初のテストとして適しています。</font><font style="vertical-align: inherit;">この関数は4つのパラメーターを受け取り、最初のパラメーターを2番目のパラメーターと乗算し、3番目のパラメーターを4番目のパラメーターと乗算し、乗算の結果を加算します。</font><font style="vertical-align: inherit;">何も複雑ではありませんが、被験者がこれにどう対処するか見てみましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MathworksによるHDLコーダー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、mスクリプトは次のようになります。</font></font><br>
<br>
<pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[out]</span> = <span class="hljs-title">TwoMultAdd</span><span class="hljs-params">(a,b,c,d)</span></span><font></font>
    out = (a*b)+(c*d);<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 MathworksがコードをHDLに変換するために提供するものを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はHDLコーダーでの作業を詳細に検討するつもりはありません。FPGAで異なる結果を得るために将来変更する設定にのみ焦点を当て、FPGAでコードを実行する必要があるMATLABプログラマーがその変更を考慮する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初に行うことは、入力値のタイプと範囲を設定することです。 FPGAにはおなじみのchar、int、float、doubleはありません。数のビット深度は任意ですが、使用する予定の入力値の範囲に基づいて選択することが論理的です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真1</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MATLABは変数のタイプとその値をチェックし、バスとレジスターの正しいビット深度を選択します。これは本当に便利です。ビット深度とタイピングに問題がない場合は、次のポイントに進むことができます。</font><i><font style="vertical-align: inherit;">図2</font></i><font style="vertical-align: inherit;"> 
HDLコード生成にはいくつかのタブがあり、変換する言語（VerilogまたはVHDL）を選択できます。コードスタイル信号の名前。私の意見では、最も興味深いタブは最適化であり、私はそれを実験しますが、後で、今のところ、すべてをデフォルトのままにして、「そのまま」のHDLコーダーで何が起こるかを見てみましょう。</font><font style="vertical-align: inherit;">
実行ボタンを押して、次のコードを取得します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="画像"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">`timescale 1 ns / 1 ns<font></font>
<font></font>
module TwoMultAdd_fixpt<font></font>
          (a,<font></font>
           b,<font></font>
           c,<font></font>
           d,<font></font>
           out);<font></font>
<font></font>
  input   [7:0] a;  // ufix8<font></font>
  input   [7:0] b;  // ufix8<font></font>
  input   [7:0] c;  // ufix8<font></font>
  input   [7:0] d;  // ufix8<font></font>
  output  [16:0] out;  // ufix17<font></font>
<font></font>
  wire [15:0] TwoMultAdd_fixpt_mul_temp;  // ufix16<font></font>
  wire [16:0] TwoMultAdd_fixpt_2;  // ufix17<font></font>
  wire [15:0] TwoMultAdd_fixpt_mul_temp_1;  // ufix16<font></font>
  wire [16:0] TwoMultAdd_fixpt_3;  // ufix17<font></font>
<font></font>
<font></font>
  //HDL code generation from MATLAB function: TwoMultAdd_fixpt<font></font>
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<font></font>
  //                                                                          %<font></font>
  //           Generated by MATLAB 9.2 and Fixed-Point Designer 5.4           %<font></font>
  //                                                                          %<font></font>
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<font></font>
  assign TwoMultAdd_fixpt_mul_temp = a * b;<font></font>
  assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp};<font></font>
  assign TwoMultAdd_fixpt_mul_temp_1 = c * d;<font></font>
  assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1};<font></font>
  assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3;<font></font>
<font></font>
endmodule  // TwoMultAdd_fixpt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードはよさそうだ。 MATLABは、式全体をVerilogの単一行に書き込むことは悪い習慣であることを理解しています。</font><font style="vertical-align: inherit;">乗算器と加算器に</font><font style="vertical-align: inherit;">個別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイヤ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成します</font><font style="vertical-align: inherit;">。不満はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスターの記述が欠落していることは憂慮すべきことです。これは、これについてHDL-coderに問い合わせず、設定のすべてのフィールドをデフォルト値のままにしたために発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、Quartusがそのようなコードから合成するものです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
問題はありません。すべてが計画どおりでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGAには同期回路を実装していますが、それでもレジスタを確認したいと思います。 HDL-coderはレジスタを配置するためのメカニズムを提供しますが、それらを配置する場所は開発者次第です。乗算器の入力、乗算器の出力、加算器の前、または加算器の出力にレジスタを配置できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を合成するために、FPGA Cyclone Vファミリを選択しました。ここでは、加算器と乗算器が組み込まれた特別なDSPブロックを使用して、算術演算を実装しています。 DSPブロックは次のようになります。</font><i><font style="vertical-align: inherit;">図4</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DSPブロックには入力レジスタと出力レジスタがあります。加算の前にレジスターで乗算の結果をスナップする必要はありません。これはアーキテクチャーに違反するだけです（特定のケースでは、このオプションは可能であり、さらには必要です）。レイテンシ要件と必要な最大周波数に基づいて、入力レジスタと出力レジスタの処理方法を決定するのは開発者の責任です。出力レジスタのみを使用することにしました。このレジスターをHDL-coderによって生成されたコードで記述するためには、HDL coderの[Options]タブで、[Register output]チェックボックスをオンにして変換を再開する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードがわかります。</font></font><br>
<br>
<pre><code class="plaintext hljs">`timescale 1 ns / 1 ns<font></font>
<font></font>
module TwoMultAdd_fixpt<font></font>
          (clk,<font></font>
           reset,<font></font>
           clke_ena_i,<font></font>
           a,<font></font>
           b,<font></font>
           c,<font></font>
           d,<font></font>
           clke_ena_o,<font></font>
           out);<font></font>
<font></font>
  input   clk;<font></font>
  input   reset;<font></font>
  input   clke_ena_i;<font></font>
  input   [7:0] a;  // ufix8<font></font>
  input   [7:0] b;  // ufix8<font></font>
  input   [7:0] c;  // ufix8<font></font>
  input   [7:0] d;  // ufix8<font></font>
  output  clke_ena_o;<font></font>
  output  [16:0] out;  // ufix17<font></font>
<font></font>
  wire enb;<font></font>
  wire [16:0] out_1;  // ufix17<font></font>
  wire [15:0] TwoMultAdd_fixpt_mul_temp;  // ufix16<font></font>
  wire [16:0] TwoMultAdd_fixpt_2;  // ufix17<font></font>
  wire [15:0] TwoMultAdd_fixpt_mul_temp_1;  // ufix16<font></font>
  wire [16:0] TwoMultAdd_fixpt_3;  // ufix17<font></font>
  reg [16:0] out_2;  // ufix17<font></font>
<font></font>
  //HDL code generation from MATLAB function: TwoMultAdd_fixpt<font></font>
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<font></font>
  //                                                                          %<font></font>
  //           Generated by MATLAB 9.2 and Fixed-Point Designer 5.4           %<font></font>
  //                                                                          %<font></font>
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<font></font>
  assign TwoMultAdd_fixpt_mul_temp = a * b;<font></font>
  assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp};<font></font>
  assign TwoMultAdd_fixpt_mul_temp_1 = c * d;<font></font>
  assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1};<font></font>
  assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3;<font></font>
<font></font>
  assign enb = clke_ena_i;<font></font>
<font></font>
  always @(posedge clk or posedge reset)<font></font>
    begin : out_reg_process<font></font>
      if (reset == 1'b1) begin<font></font>
        out_2 &lt;= 17'b00000000000000000;<font></font>
      end<font></font>
      else begin<font></font>
        if (enb) begin<font></font>
          out_2 &lt;= out_1;<font></font>
        end<font></font>
      end<font></font>
    end<font></font>
<font></font>
  assign clke_ena_o = clke_ena_i;<font></font>
  assign out = out_2;<font></font>
endmodule  // TwoMultAdd_fixpt<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ご覧のとおり、コードには前のバージョンとは根本的な違いがあります。レジスタの説明であるalways-blockが表示されました（まさに私たちが欲しかったものです）。 always-blockオペレーションでは、clkモジュール（クロック周波数）とリセット（リセット）の入力も表示されました。加算器の出力が常に説明されているトリガーにラッチされていることがわかります。 enaの許可信号もいくつかありますが、私たちにはあまり興味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quartusが現在合成している図を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
繰り返しになりますが、結果は良好で期待どおりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の表は、使用されているリソースの表を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図6</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この最初の割り当てでは、Mathworksがクレジットを受け取ります。すべてが複雑ではなく、予測可能であり、望ましい結果が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例を詳細に説明し、DSPブロックの図を示し、「デフォルト」設定とは異なるHDL-coderのレジスタ使用設定を使用する可能性について説明しました。</font><font style="vertical-align: inherit;">これには理由があります。</font><font style="vertical-align: inherit;">これにより、このような簡単な例でも、HDLコーダーを使用する場合は、FPGAアーキテクチャとデジタル回路の基礎についての知識が必要であり、設定を意識的に変更する必要があることを強調しておきました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インテルHLSコンパイラー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++で記述された同じ機能を使用してコードをコンパイルし、HLSコンパイラを使用してFPGAで最終的に何が合成されるかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だからC ++コード</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">component <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TwoMultAdd</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> d)</span>
</span>{
	<span class="hljs-keyword">return</span> (a*b)+(c*d);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数がオーバーフローしないようにデータ型を選択しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビット深度を設定するための高度な方法がありますが、私たちの目標は、変更を加えずに、C / C ++スタイルで記述された関数をFPGAでアセンブルする機能をすべてそのままでテストすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSコンパイラはIntelのネイティブツールであるため、特別なコンパイラを使用してコードを収集し、結果をQuartusですぐに確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quartusが合成する回路を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コンパイラは入力および出力レジスタを作成しましたが、本質はラッパーモジュールに隠されています。ラッパーのデプロイを開始すると、ネストされたモジュールがますます多く表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの構造は次のようになります。</font><i><font style="vertical-align: inherit;">図8</font></i><font style="vertical-align: inherit;"> 
インテルから</font><i><font style="vertical-align: inherit;">の</font></i><font style="vertical-align: inherit;">明らかなヒント：「手に入れないでください！」ただし、特に機能は複雑ではありません。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトツリーの深さで| quartus_compile | TwoMultAdd：TwoMultAdd_inst | TwoMultAdd_internal：twomultadd_internal_inst | TwoMultAdd_fu </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nction_wrapper：TwoMultAdd_internal | TwoMultAdd_function：theTwoMultAdd_function | bb_TwoMultAdd_B1_start：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region：thebb_TwoMultAdd_B1_start_stall_region |私</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
_sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd：thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13：thei_sfc_logic_c1_wt_entry_twom </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ultadd_c1_enter_twomultadd13_aunroll_x | MULT1はモジュールが望まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quartusによって合成された目的のモジュールの図を見ることができます。</font><i><font style="vertical-align: inherit;">図9</font></i><font style="vertical-align: inherit;"> 
このスキームからどのような結論を導き出すことができるか。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MATLABで作業するときに回避しようとした何かが起こったことがわかります。乗算器の出力のケースが合成されました-これはあまり良くありません。 DSPブロック図（図4）からわかるように、その出力にはレジスタが1つしかありません。つまり、各乗算は個別のブロックで実行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用されたリソースの表は、これが何をもたらすかを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図10</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
結果をHDLコーダーテーブルと比較します（図6）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我慢できる多数のレジスタを使用する場合、そのような単純な機能に貴重なDSPブロックを費やすことは非常に不愉快です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、HDLコーダーと比較してIntel HLSには大きなプラスがあります。</font><font style="vertical-align: inherit;">デフォルト設定では、HLSコンパイラはFPGAで同期デザインを開発しましたが、より多くのリソースを消費しました。</font><font style="vertical-align: inherit;">このようなアーキテクチャは可能であり、リソースを節約するのではなく、最大のパフォーマンスを達成するようにIntel HLSが構成されていることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
被験者がより複雑なプロジェクトでどのように動作するかを見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のテスト。</font><font style="vertical-align: inherit;">「結果の合計を伴う行列の要素ごとの乗算」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、画像処理で広く使用されています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">いわゆる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「マトリックスフィルター」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">高度なツールを使用して販売しています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MathworkによるHDLコーダー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業はすぐに制限から始まります。 HDL Coderは、入力として2次元行列関数を受け入れることができません。 MATLABが行列を操作するためのツールであることを考えると、これは継承されたコード全体に対する深刻な打撃であり、深刻な問題になる可能性があります。コードが最初から作成されている場合、これは考慮すべき不愉快な機能です。したがって、すべての行列をベクトルに展開し、入力ベクトルを考慮して関数を実装する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MATLABでの関数のコードは次のとおりです</font></font><br>
<br>
<pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[out]</span> = <span class="hljs-title">mhls_conv2_manually</span><span class="hljs-params">(target,kernel)</span></span>
    len = <span class="hljs-built_in">length</span>(kernel);<font></font>
    mult = target.*kernel;<font></font>
    summ = sum(mult);<font></font>
    out = summ/len;<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成されたHDLコードは非常に肥大化し、数百行が含まれていることが判明したため、ここでは説明しません。 Quartusがこのコードから合成するスキームを見てみましょう。</font><i><font style="vertical-align: inherit;">図11</font></i><font style="vertical-align: inherit;"> 
この回路は失敗しています。正式には動作していますが、非常に低い周波数で動作すると想定されており、実際のハードウェアではほとんど使用できません。ただし、仮定は検証する必要があります。これを行うには、この回路の入力と出力にレジスタを配置し、Timing Analyzerを使用して実際の状況を評価します。解析を行うには、回路の目的の動作周波数を指定して、配線時にQuartusが何をすべきかを認識し、障害が発生した場合に違反のレポートを提供できるようにする必要があります。</font><font style="vertical-align: inherit;">
周波数を100 MHzに設定して、Quartusが提案された回路から何を絞り出すことができるか見てみましょう。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図12</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
少し判明したことがわかります。33MHzは軽薄に見えます。乗算器と加算器のチェーンの遅延は約30 nsです。この「ボトルネック」を解消するには、コンベヤーを使用する必要があります。算術演算の後にレジスターを挿入して、クリティカルパスを削減します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HDLコーダーは私たちにこの機会を与えてくれます。 [オプション]タブでは、パイプライン変数を設定できます。問題のコードはMATLABスタイルで記述されているため、変数（mult変数とsumm変数を除く）をパイプ処理する方法はありません。 HDLコードに隠されている中間回路にレジスタを挿入する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、最適化の状況は悪化する可能性があります。たとえば、コードの記述を妨げるものは何もありません</font></font><br>
<br>
<pre><code class="matlab hljs">out = (sum(target.*kernel))/len;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはMATLABには十分ですが、HDLを最適化する可能性を完全に奪います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の方法は、コードを手動で編集することです。これは非常に重要なポイントです。MATLABスタイルではなく、mスクリプトを継承して書き直すことを拒否するためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいコードは次のとおりです</font></font><br>
<br>
<pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[out]</span> = <span class="hljs-title">mhls_conv2_manually</span><span class="hljs-params">(target,kernel)</span></span>
    len = <span class="hljs-built_in">length</span>(kernel);<font></font>
    mult = target.*kernel;    <font></font>
    summ_1 = <span class="hljs-built_in">zeros</span>([<span class="hljs-number">1</span>,(len/<span class="hljs-number">2</span>)]);<font></font>
    summ_2 = <span class="hljs-built_in">zeros</span>([<span class="hljs-number">1</span>,(len/<span class="hljs-number">4</span>)]);<font></font>
    summ_3 = <span class="hljs-built_in">zeros</span>([<span class="hljs-number">1</span>,(len/<span class="hljs-number">8</span>)]);       <font></font>
    <font></font>
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:(len/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>
        summ_1(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>) = (mult(<span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)+mult(<span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>));
    <span class="hljs-keyword">end</span>        
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:(len/<span class="hljs-number">4</span>)<span class="hljs-number">-1</span>
        summ_2(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>) = (summ_1(<span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)+summ_1(<span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>));
    <span class="hljs-keyword">end</span>   
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:(len/<span class="hljs-number">8</span>)<span class="hljs-number">-1</span>
        summ_3(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>) = (summ_2(<span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)+summ_2(<span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>));
    <span class="hljs-keyword">end</span>    <font></font>
    out = summ_3/len;<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quartusでは、HDL Coderによって生成されたコードを収集します。プリミティブを含むレイヤーの数が減少し、スキームがはるかに良く見えることがわかります。</font><i><font style="vertical-align: inherit;">図12</font></i><font style="vertical-align: inherit;"> 
プリミティブを正しく配置すると、周波数はほぼ3倍になり、最大88 MHzになります。</font><i><font style="vertical-align: inherit;">図13</font></i><font style="vertical-align: inherit;"> 
最後の仕上げ：最適化設定で、summ_1、summ_2、summ_3をパイプラインの要素として指定します。結果のコードをQuartusに収集します。スキームは次のように変更されます。</font><i><font style="vertical-align: inherit;">図14</font></i><font style="vertical-align: inherit;"> 
最大周波数が再び増加し、現在の値は約195 MHzです。</font><i><font style="vertical-align: inherit;">図15</font></i><font style="vertical-align: inherit;"> 
チップ上のリソースはいくつありますか？図16は、上記のケースで使用されるリソースの表を示しています。</font><i><font style="vertical-align: inherit;">図16</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例を検討した後、どのような結論を導き出すことができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HDLコーダーの主な欠点は、MATLABコードを純粋な形式で使用する可能性が低いことです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数入力としての行列のサポートはありません。MATLABスタイルのコードのレイアウトは平凡です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な危険性は、追加の設定なしで生成されたコードにレジスタがないことです。これらのレジスタがないと、構文エラーなしで正式に機能するHDLコードを受け取っても、現代の現実や開発でそのようなコードを使用することは望ましくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HDLに変換するためにシャープにしたコードをすぐに作成することをお勧めします。この場合、速度とリソースの集中度の点で、かなり満足できる結果が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがMATLAB開発者である場合、実行ボタンをクリックしてFPGAでコードをコンパイルすることを急いではいけません。コードは実際の回路に合成されることを覚えておいてください。</font><font style="vertical-align: inherit;">=）</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インテルHLSコンパイラー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ機能について、私は次のC / C ++コードを書きました</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function">component <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">conv</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *kernel)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mult_res[<span class="hljs-number">16</span>];
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> summl;<font></font>
	summl = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<font></font>
	{	<font></font>
		mult_res[i] = data[i] * kernel[i];<font></font>
		summl = summl+mult_res[i];<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> summl/<span class="hljs-number">16</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に目を引くのは、使用されるリソースの量です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図17</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
表からわかるように、1つのDSPブロックしか使用されていないため、問題が発生し、乗算が並列に実行されていません。使用されるレジスタの数も驚くべきものであり、メモリも含まれますが、これはHLSコンパイラの良心に任されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSコンパイラーは、大量の追加リソースを使用して次善の最適化を開発しましたが、Quartusのレポートによると、許容可能な周波数で動作する回路がまだ機能しており、HDLコーダーが機能しないなどの障害があることに注意したいと思います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図18</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
状況を改善してみましょう。これには何が必要ですか？その通りです。目を閉じて継承に気をつけて、コードをクロールしてください。しかし、今のところはそれほど多くありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSには、FPGAのコードを最適化するための特別なディレクティブがあります。ループを並列に展開するunrollディレクティブを挿入します。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> unroll</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<font></font>
	{	<font></font>
		mult_res[i] = data[i] * kernel[i];<font></font>
	}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quartusがこれにどのように反応したかを見てみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図19</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初に、DSPブロックの数に注目します。16個あります。つまり、乗算が並列に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
やったー！アンロール作品！しかし、他のリソースの利用率がどれほど伸びたかに我慢することはすでに困難です。回路が完全に読めなくなった。</font><i><font style="vertical-align: inherit;">図20</font></i><font style="vertical-align: inherit;"> 
これは、固定小数点数での計算が私たちに非常に適しているとコンパイラに指摘したことがなく、論理とレジスタにすべての浮動小数点演算を正直に実装したという事実によるものだと思います。コンパイラーに何が必要かを説明する必要があります。そのために、もう一度コードに突入します。</font><font style="vertical-align: inherit;">
固定小数点を使用するために、テンプレートクラスが実装されています。</font><i><font style="vertical-align: inherit;">図21</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たち自身の言葉で言えば、ビット深度が少し手作業で設定されている変数を使用できます。 HDLで書く人には慣れませんが、C / C ++プログラマーはおそらく頭を抱えます。この場合、MATLABのようにビット深度は誰にもわかりません。開発者自身がビット数をカウントする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際にどのように見えるか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようにコードを編集します。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function">component ac_fixed&lt;16,16,<span class="hljs-literal">false</span>&gt; <span class="hljs-title">conv</span><span class="hljs-params">(ac_fixed&lt;<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">false</span>&gt; *data, ac_fixed&lt;<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">false</span>&gt; *kernel)</span>
</span>{<font></font>
	ac_fixed&lt;<span class="hljs-number">16</span>,<span class="hljs-number">16</span>,<span class="hljs-literal">false</span>&gt;mult_res[<span class="hljs-number">16</span>];<font></font>
    ac_fixed&lt;<span class="hljs-number">32</span>,<span class="hljs-number">32</span>,<span class="hljs-literal">false</span>&gt;summl;<font></font>
<font></font>
	<font></font>
	<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> unroll</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<font></font>
	{	<font></font>
		mult_res[i] = data[i] * kernel[i];<font></font>
	}<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<font></font>
	{<font></font>
		summl = summl+mult_res[i];		<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> summl/<span class="hljs-number">16</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、図20の不気味なパスタの代わりに、次のような美しさが得られます。</font><i><font style="vertical-align: inherit;">図22</font></i><font style="vertical-align: inherit;"> 
残念ながら、使用するリソースで奇妙なことが起こり続けています。</font><i><font style="vertical-align: inherit;">図23</font></i><font style="vertical-align: inherit;"> 
しかし、レポートを詳細に調べると、関心のあるモジュールは直接、十分すぎるほどに見えます。</font><i><font style="vertical-align: inherit;">図24</font></i><font style="vertical-align: inherit;"> 
レジスタとブロックメモリ</font><i><font style="vertical-align: inherit;">の</font></i><font style="vertical-align: inherit;">大量の消費は、多数の周辺モジュールに関連しています。</font><font style="vertical-align: inherit;">私はまだ彼らの存在の深い意味を完全に理解していません、そしてこれは扱われる必要があるでしょうが、問題は解決されます。</font><font style="vertical-align: inherit;">極端な場合は、プロジェクトの一般的な構造から関心のあるモジュールを1つ注意深く切り取ることができます。これにより、リソースを食い尽くす周辺モジュールから節約できます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のテスト。</font><font style="vertical-align: inherit;">「RGBからHSVへの移行」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を書き始めたとき、私はそれがそれほどボリュームがあるとは思っていませんでした。しかし、私はこの記事の枠組みの中で3番目と最後の例を拒否することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、これは私の実践からの実際の例であり、それが私が高レベルの開発ツールに目を向け始めたのはそれが理由でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最初の2つの例から、設計が複雑であるほど、高レベルのツールがタスクを処理するのが難しくなるという仮定を立てることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この判断は誤りであり、実際には、タスクが複雑になるほど、高レベルの開発ツールの利点が明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
昨年、プロジェクトの1つで作業しているときに、Aliexpressで購入したカメラが気に入りませんでした。つまり、色が十分に飽和していませんでした。色の彩度を変える一般的な方法の1つは、RGBカラースペースからHSVスペースに切り替えることです。ここで、パラメーターの1つは彩度です。遷移式を開いて深呼吸した方法を覚えています...そのような計算をFPGAに実装することは特別なことではありませんが、もちろんコードの記述には時間がかかります。 ：だから、HSVにRGBから切り替えるための式は次の通りされ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、図25</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
FPGAでのこのようなアルゴリズムの実装がない日かかりますが、時間、そしてすべてこれは非常に慎重にHDLの仕様によるもので行われなければならない、とC ++またはMATLABでの実装は、私が思うに、数分かかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、額に直接コードを記述しても、動作する結果を得ることができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++で次のオプションを書いた</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">color_space</span>{</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> rh;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> gs;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> bv;<font></font>
};<font></font>
<font></font>
<span class="hljs-function">component color_space <span class="hljs-title">rgb2hsv</span><span class="hljs-params">(color_space rgb_0)</span>
</span>{<font></font>
	color_space hsv;<font></font>
	<span class="hljs-keyword">float</span> h,s,v,r,g,b;
	<span class="hljs-keyword">float</span> max_col, min_col;<font></font>
<font></font>
	r = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(rgb_0.rh)/<span class="hljs-number">255</span>;<font></font>
	g = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(rgb_0.gs)/<span class="hljs-number">255</span>;<font></font>
	b = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(rgb_0.bv)/<span class="hljs-number">255</span>;<font></font>
<font></font>
	max_col = <span class="hljs-built_in">std</span>::max(<span class="hljs-built_in">std</span>::max(r,g),b);<font></font>
	min_col = <span class="hljs-built_in">std</span>::min(<span class="hljs-built_in">std</span>::min(r,g),b);
	<span class="hljs-comment">// H</span>
	<span class="hljs-keyword">if</span> (max_col == min_col)<font></font>
		h = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max_col==r &amp;&amp; g&gt;=b)<font></font>
		h = <span class="hljs-number">60</span>*((g-b)/(max_col-min_col));
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max_col==r &amp;&amp; g&lt;b)<font></font>
		h = <span class="hljs-number">60</span>*((g-b)/(max_col-min_col))+<span class="hljs-number">360</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max_col==g)<font></font>
		h = <span class="hljs-number">60</span>*((b-r)/(max_col-min_col))+<span class="hljs-number">120</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max_col==b)<font></font>
		h = <span class="hljs-number">60</span>*((r-g)/(max_col-min_col))+<span class="hljs-number">240</span>;
	<span class="hljs-comment">// S</span>
	<span class="hljs-keyword">if</span> (max_col == <span class="hljs-number">0</span>)<font></font>
		s = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		s = (<span class="hljs-number">1</span>-(min_col/max_col))*<span class="hljs-number">100</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">// V</span>
	v = max_col*<span class="hljs-number">100</span>;<font></font>
<font></font>
	hsv.rh = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(h);<font></font>
	hsv.gs = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(s);<font></font>
	hsv.bv = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(v);
	<span class="hljs-keyword">return</span> hsv;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、使用されたリソースの表からわかるように、Quartusは結果を正常に実装しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図26.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
周波数は非常に良好</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図27.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
HDLコーダーを使用すると、状況は少し複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事が膨らまないようにするため、このタスクのmスクリプトは提供しません。問題が発生することはありません。</font><font style="vertical-align: inherit;">額に書かれたm-scriptはうまく使用できませんが、コードを編集してパイプラインの場所を正しく指定すると、正常な結果が得られます。</font><font style="vertical-align: inherit;">もちろん、これには数十分かかりますが、数時間はかかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、ディレクティブを設定して計算を固定小数点に変換することも望ましく、これも非常に時間がかかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、高レベルの開発ツールを使用すると、時間を節約でき、アルゴリズムが複雑になるほど、時間を節約できます。これは、HDLに取り組む必要があるFPGAリソース制限または厳密な計算速度制限に達するまで続きます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として何が言えるでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、ゴールデンハンマーはまだ発明されていませんが、開発に使用できる追加のツールがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、高水準ツールの主な利点は開発の速度です。時間の観点から十分な品質を得るのは現実ですが、HDLを使用して開発する場合よりも1桁小さい場合もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGAにレガシーコードを使用したり、事前準備をせずにプログラマーをFPGA開発に接続したりするなどの利点があるため、私は警戒しています。満足のいく結果を得るには、多くの使い慣れたプログラミング手法を放棄する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、この記事はFPGAの高レベル開発ツールの表面的な見方にすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HLSコンパイラには、最適化の大きな機会があります。プラグマ、最適化された関数を備えた特別なライブラリ、インターフェイスの説明、インターネット上の「ベストプラクティス」に関する記事などです。考慮されていないMATLABチップは、たとえば、コードを1行も書かずにGUIからフィルターを直接生成する機能であり、目的の特性を示すだけなので、開発時間をさらに短縮できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日の研究で誰が勝ったのですか？私の意見は、インテルHLSコンパイラーです。最適化されていないコードからでも機能するデザインを生成します。思慮深い分析とコード処理のないHDLコーダーを使用するのは怖いでしょう。また、HDLコーダーはかなり古いツールですが、ご存知のように、広く認知されていません。しかし、HLSは若いですが、FPGAメーカーがそれに賭けていることがわかりますが、今後さらに発展し、人気が高まると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ザイリンクスの担当者は、高レベルツールの開発と実装が、今後ますます大規模なFPGAチップ向けに開発する唯一の機会であることを保証します。従来のツールではこれに対処できません。Verilog/ VHDLはおそらくアセンブラー向けですが、将来的にはそうです。そして今、私たちは開発ツール（その長所と短所を含む）を手にしています。タスクに基づいて選択する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕事で高レベルの開発ツールを使用しますか？むしろ、はい、今、彼らの開発は飛躍的に進んでいるので、私たちは少なくとも追いつく必要がありますが、私はすぐにHDLを放棄する客観的な理由はないと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、高レベルの設計ツールの開発のこの段階で、ユーザーはプロセッサで実行できないプログラムを作成することを忘れないでください。ただし、実際のワイヤー、トリガー、およびロジックエレメントを使用して回路を作成することに注意してください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455650/index.html">ネジを分類するためのニューラルネットワークのトレーニング方法</a></li>
<li><a href="../ja455652/index.html">ディープラーニングと常識：チャットボットの開発</a></li>
<li><a href="../ja455658/index.html">伝説のIntel Core i7-2600K：2019年のSandy Bridgeのテスト（パート3）</a></li>
<li><a href="../ja455662/index.html">デコーダーとしてカム機構を備えた大型機械式ディスプレイ</a></li>
<li><a href="../ja455666/index.html">ITサービス会社でのアウトバウンドセールスの構築</a></li>
<li><a href="../ja455670/index.html">3Dプリンターが骨、血管、臓器を印刷する方法</a></li>
<li><a href="../ja455676/index.html">機械学習のバブルが破裂しましたか、それとも新しい夜明けが始まりましたか</a></li>
<li><a href="../ja455678/index.html">セルゲイパブロビッチコロレフの途中。現代ロシア有人プロジェクト。パート1.「フェデレーション」</a></li>
<li><a href="../ja455682/index.html">インフラストラクチャにどれくらい費やしていますか？そして、これを節約する方法は？</a></li>
<li><a href="../ja455684/index.html">テスターのためにハッカソンを行った理由</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>