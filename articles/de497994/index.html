<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÇ ‚ùóÔ∏è üíò Sprachmechanik entgeht der Analyse üéê üòå üñçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auftakt
 Dies ist der zweite von vier Artikeln in einer Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sprachmechanik entgeht der Analyse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497994/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auftakt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der zweite von vier Artikeln in einer Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analysen und der Go / Value-Semantik bieten. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um Haufen- und Fluchtanalyse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inhaltsverzeichnis:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik auf Stapeln und Zeigern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Fluchtanalyse</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Speicherprofilerstellung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designphilosophie zu Daten und Semantik</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ersten Beitrag dieser Reihe habe ich anhand eines Beispiels, in dem der Wert √ºber den Stapel zwischen Goroutinen verteilt ist, √ºber die Grundlagen der Zeigermechanik gesprochen. Ich habe Ihnen nicht gezeigt, was passiert, wenn Sie den Wert auf dem Stapel teilen. Um dies zu verstehen, m√ºssen Sie sich √ºber einen anderen Speicherbereich informieren, in dem sich die Werte befinden k√∂nnen: √ºber den ‚ÄûHeap‚Äú. Mit diesem Wissen k√∂nnen Sie beginnen, ‚ÄûFluchtanalyse‚Äú zu studieren.</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Escape-Analyse ist ein Prozess, mit dem der Compiler die Platzierung der von Ihrem Programm erstellten Werte ermittelt. </font><font style="vertical-align: inherit;">Insbesondere f√ºhrt der Compiler eine statische Code-Analyse durch, um festzustellen, ob der Wert f√ºr die Funktion, die ihn erstellt, auf dem Stapelrahmen platziert werden kann oder ob der Wert in den Heap "maskiert" werden soll. </font><font style="vertical-align: inherit;">In Go gibt es kein einziges Schl√ºsselwort oder keine einzige Funktion, mit der Sie dem Compiler mitteilen k√∂nnen, welche Entscheidung er treffen soll. </font><font style="vertical-align: inherit;">Nur wenn Sie Ihren Code bedingt schreiben, k√∂nnen Sie diese Entscheidung beeinflussen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haufen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Heap ist neben dem Stapel ein zweiter Speicherbereich, in dem Werte gespeichert werden. Der Heap ist nicht wie Stapel selbstreinigend, daher ist die Verwendung dieses Speichers teurer. Zuallererst sind die Kosten mit dem Garbage Collector (GC) verbunden, der diesen Bereich sauber halten soll. Wenn der GC gestartet wird, verbraucht er 25% der verf√ºgbaren Leistung Ihres Prozessors. Dar√ºber hinaus kann es m√∂glicherweise zu Mikrosekunden Verz√∂gerungen kommen, die die Welt stoppen. Der Vorteil eines GC besteht darin, dass Sie sich nicht um die Verwaltung des Heap-Speichers k√ºmmern m√ºssen, der in der Vergangenheit komplex und fehleranf√§llig war.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Werte im Heap provozieren Speicherzuordnungen in Go. </font><font style="vertical-align: inherit;">Diese Zuordnungen √ºben Druck auf den GC aus, da jeder Wert im Heap, auf den sich der Zeiger nicht mehr bezieht, gel√∂scht werden muss. </font><font style="vertical-align: inherit;">Je mehr Werte Sie √ºberpr√ºfen und l√∂schen m√ºssen, desto mehr Arbeit muss der GC bei jedem Start leisten. </font><font style="vertical-align: inherit;">Daher arbeitet der Stimulationsalgorithmus st√§ndig daran, die Gr√∂√üe des Heapspeichers und die Ausf√ºhrungsgeschwindigkeit in Einklang zu bringen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack-Sharing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Go d√ºrfen keine Goroutinen einen Zeiger haben, der auf einen Speicher auf dem Stapel einer anderen Goroutine zeigt. </font><font style="vertical-align: inherit;">Dies liegt an der Tatsache, dass der Stapelspeicher f√ºr Goroutinen durch einen neuen Speicherblock ersetzt werden kann, wenn der Stapel vergr√∂√üert oder verkleinert werden soll. </font><font style="vertical-align: inherit;">Wenn Sie zur Laufzeit die Stapelzeiger in einer anderen Goroutine verfolgen m√ºssten, m√ºssten Sie zu viel verwalten, und die Verz√∂gerung beim Stoppen der Zeiger auf diese Stapel w√§re ersch√ºtternd. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel f√ºr einen Stapel, der aufgrund von Wachstum mehrmals ersetzt wird. </font><font style="vertical-align: inherit;">Sehen Sie sich die Ausgabe in den Zeilen 2 und 6 an. Sie sehen zweimal die Adress√§nderungen des Zeichenfolgenwerts im Hauptstapelrahmen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/pxn5u4EBSI</font></font></a> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluchtmechanik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Mal, wenn ein Wert au√üerhalb des Bereichs des Stapelrahmens einer Funktion geteilt wird, wird er in einem Heap platziert (oder zugewiesen). Die Aufgabe von Escape-Analyse-Algorithmen besteht darin, solche Situationen zu finden und das Integrit√§tsniveau im Programm aufrechtzuerhalten. Integrit√§t soll sicherstellen, dass der Zugriff auf jeden Wert immer genau, konsistent und effizient ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich dieses Beispiel an, um die grundlegenden Mechanismen der Fluchtanalyse zu lernen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/Y_VZxYteKO</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Listing 1</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> {
<span class="hljs-number">04</span>     name  <span class="hljs-keyword">string</span>
<span class="hljs-number">05</span>     email <span class="hljs-keyword">string</span>
<span class="hljs-number">06</span> }
<span class="hljs-number">07</span>
<span class="hljs-number">08</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">09</span>     u1 := createUserV1()
<span class="hljs-number">10</span>     u2 := createUserV2()
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"u1"</span>, &amp;u1, <span class="hljs-string">"u2"</span>, &amp;u2)
<span class="hljs-number">13</span> }
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich verwende die Anweisung go: noinline, damit der Compiler keinen Code f√ºr diese Funktionen direkt in main einbettet. Durch das Einbetten werden Funktionsaufrufe entfernt und dieses Beispiel kompliziert. Ich werde im n√§chsten Beitrag √ºber die Nebenwirkungen der Einbettung sprechen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Listing 1 zeigt ein Programm mit zwei verschiedenen Funktionen, die einen Wert vom Typ user erstellen und an den Aufrufer zur√ºckgeben. Die erste Version der Funktion verwendet bei der R√ºckgabe die Semantik des Werts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sagte, dass die Funktion bei der R√ºckgabe die Semantik von Werten verwendet, da ein von dieser Funktion erstellter Wert vom Typ Benutzer kopiert und an den Aufrufstapel √ºbergeben wird. Dies bedeutet, dass die aufrufende Funktion eine Kopie des Werts selbst erh√§lt.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sie k√∂nnen die Erstellung eines Werts vom Typ Benutzer sehen, der in den Zeilen 17 bis 20 ausgef√ºhrt wird. In Zeile 23 wird dann eine Kopie des Werts an den Aufrufstapel √ºbergeben und an den Aufrufer zur√ºckgegeben. Nach dem Zur√ºckgeben der Funktion sieht der Stapel wie folgt aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bild 1 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hs/me/pj/hsmepjswe1d_ggonuc8jkwscyk8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abbildung 1 sehen Sie, dass nach dem Aufruf von createUserV1 in beiden Frames ein Wert vom Typ user vorhanden ist. In der zweiten Version der Funktion wird die Zeigersemantik verwendet, um zur√ºckzukehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sagte, dass eine Funktion bei der R√ºckgabe eine Zeigersemantik verwendet, da ein Wert vom Typ Benutzer, der von dieser Funktion erstellt wurde, vom Aufrufstapel gemeinsam genutzt wird. Dies bedeutet, dass die aufrufende Funktion eine Kopie der Adresse erh√§lt, an der sich die Werte befinden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sie k√∂nnen dasselbe Strukturliteral sehen, das in den Zeilen 28 bis 31 verwendet wird, um einen Wert vom Typ user zu erstellen, aber in Zeile 34 ist die R√ºckgabe von der Funktion unterschiedlich. Anstatt eine Kopie des Werts an den Aufrufstapel zur√ºckzugeben, wird eine Kopie der Adresse f√ºr den Wert √ºbergeben. Auf dieser Grundlage k√∂nnten Sie denken, dass der Stapel nach dem Aufruf so aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bild 2</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/ld/nh/muldnhq-xncjaz97pv-647tybme.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das, was Sie in Abbildung 2 sehen, wirklich passiert, liegt ein Integrit√§tsproblem vor. </font><font style="vertical-align: inherit;">Ein Zeiger zeigt nach unten auf einen Stapel von Speicheraufrufen, der nicht mehr g√ºltig ist. </font><font style="vertical-align: inherit;">Beim n√§chsten Aufruf der Funktion wird der angegebene Speicher neu formatiert und neu initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier beginnt die Escape-Analyse, die Integrit√§t aufrechtzuerhalten. </font><font style="vertical-align: inherit;">In diesem Fall stellt der Compiler fest, dass es nicht sicher ist, einen Wert vom Typ user innerhalb des Stapelrahmens createUserV2 zu erstellen. Stattdessen wird ein Wert auf dem Heap erstellt. </font><font style="vertical-align: inherit;">Dies geschieht sofort w√§hrend des Baus der Linie 28.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesbarkeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie aus einem fr√ºheren Beitrag erfahren haben, hat eine Funktion √ºber den Frame-Zeiger direkten Zugriff auf den Speicher innerhalb ihres Frames. F√ºr den Zugriff auf den Speicher au√üerhalb des Frames ist jedoch ein indirekter Zugriff erforderlich. Dies bedeutet, dass der Zugriff auf Werte, die in den Heap fallen, auch indirekt √ºber einen Zeiger erfolgen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran, wie der createUserV2-Code aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Syntax verbirgt, was in diesem Code wirklich passiert. Die in Zeile 28 deklarierte Variable u repr√§sentiert einen Wert vom Typ user. Die Konstruktion in Go sagt Ihnen nicht genau, wo der Wert im Speicher gespeichert ist. Vor der return-Anweisung in Zeile 34 wissen Sie also nicht, dass der Wert geh√§uft wird. Dies bedeutet, dass u zwar einen Wert vom Typ user darstellt, der Zugriff auf diesen Wert jedoch √ºber einen Zeiger erfolgen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen einen Stapel visualisieren, der nach einem Funktionsaufruf so aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bild 3</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/ya/sv/5uyasv63ozdef8jclixqpv4anx4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable u im Stapelrahmen f√ºr createUserV2 repr√§sentiert den Wert auf dem Heap und nicht auf dem Stapel. </font><font style="vertical-align: inherit;">Dies bedeutet, dass f√ºr die Verwendung von u f√ºr den Zugriff auf einen Wert der Zugriff auf einen Zeiger erforderlich ist, nicht auf den von der Syntax vorgeschlagenen direkten Zugriff. </font><font style="vertical-align: inherit;">Sie k√∂nnten denken, warum nicht sofort einen Zeiger erstellen, da f√ºr den Zugriff auf den Wert, den er darstellt, immer noch ein Zeiger verwendet werden muss? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie dies tun, verlieren Sie die Lesbarkeit, die Sie in Ihrem Code nicht verlieren k√∂nnten. </font><font style="vertical-align: inherit;">Bewegen Sie sich f√ºr eine Sekunde vom Funktionsk√∂rper weg und konzentrieren Sie sich nur auf die R√ºckkehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wor√ºber spricht diese R√ºckkehr? </font><font style="vertical-align: inherit;">Er sagt nur, dass eine Kopie von u auf den Aufrufstapel geschoben wird. </font><font style="vertical-align: inherit;">Was sagt Ihnen die R√ºckkehr in der Zwischenzeit, wenn Sie den Operator &amp; verwenden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank des Operators &amp; return erfahren Sie jetzt, dass Sie den Aufrufstapel gemeinsam nutzen und daher in den Heap gehen. Denken Sie daran, dass Zeiger zusammen verwendet werden sollen und beim Lesen des Codes den Operator &amp; durch den Ausdruck "Freigabe" ersetzen. Es ist sehr leistungsf√§hig in Bezug auf die Lesbarkeit. Das m√∂chte ich nicht verlieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres Beispiel, bei dem das Erstellen von Werten mithilfe der Zeigersemantik die Lesbarkeit beeintr√§chtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u *user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> u, err</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dieser Code funktioniert, m√ºssen Sie beim Aufrufen von json.Unmarshal in Zeile 02 einen Zeiger auf eine Zeigervariable √ºbergeben. Ein Aufruf von json.Unmarshal erstellt einen Wert vom Typ user und weist seine Adresse einer Zeigervariablen zu. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/koI8EjpeIx</font></font></a> </i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Was dieser Code sagt: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Erstellen Sie einen Zeiger vom Typ Benutzer mit einem Nullwert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Teilen Sie die Variable u mit der Funktion json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Eine Kopie der Variablen u an den Aufrufer zur√ºckgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht ganz offensichtlich, dass ein Wert vom Typ user, der von der Funktion json.Unmarshal erstellt wurde, an den Aufrufer √ºbergeben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie √§ndert sich die Lesbarkeit, wenn die Semantik von Werten w√§hrend der Variablendeklaration verwendet wird? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> &amp;u, err</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was dieser Code sagt: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Erstellen Sie einen Wert vom Typ Benutzer mit einem Nullwert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Teilen Sie die Variable u mit der Funktion json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Teilen Sie die Variable u mit dem Aufrufer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles ist sehr klar. </font><font style="vertical-align: inherit;">Zeile 02 teilt den Wert des Typbenutzers im Aufrufstapel in json.Unmarshal auf, und Zeile 03 teilt den Wert des Aufrufstapels an den Anrufer zur√ºck. </font><font style="vertical-align: inherit;">Diese Freigabe bewirkt, dass der Wert auf den Heap verschoben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie beim Erstellen von Werten die Semantik von Werten und nutzen Sie die Lesbarkeit des Operators &amp;, um zu verdeutlichen, wie Werte getrennt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiler-Berichterstellung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die vom Compiler getroffenen Entscheidungen anzuzeigen, k√∂nnen Sie den Compiler bitten, einen Bericht bereitzustellen. </font><font style="vertical-align: inherit;">Alles, was Sie tun m√ºssen, ist, den Schalter -gcflags mit der Option -m zu verwenden, wenn Sie go build aufrufen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen Sie 4 Ebenen von -m verwenden, aber nach 2 Informationsebenen wird es zu viel. </font><font style="vertical-align: inherit;">Ich werde 2 Ebenen -m verwenden. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10:</font></font><br>
<br>
<pre><code class="bash hljs">$ go build -gcflags <span class="hljs-string">"-m -m"</span><font></font>
./main.go:16: cannot inline createUserV1: marked go:noinline<font></font>
./main.go:27: cannot inline createUserV2: marked go:noinline<font></font>
./main.go:8: cannot inline main: non-leaf <span class="hljs-keyword">function</span><font></font>
./main.go:22: createUserV1 &amp;u does not escape<font></font>
./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape<font></font>
./main.go:12: main &amp;u1 does not escape<font></font>
./main.go:12: main &amp;u2 does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen sehen, dass der Compiler Entscheidungen meldet, um den Wert in den Heap zu sichern. </font><font style="vertical-align: inherit;">Was sagt der Compiler? </font><font style="vertical-align: inherit;">Schauen Sie sich zun√§chst die Funktionen createUserV1 und createUserV2 noch einmal an, um sie im Speicher zu aktualisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }<font></font>
<font></font>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dieser Zeile im Bericht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14:</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:22: createUserV1 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies deutet darauf hin, dass der Aufruf der Funktion println innerhalb der Funktion createUserV1 nicht dazu f√ºhrt, dass der Benutzertyp in den Heap kopiert wird. Dieser Fall musste √ºberpr√ºft werden, da er in Verbindung mit der Funktion println verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich als N√§chstes diese Zeilen im Bericht an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 15:</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Zeilen besagen, dass der Wert des Benutzertyps, der der Variablen u zugeordnet ist, die den benannten Benutzertyp hat und in Zeile 31 erstellt wird, aufgrund der R√ºckgabe in Zeile 34 in den Heap ausgegeben wird. Die letzte Zeile sagt dasselbe wie zuvor, println call in der Zeile 33 setzt den Benutzertyp nicht zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Lesen dieser Berichte kann verwirrend sein und leicht variieren, je nachdem, ob der Typ der betreffenden Variablen auf einem benannten oder einem w√∂rtlichen Typ basiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñndern Sie die Variable u so, dass sie wie zuvor der Literal-Typ * user anstelle des benannten Typbenutzers ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 16:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie den Bericht erneut aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 17:</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:30: &amp;user literal escapes to heap<font></font>
./main.go:30:     from u (assigned) at ./main.go:28<font></font>
./main.go:30:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bericht besagt nun, dass der Wert des Benutzertyps, auf den die Variable u verweist, die den Literaltyp * user hat und in Zeile 28 erstellt wurde, aufgrund der R√ºckgabe in Zeile 34 auf dem Heap gespeichert wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines Werts bestimmt nicht, wo er sich befindet. </font><font style="vertical-align: inherit;">Nur wie der Wert aufgeteilt wird, bestimmt, was der Compiler mit diesem Wert macht. </font><font style="vertical-align: inherit;">Jedes Mal, wenn Sie einen Wert im Aufrufstapel freigeben, wird er auf dem Heap gespeichert. </font><font style="vertical-align: inherit;">Es gibt andere Gr√ºnde, warum ein Wert aus dem Stapel entkommen kann. </font><font style="vertical-align: inherit;">Ich werde im n√§chsten Beitrag dar√ºber sprechen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck dieser Beitr√§ge besteht darin, Anleitungen zur Auswahl der Wertesemantik oder Zeigersemantik f√ºr einen bestimmten Typ bereitzustellen. </font><font style="vertical-align: inherit;">Jede Semantik ist mit Gewinn und Wert verbunden. </font><font style="vertical-align: inherit;">Die Semantik der Werte speichert die Werte auf dem Stapel, wodurch die Belastung des GC verringert wird. </font><font style="vertical-align: inherit;">Es gibt jedoch verschiedene Kopien desselben Werts, die gespeichert, verfolgt und verwaltet werden m√ºssen. </font><font style="vertical-align: inherit;">Die Zeigersemantik legt Werte auf einen Haufen, was Druck auf den GC aus√ºben kann. </font><font style="vertical-align: inherit;">Sie sind jedoch effektiv, da nur ein Wert gespeichert, verfolgt und verwaltet werden muss. </font><font style="vertical-align: inherit;">Der entscheidende Punkt ist die korrekte, konsistente und ausgewogene Verwendung jeder Semantik.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de497982/index.html">Funktions- und Prozessansatz f√ºr das Management. Wie und was ist zu verwalten?</a></li>
<li><a href="../de497984/index.html">Migration von reCAPTCHA zu hCaptcha in Cloudflare</a></li>
<li><a href="../de497986/index.html">√úberwachen des gesamten von einer Webseite verwendeten Speichers: performance.measureMemory ()</a></li>
<li><a href="../de497988/index.html">React Application Performance Profiling</a></li>
<li><a href="../de497990/index.html">PostgreSQL: Entwicklung von Erweiterungen (Funktionen) in C-Sprache</a></li>
<li><a href="../de497996/index.html">Sie wollen die Immunit√§t nicht st√§rken. Oder die Extreme des menschlichen K√∂rpers</a></li>
<li><a href="../de498000/index.html">Dinge, die ich gerne wissen w√ºrde, bevor ich mein eigenes Spiel entwickle</a></li>
<li><a href="../de498002/index.html">Taschenanleitung zum Z3</a></li>
<li><a href="../de498004/index.html">Workstation in einem Docker-Container</a></li>
<li><a href="../de498006/index.html">Wahl eines Patentanwalts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>