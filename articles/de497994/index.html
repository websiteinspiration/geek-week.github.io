<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😂 ❗️ 💘 Sprachmechanik entgeht der Analyse 🎐 😌 🖍️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auftakt
 Dies ist der zweite von vier Artikeln in einer Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sprachmechanik entgeht der Analyse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497994/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auftakt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der zweite von vier Artikeln in einer Reihe, die Einblicke in die Mechanik und das Design von Zeigern, Stapeln, Haufen, Escape-Analysen und der Go / Value-Semantik bieten. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um Haufen- und Fluchtanalyse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inhaltsverzeichnis:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik auf Stapeln und Zeigern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Fluchtanalyse</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachmechanik zur Speicherprofilerstellung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designphilosophie zu Daten und Semantik</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ersten Beitrag dieser Reihe habe ich anhand eines Beispiels, in dem der Wert über den Stapel zwischen Goroutinen verteilt ist, über die Grundlagen der Zeigermechanik gesprochen. Ich habe Ihnen nicht gezeigt, was passiert, wenn Sie den Wert auf dem Stapel teilen. Um dies zu verstehen, müssen Sie sich über einen anderen Speicherbereich informieren, in dem sich die Werte befinden können: über den „Heap“. Mit diesem Wissen können Sie beginnen, „Fluchtanalyse“ zu studieren.</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Escape-Analyse ist ein Prozess, mit dem der Compiler die Platzierung der von Ihrem Programm erstellten Werte ermittelt. </font><font style="vertical-align: inherit;">Insbesondere führt der Compiler eine statische Code-Analyse durch, um festzustellen, ob der Wert für die Funktion, die ihn erstellt, auf dem Stapelrahmen platziert werden kann oder ob der Wert in den Heap "maskiert" werden soll. </font><font style="vertical-align: inherit;">In Go gibt es kein einziges Schlüsselwort oder keine einzige Funktion, mit der Sie dem Compiler mitteilen können, welche Entscheidung er treffen soll. </font><font style="vertical-align: inherit;">Nur wenn Sie Ihren Code bedingt schreiben, können Sie diese Entscheidung beeinflussen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haufen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Heap ist neben dem Stapel ein zweiter Speicherbereich, in dem Werte gespeichert werden. Der Heap ist nicht wie Stapel selbstreinigend, daher ist die Verwendung dieses Speichers teurer. Zuallererst sind die Kosten mit dem Garbage Collector (GC) verbunden, der diesen Bereich sauber halten soll. Wenn der GC gestartet wird, verbraucht er 25% der verfügbaren Leistung Ihres Prozessors. Darüber hinaus kann es möglicherweise zu Mikrosekunden Verzögerungen kommen, die die Welt stoppen. Der Vorteil eines GC besteht darin, dass Sie sich nicht um die Verwaltung des Heap-Speichers kümmern müssen, der in der Vergangenheit komplex und fehleranfällig war.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Werte im Heap provozieren Speicherzuordnungen in Go. </font><font style="vertical-align: inherit;">Diese Zuordnungen üben Druck auf den GC aus, da jeder Wert im Heap, auf den sich der Zeiger nicht mehr bezieht, gelöscht werden muss. </font><font style="vertical-align: inherit;">Je mehr Werte Sie überprüfen und löschen müssen, desto mehr Arbeit muss der GC bei jedem Start leisten. </font><font style="vertical-align: inherit;">Daher arbeitet der Stimulationsalgorithmus ständig daran, die Größe des Heapspeichers und die Ausführungsgeschwindigkeit in Einklang zu bringen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack-Sharing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Go dürfen keine Goroutinen einen Zeiger haben, der auf einen Speicher auf dem Stapel einer anderen Goroutine zeigt. </font><font style="vertical-align: inherit;">Dies liegt an der Tatsache, dass der Stapelspeicher für Goroutinen durch einen neuen Speicherblock ersetzt werden kann, wenn der Stapel vergrößert oder verkleinert werden soll. </font><font style="vertical-align: inherit;">Wenn Sie zur Laufzeit die Stapelzeiger in einer anderen Goroutine verfolgen müssten, müssten Sie zu viel verwalten, und die Verzögerung beim Stoppen der Zeiger auf diese Stapel wäre erschütternd. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel für einen Stapel, der aufgrund von Wachstum mehrmals ersetzt wird. </font><font style="vertical-align: inherit;">Sehen Sie sich die Ausgabe in den Zeilen 2 und 6 an. Sie sehen zweimal die Adressänderungen des Zeichenfolgenwerts im Hauptstapelrahmen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/pxn5u4EBSI</font></font></a> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluchtmechanik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Mal, wenn ein Wert außerhalb des Bereichs des Stapelrahmens einer Funktion geteilt wird, wird er in einem Heap platziert (oder zugewiesen). Die Aufgabe von Escape-Analyse-Algorithmen besteht darin, solche Situationen zu finden und das Integritätsniveau im Programm aufrechtzuerhalten. Integrität soll sicherstellen, dass der Zugriff auf jeden Wert immer genau, konsistent und effizient ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich dieses Beispiel an, um die grundlegenden Mechanismen der Fluchtanalyse zu lernen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/Y_VZxYteKO</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Listing 1</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> {
<span class="hljs-number">04</span>     name  <span class="hljs-keyword">string</span>
<span class="hljs-number">05</span>     email <span class="hljs-keyword">string</span>
<span class="hljs-number">06</span> }
<span class="hljs-number">07</span>
<span class="hljs-number">08</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">09</span>     u1 := createUserV1()
<span class="hljs-number">10</span>     u2 := createUserV2()
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"u1"</span>, &amp;u1, <span class="hljs-string">"u2"</span>, &amp;u2)
<span class="hljs-number">13</span> }
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich verwende die Anweisung go: noinline, damit der Compiler keinen Code für diese Funktionen direkt in main einbettet. Durch das Einbetten werden Funktionsaufrufe entfernt und dieses Beispiel kompliziert. Ich werde im nächsten Beitrag über die Nebenwirkungen der Einbettung sprechen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Listing 1 zeigt ein Programm mit zwei verschiedenen Funktionen, die einen Wert vom Typ user erstellen und an den Aufrufer zurückgeben. Die erste Version der Funktion verwendet bei der Rückgabe die Semantik des Werts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sagte, dass die Funktion bei der Rückgabe die Semantik von Werten verwendet, da ein von dieser Funktion erstellter Wert vom Typ Benutzer kopiert und an den Aufrufstapel übergeben wird. Dies bedeutet, dass die aufrufende Funktion eine Kopie des Werts selbst erhält.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sie können die Erstellung eines Werts vom Typ Benutzer sehen, der in den Zeilen 17 bis 20 ausgeführt wird. In Zeile 23 wird dann eine Kopie des Werts an den Aufrufstapel übergeben und an den Aufrufer zurückgegeben. Nach dem Zurückgeben der Funktion sieht der Stapel wie folgt aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bild 1 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hs/me/pj/hsmepjswe1d_ggonuc8jkwscyk8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abbildung 1 sehen Sie, dass nach dem Aufruf von createUserV1 in beiden Frames ein Wert vom Typ user vorhanden ist. In der zweiten Version der Funktion wird die Zeigersemantik verwendet, um zurückzukehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sagte, dass eine Funktion bei der Rückgabe eine Zeigersemantik verwendet, da ein Wert vom Typ Benutzer, der von dieser Funktion erstellt wurde, vom Aufrufstapel gemeinsam genutzt wird. Dies bedeutet, dass die aufrufende Funktion eine Kopie der Adresse erhält, an der sich die Werte befinden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sie können dasselbe Strukturliteral sehen, das in den Zeilen 28 bis 31 verwendet wird, um einen Wert vom Typ user zu erstellen, aber in Zeile 34 ist die Rückgabe von der Funktion unterschiedlich. Anstatt eine Kopie des Werts an den Aufrufstapel zurückzugeben, wird eine Kopie der Adresse für den Wert übergeben. Auf dieser Grundlage könnten Sie denken, dass der Stapel nach dem Aufruf so aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bild 2</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/ld/nh/muldnhq-xncjaz97pv-647tybme.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das, was Sie in Abbildung 2 sehen, wirklich passiert, liegt ein Integritätsproblem vor. </font><font style="vertical-align: inherit;">Ein Zeiger zeigt nach unten auf einen Stapel von Speicheraufrufen, der nicht mehr gültig ist. </font><font style="vertical-align: inherit;">Beim nächsten Aufruf der Funktion wird der angegebene Speicher neu formatiert und neu initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier beginnt die Escape-Analyse, die Integrität aufrechtzuerhalten. </font><font style="vertical-align: inherit;">In diesem Fall stellt der Compiler fest, dass es nicht sicher ist, einen Wert vom Typ user innerhalb des Stapelrahmens createUserV2 zu erstellen. Stattdessen wird ein Wert auf dem Heap erstellt. </font><font style="vertical-align: inherit;">Dies geschieht sofort während des Baus der Linie 28.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesbarkeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie aus einem früheren Beitrag erfahren haben, hat eine Funktion über den Frame-Zeiger direkten Zugriff auf den Speicher innerhalb ihres Frames. Für den Zugriff auf den Speicher außerhalb des Frames ist jedoch ein indirekter Zugriff erforderlich. Dies bedeutet, dass der Zugriff auf Werte, die in den Heap fallen, auch indirekt über einen Zeiger erfolgen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran, wie der createUserV2-Code aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Syntax verbirgt, was in diesem Code wirklich passiert. Die in Zeile 28 deklarierte Variable u repräsentiert einen Wert vom Typ user. Die Konstruktion in Go sagt Ihnen nicht genau, wo der Wert im Speicher gespeichert ist. Vor der return-Anweisung in Zeile 34 wissen Sie also nicht, dass der Wert gehäuft wird. Dies bedeutet, dass u zwar einen Wert vom Typ user darstellt, der Zugriff auf diesen Wert jedoch über einen Zeiger erfolgen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können einen Stapel visualisieren, der nach einem Funktionsaufruf so aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bild 3</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/ya/sv/5uyasv63ozdef8jclixqpv4anx4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable u im Stapelrahmen für createUserV2 repräsentiert den Wert auf dem Heap und nicht auf dem Stapel. </font><font style="vertical-align: inherit;">Dies bedeutet, dass für die Verwendung von u für den Zugriff auf einen Wert der Zugriff auf einen Zeiger erforderlich ist, nicht auf den von der Syntax vorgeschlagenen direkten Zugriff. </font><font style="vertical-align: inherit;">Sie könnten denken, warum nicht sofort einen Zeiger erstellen, da für den Zugriff auf den Wert, den er darstellt, immer noch ein Zeiger verwendet werden muss? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie dies tun, verlieren Sie die Lesbarkeit, die Sie in Ihrem Code nicht verlieren könnten. </font><font style="vertical-align: inherit;">Bewegen Sie sich für eine Sekunde vom Funktionskörper weg und konzentrieren Sie sich nur auf die Rückkehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Worüber spricht diese Rückkehr? </font><font style="vertical-align: inherit;">Er sagt nur, dass eine Kopie von u auf den Aufrufstapel geschoben wird. </font><font style="vertical-align: inherit;">Was sagt Ihnen die Rückkehr in der Zwischenzeit, wenn Sie den Operator &amp; verwenden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank des Operators &amp; return erfahren Sie jetzt, dass Sie den Aufrufstapel gemeinsam nutzen und daher in den Heap gehen. Denken Sie daran, dass Zeiger zusammen verwendet werden sollen und beim Lesen des Codes den Operator &amp; durch den Ausdruck "Freigabe" ersetzen. Es ist sehr leistungsfähig in Bezug auf die Lesbarkeit. Das möchte ich nicht verlieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres Beispiel, bei dem das Erstellen von Werten mithilfe der Zeigersemantik die Lesbarkeit beeinträchtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u *user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> u, err</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dieser Code funktioniert, müssen Sie beim Aufrufen von json.Unmarshal in Zeile 02 einen Zeiger auf eine Zeigervariable übergeben. Ein Aufruf von json.Unmarshal erstellt einen Wert vom Typ user und weist seine Adresse einer Zeigervariablen zu. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/koI8EjpeIx</font></font></a> </i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Was dieser Code sagt: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Erstellen Sie einen Zeiger vom Typ Benutzer mit einem Nullwert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Teilen Sie die Variable u mit der Funktion json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Eine Kopie der Variablen u an den Aufrufer zurückgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht ganz offensichtlich, dass ein Wert vom Typ user, der von der Funktion json.Unmarshal erstellt wurde, an den Aufrufer übergeben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ändert sich die Lesbarkeit, wenn die Semantik von Werten während der Variablendeklaration verwendet wird? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> &amp;u, err</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was dieser Code sagt: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Erstellen Sie einen Wert vom Typ Benutzer mit einem Nullwert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Teilen Sie die Variable u mit der Funktion json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Teilen Sie die Variable u mit dem Aufrufer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles ist sehr klar. </font><font style="vertical-align: inherit;">Zeile 02 teilt den Wert des Typbenutzers im Aufrufstapel in json.Unmarshal auf, und Zeile 03 teilt den Wert des Aufrufstapels an den Anrufer zurück. </font><font style="vertical-align: inherit;">Diese Freigabe bewirkt, dass der Wert auf den Heap verschoben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie beim Erstellen von Werten die Semantik von Werten und nutzen Sie die Lesbarkeit des Operators &amp;, um zu verdeutlichen, wie Werte getrennt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiler-Berichterstellung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die vom Compiler getroffenen Entscheidungen anzuzeigen, können Sie den Compiler bitten, einen Bericht bereitzustellen. </font><font style="vertical-align: inherit;">Alles, was Sie tun müssen, ist, den Schalter -gcflags mit der Option -m zu verwenden, wenn Sie go build aufrufen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich können Sie 4 Ebenen von -m verwenden, aber nach 2 Informationsebenen wird es zu viel. </font><font style="vertical-align: inherit;">Ich werde 2 Ebenen -m verwenden. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10:</font></font><br>
<br>
<pre><code class="bash hljs">$ go build -gcflags <span class="hljs-string">"-m -m"</span><font></font>
./main.go:16: cannot inline createUserV1: marked go:noinline<font></font>
./main.go:27: cannot inline createUserV2: marked go:noinline<font></font>
./main.go:8: cannot inline main: non-leaf <span class="hljs-keyword">function</span><font></font>
./main.go:22: createUserV1 &amp;u does not escape<font></font>
./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape<font></font>
./main.go:12: main &amp;u1 does not escape<font></font>
./main.go:12: main &amp;u2 does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sehen, dass der Compiler Entscheidungen meldet, um den Wert in den Heap zu sichern. </font><font style="vertical-align: inherit;">Was sagt der Compiler? </font><font style="vertical-align: inherit;">Schauen Sie sich zunächst die Funktionen createUserV1 und createUserV2 noch einmal an, um sie im Speicher zu aktualisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }<font></font>
<font></font>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dieser Zeile im Bericht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14:</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:22: createUserV1 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies deutet darauf hin, dass der Aufruf der Funktion println innerhalb der Funktion createUserV1 nicht dazu führt, dass der Benutzertyp in den Heap kopiert wird. Dieser Fall musste überprüft werden, da er in Verbindung mit der Funktion println verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich als Nächstes diese Zeilen im Bericht an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 15:</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Zeilen besagen, dass der Wert des Benutzertyps, der der Variablen u zugeordnet ist, die den benannten Benutzertyp hat und in Zeile 31 erstellt wird, aufgrund der Rückgabe in Zeile 34 in den Heap ausgegeben wird. Die letzte Zeile sagt dasselbe wie zuvor, println call in der Zeile 33 setzt den Benutzertyp nicht zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Lesen dieser Berichte kann verwirrend sein und leicht variieren, je nachdem, ob der Typ der betreffenden Variablen auf einem benannten oder einem wörtlichen Typ basiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ändern Sie die Variable u so, dass sie wie zuvor der Literal-Typ * user anstelle des benannten Typbenutzers ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 16:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie den Bericht erneut aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 17:</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:30: &amp;user literal escapes to heap<font></font>
./main.go:30:     from u (assigned) at ./main.go:28<font></font>
./main.go:30:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bericht besagt nun, dass der Wert des Benutzertyps, auf den die Variable u verweist, die den Literaltyp * user hat und in Zeile 28 erstellt wurde, aufgrund der Rückgabe in Zeile 34 auf dem Heap gespeichert wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines Werts bestimmt nicht, wo er sich befindet. </font><font style="vertical-align: inherit;">Nur wie der Wert aufgeteilt wird, bestimmt, was der Compiler mit diesem Wert macht. </font><font style="vertical-align: inherit;">Jedes Mal, wenn Sie einen Wert im Aufrufstapel freigeben, wird er auf dem Heap gespeichert. </font><font style="vertical-align: inherit;">Es gibt andere Gründe, warum ein Wert aus dem Stapel entkommen kann. </font><font style="vertical-align: inherit;">Ich werde im nächsten Beitrag darüber sprechen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck dieser Beiträge besteht darin, Anleitungen zur Auswahl der Wertesemantik oder Zeigersemantik für einen bestimmten Typ bereitzustellen. </font><font style="vertical-align: inherit;">Jede Semantik ist mit Gewinn und Wert verbunden. </font><font style="vertical-align: inherit;">Die Semantik der Werte speichert die Werte auf dem Stapel, wodurch die Belastung des GC verringert wird. </font><font style="vertical-align: inherit;">Es gibt jedoch verschiedene Kopien desselben Werts, die gespeichert, verfolgt und verwaltet werden müssen. </font><font style="vertical-align: inherit;">Die Zeigersemantik legt Werte auf einen Haufen, was Druck auf den GC ausüben kann. </font><font style="vertical-align: inherit;">Sie sind jedoch effektiv, da nur ein Wert gespeichert, verfolgt und verwaltet werden muss. </font><font style="vertical-align: inherit;">Der entscheidende Punkt ist die korrekte, konsistente und ausgewogene Verwendung jeder Semantik.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de497982/index.html">Funktions- und Prozessansatz für das Management. Wie und was ist zu verwalten?</a></li>
<li><a href="../de497984/index.html">Migration von reCAPTCHA zu hCaptcha in Cloudflare</a></li>
<li><a href="../de497986/index.html">Überwachen des gesamten von einer Webseite verwendeten Speichers: performance.measureMemory ()</a></li>
<li><a href="../de497988/index.html">React Application Performance Profiling</a></li>
<li><a href="../de497990/index.html">PostgreSQL: Entwicklung von Erweiterungen (Funktionen) in C-Sprache</a></li>
<li><a href="../de497996/index.html">Sie wollen die Immunität nicht stärken. Oder die Extreme des menschlichen Körpers</a></li>
<li><a href="../de498000/index.html">Dinge, die ich gerne wissen würde, bevor ich mein eigenes Spiel entwickle</a></li>
<li><a href="../de498002/index.html">Taschenanleitung zum Z3</a></li>
<li><a href="../de498004/index.html">Workstation in einem Docker-Container</a></li>
<li><a href="../de498006/index.html">Wahl eines Patentanwalts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>