<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèæ üë≠ ‚ÑπÔ∏è SwiftUI sur les √©tag√®res: Animation. Partie 1 üë∂üèø üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üìº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, je suis tomb√© sur un nouvel article dans lequel les gars essayaient de reproduire un concept int√©ressant en utilisant SwiftUI. Voici ce qu'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI sur les √©tag√®res: Animation. Partie 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R√©cemment, je suis tomb√© sur un nouvel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans lequel les gars essayaient de reproduire un concept int√©ressant en utilisant SwiftUI. Voici ce qu'ils ont fait: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
j'ai √©tudi√© leur code avec int√©r√™t, mais j'ai v√©cu une certaine frustration. Non, pas dans le sens o√π ils ont fait quelque chose de mal, pas du tout. Je n'ai tout simplement pas appris de leur code pratiquement rien de nouveau. Leur impl√©mentation concerne plus la combinaison que l'animation. Et j'ai d√©cid√© de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construire mon lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour √©crire mon article sur l'animation dans SwiftUI, en mettant en ≈ìuvre le m√™me concept, mais en utilisant 100% des capacit√©s de l'animation int√©gr√©e, m√™me si elle n'est pas tr√®s efficace. Pour √©tudier - jusqu'√† la fin. Pour exp√©rimenter - donc avec un clin d'≈ìil :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici ce que j'ai obtenu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, pour une divulgation compl√®te du sujet, j'ai d√ª parler en d√©tail des bases m√™mes. Le texte s'est av√©r√© volumineux et, par cons√©quent, je l'ai divis√© en deux articles. Voici la premi√®re partie de celui-ci - plut√¥t, un tutoriel sur l'animation en g√©n√©ral, pas directement li√© √† l'animation arc-en-ciel, dont je parlerai en d√©tail dans le prochain article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, je vais parler des bases, sans lesquelles vous pouvez facilement vous perdre dans des exemples plus complexes. Une grande partie de ce dont je vais parler, sous une forme ou une autre, a d√©j√† √©t√© d√©crite dans des articles en anglais tels que cette s√©rie ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Pour ma part, je me suis concentr√© non pas tant sur l'√©num√©ration des m√©thodes de travail que sur la description exacte de son fonctionnement. </font><font style="vertical-align: inherit;">Et comme toujours, j'ai beaucoup exp√©riment√©, donc je m'empresse de partager les r√©sultats les plus int√©ressants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
avertissement: sous le chat il y a beaucoup d'images et d'animations gif.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet est disponible sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez voir le r√©sultat actuel avec une animation arc-en-ciel dans TransitionRainbowView (), mais je ne me pr√©cipiterais pas √† votre place, mais j'ai attendu le prochain article. </font><font style="vertical-align: inherit;">De plus, lors de sa pr√©paration, je peigne un peu le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous aborderons uniquement les bases et n'affecterons que le contenu du dossier Bases.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'avoue, je n'allais pas √©crire cet article maintenant. J'avais un plan selon lequel un article sur l'animation √©tait cens√© √™tre le troisi√®me, voire le quatri√®me d'affil√©e. Cependant, je n'ai pas pu r√©sister, je voulais vraiment apporter un point de vue alternatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux faire une r√©servation tout de suite. Je ne pense pas que des erreurs aient √©t√© commises dans l'article mentionn√©, ou l'approche utilis√©e dans celui-ci est incorrecte. Pas du tout. Il construit un mod√®le objet du processus (animation) qui, r√©pondant au signal re√ßu, commence √† faire quelque chose. Cependant, pour moi, cet article r√©v√®le tr√®s probablement un travail avec le framework Combine. Oui, ce framework est une partie importante de SwiftUI, mais il s'agit plus d'un style de r√©action en g√©n√©ral que d'animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon option n'est certainement pas plus √©l√©gante, plus rapide et plus facile √† entretenir. Cependant, il r√©v√®le beaucoup mieux ce qui se trouve sous le capot de SwiftUI, et c'√©tait d'ailleurs le but de l'article - de le comprendre en premier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article pr√©c√©dent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par SwiftUI, j'ai commenc√© ma plong√©e dans le monde du d√©veloppement mobile tout de suite avec SwiftUI, en ignorant UIKit. Bien s√ªr, cela a un prix, mais il y a des avantages. Je n'essaie pas de vivre dans un nouveau monast√®re selon l'ancienne charte. Honn√™tement, je ne connais pas encore de chartes, donc je n'ai pas de rejet de la nouvelle. C'est pourquoi, cet article, il me semble, peut √™tre utile non seulement pour les d√©butants, comme moi, mais aussi pour ceux qui √©tudient SwiftUI ayant d√©j√† des ant√©c√©dents en mati√®re de d√©veloppement sur UIKit. Il me semble que beaucoup de gens manquent d'un nouveau regard. Ne faites pas la m√™me chose, essayez d'int√©grer un nouvel outil dans les anciens dessins, mais changez votre vision en fonction de nouvelles possibilit√©s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous 1c-nicks sommes pass√©s par l√† avec des ¬´formes contr√¥l√©es¬ª. C'est une sorte de SwiftUI dans le monde des 1, qui s'est produit il y a plus de 10 ans. En fait, l'analogie est assez pr√©cise, car les formulaires g√©r√©s ne sont qu'une nouvelle fa√ßon de dessiner une interface. Cependant, il a compl√®tement chang√© l'interaction client-serveur de l'application dans son ensemble, et l'image du monde dans l'esprit des d√©veloppeurs en particulier. Ce n‚Äô√©tait pas facile, moi-m√™me je ne voulais pas l‚Äô√©tudier pendant environ 5 ans, car Je pensais que beaucoup des opportunit√©s qui y √©taient ferm√©es √©taient simplement n√©cessaires pour moi. Mais, comme la pratique l'a montr√©, le codage sur les formulaires g√©r√©s est non seulement possible, mais seulement n√©cessaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais n'en parlons plus. </font><font style="vertical-align: inherit;">J'ai obtenu un guide d√©taill√© et ind√©pendant qui n'a pas de r√©f√©rences, ou d'autres liens avec l'article mentionn√© ou le 1er pass√©. </font><font style="vertical-align: inherit;">√âtape par √©tape, nous allons plonger dans les d√©tails, les fonctionnalit√©s, les principes et les limites. </font><font style="vertical-align: inherit;">Aller.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forme anim√©e</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctionnement de l'animation en g√©n√©ral</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, l'id√©e principale de l'animation est la transformation d'un changement particulier et discret en un processus continu. Par exemple, le rayon du cercle √©tait de 100 unit√©s, est devenu 50 unit√©s. Sans animation, le changement se fera instantan√©ment, avec animation - en douceur. Comment √ßa fonctionne? Tr√®s simple. Pour des changements en douceur, nous devons interpoler plusieurs valeurs dans le segment ¬´C'√©tait ... c'est devenu¬ª. Dans le cas du rayon, nous devrons dessiner plusieurs cercles interm√©diaires avec un rayon de 98 unit√©s, 95 unit√©s, 90 unit√©s ... 53 unit√©s et, enfin, 50 unit√©s. SwiftUI peut le faire facilement et naturellement, il suffit d'encapsuler le code qui effectue ce changement dans withAnimation {...}. Cela semble magique ... Jusqu'√† ce que vous vouliez impl√©menter quelque chose d'un peu plus compliqu√© que "bonjour le monde".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons aux exemples. L'objet d'animation le plus simple et le plus compr√©hensible est consid√©r√© comme une animation de formes. La forme (j'appellerai toujours la structure conforme au protocole de forme de forme) dans SwiftUI est une structure avec des param√®tres qui peuvent s'ins√©rer dans ces limites. Ceux. c'est une structure qui a le corps de la fonction (en rect: CGRect) -&gt; Path. Tout ce dont le runtime a besoin pour dessiner ce formulaire est de demander son contour (le r√©sultat de la fonction est un objet de type Path, en fait, c'est une courbe de B√©zier) pour la taille requise (sp√©cifi√©e comme param√®tre de fonction, un rectangle de type CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forme est une structure stock√©e. En l'initialisant, vous stockez dans les param√®tres tout ce dont vous avez besoin pour dessiner son contour. La taille de la s√©lection pour ce formulaire peut changer, alors tout ce qui est n√©cessaire est d'obtenir une nouvelle valeur Path pour la nouvelle trame CGRect, et le tour est jou√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commen√ßons d√©j√† le codage:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc un cercle (Circle ()), dont le rayon peut √™tre modifi√© √† l'aide du curseur. Cela se passe bien, car le curseur nous donne toutes les valeurs interm√©diaires. Cependant, lorsque vous cliquez sur le bouton "d√©finir le rayon par d√©faut", le changement ne se produit pas non plus instantan√©ment, mais selon l'instruction withAnimation (.linear (duration: 1)). Lin√©airement, sans acc√©l√©ration, √©tir√© pendant 1 seconde. Classe! Nous avons ma√Ætris√© l'animation! Nous ne sommes pas d'accord :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que faire si nous voulons impl√©menter notre propre formulaire et animer ses changements? Est-ce difficile de faire √ßa? Allons v√©rifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai fait une copie de Circle comme suit:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rayon du cercle est calcul√© comme la moiti√© de la plus petite de la largeur et de la hauteur de la bordure de la zone d'√©cran qui nous est attribu√©e. </font><font style="vertical-align: inherit;">Si la largeur est sup√©rieure √† la hauteur, nous partons du milieu de la bordure sup√©rieure (note 1), d√©crivons le cercle complet dans le sens des aiguilles d'une montre (note 2) et fermons notre contour √† ce sujet. </font><font style="vertical-align: inherit;">Si la hauteur est sup√©rieure √† la largeur, nous partons du milieu de la bordure droite, nous d√©crivons √©galement le cercle complet dans le sens horaire et fermons le contour.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x ‚Äî  ,  y ‚Äî  . ..        y.   y ‚Äî   .  ,        .  90    , 180  ‚Äî , 270  ‚Äî .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 2</font></font></b>
                        <div class="spoiler_text">   1   ,   ‚Äú ‚Äù  ‚Äú ‚Äù         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifions comment notre nouveau cercle r√©agira aux modifications du bloc withAnimation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hou la la! </font><font style="vertical-align: inherit;">Nous avons appris √† cr√©er nos propres images de forme libre et √† les animer! </font><font style="vertical-align: inherit;">Il en est ainsi? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pas vraiment. </font><font style="vertical-align: inherit;">Tout le travail ici est effectu√© par le modificateur .frame (largeur: self.radius * 2, hauteur: self.radius * 2). </font><font style="vertical-align: inherit;">√Ä l'int√©rieur du bloc withAnimation {...} nous changeons</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une variable, il envoie un signal pour r√©initialiser CustomCircleView () avec une nouvelle valeur de rayon, cette nouvelle valeur tombe dans le modificateur .frame (), et ce modificateur peut d√©j√† animer les changements de param√®tres. Notre formulaire CustomCircle () r√©agit √† cela avec une animation, car cela ne d√©pend pas d'autre chose que de la taille de la zone s√©lectionn√©e. Le changement de zone se produit avec l'animation, (c'est-√†-dire progressivement, interpolant les valeurs interm√©diaires entre elles √©tait-est devenue), donc notre cercle est dessin√© avec la m√™me animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simplifions (ou compliquons encore?) Notre forme un peu. Nous ne calculerons pas le rayon en fonction de la taille de la zone disponible, mais nous transf√©rerons le rayon sous la forme finie, c'est-√†-dire en faire un param√®tre de structure stock√©.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, la magie est irr√©m√©diablement perdue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons exclu le modificateur frame () de notre CustomCircleView (), d√©pla√ßant la responsabilit√© de la taille du cercle sur la forme elle-m√™me, et l'animation a disparu. </font><font style="vertical-align: inherit;">Mais cela n'a pas d'importance; apprendre √† un formulaire √† animer les changements de ses param√®tres n'est pas trop difficile. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez impl√©menter les exigences du protocole Animatable:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">La magie est de retour! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous pouvons dire avec confiance que notre formulaire est vraiment anim√© - il peut refl√©ter les changements de ses param√®tres avec l'animation. </font><font style="vertical-align: inherit;">Nous avons donn√© au syst√®me une fen√™tre o√π il peut entasser les valeurs interpol√©es n√©cessaires √† l'animation. </font><font style="vertical-align: inherit;">S'il existe une telle fen√™tre, les modifications sont anim√©es. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, les modifications ont lieu sans animation, c'est-√†-dire </font><font style="vertical-align: inherit;">imm√©diatement. </font><font style="vertical-align: inherit;">Rien de compliqu√©, non?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment animer des modifications dans une vue</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais allons directement √† View. </font><font style="vertical-align: inherit;">Supposons que nous voulons animer la position d'un √©l√©ment √† l'int√©rieur d'un conteneur. </font><font style="vertical-align: inherit;">Dans notre cas, ce sera un simple rectangle de couleur verte et une largeur de 10 unit√©s. </font><font style="vertical-align: inherit;">Nous animerons sa position horizontale.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe! </font><font style="vertical-align: inherit;">Travaux! </font><font style="vertical-align: inherit;">Maintenant, nous savons tout sur l'animation! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pas vraiment. </font><font style="vertical-align: inherit;">Si vous regardez la console, nous verrons ce qui suit:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calcul de l' </font><font style="vertical-align: inherit;">init BorderView </font><font style="vertical-align: inherit;">: 0,4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Position de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calcul de l' </font><font style="vertical-align: inherit;">init </font><font style="vertical-align: inherit;">BorderView: 0,468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Position de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calcul de l' </font><font style="vertical-align: inherit;">init BorderView </font><font style="vertical-align: inherit;">: 0,0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, chaque modification de la valeur de position √† l'aide du curseur entra√Æne la r√©initialisation de BorderView avec la nouvelle valeur. C'est pourquoi nous voyons un mouvement r√©gulier de la ligne verte apr√®s le curseur, le curseur signale simplement tr√®s souvent un changement dans la variable, et cela ressemble √† une animation, mais ce n'est pas le cas. L'utilisation du curseur est tr√®s pratique lorsque vous d√©boguez une animation. Vous pouvez l'utiliser pour suivre certains √©tats de transition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxi√®mement, nous voyons que la position de calcul est simplement devenue √©gale √† 0, et aucun journal interm√©diaire, comme ce fut le cas avec l'animation correcte du cercle. Pourquoi?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La chose, comme dans l'exemple pr√©c√©dent, est dans le modificateur. </font><font style="vertical-align: inherit;">Cette fois, le modificateur .offset () obtient la nouvelle valeur de retrait, et il anime le changement lui-m√™me. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">en fait, ce n'est pas le changement du param√®tre de position que nous voulions animer, mais le changement horizontal du retrait dans le modificateur .offset () qui en d√©rive. </font><font style="vertical-align: inherit;">Dans ce cas, il s'agit d'un remplacement inoffensif, le r√©sultat est le m√™me. </font><font style="vertical-align: inherit;">Mais depuis qu'ils sont venus, creusons plus profond√©ment. </font><font style="vertical-align: inherit;">Faisons notre propre modificateur, qui recevra la position (de 0 √† 1) √† l'entr√©e, il recevra la taille de la zone disponible et calculera le retrait.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le BorderView d'origine, respectivement, le GeometryReader n'est plus n√©cessaire, ainsi que la fonction de calcul du retrait:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, nous utilisons toujours le modificateur .offset () dans notre modificateur, mais apr√®s cela, nous avons ajout√© le modificateur .animation (nil), qui bloque notre propre animation de d√©calage. </font><font style="vertical-align: inherit;">Je comprends qu'√† ce stade, vous pouvez d√©cider qu'il suffit de retirer ce verrou, mais nous n'irons pas au fond de la v√©rit√©. </font><font style="vertical-align: inherit;">Et la v√©rit√© est que notre astuce avec animatableData pour BorderView ne fonctionne pas. </font><font style="vertical-align: inherit;">En fait, si vous regardez la documentation du protocole </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous remarquerez que l'impl√©mentation de ce protocole n'est prise en charge que pour AnimatableModifier, GeometryEffect et Shape. </font><font style="vertical-align: inherit;">La vue n'en fait pas partie.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bonne approche consiste √† animer les modifications</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche elle-m√™me, lorsque nous demandons √† View d'animer certains changements, √©tait incorrecte. </font><font style="vertical-align: inherit;">Pour View, vous ne pouvez pas utiliser la m√™me approche que pour les formulaires. </font><font style="vertical-align: inherit;">Au lieu de cela, l'animation doit √™tre int√©gr√©e √† chaque modificateur. </font><font style="vertical-align: inherit;">La plupart des modificateurs int√©gr√©s prennent d√©j√† en charge l'animation pr√™te √† l'emploi. </font><font style="vertical-align: inherit;">Si vous souhaitez une animation pour vos propres modificateurs, vous pouvez utiliser le protocole AnimatableModifier au lieu de ViewModifier. </font><font style="vertical-align: inherit;">Et l√†, vous pouvez impl√©menter la m√™me chose que lors de l'animation des changements de forme, comme nous l'avons fait ci-dessus.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, tout va bien. </font><font style="vertical-align: inherit;">Les messages dans la console aident √† comprendre que notre animation fonctionne vraiment et que l'animation (nil) √† l'int√©rieur du modificateur ne la g√™ne pas du tout. </font><font style="vertical-align: inherit;">Mais voyons toujours comment cela fonctionne.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, vous devez comprendre ce qu'est un modificateur.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons une vue. Comme je l'ai dit dans la partie pr√©c√©dente, il s'agit d'une structure avec des param√®tres stock√©s et des instructions d'assemblage. Cette instruction, dans l'ensemble, ne contient pas une s√©quence d'actions, qui est le code habituel que nous √©crivons dans un style non d√©claratif, mais une simple liste. Il r√©pertorie l'autre vue, les modificateurs qui leur sont appliqu√©s et les conteneurs dans lesquels ils sont inclus. Nous ne sommes pas encore int√©ress√©s par les conteneurs, mais parlons plus des modificateurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un modificateur est √† nouveau une structure avec des param√®tres stock√©s et des instructions de traitement View. </font><font style="vertical-align: inherit;">Il s'agit en fait de la m√™me instruction que la vue - nous pouvons utiliser d'autres modificateurs, utiliser des conteneurs (par exemple, j'ai utilis√© le GeometryReader un peu plus haut) et m√™me une autre vue. </font><font style="vertical-align: inherit;">Mais nous n'avons que du contenu entrant, et nous devons en quelque sorte le modifier en utilisant cette instruction. </font><font style="vertical-align: inherit;">Les param√®tres des modificateurs font partie de l'instruction. </font><font style="vertical-align: inherit;">Mais le plus int√©ressant est qu'ils sont stock√©s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans un article pr√©c√©dent, j'ai dit que l'instruction elle-m√™me n'est pas stock√©e, qu'elle est lanc√©e √† chaque fois apr√®s la mise √† jour de la vue. </font><font style="vertical-align: inherit;">Tout est ainsi, mais il y a une nuance. </font><font style="vertical-align: inherit;">√Ä la suite du travail de cette instruction, nous n'avons pas tout √† fait une image, comme je l'ai dit plus t√¥t - c'√©tait une simplification. </font><font style="vertical-align: inherit;">Les modificateurs ne disparaissent pas apr√®s l'ex√©cution de cette instruction. </font><font style="vertical-align: inherit;">Ils le restent tant que la vue parent existe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques analogies primitives</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment d√©cririons-nous un tableau dans un style d√©claratif? </font><font style="vertical-align: inherit;">Eh bien, nous √©num√©rons 4 pieds et un comptoir. </font><font style="vertical-align: inherit;">Ils les combineraient dans une sorte de conteneur, et avec l'aide de certains modificateurs, ils prescriraient comment ils sont attach√©s les uns aux autres. </font><font style="vertical-align: inherit;">Par exemple, chaque pied indiquerait l'orientation par rapport au plan de travail et la position - quel pied est √©pingl√© √† quel coin. </font><font style="vertical-align: inherit;">Oui, nous pouvons jeter les instructions apr√®s l'assemblage, mais les clous resteront dans le tableau. </font><font style="vertical-align: inherit;">Les modificateurs aussi. </font><font style="vertical-align: inherit;">A la sortie de la fonction body, nous n'avons pas tout √† fait de tableau. </font><font style="vertical-align: inherit;">En utilisant le corps, nous cr√©ons des √©l√©ments de table (vue) et des attaches (modificateurs), et nous mettons tout cela dans des tiroirs. </font><font style="vertical-align: inherit;">La table elle-m√™me est assembl√©e par un robot. </font><font style="vertical-align: inherit;">Quelles fixations vous mettez dans une bo√Æte √† chaque jambe, vous obtiendrez une telle table.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction .modifier (BorderPosition (position: position)), avec laquelle nous avons transform√© la structure BorderPosition en modificateur, ne met qu'une vis suppl√©mentaire dans le tiroir sur le pied de table. La structure BorderPosition est cette vis. Le rendu, au moment du rendu, prend cette case, en retire une jambe (Rectangle () dans notre cas), et obtient s√©quentiellement tous les modificateurs de la liste, avec les valeurs stock√©es en eux. La fonction corporelle de chaque modificateur est une instruction sur la fa√ßon de visser une jambe sur un dessus de table avec cette vis, et la structure elle-m√™me avec des propri√©t√©s stock√©es, c'est cette vis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi est-il important de comprendre cela dans le contexte de l'animation? Parce que l'animation vous permet de modifier les param√®tres d'un modificateur sans affecter les autres, puis de restituer l'image. Si vous faites de m√™me en changeant certains</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tres - cela entra√Ænera la r√©initialisation de la vue imbriqu√©e, des structures de modificateurs, etc., tout au long de la cha√Æne. Mais l'animation ne l'est pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, lorsque nous changeons la valeur de la position lorsque nous appuyons sur un bouton, cela change. Jusqu'au bout. Aucun √©tat interm√©diaire n'est stock√© dans la variable elle-m√™me, ce qui ne peut pas √™tre dit au sujet du modificateur. Pour chaque nouvelle image, les valeurs des param√®tres du modificateur changent en fonction de la progression de l'animation en cours. Si l'animation dure 1 seconde, puis tous les 1/60 de seconde (l'iphone affiche exactement ce nombre d'images par seconde), la valeur animatableData √† l'int√©rieur du modificateur changera, puis elle sera lue par le rendu pour le rendu, apr√®s quoi, apr√®s encore 1/60 de seconde, ce sera chang√© √† nouveau, et relu par le rendu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est caract√©ristique, nous obtenons d'abord l'√©tat final de la vue enti√®re, souvenez-vous-en, et ce n'est qu'alors que le m√©canisme d'animation commence √† d√©limiter les valeurs de position interpol√©es dans le modificateur. L'√©tat initial n'est stock√© nulle part. Quelque part dans les entrailles de SwiftUI, seule la diff√©rence entre l'√©tat initial et l'√©tat final est stock√©e. Cette diff√©rence est √† chaque fois multipli√©e par la fraction du temps √©coul√©. C'est ainsi que la valeur interpol√©e est calcul√©e, qui est ensuite remplac√©e par animatableData. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rence = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acier </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- √âtait </font></i><i><font style="vertical-align: inherit;">Valeur actuelle = Acier - Diff√©rence * (1 - Temps √©coul√©) </font></i><i><font style="vertical-align: inherit;">
Temps √©coul√© = Temps depuis StartAnimations / DurationAnimations La</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
valeur actuelle doit √™tre calcul√©e autant de fois que le nombre d'images que nous devons afficher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi le ¬´n'a pas √©t√©¬ª utilis√© explicitement? Le fait est que SwiftUI ne stocke pas l'√©tat initial. Seule la diff√©rence est enregistr√©e: ainsi, en cas d'√©chec, vous pouvez simplement d√©sactiver l'animation et revenir √† l'√©tat actuel de ¬´devenir¬ª. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche vous permet de rendre l'animation r√©versible. Supposons, quelque part au milieu d'une animation, que l'utilisateur ait √† nouveau appuy√© sur un bouton et que nous ayons √† nouveau modifi√© la valeur de la m√™me variable. Dans ce cas, tout ce que nous devons faire pour r√©ussir ce changement est d'utiliser "Current" comme valeur actuelle dans l'animation au moment du nouveau changement, de se souvenir de la nouvelle diff√©rence et de d√©marrer une nouvelle animation bas√©e sur le nouveau "Became" et la nouvelle "Difference" . Oui, en fait, ces transitions d'une animation √† une autre peuvent √™tre un peu plus difficiles √† simuler l'inertie, mais le sens, je pense, est compr√©hensible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est int√©ressant, c'est que l'animation de chaque image demande la valeur actuelle √† l'int√©rieur du modificateur (√† l'aide d'un getter). Ceci, comme vous pouvez le voir dans les enregistrements de service dans le journal, est responsable du statut de ¬´Acier¬ª. Ensuite, en utilisant le setter, nous d√©finissons le nouvel √©tat qui est courant pour cette trame. Apr√®s cela, pour la trame suivante, la valeur actuelle du modificateur est √† nouveau demand√©e - et elle est de nouveau ¬´est devenue¬ª, c'est-√†-dire Valeur finale vers laquelle l'animation se d√©place. Il est probable que des copies des structures de modificateurs soient utilis√©es pour l'animation, et un getter d'une structure (un modificateur r√©el de la vue r√©elle) est utilis√© pour obtenir la valeur "Acier", et un setter d'une autre (un modificateur temporaire utilis√© pour l'animation) est utilis√©. Je n'ai pas trouv√© de moyen de m'en assurer, mais par des indications indirectes, tout ressemble √† √ßa. En tous cas,les modifications au sein de l'animation n'affectent pas la valeur stock√©e de la structure des modificateurs de la vue actuelle. Si vous avez des id√©es sur la fa√ßon de savoir exactement ce qui se passe exactement avec le getter et le setter, √©crivez √† ce sujet dans les commentaires, je mettrai √† jour l'article.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs param√®tres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'√† ce moment, nous n'avions qu'un seul param√®tre pour l'animation. </font><font style="vertical-align: inherit;">La question peut se poser, mais qu'en est-il si plusieurs param√®tres sont pass√©s au modificateur? </font><font style="vertical-align: inherit;">Et si les deux doivent √™tre anim√©s en m√™me temps? </font><font style="vertical-align: inherit;">Voici comment avec le modificateur de cadre (largeur: hauteur :) par exemple. </font><font style="vertical-align: inherit;">Apr√®s tout, nous pouvons changer simultan√©ment la largeur et la hauteur de cette vue, et nous voulons que le changement se produise dans une animation, comment faire? </font><font style="vertical-align: inherit;">Apr√®s tout, le param√®tre AnimatableData en est un, que puis-je lui substituer?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez, Apple n'a qu'une seule exigence pour animatableData. Le type de donn√©es que vous y remplacez doit respecter le protocole VectorArithmetic. Ce protocole n√©cessite que l'objet garantisse les op√©rations arithm√©tiques minimales n√©cessaires pour pouvoir former un segment de deux valeurs et interpoler les points √† l'int√©rieur de ce segment. Les op√©rations n√©cessaires pour cela sont l'addition, la soustraction et la multiplication. La difficult√© est que nous devons effectuer ces op√©rations avec un seul objet qui stocke plusieurs param√®tres. Ceux. nous devons emballer la liste compl√®te de nos param√®tres dans un conteneur qui sera un vecteur. Apple fournit un tel objet hors de la bo√Æte, et nous propose d'utiliser une solution cl√© en main pour les cas pas tr√®s difficiles. Il s'appelle AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Changeons un peu la t√¢che. </font><font style="vertical-align: inherit;">Nous avons besoin d'un nouveau modificateur qui non seulement d√©placera la barre verte, mais changera √©galement sa hauteur. </font><font style="vertical-align: inherit;">Ce seront deux param√®tres modificateurs ind√©pendants. </font><font style="vertical-align: inherit;">Je ne donnerai pas le code complet de toutes les modifications √† effectuer, vous pouvez le voir sur le github dans le fichier SimpleBorderMove. </font><font style="vertical-align: inherit;">Je ne montrerai que le modificateur lui-m√™me:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ajout√© un autre curseur et un bouton pour modifier al√©atoirement les deux param√®tres √† la fois dans la vue parent de SimpleView, mais il n'y a rien d'int√©ressant, donc pour le code complet, bienvenue dans le github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout fonctionne, nous obtenons vraiment un changement coh√©rent dans la paire de param√®tres emball√©s dans le tuple AnimatablePair. </font><font style="vertical-align: inherit;">Pas mal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rien de confus dans cette mise en ≈ìuvre? </font><font style="vertical-align: inherit;">Personnellement, je me suis tendu quand j'ai vu ce design:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai indiqu√© nulle part lequel de ces param√®tres devrait aller en premier et lequel en second. Comment SwiftUI d√©cide quelle valeur mettre en premier et quelle valeur en deuxi√®me? Eh bien, cela ne correspond-il pas aux noms des param√®tres de fonction avec les noms des attributs de structure?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re id√©e √©tait l'ordre des attributs dans les param√®tres de la fonction et leurs types, comme cela arrive avec @EnvironmentObject. L√†, nous mettons simplement les valeurs dans la bo√Æte, sans leur attribuer d'√©tiquette, puis nous les sortons de l√†, √©galement sans indiquer d'√©tiquette. L√†, tapez les sujets, et dans un seul type, l'ordre. Dans quel ordre ils mettent dans la bo√Æte, de la m√™me mani√®re et l'obtiennent. J'ai essay√© un ordre diff√©rent des arguments de la fonction, l'ordre des arguments pour initialiser la structure, l'ordre des attributs de la structure elle-m√™me, me cognais g√©n√©ralement la t√™te contre le mur, mais ne pouvais pas confondre SwiftUI afin qu'il commence √† animer la position avec des valeurs de hauteur et vice versa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puis cela m'est apparu. J'indique moi-m√™me quel param√®tre sera le premier et quel second dans le getter. SwiftUI n'a pas besoin de savoir exactement comment nous initialisons cette structure. Il peut obtenir la valeur animatableData avant le changement, l'obtenir apr√®s le changement, calculer la diff√©rence entre eux et renvoyer la m√™me diff√©rence, mise √† l'√©chelle proportionnellement √† l'intervalle de temps √©coul√©, √† notre configurateur. Il n'a g√©n√©ralement pas besoin de conna√Ætre la valeur elle-m√™me dans AnimatableData. Et si vous ne confondez pas l'ordre des variables sur deux lignes adjacentes, alors tout sera en ordre, quelle que soit la complexit√© de la structure du reste du code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais voyons √ßa. Apr√®s tout, nous pouvons cr√©er notre propre vecteur conteneur (oh, j'adore, cr√©er notre propre impl√©mentation d'objets existants, vous l'avez peut-√™tre remarqu√© dans un article pr√©c√©dent).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous d√©crivons la structure √©l√©mentaire, d√©clarons la prise en charge du protocole VectorArithmetic, ouvrons l'erreur sur le protocole non conforme, cliquons sur fix, et nous obtenons la d√©claration de toutes les fonctions requises et des param√®tres calcul√©s. </font><font style="vertical-align: inherit;">Il ne reste plus qu'√† les remplir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la m√™me mani√®re, nous remplissons notre objet avec les m√©thodes requises pour le protocole AdditiveArithmetic (VectorArithmetic inclut son support).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense pourquoi nous avons besoin de + et - √©videmment. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'√©chelle est une fonction de la mise √† l'√©chelle. </font><font style="vertical-align: inherit;">Nous prenons la diff√©rence ¬´C'√©tait - c'est devenu¬ª et la multiplions par le stade actuel de l'animation (de 0 √† 1). </font><font style="vertical-align: inherit;">"C'est devenu + Diff√©rence * (1 - √âtape)" et il y aura une valeur actuelle que nous devrions supprimer dans animatableData</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z√©ro est probablement n√©cessaire pour initialiser de nouveaux objets dont les valeurs seront utilis√©es pour l'animation. </font><font style="vertical-align: inherit;">L'animation utilise .zero au tout d√©but, mais je n'ai pas pu comprendre exactement comment. </font><font style="vertical-align: inherit;">Cependant, je ne pense pas que ce soit important.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magnitudeSquared est un produit scalaire d'un vecteur donn√© avec lui-m√™me. </font><font style="vertical-align: inherit;">Pour un espace √† deux dimensions, cela signifie la longueur du vecteur au carr√©. </font><font style="vertical-align: inherit;">Ceci est probablement utilis√© pour pouvoir comparer deux objets l'un avec l'autre, non pas par √©l√©ment, mais dans son ensemble. </font><font style="vertical-align: inherit;">Il ne semble pas √™tre utilis√© √† des fins d'animation.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De mani√®re g√©n√©rale, les fonctions ¬´- =¬ª ¬´+ =¬ª sont √©galement incluses dans le support du protocole, mais pour la structure elles peuvent √™tre g√©n√©r√©es automatiquement sous cette forme</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour plus de clart√©, j'ai expos√© toute cette logique sous forme de sch√©ma. </font><font style="vertical-align: inherit;">
L'image est cliquable. </font><font style="vertical-align: inherit;">
Ce que nous obtenons pendant l'animation est surlign√© en rouge - √† chaque tick (1/60 seconde), le temporisateur donne une nouvelle valeur de t, et nous, dans le r√©gleur de notre modificateur, obtenons une nouvelle valeur de animatableData. </font><font style="vertical-align: inherit;">Voil√† comment l'animation fonctionne sous le capot. </font><font style="vertical-align: inherit;">Dans le m√™me temps, il est important de comprendre qu'un modificateur est une structure stock√©e et qu'une copie du modificateur actuel avec un nouvel √©tat actuel est utilis√©e pour afficher l'animation.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi AnimatableData ne peut √™tre qu'une structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a encore un point. Vous ne pouvez pas utiliser des classes en tant qu'objet AnimatableData. Formellement, vous pouvez d√©crire pour une classe toutes les m√©thodes n√©cessaires du protocole correspondant, mais cela ne d√©collera pas, et voici pourquoi. Comme vous le savez, une classe est un type de donn√©es de r√©f√©rence et une structure est un type de donn√©es bas√© sur des valeurs. Lorsque vous cr√©ez une variable bas√©e sur une autre, dans le cas d'une classe, vous copiez un lien vers cet objet et dans le cas d'une structure, vous cr√©ez un nouvel objet bas√© sur les valeurs de l'existant. Voici un petit exemple illustrant cette diff√©rence:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'animation, exactement la m√™me chose se produit. Nous avons un objet AnimatableData repr√©sentant la diff√©rence entre ¬´√©tait¬ª et ¬´est devenu¬ª. Nous devons calculer une partie de cette diff√©rence pour la refl√©ter sur l'√©cran. Pour ce faire, nous devons copier cette diff√©rence et la multiplier par un nombre repr√©sentant l'√©tape actuelle de l'animation. Dans le cas de la structure, cela n'affectera pas la diff√©rence elle-m√™me, mais dans le cas de la classe, ce sera le cas. Le premier cadre que nous dessinons est l'√©tat ¬´√©tait¬ª. Pour ce faire, nous devons calculer Acier + Diff√©rence * √âtape actuelle - Diff√©rence. Dans le cas de la classe, dans la premi√®re image, nous multiplions la diff√©rence par 0, en la mettant √† z√©ro, et toutes les images suivantes sont dessin√©es de sorte que la diff√©rence = 0. l'animation semble √™tre correctement dessin√©e, mais en fait, nous voyons une transition instantan√©e d'un √©tat √† un autre, comme s'il n'y avait pas d'animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez probablement √©crire une sorte de code de bas niveau qui cr√©e de nouvelles adresses m√©moire pour le r√©sultat de la multiplication - mais pourquoi? </font><font style="vertical-align: inherit;">Vous pouvez simplement utiliser des structures - elles sont cr√©√©es pour cela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui veulent comprendre exactement comment SwiftUI calcule les valeurs interm√©diaires, par quelles op√©rations et √† quel moment, les </font><font style="vertical-align: inherit;">messages sont pouss√©s dans la console </font><font style="vertical-align: inherit;">du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De plus, j'y ai ins√©r√© sleep 0.1 seconde pour simuler des calculs gourmands en ressources √† l'int√©rieur de l'animation, amusez-vous :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation d'√©cran: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'√† ce point, nous avons parl√© d'animer une modification d'une valeur pass√©e √† un modificateur ou √† un formulaire. Ce sont des outils assez puissants. Mais il existe un autre outil qui utilise √©galement l'animation - c'est l'animation de l'apparition et de la disparition de la vue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le dernier article, nous avons parl√© du fait que dans le style d√©claratif de if-else, ce n'est pas du tout le contr√¥le du flux de code lors de l'ex√©cution, mais plut√¥t une vue de Schr√∂dinger. Il s'agit d'un conteneur contenant deux vues en m√™me temps, qui d√©cide lequel afficher en fonction d'une certaine condition. Si vous manquez le bloc else, EmptyView s'affiche √† la place de la deuxi√®me vue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La commutation entre les deux vues peut √©galement √™tre anim√©e. Pour ce faire, utilisez le modificateur .transition ().</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment cela fonctionne. Tout d'abord, √† l'avance, m√™me au stade de l'initialisation de la vue parent, nous avons cr√©√© et plac√© plusieurs vues dans le tableau. Le tableau est de type AnyView, car les √©l√©ments du tableau doivent avoir le m√™me type, sinon ils ne peuvent pas √™tre utilis√©s dans ForEach. Type de r√©sultat opaque de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pr√©c√©dent </font><font style="vertical-align: inherit;">, vous vous souvenez? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous avons prescrit l'√©num√©ration des indices de ce tableau, et pour chacun d'eux, nous affichons la vue par cet index. Nous sommes oblig√©s de le faire et de ne pas it√©rer sur View imm√©diatement, car pour travailler avec ForEach, nous devons attribuer un identifiant interne √† chaque √©l√©ment afin que SwiftUI puisse parcourir le contenu de la collection. Comme alternative, nous devrions cr√©er un identifiant de proxy dans chaque vue, mais pourquoi, si des index peuvent √™tre utilis√©s?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous emballons chaque vue de la collection dans un √©tat et nous la montrons uniquement si elle est active. Cependant, la construction if-else ne peut tout simplement pas exister ici, le compilateur la prend pour le contr√¥le de flux, nous mettons donc tout cela dans le groupe afin que le compilateur comprenne exactement ce que c'est View, ou plus pr√©cis√©ment, les instructions pour que ViewBuilder cr√©e un conteneur ConditionalContent facultatif &lt;View1, View2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, lorsque vous modifiez la valeur de currentViewInd, SwiftUI masque la vue active pr√©c√©dente et affiche la vue actuelle. Comment aimez-vous cette navigation dans l'application?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce qui reste √† faire est de mettre la modification currentViewInd dans l'encapsuleur withAnimation, et le basculement entre les fen√™tres deviendra fluide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez le modificateur .transition, en sp√©cifiant .scale comme param√®tre. </font><font style="vertical-align: inherit;">Cela rendra l'animation de l'apparence et de la disparition de chacune de ces vues diff√©rente - en utilisant la mise √† l'√©chelle plut√¥t que la transparence utilis√©e par d√©faut SwiftUI.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez que la vue appara√Æt et dispara√Æt avec la m√™me animation, seule la disparition d√©file dans l'ordre inverse. </font><font style="vertical-align: inherit;">En fait, nous pouvons attribuer individuellement des animations √† la fois pour l'apparition et la disparition d'une vue. </font><font style="vertical-align: inherit;">Une transition asym√©trique est utilis√©e pour cela.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√™me animation .scale est utilis√©e pour appara√Ætre √† l'√©cran, mais maintenant nous avons sp√©cifi√© les param√®tres pour son utilisation. Il ne commence pas par une taille z√©ro (point), mais par une taille de 0,1 par rapport √† la taille habituelle. Et la position de d√©part de la petite fen√™tre n'est pas au centre de l'√©cran, mais d√©cal√©e vers le bord gauche. De plus, pas une transition n'est responsable de l'apparence, mais deux. Ils peuvent √™tre combin√©s avec .combined (avec :). Dans ce cas, nous avons ajout√© de la transparence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La disparition de la vue est maintenant rendue par une autre animation - balayant le bord droit de l'√©cran. J'ai rendu l'animation un peu plus lente pour que vous puissiez y jeter un ≈ìil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et comme toujours, j'ai h√¢te d'√©crire ma propre version d'animation de transit. C'est encore plus simple que les formulaires anim√©s ou les modificateurs.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, nous √©crivons le modificateur habituel dans lequel nous transf√©rons un certain nombre - l'angle de rotation en degr√©s, ainsi que le point par rapport auquel cette rotation se produit. Ensuite, nous √©tendons le type AnyTransition avec deux fonctions. Cela aurait pu en √™tre un, mais cela me semblait plus pratique. J'ai trouv√© plus facile d'attribuer des noms parlants √† chacun d'eux que de contr√¥ler les degr√©s de rotation directement dans la vue elle-m√™me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type AnyTransition a une m√©thode de modificateur statique, dans laquelle nous transmettons deux modificateurs, et nous obtenons un objet AnyTransition qui d√©crit une transition en douceur d'un √©tat √† un autre. l'identit√© est le modificateur d'√©tat normal de la vue anim√©e. Actif est l'√©tat du d√©but de l'animation pour l'apparence de la vue, ou la fin de l'animation pour la disparition, c'est-√†-dire l'autre extr√©mit√© du segment, les √©tats dans lesquels seront interpol√©s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, spinIn implique que je vais l'utiliser pour faire appara√Ætre la vue de l'ext√©rieur de l'√©cran (ou de l'espace allou√© √† la vue) en tournant dans le sens horaire autour du point sp√©cifi√©. spinOut signifie que la vue dispara√Ætra de la m√™me mani√®re, en tournant autour du m√™me point, √©galement dans le sens des aiguilles d'une montre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon mon id√©e, si vous utilisez le m√™me point pour l'apparition et la disparition de la vue, vous obtenez l'effet de tourner tout l'√©cran autour de ce point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute l'animation est bas√©e sur la m√©canique des modificateurs standard. Si vous √©crivez un modificateur enti√®rement personnalis√©, vous devez impl√©menter les exigences du protocole AnimatableModifier, comme nous l'avons fait avec TwoParameterBorder, ou utiliser les modificateurs int√©gr√©s √† l'int√©rieur qui fournissent leur propre animation par d√©faut. Dans ce cas, je me suis appuy√© sur l'animation .rotationEffect () int√©gr√©e dans mon modificateur SpinTransitionModifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modificateur .transition () pr√©cise uniquement ce qu'il faut consid√©rer comme point de d√©part et d'arriv√©e de l'animation. Si nous devons demander l'√©tat AnimatableData avant de d√©marrer l'animation, pour demander le modificateur AnimatableData de l'√©tat actuel, calculez la diff√©rence, puis animez la diminution de 1 √† 0, puis .transition () modifie simplement les donn√©es d'origine. Vous n'√™tes pas attach√© √† l'√©tat de votre vue, vous n'√™tes pas bas√© sur celui-ci. Vous sp√©cifiez explicitement l'√©tat initial et final vous-m√™me, √† partir d'eux vous obtenez AnimatableData, calculez la diff√©rence et l'animez. Ensuite, √† la fin de l'animation, votre vue actuelle appara√Æt au premier plan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, l'identit√© est un modificateur qui restera appliqu√© √† votre vue √† la fin de l'animation. Sinon, une erreur entra√Ænerait des sauts √† la fin de l'animation d'apparition et le d√©but de l'animation de disparition. Ainsi, la transition peut √™tre consid√©r√©e comme ¬´deux en un¬ª - en appliquant un modificateur sp√©cifique directement √† la vue + la possibilit√© d'animer ses changements lorsque la vue appara√Æt et dispara√Æt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honn√™tement, ce m√©canisme de contr√¥le d'animation me semble tr√®s fort, et je suis un peu d√©sol√© de ne pouvoir l'utiliser pour aucune animation. Je ne refuserais pas une telle cr√©ation d'animation ferm√©e sans fin. Cependant, nous en parlerons dans le prochain article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour mieux voir comment le changement se produit, j'ai remplac√© notre vue de test par des carr√©s √©l√©mentaires, sign√©s avec des nombres et encadr√©s.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pour rendre ce mouvement encore meilleur, j'ai supprim√© .clipped () du modificateur SpinTransitionModifier:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, nous avons maintenant besoin de SpinTransitionModifier dans notre propre modificateur. </font><font style="vertical-align: inherit;">Il a √©t√© cr√©√© uniquement afin de combiner les deux modificateurs, rotationEffect et clipped () en un seul, afin que l'animation de rotation ne d√©passe pas la port√©e s√©lectionn√©e pour notre vue. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser .rotationEffect () directement √† l'int√©rieur de .modifier (), nous n'avons pas besoin d'un interm√©diaire sous la forme de SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand la vue meurt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un point int√©ressant est le cycle de vie de la vue s'il est plac√© dans un if-else. </font><font style="vertical-align: inherit;">La vue, bien qu'initi√©e et enregistr√©e en tant qu'√©l√©ment de tableau, n'est pas stock√©e en m√©moire. </font><font style="vertical-align: inherit;">Tout son</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les param√®tres sont r√©initialis√©s par d√©faut la prochaine fois qu'ils apparaissent √† l'√©cran. C'est presque la m√™me chose que l'initialisation. Malgr√© le fait que la structure objet elle-m√™me existe toujours, le rendu l'a retir√©e de son champ de vision, car elle ne l'est pas. D'une part, cela r√©duit l'utilisation de la m√©moire. Si vous avez un grand nombre de vues complexes dans le tableau, le rendu devra les dessiner toutes en permanence, r√©agissant aux changements - cela affecte n√©gativement les performances. Si je ne me trompe pas, c'√©tait le cas avant la mise √† jour Xcode 11.3. D√©sormais, les vues inactives sont d√©charg√©es de la m√©moire de rendu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un autre c√¥t√©, nous devons d√©placer tout √©tat important au-del√† de la port√©e de ce point de vue. Pour cela, il est pr√©f√©rable d'utiliser les variables @EnvironmentObject.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenant au cycle de vie, il convient √©galement de noter que le modificateur .onAppear {}, s'il est enregistr√© dans cette vue, fonctionne imm√©diatement apr√®s avoir modifi√© la condition et l'apparence de la vue √† l'√©cran, avant m√™me le d√©but de l'animation. </font><font style="vertical-align: inherit;">En cons√©quence, onDisappear {} est d√©clench√© apr√®s la fin de l'animation de disparition. </font><font style="vertical-align: inherit;">Gardez cela √† l'esprit si vous pr√©voyez de les utiliser avec une animation de transition.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et apr√®s? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
phew </font><font style="vertical-align: inherit;">Cela s'est av√©r√© assez volumineux, mais en d√©tail et, je l'esp√®re, intelligible. </font><font style="vertical-align: inherit;">Honn√™tement, j'esp√©rais parler de l'animation arc-en-ciel dans le cadre d'un article, mais je ne pouvais pas m'arr√™ter √† temps avec les d√©tails. </font><font style="vertical-align: inherit;">Alors attendez la suite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie suivante nous attend:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisation des d√©grad√©s: lin√©aire, circulaire et angulaire - tout sera utile</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couleur n'est pas du tout la couleur: choisissez judicieusement.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animation en boucle: comment d√©marrer et comment arr√™ter, et comment arr√™ter imm√©diatement (sans animation, changer l'animation - oui, il y en a une aussi)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animation actuelle du flux: priorit√©s, remplacements, animation diff√©rente pour diff√©rents objets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©tails sur les timings d'animation: nous allons conduire des timings √† la fois dans la queue et dans la crini√®re, jusqu'√† notre propre impl√©mentation de timingCurve (oh, gardez-moi sept :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment trouver le moment actuel de l'animation jou√©e</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si SwiftUI ne suffit pas</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais parler de tout cela en d√©tail en utilisant l'exemple de la cr√©ation d'une animation arc-en-ciel, comme dans l'image:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne suis pas all√© par la voie facile, mais j'ai rassembl√© tous les r√¢teaux que j'ai pu atteindre, incarnant cette animation selon les principes d√©crits ci-dessus. </font><font style="vertical-align: inherit;">L'histoire √† ce sujet devrait s'av√©rer tr√®s informative et riche en astuces et en toutes sortes de hacks, sur lesquels il y avait peu de rapports, et qui sera utile √† ceux qui d√©cident de devenir un pionnier de SwiftUI. </font><font style="vertical-align: inherit;">Il appara√Ætra environ dans une semaine ou deux. </font><font style="vertical-align: inherit;">Au fait, vous pouvez vous abonner pour ne rien manquer. </font><font style="vertical-align: inherit;">Mais cela, bien s√ªr, uniquement si le mat√©riel vous semble utile et que la m√©thode de pr√©sentation est approuv√©e. </font><font style="vertical-align: inherit;">Ensuite, votre abonnement aidera √† mettre rapidement de nouveaux articles au sommet, en les amenant t√¥t √† un public plus large. </font><font style="vertical-align: inherit;">Sinon, √©crivez dans les commentaires ce qui ne va pas.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504186/index.html">Paul Graham: Comment √©crire des textes utiles (complet)</a></li>
<li><a href="../fr504188/index.html">Quarantaine, syst√®mes en ligne et science des donn√©es. Qui pense √† la fid√©lisation de la client√®le?</a></li>
<li><a href="../fr504190/index.html">MVCC comme moyen d'assurer l'isolement des transactions</a></li>
<li><a href="../fr504194/index.html">Le r√©sultat d'une enqu√™te aupr√®s des d√©veloppeurs sur Stack Overflow 2020 (+ habraopros)</a></li>
<li><a href="../fr504196/index.html">NFC: Analyse de la technologie de communication en champ proche</a></li>
<li><a href="../fr504204/index.html">Ateliers IBM: Quarkus (Java ultrarapide pour microservices), Jakarta EE et OpenShift</a></li>
<li><a href="../fr504208/index.html">Comment automatiser un centre de services partag√©s</a></li>
<li><a href="../fr504210/index.html">Qu'est-ce que Deno et remplacera-t-il Node.js?</a></li>
<li><a href="../fr504214/index.html">Le d√©veloppement de DATA VAULT et la transition vers BUSINESS DATA VAULT</a></li>
<li><a href="../fr504216/index.html">Quel √¢ge a cette maison. Comment j'ai fait une carte de l'√¢ge des maisons √† Saint-P√©tersbourg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>